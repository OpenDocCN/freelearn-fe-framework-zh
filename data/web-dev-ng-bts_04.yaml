- en: Routing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: The previous chapter was a monster, but it was needed to give you a couple of
    crash courses on two of the technologies you're likely to use, or should definitely
    consider using, in your web development projects (and this is true whether or
    not your project leverages Angular). Additionally, [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml),
    *Bootstrap – Grid Layout and Components*, was also there to help set the stage
    for the rest of the book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章是一个庞然大物，但它是必要的，因为它需要给你提供两种你可能会使用的技术的速成课程，或者应该考虑在你的网页开发项目中使用的技术（无论你的项目是否利用Angular）。另外，第三章《Bootstrap
    - 网格布局和组件》也有助于为本书的其余部分铺平道路。
- en: This chapter is much smaller by comparison, but it marks the true beginning
    of our journey into Angular. Each chapter from this point forward, even [Chapter
    12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml), *Integrating Backend Data Services*,
    where the primary focus is on building backend services in Node and MongoDB, has
    Angular material in it (specifically, how to use Angular's HTTP client and how
    to wrap your code up in an Angular service).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相比，本章要小得多，但它标志着我们进入Angular的真正开端。从这一点开始，每一章，甚至第12章《集成后端数据服务》，其中主要关注在Node和MongoDB中构建后端服务，都包含Angular的内容（具体来说，如何使用Angular的HTTP客户端以及如何将代码封装在Angular服务中）。
- en: One other note about this chapter that I'd like to point out is that most books
    on Angular don't introduce routing before they introduce Angular templates and
    components, which is fine; but we won't be following that approach. Although routing
    and component templates are inextricably linked together, which is the the likely
    reason that most books discuss routing after components, understanding components
    is not at all a prerequisite for understanding routing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章的另一个注意事项是，大多数关于Angular的书籍在介绍Angular模板和组件之前并不介绍路由，这是可以接受的；但我们不会遵循这种方法。尽管路由和组件模板是密不可分的，这也是大多数书籍在介绍组件之后再讨论路由的原因，但理解组件并不是理解路由的先决条件。
- en: More generally, most programming books try and present all the material and
    concepts in advance, and then circle back at a later time to try and implement
    them in some fashion. One of the problems with this approach is that it goes against
    the way our brains work when assimilating and internalizing new information. It
    is usually better to immediately use new information, in small incremental steps.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地说，大多数编程书籍都试图提前呈现所有的材料和概念，然后在以后的某个时候回过头来尝试以某种方式实现它们。这种方法的问题之一是，它违反了我们大脑在吸收和内化新信息时的工作方式。通常最好立即以小的增量步骤使用新信息。
- en: This book focuses on being as practical as possible, as soon as possible, and
    in a way that maximizes the retention and understanding of new material. So, in
    order to accomplish this, we'll be building our example application together throughout
    the book, learning the topics as we need them, and not before. This means that
    we will often implement things that haven't yet been fully explained. They will
    be explained to you as we implement them, or immediately afterward—when your brain
    is primed, and looking for patterns to forment understanding.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的重点是尽可能实用，尽快实现，并以最大程度地保留和理解新材料的方式。因此，为了实现这一点，我们将在整本书中一起构建我们的示例应用程序，学习我们需要的主题，而不是在之前。这意味着我们经常会实现尚未完全解释的内容。它们将在实现它们时向您解释，或者在之后立即解释——当您的大脑处于最佳状态，并寻找模式以促进理解时。
- en: So, don't worry about diving in head first—it's usually the best way. I'm your
    guide and I am with you to all the way to the end of the book.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，不要担心头等跳进去——通常这是最好的方式。我是你的向导，我会一直陪伴你到书的最后。
- en: 'Here is what we''ll be covering together in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将一起学习以下内容：
- en: Defining what routing is, for Angular applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Angular 应用程序定义路由是什么
- en: Creating the shell of our application, as well as its first few components,
    using the CLI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CLI 创建应用程序的外壳以及它的前几个组件
- en: Configuring routing for our application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的应用程序配置路由
- en: Taking a look at route redirection, parameterized routes, and route guards
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究路由重定向、参数化路由和路由守卫
- en: Completing the routing configuration for our application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成我们应用程序的路由配置。
- en: Taking a look at routing strategies
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究路由策略
- en: There's quite a bit to cover (even for a small chapter such as this one), so
    let's get started!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多内容要涵盖（即使是像这样的小章节），所以让我们开始吧！
- en: What is routing in Angular?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Angular 中的路由？
- en: Routing in Angular is simply a set of rules that map a requested URL to a component.
    This tends to confuse people that are coming to Angular from another technology
    that has routing, especially a technology that is not an SPA (that is, a single-page
    application) framework. Let me explain this a bit.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，路由简单地将请求的 URL 映射到一个组件。这往往会让从另一个具有路由的技术（特别是不是单页面应用程序框架的技术）转向 Angular
    的人感到困惑。让我稍微解释一下。
- en: Angular applications only have one page (hence, the term single-page application),
    as we'll see in a moment when we create our Angular application. Angular components
    have templates, which are standard HTML elements that are used to design the layout
    of the structure for presentation. And as we'll see in [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml),
    *Building Angular Components*, they also have styles.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 应用程序只有一个页面（因此，术语单页面应用程序），我们将在创建 Angular 应用程序时看到。Angular 组件有模板，这些模板是用于设计结构和布局的标准
    HTML 元素。正如我们将在第 6 章中看到的 *构建 Angular 组件*，它们也有样式。
- en: As was mentioned in the first chapter of the book, Angular applications can
    be thought of as trees of components. This is to say that components can contain
    other components, and this nesting of components can continue as much as is required
    for your application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如书的第一章中提到的，Angular 应用程序可以被看作是组件树。这意味着组件可以包含其他组件，并且这种组件的嵌套可以根据应用程序的需要继续进行。
- en: 'So, although components have templates (note: some web frameworks refer to
    web pages as templates), Angular''s routing maps URL paths to components, not
    to web pages or templates. When the template of the component that the requested
    URL is rendered (and we''ll see how this happens in just a moment), not only is
    that component''s template rendered, but all nested components'' templates are
    also rendered. The top-level component that is mapped to by Angular''s router
    may contain other child components, which in turn can contain other child components,
    and so forth. This is what is meant by a tree of components.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管组件有模板（注意：一些 web 框架将 web 页面称为模板），Angular 的路由将 URL 路径映射到组件，而不是 web 页面或模板。当请求的
    URL 渲染为组件的模板时（我们马上就会看到这是如何发生的），不仅会渲染该组件的模板，还会渲染所有嵌套组件的模板。由 Angular 路由映射到的顶级组件可能包含其他子组件，这些子组件又可以包含其他子组件，依此类推。这就是组件树的含义。
- en: For the most part, data in Angular applications flow from the parent components
    to their immediate children. It does not flow from the parent component to its
    grandchild component. Moreover, data does not flow upward. It is a unidirectional
    flow—parent to child. I say *for the most part*, because there are techniques
    and libraries that change some of this behavior—for instance, components can talk
    to each other through an intermediary, which we'll look at later on in the book.
    However, by design, and without outside intervention, data flows from parent to
    child.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，Angular应用程序中的数据是从父组件流向其直接子组件的。它不会从父组件流向其孙子组件。此外，数据也不会向上流动。这是一个单向流动-从父级到子级。我说“在大多数情况下”，因为有一些技术和库可以改变部分行为-例如，组件可以通过中介相互通信，我们将在本书后面讨论。但是，按设计，没有外部干预，数据是从父级到子级流动的。
- en: You'll become familiar with all of this as we progress through the book. All
    you have to understand at this point, to understand routing, is that URLs are
    mapped to components instead of to pages, because Angular applications only have
    one page. The only page in Angular apps is the `index.html` page, which is in
    the app directory. In [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml),
    *Building Angular Components*, we'll see how our default component gets loaded
    into the `index.html` page. For now, let's get back to routing.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在本书中的进展，您将熟悉所有这些。您现在唯一需要理解的是，要理解路由，URL被映射到组件而不是页面，因为Angular应用程序只有一个页面。Angular应用程序中唯一的页面是`index.html`页面，位于app目录中。在[第6章]中，我们将看到我们的默认组件如何加载到`index.html`页面中。现在，让我们回到路由。
- en: Creating our application's shell using the CLI
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CLI创建应用程序的外壳
- en: This is where it all starts. We have now reached the point where we are going
    to use the CLI to create our application's starting point, as well as the first
    bunch of components we'll need to connect them to our routing configuration. We've
    looked at how to install the CLI, and we've even created our first Angular application
    together—although our todo application was a tiny one, just to get our feet wet—back
    in [Chapter 1](f1243d74-a120-408f-8181-cb379b457dd1.xhtml), *Quick Start*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是一切的开始。我们现在已经到达了使用CLI创建应用程序的起点以及我们需要连接到路由配置的第一批组件的点。我们已经学习了如何安装CLI，甚至一起创建了我们的第一个Angular应用程序-尽管我们的待办事项应用程序很小，只是为了让我们入门-在[第1章]中。
- en: If you haven't yet installed the CLI, you're definitely going to want to do
    that now. Once you've done that (hopefully, you already have), fire up your CLI,
    and let's begin!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有安装CLI，那么现在肯定要安装了。一旦您完成了这个步骤（希望您已经完成了），启动CLI，让我们开始吧！
- en: The first order of business is to create a directory on your machine where you're
    going to place all your Angular projects. Don't create a directory for our example
    application, because the CLI will do that for you. Simply create a folder on your
    filesystem and navigate to it from your command line (if your OS is Windows),
    or Terminal (if your OS is a Mac or Linux). For brevity, from here on in, I'll
    be referring to it as your Terminal, and the folders as directories.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首要任务是在您的计算机上创建一个目录，您将在其中放置所有的Angular项目。不要为我们的示例应用程序创建一个目录，因为CLI会为您完成这项工作。只需在文件系统上创建一个文件夹，并从命令行（如果您的操作系统是Windows）或终端（如果您的操作系统是Mac或Linux）中导航到该文件夹。为了简洁起见，从现在开始，我将称其为您的终端，文件夹为目录。
- en: 'Next, we''re going to use our CLI to create the skeleton of our application
    (that is, the root directory), and all the accompanying files and sub-directories
    that the CLI creates for us that are needed for an Angular application. Enter
    the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用CLI来创建我们应用程序的骨架（即根目录），以及CLI为我们创建的所有必需的Angular应用程序所需的文件和子目录。输入以下命令：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Note**: This will take about a minute to complete.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：这将需要大约一分钟的时间来完成。'
- en: If you see Project realtycarousel successfully created. as the last line of
    output, you should now have a directory named `realtycarousel` that will contain
    all our application files.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到最后一行输出为Project realtycarousel successfully created.，那么现在你应该有一个名为`realtycarousel`的目录，其中包含我们应用程序的所有文件。
- en: 'The output of the preceding command is displayed in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下截图所示：
- en: '![](assets/b2659de5-4388-4f65-80f5-2b0906a67ef4.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b2659de5-4388-4f65-80f5-2b0906a67ef4.png)'
- en: 'Let''s now test that we can run it. Navigate to your `realtycarousel` directory
    with the `cd` command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试一下是否可以运行它。使用`cd`命令导航到你的`realtycarousel`目录：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, start our Angular application with the CLI''s server command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用CLI的服务器命令启动我们的Angular应用程序：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should see a bunch of lines output to your Terminal. If one of the lines
    is something similar to `*** NG Live Development* Server is listening on localhost:4200,
    open your browser on http://localhost:4200/ **`, and the last line is `webpack:
    Compiled successfully`, then you should open a browser and point it to `http://localhost:4200`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '你应该在终端看到一堆行输出。如果其中一行类似于`*** NG Live Development* Server is listening on localhost:4200,
    open your browser on http://localhost:4200/ **`，并且最后一行是`webpack: Compiled successfully`，那么你应该打开浏览器并将其指向`http://localhost:4200`。'
- en: If you see a page with the Angular logo, this means that everything was set
    up correctly. You now have an empty Angular application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到一个带有Angular标志的页面，这意味着一切都设置正确了。你现在有一个空的Angular应用程序。
- en: You can press *Ctrl* + *C* to stop the CLI's development server.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按下*Ctrl* + *C*来停止CLI的开发服务器。
- en: Next, let's add several components, which we will reference in our routing configuration.
    Again, don't worry about components for now. We will look at them in depth in
    [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml), *Building Angular Components*,
    and [Chapter 7](cd8509d5-4bce-4056-8156-557186df18cd.xhtml), *Templates, Directives,
    and Pipes*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加几个组件，我们将在路由配置中引用它们。同样，现在不要担心组件。我们将在[第6章](acd5e47c-07a7-4954-993d-360134221325.xhtml)
    *构建Angular组件* 和 [第7章](cd8509d5-4bce-4056-8156-557186df18cd.xhtml) *模板、指令和管道* 中深入研究它们。
- en: 'Run the following list of CLI commands, one at a time:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 依次运行以下CLI命令列表：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of the first command is given in the following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令的输出如下截图所示：
- en: '![](assets/07479861-06b6-476d-a513-58f1833149a6.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/07479861-06b6-476d-a513-58f1833149a6.png)'
- en: We should see a similar output when we create all the other components.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建所有其他组件时，我们应该看到类似的输出。
- en: We now have the first set of components that we need. Although their templates
    are empty for now, this will be good enough to enable us to configure routing
    for our application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了我们需要的第一组组件。虽然它们的模板现在是空的，但这已经足够让我们为我们的应用程序配置路由了。
- en: Since we'll be using Bootstrap for a few things in our application, such as
    its navigation bar and its responsive grid, we need to install Bootstrap along
    with its dependencies. In [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml),
    *Bootstrap – Grid Layout and Components*, we simply referenced a few CDN URLs
    in the header of our `index.html` page in order to be able to use Bootstrap. However,
    we will now install Bootstrap differently—we'll be using `npm`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在应用程序中使用Bootstrap进行一些操作，例如其导航栏和响应式网格，我们需要安装Bootstrap以及其依赖项。在[第3章](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml)中，*Bootstrap
    - 网格布局和组件*，我们只是在`index.html`页面的头部引用了一些CDN URL，以便能够使用Bootstrap。但是，我们现在将以不同的方式安装Bootstrap
    - 我们将使用`npm`。
- en: You will need Node.js installed on your system in order to use the **node package
    manager** (**npm**).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在系统上安装Node.js才能使用**node package manager**（**npm**）。
- en: 'To install Bootstrap, jQuery, and Popper, run the following command in your
    Terminal:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Bootstrap、jQuery和Popper，请在终端中运行以下命令：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have installed the libraries, and now it's time to include them in our config
    file so they are available throughout the application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经安装了库，现在是时候在我们的配置文件中包含它们，以便它们在整个应用程序中可用。
- en: 'Open up the `angular.json` file and include the stylesheet and JavaScript files
    in the respective sections, as shown in the following code snippet:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`angular.json`文件，并在相应的部分中包含样式表和JavaScript文件，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The screenshot shows the edited `angular.json` file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕截图显示了编辑后的`angular.json`文件：
- en: '![](assets/5521ee4d-875c-45da-b366-fc395f4e7e01.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5521ee4d-875c-45da-b366-fc395f4e7e01.png)'
- en: All set!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪！
- en: We now have the core files that we need to be able to set up routing for our
    application. We also made sure to install Bootstrap because we're going to create
    our navigation bar for our application in this chapter. Moreover, our navigation
    links will contain special tags that Angular uses for routing, which is another
    reason why we needed to install Bootstrap at this point.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了我们需要为应用程序设置路由的核心文件。我们还确保安装了Bootstrap，因为我们将在本章中为我们的应用程序创建导航栏。此外，我们的导航链接将包含Angular用于路由的特殊标签，这也是我们此时需要安装Bootstrap的另一个原因。
- en: Let's open our project using our IDE (again, it's easiest if you're using Visual
    Studio Code—but you can use whichever IDE you prefer), so we can take a look at
    the project structure. Additionally, in the next section, *Completing our route
    configuration*, we'll be making changes to a couple of files for setting things
    up, so you'll want to have a way to easily open and edit those files.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次使用我们的IDE（最好使用Visual Studio Code，但您可以使用您喜欢的任何IDE）打开我们的项目，这样我们就可以查看项目结构。此外，在下一节“完成我们的路由配置”中，我们将对一些文件进行更改以进行设置，因此您需要一种方便打开和编辑这些文件的方式。
- en: With the project now open in your IDE, navigate to the `app` directory, which
    is located within the `src` directory. As Angular developers, we'll be spending
    the vast majority of our time within the `app` directory. Inside the `app` directory,
    you will find a number of files that all start with *app*. These files make up
    the root component (that is, the app component) in our application, and we're
    going to be examining what each of these files does when we come to [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml),
    *Building Angular Components*, where you will become very familiar with Angular
    components. You will see many subdirectories in the `app` directory—one for each
    component we created just a few moments ago, such as for about, account, home,
    and so on.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在您的IDE中打开项目后，导航到`app`目录，该目录位于`src`目录内。作为Angular开发人员，我们将在`app`目录中度过绝大部分时间。在`app`目录中，您会找到许多以*app*开头的文件。这些文件组成了我们应用程序中的根组件（即应用程序组件），当我们来到[第6章](acd5e47c-07a7-4954-993d-360134221325.xhtml)
    *构建Angular组件*时，我们将会检查这些文件的每个文件的作用，您将会非常熟悉Angular组件。您将在`app`目录中看到许多子目录，每个子目录都是我们刚刚创建的组件，比如about、account、home等。
- en: Remember, the language Angular applications are written in is TypeScript, which
    is what the `.ts` file extension stands for. Let's roll up our sleeves and configure
    routing for our application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Angular应用程序的编写语言是TypeScript，这就是`.ts`文件扩展名的含义。让我们开始为我们的应用程序配置路由。
- en: First things first – basic concepts
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首先要了解的是基本概念
- en: In this section, we will quickly touch base and get an overview of some of the
    basic concepts before we start adding routing to our Angular apps. In the basic
    concepts, we will learn about `Base Href`, `RouterLink`, and `RouterLinkActive`,
    which we will need to implement in our templates while working with Angular routing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将在开始为我们的Angular应用程序添加路由之前，快速了解一些基本概念的概述。在基本概念中，我们将学习`Base Href`、`RouterLink`和`RouterLinkActive`，这些是我们在使用Angular路由时需要在模板中实现的内容。
- en: Base Href
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Base Href
- en: Every Angular application, in order to compose the links inside the app, should
    have `base href` defined at the parent level.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在应用程序内部组合链接，每个Angular应用程序都应该在父级别定义`base href`。
- en: Open the application generated by the Angular CLI, and look inside the `index.html`
    file. We will see the base `href` defined to `/`, which resolves to be the root
    or top-level hierarchy.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 打开由Angular CLI生成的应用程序，并查看`index.html`文件。我们将看到基本`href`定义为`/`，这将解析为根或顶级层次结构。
- en: 'The following screenshot shows the default base `href` configuration, as generated
    by the Angular CLI:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了由Angular CLI生成的默认基本`href`配置：
- en: '![](assets/86a36aa5-3a0b-4b7a-9775-a45df003382d.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/86a36aa5-3a0b-4b7a-9775-a45df003382d.png)'
- en: RouterLink and RouterLinkActive
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RouterLink和RouterLinkActive
- en: 'In [Chapter 7](cd8509d5-4bce-4056-8156-557186df18cd.xhtml), *Templates, Directives,
    and Pipes*, we will learn in detail about components, directives, and templates.
    For now, just understand that, like the anchor element and `href` attribute in
    HTML5, Angular provides a way to bind the links and the URL resource:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](cd8509d5-4bce-4056-8156-557186df18cd.xhtml)中，*模板、指令和管道*，我们将详细了解组件、指令和模板。现在，只需了解，就像HTML5中的锚元素和`href`属性一样，Angular提供了一种绑定链接和URL资源的方式：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we are adding two links. Notice that we have added the
    `routerLink` attribute to the links, which will help us bind the value of `/home`
    and `/listings`, respectively.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们添加了两个链接。请注意，我们已经在链接中添加了`routerLink`属性，这将帮助我们分别绑定`/home`和`/listings`的值。
- en: Also, notice that we have added the `routerLinkActive` attribute and assigned
    the value as `active`. Whenever a user clicks on the link, the Angular router
    will know and make it active. Some call it magic!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们已经添加了`routerLinkActive`属性，并将值分配为`active`。每当用户点击链接时，Angular路由将知道并使其处于活动状态。有些人称之为魔术！
- en: Configuring routes for our application
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的应用程序配置路由
- en: It's time to add Angular routing to our application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候为我们的应用程序添加Angular路由了。
- en: 'We have two options for implementing routing:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种实现路由的选项：
- en: We can use the Angular CLI to add routing during the creation of the project
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用Angular CLI在项目创建期间添加路由
- en: Or we can add Angular routing manually into our applications
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者我们可以手动添加Angular路由到我们的应用程序中
- en: First, let's explore the easy way, using the Angular CLI to add routing.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们探索简单的方法，使用Angular CLI添加路由。
- en: The Angular CLI provides us with an easy way to add routing capabilities to
    our Angular application. While generating a new project, the Angular CLI will
    prompt us to select if we want to add routing to our app.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI为我们提供了一种简单的方法来为我们的Angular应用程序添加路由功能。在生成新项目时，Angular CLI将提示我们选择是否要为我们的应用程序添加路由。
- en: 'The following screenshot shows the option displayed in the CLI for adding Angular
    routing:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在CLI中显示添加Angular路由选项：
- en: '![](assets/e1b33a23-33ed-45e9-a4e6-5f78ba72bd9d.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e1b33a23-33ed-45e9-a4e6-5f78ba72bd9d.png)'
- en: When we choose the option to add routing in our app, we are using the Angular
    CLI to create files, import the required modules, and create the route's rulesets.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们选择在我们的应用程序中添加路由选项时，我们使用Angular CLI创建文件，导入所需的模块，并创建路由规则集。
- en: Now, let's add routing to our project manually. Let's see how we can configure
    routing in our app.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们手动为我们的项目添加路由。让我们看看如何在我们的应用程序中配置路由。
- en: 'In order to configure our routing, we need to follow these steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置我们的路由，我们需要按照以下步骤进行：
- en: Open the `app.module.ts` file
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.module.ts`文件
- en: 'Add the following `import` statement to the `import` section at the top of
    the file:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件顶部的`import`部分添加以下`import`语句：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`RouterModule` contains the router service and router directives.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouterModule`包含路由服务和路由指令。'
- en: The `Routes` module defiles the routes type (remember, TypeScript adds variable
    typing to JavaScript).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Routes`模块定义了路由类型（记住，TypeScript为JavaScript添加了变量类型）。'
- en: 'Write a few routes and ruleset in the `app-routing.module.ts` file:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app-routing.module.ts`文件中编写一些路由和规则集：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This code only shows three mappings:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码只显示了三个映射：
- en: Mapping for `HomeComponent`
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HomeComponent`的映射'
- en: Mapping for a redirection
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重定向的映射
- en: Mapping for a wildcard, or *catch-all*, the URL request
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通配符或*catch-all*的URL请求的映射
- en: The first mapping object is the simplest case. A URL path (that is, the part
    of the URL that comes after the domain name) maps to one component, without any
    parameters (note routes can be parameterized, and we'll look at that in the *Parameterized
    routes* section shortly). What this route does is instruct Angular to render the `HomeComponent` template
    when the path in the requested URL ends in the home.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个映射对象是最简单的情况。URL路径（即域名后面的部分）映射到一个组件，没有任何参数（注意路由可以被参数化，我们很快会在*参数化路由*部分看到）。这个路由的作用是指示Angular在请求的URL路径以home结尾时呈现`HomeComponent`模板。
- en: The second mapping object is an example of how to get one path to redirect to
    another URL, and, thus, route. This is typically referred to as route redirection.
    In our case, the path is an empty string, which means that when only the domain
    name is entered into the browser location bar, Angular's routing mechanism will
    redirect the request (that is, change the path in the URL) to `/home`. And since
    there is a mapping object that deals with `/home`, it will get triggered, thus
    rendering the `HomeComponent` template. This is a common practice for websites—entering
    just the domain name typically brings the user to the home or index web page.
    In our case, since we're building an SPA (which is what Angular web applications
    are), there is no home page, but rather a home component, meaning that the home
    component's template is rendered to simulate a home page.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个映射对象是如何将一个路径重定向到另一个URL和路由的示例。这通常被称为路由重定向。在我们的情况下，路径是一个空字符串，这意味着当仅在浏览器位置栏中输入域名时，Angular的路由机制将重定向请求（即更改URL中的路径）到`/home`。由于有一个处理`/home`的映射对象，它将被触发，从而呈现`HomeComponent`模板。这是网站的常见做法——输入域名通常会将用户带到主页或索引网页。在我们的情况下，由于我们正在构建SPA（这就是Angular
    web应用程序），没有主页，而是一个主页组件，这意味着主页组件的模板被呈现以模拟主页。
- en: The third mapping object is an example of a wildcard match and is placed as
    the last mapping object. When Angular's routing mechanism parses the requested
    URL, it compares it to the mapping objects from the top down. If the URL does
    not match any of the mapping rulesets, this last mapping object is triggered.
    What this means for our application is that, if there are no matches, the `PageNotFoundComponent` template
    will be rendered.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个映射对象是通配符匹配的一个示例，并且放置在最后一个映射对象。当Angular的路由机制解析请求的URL时，它会从上到下将其与映射对象进行比较。如果URL不匹配任何映射规则集，将触发最后一个映射对象。对于我们的应用程序来说，这意味着如果没有匹配项，将呈现`PageNotFoundComponent`模板。
- en: 'Now it''s time to import our `appRoutes`; this is how we tell Angular about
    our routes. `appRoutes` is a constant that holds our route mapping, so let''s
    create that next:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候导入我们的`appRoutes`了；这是我们告诉Angular我们的路由的方式。`appRoutes`是一个包含我们路由映射的常量，让我们接着创建它：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Finally, we will need to import the `app-routing.module.ts` file into `app.module.ts`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将`app-routing.module.ts`文件导入到`app.module.ts`中。
- en: The complete code listing of the `app-routing.module.ts` file is in the *Completing
    our route configuration* section later in this chapter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`app-routing.module.ts`文件的完整代码清单在本章后面的*完成我们的路由配置*部分中。'
- en: We have added the routes directly into `app.module.ts` file. It's a good practice
    to always separate out the route config file separately. Even better, always use
    the Angular CLI to add routing directly when you create the project.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将路由直接添加到`app.module.ts`文件中。将路由配置文件分离出来是一个很好的做法。更好的做法是，在创建项目时始终使用Angular
    CLI直接添加路由。
- en: That's it; we have implemented routing in our project. In the next section,
    we will learn in detail about adding more routes, adding parameters to our routes,
    and creating child routes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样；我们已经在我们的项目中实现了路由。在下一节中，我们将详细了解如何添加更多路由，向我们的路由添加参数，并创建子路由。
- en: Parameterized routes
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数化路由
- en: 'Parameterized routes are routes that have a variable value as part of the URL
    path. For instance, a common example of this is when we reference something by
    its ID, as in the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化路由是具有变量值作为URL路径一部分的路由。例如，一个常见的例子是当我们通过ID引用某些内容时，如下所示：
- en: '`/listing/23` (shows property #23 in our realty site)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/listing/23`（在我们的房地产网站上显示属性＃23）'
- en: '`/listing/55` (shows property #55 in our realty site)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/listing/55`（在我们的房地产网站上显示属性＃55）'
- en: '`/listing/721` (shows property #721 in our realty site)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/listing/721`（在我们的房地产网站上显示属性＃721）'
- en: Clearly, having to configure potentially hundreds of routes would not only be
    tedious, inefficient, and error-prone, but the maintenance of these routes (that
    is, removing routes and adding new ones as the inventory of property listings
    changed) would be troublesome.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，必须配置数百个路由不仅会很繁琐、低效和容易出错，而且这些路由的维护（即删除路由和添加新路由，因为属性列表的库存发生了变化）将会很麻烦。
- en: Fortunately, Angular allows for parameterized routes, which solve issues such
    as these.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Angular允许参数化路由，可以解决这些问题。
- en: 'Take a look at the updated routes in the following code snippet:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码片段中更新的路由：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you look carefully, in the preceding routes we have added one more route,
    which captures the `id` of the listing, and we are also mapping it to the `ListingDetailsComponent `component.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看，在前面的路由中，我们添加了一个捕获列表`id`的路由，并且我们还将其映射到`ListingDetailsComponent`组件。
- en: In other words, we can also say that we have created a generic template for
    listings and, based on the dynamic value passed during runtime, the respective
    data will be displayed by the component.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们还可以说我们已经为列表创建了一个通用模板，并且根据运行时传递的动态值，组件将显示相应的数据。
- en: That was easy. What if we have a more complex scenario that involves creating
    child routes? Read on.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 那很容易。如果我们有一个涉及创建子路由的更复杂的场景呢？继续阅读。
- en: Child routes
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子路由
- en: The routes we have created so far are very easy and straightforward use cases.
    In complex applications, we will need to use deep linking, which refers to hunting
    down a link into many levels under.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们创建的路由都是非常简单和直接的用例。在复杂的应用程序中，我们将需要使用深度链接，这指的是在许多级别下追踪链接。
- en: 'Let''s take a look at some examples:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些例子：
- en: '`/home/listings` (shows listings inside home)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/home/listings`（显示家中的列表）'
- en: '`/listing/55/details` (shows the details of listing #55)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/listing/55/details`（显示列表＃55的详细信息）'
- en: '`/listing/721/facilities` (shows the facilities of listing #721)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/listing/721/facilities`（显示列表＃721的设施）'
- en: That's where child routes can be very handy for us to use.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是子路由对我们非常有用的地方。
- en: 'In the following example, we are creating a child route inside the home route
    path:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们在home路由路径内创建了一个子路由：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we are defining `children` for the *home* path and, again,
    we are specifying the `path` and `component`, which will correspond to the child
    route path.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们为*home*路径定义了`children`，再次指定了`path`和`component`，这将对应于子路由路径。
- en: OK, fine. This is good stuff.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，很好。这是好东西。
- en: What if we want to add some validation before a user can access a particular
    route? like a bouncer outside a club? That bouncer is called a route guard.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在用户访问特定路由之前添加一些验证呢？就像俱乐部外面的保镖一样？那个保镖就叫做路由守卫。
- en: Route guards
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由守卫
- en: As in most web applications, there are resources (that is, pages/component templates)
    that are accessible to everyone (such as the **Welcome page**, **Pricing page**,
    **About Us** page, and other informational pages), and there are other resources
    that are only meant to be accessed by authorized users (such as a dashboard page
    and an account page). That's where route guards come in, which are Angular's way
    to prevent unauthorized users from accessing protected parts of our application.
    When someone tries to access a URL that is reserved for authorized users, he will
    typically be redirected to the public home page of the application.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数Web应用程序一样，有一些资源（即页面/组件模板）是每个人都可以访问的（例如**欢迎页面**、**定价页面**、**关于我们**页面和其他信息页面），还有一些资源只能被授权用户访问（例如仪表板页面和帐户页面）。这就是路由守卫的作用，它是Angular防止未经授权用户访问应用程序受保护部分的方式。当有人尝试访问保留给授权用户的URL时，他通常会被重定向到应用程序的公共主页。
- en: In traditional web applications, the checks and validations are implemented
    in the server-side code and there is practically no option to validate whether
    the user can access the page at the client side. But using the Angular route guard,
    we can implement the checks at the client side without even hitting the backend
    services.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的Web应用程序中，检查和验证是在服务器端代码中实现的，实际上没有选项可以在客户端验证用户是否可以访问页面。但是使用Angular路由守卫，我们可以在客户端实现检查，甚至不需要访问后端服务。
- en: 'The following are the various types of guards available that we can use in
    our applications to enhance security for authorization:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们可以在应用程序中使用的各种类型的守卫，以增强授权安全性的各种类型的守卫：
- en: '`CanActivate`: Helps to check whether the route can be activated or not'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CanActivate`：帮助检查路由是否可以被激活'
- en: '`CanActivateChild`: Helps to check whether the route can access child routes
    or not'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CanActivateChild`：帮助检查路由是否可以访问子路由'
- en: '`CanDeactivate`: Helps to check whether the route can be deactivated or not'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CanDeactivate`：帮助检查路由是否可以被停用'
- en: '`Resolve`: Helps to retrieve route data before activation of any route'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Resolve`：帮助在激活任何路由之前检索路由数据'
- en: '`CanLoad`: Verifies whether the user can activate the module that is being
    lazy loaded'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CanLoad`：验证用户是否可以激活正在进行懒加载的模块'
- en: And before we jump into our hands-on exercise, I want to give you a quick overview
    of Angular route guards, such as where to use them, how to use them, what's the
    return type, and so on. Route guards are always injected as a service (that is,
    we have `@injectable` and we will need to inject it). The guards always return
    a Boolean value, `true` or `false`. We can make our route guards return the observables
    or promises, which internally get resolved into a Boolean value.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实际操作之前，我想给你快速概述一下Angular路由守卫，比如在哪里使用它们，如何使用它们，返回类型是什么，等等。路由守卫总是作为服务注入的（即，我们有`@injectable`并且需要注入它）。守卫总是返回一个布尔值，`true`或`false`。我们可以让我们的路由守卫返回可观察对象或承诺，内部将其解析为布尔值。
- en: We will continue to work on and expand the example we have created in the previous
    section. We are going to add a new component and call it **CRUD**. As a user,
    when you try to access the `crud` route, we will check when the route returns
    `true`. We will allow the user to navigate and see the template; otherwise, the
    application will throw an error prompt.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续在上一节中创建的示例上继续工作和扩展。我们将添加一个新组件并将其命名为**CRUD**。作为用户，当您尝试访问`crud`路由时，我们将检查路由返回`true`时。我们将允许用户导航并查看模板；否则，应用程序将抛出错误提示。
- en: 'Let''s dig right into the code to implement route guards. Just as we learned
    how to generate a component or a service, we can use the `ng` command and generate
    a route guard. In the Terminal, run the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入代码，实现路由守卫。就像我们学习如何生成组件或服务一样，我们可以使用`ng`命令生成路由守卫。在终端中运行以下命令：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We have just generated a new route guard named `activateAdmin`. The output
    of the preceding command is displayed here:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚生成了一个名为`activateAdmin`的新路由守卫。上述命令的输出显示在这里：
- en: '![](assets/12833ce7-fa3e-456a-824e-e926a9b69796.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/12833ce7-fa3e-456a-824e-e926a9b69796.png)'
- en: 'Let''s take a look at the files generated by the Angular CLI. Open the `activate-admin.guard.ts`
    file in the editor. Take a look at the default code generated in the file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Angular CLI生成的文件。在编辑器中打开`activate-admin.guard.ts`文件。看一下文件中生成的默认代码：
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first few lines are just importing the required `CanActivate`, `ActivatedRouteSnapShot`,
    and `RouterStateSnapshot` modules from the Angular router. Next, we know that
    since route guards are injectable, by using the `@injectable`
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 前几行只是从Angular路由器中导入所需的`CanActivate`、`ActivatedRouteSnapShot`和`RouterStateSnapshot`模块。接下来，我们知道由于路由守卫是可注入的，通过使用`@injectable`
- en: decorator, we are informing Angular to inject it inside the root. And we are
    creating a class, `ActivatedAdminGuard`, that has a method already created inside
    it named `canActivate`. Note that this method has to return a Boolean value, either
    `true` or `false`. We have created our route guard, so now let's create a route
    now in our `app-routing.module.ts` file.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器，我们正在告知Angular将其注入到根内。我们正在创建一个名为`ActivatedAdminGuard`的类，其中已经创建了一个名为`canActivate`的方法。请注意，该方法必须返回一个布尔值，要么是`true`要么是`false`。我们已经创建了我们的路由守卫，现在让我们在`app-routing.module.ts`文件中创建一个路由。
- en: 'Take a look at the updated code of the `app-routing.module.ts` file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`app-routing.module.ts`文件的更新代码：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that in the routes, we have added the `canActivate` interface and, for
    our `crud` path, when we try to launch the `crud` route, since the `canActivate`
    method is returning `true`, the user will be able to see the component template.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在路由中，我们已经添加了`canActivate`接口，并且对于我们的`crud`路径，当我们尝试启动`crud`路由时，由于`canActivate`方法返回`true`，用户将能够看到组件模板。
- en: Now, go ahead and set the value to `false` and find out what happens.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，继续将值设置为`false`，看看会发生什么。
- en: If you see the application's routing go back to `base href`, don't be surprised.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到应用程序的路由返回到`base href`，不要感到惊讶。
- en: Completing our route configuration
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成我们的路由配置
- en: As promised in previous sections, I will share the entire source code of `AppModule`,
    including the route configurations. The following code may look lengthy or scary,
    but trust me, it's actually very simple and straightforward.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几节所承诺的，我将分享整个`AppModule`的源代码，包括路由配置。以下代码可能看起来很长或令人害怕，但相信我，它实际上非常简单和直接。
- en: During the course of learning this chapter, we have generated many components
    and created their route paths. We are just importing the components and updating `appRoutes`
    with their paths. That's it. I promise.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习本章的过程中，我们生成了许多组件并创建了它们的路由路径。我们只是导入这些组件并用它们的路径更新`appRoutes`。就是这样。我保证。
- en: 'Here is the complete listing of the `app.module.ts` file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`app.module.ts`文件的完整清单：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We have just created our routes, but we will need to update our template file
    by creating a few links that will have the path to the aforementioned-defined
    routes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了我们的路由，但我们需要通过创建一些链接来更新我们的模板文件，这些链接将具有前面定义的路由的路径。
- en: One thing that's most important in any application is a well-designed menu,
    which helps guide users and adds to a good user experience.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序中最重要的一点就是一个设计良好的菜单，它有助于引导用户并增加良好的用户体验。
- en: Using the Bootstrap `nav` component, we will design a menu for our application
    in the next section.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Bootstrap `nav`组件，我们将在下一节为我们的应用程序设计一个菜单。
- en: Bootstrap navigation bar and router links directives
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bootstrap导航栏和路由链接指令
- en: Just before we cover a couple of routing strategies to wrap up this chapter,
    let's circle back and create our Bootstrap navigation bar for our application.
    If you recall from the previous chapter, [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml), *Bootstrap –
    Grid Layout and Components*, I had mentioned that we'll be covering the Bootstrap
    navigation component in this chapter. The reason for this is that we're going
    to be tying our navigation bar to our routing by using routing directives as the
    menu links, and so the best place to cover that is in this chapter, since it falls
    into the domain of routing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，让我们回顾一下并为我们的应用程序创建Bootstrap导航栏。如果你还记得上一章，[第3章](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml)，*Bootstrap
    - 网格布局和组件*，我曾提到我们将在本章中涵盖Bootstrap导航组件。之所以这样做是因为我们将使用路由指令将我们的导航栏与我们的路由绑定在一起，所以最好的地方就是在本章中进行覆盖，因为它属于路由的范畴。
- en: In the previous section, I gave you homework to enter the route path URL manually
    in the browser bar to see the routes working, in this section, we will add all
    the route URLs to the Bootstrap `navbar` component, so that the user can just
    click and navigate instead of typing manually.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我让你手动在浏览器栏中输入路由路径URL以查看路由是否正常工作，本节中，我们将把所有路由URL添加到Bootstrap `navbar`组件中，这样用户就可以直接点击导航，而不是手动输入。
- en: At the starting of the chapter, we briefly touched upon `routerLink` and `routerLinkActive`.
    Now it's time to see them in action.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们简要提到了`routerLink`和`routerLinkActive`。现在是时候看到它们的实际效果了。
- en: Let's take a look at the `app.component.html` file, which is the template of
    our app component. If you are familiar with the notion of master pages in ASP.NET,
    or a layout page in Rails, then you can consider the app component template as
    the equivalent for Angular applications. This is because the app component is
    the top-level component in the tree of components that will form our application.
    The reason I brought up the notion of a master layout is that whatever HTML is
    inserted into it is preserved by the server by it rendering the called page within
    the layout page. While this is not what happens in Angular, since it's not a server-side
    technology, it does hold true in concept.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`app.component.html`文件，这是我们应用程序组件的模板。如果你熟悉ASP.NET中的主页面的概念，或者Rails中的布局页面，那么你可以将应用程序组件模板视为Angular应用程序的等价物。这是因为应用程序组件是将形成我们的应用程序的组件树中的顶级组件。我提出主布局的概念的原因是，无论HTML被插入到其中，服务器都会通过在布局页面中呈现调用页面来保留它。虽然这在Angular中并不是发生的事情，因为它不是服务器端技术，但在概念上是正确的。
- en: What I mean by this is that whatever HTML we insert into the app component's
    template, it is generally still visible when other components are rendered within
    it. This makes the app component template a perfect place to hold our navigation
    bar, since it'll always be visible regardless of what component template is selected
    to be rendered by our routing rulesets for a given URL that is requested by our
    users.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我的意思是，无论我们将什么HTML插入到应用程序组件的模板中，当其他组件在其中呈现时，它通常仍然可见。这使得应用程序组件模板成为保存我们的导航栏的理想位置，因为无论选择哪个组件模板来由我们的路由规则集呈现给用户请求的给定URL，它都将始终可见。
- en: 'Here is the code listing for our `app.component.html` file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`app.component.html`文件的代码清单：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Take a deep breath, and let''s analyze the preceding lines of code. We are
    using both Angular directives and attributes, along with Bootstrap built-in classes.
    So let''s begin:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 深呼吸，让我们分析前面的代码行。我们正在使用Angular指令和属性以及Bootstrap内置类。所以让我们开始：
- en: We are creating a menu `navbar` element, `<nav>`, provided in Bootstrap, and
    assigning the built-in `navbar` classes, `navbar-expand-lg navbar-light bg-light`.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在创建一个菜单`navbar`元素`<nav>`，在Bootstrap中提供，并分配内置的`navbar`类，`navbar-expand-lg
    navbar-light bg-light`。
- en: We are also creating an element and placeholder for the logo of our application
    using the `navbar-brand` class.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还使用`navbar-brand`类创建了应用程序的标志的元素和占位符。
- en: Using the `navbar-nav` class, we are defining a collection of links.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`navbar-nav`类，我们正在定义一组链接。
- en: We are adding few links using the anchor tag, `<a>`, and assigning the `nav-link` class,
    which will form the links in the menu section.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在使用锚标签`<a>`添加一些链接，并分配`nav-link`类，这将形成菜单部分的链接。
- en: We are also creating a drop-down menu using the `dropdown-menu` class and adding
    items to the menu using `dropdown-item`.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还使用`dropdown-menu`类创建了一个下拉菜单，并使用`dropdown-item`向菜单添加项目。
- en: For Angular directives and attributes, we are using `routerLink` and `routerLinkActive`
    and, as explained in the *First thing first - basic concepts*, section, the `routerLink`
    attribute is used to bind the URL resource of the link.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Angular指令和属性，我们正在使用`routerLink`和`routerLinkActive`，如*首先要做的事情-基本概念*部分所述，`routerLink`属性用于绑定链接的URL资源。
- en: To highlight the active link, we are using the `routerLinkActive` attribute.
    You will notice that for all links, we have assigned the attribute value as `active`.
    Angular at runtime will detect the link clicked and will highlight it.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了突出显示活动链接，我们正在使用`routerLinkActive`属性。您会注意到，对于所有链接，我们已经将属性值分配为`active`。Angular在运行时将检测到链接被点击并将其突出显示。
- en: Awesome, good job so far. We have implemented a `nav` menu for our application.
    We are just one step away from seeing our application in action.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，到目前为止做得很好。我们已经为我们的应用程序实现了一个`nav`菜单。我们离看到我们的应用程序运行只有一步之遥。
- en: Specifying the location for rendering the component templates
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定渲染组件模板的位置
- en: We need to tell Angular where we want the component templates, for the mapped
    components in our routing rulesets, to be displayed. For our application, we want
    to have the components that the router calls upon to be rendered under our navigation
    bar.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要告诉Angular我们希望在哪里显示映射组件的组件模板，以符合我们的路由规则集。对于我们的应用程序，我们希望路由器调用的组件在我们的导航栏下呈现。
- en: Angular has a directive for doing this, `<router-outlet>`, which is defined
    in `RouterModule`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Angular有一个指令可以做到这一点，`<router-outlet>`，它在`RouterModule`中定义。
- en: 'Under the HTML we added for creating our Bootstrap navigation bar, add this
    following line of HTML:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加用于创建Bootstrap导航栏的HTML下面，添加以下一行HTML：
- en: '[PRE17]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That's all that is needed to tell Angular where the components that are called
    upon by the routing service should be rendered.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是告诉Angular路由服务调用的组件应该呈现在哪里所需的一切。
- en: Running our application
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的应用程序
- en: Now that we have completed configuring routing for our application, let's take
    it for a quick spin.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经完成了为我们的应用程序配置路由，让我们快速试一下。
- en: 'Do you remember how to build and start our Angular application? Right! Use
    the CLI and issue the `serve` command like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您还记得如何构建和启动我们的Angular应用程序吗？对了！使用CLI并像这样发出`serve`命令：
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Make sure you are in the application's root folder when you do this.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在执行此操作时，您位于应用程序的根文件夹中。
- en: 'A shortcut for starting the application and opening your browser to localhost
    in one fell swoop, is issuing the `ng server` command with the `open` option,
    like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性启动应用程序并在浏览器中打开localhost的快捷方式是使用`ng server`命令与`open`选项，就像这样：
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What you should see is that the URL in the browser's location bar is pointing
    to `http://localhost:4200/home`, which is Angular routing at work. The `ng serve`
    command with the `open` option issued the `http://localhost:4200` URL, but this
    triggered the route redirection to `/home`. Pretty cool, huh?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到的是浏览器地址栏中的URL指向`http://localhost:4200/home`，这是Angular路由在起作用。`ng serve`命令与`open`选项一起发出了`http://localhost:4200`的URL，但这触发了路由重定向到`/home`。很酷，对吧？
- en: 'When we run the application, we should see the output shown in the following
    screenshot:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用程序时，我们应该看到以下截图中显示的输出：
- en: '![](assets/98d58a94-73e5-4779-bbe6-a1c4b9200b42.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/98d58a94-73e5-4779-bbe6-a1c4b9200b42.png)'
- en: In the next section, we will learn about some of the routing strategies we can
    implement in our apps.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习一些我们可以在应用程序中实现的路由策略。
- en: Routing strategies
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由策略
- en: 'There are two client-side routing strategies in Angular:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Angular中有两种客户端路由策略：
- en: '`HashLocationStrategy` (typically used for client-side purposes, such as anchor
    tags)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HashLocationStrategy`（通常用于客户端目的，如锚标签）'
- en: '`PathLocationStrategy` (this is the default)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PathLocationStrategy`（这是默认值）'
- en: 'To enable `HashLocationStrategy`, in the `app.module.ts` file, where we have
    `RouterModule.forRoot(appRoutes)`, append `{ useHash: true }` as the second parameter
    in the `forRoot` method. This is what it should look like:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '要启用`HashLocationStrategy`，在`app.module.ts`文件中，我们有`RouterModule.forRoot(appRoutes)`，在`forRoot`方法的第二个参数中添加`{
    useHash: true }`。应该是这样的：'
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'URLs with `HashLocationStrategy` have a hash sign (#) in their path. Here is
    an example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`HashLocationStrategy`的URL在其路径中有一个井号（#）。以下是一个例子：
- en: '[http://madeuplistofpeople.com/superheros#cloudman](http://madeuplistofpeople.com/superheros#cloudman)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://madeuplistofpeople.com/superheros#cloudman](http://madeuplistofpeople.com/superheros#cloudman)'
- en: The preceding URL represents a get request to [http://madeuplistofpeople.com/superheros](http://madeuplistofpeople.com/superheros)
    to the server.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的URL表示对服务器的[http://madeuplistofpeople.com/superheros](http://madeuplistofpeople.com/superheros)的get请求。
- en: Everything from the hash onward is not part of the request, because the browser
    only sends everything in the browser's location bar, to the left of the hash sign,
    to the server.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从井号（#）开始的所有内容都不是请求的一部分，因为浏览器只会发送井号左边的所有内容到服务器。
- en: The `#cloudman` portion of the URL is used exclusively by the client, and, typically,
    this is used by the browser to automatically scroll down to the anchor tag on
    the page (in this case, to the anchor tag with a `name` attribute of `cloudman`).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: URL的`#cloudman`部分仅由客户端使用，通常情况下，浏览器会自动滚动到页面上的锚标签（在本例中，滚动到具有`name`属性为`cloudman`的锚标签）。
- en: One use of the `HashLocationStrategy` strategy is for using the hash sign to
    store application state, which is convenient for implementing client-side routing
    for an SPA.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashLocationStrategy`策略的一个用途是使用井号来存储应用程序状态，这对于实现SPA的客户端路由非常方便。'
- en: 'As an example, consider the following URLs:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下URL：
- en: '[http://madeuplistofpeople.com/#/about](http://madeuplistofpeople.com/#/about)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://madeuplistofpeople.com/#/about](http://madeuplistofpeople.com/#/about)'
- en: '[http://madeuplistofpeople.com/#/search](http://madeuplistofpeople.com/#/search)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://madeuplistofpeople.com/#/search](http://madeuplistofpeople.com/#/search)'
- en: '[http://madeuplistofpeople.com/#/contactus](http://madeuplistofpeople.com/#/contactus)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://madeuplistofpeople.com/#/contactus](http://madeuplistofpeople.com/#/contactus)'
- en: This URL pattern is great for an SPA because the only request going to the server
    is [http://madeuplistofpeople.com](http://madeuplistofpeople.com), which is essentially
    one page. The client side will handle the different hash fragments (that is, from
    the hash sign to the end of the right-hand side of the hash sign) in whichever
    way it was programmed to.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这种URL模式非常适合SPA，因为发送到服务器的唯一请求是[http://madeuplistofpeople.com](http://madeuplistofpeople.com)，基本上就是一个页面。客户端将以其编程的任何方式处理不同的哈希片段（即从井号到右侧井号的末尾）。
- en: To wrap up this section, an important concept of `PathLocationStrategy` is that
    Angular takes advantage of an HTML5 history API called pushstate. We can change
    the URL using the pushstate API while suppressing the traditional default action
    by the browser to send the new request (that is, the altered URL) to the server.
    This makes it possible to implement client-side routing without resorting to using
    a hash sign (#). This is why it is the default client-side routing strategy in
    Angular.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，`PathLocationStrategy`的一个重要概念是Angular利用了一个名为pushstate的HTML5历史API。我们可以使用pushstate
    API更改URL，同时抑制浏览器发送新请求（即更改后的URL）到服务器的传统默认操作。这使得可以实现客户端路由，而无需使用井号（#）。这就是为什么它是Angular中默认的客户端路由策略的原因。
- en: However, there is a downside. If the browser were to be refreshed, a request
    would be made to the server, which would reset your application with whatever
    the server sent back. In other words, your application would lose its state, unless
    you had implemented local storage strategies.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也有一个缺点。如果浏览器刷新，将向服务器发出请求，服务器将用返回的内容重置您的应用程序。换句话说，除非您实施了本地存储策略，否则您的应用程序将丢失其状态。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was a fairly short chapter, but we still covered a lot of ground. In this
    chapter, we created the skeleton for our application, including creating the components
    that we had our routes mapped to. We then went through a step-by-step process
    of configuring routing for our application. This included importing the two required
    modules (that is, `RoutingModule` and `Routes`), coding up routing rulesets in
    the form of mapping objects, and specifying where the routed components were to
    be rendered.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简短的章节，但我们仍然涵盖了很多内容。在本章中，我们为我们的应用程序创建了骨架，包括创建我们的路由映射到的组件。然后，我们逐步配置了我们应用程序的路由。这包括导入两个必需的模块（即RoutingModule和Routes），编写路由规则集的映射对象形式，并指定路由组件的呈现位置。
- en: We also installed and integrated Bootstrap into our application, and created
    our Bootstrap navigation bar in our root component's template. We then took a
    look at how to make Angular aware of installed node packages, Bootstrap and jQuery
    in particular, since that is how we installed Bootstrap and its dependencies (that
    is, jQuery and Popper).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将Bootstrap安装并集成到我们的应用程序中，并在根组件的模板中创建了我们的Bootstrap导航栏。然后，我们看了一下如何让Angular意识到已安装的节点包，特别是Bootstrap和jQuery，因为这是我们安装Bootstrap及其依赖项（即jQuery和Popper）的方式。
- en: Although we didn't make use of parameterized routes and route guards in this
    chapter, we mentioned them here because we'll be making use of them later in the
    book—in [Chapter 12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml), *Integrating
    Backend Data Services*, and *[Chapter 14](485921eb-86e2-4068-b314-5c62a1545c22.xhtml),
    Advanced Angular Topics—*and in the spirit of the book, discussing things at the
    time we need them and not before, we are deferring their demonstration until the
    appropriate times.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在本章中我们没有使用参数化路由和路由守卫，但我们在这里提到它们，因为我们将在本书的后面部分使用它们——在[第12章](9610f27b-03db-4258-8a68-24eb3901117b.xhtml)
    *集成后端数据服务* 和 *[第14章](485921eb-86e2-4068-b314-5c62a1545c22.xhtml) *高级Angular主题*，并且根据本书的精神，在我们需要它们的时候讨论它们，而不是提前，我们将推迟它们的演示直到适当的时间。
- en: And to wrap this chapter up, we took a look at the two client-side routing strategies
    that Angular lets us choose from.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看了一下Angular让我们可以选择的两种客户端路由策略。
- en: We've mentioned the word *components* over and over again in this chapter, since
    routing maps URL paths to components. We've even created several components using
    the CLI, but we've spent no time understanding components. That's perfectly fine
    because, as was mentioned, you didn't need to understand components in order to
    understand routing. Now that we have routing under our belt, we'll be looking
    at components in the chapters ahead. But just before we do that, there is another
    short chapter, [Chapter 5](7a55c9e9-7f80-41bc-9678-eb191fdc4c2d.xhtml), *Flex-layout
    – Angular's Responsive Layout Engine*, that we're going to quickly cover. It's
    a bit of an odd-ball chapter because Flex-layout is an alternative to Bootstrap's
    responsive grid and, as such, it is not at all required to build an Angular application.
    However, I thought it may be of interest to you. With that said, let's turn our
    attention to Flex-layout.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们一再提到了“组件”这个词，因为路由将URL路径映射到组件。我们甚至使用CLI创建了几个组件，但我们没有花时间去理解组件。这完全没关系，因为正如我们所提到的，你不需要理解组件就能理解路由。现在我们已经掌握了路由，我们将在接下来的章节中看看组件。但在我们开始之前，还有另一个简短的章节[第5章]，*Flex-layout
    – Angular的响应式布局引擎*，我们将快速介绍一下。这是一个有点奇怪的章节，因为Flex-layout是Bootstrap响应式网格的替代方案，因此完全不需要构建Angular应用程序。然而，我认为这可能会引起你的兴趣。说到这里，让我们把注意力转向Flex-layout。
