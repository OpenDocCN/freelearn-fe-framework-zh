- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Creating a Frontend to Consume and Send Events
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个用于消费和发送事件的前端
- en: After successfully creating a Socket.IO backend in the previous chapter, and
    doing our first experiments with the Socket.IO client, let’s now focus on implementing
    a frontend to connect to the backend and consume and send events.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章成功创建 Socket.IO 后端，并进行了第一次 Socket.IO 客户端实验后，现在让我们专注于实现一个前端来连接后端并消费和发送事件。
- en: We are first going to clean up our project by removing files from the previously
    created blog app. Then, we are going to implement a React Context to initialize
    and store our Socket.IO instance, making use of the existing `AuthProvider` to
    provide the token for authenticating with the backend. After that, we are going
    to implement an interface for our chat app and a way to send chat messages, as
    well as displaying received chat messages. Finally, we are going to implement
    chat commands with acknowledgments to show which rooms we are currently in.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将清理我们的项目，通过从之前创建的博客应用中删除文件。然后，我们将实现一个 React Context 来初始化和存储我们的 Socket.IO
    实例，利用现有的 `AuthProvider` 为与后端进行身份验证提供令牌。之后，我们将实现一个用于我们的聊天应用的接口，以及发送聊天消息和显示接收到的聊天消息的方法。最后，我们将实现带有确认的聊天命令，以显示我们当前所在的房间。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Integrating the Socket.IO client with React
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Socket.IO 客户端集成到 React 中
- en: Implementing chat functionality
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现聊天功能
- en: Implementing chat commands with acknowledgments
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现带有确认的聊天命令
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before we start, please install all the requirements from [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016),
    *Preparing for Full-Stack Development*, and [*Chapter 2*](B19385_02.xhtml#_idTextAnchor028),
    *Getting to Know Node.js* *and MongoDB*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请安装来自 [*第 1 章*](B19385_01.xhtml#_idTextAnchor016) *为全栈开发做准备* 和 [*第 2
    章*](B19385_02.xhtml#_idTextAnchor028) *了解 Node.js 和 MongoDB* 的所有要求。
- en: The versions listed in those chapters are the ones used in the book. While installing
    a newer version should not be an issue, please note that certain steps might work
    differently on a newer version. If you have an issue with the code and steps provided
    in this book, please try using the versions listed in *Chapters 1* and *2.*
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那些章节中列出的版本是书中使用的版本。虽然安装较新版本可能不会出现问题，但请注意，某些步骤在较新版本上可能有所不同。如果您在这本书提供的代码和步骤中遇到问题，请尝试使用
    *第 1 章* 和 *第 2 章* 中列出的版本。
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch14](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch14).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章的代码：[https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch14](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch14)。
- en: If you cloned the full repository for the book, Husky may not find the `.git`
    directory when running `npm install`. In that case, just run `git init` in the
    root of the corresponding chapter folder.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您克隆了本书的完整仓库，Husky 在运行 `npm install` 时可能找不到 `.git` 目录。在这种情况下，只需在相应章节文件夹的根目录中运行
    `git init`。
- en: 'The CiA video for this chapter can be found at: [https://youtu.be/d_TZK6S_XDU](https://youtu.be/d_TZK6S_XDU).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 CiA 视频可以在：[https://youtu.be/d_TZK6S_XDU](https://youtu.be/d_TZK6S_XDU) 找到。
- en: Integrating the Socket.IO client with React
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Socket.IO 客户端集成到 React 中
- en: Let’s start by cleaning up the project and deleting all old files copied over
    from the blog app. Then, we are going to set up a Socket.IO context to make it
    easier to initialize and use Socket.IO in React components. Finally, we are going
    to create our first component that utilizes this context to show the status of
    our Socket.IO connection.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先清理项目，删除从博客应用中复制过来的所有旧文件。然后，我们将设置一个 Socket.IO 上下文，以便在 React 组件中更容易地初始化和使用
    Socket.IO。最后，我们将创建第一个利用此上下文来显示我们的 Socket.IO 连接状态的组件。
- en: Cleaning up the project
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理项目
- en: 'Let’s first delete the folders and files from the blog application we created
    earlier:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先删除我们之前创建的博客应用中的文件夹和文件：
- en: 'Copy the existing **ch13** folder to a new **ch14** folder, as follows:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的 **ch13** 文件夹复制到新的 **ch14** 文件夹中，如下所示：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Open the **ch14** folder in VS Code.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开 **ch14** 文件夹。
- en: '*Delete* the following folders and files, as they were only required for the
    blog application backend:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*删除* 以下文件夹和文件，因为它们仅适用于博客应用的后端：'
- en: '**backend/src/__tests__/**'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**backend/src/__tests__/**'
- en: '**backend/src/example.js**'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**backend/src/example.js**'
- en: '**backend/src/db/models/post.js**'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**backend/src/db/models/post.js**'
- en: '**backend/src/routes/posts.js**'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**backend/src/routes/posts.js**'
- en: '**backend/src/services/posts.js**'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**backend/src/services/posts.js**'
- en: 'In **backend/src/app.js**, *remove* the following import:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **backend/src/app.js** 中，*移除* 以下导入：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Also, *remove* **postRoutes**:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，*移除* **postRoutes**：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Delete* the following folders and files, as they were only required for the
    blog application frontend:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*删除* 以下文件夹和文件，因为它们仅用于博客应用的前端：'
- en: '**src/api/posts.js**'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**src/api/posts.js**'
- en: '**src/components/CreatePost.jsx**'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**src/components/CreatePost.jsx**'
- en: '**src/components/Post.jsx**'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**src/components/Post.jsx**'
- en: '**src/components/PostFilter.jsx**'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**src/components/PostFilter.jsx**'
- en: '**src/components/PostList.jsx**'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**src/components/PostList.jsx**'
- en: '**src/components/PostSorting.jsx**'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**src/components/PostSorting.jsx**'
- en: '**src/pages/Blog.jsx**'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**src/pages/Blog.jsx**'
- en: Now that we have cleaned up our project, let’s get started with implementing
    a Socket.IO context for our new chat app.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经清理了我们的项目，让我们开始实现我们新聊天应用的 Socket.IO 上下文。
- en: Creating a Socket.IO context
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Socket.IO 上下文
- en: 'Up until now, we have been initializing the Socket.IO client instance in the
    `src/App.jsx` component. However, doing this has some downsides:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在 `src/App.jsx` 组件中初始化 Socket.IO 客户端实例。然而，这样做有一些缺点：
- en: To access the socket in other components, we would need to pass it down via
    props.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在其他组件中访问套接字，我们需要通过属性传递它。
- en: We can only have one socket connection for the whole app.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在整个应用中只能有一个套接字连接。
- en: It is not possible to get the token dynamically from **AuthContext**, requiring
    us to store the token in local storage instead.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 **AuthContext** 中动态获取令牌是不可能的，这迫使我们将其存储在本地存储中。
- en: Our app requires a full refresh to be able to load the new token and connect
    with it.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的应用需要完全刷新才能加载新的令牌并与之连接。
- en: We still try to connect and get an error when not logged in.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们仍然尝试连接，并在未登录时获取错误。
- en: 'To solve these issues, we can instead create a Socket.IO context. We can then
    use the provider component to do the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，我们可以创建一个 Socket.IO 上下文。然后我们可以使用提供者组件执行以下操作：
- en: Connect to Socket.IO only when the token is available in **AuthContext**.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在 **AuthContext** 中有可用令牌时才连接到 Socket.IO。
- en: Store the status of the Socket.IO connection and use it within components to,
    for example, only show the chat interface when logged in.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储Socket.IO连接的状态，并在组件中使用它，例如，仅在登录时显示聊天界面。
- en: Store the error object and display errors in the user interface.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储错误对象并在用户界面中显示错误。
- en: 'The following diagram shows how the status of our connection will be tracked:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了我们的连接状态将如何被跟踪：
- en: '![Figure 14.1 – The different states of the connection](img/B19385_14_1.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.1 – 连接的不同状态](img/B19385_14_1.jpg)'
- en: Figure 14.1 – The different states of the connection
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1 – 连接的不同状态
- en: As can be seen, the socket connection is initially waiting for the user to log
    in. Once the token is available, we attempt to establish a socket connection.
    If successful, the status changes to `connected`, otherwise to `error`. If the
    socket disconnects (for example, when the internet connection is lost), the state
    is set to `disconnected`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如所见，套接字连接最初正在等待用户登录。一旦可用令牌，我们尝试建立套接字连接。如果成功，状态变为`connected`，否则变为`error`。如果套接字断开连接（例如，当互联网连接丢失时），状态设置为`disconnected`。
- en: 'Now, let’s get started with creating a Socket.IO context:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始创建 Socket.IO 上下文：
- en: Create a new **src/contexts/SocketIOContext.jsx** file.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **src/contexts/SocketIOContext.jsx** 文件。
- en: 'Inside this file, import the following functions from **react**, **socket.io-client**,
    and **prop-types**:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件中，从 **react**、**socket.io-client** 和 **prop-types** 中导入以下函数：
- en: '[PRE3]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Additionally, import the **useAuth** hook from **AuthContext** to get the current
    token:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，从 **AuthContext** 中导入 **useAuth** 钩子以获取当前令牌：
- en: '[PRE4]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, define a React Context with some initial values for **socket**, **status**
    and **error**:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义一个带有一些初始值（**socket**、**status** 和 **error**）的 React 上下文：
- en: '[PRE5]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, define a provider component, in which we first create state hooks for
    the different values of the context:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义一个提供者组件，在其中我们首先为上下文的不同值创建状态钩子：
- en: '[PRE6]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, use the **useAuth** hook to get the JWT (if available):'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用 **useAuth** 钩子获取 JWT（如果可用）：
- en: '[PRE7]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create an effect hook that checks whether the token is available, and if so,
    attempts to connect to the Socket.IO backend:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个效果钩子，检查令牌是否可用，如果可用，则尝试连接到 Socket.IO 后端：
- en: '[PRE8]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Just like before, we pass the host, the `query` string, and the `auth` object.
    However, now we get the token from the `useAuth` hook instead of local storage.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就像之前一样，我们传递主机、`query` 字符串和 `auth` 对象。然而，现在我们从 `useAuth` 钩子而不是本地存储中获取令牌。
- en: 'Create handlers for the **connect**, **connect_error**, and **disconnect**
    events and set the **status** string and the **error** object, respectively:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为**connect**、**connect_error**和**disconnect**事件创建处理程序，并分别设置**status**字符串和**error**对象：
- en: '[PRE9]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Set the **socket** object and list all necessary dependencies for the effect
    hook:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置**socket**对象并列出effect钩子所需的所有必要依赖项：
- en: '[PRE10]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we can return the provider, passing all values from the state hooks to
    it:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以返回提供者，将状态钩子中的所有值传递给它：
- en: '[PRE11]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we set **PropTypes** for the context provider component and define
    a **useSocket** hook that will simply return the whole context:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们为上下文提供者组件设置**PropTypes**，并定义一个将简单地返回整个上下文的**useSocket**钩子：
- en: '[PRE12]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we have a context to initialize our Socket.IO client, let’s hook it
    up and display the status of the socket connection.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个上下文来初始化我们的Socket.IO客户端，让我们将其连接并显示套接字连接的状态。
- en: Hooking up the context and displaying the status
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接上下文并显示状态
- en: 'We can now remove the code to connect to Socket.IO from the `App` component
    and use the provider instead, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以从`App`组件中删除连接到Socket.IO的代码，并使用提供者，如下所示：
- en: 'Edit **src/App.jsx** and *remove* the following import:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/App.jsx**并*删除*以下导入：
- en: '[PRE13]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add an import to **SocketIOContextProvider**:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向**SocketIOContextProvider**添加导入：
- en: '[PRE14]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, *remove* the following code related to the Socket.IO connection:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，*删除*与Socket.IO连接相关的以下代码：
- en: '[PRE15]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Inside the **App** component, render the context provider:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**App**组件内部，渲染上下文提供者：
- en: '[PRE16]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After hooking up the Socket.IO context, let’s move on to creating a `Status`
    component to display the status.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接Socket.IO上下文之后，让我们继续创建一个用于显示状态的`Status`组件。
- en: Creating a Status component
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个状态组件
- en: 'Now, let’s create a `Status` component to display the current status of the
    socket:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个`Status`组件来显示套接字当前的状态：
- en: Create a new **src/components/Status.jsx** file.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**src/components/Status.jsx**文件。
- en: 'Inside it, import the **useSocket** hook from our **SocketIOContext**:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，从我们的**SocketIOContext**导入**useSocket**钩子：
- en: '[PRE17]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Define a **Status** component, in which we get the **status** string and **error**
    object from the hook:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个**Status**组件，其中我们从钩子中获取**status**字符串和**error**对象：
- en: '[PRE18]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Render the socket status:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染套接字状态：
- en: '[PRE19]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we have an **error** object, we can additionally display the error message
    now:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们有一个**error**对象，我们现在还可以显示错误信息：
- en: '[PRE20]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that we have a `Status` component, let’s create a `Chat` page component,
    where we render the `Header` and `Status` components.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个`Status`组件，让我们创建一个`Chat`页面组件，在其中渲染`Header`和`Status`组件。
- en: Creating a Chat page component
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个聊天页面组件
- en: 'We previously had a `Blog` page for our blog app, which we deleted earlier
    in this chapter. Let’s now create a new `Chat` page component for our chat app:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在我们的博客应用中有一个`Blog`页面，我们在本章早期删除了它。现在，让我们为我们的聊天应用创建一个新的`Chat`页面组件：
- en: Create a new **src/pages/Chat.jsx** file.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**src/pages/Chat.jsx**文件。
- en: 'Inside it, import the **Header** component (which we are going to reuse from
    the **Blog** app) and the **Status** component:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，导入**Header**组件（我们将从**Blog**应用中重用）和**Status**组件：
- en: '[PRE21]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Render a **Chat** component in which we display the **Header** and **Status**
    components:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染一个**Chat**组件，在其中显示**Header**和**Status**组件：
- en: '[PRE22]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Edit **src/App.jsx** and locate the following import:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/App.jsx**并定位到以下导入：
- en: '[PRE23]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Replace* it with an import to the `Chat` component:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*替换*为对`Chat`组件的导入：'
- en: '[PRE24]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, *replace* the **<Blog />** component in the main path in our router
    with the **<Chat />** component:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，*替换*主路径中的**<Blog />**组件为**<Chat />**组件：
- en: '[PRE25]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Starting and testing our chat app frontend
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动和测试我们的聊天应用前端
- en: 'We can now start and test out our chat app frontend:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以启动并测试我们的聊天应用前端：
- en: 'Run the frontend, as follows:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式运行前端：
- en: '[PRE26]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the backend, as follows (make sure Docker and the database container are
    running!):'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式运行后端（确保Docker和数据库容器正在运行！）：
- en: '[PRE27]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now go to **http://localhost:5173/** and you should see the following interface:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在转到**http://localhost:5173/**，你应该看到以下界面：
- en: '![Figure 14.2 – Socket connection waiting for user to be logged in](img/B19385_14_2.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图14.2 – 套接字连接等待用户登录](img/B19385_14_2.jpg)'
- en: Figure 14.2 – Socket connection waiting for user to be logged in
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 – 套接字连接等待用户登录
- en: 'Log in (create a new user if you do not have one yet), and the socket should
    connect successfully:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录（如果您还没有，请创建一个新用户），套接字应该成功连接：
- en: '![Figure 14.3 – Socket connected after user is logged in](img/B19385_14_3.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图14.3 – 用户登录后套接字已连接](img/B19385_14_3.jpg)'
- en: Figure 14.3 – Socket connected after user is logged in
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3 – 用户登录后套接字已连接
- en: Disconnecting socket on logout
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注销时断开套接字
- en: 'You may have noticed that when pressing **Logout**, the socket stays connected.
    Let’s fix that now, by disconnecting the socket when logging out:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，当按下 **注销** 时，套接字仍然保持连接。现在，让我们修复这个问题，通过在注销时断开套接字。
- en: 'Edit **src/components/Header.jsx** and import the **useSocket** hook:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/components/Header.jsx** 并导入 **useSocket** 钩子：
- en: '[PRE28]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Get the socket from the **useSocket** hook, as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **useSocket** 钩子中获取套接字，如下所示：
- en: '[PRE29]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Define a new **handleLogout** function, which disconnects the socket and resets
    the token:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的 **handleLogout** 函数，它断开套接字并重置令牌：
- en: '[PRE30]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Lastly, set the **onClick** handler to the **handleLogout** function:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将 **onClick** 处理器设置为 **handleLogout** 函数：
- en: '[PRE31]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, when you log out, the socket will be disconnected, as can be seen in the
    following screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你注销时，套接字将会断开连接，如下面的截图所示：
- en: '![Figure 14.4 – Socket disconnected after logging out](img/B19385_14_4.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.4 – 注销后套接字已断开](img/B19385_14_4.jpg)'
- en: Figure 14.4 – Socket disconnected after logging out
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4 – 注销后套接字已断开
- en: Now that the Socket.IO client is successfully integrated with our React frontend,
    we can continue by implementing chat functionality in the frontend.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Socket.IO客户端已成功集成到我们的React前端，我们可以继续在前端实现聊天功能。
- en: Implementing chat functionality
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 chat 功能
- en: We are now going to implement functionality to send and receive messages in
    our chat app. First, we are going to implement all the components that we need.
    Then, we are going to create a `useChat` hook to implement the logic to interface
    with the socket connection and provide functions to send/receive messages. Lastly,
    we are going to put it all together by creating a chat room.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现发送和接收消息的功能。首先，我们将实现所有需要的组件。然后，我们将创建一个 `useChat` 钩子来实现与套接字连接的接口并提供发送/接收消息的函数。最后，我们将通过创建聊天室来将这些功能组合在一起。
- en: Implementing the chat components
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 chat 组件
- en: 'We are going to implement the following chat components:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现以下聊天组件：
- en: '**ChatMessage**: To display chat messages'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ChatMessage**：用于显示聊天消息'
- en: '**EnterMessage**: A field to enter new messages and a button to send them'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EnterMessage**：一个输入新消息的字段和一个发送它们的按钮'
- en: Implementing the ChatMessage component
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 ChatMessage 组件
- en: 'Let’s start by implementing the `ChatMessage` component:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先实现 `ChatMessage` 组件：
- en: Create a new **src/components/ChatMessage.jsx** file, which will render a chat
    message.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **src/components/ChatMessage.jsx** 文件，它将渲染聊天消息。
- en: 'Import **PropTypes** and define a new function with **username** and **message**
    props:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 **PropTypes** 并定义一个新的函数，带有 **username** 和 **message** 属性：
- en: '[PRE32]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Render the username in bold and the message next to it:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以粗体形式渲染用户名，并在其旁边显示消息：
- en: '[PRE33]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Define the prop types, as follows:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义属性类型，如下所示：
- en: '[PRE34]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Implementing the EnterMessage component
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 EnterMessage 组件
- en: 'Now, let’s create the `EnterMessage` component, which will allow users to send
    a new chat message:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建 `EnterMessage` 组件，它将允许用户发送新的聊天消息：
- en: Create a new **src/components/EnterMessage.jsx** file.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **src/components/EnterMessage.jsx** 文件。
- en: 'Import the **useState** hook and **PropTypes**:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 **useState** 钩子和 **PropTypes**：
- en: '[PRE35]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Define a new **EnterMessage** component, which receives an **onSend** function
    as props:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的 **EnterMessage** 组件，它接收一个 **onSend** 函数作为属性：
- en: '[PRE36]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We store the current state of the message entered:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们存储输入的消息的当前状态：
- en: '[PRE37]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, we define a function to handle sending the request and clearing the field
    afterward:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个函数来处理发送请求并在之后清除字段：
- en: '[PRE38]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Reminder
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒
- en: Because we are submitting a form using a **submit** button, we need to call
    **e.preventDefault()** to prevent the form from refreshing the page.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们是使用 **submit** 按钮提交表单，所以我们需要调用 **e.preventDefault()** 来防止表单刷新页面。
- en: 'Render a form with an input field to enter the message and a button to send
    it:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染一个表单，包含一个输入字段来输入消息和一个按钮来发送它：
- en: '[PRE39]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Define the prop types, as follows:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义属性类型，如下所示：
- en: '[PRE40]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Implementing a useChat hook
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 useChat 钩子
- en: 'To bundle all the logic together, we are going to implement a `useChat` hook,
    which is going to deal with sending and receiving messages, as well as storing
    all current messages in a state hook. Follow these steps to implement it:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将所有逻辑组合在一起，我们将实现一个 `useChat` 钩子，它将处理发送和接收消息，以及将所有当前消息存储在状态钩子中。按照以下步骤实现它：
- en: Create a new **src/hooks/** folder. Inside it, create a new **src/hooks/useChat.js**
    file.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **src/hooks/** 文件夹。在其内部，创建一个新的 **src/hooks/useChat.js** 文件。
- en: 'Import the **useState** and **useEffect** hooks from React:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 React 中导入 **useState** 和 **useEffect** 钩子：
- en: '[PRE41]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Import the **useSocket** hook from our context:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们的上下文中导入 **useSocket** 钩子：
- en: '[PRE42]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Define a new **useChat** function, where we get the socket from the **useSocket**
    hook, and define a state hook to store an array of messages:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的 **useChat** 函数，其中我们从 **useSocket** 钩子获取套接字，并定义一个状态钩子来存储消息数组：
- en: '[PRE43]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, define a **receiveMessage** function, which appends a new message to
    the array:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义一个 **receiveMessage** 函数，该函数将新消息追加到数组中：
- en: '[PRE44]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, create an effect hook, in which we create a listener using **socket.on**:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个效果钩子，在其中我们使用 **socket.on** 创建一个监听器：
- en: '[PRE45]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We need to make sure to remove the listener again using **socket.off** when
    the effect hook unmounts, otherwise we might end up with multiple listeners when
    the component re-renders or unmounts:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要确保在效果钩子卸载时再次使用 **socket.off** 移除监听器，否则在组件重新渲染或卸载时我们可能会得到多个监听器：
- en: '[PRE46]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, receiving messages should work fine. Let’s move on to sending messages.
    To do this, we create a **sendMessage** function, which uses **socket.emit** to
    send the message:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，接收消息应该可以正常工作。让我们继续发送消息。为此，我们创建一个 **sendMessage** 函数，该函数使用 **socket.emit**
    来发送消息：
- en: '[PRE47]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Lastly, return the **messages** array and the **sendMessage** function so that
    we can use them in our components:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，返回 **messages** 数组和 **sendMessage** 函数，以便我们可以在我们的组件中使用它们：
- en: '[PRE48]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now that we have successfully implemented the `useChat` hook, let’s use it!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功实现了 `useChat` 钩子，让我们使用它！
- en: Implementing the ChatRoom component
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 ChatRoom 组件
- en: 'Finally, we can put it all together and implement a `ChatRoom` component. Follow
    these steps to get started:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以把它们全部放在一起，并实现一个 `ChatRoom` 组件。按照以下步骤开始：
- en: Create a new **src/components/ChatRoom.jsx** file.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **src/components/ChatRoom.jsx** 文件。
- en: 'Import the **useChat** hook and the **EnterMessage** and **ChatMessage** components:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 **useChat** 钩子和 **EnterMessage** 以及 **ChatMessage** 组件：
- en: '[PRE49]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Define a new component, which gets the **messages** array and the **sendMessage**
    function from the **useChat** hook:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的组件，该组件从 **useChat** 钩子获取 **messages** 数组和 **sendMessage** 函数：
- en: '[PRE50]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, render the list of messages as **ChatMessage** components:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将消息列表渲染为 **ChatMessage** 组件：
- en: '[PRE51]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, render the **EnterMessage** component and pass the **sendMessage** function
    as the **onSend** prop:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，渲染 **EnterMessage** 组件，并将 **sendMessage** 函数作为 **onSend** 属性传递：
- en: '[PRE52]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Edit **src/pages/Chat.jsx** and import the **ChatRoom** component and the **useSocket**
    hook:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/pages/Chat.jsx** 并导入 **ChatRoom** 组件和 **useSocket** 钩子：
- en: '[PRE53]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Get the status from the **useSocket** hook in the **Chat** page component:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Chat** 页面组件中的 **useSocket** 钩子获取状态：
- en: '[PRE54]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If the status is **connected**, we show the **ChatRoom** component:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果状态是 **已连接**，我们显示 **ChatRoom** 组件：
- en: '[PRE55]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now, go to **http://localhost:5173/** in your browser and log in with a username
    and password. The socket connects and the chat room is rendered. Enter a chat
    message and send it by pressing *Return/Enter* or by clicking the **Send** button.
    You will see that the message is received and displayed!
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在您的浏览器中转到 **http://localhost:5173/** 并使用用户名和密码登录。套接字连接并渲染聊天室。输入一条聊天消息，并通过按
    *Return/Enter* 或点击 **发送** 按钮发送它。您将看到消息被接收并显示出来！
- en: 'Open a second browser window and log in with a second user. Send another message
    there. You will see that the message is received by both users, as can be seen
    in the following screenshot:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开第二个浏览器窗口并使用第二个用户登录。在那里发送另一条消息。您将看到消息被两个用户接收，如下面的截图所示：
- en: '![Figure 14.5 – Sending and receiving messages from different users](img/B19385_14_5.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.5 – 从不同用户发送和接收消息](img/B19385_14_5.jpg)'
- en: Figure 14.5 – Sending and receiving messages from different users
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5 – 从不同用户发送和接收消息
- en: Now that we have a basic chat app working, let’s explore how we could implement
    chat commands using acknowledgments.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个基本的聊天应用正在运行，让我们探索如何使用确认来实现聊天命令。
- en: Implementing chat commands with acknowledgments
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用确认实现聊天命令
- en: 'In addition to sending and receiving messages, chat apps often offer a way
    to send commands to the client and/or server. For example, we could send a `/clear`
    command to clear our local messages list. Or we could send a `/rooms` command
    to get a list of rooms that we are in. Follow these steps to implement chat commands:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 除了发送和接收消息外，聊天应用通常还提供了一种向客户端和/或服务器发送命令的方式。例如，我们可以发送一个 `/clear` 命令来清除我们的本地消息列表。或者，我们可以发送一个
    `/rooms` 命令来获取我们所在的房间列表。按照以下步骤实现聊天命令：
- en: 'Edit **src/hooks/useChat.js** and adjust the **sendMessage** function inside
    it. First, let’s make it an **async** function:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/hooks/useChat.js**并调整其中的**sendMessage**函数。首先，让我们将其改为**async**函数：
- en: '[PRE56]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '*Replace* the contents of the function with the following. We first check whether
    the message starts with a slash (**/**). If so, then we get the command by removing
    the slash and use a **switch** statement:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*替换*函数的内容如下。我们首先检查消息是否以斜杠（**/**）开头。如果是，那么我们通过删除斜杠来获取命令，并使用**switch**语句：'
- en: '[PRE57]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'For the **clear** command, we simply set the array of messages to an empty
    array:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**clear**命令，我们只需将消息数组设置为空数组：
- en: '[PRE58]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'For the **rooms** command, we get the user info by using **socket.emitWithAck**
    and our own **socket.id**:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**rooms**命令，我们通过使用**socket.emitWithAck**和我们的**socket.id**来获取用户信息：
- en: '[PRE59]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Then, we get the list of rooms, filtering out our own room (with the name of
    our **socket.id**) that we automatically join in Socket.IO:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们获取房间列表，过滤掉我们自动加入的带有我们**socket.id**名称的房间：
- en: '[PRE60]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We reuse the **receiveMessage** function to send a message from the server,
    telling us the rooms that we are in:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重用**receiveMessage**函数从服务器发送消息，告诉我们我们所在的房间：
- en: '[PRE61]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note that we are not sending a username here, just a message. We will have to
    adapt the `ChatMessage` component to accommodate that later.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这里我们没有发送用户名，只是发送消息。我们稍后必须调整`ChatMessage`组件以适应这一点。
- en: 'If we receive any other command, we show an error message:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们收到任何其他命令，我们将显示一个错误消息：
- en: '[PRE62]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Otherwise (if the message did not start with a slash), we simply emit the chat
    message, as before:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则（如果消息没有以斜杠开头），我们就像之前一样简单地发出聊天消息：
- en: '[PRE63]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Finally, edit **src/components/ChatMessage.jsx** and adapt the component to
    render a system message if no username was given:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，编辑**src/components/ChatMessage.jsx**并调整组件以在未提供用户名时渲染系统消息：
- en: '[PRE64]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Do not forget to adjust **PropTypes** to make the username optional (by *removing*
    **.isRequired** from the **username** prop):'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记调整**PropTypes**以使用户名可选（通过从**username**属性中*移除***.isRequired**）：
- en: '[PRE65]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Go to **http://localhost:5173/** in your browser and try sending a couple messages.
    Then, type **/clear** and you will see all messages were cleared. Next, type **/rooms**
    to get the list of rooms that you are in, as you can see in the following screenshot:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中转到**http://localhost:5173/**并尝试发送几条消息。然后，键入**/clear**，您将看到所有消息都被清除了。接下来，键入**/rooms**以获取您所在的房间列表，如下面的截图所示：
- en: '![Figure 14.6 – Sending the /rooms command](img/B19385_14_6.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图14.6 – 发送/rooms命令](img/B19385_14_6.jpg)'
- en: Figure 14.6 – Sending the /rooms command
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6 – 发送/rooms命令
- en: Note
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Joining different rooms currently does not work due to the query parameter getting
    cleared after logging in. In the next chapter, we are going to refactor the chat
    app and implement a **/join** command to join a different room.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 由于登录后查询参数被清除，目前无法加入不同的房间。在下一章中，我们将重构聊天应用并实现**/join**命令以加入不同的房间。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we implemented a frontend for our chat app backend. We started
    by integrating the Socket.IO client with React by making a context and a custom
    hook for it. Then, we used `AuthProvider` to get the token to authenticate a user
    when connecting to the socket. After that, we displayed the status of our socket.
    Then, we implemented a chat app interface to send and receive messages. Finally,
    we implemented chat commands by using acknowledgments to get the rooms that we
    are in.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为我们的聊天应用后端实现了一个前端。我们首先通过创建一个上下文和自定义钩子来集成Socket.IO客户端和React。然后，我们使用`AuthProvider`获取令牌以在连接到socket时验证用户。之后，我们显示了我们的socket状态。然后，我们实现了聊天应用界面以发送和接收消息。最后，我们通过使用确认来获取我们所在的房间实现了聊天命令。
- en: In the next chapter, [*Chapter 15*](B19385_15.xhtml#_idTextAnchor276), *Adding
    Persistence to Socket.IO Using MongoDB*, we are going to learn how to store and
    replay previously sent messages using MongoDB with Socket.IO.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，[*第15章*](B19385_15.xhtml#_idTextAnchor276)，*使用MongoDB为Socket.IO添加持久性*，我们将学习如何使用MongoDB和Socket.IO存储和回放之前发送的消息。
