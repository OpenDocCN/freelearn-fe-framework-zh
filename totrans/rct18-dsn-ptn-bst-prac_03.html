<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer023">
<h1 class="chapterNumber">3</h1>
<h1 class="chapterTitle" id="_idParaDest-41">Cleaning Up Your Code </h1>
<p class="normal">This <a id="_idIndexMarker062"/>chapter assumes that you have prior experience with <strong class="keyWord">JSX</strong> (<strong class="keyWord">JavaScript XML</strong>) and are interested in improving your skills to use it effectively. To use JSX/TSX without any issues or unexpected behavior, it’s crucial to understand how it works under the hood and the reasons why it’s a useful tool for building UIs.</p>
<p class="normal">Our objective is to write clean JSX/TSX code, maintain it, and have a good understanding of its inner workings, including how it’s translated to JavaScript and the features it provides.</p>
<p class="normal">By understanding the intricacies of JSX/TSX, you can leverage its full potential to build efficient and scalable UIs. We will explore various tips and techniques to help you write better code and avoid common mistakes. By the end of this chapter, you will have a solid grasp of how JSX/TSX works and how to use it effectively in your React applications.</p>
<p class="normal">In this chapter, we will cover the following topics:</p>
<ul>
<li class="bulletList">What is JSX and why should we use it?</li>
<li class="bulletList">What is Babel and how can we use it to write modern JavaScript code?</li>
<li class="bulletList">The main features of JSX and the differences between HTML and JSX.</li>
<li class="bulletList">Best practices to write JSX in an elegant and maintainable way.</li>
<li class="bulletList">How linting, and ESLint in particular, can make our JavaScript code consistent across applications and teams.</li>
<li class="bulletList">The basics of functional programming and why following a functional paradigm will make us write better React components.</li>
</ul>
<h1 class="heading-1" id="_idParaDest-42">Technical requirements</h1>
<p class="normal">To complete this chapter, you will need the following:</p>
<ul>
<li class="bulletList">Node.js 19+</li>
<li class="bulletList">Visual Studio Code</li>
</ul>
<h1 class="heading-1" id="_idParaDest-43">Using JSX</h1>
<p class="normal">In <em class="chapterRef">Chapter 1</em>, we<a id="_idIndexMarker063"/> saw how React changes the concept of separation of concerns, moving the boundaries inside components. We also learned how React uses the elements returned by the components to display the UI on the screen.</p>
<p class="normal">Let’s now look at how we can declare elements inside our components.</p>
<p class="normal">React<a id="_idIndexMarker064"/> provides two ways to define elements. The first one is by using JavaScript functions, and the second one is by using JSX, an optional XML-like syntax. The following is a screenshot of the new official documentation of React.js (<a href="https://react.dev"><span class="url">https://react.dev</span></a>):</p>
<figure class="mediaobject"><img alt="Graphical user interface, website  Description automatically generated" height="585" src="../Images/B18414_03_01.png" width="825"/></figure>
<p class="packt_figref">Figure 3.1: New official documentation site of React.js</p>
<p class="normal">To begin with, JSX is one of the main reasons why people fail to approach React, because looking at the examples on the home page and seeing JavaScript mixed with HTML for the first time can seem strange to most of us.</p>
<p class="normal">As soon as we get used to it, we realize that it is very convenient, precisely because it is similar to HTML and looks very familiar to anyone who has already created UIs on the web. The<a id="_idIndexMarker065"/> opening and closing tags make it easier to represent nested trees of elements, something that would have been unreadable and hard to maintain using plain JavaScript.</p>
<p class="normal">Let’s take a look at JSX in more detail in the following sub-sections.</p>
<h2 class="heading-2" id="_idParaDest-44">Babel</h2>
<p class="normal">Babel is a<a id="_idIndexMarker066"/> popular JavaScript <a id="_idIndexMarker067"/>compiler widely used in the React community. It allows developers to write code using the latest language features, such as JSX and ES6, that may not yet be supported in all browsers. By transpiling the code into the more widely supported ES5, Babel ensures that your application runs smoothly across different browsers.</p>
<p class="normal">To use Babel, you’ll first <a id="_idIndexMarker068"/>need to install the necessary packages. In older versions (Babel 6.x), you would install the <code class="inlineCode">babel-cli</code> package, which included <strong class="keyWord">babel-node</strong> and <strong class="keyWord">babel-core</strong>. However, in <a id="_idIndexMarker069"/>more recent versions, these packages have been separated into individual modules: <code class="inlineCode">@babel/core</code>, <code class="inlineCode">@babel/cli</code>, <code class="inlineCode">@babel/node</code>, and so on.</p>
<p class="normal">To install <a id="_idIndexMarker070"/>Babel, follow these steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Install the required packages globally (although local installations are generally preferred):
        <pre class="programlisting con"><code class="hljs-con">npm install -g @babel/core @babel/node
</code></pre>
</li>
<li class="numberedList">To compile a JavaScript file using Babel, run:
        <pre class="programlisting con"><code class="hljs-con">babel source.js -o output.js
</code></pre>
</li>
<li class="numberedList">Babel is highly configurable, and you can customize it using presets. To install the most common presets, run:
        <pre class="programlisting con"><code class="hljs-con">npm install -g @babel/preset-env @babel/preset-react
</code></pre>
</li>
<li class="numberedList">Create a <code class="inlineCode">.babelrc</code> configuration file in your project’s root directory and add the following content to tell Babel to use<a id="_idIndexMarker071"/> the installed <a id="_idIndexMarker072"/>presets:
        <pre class="programlisting code"><code class="hljs-code">{
  <span class="hljs-string">"presets"</span>: [
    <span class="hljs-string">"@babel/preset-env"</span>,
    <span class="hljs-string">"@babel/preset-react"</span>
  ]
}
</code></pre>
</li>
</ol>
<p class="normal">Now, you can write ES6 and JSX in your source files, and Babel will transpile them into browser-compatible ES5 JavaScript code.</p>
<h2 class="heading-2" id="_idParaDest-45">Creating our first element</h2>
<p class="normal">Now that our<a id="_idIndexMarker073"/> environment supports JSX, let’s explore a basic example: creating <a id="_idIndexMarker074"/>a <code class="inlineCode">div</code> element. Using the <code class="inlineCode">_jsx</code> function, we can write:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">_jsx</span>(<span class="hljs-string">'div'</span>, {})
</code></pre>
<p class="normal">However, using JSX, we can simply write:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> /&gt;</span>
</code></pre>
<p class="normal">This appears similar to regular HTML, but the crucial difference is that we’re writing markup within a <code class="inlineCode">.js</code> file. Keep in mind that JSX is only syntactic sugar and gets transpiled into JavaScript before being executed in the browser.</p>
<p class="normal">When we run Babel, our <code class="inlineCode">&lt;div /&gt;</code> element is translated into <code class="inlineCode">_jsx('div', {})</code>. Remember this when crafting templates.</p>
<p class="normal">Starting from <strong class="keyWord">React 17</strong>, <code class="inlineCode">React.createElement('div')</code> has been deprecated, and the library now uses <code class="inlineCode">react/jsx-runtime</code> internally to render JSX. This means that you no longer need to import the React object to write JSX code. Instead, you can write JSX directly, as shown in the previous example.</p>
<h2 class="heading-2" id="_idParaDest-46">DOM elements and React components</h2>
<p class="normal">JSX<a id="_idIndexMarker075"/> allows us to create both HTML elements and <a id="_idIndexMarker076"/>React components, with the only difference being whether or not they start with a capital letter. For instance, to render an HTML button, we use <code class="inlineCode">&lt;button /&gt;</code>, while to render the <code class="inlineCode">Button</code> component, we use <code class="inlineCode">&lt;Button /&gt;</code>.</p>
<p class="normal">The first button is transpiled into the following:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">_jsx</span>(<span class="hljs-string">'button'</span>, {})
</code></pre>
<p class="normal">The second one is transpiled into the following:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">_jsx</span>(<span class="hljs-title">Button</span>, {})
</code></pre>
<p class="normal">The key difference is that in the first call, we<a id="_idIndexMarker077"/> pass the type of the<a id="_idIndexMarker078"/> DOM element as a string, while in the second call, we pass the component itself. As a result, the component should exist in the scope for it to work properly.</p>
<p class="normal">JSX also supports self-closing tags, which are<a id="_idIndexMarker079"/> useful for keeping the code concise and avoiding unnecessary tag repetition.</p>
<h2 class="heading-2" id="_idParaDest-47">Props</h2>
<p class="normal">JSX is <a id="_idIndexMarker080"/>very convenient when your <a id="_idIndexMarker081"/>DOM elements or React components have props. Using XML is pretty easy to set attributes on elements:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;img src=<span class="hljs-string">"https://www.ranchosanpancho.com/images/logo.png"</span> alt=<span class="hljs-string">"Cabañas San Pancho"</span> /&gt;
</code></pre>
<p class="normal">The equivalent in JavaScript would be as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">_jsx</span>(<span class="hljs-string">"img"</span>, { 
  <span class="hljs-attr">src</span>: <span class="hljs-string">"https://www.ranchosanpancho.com/images/logo.png"</span>, 
  <span class="hljs-attr">alt</span>: <span class="hljs-string">"Cabañas San Pancho"</span> 
})
</code></pre>
<p class="normal">This is far less readable, and even with only a couple of attributes, it is harder to read without a bit of reasoning.</p>
<h2 class="heading-2" id="_idParaDest-48">Children</h2>
<p class="normal">JSX allows <a id="_idIndexMarker082"/>you to define children<a id="_idIndexMarker083"/> to describe the tree of elements and compose complex UIs. A basic example is a link with text inside it, as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">a</span><span class="hljs-tag"> </span><span class="hljs-attr">href</span><span class="hljs-tag">=</span><span class="hljs-string">"https://ranchosanpancho.com"</span><span class="hljs-tag">&gt;</span>Click me!<span class="hljs-tag">&lt;/</span><span class="hljs-name">a</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">This would be transpiled into the following:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">_jsx</span>( 
  <span class="hljs-string">"a"</span>, 
  { <span class="hljs-attr">href</span>: <span class="hljs-string">"https://ranchosanpancho.com"</span> }, 
  <span class="hljs-string">"Click me!"</span> 
)
</code></pre>
<p class="normal">Our link can be enclosed inside a <code class="inlineCode">div</code> element for some layout requirements, and the JSX snippet to achieve that is as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span> 
  <span class="hljs-tag">&lt;</span><span class="hljs-name">a</span><span class="hljs-tag"> </span><span class="hljs-attr">href</span><span class="hljs-tag">=</span><span class="hljs-string">"https://ranchosanpancho.com"</span><span class="hljs-tag">&gt;</span>Click me!<span class="hljs-tag">&lt;/</span><span class="hljs-name">a</span><span class="hljs-tag">&gt;</span> 
<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">The JavaScript equivalent is as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">_jsx</span>( 
  <span class="hljs-string">"div"</span>, 
  <span class="hljs-literal">null</span>, 
  <span class="hljs-title">_jsx</span>( 
    <span class="hljs-string">"a"</span>, 
    { <span class="hljs-attr">href</span>: <span class="hljs-string">"https://ranchosanpancho.com"</span> }, 
    <span class="hljs-string">"Click me!"</span> 
  ) 
)
</code></pre>
<p class="normal">It should now be clear how the <em class="italic">XML-like</em> syntax of JSX makes everything more readable and maintainable, but it is always important to know the JavaScript parallel to our JSX has control over the creation of elements. The good part is that we are not limited to having elements as <a id="_idIndexMarker084"/>children of elements, but we can use <a id="_idIndexMarker085"/>JavaScript expressions, such as functions or variables.</p>
<p class="normal">To do this, we have to enclose the expression within curly braces:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span> 
  Hello, {variable}. 
  I'm a {() =&gt; console.log('Function')}. 
<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span> 
</code></pre>
<p class="normal">The same applies to non-string attributes, as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">a</span><span class="hljs-tag"> </span><span class="hljs-attr">href</span><span class="hljs-tag">=</span><span class="hljs-string">{someFunction()}</span><span class="hljs-tag">&gt;</span>Click me!<span class="hljs-tag">&lt;/</span><span class="hljs-name">a</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">As you see, any variable or function should be enclosed in curly braces.</p>
<h2 class="heading-2" id="_idParaDest-49">Differences with HTML</h2>
<p class="normal">So far, we have <a id="_idIndexMarker086"/>looked at the similarities between JSX and HTML. Let’s now look at the little differences between them and the reasons they exist.</p>
<h3 class="heading-3" id="_idParaDest-50">Attributes</h3>
<p class="normal">We must always keep in <a id="_idIndexMarker087"/>mind that JSX is not a standard language and that it gets transpiled into JavaScript. Because of this, some attributes cannot be used.</p>
<p class="normal">For example, instead of <code class="inlineCode">class</code>, we have to use <code class="inlineCode">className</code>, and instead of <code class="inlineCode">for</code>, we have to use <code class="inlineCode">htmlFor</code>, as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">label</span><span class="hljs-tag"> </span><span class="hljs-attr">className</span><span class="hljs-tag">=</span><span class="hljs-string">"awesome-label"</span><span class="hljs-tag"> </span><span class="hljs-attr">htmlFor</span><span class="hljs-tag">=</span><span class="hljs-string">"name"</span><span class="hljs-tag"> /&gt;</span>
</code></pre>
<p class="normal">The reason for this is that <code class="inlineCode">class</code> and <code class="inlineCode">for</code> are reserved words in JavaScript.</p>
<h3 class="heading-3" id="_idParaDest-51">Style</h3>
<p class="normal">A pretty significant difference is the <a id="_idIndexMarker088"/>way the <code class="inlineCode">style</code> attribute works. We will look at how to use it in more detail in <em class="chapterRef">Chapter 6</em>, <em class="italic">Making Your Components Look Beautiful</em>, but now we will focus on the way it works.</p>
<p class="normal">The <code class="inlineCode">style</code> attribute does not accept a CSS string as the HTML parallel does, but it expects a JavaScript object where the style names are <em class="italic">camelCased</em>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{{</span><span class="hljs-tag"> </span><span class="hljs-attr">backgroundColor:</span><span class="hljs-tag"> '</span><span class="hljs-attr">red</span><span class="hljs-tag">' }} /&gt;</span>
</code></pre>
<p class="normal">As you can see, you can pass an object to the <code class="inlineCode">style</code> prop, meaning you can even have your styles in a separate variable if you want:</p>
<pre class="programlisting code"><code class="hljs-code">const styles = {
  backgroundColor: 'red'
} 
<span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{styles}</span><span class="hljs-tag"> /&gt;</span>
</code></pre>
<p class="normal">This is the best way to have better control of your inline styles.</p>
<h3 class="heading-3" id="_idParaDest-52">Root</h3>
<p class="normal">One important difference with HTML <a id="_idIndexMarker089"/>worth mentioning is that since JSX elements get translated into JavaScript functions, and you cannot return two functions in JavaScript, whenever you have multiple elements at the same level, you are forced to wrap them in a parent.</p>
<p class="normal">Let’s look at a simple example:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> /&gt;</span>
<span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> /&gt;</span>
</code></pre>
<p class="normal">This gives us the following error:</p>
<pre class="programlisting con"><code class="hljs-con">Adjacent JSX elements must be wrapped in an enclosing tag.
</code></pre>
<p class="normal">On the other hand, the following works:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span> 
  <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> /&gt;</span> 
  <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> /&gt;</span> 
<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">Before, React forced you to return an element wrapped with an <code class="inlineCode">&lt;div&gt;</code> element or any other tag; since <strong class="keyWord">React 16.2.0</strong>, it is possible to return an array directly as follows:</p>
<pre class="programlisting code"><code class="hljs-code">return [
  <span class="hljs-tag">&lt;</span><span class="hljs-name">li</span><span class="hljs-tag"> </span><span class="hljs-attr">key</span><span class="hljs-tag">=</span><span class="hljs-string">"1"</span><span class="hljs-tag">&gt;</span>First item<span class="hljs-tag">&lt;/</span><span class="hljs-name">li</span><span class="hljs-tag">&gt;</span>, 
  <span class="hljs-tag">&lt;</span><span class="hljs-name">li</span><span class="hljs-tag"> </span><span class="hljs-attr">key</span><span class="hljs-tag">=</span><span class="hljs-string">"2"</span><span class="hljs-tag">&gt;</span>Second item<span class="hljs-tag">&lt;/</span><span class="hljs-name">li</span><span class="hljs-tag">&gt;</span>, 
  <span class="hljs-tag">&lt;</span><span class="hljs-name">li</span><span class="hljs-tag"> </span><span class="hljs-attr">key</span><span class="hljs-tag">=</span><span class="hljs-string">"3"</span><span class="hljs-tag">&gt;</span>Third item<span class="hljs-tag">&lt;/</span><span class="hljs-name">li</span><span class="hljs-tag">&gt;</span>
]
</code></pre>
<p class="normal">Or you can even return a string directly, as shown in the following code block:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="hljs-string">'Hello World!'</span>
</code></pre>
<p class="normal">Also, React now has a <a id="_idIndexMarker090"/>new feature <a id="_idIndexMarker091"/>called <code class="inlineCode">Fragment</code> that also works as a special wrapper for elements. It can be specified with <code class="inlineCode">React.Fragment</code>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { <span class="hljs-title">Fragment</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">return</span> ( 
  <span class="hljs-tag">&lt;</span><span class="hljs-name">Fragment</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>An h1 heading<span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span> 
    Some text here. 
    <span class="hljs-tag">&lt;</span><span class="hljs-name">h2</span><span class="hljs-tag">&gt;</span>An h2 heading<span class="hljs-tag">&lt;/</span><span class="hljs-name">h2</span><span class="hljs-tag">&gt;</span> 
    More text here.
    Even more text here.
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">Fragment</span><span class="hljs-tag">&gt;</span>
)
</code></pre>
<p class="normal">Or you can use empty tags (<code class="inlineCode">&lt;&gt;&lt;/&gt;</code>):</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> ( 
  <span class="hljs-tag">&lt;&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">ComponentA</span><span class="hljs-tag"> /&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">ComponentB</span><span class="hljs-tag"> /&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">ComponentC</span><span class="hljs-tag"> /&gt;</span>
  <span class="hljs-tag">&lt;/&gt;</span>
)
</code></pre>
<p class="normal"><code class="inlineCode">Fragment</code> won’t<a id="_idIndexMarker092"/> render anything visible on the DOM; it is just a helper tag to wrap your React elements or components.</p>
<h3 class="heading-3" id="_idParaDest-53">Spaces</h3>
<p class="normal">There’s one<a id="_idIndexMarker093"/> thing that could be a little bit tricky in the beginning and, again, it concerns the fact that we should always keep in mind that JSX is not HTML, even if it has XML-like syntax. JSX handles the spaces between text and elements differently from HTML, in a way that’s counter-intuitive.</p>
<p class="normal">Consider the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span> 
  <span class="hljs-tag">&lt;</span><span class="hljs-name">span</span><span class="hljs-tag">&gt;</span>My<span class="hljs-tag">&lt;/</span><span class="hljs-name">span</span><span class="hljs-tag">&gt;</span> 
  name is 
  <span class="hljs-tag">&lt;</span><span class="hljs-name">span</span><span class="hljs-tag">&gt;</span>Carlos<span class="hljs-tag">&lt;/</span><span class="hljs-name">span</span><span class="hljs-tag">&gt;</span> 
<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">In a browser that interprets HTML, this code would give you <code class="inlineCode">My name is Carlos</code>, which is exactly what we expect.</p>
<p class="normal">In JSX, the same code would be rendered as <code class="inlineCode">MynameisCarlos</code>, which is because the three nested lines get transpiled as individual children of the <code class="inlineCode">div</code> element, without taking the spaces into account. A common solution to get the same output is putting a space explicitly between the elements, as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span> 
  <span class="hljs-tag">&lt;</span><span class="hljs-name">span</span><span class="hljs-tag">&gt;</span>My<span class="hljs-tag">&lt;/</span><span class="hljs-name">span</span><span class="hljs-tag">&gt;</span> 
  {' '}
  name is
  {' '} 
  <span class="hljs-tag">&lt;</span><span class="hljs-name">span</span><span class="hljs-tag">&gt;</span>Carlos<span class="hljs-tag">&lt;/</span><span class="hljs-name">span</span><span class="hljs-tag">&gt;</span> 
<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">As you may have noticed, we are using an empty string wrapped inside a JavaScript expression <a id="_idIndexMarker094"/>to force the compiler to apply a space between the elements.</p>
<h3 class="heading-3" id="_idParaDest-54">Boolean attributes</h3>
<p class="normal">A couple more <a id="_idIndexMarker095"/>things are worth mentioning before really starting regarding the way you define Boolean attributes in JSX. </p>
<p class="normal">If you set an attribute without a value, JSX assumes that its value is <code class="inlineCode">true</code>, following the same behavior as the HTML <code class="inlineCode">disabled</code> attribute, for example.</p>
<p class="normal">This means that if we want to set an attribute to <code class="inlineCode">false</code>, we have to declare it explicitly as <code class="inlineCode">false</code>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">disabled</span><span class="hljs-tag"> /&gt;</span> 
_jsx("button", { disabled: true })
</code></pre>
<p class="normal">The following is another example of the Boolean attribute:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">disabled</span><span class="hljs-tag">=</span><span class="hljs-string">{false}</span><span class="hljs-tag"> /&gt;</span> 
_jsx("button", { disabled: false })
</code></pre>
<p class="normal">This can be confusing in the beginning, because we may think that omitting an attribute would mean <code class="inlineCode">false</code>, but it is not like that. With React, we should always be explicit to avoid confusion.</p>
<h2 class="heading-2" id="_idParaDest-55">Spread attributes</h2>
<p class="normal">An important feature<a id="_idIndexMarker096"/> is the <code class="inlineCode">spread attribute</code> operator (<code class="inlineCode">...</code>), which comes<a id="_idIndexMarker097"/> from the rest/spread properties for ECMAScript “proposal” and is very convenient whenever we want to pass all the attributes of a JavaScript object to an element.</p>
<p class="normal">A common practice that leads to fewer bugs is not to pass entire JavaScript objects down to children by reference, but to use their primitive values, which can be easily validated, making components more robust and error-proof.</p>
<p class="normal">Let’s see how it works:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> attrs = { 
  <span class="hljs-attr">id</span>: <span class="hljs-string">'myId'</span>,
  <span class="hljs-attr">className</span>: <span class="hljs-string">'myClass'</span>
}
<span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> {</span><span class="hljs-attr">...attrs</span><span class="hljs-tag">} /&gt;</span>
</code></pre>
<p class="normal">The preceding<a id="_idIndexMarker098"/> code gets transpiled into <a id="_idIndexMarker099"/>the following:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> attrs = { 
  <span class="hljs-attr">id</span>: <span class="hljs-string">'myId'</span>,
  <span class="hljs-attr">className</span>: <span class="hljs-string">'</span><span class="hljs-string">myClass'</span>
} 
<span class="hljs-keyword">return</span> <span class="hljs-title">_jsx</span>(<span class="hljs-string">'div'</span>, attrs)
</code></pre>
<h2 class="heading-2" id="_idParaDest-56">Template literals</h2>
<p class="normal"><code class="inlineCode">Template</code><strong class="keyWord"> </strong>literals are<a id="_idIndexMarker100"/> string literals that allow for embedded <a id="_idIndexMarker101"/>expressions, multiline strings, and string interpolation. They are enclosed by the backtick (``) character instead of single or double quotes.</p>
<p class="normal">One of the most useful features of template literals is the ability to include placeholders using the dollar sign and curly braces <code class="inlineCode">(${expression}</code>). This allows us to easily interpolate variables or complex expressions into our string templates. Here’s an example:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> name = <span class="hljs-string">'Carlos'</span>
<span class="hljs-keyword">const</span> age = <span class="hljs-number">35</span>
<span class="hljs-keyword">const</span> message = <span class="hljs-string">`Hello, my name is </span><span class="hljs-subst">${name}</span><span class="hljs-string"> and I am </span><span class="hljs-subst">${age}</span><span class="hljs-string"> years old.`</span>
<span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(message)
</code></pre>
<p class="normal">This will log the following output:</p>
<pre class="programlisting con"><code class="hljs-con">Hello, my name is Carlos and I am 35 years old.
</code></pre>
<p class="normal">In addition to string interpolation, template literals also support multiline strings, making it easier to write and read complex strings without needing to concatenate multiple strings with the plus (<code class="inlineCode">+</code>) operator.</p>
<h2 class="heading-2" id="_idParaDest-57">Common patterns</h2>
<p class="normal">Now that we know how <a id="_idIndexMarker102"/>JSX works and can master it, we are ready to see how to use it in the right way following some useful conventions and techniques.</p>
<h3 class="heading-3" id="_idParaDest-58">Multiline</h3>
<p class="normal">Let’s start<a id="_idIndexMarker103"/> with a very simple one. As stated previously, one of the main reasons we should prefer JSX over React’s <code class="inlineCode">_jsx</code> function is because of its XML-like syntax, and because balanced opening and closing tags are perfect to represent a tree of nodes.</p>
<p class="normal">Therefore, we should try to use it in the right way and get the most out of it. One example is as follows; whenever we have nested elements, we should always go multiline:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span> 
  <span class="hljs-tag">&lt;</span><span class="hljs-name">Header</span><span class="hljs-tag"> /&gt;</span> 
  <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span> 
    <span class="hljs-tag">&lt;</span><span class="hljs-name">Main</span><span class="hljs-tag"> </span><span class="hljs-attr">content</span><span class="hljs-tag">=</span><span class="hljs-string">{...}</span><span class="hljs-tag"> /&gt;</span> 
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span> 
<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">This is preferable to the following:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;div&gt;<span class="hljs-tag">&lt;</span><span class="hljs-name">Header</span><span class="hljs-tag"> /&gt;&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;&lt;</span><span class="hljs-name">Main</span><span class="hljs-tag"> </span><span class="hljs-attr">content</span><span class="hljs-tag">=</span><span class="hljs-string">{...}</span><span class="hljs-tag"> /&gt;&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>&lt;/div&gt;
</code></pre>
<p class="normal">The exception is if the children are not elements such as text or variables. In that case, it makes sense to remain on the same line and avoid adding noise to the markup, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;div&gt; 
  <span class="hljs-tag">&lt;</span><span class="hljs-name">Alert</span><span class="hljs-tag">&gt;</span>{message}<span class="hljs-tag">&lt;/</span><span class="hljs-name">Alert</span><span class="hljs-tag">&gt;</span> 
  <span class="hljs-tag">&lt;</span><span class="hljs-name">Button</span><span class="hljs-tag">&gt;</span>Close<span class="hljs-tag">&lt;/</span><span class="hljs-name">Button</span><span class="hljs-tag">&gt;</span> 
&lt;/div&gt;
</code></pre>
<p class="normal">Always remember to wrap your elements inside parentheses when you write them on multiple lines. JSX always gets replaced by functions, and functions written on a new line can give you an unexpected result because of automatic semicolon insertion. Suppose, for example, that you are returning JSX from your render method, which is how you create UIs in React.</p>
<p class="normal">The following example works fine because the <code class="inlineCode">div</code> element is on the same line as the <code class="inlineCode">return</code>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> /&gt;</span>
</code></pre>
<p class="normal">The following, however, is not right:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return </span>
  <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> /&gt;</span>
</code></pre>
<p class="normal">The reason for this is that you would then have the following:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span>
<span class="hljs-title">_jsx</span>(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>)
</code></pre>
<p class="normal">This is why<a id="_idIndexMarker104"/> you have to wrap the statement in parentheses, as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> ( 
  <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> /&gt;</span> 
)
</code></pre>
<h3 class="heading-3" id="_idParaDest-59">Multi-properties</h3>
<p class="normal">A common<a id="_idIndexMarker105"/> problem in writing JSX comes when an element has multiple attributes. One solution is to write all the attributes on the same line, but this would lead to very long lines that we do not want in our code (see the following section for how to enforce coding style guides).</p>
<p class="normal">A common solution is to write each attribute on a new line, with one level of indentation, and then align the closing bracket with the opening tag:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span>
<span class="hljs-tag">  </span><span class="hljs-attr">foo</span><span class="hljs-tag">=</span><span class="hljs-string">"bar"</span><span class="hljs-tag"> </span>
<span class="hljs-tag">  </span><span class="hljs-attr">veryLongPropertyName</span><span class="hljs-tag">=</span><span class="hljs-string">"</span><span class="hljs-string">baz"</span><span class="hljs-tag"> </span>
<span class="hljs-tag">  </span><span class="hljs-attr">onSomething</span><span class="hljs-tag">=</span><span class="hljs-string">{this.handleSomething}</span><span class="hljs-tag"> </span>
<span class="hljs-tag">/&gt;</span>
</code></pre>
<h3 class="heading-3" id="_idParaDest-60">Conditionals</h3>
<p class="normal">Things get <a id="_idIndexMarker106"/>more interesting when we start working with <code class="inlineCode">conditionals</code>, for example, if we want to render some components only when certain conditions are matched. The fact that we can use JavaScript in our conditions is a big plus, but there are many ways to express conditions in JSX, and it is important to understand the benefits and problems of each one of these to write code that is both readable and maintainable.</p>
<p class="normal">Suppose we want to show a logout button only if the user is currently logged in to our application.</p>
<p class="normal">A simple snippet to start with is as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> button
  
<span class="hljs-keyword">if</span> (isLoggedIn) { 
  button = <span class="hljs-tag">&lt;</span><span class="hljs-name">LogoutButton</span><span class="hljs-tag"> /&gt;</span>
} 
  
<span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>{button}<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">This works, but it is not very readable, especially if there are multiple components and multiple conditions.</p>
<p class="normal">In JSX, we can use an inline condition:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;div&gt; 
  {isLoggedIn &amp;&amp; <span class="hljs-tag">&lt;</span><span class="hljs-name">LoginButton</span><span class="hljs-tag"> /&gt;</span>} 
&lt;/div&gt;
</code></pre>
<p class="normal">This works because if the condition is <code class="inlineCode">false</code>, nothing gets rendered, but if the condition is <code class="inlineCode">true</code>, the <code class="inlineCode">createElement</code> function of <code class="inlineCode">LoginButton</code> gets called, and the element is returned to compose the resulting tree.</p>
<p class="normal">If the condition <a id="_idIndexMarker107"/>has an alternative (the classic <code class="inlineCode">if...else</code> statement) and we want, for example, to show a logout button if the user is logged in and a login button otherwise, we can use JavaScript’s <code class="inlineCode">if...else</code> statement as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> button
<span class="hljs-keyword">if</span> (isLoggedIn) { 
  button = <span class="hljs-tag">&lt;</span><span class="hljs-name">LogoutButton</span><span class="hljs-tag"> /&gt;</span>
} <span class="hljs-keyword">else</span> { 
  button = <span class="hljs-tag">&lt;</span><span class="hljs-name">LoginButton</span><span class="hljs-tag"> /&gt;</span>
} 
  
<span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>{button}<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">Alternatively, and<a id="_idIndexMarker108"/> better still, we can use a ternary condition that makes the code more compact:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;div&gt; 
  {isLoggedIn ? <span class="hljs-tag">&lt;</span><span class="hljs-name">LogoutButton</span><span class="hljs-tag"> /&gt;</span> : <span class="hljs-tag">&lt;</span><span class="hljs-name">LoginButton</span><span class="hljs-tag"> /&gt;</span>} 
&lt;/div&gt;
</code></pre>
<p class="normal">You can find the ternary condition used in popular repositories, such as the Redux real-world example (<a href="https://github.com/reactjs/redux/blob/master/examples/real-world/src/components/List.js#L28"><span class="url">https://github.com/reactjs/redux/blob/master/examples/real-world/src/components/List.js#L28</span></a>), where the ternary is used to show a <code class="inlineCode">Loading</code> label if the component is fetching the data or <code class="inlineCode">Load More</code> inside a button depending on the value of the <code class="inlineCode">isFetching</code> variable:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;button [...]&gt; 
  {isFetching ? <span class="hljs-string">'Loading...'</span> : <span class="hljs-string">'Load More'</span>} 
&lt;/button&gt;
</code></pre>
<p class="normal">Let’s now look at the best solution for when things get more complicated and, for example, we have to check more than one variable to determine whether to render a component or not:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;div&gt;
  {dataIsReady &amp;&amp; (isAdmin || userHasPermissions) &amp;&amp; 
    <span class="hljs-tag">&lt;</span><span class="hljs-name">SecretData</span><span class="hljs-tag"> /&gt;</span>
  }
&lt;/div&gt;
</code></pre>
<p class="normal">In this case, it is clear that using the inline condition is a good solution, but the readability is strongly impacted. Instead, we can create a helper function inside our component and use it in JSX to verify the condition:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">MyComponent</span> = (<span class="hljs-params">{ dataIsReady, isAdmin, userHasPermissions }</span>) =&gt; {
  <span class="hljs-keyword">const</span> <span class="hljs-title">canShowSecretData</span> = () =&gt; { 
    <span class="hljs-keyword">return</span> dataIsReady &amp;&amp; (isAdmin || userHasPermissions)
  } 
  
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span> 
      {canShowSecretData() &amp;&amp; <span class="hljs-tag">&lt;</span><span class="hljs-name">SecretData</span><span class="hljs-tag"> /&gt;</span>} 
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  )
}
</code></pre>
<p class="normal">As you can see, this change makes the code more readable and the condition more explicit. If you look at this code in 6 months, you will still find it clear just by reading the name of the function.</p>
<p class="normal">The same applies to computed properties. Suppose you have two single properties for currency and value. Instead of creating the price string inside <code class="inlineCode">render</code>, you can create a function:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">MyComponent</span> = (<span class="hljs-params">{ currency, value }</span>) =&gt; {
     <span class="hljs-keyword">const</span> <span class="hljs-title">getPrice</span> = () =&gt; { 
    <span class="hljs-keyword">return</span> <span class="hljs-string">`</span><span class="hljs-subst">${currency}${value}</span><span class="hljs-string">`</span>
  }
   
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>{getPrice()}<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
}
</code></pre>
<p class="normal">This is better<a id="_idIndexMarker109"/> because it is isolated, and you can easily test it if it contains logic.</p>
<p class="normal">Going back to conditional statements, we can create a custom component and call it <code class="inlineCode">RenderIf</code> to render our components conditionally:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> <span class="hljs-title">React</span>, { <span class="hljs-variable">FC</span>, <span class="hljs-title">ReactElement</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
interface <span class="hljs-title">Props</span> {
  <span class="hljs-attr">children</span>: <span class="hljs-title">ReactElement</span> | string
  isTrue?: <span class="hljs-title">Boolean</span>
  isFalse?: <span class="hljs-title">Boolean</span>
}
<span class="hljs-keyword">const</span> <span class="hljs-title">RenderIf</span>: <span class="hljs-variable">FC</span>&lt;<span class="hljs-title">Props</span>&gt; = <span class="hljs-function">(</span><span class="hljs-params">{ children, isTrue, isFalse }</span><span class="hljs-function">) =&gt;</span> {
  <span class="hljs-keyword">if</span> (isTrue === <span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;&gt;</span>{children}<span class="hljs-tag">&lt;/&gt;</span>
  }
  <span class="hljs-keyword">if</span> (isFalse === <span class="hljs-literal">false</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;&gt;</span>{children}<span class="hljs-tag">&lt;/&gt;</span>
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title">RenderIf</span>
</code></pre>
<p class="normal">We can then <a id="_idIndexMarker110"/>easily use it in our projects, as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> <span class="hljs-title">RenderIf</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./RenderIf'</span>
<span class="hljs-keyword">const</span> <span class="hljs-title">MyComponent</span> = (<span class="hljs-params">{ dataIsReady, isAdmin, userHasPermissions }</span>) =&gt; {  
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span> 
      <span class="hljs-tag">&lt;</span><span class="hljs-name">RenderIf</span><span class="hljs-tag"> </span><span class="hljs-attr">isTrue</span><span class="hljs-tag">=</span><span class="hljs-string">{dataIsReady</span><span class="hljs-tag"> &amp;&amp; (</span><span class="hljs-attr">isAdmin</span><span class="hljs-tag"> || </span><span class="hljs-attr">userHasPermissions</span><span class="hljs-tag">)}&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-name">SecretData</span><span class="hljs-tag"> /&gt;</span>
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">RenderIf</span><span class="hljs-tag">&gt;</span> 
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  )
}
</code></pre>
<h3 class="heading-3" id="_idParaDest-61">Loops</h3>
<p class="normal">A very common operation in <a id="_idIndexMarker111"/>UI development is to display lists of items. When it comes to showing lists, using JavaScript as a template language is a very good idea.</p>
<p class="normal">If we write a function that returns an array inside our JSX template, each element of the array gets compiled into an element.</p>
<p class="normal">As we have seen before, we can use any JavaScript expressions inside curly braces, and the most common way to generate an array of elements, given an array of objects, is to use <code class="inlineCode">map</code>.</p>
<p class="normal">Let’s dive into a real-world example. Suppose you have a list of users, each one with a <code class="inlineCode">name</code> property attached to it.</p>
<p class="normal">To create an unordered list to show the users, you can do the following:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span> 
  {users.map(user =&gt; <span class="hljs-tag">&lt;</span><span class="hljs-name">li</span><span class="hljs-tag">&gt;</span>{user.name}<span class="hljs-tag">&lt;/</span><span class="hljs-name">li</span><span class="hljs-tag">&gt;</span>)} 
<span class="hljs-tag">&lt;/</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">This snippet is incredibly simple and incredibly powerful at the same time, where the power of HTML and JavaScript converge.</p>
<h3 class="heading-3" id="_idParaDest-62">Sub-rendering</h3>
<p class="normal">It is worth <a id="_idIndexMarker112"/>stressing that we always want to keep our components very small and our render methods very clean and simple.</p>
<p class="normal">However, that is not an easy goal, especially when you are creating an application iteratively, and in the first iteration, you are not sure exactly how to split the components into smaller ones. So, what should we be doing when the <code class="inlineCode">render</code> method becomes too big to maintain? One solution is to split it into smaller functions in a way that lets us keep all the logic in the same component.</p>
<p class="normal">Let’s look at an example:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">renderUserMenu</span> = () =&gt; { 
  <span class="hljs-comment">// JSX for user menu </span>
} 
   
<span class="hljs-keyword">const</span> <span class="hljs-title">renderAdminMenu</span> = () =&gt; { 
  <span class="hljs-comment">// JSX for admin menu </span>
} 
   
<span class="hljs-keyword">return</span> ( 
  <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span> 
    <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>Welcome back!<span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span> 
    {userExists &amp;&amp; renderUserMenu()} 
    {userIsAdmin &amp;&amp; renderAdminMenu()} 
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span> 
)
</code></pre>
<p class="normal">This is not always considered best practice because it seems more obvious to split the component into smaller ones. However, sometimes it helps to keep the render method cleaner. For example, in the Redux real-world examples, a sub-render method is used to render the <em class="italic">load more</em> button.</p>
<p class="normal">Now that we are JSX power users, it is time to move on and see how to follow a style guide within our code to make it consistent.</p>
<h1 class="heading-1" id="_idParaDest-63">Styling code</h1>
<p class="normal">In this section, you will learn how to<a id="_idIndexMarker113"/> implement <strong class="keyWord">EditorConfig</strong> and <strong class="keyWord">ESLint</strong> to<a id="_idIndexMarker114"/> improve your code quality by <a id="_idIndexMarker115"/>validating your code style. It is important to have a standard code style in your team and avoid using different code styles.</p>
<h2 class="heading-2" id="_idParaDest-64">EditorConfig</h2>
<p class="normal"><strong class="keyWord">EditorConfig</strong> helps <a id="_idIndexMarker116"/>developers to maintain consistent coding styles between different IDEs.</p>
<p class="normal">EditorConfig is supported by a lot of editors. You can check whether your editor is supported or not on the<a id="_idIndexMarker117"/> official website, <a href="https://www.editorconfig.org"><span class="url">https://www.editorconfig.org</span></a>.</p>
<p class="normal">You need to create a file called <code class="inlineCode">.editorconfig</code> in your <code class="inlineCode">root</code> directory – the configuration I use is this one:</p>
<pre class="programlisting code"><code class="hljs-code">root = <span class="hljs-literal">true</span>
[*]
indent_style = space 
indent_size = <span class="hljs-number">2</span>
end_of_line = lf
charset = utf-<span class="hljs-number">8</span> 
trim_trailing_whitespace = <span class="hljs-literal">true</span> 
insert_final_newline = <span class="hljs-literal">true</span>
[*.<span class="hljs-property">html</span>] 
indent_size = <span class="hljs-number">4</span>
[*.<span class="hljs-property">css</span>] 
indent_size = <span class="hljs-number">4</span>
[*.<span class="hljs-property">md</span>]
trim_trailing_whitespace = <span class="hljs-literal">false</span>
</code></pre>
<p class="normal">You can affect all the files with <code class="inlineCode">[*]</code>, and specific files with <code class="inlineCode">[.extension]</code>.</p>
<h2 class="heading-2" id="_idParaDest-65">Prettier</h2>
<p class="normal"><strong class="keyWord">Prettier</strong> is an<a id="_idIndexMarker118"/> opinionated code formatter, supported by many languages, that can be integrated with most editors. This plugin is really useful because you can format the code on saving and you don’t need to discuss the code style in code reviews, which will save you a lot of time and energy.</p>
<p class="normal">If you work with Visual Studio Code, you have to install the Prettier extension first:</p>
<figure class="mediaobject"><img alt="Text, website  Description automatically generated" height="157" src="../Images/B18414_03_02.png" width="825"/></figure>
<p class="packt_figref">Figure 3.2: Prettier – Code formatter</p>
<p class="normal">Then, if you want to configure the option to format when you save a file, you need to go to <strong class="screenText">Settings</strong>, search for <code class="inlineCode">Format</code> <code class="inlineCode">on</code> <code class="inlineCode">Save</code>, and check that option:</p>
<figure class="mediaobject"><img alt="Text  Description automatically generated" height="229" src="../Images/B18414_03_03.png" width="825"/></figure>
<p class="packt_figref">Figure 3.3: Configuring option to format when saving a file </p>
<p class="normal">This will affect all your<a id="_idIndexMarker119"/> projects because it is a global setting. If you want to apply this option just in a specific project, you have to create a <code class="inlineCode">.vscode</code> folder inside your project and a <code class="inlineCode">settings.json</code> file with the following code:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"editor.defaultFormatter"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"esbenp.prettier-vscode"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"editor.formatOnSave"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p class="normal">Then you can configure the options you want in your <code class="inlineCode">.prettierrc</code> file – this is the configuration I normally use:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"arrowParens"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"avoid"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"bracketSpacing"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"jsxSingleQuote"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"printWidth"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">100</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"quoteProps"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"as-needed"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"semi"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"</span><span class="hljs-attr">singleQuote"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"tabWidth"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"trailingComma"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"none"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"useTabs"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p class="normal">This will help you or your team to standardize the code style.</p>
<h2 class="heading-2" id="_idParaDest-66">ESLint</h2>
<p class="normal">Writing<a id="_idIndexMarker120"/> high-quality code is always our goal, but errors can still occur, and spending hours hunting down a bug caused by a simple typo can be incredibly frustrating. Thankfully, there are tools that can help us catch these errors as soon as we type them, allowing us to avoid simple syntactical mistakes.</p>
<p class="normal">If you’re coming from a statically typed language like C#, you may be used to getting warnings inside your IDE. In the JavaScript world, the popular tool for linting code is ESLint. ESLint is an open-source project released in 2013 that is highly configurable and extensible.</p>
<p class="normal">In the fast-paced JavaScript ecosystem, where libraries and techniques change frequently, it’s crucial to have a tool that can be easily extended with plugins and rules that can be enabled or disabled as needed. Additionally, with transpilers like Babel and experimental language features that aren’t yet part of the standard JavaScript version, we need to be able to tell our linter which rules we’re following in our source files. A linter not only helps us catch errors sooner, but it also enforces common coding style guides, which is particularly important in large teams where consistency is key.</p>
<p class="normal">In the following sections, we’ll take a closer look at ESLint and how it can help us write better, more consistent code.</p>
<h3 class="heading-3" id="_idParaDest-67">Installation</h3>
<p class="normal">First of all, we have to install <a id="_idIndexMarker121"/>ESLint and some plugins as follows:</p>
<pre class="programlisting con"><code class="hljs-con">npm install -g eslint eslint-config-airbnb eslint-config-prettier eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-prettier eslint-plugin-react
</code></pre>
<p class="normal">Once the executable is installed, we can run it with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">eslint source.ts
</code></pre>
<p class="normal">The output will tell us if there are errors within the file.</p>
<p class="normal">When we install and run it for the first time, we do not see any errors because it is completely configurable, and it does not come with any default rules.</p>
<h3 class="heading-3" id="_idParaDest-68">Configuration</h3>
<p class="normal">Let’s start configuring <a id="_idIndexMarker122"/>ESLint. It can be configured using a <code class="inlineCode">.eslintrc</code> file that lives in the root folder of the project. To add some rules, let’s create a <code class="inlineCode">.eslintrc</code> file configured for TypeScript and add one basic rule:</p>
<pre class="programlisting code"><code class="hljs-code">{
  <span class="hljs-string">"parser"</span>: <span class="hljs-string">"@typescript-eslint/parser"</span>,
  <span class="hljs-string">"plugins"</span>: [<span class="hljs-string">"@typescript-eslint"</span>, <span class="hljs-string">"prettier"</span>],
  <span class="hljs-string">"extends"</span>: [
    <span class="hljs-string">"airbnb"</span>,
    <span class="hljs-string">"eslint:recommended"</span>,
    <span class="hljs-string">"plugin:@typescript-eslint/eslint-recommended"</span>,
    <span class="hljs-string">"plugin:@typescript-eslint/recommended"</span>,
    <span class="hljs-string">"plugin:prettier/recommended"</span>
  ],
  <span class="hljs-string">"settings"</span>: {
    <span class="hljs-string">"import/extensions"</span>: [<span class="hljs-string">".js"</span>, <span class="hljs-string">".jsx"</span>, <span class="hljs-string">".ts"</span>, <span class="hljs-string">".tsx"</span>],
    <span class="hljs-string">"import/parsers"</span>: {
      <span class="hljs-string">"@typescript-eslint/parser"</span>: [<span class="hljs-string">".ts"</span>, <span class="hljs-string">".tsx"</span>]
    },
    <span class="hljs-string">"import/resolver"</span>: {
      <span class="hljs-string">"node"</span>: {
        <span class="hljs-string">"extensions"</span>: [<span class="hljs-string">".js"</span>, <span class="hljs-string">".jsx"</span>, <span class="hljs-string">".ts"</span>, <span class="hljs-string">".tsx"</span>]
      }
    }
  },
  <span class="hljs-string">"rules"</span>: {
    <span class="hljs-string">"semi"</span>: [<span class="hljs-number">2</span>, <span class="hljs-string">"never"</span>]
  }
}
</code></pre>
<p class="normal">This configuration file needs a bit of explanation: <code class="inlineCode">"semi"</code> is the name of the rule and <code class="inlineCode">[2, "never"]</code> is the value. It is not very intuitive the first time you see it.</p>
<p class="normal">ESLint rules have three levels that determine the severity of the problem:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><code class="inlineCode">off</code> (or <code class="inlineCode">0</code>): The rule is disabled.</li>
<li class="numberedList"><code class="inlineCode">warn</code> (or <code class="inlineCode">1</code>): The rule is a warning.</li>
<li class="numberedList"><code class="inlineCode">error</code> (or <code class="inlineCode">2</code>): The rule throws an error.</li>
</ol>
<p class="normal">We are using the value <code class="inlineCode">2</code> because we want ESLint to throw an error every time our code does not follow the rule. The second parameter tells ESLint that we want the semicolon to never be used (the opposite is <em class="italic">always</em>). ESLint and its plugins are very well documented, and for any single rule, you can find the description of the rule and some examples of when it passes and when it fails.</p>
<p class="normal">Now create an <code class="inlineCode">index.ts</code> file with the following content:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> foo = <span class="hljs-string">'bar'</span>;
</code></pre>
<p class="normal">If we run <code class="inlineCode">eslint index.js</code>, we get the following:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">Extra</span> semicolon (semi) 
</code></pre>
<p class="normal">This is great; we set up the linter and it is helping us follow our first rule.</p>
<p class="normal">Here are other rules that I <a id="_idIndexMarker123"/>prefer to turn off or change:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">"rules"</span>: {
    <span class="hljs-string">"semi"</span>: [<span class="hljs-number">2</span>, <span class="hljs-string">"never"</span>],
    <span class="hljs-string">"@typescript-eslint/class-name-casing"</span>: <span class="hljs-string">"off"</span>,
    <span class="hljs-string">"@typescript-eslint/interface-name-prefix"</span>: <span class="hljs-string">"off"</span>,
    <span class="hljs-string">"@typescript-eslint/member-delimiter-style"</span>: <span class="hljs-string">"off"</span>,
    <span class="hljs-string">"@typescript-eslint/no-var-requires"</span>: <span class="hljs-string">"off"</span>,
    <span class="hljs-string">"@typescript-eslint/ban-ts-ignore"</span>: <span class="hljs-string">"off"</span>,
    <span class="hljs-string">"@typescript-eslint/no-use-before-define"</span>: <span class="hljs-string">"off"</span>,
    <span class="hljs-string">"@typescript-eslint/ban-ts-comment"</span>: <span class="hljs-string">"off"</span>,
    <span class="hljs-string">"@typescript-eslint/explicit-module-boundary-types"</span>: <span class="hljs-string">"off"</span>,
    <span class="hljs-string">"no-restricted-syntax"</span>: <span class="hljs-string">"off"</span>,
    <span class="hljs-string">"no-use-before-define"</span>: <span class="hljs-string">"off"</span>,
    <span class="hljs-string">"import/extensions"</span>: <span class="hljs-string">"off"</span>,
    <span class="hljs-string">"import/prefer-default-export"</span>: <span class="hljs-string">"off"</span>,
    <span class="hljs-string">"max-len"</span>: [
      <span class="hljs-string">"error"</span>,
      {
        <span class="hljs-string">"code"</span>: <span class="hljs-number">100</span>,
        <span class="hljs-string">"tabWidth"</span>: <span class="hljs-number">2</span>
      }
    ],
    <span class="hljs-string">"no-param-reassign"</span>: <span class="hljs-string">"off"</span>,
    <span class="hljs-string">"no-underscore-dangle"</span>: <span class="hljs-string">"off"</span>,
    <span class="hljs-string">"react/jsx-filename-extension"</span>: [
      <span class="hljs-number">1</span>,
      {
        <span class="hljs-string">"extensions"</span>: [<span class="hljs-string">".tsx"</span>]
      }
    ],
    <span class="hljs-string">"import/no-unresolved"</span>: <span class="hljs-string">"off"</span>,
    <span class="hljs-string">"consistent-return"</span>: <span class="hljs-string">"off"</span>,
    <span class="hljs-string">"jsx-a11y/anchor-is-valid"</span>: <span class="hljs-string">"off"</span>,
    <span class="hljs-string">"sx-a11y/click-events-have-key-events"</span>: <span class="hljs-string">"off"</span>,
    <span class="hljs-string">"jsx-a11y/no-noninteractive-element-interactions"</span>: <span class="hljs-string">"off"</span>,
    <span class="hljs-string">"jsx-a11y/click-events-have-key-events"</span>: <span class="hljs-string">"off"</span>,
    <span class="hljs-string">"jsx-a11y/no-static-element-interactions"</span>: <span class="hljs-string">"off"</span>,
    <span class="hljs-string">"react/jsx-props-no-spreading"</span>: <span class="hljs-string">"off"</span>,
    <span class="hljs-string">"jsx-a11y/label-has-associated-control"</span>: <span class="hljs-string">"off"</span>,
    <span class="hljs-string">"react/jsx-one-expression-per-line"</span>: <span class="hljs-string">"off"</span>,
    <span class="hljs-string">"no-prototype-builtins"</span>: <span class="hljs-string">"off"</span>,
    <span class="hljs-string">"no-nested-ternary"</span>: <span class="hljs-string">"off"</span>,
    <span class="hljs-string">"prettier/prettier"</span>: [
      <span class="hljs-string">"error"</span>,
      {
        <span class="hljs-string">"endOfLine"</span>: <span class="hljs-string">"auto"</span>
      }
    ]
  }
</code></pre>
<h3 class="heading-3" id="_idParaDest-69">Git Hooks</h3>
<p class="normal">To avoid having unlinted code in our repository, what we can do is add ESLint at one point of our process using <a id="_idIndexMarker124"/>Git Hooks. For example, we can use <code class="inlineCode">husky</code> to run our linter in a Git Hook called <code class="inlineCode">pre-commit</code>, and it is also useful to run our unit tests on the Hook called <code class="inlineCode">pre-push</code>.</p>
<p class="normal">To install <code class="inlineCode">husky</code>, you need to run the following command:</p>
<pre class="programlisting con"><code class="hljs-con">npm install --save-dev husky
</code></pre>
<p class="normal">Then, in our <code class="inlineCode">package.json</code> file, we can add this node to configure the tasks we want to run in the Git Hooks.</p>
<p class="normal">Edit the <code class="inlineCode">package.json &gt;</code> <code class="inlineCode">prepare</code> script and run it once:</p>
<pre class="programlisting con"><code class="hljs-con">  npm pkg set scripts.prepare="husky install"
  npm run prepare
</code></pre>
<p class="normal">Add a hook:</p>
<pre class="programlisting con"><code class="hljs-con">  npx husky add .husky/pre-commit "npm run lint"
  git add .husky/pre-commit
</code></pre>
<p class="normal">Make a commit:</p>
<pre class="programlisting con"><code class="hljs-con">  git commit -m "Keep calm and commit"
<span class="hljs-con-meta">  # </span>`npm run lint` will run every time you commit
</code></pre>
<p class="normal">There is a special option (flag) for the ESlint command called <code class="inlineCode">--fix</code> – with this option, ESLint will try to <a id="_idIndexMarker125"/>fix all our linter errors automatically (not all of them). Be careful with this option because sometimes it can affect a little bit of our code style. Another useful flag is <code class="inlineCode">--ext</code> to specify the extensions of the files we want to validate – in this case, just the <code class="inlineCode">.tsx</code> and <code class="inlineCode">.ts</code> files.</p>
<p class="normal">In the next section, you will learn about how <strong class="keyWord">functional programming</strong> (<strong class="keyWord">FP</strong>) works and topics such as first-class objects, purity, immutability, currying, and composition.</p>
<h1 class="heading-1" id="_idParaDest-70">Functional programming</h1>
<p class="normal">In addition to following <a id="_idIndexMarker126"/>best practices and using a linter to catch errors and enforce consistency, another way to clean up our code is to adopt an <strong class="keyWord">FP</strong> style.</p>
<p class="normal">As we discussed in <em class="chapterRef">Chapter 1, </em><em class="italic">Taking Your First Steps with React</em>, React’s declarative programming approach makes our code more readable. FP is a declarative paradigm as well, where side effects are avoided, and data is considered immutable to make the code easier to maintain and reason about.</p>
<p class="normal">While we won’t cover FP in depth in this section, we’ll introduce some concepts commonly used in React that you should be aware of.</p>
<p class="normal">FP principles, such as immutability, pure functions, and higher-order functions, can help us write more maintainable and testable code. By treating our data as immutable, we can avoid side effects and make it easier to reason about the flow of our application. Pure functions, which always return the same output for the same input, help us avoid unintended side effects and make our code easier to test. Higher-order functions, which take functions as arguments and/or return functions as output, can help us create more modular and reusable code.</p>
<p class="normal">By adopting an FP style, we<a id="_idIndexMarker127"/> can write more declarative and less imperative code, making our components easier to read and reason about.</p>
<h2 class="heading-2" id="_idParaDest-71">First-class functions</h2>
<p class="normal">JavaScript has<a id="_idIndexMarker128"/> first-class functions because they are <a id="_idIndexMarker129"/>treated like any other variable, meaning you can pass a function as a parameter to other functions, or it can be returned by another function and be assigned as a value to a variable.</p>
<p class="normal">This allows us to introduce the <a id="_idIndexMarker130"/>concept of <strong class="keyWord">Higher-Order Functions</strong> (<strong class="keyWord">HoFs</strong>). HoFs are functions that take a function as a parameter, and optionally some other parameters, and return a function. The returned function is usually enhanced with some special behaviors.</p>
<p class="normal">Let’s look at an example:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">add</span> = (<span class="hljs-params">x, y</span>) =&gt; x + y
<span class="hljs-keyword">const</span> <span class="hljs-title">log</span> = fn =&gt; <span class="hljs-function">(</span><span class="hljs-params">...args</span><span class="hljs-function">) =&gt;</span> { 
  <span class="hljs-keyword">return</span> <span class="hljs-title">fn</span>(...args)
}
<span class="hljs-keyword">const</span> logAdd = <span class="hljs-title">log</span>(add)
</code></pre>
<p class="normal">Here, a function is adding two numbers that enhance a function that logs all the parameters and then executes the original function.</p>
<p class="normal">This concept is pretty important to understand because, in the React world, a common pattern is to use Higher-Order Components to treat our components as functions, and to enhance them with common behaviors. We will see HOCs and other patterns in <em class="chapterRef">Chapter 4,</em> <em class="italic">Exploring Popular Composition Patterns</em>.</p>
<h2 class="heading-2" id="_idParaDest-72">Purity</h2>
<p class="normal">An important <a id="_idIndexMarker131"/>aspect of FP is to write pure functions. You will <a id="_idIndexMarker132"/>encounter this concept very often in the React ecosystem, especially if you look into libraries such as Redux.</p>
<p class="normal">What does it mean for a function to be pure?</p>
<p class="normal">A function is pure when there are no side effects, which means that the function does not change anything that is not local to the function itself.</p>
<p class="normal">For example, a function that changes the state of an application, or modifies variables defined in the upper scope, or a<a id="_idIndexMarker133"/> function that touches external entities, such as the <strong class="keyWord">Document Object Model</strong> (<strong class="keyWord">DOM</strong>), is considered impure. Impure functions are harder to debug, and most of the time it is not possible to apply them multiple times and expect to get the same result.</p>
<p class="normal">For example, the following function is pure:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">add</span> = (<span class="hljs-params">x, y</span>) =&gt; x + y
</code></pre>
<p class="normal">It can be run multiple times, always getting the same result, because nothing is stored anywhere, and nothing gets modified.</p>
<p class="normal">The following function is not pure:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>
<span class="hljs-keyword">const</span> <span class="hljs-title">add</span> = y =&gt; (x = x + y)
</code></pre>
<p class="normal">Running <code class="inlineCode">add(1)</code> twice, we get two different results. The first time we get <code class="inlineCode">1</code>, but the second time we get <code class="inlineCode">2</code>, even if we call the same function with the same parameter. The reason we get that behavior is that the global state gets modified after every execution.</p>
<h2 class="heading-2" id="_idParaDest-73">Immutability</h2>
<p class="normal">We have <a id="_idIndexMarker134"/>seen how to write pure functions that don’t mutate the state, but what if we need to change the value of a variable? In FP, a function, instead of changing the value of a variable, creates a new variable with a new value and returns it. </p>
<p class="normal">This way of working with data is<a id="_idIndexMarker135"/> called <strong class="keyWord">immutability</strong>.</p>
<p class="normal">An immutable value is a value that cannot be changed.</p>
<p class="normal">Let’s look at an example:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">add3</span> = arr =&gt; arr.<span class="hljs-title">push</span>(<span class="hljs-number">3</span>)
<span class="hljs-keyword">const</span> myArr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
<span class="hljs-title">add3</span>(myArr); <span class="hljs-comment">// [1, 2, 3]</span>
<span class="hljs-title">add3</span>(myArr); <span class="hljs-comment">// [1, 2, 3, 3]</span>
</code></pre>
<p class="normal">The preceding function doesn’t follow immutability because it changes the value of the given array. Again, if we call the same function twice, we get different results.</p>
<p class="normal">We can change<a id="_idIndexMarker136"/> the preceding function to make it immutable using <code class="inlineCode">concat</code>, which returns a new array without modifying the given one:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">add3</span> = arr =&gt; arr.<span class="hljs-title">concat</span>(<span class="hljs-number">3</span>)
<span class="hljs-keyword">const</span> myArr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
<span class="hljs-keyword">const</span> result1 = <span class="hljs-title">add3</span>(myArr) <span class="hljs-comment">// [1, 2, 3]</span>
<span class="hljs-keyword">const</span> result2 = <span class="hljs-title">add3</span>(myArr) <span class="hljs-comment">// [1, 2, 3]</span>
</code></pre>
<p class="normal">After we have run the function twice, <code class="inlineCode">myArr</code> still has its original value.</p>
<h2 class="heading-2" id="_idParaDest-74">Currying</h2>
<p class="normal">A common <a id="_idIndexMarker137"/>technique in FP is currying. <code class="inlineCode">Currying</code> is the process of <a id="_idIndexMarker138"/>converting a function that takes multiple arguments into a function one argument at a time and returning another function. Let’s look at an example to clarify the concept.</p>
<p class="normal">Let’s start with the <code class="inlineCode">add</code> function we have seen before and transform it into a curried function.</p>
<p class="normal">Say we have the following code:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">add</span> = (<span class="hljs-params">x, y</span>) =&gt; x + y
</code></pre>
<p class="normal">We can instead define the function as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">add</span> = x =&gt; <span class="hljs-params">y</span><span class="hljs-function"> =&gt;</span> x + y
</code></pre>
<p class="normal">We use it in the following way:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> add1 = <span class="hljs-title">add</span>(<span class="hljs-number">1</span>)
<span class="hljs-title">add1</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 3</span>
<span class="hljs-title">add1</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 4</span>
</code></pre>
<p class="normal">This is a pretty<a id="_idIndexMarker139"/> convenient way of writing functions <a id="_idIndexMarker140"/>because, since the first value is stored after the application of the first parameter, we can reuse the second function multiple times.</p>
<h2 class="heading-2" id="_idParaDest-75">Composition</h2>
<p class="normal">Finally, an <a id="_idIndexMarker141"/>important concept in FP that can be applied to <a id="_idIndexMarker142"/>React is <strong class="keyWord">composition</strong>. Functions (and components) can be combined to produce new functions with more advanced features and properties.</p>
<p class="normal">Consider the following functions:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">add</span> = (<span class="hljs-params">x, y</span>) =&gt; x + y
<span class="hljs-keyword">const</span> <span class="hljs-title">square</span> = x =&gt; x * x
</code></pre>
<p class="normal">These functions can be composed together to create a new function that adds two numbers and then doubles the result:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">addAndSquare</span> = (<span class="hljs-params">x, y</span>) =&gt; <span class="hljs-title">square</span>(<span class="hljs-title">add</span>(x, y))
</code></pre>
<p class="normal">Following this paradigm, we end up with small, simple, testable pure functions that can be composed together.</p>
<h1 class="heading-1" id="_idParaDest-76">Summary</h1>
<p class="normal">In this chapter, we have covered the fundamentals of JSX, including its syntax and features. We have also learned how to configure Prettier and ESLint to maintain consistency and catch errors early on in our codebase. Additionally, we have explored some essential concepts of functional programming, which can help us write more maintainable and testable code.</p>
<p class="normal">With our code now clean and well-organized, we are ready to dive deeper into React and learn how to write truly reusable components in the next chapter. By following best practices and adopting good coding habits, we can create React applications that are easier to maintain, scale, and test.</p>
<h1 class="heading-1" id="_idParaDest-77">Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussion with the author and other readers:</p>
<p class="normal"><a href="https://packt.link/React18DesignPatterns4e"><span class="url">https://packt.link/React18DesignPatterns4e</span></a></p>
<p class="normal"><img alt="" height="177" src="../Images/QR_Code2450023176943770109.png" width="177"/></p>
</div>
</div></body></html>