- en: Chapter 1. Thinking in Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React was the first interface library that got me thinking about component-based
    design. React promotes many good patterns and habits, but this one stands out
    for me. To understand why, we need to think about how React works under the hood.
    React is primarily a rendering engine. It was created (and is used) for generating
    user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: How interfaces used to work (and indeed still work apart from React) was that
    someone would come up with a design. That image file would then be split up into
    assets for each interactive part of the interface. A library such as jQuery would
    manage user interactions and connect different interface components, often with
    an assortment of plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Individual interface components can be quite clean and complete individually.
    However, when they are combined, interactions between components and shared, mutable
    component state often make a messy codebase. One of the main reasons why React
    was created was to simplify the interactions between components, so they can remain
    clean and easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Why components?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Component-based design is powerful, especially when we use immutable data and
    unidirectional data flow. It forces me to stop thinking about how different technologies
    or tools interact. It gets me thinking about the single most important function
    of each interface element.
  prefs: []
  type: TYPE_NORMAL
- en: When we start building an application, it's tempting to think of every piece
    as part of the whole. All interface elements blend into the same big picture,
    until it becomes so big that separating parts of it out seems impossible.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you had to build a space ship. What a huge task! You'd need some rocket
    boosters, a couple of wings, life support, and so on. Now consider how you would
    approach it if one of the constraints was that each moving part of the space ship
    would need to be individually tested.
  prefs: []
  type: TYPE_NORMAL
- en: Testing is the great divide between designing systems as a whole and designing
    systems as large collections of small pieces. Component-based design is fantastic
    because it makes sure that every part is testable.
  prefs: []
  type: TYPE_NORMAL
- en: Using modern JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React components are wonderfully encapsulated. Each component is a blueprint
    for what a focused bit of markup should look like at any moment. They're reusable
    and can change their behavior depending on the context provided. Does that remind
    you of another programming paradigm?
  prefs: []
  type: TYPE_NORMAL
- en: Let's talk about JavaScript. JavaScript has a prototypical inheritance model.
    That means different objects can have a common structure. The structure of one
    object can be derived from the structure of another.
  prefs: []
  type: TYPE_NORMAL
- en: 'It also means that changes to the original object are inherited in all derivative
    objects. Let me illustrate this with some code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: I begin by creating a function called `Page`, which requires a `content` parameter.
    A simple `render` method returns that content, wrapped in a `div` tag. This seems
    like a good starting point for a website.
  prefs: []
  type: TYPE_NORMAL
- en: Next, I decide to make a second type called `Post`. Objects of this type have
    tags, so I create a new initialization function to store them. I want `Post` to
    behave almost like a `Page` type, so I call the `Page` initialization function.
  prefs: []
  type: TYPE_NORMAL
- en: To inherit the `Page` methods in `Post`, I need to link their prototypes. I
    can then choose to override the `render` method and add new methods to the derived
    type. I can also change the `Page` type and these changes will be inherited by
    objects of the `Post` type. The connection happens because a prototype is a reference
    and not a copy.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the programming languages you grew up with, prototypical inheritance
    might be tricky at first. Many new developers learn (incorrectly) that object-oriented
    code means class-oriented code. Dynamic concepts such as prototypes are foreign
    to them. In the past, this led to a few libraries implementing "pretend" classes.
    They created patterns that would make code appear as if it was class-oriented.
  prefs: []
  type: TYPE_NORMAL
- en: Then, ES6 added the `class` keyword. It's a formalization of the pattern I just
    showed you. It's a syntactic shortcut to prototypical inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could reduce the previous code to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're trying to run this using Node (preferably a version greater than 4.1),
    you may need to add `use strict` at the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how much clearer things are? If you want to use classes, then this syntactic
    shortcut is brilliant!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a typical ES5-compatible React component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You've probably seen this kind of code before. It's called JSX and it's a JavaScript
    superset language. The idea is that the markup and the supporting logic are created
    and stored together.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: React components must return a single React node, which is why we wrap the tags
    and page elements in a `div` element. If you are using React in the browser, you
    also need to render your components to an existing DOM node (like I've just rendered
    the post to `.react`).
  prefs: []
  type: TYPE_NORMAL
- en: We'll get into some of the specifics in later chapters, but this is doing pretty
    much the same thing as before. We create a base component called `Page`. It renders
    a property instead of a constructor parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Post` component composes the `Page` component. This style of React code
    doesn''t support component inheritance. For that, we need ES6 code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We could still compose `Page` within `Post`, but that's not the only option
    with ES6\. This code resembles the non-React version we saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: In upcoming chapters, we'll learn many useful features of ES6 that'll allow
    us to create modern, expressive React components.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to look ahead a little, check out [http://babeljs.io/docs/learn-es2015](http://babeljs.io/docs/learn-es2015).
    It's a great place to learn the main features of ES6!
  prefs: []
  type: TYPE_NORMAL
- en: 'Babel is the cross-compilation tool we''ll use to turn ES6 code into ES5 code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using modern JavaScript](img/5268_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Compiling modern JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time for us to look at how to compile ES6 and JSX code into formats that
    most browsers can read. Create a folder for your React components and run the
    following commands inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The first command will kick off a series of questions, most of which should
    have reasonable defaults. The second command will download a builder and a cross-compiler
    for your ES6 code. Place the following component in a file called `page.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of important differences between this and the previous `Page`
    component. We import the main `React` object from within the `node_modules` folder.
    We also export the class definition so that importing this file immediately references
    this class. It''s a good idea to limit each file to a single class. It''s also
    a good idea to make each file define types or use them. We use this class in `main.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This code imports `React` and `ReactDOM` from within the `node_modules` folder,
    so we can render the `Page` class. Here we''re referencing an element in the DOM
    again. We can use this JavaScript within an HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step is to compile the ES6/JSX code in `main.js` to ES5-compatible
    code in `main.dist.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first command creates a shortcut to the `browserify` command in the `node_modules/.bin`
    folder. This is useful for repeated calls to `browserify`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to keep that alias around, be sure to add it to your `~/.bashrc`,
    `~/.zshrc` or `~/.profile` file.
  prefs: []
  type: TYPE_NORMAL
- en: The second command starts a build. *Browserify* will combine all imported files
    into a single file, so they can be used in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `babelify` transformer, so the ES6 code becomes ES5-compatible code.
    Babel supports JSX, so we don't need additional steps for that. We specify `main.js`
    as the file to transform and `main.dist.js` as the output file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to compile React and ReactDOM into their own file, you can exclude
    them with the `-x` switch. Your command should be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Debugging in the browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also use our code directly in the browser. There may be times when we
    want to see the effects of a change, without a build step. In such cases, we can
    try something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'These will give us access to a browser-based dependency manager and cross-compiler;
    that is, we can use unbundled source code in an example HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This uses the same unprocessed `main.js` file as before, but we no longer need
    to rebuild it after each change to the source code. The `System` is a reference
    to the *SystemJS* library we just installed through NPM. It takes care of the
    import statements, loading those dependencies with Ajax requests.
  prefs: []
  type: TYPE_NORMAL
- en: You may notice the references to `react` and `react-dom`. We import these in
    `main.js`, but where do they come from? Browserify fetches them out of the `node_modules`
    folder. When we skip the Browserify step, we need to let SystemJS know where to
    find them.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest place to find these files is at [https://facebook.github.io/react](https://facebook.github.io/react).
    Click on the download button, extract the archive, and copy the `JS` files in
    the `build` folder to where they are referenced in the HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ReactJS website is a great place to download ReactJS, and find documentation
    about how you can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging in the browser](img/5268_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Managing common tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As our collection of React components grows, we'll need ways of bundling them
    all together. It would also be a good idea for us to minify the resulting JavaScript
    to reduce the time it takes to load them in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can perform these kinds of tasks using scripts in `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: NPM scripts are fine for small, simple tasks. When the tasks get more complex,
    we'll start to see the drawbacks of using NPM scripts for this. There's no easy
    way to use variables in these scripts, so parameters are often repeated. The scripts
    are also a bit inflexible and frankly ugly.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few tools that address these problems. We're going to use one of
    them, called **Grunt**, to create flexible, repeatable tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Grunt website has instructions for using Grunt and a list of popular plugins
    you can use to customize your workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing common tasks](img/5268_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Grunt is a JavaScript task runner. There are three steps for using it:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to install the CLI tool. We'll use this to run different tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we need to install the libraries our tasks will use, via NPM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to create a `gruntfile.js` file where we'll put our tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can install the CLI tool using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding command installs the Grunt CLI tool globally. If you don't want
    that, omit the `-g` flag. You'll need to alias/run it directly with `node_modules/.bin/grunt`
    from here on though.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need the following task libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The global CLI tool needs a local copy of `grunt`. In addition, we also want
    the glue libraries to run Browserify, Uglify, and a file watcher in Grunt. We
    configure them with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We can configure each task in `gruntfile.js`. Here, we create a `browserify`
    task, defining the source and destination files. We include the `babelify` transformation
    to convert our ES6 classes into ES5-compatible code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I've added the `external` option so you can see how. If you don't need it, just
    delete it and your bundle file should then include the full React source code.
  prefs: []
  type: TYPE_NORMAL
- en: After the ES6 code is transformed, we can run *Uglify* to remove unnecessary
    whitespace. This reduces the size of the file, so browsers can download it quicker.
    We can target the file Browserify created and create a new minified file from
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we create a `watch` task. This watches for changes to `main.js` and
    triggers the Browserify and Uglify tasks. We need to register a default set of
    tasks, which we set to `browserify` and `uglify`. This configuration enables the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There are other great tools like Grunt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://gulpjs.com](http://gulpjs.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://webpack.github.io](https://webpack.github.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They work with similar configuration files, but the configuration is done through
    functional composition. The important thing to take from this is that there are
    tools we can use to automate tasks we would have run by hand. They make these
    repetitive tasks easy!
  prefs: []
  type: TYPE_NORMAL
- en: Testing in JSBin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''re anything like me, you''ll often just want a quick place to test
    some small component or ES6 code. Setting up these build chains or live browser
    environments takes time. There is a quicker way. It''s called JSBin and you can
    find it at [https://jsbin.com](https://jsbin.com):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing in JSBin](img/5268_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To get the most out of JSBin, be sure to set the **JavaScript** dropdown to
    **ES6/Babel** and include the ReactJS scripts from *CDNJS*. These are pre-built
    versions of ReactJS, so you can create React components (using ES6 features) straight
    from the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for this book from your account at [http://www.packtpub.com](http://www.packtpub.com).
    If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the code files by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in or register to our website using your e-mail address and password.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hover the mouse pointer on the SUPPORT tab at the top.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on Code Downloads & Errata.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter the name of the book in the Search box.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the book for which you're looking to download the code files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose from the drop-down menu where you purchased this book from.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on Code Download.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also download the code files by clicking on the Code Files button on
    the book's webpage at the Packt Publishing website. This page can be accessed
    by entering the book's name in the Search box. Please note that you need to be
    logged in to your Packt account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the file is downloaded, please make sure that you unzip or extract the
    folder using the latest version of:'
  prefs: []
  type: TYPE_NORMAL
- en: WinRAR / 7-Zip for Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zipeg / iZip / UnRarX for Mac
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7-Zip / PeaZip for Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw why component-based design is good. We saw what simple
    React components look like. We saw a few interesting differences between ES5 and
    ES6, and we also saw how those differences influence React components.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw a few ways to make ES6 code work in an ES5-compatible way. We can
    write cutting-edge code that works on common browsers. We can even bundle that
    code into single, efficient files, or debug it live in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to look at some intricacies of state and properties.
    We'll begin by creating reusable React components to use in our example application.
  prefs: []
  type: TYPE_NORMAL
