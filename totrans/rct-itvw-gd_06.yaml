- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: 'Redux: The Best State Management Solution'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux：最佳状态管理解决方案
- en: As the requirements of your JavaScript single-page applications become more
    complicated, it will become challenging to maintain the application state. This
    application state can be created from server or API responses, the local component
    state, and the UI state such as pagination controls, active routes, and selected
    tabs. The state can be changed with the help of direct or indirect models or UI
    interactions in your application. At some point, you may lose control over when,
    why, and how the state has been changed. This issue has been resolved by state
    management design patterns and libraries such as Flux, Redux, MobX, Recoil, Rematch,
    Vuex, and so on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的 JavaScript 单页应用程序的需求变得更加复杂，维护应用程序状态将变得具有挑战性。这种应用程序状态可以由服务器或 API 响应、本地组件状态以及
    UI 状态（如分页控件、活动路由和选定的标签页）创建。可以通过你应用程序中的直接或间接模型或 UI 交互来更改状态。在某个时候，你可能会失去对何时、为什么以及如何更改状态的控制。这个问题已经被状态管理设计模式和库（如
    Flux、Redux、MobX、Recoil、Rematch、Vuex 等）所解决。
- en: Choosing the right state management solution is crucial for any medium- to large-scale
    React application. After reading this chapter, you will be able to answer questions
    fluently about the Flux pattern and Redux architecture, core principles, main
    components, handling asynchronous data flow, middleware such as Saga and Thunk,
    and Redux DevTools for debugging.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的状态管理解决方案对于任何中型到大型规模的 React 应用程序至关重要。阅读本章后，你将能够流畅地回答有关 Flux 模式和 Redux 架构、核心原则、主要组件、处理异步数据流、中间件如
    Saga 和 Thunk 以及 Redux DevTools 用于调试的问题。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Understanding the Flux pattern and Redux
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Flux 模式和 Redux
- en: Core principles of Redux, components, and APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux 的核心原则、组件和 API
- en: Redux middleware – Saga and Thunk
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux 中间件 – Saga 和 Thunk
- en: Standardizing Redux logic using RTK
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 RTK 标准化 Redux 逻辑
- en: Debugging applications using Redux DevTools
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Redux DevTools 调试应用程序
- en: Redux was initially created for React applications and it is quite popular among
    all the state management libraries available. Let’s learn more about the Flux
    pattern, Redux fundamentals, and core concepts in the next section for a better
    understanding of the Redux library.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 最初是为 React 应用程序创建的，并且在所有可用的状态管理库中都非常受欢迎。让我们在下一节中了解更多关于 Flux 模式、Redux 基础和核心概念，以便更好地理解
    Redux 库。
- en: Understanding the Flux pattern and Redux
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Flux 模式和 Redux
- en: Flux has been created as a design pattern to manage the data flow in React applications.
    This is a slight modification of the *Observer* pattern, which defines a subscription
    mechanism in which any state change to one object notifies all other objects ([https://en.wikipedia.org/wiki/Observer_pattern](https://en.wikipedia.org/wiki/Observer_pattern)).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 被创建为一种设计模式，用于管理 React 应用程序中的数据流。这是对 *观察者* 模式的一种轻微修改，该模式定义了一种订阅机制，其中任何对象的状态更改都会通知所有其他对象（[https://en.wikipedia.org/wiki/Observer_pattern](https://en.wikipedia.org/wiki/Observer_pattern)）。
- en: In 2015, the Redux library was introduced. It was inspired by Flux architecture
    but implemented differently. The next couple of questions focus on Flux and Redux
    core concepts for the strong foundation of the Redux state management library.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 2015 年，Redux 库被引入。它受到了 Flux 架构的启发，但实现方式不同。接下来的几个问题将关注 Flux 和 Redux 的核心概念，为 Redux
    状态管理库的坚实基础。
- en: What is the Flux pattern? Can you explain the data flow?
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 Flux 模式？你能解释数据流吗？
- en: Flux is a pattern for managing the unidirectional data flow in your application
    and acts as a replacement for the traditional MVC pattern. It is neither a framework
    nor a library but a new kind of architecture to resolve the state management complexities
    in client-side web applications. It has been developed and used by Facebook internally
    while working with React applications.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 是一种管理应用程序中单向数据流的模式，并作为传统 MVC 模式的替代品。它既不是框架也不是库，而是一种新的架构，用于解决客户端 Web 应用程序中的状态管理复杂性。它是在与
    React 应用程序一起工作时由 Facebook 内部开发和使用的。
- en: 'Flux has four major components in its data flow: Action, Dispatcher, Store,
    and View. Here’s a little more about them:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 在其数据流中有四个主要组件：Action、Dispatcher、Store 和 View。以下是关于它们的更多内容：
- en: '**Action**: This represents a JavaScript object that is sent to the dispatcher
    to trigger the data flow.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Action**：这代表一个发送到派发器的 JavaScript 对象，用于触发数据流。'
- en: '**Dispatcher**: This is a singleton registry of callbacks to update the store,
    and it works as a central hub of the data flow in the Flux application. It has
    no real intelligence and simply dispatches the payload from the action to the
    store.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分发器**：这是一个更新存储的单例回调注册表，并在 Flux 应用程序的数据流中充当中央枢纽。它没有真正的智能，只是简单地从动作分发有效载荷到存储。'
- en: '**Store**: This is the place where the application state and logic are maintained.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储**：这是应用程序状态和逻辑维护的地方。'
- en: '**View**: This receives the data from the store and re-renders the app. The
    view is going to trigger the action for any user interactions.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：它从存储接收数据并重新渲染应用程序。视图将触发动作以响应任何用户交互。'
- en: 'The step-by-step data flow of the Flux architecture based on the preceding
    components looks like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 preceding 组件的 Flux 架构的逐步数据流看起来是这样的：
- en: If any user performs any UI interactions, an event will be generated, and the
    views will send actions to the dispatcher.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任何用户执行任何 UI 交互，将生成一个事件，并且视图将向分发器发送动作。
- en: Dispatchers send those actions to the respective stores.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分发器将那些动作发送到相应的存储。
- en: Stores update the state and notify the views to re-render.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储更新状态并通知视图重新渲染。
- en: 'The following diagram describes how the data flow happens in a Flux-based web
    application:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了基于 Flux 的 Web 应用程序中数据流的发生方式：
- en: '![Figure 6.1: Flux data flow](img/Figure_06.01_B18603.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1：Flux 数据流](img/Figure_06.01_B18603.jpg)'
- en: 'Figure 6.1: Flux data flow'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1：Flux 数据流
- en: In most applications, we will also create *action creators* as a library of
    helper methods that not only create action objects but also pass the action to
    the dispatcher.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数应用程序中，我们还会创建 *action creators* 作为一组辅助方法库，这些方法不仅创建动作对象，还将动作传递给分发器。
- en: What are the advantages of Flux?
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flux 的优点是什么？
- en: 'The Flux architecture comes with the following advantages and is helpful to
    use in client-side web applications:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 架构具有以下优点，并且有助于在客户端 Web 应用程序中使用：
- en: It is easy to understand because of its unidirectional data flow
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于其单向数据流，它很容易理解
- en: The Flux components are decoupled, and each component has its own responsibility
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flux 组件是解耦的，每个组件都有自己的职责
- en: It is an open source architecture rather than a framework or a library
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个开源架构，而不是框架或库
- en: Runtime errors will be reduced because of its design
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于其设计，运行时错误将减少
- en: It is easy to maintain
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它易于维护
- en: The Flux architecture helps move the implementation of API communication, caching,
    and localization code out from the view or UI layer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 架构有助于将 API 通信、缓存和本地化代码的实现从视图或 UI 层移出。
- en: How do you differentiate Flux from MVC?
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何区分 Flux 和 MVC？
- en: The **Model, View, Controller** (**MVC**) design pattern was introduced in 1976
    in the Smalltalk programming language. As the application grows, this pattern
    becomes complex with its multi-data flow. The Facebook team solved this problem
    by introducing the Flux architecture. The major differences between MVC and Flux
    design patterns are listed in the following table.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**（**MVC**）设计模式于 1976 年在 Smalltalk 编程语言中引入。随着应用程序的增长，这种模式因其多数据流而变得复杂。Facebook
    团队通过引入 Flux 架构解决了这个问题。MVC 和 Flux 设计模式之间的主要区别列在以下表格中。'
- en: '| **MVC** | **Flux** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **MVC** | **Flux** |'
- en: '| --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| The data flow direction is bi-directional | The data flow direction is unidirectional
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 数据流方向是双向的 | 数据流方向是单向的 |'
- en: '| The controller handles the logic | The store handles the logic |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 控制器处理逻辑 | 存储处理逻辑 |'
- en: '| There is no store concept in MVC | There can be multiple stores in Flux |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| MVC 中没有存储概念 | Flux 中可以有多个存储 |'
- en: '| It is synchronous | It is asynchronous |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 它是同步的 | 它是异步的 |'
- en: '| Debugging is difficult due to the bi-directional data flow | Debugging is
    easier with the dispatcher |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 由于双向数据流，调试困难 | 使用分发器调试更容易 |'
- en: '| It is used for both client-side and server-side frameworks | It is used for
    client-side frameworks only |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 它用于客户端和服务器端框架 | 它仅用于客户端框架 |'
- en: 'Table 6.1: MVC versus Flux'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.1：MVC 与 Flux 对比
- en: Flux is not totally a different approach from MVC, but it is an improved MVC
    pattern. If the application is complex and has a complicated data model, it’s
    better to opt for Flux over MVC.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 并非完全不同于 MVC 的方法，但它是一个改进的 MVC 模式。如果应用程序复杂且数据模型复杂，最好选择 Flux 而不是 MVC。
- en: What is Redux?
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 Redux？
- en: Redux is a popular and predictable state container library designed to write
    JavaScript applications that behave consistently across client, server, and native
    environments, and at the same time, is easy to test. It is inspired by Facebook’s
    Flux architecture. The unnecessary complexities that existed in the Flux pattern
    have been eliminated by it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Redux是一个流行的、可预测的状态容器库，旨在编写在客户端、服务器和原生环境中表现一致的JavaScript应用，同时易于测试。它受到了Facebook的Flux架构的启发。它消除了Flux模式中存在的无必要复杂性。
- en: It is quite straightforward to use a component state when the application contains
    fewer components. As the number of components increases and the application becomes
    larger, it will be challenging to maintain the state of each component in your
    application. In this case, Redux comes to the rescue to manage the state of large
    applications by creating a global store, and all the needed components use this
    global store without passing down props from one component to the other.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用包含较少的组件时，使用组件状态相当直接。随着组件数量的增加和应用的变大，维护应用中每个组件的状态将变得具有挑战性。在这种情况下，Redux通过创建一个全局存储来拯救，所有需要的组件都使用这个全局存储，而不需要从一个组件传递props到另一个组件。
- en: Note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Redux is a lightweight library with a size of around 2 KB, including its dependencies.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Redux是一个大小约为2 KB的轻量级库，包括其依赖项。
- en: What are the differences between Flux and Redux?
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flux和Redux之间有什么区别？
- en: Even though Redux is inspired by the Flux architecture, there are a few major
    differences, as listed in the following table.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Redux受到了Flux架构的启发，但有一些主要区别，如下表所示。
- en: '| **Flux** | **Redux** |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **Flux** | **Redux** |'
- en: '| --- | --- |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| This was developed by Facebook | This was developed by Dan Abramov and Andrew
    Clark |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 这是由Facebook开发的 | 这是由Dan Abramov和Andrew Clark开发的 |'
- en: '| It is an application architecture to manage the application state | It is
    an open source JavaScript library to manage the state |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 它是一种用于管理应用状态的应用架构 | 它是一个用于管理状态的开放源代码JavaScript库 |'
- en: '| Flux provides multiple stores in the application | The intended pattern in
    Redux is to have only one store in the application |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| Flux在应用中提供多个存储 | Redux的目标模式是在应用中只有一个存储 |'
- en: '| It consists of four major components:ActionDispatcherStoreView | It consists
    of three major components:ActionReducerStore |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 它由四个主要组件组成：ActionDispatcherStoreView | 它由三个主要组件组成：ActionReducerStore |'
- en: '| The store manages the logic handling | Reducers manage the logic handling
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 存储管理处理逻辑 | Reducers管理处理逻辑 |'
- en: '| It has a singleton dispatcher | It won’t use any dispatcher |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 它有一个单例分发器 | 它不会使用任何分发器 |'
- en: '| The store’s state can be mutable | The store’s state is immutable |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 存储的状态是可变的 | 存储的状态是不可变的 |'
- en: 'Table 6.2: Flux versus Redux'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.2：Flux与Redux对比
- en: Apart from the preceding differences, Redux reduces complexity via functional
    composition, unlike Flux, which uses callback registration.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述区别之外，Redux通过函数组合减少复杂性，而Flux使用回调注册。
- en: When do you need to use Redux?
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你何时需要使用Redux？
- en: Redux is used to maintain and update the data across your application with a
    shared state for multiple components. But it may not be needed for all kinds of
    applications. It comes with a big learning curve and the need to write more code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Redux用于维护和更新应用中的数据，为多个组件提供共享状态。但并非所有类型的应用都需要它。它具有较大的学习曲线和需要编写更多代码的需求。
- en: 'The following is a list of use cases where Redux is useful:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个Redux有用的用例列表：
- en: You have large amounts of application state that needs to be shared by many
    components in the app
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有大量的应用状态需要由应用中的许多组件共享
- en: You need to follow a single source of truth for your application state
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要遵循应用状态的单一真相源
- en: The application state needs to be updated frequently
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用状态需要频繁更新
- en: The logic of updating the application state is complex
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新应用状态的逻辑很复杂
- en: You need to monitor how the state update happens over a period
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要监控状态更新在一段时间内发生的情况
- en: The application code is not a small-scale code base and many team members need
    to work on it
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用代码不是一个小型代码库，许多团队成员需要在其上工作
- en: Moreover, if you can manage state within React or any other frontend framework
    itself, then you don’t need to use Redux.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你可以在React或其他前端框架内部管理状态，那么你不需要使用Redux。
- en: Redux is not just a tiny library; it is also a pattern based on core principles,
    a working system with three major components, and provides several add-ons and
    vast APIs to cover common use cases in Redux applications. Let’s dive deep into
    all these topics in the next section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Redux不仅仅是一个小型的库；它还基于核心原则的模式，一个由三个主要组件组成的工作系统，并为Redux应用程序提供了多个附加功能和广泛的API，以覆盖常见的用例。让我们在下一节深入探讨所有这些主题。
- en: Core principles of Redux, components, and APIs
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux的核心原则、组件和API
- en: Even though Redux is inspired by the important qualities of Flux architecture,
    it has its own foundation principles and various components that make the Redux
    system handle state management in massive applications. As part of this section,
    you will get a clear understanding of Redux internals and their usage to answer
    medium- to advanced-level questions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Redux受到了Flux架构重要品质的启发，但它有自己的基础原则和多种组件，这使得Redux系统能够处理大型应用程序的状态管理。作为本节的一部分，你将清楚地了解Redux的内部结构和它们的用法，以回答中到高级别的问题。
- en: What are the core principles of Redux?
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Redux的核心原则是什么？
- en: 'Redux is based on three core principles. These principles are helpful to understand
    the library in a better way:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Redux基于三个核心原则。这些原则有助于更好地理解库：
- en: '`getState()` function, as follows:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getState()`函数如下：'
- en: '[PRE0]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This single tree is also helpful to persist the state in development for a faster
    development cycle.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这棵单一的树也有助于在开发中持久化状态，以加快开发周期。
- en: Note
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The one-store approach of Redux is one of the major differences from the multi-store
    approach of Flux.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Redux的单存储方法与Flux的多存储方法的主要区别之一。
- en: '**The state is read-only**: The only possible way to modify the state is to
    emit an action, an object form that describes what happened. That means an application
    cannot change the state directly, but instead, expresses an intent to change the
    state by passing an action.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态是只读的**：修改状态的唯一可能方式是发出一个动作，该动作是一个对象，描述了发生了什么。这意味着应用程序不能直接更改状态，而是通过传递一个动作来表达更改状态的意图。'
- en: '[PRE1]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since the preceding action is a plain JavaScript object, it can be serialized,
    stored, logged, and replayed for debugging purposes.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于前面的动作是一个普通的JavaScript对象，它可以被序列化、存储、记录，并且可以用于调试目的的重放。
- en: '`cities` state variable:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cities`状态变量：'
- en: '[PRE3]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Initially, your application can start with a single reducer. Once your application
    grows, you can split the large reducer into multiple small reducers that manage
    specific parts of the state tree. Moreover, you can also control the order of
    reducers invoked, passing the additional data, and making them reusable in the
    application for common tasks.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，你的应用程序可以从单个还原器开始。一旦你的应用程序增长，你可以将大型还原器拆分为多个小型还原器，这些还原器管理状态树的具体部分。此外，你还可以控制还原器的调用顺序，传递额外的数据，并在应用程序中使它们可重用于常见任务。
- en: How does Redux work? What are the main components of Redux?
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Redux是如何工作的？Redux的主要组件有哪些？
- en: 'The Redux system works by holding the entire state of the application in a
    central store. Each UI component that is a child of the Redux''s provider can
    access this stored state instead of sending the props from one component to the
    other. The entire process of the Redux workflow is based on three main core components:
    **Actions**, **Reducers**, and **the Store**.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Redux系统通过在中央存储中保留整个应用程序的状态来工作。每个作为Redux提供者子组件的UI组件都可以访问这个存储状态，而不是从一个组件向另一个组件发送props。Redux工作流程的整个过程基于三个主要核心组件：**动作**、**还原器**和**存储**。
- en: 'The workflow of Redux using the core components is explained with a simple
    todo example for better understanding in the following code. In the example, daily
    activities such as eating and running are considered as todos and added to the
    store using the Redux workflow:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，使用简单的待办事项示例解释了Redux使用核心组件的工作流程，以更好地理解。在示例中，日常活动如吃饭和跑步被视为待办事项，并使用Redux工作流程添加到存储中：
- en: '`type` fields that denote what kind of action to perform, and other data fields
    that are used to change the state. They are the only way to send the application
    data (for example, through form data, user interaction, or API calls) to the Redux
    store. All these actions are created via action creators, which are just functions
    that return actions.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`字段表示要执行的动作类型，以及其他用于更改状态的数据字段。它们是向Redux存储发送应用程序数据的唯一方式（例如，通过表单数据、用户交互或API调用）。所有这些动作都是通过动作创建器创建的，这些动作创建器只是返回动作的函数。'
- en: '[PRE4]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding action also contains todo details as a payload. It will be executed
    by the `store.dispatch(addTodo)` method, which sends this action to the store.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的动作还包含todo详细信息作为有效负载。它将由`store.dispatch(addTodo)`方法执行，该方法将此动作发送到存储。
- en: '`todo`, which looks like the following code snippet:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`todo`，如下代码片段所示：'
- en: '[PRE6]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding reducer takes the initial state and action as arguments. If the
    switch case matches with the `ADD_TODO` action type, it copies the existing todos
    from the state, updates the todos with a new `todo` value, and returns the todo
    new list. Otherwise, the existing state with unchanged todos will be returned.
    You can add more functional cases based on possible actions such as updating,
    deleting, and filtering todos in the application.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的reducer将初始状态和动作作为参数。如果switch case与`ADD_TODO`动作类型匹配，它将复制状态中的现有todos，使用新的`todo`值更新todos，并返回新的todo列表。否则，将返回带有未更改todos的现有状态。您可以根据可能的动作（如更新、删除和过滤应用程序中的todos）添加更多功能案例。
- en: Note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is not restricted to using switch-case code blocks only to decide what the
    new state should be. You can also use `if/else` loops or any other programming
    constructs.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它不仅限于使用switch-case代码块来决定新状态应该是什么。您还可以使用`if/else`循环或任何其他编程结构。
- en: '`createStore` or `configureStore`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createStore`或`configureStore`'
- en: '`dispatch(action)`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dispatch(action)`'
- en: '`getState()`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getState()`'
- en: 'These helper methods are going to be used to create or update the todos state
    in the store, as shown here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些辅助方法将被用来创建或更新存储中的todos状态，如下所示：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As the application grows, the specific parts of the state information from the
    store’s state can be accessed using functions known as *selectors*. The reselect
    library is popular for memoized selector functions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的增长，可以使用称为*选择器*的函数访问存储状态中的特定状态信息部分。reselect库因其记忆化的选择器函数而广受欢迎。
- en: It is also possible to extend the store functionality by adding store enhancers
    and middleware. These topics will be covered in the upcoming questions in this
    chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过添加store enhancers和middleware来扩展store的功能。这些主题将在本章后续问题中介绍。
- en: Can I use Redux with non-React UI libraries?
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我可以使用Redux与非React UI库一起使用吗？
- en: Even though Redux is mostly used with React and React Native libraries, it can
    be used with any other UI library (i.e., Redux works as a data store for various
    UI libraries). But you need to use the UI binding library to integrate Redux with
    your UI framework or library. For example, React Redux is the official binding
    library to tie Redux together with the React library. There are bindings available
    for AngularJS, Angular, Vue, Mithril, Ember, and many other frameworks too. Redux
    provides a subscription mechanism that can be used by any other code, but it is
    mostly useful when you integrate with declarative views or UIs created via React
    or other similar libraries.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Redux主要用于与React和React Native库一起使用，但它可以与任何其他UI库（即Redux作为各种UI库的数据存储）一起使用。但您需要使用UI绑定库将Redux与您的UI框架或库集成。例如，React
    Redux是将Redux与React库结合在一起的官方绑定库。还有为AngularJS、Angular、Vue、Mithril、Ember和其他许多框架提供的绑定。Redux提供了一个订阅机制，可以被任何其他代码使用，但它主要用于与通过React或其他类似库创建的声明性视图或UI集成。
- en: What are the rules followed by reducers?
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Reducers遵循哪些规则？
- en: 'In Redux, the reducer component should follow some specific rules. Those rules
    are listed here:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在Redux中，reducer组件应遵循一些特定的规则。这些规则在此列出：
- en: Reducers should only derive the new state value based on the current state and
    action arguments.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reducers应该仅根据当前状态和动作参数推导出新的状态值。
- en: Reducers shouldn’t modify the existing state. However, they can perform immutable
    updates by copying the existing state and making changes to the copied values
    instead.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reducers不应该修改现有的状态。然而，他们可以通过复制现有状态并对复制的值进行更改来执行不可变更新。
- en: They are not allowed to perform any asynchronous logic, calculate random values,
    or any side effects.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们不允许执行任何异步逻辑，计算随机值或任何副作用。
- en: The functions that follow the preceding rules are also known as **pure functions**.
    In other words, reducers are simply pure functions. By following these rules,
    reducers make Redux code and state predictable without any bugs.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循上述规则的函数也被称为**纯函数**。换句话说，reducers仅仅是纯函数。通过遵循这些规则，reducers使Redux代码和状态可预测，没有任何错误。
- en: What is the difference between the mapStateToProps() and mapDispatchToProps()
    methods?
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: mapStateToProps()方法和mapDispatchToProps()方法之间的区别是什么？
- en: The `mapStateToProps()` method is a utility function used to select the part
    of the data from the store that the connected component needs. The selected state
    is going to be passed as props to the component to which `connect()` is applied.
    In this way, this method is helpful to avoid passing the entire application state
    to the component.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapStateToProps()`方法是一个用于从存储中选择连接组件所需数据部分的实用函数。所选状态将被传递给应用了`connect()`的组件作为属性。这样，这个方法有助于避免将整个应用程序状态传递给组件。'
- en: 'The following example passes a `city` value as a prop to the `WeatherReport`
    component to find the weather information:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将`city`值作为属性传递给`WeatherReport`组件以查找天气信息：
- en: '[PRE8]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, the `WeatherReport` component only accepts `city` as a prop. You can easily
    use this component anywhere else in the application by decoupling Redux code from
    React components:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`WeatherReport`组件只接受`city`作为属性。你可以通过解耦Redux代码和React组件，轻松地在应用程序的任何地方使用此组件：
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The shorthand notation for this function is `mapState` and this function is
    called every time the store state changes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的简写符号是`mapState`，这个函数会在存储状态改变时被调用。
- en: The `mapDispatchToProps()` method is a utility function that is used to specify
    which actions your component might need to dispatch. This function provides action
    dispatching functions as props.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapDispatchToProps()`方法是一个实用函数，用于指定组件可能需要派发的动作。此函数提供动作派发函数作为属性。'
- en: 'The following function specifies the actions required for the `WeatherReport`
    React component:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数指定了`WeatherReport` React组件所需的动作：
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code snippet performs a city change action. This is done by invoking
    the `props.changeCity(city)` action directly in the component instead of calling
    the `props.dispatch(changeCity(city))` verbose expression.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段执行了一个城市更改动作。这是通过在组件中直接调用`props.changeCity(city)`动作来完成的，而不是调用`props.dispatch(changeCity(city))`这种冗长的表达式。
- en: There is a recommended object shorthand notation for the `mapDispatchToProps`
    function. In this approach, Redux wraps it in another function that looks like
    `(…args) => dispatch(changeCity(…args))` and passes that wrapper function as a
    prop to your component.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`mapDispatchToProps`函数，有一个推荐的对象简写符号。在这种方法中，Redux将其包装在一个看起来像`(…args) => dispatch(changeCity(…args))`的函数中，并将该包装函数作为属性传递给您的组件。
- en: 'Now, the preceding code can be simplified as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，前面的代码可以简化如下：
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In summary, the `mapStateToProps` function is used to render the stored data
    to the component and `mapDispatchToProps` is used to provide the action creators
    as props to the component.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`mapStateToProps`函数用于将存储数据渲染到组件中，而`mapDispatchToProps`用于将动作创建者作为属性提供给组件。
- en: What is a store enhancer?
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是存储增强器？
- en: A store enhancer is a higher-order function that accepts a store creator function
    (i.e., `createStore`) and returns a new enhanced store creator function. This
    is helpful to customize the original Redux store, and it will override the store
    methods such as `dispatch`, `getState`, and `subscribe`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 存储增强器是一个接受存储创建函数（即`createStore`）并返回一个新的增强存储创建函数的高阶函数。这有助于自定义原始Redux存储，并将覆盖存储方法，如`dispatch`、`getState`和`subscribe`。
- en: 'Take a look at the following snippet to see how the store enhancer implementation
    looks:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下代码片段以了解存储增强器实现的外观：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Store enhancer is quite similar to the concept of **higher-order component**
    (**HOC**) in React. So you can also call the HOC as **component enhancer**.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 存储增强器与React中的**高阶组件**（**HOC**）概念非常相似。因此，你也可以将HOC称为**组件增强器**。
- en: Note
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Middleware provides additional functionality to the Redux dispatch function
    and enhancers provide additional functionality to the Redux store.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件为Redux的派发函数提供了额外的功能，增强器为Redux存储提供了额外的功能。
- en: Real-time applications contain logic that involves side effects such as external
    API calls, generating random values, saving files, and updating local storage.
    By default, Redux has no support for these kinds of side effects to be executed.
    However, Redux middleware makes it possible to intercept the dispatched actions
    and inject additional complex behavior, including side effects. Next, we will
    get a better idea about that.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 实时应用程序包含涉及副作用（如外部API调用、生成随机值、保存文件和更新本地存储）的逻辑。默认情况下，Redux不支持执行这些类型的副作用。然而，Redux中间件使得拦截派发的动作并注入额外的复杂行为（包括副作用）成为可能。接下来，我们将对此有更好的了解。
- en: Redux middleware – Saga and Thunk
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux中间件 – Saga和Thunk
- en: The basic Redux store can only perform simple synchronous state updates by dispatching
    an action. Middleware such as **Redux Thunk** and **Redux Saga** help extend the
    store capabilities by writing the async logic to interact with the store. These
    middleware are helpful to avoid directly causing side effects in our actions,
    action creators, or components.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的Redux存储只能通过分发一个动作来执行简单的同步状态更新。例如**Redux Thunk**和**Redux Saga**这样的中间件通过将异步逻辑写入与存储交互来扩展存储功能。这些中间件有助于避免在我们的动作、动作创建者或组件中直接引起副作用。
- en: What is Redux middleware? How do you create middleware?
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是Redux中间件？如何创建中间件？
- en: Redux middleware provides a third-party extension to intercept every action
    sent to the reducer by modifying the action or canceling the action. It is helpful
    for logging, error reporting, routing, and making asynchronous API calls. Although
    Redux middleware is like Node.js middleware (for example, Express and Koa), it
    solves different problems.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Redux中间件提供了一种第三方扩展，通过修改动作或取消动作来拦截发送给reducer的每个动作。这对于日志记录、错误报告、路由和执行异步API调用非常有用。尽管Redux中间件类似于Node.js中间件（例如Express和Koa），但它解决了不同的问题。
- en: 'In the following example, let’s demonstrate the creation of a custom middleware
    named `loggerMiddleware` to log the various actions in the console with step-by-step
    instructions:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将通过逐步说明来演示创建一个名为`loggerMiddleware`的自定义中间件，以在控制台中记录各种动作：
- en: 'As a first step, you need to import the `applyMiddleware` function from the
    Redux library as follows:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第一步，你需要按照以下方式从Redux库中导入`applyMiddleware`函数：
- en: '[PRE13]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a middleware named `loggerMiddleware` to intercept the action for logging
    purposes with the following structured syntax:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`loggerMiddleware`的中间件，用于拦截动作以进行日志记录，其结构化语法如下：
- en: '[PRE14]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After the `loggerMiddleware` function has been created, it needs to be passed
    to the `applyMiddleware` function:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建`loggerMiddleware`函数之后，需要将其传递给`applyMiddleware`函数：
- en: '[PRE15]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we need to pass the custom middleware to the `createStore` function.
    Even though the middleware is assigned as a third argument to the store, the `createStore`
    function automatically identifies the middleware based on the type:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将自定义中间件传递给`createStore`函数。尽管中间件被分配为存储的第三个参数，但`createStore`函数会根据类型自动识别中间件：
- en: '[PRE16]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Before the action is dispatched to the store, the middleware gets executed by
    logging the action details in the console. Since the next function has been invoked
    inside the middleware, the reducer will also be executed to update the state in
    the store.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在动作被分发到存储之前，中间件会执行，并在控制台中记录动作详情。由于在中间件内部调用了下一个函数，因此reducer也会执行以更新存储中的状态。
- en: 'It is also possible to create multiple middleware by passing them to `applyMiddleware`
    function as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过将它们传递给`applyMiddleware`函数来创建多个中间件，如下所示：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, all these middleware are executed one after the other.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，所有这些中间件都是依次执行的。
- en: How do you handle asynchronous tasks in Redux?
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你如何在Redux中处理异步任务？
- en: 'Most modern web applications need to deal with asynchronous tasks. In React,
    there are two popular libraries available to handle them: **Redux Thunk** and
    **Redux Saga**.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代Web应用都需要处理异步任务。在React中，有两个流行的库可以用来处理这些任务：**Redux Thunk**和**Redux Saga**。
- en: 'Redux Thunk middleware is used to write an action creator that returns a function
    instead of just an action object in the Redux application. The functions returned
    from the action creator are called thunk functions and are used to delay the computation.
    These functions accept two arguments – the `dispatch` and `getState` methods:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Redux Thunk中间件用于编写一个动作创建者，它返回一个函数而不是一个动作对象。从动作创建者返回的函数被称为thunk函数，用于延迟计算。这些函数接受两个参数——`dispatch`和`getState`方法：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: All thunk functions are invoked through the store’s `dispatch` method but not
    from the application code. The same behavior can be seen with the preceding code
    as well.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 所有thunk函数都是通过store的`dispatch`方法调用的，而不是从应用代码中调用。这种行为在前面代码中也可以看到。
- en: 'Similar to action creators generating actions for dispatching, you can use
    Thunk action creators to generate thunk functions. For example, the list of posts
    created by a specific user can be retrieved using the thunk action creator named
    `getPostsByAuthor`, which generates anonymous thunk functions:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 与生成动作以进行分发的动作创建者类似，你可以使用Thunk动作创建者来生成thunk函数。例如，可以使用名为`getPostsByAuthor`的thunk动作创建者检索特定用户创建的帖子列表，它生成匿名thunk函数：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After that, you can access the action creator inside the UI component for any
    user interaction. The following `AuthorComponent` accesses the list of posts on
    the lazy loading event:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您可以在 UI 组件内部访问动作创建器以处理任何用户交互。以下 `AuthorComponent` 在懒加载事件中访问帖子列表：
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The last important step is configuring the `redux-thunk` middleware to the Redux
    store to dispatch the thunk functions. There are two possible options available.
    Thunk middleware needs to be passed to the `applyMiddleware()` method to add thunk
    middleware to the store manually. But if you are using RTK, the `configureStore`
    API automatically adds the thunk middleware during the store creation (i.e., it
    doesn’t require any additional configuration).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个重要步骤是将 `redux-thunk` 中间件配置到 Redux 存储中，以分发 thunk 函数。有两种可能的选择。Thunk 中间件需要传递给
    `applyMiddleware()` 方法，以手动将 thunk 中间件添加到存储中。但如果你使用 RTK，`configureStore` API 在创建存储时会自动添加
    thunk 中间件（即不需要任何额外的配置）。
- en: What are the use cases of Redux Thunk?
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Redux Thunk 的用例有哪些？
- en: 'Redux Thunk can have any arbitrary logic and it can be used for a variety of
    purposes. The most common use cases of Redux Thunk are listed as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Redux Thunk 可以有任意逻辑，并且可以用作多种目的。Redux Thunk 的最常见用例如下：
- en: When you’re trying to move complex logic out of React components
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你试图将复杂逻辑从 React 组件中移除时。
- en: When you are making async requests such as Ajax calls and other async logic
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你正在执行异步请求，如 Ajax 调用和其他异步逻辑时。
- en: When you need to create a logic that needs to dispatch multiple distinct actions
    in a row
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要创建需要连续分发多个不同动作的逻辑时。
- en: When you are planning to write a logic that needs to access `getState` or other
    state values to make decisions
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你计划编写需要访问 `getState` 或其他状态值以做出决策的逻辑时。
- en: In summary, the main use case of Redux Thunk middleware is for handling actions
    that are not synchronous.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Redux Thunk 中间件的主要用途是处理非同步的动作。
- en: What is Redux Saga?
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Redux Saga 是什么？
- en: Redux Saga is a popular competitor for Redux Thunk middleware for handling asynchronous
    side effects. Redux Saga uses an ES6 feature known as **generators** that helps
    in writing asynchronous code. These generators are functions that can be paused,
    resumed, exited in the middle of execution, and re-entered later during the operations.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Redux Saga 是 Redux Thunk 中间件处理异步副作用的一个流行竞争对手。Redux Saga 使用一个名为 **generators**
    的 ES6 功能，这有助于编写异步代码。这些生成器是可以在执行过程中暂停、恢复、退出并在稍后重新进入的函数。
- en: 'The side effects will be generated using special helper functions from the
    `redux-saga` package. Some of those commonly used functions are listed here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用来自 `redux-saga` 包的特殊辅助函数生成副作用。以下列出了一些常用函数：
- en: '`Call`: An effect description that instructs the middleware to call other functions
    in Saga'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Call`：一个效果描述，指示中间件在 Saga 中调用其他函数。'
- en: '`Put`: Used to dispatch an action to the store'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Put`：用于向存储分发动作。'
- en: '`Yield`: A built-in function that allows the use of generator functions sequentially'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Yield`：一个内置函数，允许顺序使用生成器函数。'
- en: '`takeLatest`: Invokes the function handler only once at a time and cancels
    the previous tasks by running again with the latest data'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`takeLatest`：一次只调用一次函数处理器，并通过再次运行带有最新数据的任务来取消之前的任务。'
- en: '`takeEvery`: Invokes the function handler every time infinitely and concurrently
    whenever the action fires'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`takeEvery`：每当动作触发时，无限并发地调用函数处理器。'
- en: 'The Saga functions listen for the actions that got dispatched and trigger side
    effects written in your code. For example, the following `postsSaga` function
    listens for the `GET_POSTS` action and invokes the Posts API to retrieve the author''s
    posts:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Saga 函数监听已分发的动作，并触发你代码中编写的副作用。例如，以下 `postsSaga` 函数监听 `GET_POSTS` 动作，并调用 Posts
    API 获取作者的帖子：
- en: '[PRE21]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code, either the successful response or failed response dispatched
    to the store. This response depends on API call happened through the `call` helper
    function.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，无论是成功响应还是失败响应都会分发到存储中。这个响应取决于通过 `call` 辅助函数发生的 API 调用。
- en: How do you choose between Redux Saga and Redux Thunk?
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你是如何在 Redux Saga 和 Redux Thunk 之间做出选择的？
- en: Both Redux Thunk and Redux Saga middleware are helpful in allowing the Redux
    store to interact with external API calls (or side effects) asynchronously. But
    the decision to choose one of them totally depends on your project requirements
    and personal preference. Redux Thunk is a good choice if you are new to the React
    or Redux ecosystem and the project is small in size. Moreover, Redux Thunk requires
    less boilerplate code and is easy to understand.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是 Redux Thunk 还是 Redux Saga 中间件，都有助于允许 Redux 存储异步地与外部 API 调用（或副作用）交互。但选择其中之一完全取决于你的项目需求和个人偏好。如果你是
    React 或 Redux 生态系统的初学者，且项目规模较小，Redux Thunk 是一个不错的选择。此外，Redux Thunk 需要的样板代码更少，更容易理解。
- en: On the other hand, Redux Saga is suitable for big projects where you need to
    split the logic into multiple files. However, the main advantage of Redux Saga
    over Redux Thunk is the ability to write clean and readable tests for asynchronous
    code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Redux Saga 适用于需要将逻辑拆分为多个文件的大型项目。然而，Redux Saga 相较于 Redux Thunk 的主要优势是能够编写干净且可读的异步代码测试。
- en: The plain Redux requires a lot of boilerplate code to fulfill the state management
    requirements. Developers need to implement common tasks such as store setup, writing
    reducers and actions, and so on. Also, you may need to import APIs from other
    packages based on needs. So, this entire process makes it difficult for developers
    to learn and implement the Redux solution. RTK is going to standardize the process
    and simplify it with its helpers.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 纯粹的 Redux 需要大量的样板代码来满足状态管理需求。开发者需要实现一些常见任务，如设置存储、编写 reducer 和 actions 等。此外，你可能还需要根据需要从其他包中导入
    API。这个过程使得开发者学习并实现 Redux 解决方案变得困难。RTK 通过其辅助工具将标准化这个过程并简化它。
- en: Standardizing Redux logic using RTK
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 RTK 标准化 Redux 逻辑
- en: The RTK package provides the necessary tools to ease Redux development. This
    package not only eases development but also prevents common mistakes, provides
    suggested best practices, and many more features.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: RTK 包提供了必要的工具来简化 Redux 开发。这个包不仅简化了开发，还防止了常见的错误，提供了建议的最佳实践，以及更多功能。
- en: What is RTK?
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 RTK？
- en: '`@reduxjs/toolkit`, which is wrapped around the core `redux` package. In summary,
    this package provides utilities and common dependencies that are required for
    building a Redux application.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`@reduxjs/toolkit`，它围绕核心 `redux` 包进行包装。总的来说，这个包提供了构建 Redux 应用程序所需的实用工具和常见依赖项。'
- en: This tool helps cover common use cases such as setting up the store, creating
    the reducers and actions, writing immutable update logic, and creating entire
    slices of state at once.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具有助于覆盖常见的用例，例如设置存储、创建 reducer 和 actions、编写不可变更新逻辑，以及一次性创建整个状态切片。
- en: 'By default, RTK automatically supports the following officially recommended
    set of tools or libraries to cover most of the common use cases:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，RTK 自动支持以下官方推荐的工具或库集合，以覆盖大多数常见用例：
- en: Redux DevTools
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux DevTools
- en: Immer
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Immer
- en: Redux Thunk
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux Thunk
- en: Reselect
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reselect
- en: RTK supports TypeScript through which APIs provide excellent type safety and
    reduce the number of types used in the code.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: RTK 通过 TypeScript 支持，API 提供了出色的类型安全，并减少了代码中使用的类型数量。
- en: What are the problems solved by RTK?
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RTK 解决了哪些问题？
- en: 'RTK is helpful to speed up the development process and apply the recommended
    best practices automatically. It solves the following three major issues found
    in the Redux library:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: RTK 有助于加快开发过程并自动应用推荐的最佳实践。它解决了在 Redux 库中发现的以下三个主要问题：
- en: Configuring a Redux store that is too complicated
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置过于复杂的 Redux 存储
- en: This Redux library requires a lot of dependencies for building a large-scale
    application
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个 Redux 库需要大量的依赖项来构建大型应用程序
- en: Redux requires too much boilerplate code, which impacts the efficiency and quality
    of the code
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux 需要太多的样板代码，这影响了代码的效率和品质
- en: The toolkit provides certain options to configure the global store, creating
    actions and reducers that make the development simpler by abstracting the Redux
    API.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 工具包提供了一些配置全局存储的选项，创建 actions 和 reducers，通过抽象 Redux API 使开发更加简单。
- en: What is RTK Query? How do you use it?
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 RTK Query？如何使用它？
- en: RTK Query is a powerful data fetching and client-side caching tool to simplify
    common use cases in Redux applications. For example, this tool supports use cases
    such as loading data in the web application, avoiding the need for hand-written
    data fetching and caching logic, and so on. If you are using the RTK package,
    this query feature is going to be available as an optional add-on. Also, this
    feature is built-in on top of the RTK API methods such as `createSlice` and `createAsyncThunk`
    for its implementation.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: RTK Query 是一个强大的数据获取和客户端缓存工具，用于简化 Redux 应用程序中的常见用例。例如，此工具支持在 Web 应用程序中加载数据、避免需要手动编写数据获取和缓存逻辑等用例。如果你正在使用
    RTK 包，此查询功能将作为一个可选的附加组件提供。此外，此功能是在 `createSlice` 和 `createAsyncThunk` 等RTK API方法之上构建的，以实现其实施。
- en: Let’s explain the usage of RTK Query with a data fetching use case in the web
    application.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 Web 应用程序中的数据获取用例来解释 RTK Query 的用法。
- en: First, you need to import the `createAPI` and `fetchBaseQuery` API methods from
    the RTK Query package. This `createAPI` method accepts an object that includes
    the `baseQuery` configuration created by the `fetchBaseQuery` API and a list of
    API endpoints to interact with the server.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要从 RTK Query 包中导入 `createAPI` 和 `fetchBaseQuery` API 方法。此 `createAPI` 方法接受一个对象，该对象包括由
    `fetchBaseQuery` API 创建的 `baseQuery` 配置以及与服务器交互的 API 端点列表。
- en: 'In this example, two endpoints are going to be created – one for creating the
    user and the other one for listing the users:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，将创建两个端点 – 一个用于创建用户，另一个用于列出用户：
- en: '[PRE22]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As shown in the preceding code, RTK Query auto-generates React Hooks for each
    endpoint that is available to use in function components through export declaration.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，RTK Query 为每个可用的端点自动生成 React Hooks，这些 Hooks 可以通过导出声明在函数组件中使用。
- en: 'Next, the store needs to be configured by mapping RTK Query’s generated slice
    reducer into root reducer along with a custom middleware that handles data fetching.
    The `setupListners` API is an optional utility to enable `refreshOnFocus` and
    `refreshOnReconnect` behaviors:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，需要通过将 RTK Query 生成的切片还原器映射到根还原器以及处理数据获取的自定义中间件来配置存储。`setupListeners` API
    是一个可选的实用工具，用于启用 `refreshOnFocus` 和 `refreshOnReconnect` 行为：
- en: '[PRE23]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After that, you need to wrap our application with the `Provider` component
    from the `react-redux` package to pass the store as a prop to all the child components,
    just like any Redux application:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你需要使用 `react-redux` 包中的 `Provider` 组件包裹我们的应用程序，将存储作为属性传递给所有子组件，就像任何 Redux
    应用程序一样：
- en: '[PRE24]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once that is done, you can make requests in your component through queries.
    The list of users on the second page can be retrieved as shown in the following
    code snippet:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，你可以在组件中通过查询进行请求。第二页上的用户列表可以按以下代码片段所示检索：
- en: '[PRE25]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In addition to users `data`, `error` and `isLoading` fields, the preceding query
    also provides other Boolean utilities such as `isFetching`, `isError`, and `isSuccess`,
    which might be of use, depending on functional requirements.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用户的 `data`、`error` 和 `isLoading` 字段外，前面的查询还提供了其他布尔实用工具，如 `isFetching`、`isError`
    和 `isSuccess`，这些可能根据功能需求而有用。
- en: Redux is the best state solution for large-scale applications. However, it will
    be challenging to debug the bugs that arise in these kinds of applications. Redux
    DevTools makes the development and debugging experience easy by tracing when,
    where, and how your application’s state has been changed.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 是大型应用程序的最佳状态解决方案。然而，调试这类应用程序中出现的错误将具有挑战性。Redux DevTools 通过追踪应用程序状态何时、何地以及如何被更改，使开发和调试体验变得容易。
- en: Debugging applications using Redux DevTools
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Redux DevTools 调试应用程序
- en: Just like Chrome DevTools is used to manipulate the content of the web page
    on the fly, Redux DevTools allows you to directly manipulate Redux operations
    in the web application. Nowadays, this tool has become a standard development
    tool for developing any kind of Redux application.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Chrome DevTools 用于动态操作网页内容一样，Redux DevTools 允许你直接操作 Web 应用程序中的 Redux 操作。如今，这个工具已成为开发任何类型
    Redux 应用程序的标准开发工具。
- en: What is Redux DevTools?
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 Redux DevTools？
- en: Redux DevTools is a development-purpose-only tool for debugging an application’s
    state changes. It is used to perform time-travel debugging and live editing for
    Redux with hot reloading, actions history, undo, and replay features. If you don’t
    want to install Redux DevTools as a standalone app or integrate it as a React
    component in the client app, it can be used as a browser extension for Chrome,
    Firefox, or Edge browsers.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Redux DevTools 是一个仅用于调试应用程序状态变化的开发工具。它用于执行时间旅行调试和 Redux 的实时编辑，具有热重载、动作历史、撤销和重放功能。如果您不想将
    Redux DevTools 作为独立应用程序安装或将其集成为客户应用程序中的 React 组件，它可以用作 Chrome、Firefox 或 Edge 浏览器的浏览器扩展。
- en: 'The following is an example DevTools snapshot representing the sequence of
    fetching todos, completing, and deleting todo operations:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 DevTools 快照示例，表示获取待办事项、完成和删除待办事项操作的顺序：
- en: '![Figure 6.2: Redux DevTools UI](img/Figure_06.02_B18603.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2：Redux DevTools UI](img/Figure_06.02_B18603.jpg)'
- en: 'Figure 6.2: Redux DevTools UI'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2：Redux DevTools UI
- en: In the preceding screenshot, the left panel represents the list of actions with
    *Skip* and *Jump* options on selecting the particular action and the right panel
    describes the current state, differences in state, and other useful features.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，左侧面板表示动作列表，在选择特定动作时具有 *跳过* 和 *跳转* 选项，右侧面板描述了当前状态、状态差异和其他有用功能。
- en: Note
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: RTK’s `configureStore` API automatically sets up integration with Redux DevTools.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: RTK 的 `configureStore` API 会自动设置与 Redux DevTools 的集成。
- en: What are the major features of Redux DevTools?
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Redux DevTools 的主要功能有哪些？
- en: 'Some of the major features of Redux DevTools are listed here:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 下面列出了 Redux DevTools 的一些主要功能：
- en: It provides the ability to inspect every state and action payload
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了检查每个状态和动作负载的能力
- en: You can go back in time by canceling the actions
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过取消动作来回到过去
- en: Once the reducer code changes, each staged action will be re-evaluated
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦 reducer 代码发生变化，每个阶段动作将被重新评估
- en: If there is an error thrown from the reducer, you can trace which action caused
    the error and what the error is about
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 reducer 抛出错误，您可以追踪导致错误的动作以及错误的内容
- en: You can persist debug sessions across page reloads using the `persistState()`
    store enhancer
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `persistState()` 存储增强器在页面重新加载之间持久化调试会话
- en: It is also possible to dispatch actions without writing any code in the application
    using the **dispatch** option of Redux DevTools.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Redux DevTools 的 **dispatch** 选项，可以在不编写任何代码的情况下在应用程序中分发动作。
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has offered comprehensive knowledge of Redux state management solutions
    for React applications. We began this chapter with a brief introduction to Flux,
    its architecture, differences with the MVC pattern, and use cases, followed by
    Redux fundamentals, differences with Flux, and its advantages as a state management
    solution. We also covered topics such as the core principles of Redux, their components,
    various add-ons, and data flows. After that, we went through understanding async
    tasks, popular middleware libraries in Redux, how to use them in React applications,
    and their use cases. Finally, we covered the debugging techniques and Redux DevTools
    to track the state changes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了关于 React 应用程序 Redux 状态管理解决方案的全面知识。我们本章开始以对 Flux 的简要介绍，其架构、与 MVC 模式的差异以及用例，然后是
    Redux 基础知识、与 Flux 的差异以及作为状态管理解决方案的优势，接着我们讨论了 Redux 的核心原则、其组件、各种附加组件和数据流。之后，我们了解了异步任务、Redux
    中流行的中间件库，如何在 React 应用程序中使用它们以及它们的用例。最后，我们介绍了调试技术以及 Redux DevTools 以跟踪状态变化。
- en: In the next chapter, we will understand the various approaches to applying CSS
    in React applications. First, we will start with a regular CSS styling approach
    in React using inline styles and external styles. Then, we will go through advanced
    techniques such as locally scoped CSS using CSS Modules and the `styled-components`
    library based on the CSS-in-JS solution.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解在 React 应用程序中应用 CSS 的各种方法。首先，我们将从 React 中的常规 CSS 样式方法开始，使用内联样式和外部样式。然后，我们将介绍一些高级技术，例如使用
    CSS Modules 的局部作用域 CSS 和基于 CSS-in-JS 解决方案的 `styled-components` 库。
