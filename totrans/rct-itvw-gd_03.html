<html><head></head><body>
<div id="_idContainer028">
<h1 class="chapter-number" id="_idParaDest-111"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-112"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.2.1">Hooks: Bring State and Other Features into Function Components</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Hooks were introduced in function components to reap the benefits of React features without writing any classes and life cycle methods. </span><span class="koboSpan" id="kobo.3.2">Most developers use Redux, Recoil, Mobx, and other third-party libraries to manage the global state in large-scale applications. </span><span class="koboSpan" id="kobo.3.3">But when you use React Hooks such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.4.1">useContext</span></strong><span class="koboSpan" id="kobo.5.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.6.1">useReducer</span></strong><span class="koboSpan" id="kobo.7.1"> together, it becomes a better alternative for external state management. </span><span class="koboSpan" id="kobo.7.2">Hooks are much easier to use than complex external libraries that involve excessive amounts of boilerplate code, repetitive files, and folders across the application. </span><span class="koboSpan" id="kobo.7.3">React also provides numerous other built-in Hooks that can be useful for various use cases in React applications. </span><span class="koboSpan" id="kobo.7.4">If there is no specific built-in Hook available to handle your use case, you can create your own Hook to fulfill your business needs. </span><span class="koboSpan" id="kobo.7.5">Some common use cases (or cross-cutting concerns) for Hooks are authentication, logging, caching, data fetching, and </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">error handling.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, you will be introduced to React Hooks, their benefits, and various built-in Hooks that add React features to function components. </span><span class="koboSpan" id="kobo.9.2">The built-in Hooks will be explained in depth through examples to understand their usage in React applications. </span><span class="koboSpan" id="kobo.9.3">Additionally, you will gain the knowledge and confidence to answer questions related to third-party Hooks, create your own Hooks, and </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">troubleshoot Hooks.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Introduction to Hooks and </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">their purpose</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Local state management </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">using Hooks</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Global state management </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">using Hooks</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Performing side effects in </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">React applications</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Accessing DOM nodes using </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">Ref Hooks</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Optimizing the </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">application performance</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Learning about popular </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">third-party Hooks</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">Building your </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">own Hooks</span></span></li>
<li><span class="koboSpan" id="kobo.29.1">Troubleshooting and </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">debugging Hooks</span></span></li>
</ul>
<h1 id="_idParaDest-113"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.31.1">Introduction to Hooks and their purpose</span></h1>
<p><span class="koboSpan" id="kobo.32.1">Initially, React was mainly used with class components, but over the years the components became </span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.33.1">complex with the usage of various patterns to reuse the component logic. </span><span class="koboSpan" id="kobo.33.2">Subsequently, Hooks were introduced to simplify the code without writing any patterns, such as render props and </span><strong class="bold"><span class="koboSpan" id="kobo.34.1">higher-order components</span></strong><span class="koboSpan" id="kobo.35.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.36.1">HOCs</span></strong><span class="koboSpan" id="kobo.37.1">). </span><span class="koboSpan" id="kobo.37.2">Since Hooks play an important role in building React applications nowadays, you can expect a couple of questions on Hooks in a React interview. </span><span class="koboSpan" id="kobo.37.3">This section will give you detailed answers about what Hooks are and what their </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">purpose is.</span></span></p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.39.1">What are Hooks?</span></h2>
<p><span class="koboSpan" id="kobo.40.1">Hooks are simple JavaScript functions that allow components to use the local state and execute side </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.41.1">effects (or cross-cutting concerns) and other React features without writing classes. </span><span class="koboSpan" id="kobo.41.2">The Hooks API has been introduced in React 16.8 to isolate the stateful logic from </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">the components.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">In a nutshell, the Hooks feature is a way for your function components to </span><em class="italic"><span class="koboSpan" id="kobo.44.1">Hook</span></em><span class="koboSpan" id="kobo.45.1"> into React’s life cycle </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">and state.</span></span></p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.47.1">What is the motivation behind Hooks?</span></h2>
<p><span class="koboSpan" id="kobo.48.1">Hooks can </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.49.1">solve a wide variety </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">of problems.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">Here are </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">a few:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.53.1">Difficulty in reusing stateful logic between components</span></em><span class="koboSpan" id="kobo.54.1">: By default, React didn’t provide </span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.55.1">a way to reuse the component logic. </span><span class="koboSpan" id="kobo.55.2">Programming </span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.56.1">patterns such as </span><strong class="bold"><span class="koboSpan" id="kobo.57.1">render props</span></strong><span class="koboSpan" id="kobo.58.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.59.1">HOCs</span></strong><span class="koboSpan" id="kobo.60.1"> tried to solve this problem. </span><span class="koboSpan" id="kobo.60.2">But those patterns require modifying the structure of the component hierarchy, which makes the application cumbersome with the several layers of wrappers and makes it harder to follow </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">the code.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.62.1">As a result, Hooks were introduced to separate stateful logic from the components without modifying the </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">component hierarchy.</span></span></p></li>
<li><em class="italic"><span class="koboSpan" id="kobo.64.1">Difficulty in understanding the complex components</span></em><span class="koboSpan" id="kobo.65.1">: As an application grows, the components become much more complex with a full set of stateful logic and side effects. </span><span class="koboSpan" id="kobo.65.2">The life cycle methods become occupied with a mix of unrelated logic </span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.66.1">such as data fetching, adding event listeners, or removing event listeners in one place. </span><span class="koboSpan" id="kobo.66.2">For example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">componentDidMount</span></strong><span class="koboSpan" id="kobo.68.1"> life cycle method can perform data fetching for the component and add the event listeners too. </span><span class="koboSpan" id="kobo.68.2">At the same time, the related event listener logic, such as cleanup, needs to be added in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">componentWillUnmount</span></strong><span class="koboSpan" id="kobo.70.1"> life cycle method. </span><span class="koboSpan" id="kobo.70.2">Ultimately, it becomes difficult to split the larger components into small components and, at the same time, difficult to </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">test them.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.72.1">Hooks can split the larger components into smaller functions with the related piece of code rather than splitting the code based on the life </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">cycle methods.</span></span></p></li>
<li><em class="italic"><span class="koboSpan" id="kobo.74.1">Confusion created by classes</span></em><span class="koboSpan" id="kobo.75.1">: Classes are not specific to React, but they belong to JavaScript. </span><span class="koboSpan" id="kobo.75.2">If you would like to work on class components, first you should have a clear </span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.76.1">idea about </span><strong class="bold"><span class="koboSpan" id="kobo.77.1">the</span></strong><span class="koboSpan" id="kobo.78.1"> keyword behavior called </span><strong class="bold"><span class="koboSpan" id="kobo.79.1">this</span></strong><span class="koboSpan" id="kobo.80.1">, which is different from that in other languages. </span><span class="koboSpan" id="kobo.80.2">Also, if you are not familiar with using ES2022 public class fields syntax, you need to remember about binding event listeners in the constructor. </span><span class="koboSpan" id="kobo.80.3">All these concepts created a lot of confusion among the developers about the </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">proper usage.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.82.1">Hooks are helpful for creating React features without writing the classes and to avoid confusion within the </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">developer community.</span></span></p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.84.1">Can you describe the rules of Hook usage?</span></h2>
<p><span class="koboSpan" id="kobo.85.1">There are </span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.86.1">two main rules to be followed while </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">using Hooks:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.88.1">Call Hooks at the top level only</span></strong><span class="koboSpan" id="kobo.89.1">: You shouldn’t invoke Hooks inside loops, conditions, or nested functions that are part of React’s component logic. </span><span class="koboSpan" id="kobo.89.2">Instead, it is highly recommended to follow the rule of using Hooks at the top level of your React function components before any </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">early returns.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.91.1">This guideline will ensure that Hooks have been called in the same order irrespective of </span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.92.1">the component logic each time a component is rendered. </span><span class="koboSpan" id="kobo.92.2">In other words, it preserves the state of Hooks between multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">useState</span></strong><span class="koboSpan" id="kobo.94.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">useEffect</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.96.1"> Hooks.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.97.1">Call Hooks from React functions only</span></strong><span class="koboSpan" id="kobo.98.1">: You shouldn’t call Hooks from regular JavaScript functions. </span><span class="koboSpan" id="kobo.98.2">Instead, you can call them from either React function components or </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">custom Hooks.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.100.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.101.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">eslint</span></strong><span class="koboSpan" id="kobo.103.1"> plugin </span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.104.1">named </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">eslint-plugin-react-Hooks</span></strong><span class="koboSpan" id="kobo.106.1"> (</span><a href="https://www.npmjs.com/package/eslint-plugin-react-hooks"><span class="koboSpan" id="kobo.107.1">https://www.npmjs.com/package/eslint-plugin-react-hooks</span></a><span class="koboSpan" id="kobo.108.1">) can be used to enforce the two rules described in the </span><em class="italic"><span class="koboSpan" id="kobo.109.1">Can you describe the rules of Hook </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.110.1">usage?</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.111.1"> section.</span></span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.112.1">Can I use Hooks inside class components?</span></h2>
<p><span class="koboSpan" id="kobo.113.1">You cannot write Hooks inside class components. </span><span class="koboSpan" id="kobo.113.2">In other words, Hooks have been created for </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.114.1">the function components only. </span><span class="koboSpan" id="kobo.114.2">However, you can mix class components, and function components with Hooks in a single component tree without causing </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">any problems.</span></span></p>
<p><span class="koboSpan" id="kobo.116.1">React components hold the data and keep track of data changes using an updatable structure called the </span><strong class="bold"><span class="koboSpan" id="kobo.117.1">state</span></strong><span class="koboSpan" id="kobo.118.1">. </span><span class="koboSpan" id="kobo.118.2">In real-world applications, most components use the state to process and display the data in their UI. </span><span class="koboSpan" id="kobo.118.3">In the next section, we will be covering questions and their answers related to local state management using </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">state Hooks.</span></span></p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.120.1">Local state management using Hooks</span></h1>
<p><span class="koboSpan" id="kobo.121.1">There are two </span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.122.1">Hooks to achieve local state management </span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.123.1">inside React applications. </span><span class="koboSpan" id="kobo.123.2">The first Hook, named </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">useState</span></strong><span class="koboSpan" id="kobo.125.1">, can be used for simple state transformations, and the other Hook, </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">useReducer</span></strong><span class="koboSpan" id="kobo.127.1">, is used for complex state logic. </span><span class="koboSpan" id="kobo.127.2">Basically, </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">useState</span></strong><span class="koboSpan" id="kobo.129.1"> uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">useReducer</span></strong><span class="koboSpan" id="kobo.131.1"> internally. </span><span class="koboSpan" id="kobo.131.2">This means that the entire component state can be managed through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">useReducer</span></strong><span class="koboSpan" id="kobo.133.1"> Hook itself. </span><span class="koboSpan" id="kobo.133.2">Since the state is a core building block of a React component, every developer should have a clear idea about managing the state </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">using Hooks.</span></span></p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.135.1">What is the useState Hook?</span></h2>
<p><span class="koboSpan" id="kobo.136.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">useState</span></strong><span class="koboSpan" id="kobo.138.1"> Hook is used to add the state to a function component. </span><span class="koboSpan" id="kobo.138.2">This is one of the most </span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.139.1">used built-in Hooks from React. </span><span class="koboSpan" id="kobo.139.2">This Hook takes the initial state as an argument and the same initial state can be either a value or </span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.140.1">a function type (i.e., initializer function). </span><span class="koboSpan" id="kobo.140.2">If the initial state is derived from an expensive computation, it is suggested to use the initializer function, which will be executed only on the initial render. </span><span class="koboSpan" id="kobo.140.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">useState</span></strong><span class="koboSpan" id="kobo.142.1"> Hook returns an array that contains two values: the state variable and the setter function to update </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">the state.</span></span></p>
<p><span class="koboSpan" id="kobo.144.1">The syntactic representation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">useState</span></strong><span class="koboSpan" id="kobo.146.1"> looks </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.148.1">
const [state, setState] = useState(initialState)</span></pre> <p><span class="koboSpan" id="kobo.149.1">Let’s take an example of a counter component that preserves the state of a counter using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">useState</span></strong><span class="koboSpan" id="kobo.151.1"> Hook. </span><span class="koboSpan" id="kobo.151.2">The setter function is used to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">count</span></strong><span class="koboSpan" id="kobo.153.1"> state variable and re-render the UI for </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">any changes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.155.1">
import { useState } from "react";
function Counter() {
  const [count, setCount] = useState(0);
  return (
    &lt;&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me&lt;/button&gt;
    &lt;/&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.156.1">Upon clicking </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.157.1">the counter button each time, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">count</span></strong> <a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.159.1">state variable will be incremented by one and the respective UI updated with the latest state </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">variable's value.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.161.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.162.1">The state setter function doesn’t update the current state in the already executing code. </span><span class="koboSpan" id="kobo.162.2">It will be available only in the </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">next render.</span></span></p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.164.1">Is it always recommended to use an updater function?</span></h2>
<p><span class="koboSpan" id="kobo.165.1">You might hear about the recommendation from the developer community to always use an updater </span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.166.1">function to update the state if the new state is calculated from the previous state. </span><span class="koboSpan" id="kobo.166.2">This rule is helpful to avoid an </span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.167.1">unpredictable state after doing some state calculation logic. </span><span class="koboSpan" id="kobo.167.2">Even though there is no harm in following this rule, it is not always necessary. </span><span class="koboSpan" id="kobo.167.3">In most cases, React will update the state variable before the next event happens. </span><span class="koboSpan" id="kobo.167.4">That is, there is no risk of stale data for the state in the beginning of the </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">event handler.</span></span></p>
<p><span class="koboSpan" id="kobo.169.1">But if you are doing multiple state updates in the same event handler, then it is suggested to use an updater function to receive the expected data result. </span><span class="koboSpan" id="kobo.169.2">The usage of an updater function inside an event handler is coded </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.171.1">
function handleClick() {
  setCounter(a =&gt; a + 1);
  setCounter(a =&gt; a + 1);
  setCounter(a =&gt; a + 1);
}</span></pre> <p><span class="koboSpan" id="kobo.172.1">In this code, </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">a =&gt; a + 1</span></strong><span class="koboSpan" id="kobo.174.1"> is an updater function. </span><span class="koboSpan" id="kobo.174.2">React puts your updater functions in a queue </span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.175.1">and as a result, updates on same state variables are batched. </span><span class="koboSpan" id="kobo.175.2">During the next render, React will call them in the </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">same order.</span></span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.177.1">What is a useReducer Hook? </span><span class="koboSpan" id="kobo.177.2">How do you use it?</span></h2>
<p><span class="koboSpan" id="kobo.178.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">useReducer</span></strong><span class="koboSpan" id="kobo.180.1"> Hook is </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.181.1">an alternative to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">useState</span></strong><span class="koboSpan" id="kobo.183.1"> Hook. </span><span class="koboSpan" id="kobo.183.2">It </span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.184.1">is used to separate the custom state logic (e.g., add, update, and delete items of a state) from the rendering logic. </span><span class="koboSpan" id="kobo.184.2">In other words, it is helpful for extracting the state management out of </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">the component.</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">This Hook accepts three arguments. </span><span class="koboSpan" id="kobo.186.2">The first argument is a reducer function that specifies how to update the state, the second argument is for the initial state, and the third argument is an optional initializer function to determine the initial state. </span><span class="koboSpan" id="kobo.186.3">In contrast, </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">useState</span></strong><span class="koboSpan" id="kobo.188.1"> just accepts the </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">initial state.</span></span></p>
<p><span class="koboSpan" id="kobo.190.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">useReducer</span></strong><span class="koboSpan" id="kobo.192.1"> Hook returns an array with two values, current state and dispatch function, which is used to modify the state and </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">trigger re-renders.</span></span></p>
<p><span class="koboSpan" id="kobo.194.1">Let’s understand the usage of this Hook with a counter example. </span><span class="koboSpan" id="kobo.194.2">Here, you can update the counter state value with increment, decrement, and reset actions using a </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">reducer function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.196.1">
ffunction reducer(state, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    case "reset":
      return { count: action.payload };
    default:
      throw new Error();
  }
}
function init(initialCount) {
  return { count: initialCount };
}
function Counter() {
  const initialCount = 0;
  const [state, dispatch] = useReducer(reducer, initialCount, init);
  return (
    &lt;&gt;
      Count: {state.count}
      &lt;button
        onClick={() =&gt; dispatch({ type: "reset", payload: initialCount })}
      &gt;
        Reset
      &lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: "decrement" 
        })}&gt;decrement&lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: "increment" 
        })}&gt;increment&lt;/button&gt;
    &lt;/&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.197.1">React will save the initial state once and ignore it for the next renders. </span><span class="koboSpan" id="kobo.197.2">So, you need to avoid recreating the initial state for each render if you are deriving the state through a function call. </span><span class="koboSpan" id="kobo.197.3">Instead, you can use an initializer function as a third argument for the </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">reducer function.</span></span></p>
<p><span class="koboSpan" id="kobo.199.1">In the third </span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.200.1">argument in the preceding code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">init</span></strong><span class="koboSpan" id="kobo.202.1"> function has </span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.203.1">been used to process the initial state based on a default value mentioned as the second argument within </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">the Hook.</span></span></p>
<p><span class="koboSpan" id="kobo.205.1">The important phases of the preceding code are described in the </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.207.1">When any of the button-click events are triggered, the respective event handler will be dispatched with an action to the </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">reducer function.</span></span></li>
<li><span class="koboSpan" id="kobo.209.1">Thereafter, the reducer function will update the state to a new state based on </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">the requirement.</span></span></li>
<li><span class="koboSpan" id="kobo.211.1">The state update will trigger the component to re-render to update </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">the UI.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.213.1">The flow diagram in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.214.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.215.1">.1</span></em><span class="koboSpan" id="kobo.216.1"> depicts the </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">useReducer</span></strong><span class="koboSpan" id="kobo.218.1"> Hook’s behavior in a </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">step-by-step manner:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<span class="koboSpan" id="kobo.220.1"><img alt="Figure 3.1: Behavior of the useReducer Hook" src="image/Figure_03.01_B18603.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.221.1">Figure 3.1: Behavior of the useReducer Hook</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.222.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.223.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">useReducer</span></strong><span class="koboSpan" id="kobo.225.1"> Hook won’t </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.226.1">re-render the children if there is </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.227.1">no change in state compared to the </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">previous state.</span></span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.229.1">When should you use the useReducer Hook over the useState Hook?</span></h2>
<p><span class="koboSpan" id="kobo.230.1">Both </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.231.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">useReducer</span></strong><span class="koboSpan" id="kobo.233.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">useState</span></strong><span class="koboSpan" id="kobo.235.1"> Hooks are </span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.236.1">helpful in managing the application state, but the </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">useReducer</span></strong><span class="koboSpan" id="kobo.238.1"> Hook provides a well-controlled and powerful state management solution for the </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">following reasons:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.240.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">useReducer</span></strong><span class="koboSpan" id="kobo.242.1"> Hook is preferred over </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">useState</span></strong><span class="koboSpan" id="kobo.244.1"> when you need to manage complex state logic. </span><span class="koboSpan" id="kobo.244.2">For example, when the state contains multiple nested values or the next state depends on the previous one, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">useReducer</span></strong><span class="koboSpan" id="kobo.246.1"> Hook is a </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">better choice.</span></span></li>
<li><span class="koboSpan" id="kobo.248.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">useReducer</span></strong><span class="koboSpan" id="kobo.250.1"> Hook can handle multiple actions in a single function rather than creating separate functions for each action using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">useState</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.252.1"> Hook.</span></span></li>
<li><span class="koboSpan" id="kobo.253.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">useReducer</span></strong><span class="koboSpan" id="kobo.255.1"> Hook is also helpful in optimizing the performance of components that trigger deep or nested updates, because you can pass down a dispatch function of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">useReducer</span></strong><span class="koboSpan" id="kobo.257.1"> Hook at any nested level via context instead of passing callbacks to every level of a component tree. </span><span class="koboSpan" id="kobo.257.2">In other words, it helps </span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.258.1">in avoiding the prop </span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.259.1">drilling issue mentioned in </span><a href="B18603_02.xhtml#_idTextAnchor055"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.260.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.261.1">. </span><span class="koboSpan" id="kobo.261.2">Moreover, the dispatch function won’t change </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">between re-renders.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.263.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.264.1">Since </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">useState</span></strong><span class="koboSpan" id="kobo.266.1"> itself is derived from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">useReducer</span></strong><span class="koboSpan" id="kobo.268.1"> Hook under the hood, you can cover all the state use cases </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">useReducer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.272.1">If you need to share the component state with multiple child components that exist in the deeper level of a component tree, it is preferred to use the in-built context Hook from React. </span><span class="koboSpan" id="kobo.272.2">This Hook is mainly used to maintain application-wide data, which is known as global </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">state management.</span></span></p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.274.1">Global state management using Hooks</span></h1>
<p><span class="koboSpan" id="kobo.275.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">useContext</span></strong><span class="koboSpan" id="kobo.277.1"> Hook is commonly used along with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">useState</span></strong><span class="koboSpan" id="kobo.279.1"> Hook for global state </span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.280.1">management. </span><span class="koboSpan" id="kobo.280.2">The major advantage of </span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.281.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">useContext</span></strong><span class="koboSpan" id="kobo.283.1"> Hook is that it solves the prop </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">drilling issue.</span></span></p>
<p><span class="koboSpan" id="kobo.285.1">Detailed common use cases of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">useContext</span></strong><span class="koboSpan" id="kobo.287.1"> Hook were already explained in </span><a href="B18603_02.xhtml#_idTextAnchor055"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.288.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.289.1">. </span><span class="koboSpan" id="kobo.289.2">Hence, this section will mainly focus on specific use case questions related to global state management using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">useContext</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.291.1"> Hook.</span></span></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.292.1">How do you override context for a specific part of the component tree?</span></h2>
<p><span class="koboSpan" id="kobo.293.1">Sometimes, you may need to override the context with a different value for a certain part of the </span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.294.1">component tree. </span><span class="koboSpan" id="kobo.294.2">It is possible to override the context value by wrapping that part in a provider with a </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">different value.</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">As an example, the following code applies a blue background to all the pages except for the contact page, where a white background will be applied using a </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">context provider:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.298.1">
&lt;ColorContext.Provider value="blue"&gt;
  &lt;About /&gt;
  &lt;Services /&gt;
  &lt;Clients /&gt;
  &lt;ColorContext.Provider value="white"&gt;
    &lt;Contact /&gt;
  &lt;/ColorContext.Provider&gt;
&lt;/ColorContext.Provider&gt;</span></pre> <p><span class="koboSpan" id="kobo.299.1">There is no restriction on the nesting level or number of times you override the context using </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">a provider.</span></span></p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.301.1">What would the context value be for no matching provider?</span></h2>
<p><span class="koboSpan" id="kobo.302.1">If there </span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.303.1">is no matching provider above the calling component of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">useContext</span></strong><span class="koboSpan" id="kobo.305.1"> Hook, the default value mentioned in the context creation will be returned – that is, the default value used </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">createContext(defaultValue)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.309.1">If you specify a default value, you can avoid unexpected errors on the page for any missing providers in the </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">component tree.</span></span></p>
<p><span class="koboSpan" id="kobo.311.1">In class components, the side effects are handled in different life cycle methods such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">componentDidMount</span></strong><span class="koboSpan" id="kobo.313.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">componentDidUpdate</span></strong><span class="koboSpan" id="kobo.315.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">componentWillUnmount</span></strong><span class="koboSpan" id="kobo.317.1"> based on the requirement. </span><span class="koboSpan" id="kobo.317.2">On the other hand, in function components, effect Hooks simplify the handling of side effects based on rendering in a single place. </span><span class="koboSpan" id="kobo.317.3">The next section will cover frequently asked questions about performing side effects in </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">React applications.</span></span></p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.319.1">Performing side effects in React applications</span></h1>
<p><span class="koboSpan" id="kobo.320.1">Effects are an escape hatch in React programming. </span><span class="koboSpan" id="kobo.320.2">React provides a few effect Hooks that are </span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.321.1">used to implement side effects such as data fetching, subscriptions, timers, logging, DOM manipulations, and so on within function components. </span><span class="koboSpan" id="kobo.321.2">These Hooks should be used only when you are synchronizing with external systems. </span><span class="koboSpan" id="kobo.321.3">There are three types of </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">Hooks available:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.323.1">useEffect</span></strong><span class="koboSpan" id="kobo.324.1">: This is a </span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.325.1">frequently used Hook to connect </span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.326.1">a component to an </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">external system.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.328.1">useLayoutEffect</span></strong><span class="koboSpan" id="kobo.329.1">: This Hook </span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.330.1">is the same as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">useEffect</span></strong><span class="koboSpan" id="kobo.332.1"> Hook </span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.333.1">except that it fires before the browser repaints the screen to measure </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">the layout.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.335.1">useInsertionEffect</span></strong><span class="koboSpan" id="kobo.336.1">: This </span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.337.1">Hook fires before </span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.338.1">React makes changes to the DOM, such as adding </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">dynamic CSS.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.340.1">Let’s thoroughly discuss the various effect Hooks and their features to answer the questions asked in </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">the interview.</span></span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.342.1">How do reactive dependencies impact the logic inside the useEffect Hook?</span></h2>
<p><span class="koboSpan" id="kobo.343.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">useEffect</span></strong><span class="koboSpan" id="kobo.345.1"> Hook accepts an optional dependencies argument that accepts an array of </span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.346.1">reactive values. </span><span class="koboSpan" id="kobo.346.2">You cannot choose </span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.347.1">dependencies for your effect and every reactive value should be declared as a dependency to avoid any kinds of bugs. </span><span class="koboSpan" id="kobo.347.2">There are different scenarios for passing the </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">reactive dependencies.</span></span></p>
<h3><span class="koboSpan" id="kobo.349.1">Passing the dependency array</span></h3>
<p><span class="koboSpan" id="kobo.350.1">If you </span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.351.1">pass the reactive values in a dependency array, the effect should run the logic after the initial render and also after each re-render with the </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">changed dependencies.</span></span></p>
<p><span class="koboSpan" id="kobo.353.1">The following is an example of passing name and status reactive dependencies to understand the syntax of </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">useEffect</span></strong><span class="koboSpan" id="kobo.355.1"> with an array </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">of dependencies:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.357.1">
useEffect(() =&gt; {
  // Runs after first render and every re-render with
     dependency change
}, [name, status]);</span></pre> <h3><span class="koboSpan" id="kobo.358.1">Passing the empty dependency array</span></h3>
<p><span class="koboSpan" id="kobo.359.1">If your </span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.360.1">effect doesn’t use any reactive values, it only runs after the initial render. </span><span class="koboSpan" id="kobo.360.2">In this case, the effect Hook looks </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.362.1">
useEffect(() =&gt; {
  // Runs after initial render only
}, []);</span></pre> <h3><span class="koboSpan" id="kobo.363.1">Not passing the dependency array</span></h3>
<p><span class="koboSpan" id="kobo.364.1">If you </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.365.1">skip passing the dependency array, itself the effect runs after every re-render of your component, </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.367.1">
useEffect(() =&gt; {
  // Runs after every re-render
});</span></pre> <p><span class="koboSpan" id="kobo.368.1">React will compare each reactive value from the dependency array with its previous value using </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">Object.is</span></strong><span class="koboSpan" id="kobo.370.1"> comparison to verify </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">the changes.</span></span></p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.372.1">How often are setup and cleanup functions invoked inside the useEffect Hook?</span></h2>
<p><span class="koboSpan" id="kobo.373.1">In most cases, effects should have a cleanup function to clear or undo the changes created </span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.374.1">by their respective setup code. </span><span class="koboSpan" id="kobo.374.2">React invokes </span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.375.1">setup and cleanup functions in the following different phases of the component </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">life cycle:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.377.1">Mounting</span></strong><span class="koboSpan" id="kobo.378.1">: The logic inside the setup function runs whenever the component is added to the DOM </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">or view.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.380.1">Re-rendering</span></strong><span class="koboSpan" id="kobo.381.1">: After every re-rendering of a component along with its dependency change, the cleanup (if it is defined) and setup functions will be invoked in an order. </span><span class="koboSpan" id="kobo.381.2">Here, the cleanup function runs with the old props and state, and the setup code runs with the latest props and </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">state thereafter.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.383.1">Unmounting</span></strong><span class="koboSpan" id="kobo.384.1">: The cleanup code runs one final time after the component is removed from the DOM or view. </span><span class="koboSpan" id="kobo.384.2">This cleanup function helps to avoid unwanted behaviors such as memory leaks and to </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">improve performance.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.386.1">If strict mode is turned on in your React application, there will be an extra development-only </span><strong class="bold"><span class="koboSpan" id="kobo.387.1">setup and cleanup cycle</span></strong><span class="koboSpan" id="kobo.388.1"> before the first actual setup call. </span><span class="koboSpan" id="kobo.388.2">This is to ensure the cleanup logic mirrors the setup logic to avoid any discrepancies with the </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">setup code.</span></span></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.390.1">When should you remove an object or a function from dependencies?</span></h2>
<p><span class="koboSpan" id="kobo.391.1">There might be a situation where your effect might re-run more frequently than necessary </span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.392.1">if that effect depends on an object or a function created during rendering. </span><span class="koboSpan" id="kobo.392.2">This is because the object or function created is different for </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">every render.</span></span></p>
<p><span class="koboSpan" id="kobo.394.1">Let’s understand this concept in a better way using an example. </span><span class="koboSpan" id="kobo.394.2">The following is an example of fetching a list of users inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">useEffect</span></strong><span class="koboSpan" id="kobo.396.1"> Hook based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">Url</span></strong><span class="koboSpan" id="kobo.398.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">name</span></strong><span class="koboSpan" id="kobo.400.1"> query parameter dependencies. </span><span class="koboSpan" id="kobo.400.2">Here, the query object has been created during rendering to build the absolute </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">URL path:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.402.1">
const userUrl = "https://jsonplaceholder.typicode.com/users";
export default function Users() {
  const [users, setUsers] = useState([]);
  const [name, setName] = useState("John");
  const [message, setMessage] = useState("");
  const userQueryOptions = {
    url: userUrl,
    name,
  };
  useEffect(() =&gt; {
    const userUrl = buildUserURL(userQueryOptions); //buildUserURL is 
      excluded from code snippet
    fetch(userUrl)
      .then((res) =&gt; res.json())
      .then((users) =&gt; setUsers(users));
  }, [userQueryOptions]);
  return (
    &lt;&gt;
      Users: {message}
      &lt;input value={message} onChange={(e) =&gt; setMessage(e.target.
</span><span class="koboSpan" id="kobo.402.2">        value)} /&gt;
      &lt;input value={name} onChange={(e) =&gt; setName(e.target.value)} /&gt;
      {users &amp;&amp;
        users.map((user) =&gt; (
          &lt;div&gt;
            Name: {user.name}
            Email: {user.email}
          &lt;/div&gt;
        ))}
    &lt;/&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.403.1">In the preceding code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">userQueryOptions</span></strong><span class="koboSpan" id="kobo.405.1"> object has been recreated for every re-rendering due to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">message</span></strong><span class="koboSpan" id="kobo.407.1"> state changes. </span><span class="koboSpan" id="kobo.407.2">Also, this </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">message</span></strong><span class="koboSpan" id="kobo.409.1"> data is not related to reactive elements inside </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">the effect.</span></span></p>
<p><span class="koboSpan" id="kobo.411.1">This </span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.412.1">issue can be fixed by moving the object inside the effect and replacing the object dependency with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">name</span></strong><span class="koboSpan" id="kobo.414.1"> string, because </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">name</span></strong><span class="koboSpan" id="kobo.416.1"> is the only reactive value the effect </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">depends on:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.418.1">
useEffect(() =&gt; {
  const userOptions = {
    url: userUrl,
    name,
  };
  const userUrl = buildUserURL(userOptions);
  fetch(userUrl)
    .then((res) =&gt; res.json())
    .then((users) =&gt; setUsers(users));
}, [name]);</span></pre> <p><span class="koboSpan" id="kobo.419.1">In the same way, you can avoid creating the function during the rendering phase by moving it inside the effect Hook. </span><span class="koboSpan" id="kobo.419.2">After that, you can replace the function dependency with the direct reactive </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">dependency value.</span></span></p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.421.1">What is the useLayoutEffect Hook? </span><span class="koboSpan" id="kobo.421.2">How does it work?</span></h2>
<p><span class="koboSpan" id="kobo.422.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">useLayoutEffect</span></strong><span class="koboSpan" id="kobo.424.1"> Hook is a special type of effect Hook that is invoked before the browser repaints the screen. </span><span class="koboSpan" id="kobo.424.2">This Hook is mainly used for scenarios where the component </span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.425.1">flickers when the state is updated. </span><span class="koboSpan" id="kobo.425.2">Imagine a pop-over component on the web page. </span><span class="koboSpan" id="kobo.425.3">The component first needs to determine the position of the element in the viewport before rendering it correctly on </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">the screen.</span></span></p>
<p><span class="koboSpan" id="kobo.427.1">The main purpose of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">useLayoutEffect</span></strong><span class="koboSpan" id="kobo.429.1"> Hook is to provide the layout information to the component for rendering. </span><span class="koboSpan" id="kobo.429.2">It works in three </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">simple steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.431.1">Render the initial content without </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">layout information.</span></span></li>
<li><span class="koboSpan" id="kobo.433.1">Calculate the layout size before the browser repaints </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">the screen.</span></span></li>
<li><span class="koboSpan" id="kobo.435.1">Re-render the component using the correct </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">layout information.</span></span></li>
</ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.437.1">Caution</span></p>
<p class="callout"><span class="koboSpan" id="kobo.438.1">The component is going to be rendered twice and will block the browser before it repaints the screen. </span><span class="koboSpan" id="kobo.438.2">This impacts the application performance. </span><span class="koboSpan" id="kobo.438.3">Therefore, it is recommended to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">useLayoutEffect</span></strong><span class="koboSpan" id="kobo.440.1"> Hook only where it </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">is required.</span></span></p>
<p><span class="koboSpan" id="kobo.442.1">Since effects will run after every render, one of the major ways to improve performance in React applications is to avoid unnecessary re-renders. </span><span class="koboSpan" id="kobo.442.2">There are a few in-built Hooks created in React to optimize the performance. </span><span class="koboSpan" id="kobo.442.3">Let’s dive deep into those details in the </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">next section.</span></span></p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.444.1">Optimizing the application performance</span></h1>
<p><span class="koboSpan" id="kobo.445.1">The performance </span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.446.1">optimizations have a massive impact on the customer experience. </span><span class="koboSpan" id="kobo.446.2">Even though React applications have a very fast UI by default, there might be performance issues when the size of the application increases. </span><span class="koboSpan" id="kobo.446.3">This section will focus on the questions related to performance optimization Hooks, which you could expect to be asked by interviewers to gauge your skill from a </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">broader perspective.</span></span></p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.448.1">What is memoization? </span><span class="koboSpan" id="kobo.448.2">How can it be implemented in React?</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.449.1">Memoization</span></strong><span class="koboSpan" id="kobo.450.1"> is an </span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.451.1">optimization technique for speeding up web applications </span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.452.1">by caching the results of expensive function calls. </span><span class="koboSpan" id="kobo.452.2">It returns the cached result when the same input arguments have been </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">passed again.</span></span></p>
<p><span class="koboSpan" id="kobo.454.1">In React, this optimization can be implemented through two Hooks: </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">useMemo</span></strong><span class="koboSpan" id="kobo.456.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">useCallback</span></strong><span class="koboSpan" id="kobo.458.1">. </span><span class="koboSpan" id="kobo.458.2">These Hooks improve the performance, skipping the unnecessary re-rendering by returning the cached result when the same input </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">is given.</span></span></p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.460.1">Can you describe the useMemo() Hook?</span></h2>
<p><span class="koboSpan" id="kobo.461.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">useMemo()</span></strong><span class="koboSpan" id="kobo.463.1"> Hook is used </span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.464.1">to cache the result of an expensive calculation between re-renders. </span><span class="koboSpan" id="kobo.464.2">The syntax of this Hook looks </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.466.1">
const cachedValue = useMemo(calculateValue, dependencies)</span></pre> <p><span class="koboSpan" id="kobo.467.1">This Hook returns the value of the expensive calculation by accepting two arguments. </span><span class="koboSpan" id="kobo.467.2">The first argument is a function to do the expensive calculation, and the second is an array of dependencies that are reactive values used in the calculation. </span><span class="koboSpan" id="kobo.467.3">In other words, the cached result (or stored value from the last render) will be returned when there are no changes to the dependency values. </span><span class="koboSpan" id="kobo.467.4">Otherwise, the calculation will be </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">performed again.</span></span></p>
<p><span class="koboSpan" id="kobo.469.1">Let’s understand this concept with an example. </span><span class="koboSpan" id="kobo.469.2">Consider a factorial calculation function of a number and apply the </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">useMemo</span></strong><span class="koboSpan" id="kobo.471.1"> Hook around it. </span><span class="koboSpan" id="kobo.471.2">The component also performs an increment action that is independent of the </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">calculation function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.473.1">
import { useState, useMemo } from "react";
function factorial(number) {
  if (number &lt;= 0) {
    return "Number should be positive value.";
  } else if (number === 1) {
    return 1;
  } else {
    return number * factorial(number - 1);
  }
}
export default function CounterFactorial() {
  const [count, setCount] = useState(0);
  const [number, setNumber] = useState(1);
  const factorial = useMemo(() =&gt; factorial(number), [number]);
  return (
    &lt;&gt;
      &lt;h2&gt;Counter: {count}&lt;/h2&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
      &lt;h2&gt;Factorial: {factorial}&lt;/h2&gt;
      &lt;input
        type="number"
        value={number}
        onClick={() =&gt; setNumber(number + 1)}
      /&gt;
    &lt;/&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.474.1">In the preceding code, if you increment the counter value, there won’t be any re-rendering related to the factorial function because the respective reactive number was not updated. </span><span class="koboSpan" id="kobo.474.2">That is, the </span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.475.1">factorial function will only be called where there is a change in the input number, but not when the counter value </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">is incremented.</span></span></p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.477.1">What are the possible use cases of the useMemo() Hook?</span></h2>
<p><span class="koboSpan" id="kobo.478.1">Memoization is helpful in optimizing the application performance, and some of the developers </span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.479.1">even think that there is no harm in memoizing almost all the components as much as possible. </span><span class="koboSpan" id="kobo.479.2">However, this technique is unnecessary for simple calculations within </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">the functions.</span></span></p>
<p><span class="koboSpan" id="kobo.481.1">There are a few common cases where memoization </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">is useful:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.483.1">When there are expensive calculations, such as sorting, filtering, changing the format, and so on while rendering </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">the content</span></span></li>
<li><span class="koboSpan" id="kobo.485.1">When you are passing a prop to a component wrapped within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">useMemo</span></strong><span class="koboSpan" id="kobo.487.1"> Hook and want to skip re-renderings when there is no change in the prop – that is, when pure components can be wrapped </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">within </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">useMemo</span></strong></span></li>
<li><span class="koboSpan" id="kobo.490.1">When the value passing to the wrapped component has been used as a dependency of some </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">other Hook</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.492.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.493.1">profiler</span></strong><span class="koboSpan" id="kobo.494.1"> section of </span><strong class="bold"><span class="koboSpan" id="kobo.495.1">React DevTools</span></strong><span class="koboSpan" id="kobo.496.1"> will be </span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.497.1">helpful in identifying the components that are laggy and require memoization </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">to add.</span></span></p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.499.1">What are common mistakes with the usage of useMemo? </span><span class="koboSpan" id="kobo.499.2">How do you rectify them?</span></h2>
<p><span class="koboSpan" id="kobo.500.1">The usage </span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.501.1">of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">useMemo</span></strong><span class="koboSpan" id="kobo.503.1"> Hook is quite straightforward, and this Hook might be used extensively to optimize the rendering performance. </span><span class="koboSpan" id="kobo.503.2">However, you need to be careful with some of the following </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">common mistakes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.505.1">If you try to return an object from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">useMemo</span></strong><span class="koboSpan" id="kobo.507.1"> Hook, then either wrap it with parentheses or write an explicit </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">return statement.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.509.1">For example, the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">useMemo</span></strong><span class="koboSpan" id="kobo.511.1"> Hook returns an undefined value because the opening brace ({) is part of an arrow function but not </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">the object:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.513.1">
  const findCity = useMemo(() =&gt; {
    country: 'USA',
    name: name
  }, [name]);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.514.1">This can be </span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.515.1">fixed by an explicit return statement for the object, </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.517.1">const findCity = useMemo(() =&gt; {
  return {
    country: "USA",
    name: name,
  };
}, [name]);</span></pre></li> <li><span class="koboSpan" id="kobo.518.1">If you forget to specify the dependencies, then the calculation will re-render </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">every time:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.520.1">
const filterCities = useMemo(() =&gt; filteredCities(city, country));</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.521.1">The reactive values used in the calculation are to be passed in the dependencies array to avoid </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">unnecessary renders:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.523.1">const filterCities = useMemo(
  () =&gt; filteredCities(city, country),
  [city, country]
);</span></pre></li> <li><span class="koboSpan" id="kobo.524.1">You shouldn’t call </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">useMemo</span></strong><span class="koboSpan" id="kobo.526.1"> inside loops. </span><span class="koboSpan" id="kobo.526.2">Instead, wrap it or extract it under a </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">new component:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.528.1">
{
  products.map((product) =&gt; {
    const revenue = useMemo(() =&gt; calculateRevenue(product), [product]);
    return (
      &lt;&gt;
        &lt;span&gt;Product: {product.name}&lt;/span&gt;
        &lt;span&gt;Revenue: {revenue}&lt;/span&gt;
      &lt;/&gt;
    );
  });
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.529.1">This can be </span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.530.1">solved by extracting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">useMemo</span></strong><span class="koboSpan" id="kobo.532.1"> calculation inside a </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">child component:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.534.1">{
  products.map((product) =&gt; {
    return &lt;Report product={product} /&gt;;
  });
}</span></pre></li> </ul>
<p><span class="koboSpan" id="kobo.535.1">The aforementioned points can be treated as best practices while working with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">useMemo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.537.1"> Hook.</span></span></p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.538.1">When should you use the useCallback Hook instead of the useMemo Hook?</span></h2>
<p><span class="koboSpan" id="kobo.539.1">When a top-level component re-renders, by default, React re-renders all its children recursively. </span><span class="koboSpan" id="kobo.539.2">This </span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.540.1">situation will impact the performance of the application if the child component has heavy calculation. </span><span class="koboSpan" id="kobo.540.2">In this case, the child component needs to be optimized using the Memo API or the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">useMemo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.542.1"> Hook.</span></span></p>
<p><span class="koboSpan" id="kobo.543.1">However, if you pass the callback function as a prop to the child component, React will always re-render the children because either the function definition or arrow function is treated as a new function every time re-rendering occurs. </span><span class="koboSpan" id="kobo.543.2">This defeats the purpose of memoization. </span><span class="koboSpan" id="kobo.543.3">In this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">useCallback</span></strong><span class="koboSpan" id="kobo.545.1"> is helpful in optimizing </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">the performance.</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">useCallback</span></strong><span class="koboSpan" id="kobo.549.1"> Hook is like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">useMemo</span></strong><span class="koboSpan" id="kobo.551.1"> Hook, but it caches the callback function instead of a value. </span><span class="koboSpan" id="kobo.551.2">You can still use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">useMemo</span></strong><span class="koboSpan" id="kobo.553.1"> Hook but the calculation function would have to return another function; that is, it requires an extra </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">nested function.</span></span></p>
<p><span class="koboSpan" id="kobo.555.1">Let’s discuss this concept with an example that contains </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">TaxCalculation</span></strong><span class="koboSpan" id="kobo.557.1"> as the parent component and </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">TaxPayer</span></strong><span class="koboSpan" id="kobo.559.1"> as the child component. </span><span class="koboSpan" id="kobo.559.2">In the child component, you need to skip re-rendering considering when the same props are sent and re-rendering </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">is slow.</span></span></p>
<p><span class="koboSpan" id="kobo.561.1">To skip re-rendering, first, you need to wrap the child component (</span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">TaxPayer</span></strong><span class="koboSpan" id="kobo.563.1">) with the </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">memo function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.565.1">
import { memo } from 'react';
const TaxPayer = memo(function TaxPayer({ onSubmit }) {
  // ...
</span><span class="koboSpan" id="kobo.565.2">});</span></pre> <p><span class="koboSpan" id="kobo.566.1">If the parent </span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.567.1">component re-renders with a change in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">income</span></strong><span class="koboSpan" id="kobo.569.1"> prop, then this change leads to the re-rendering of the child component as well. </span><span class="koboSpan" id="kobo.569.2">This won’t be a big problem when the child component doesn’t have any big calculations and changes from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">income</span></strong><span class="koboSpan" id="kobo.571.1"> prop </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">are minimal.</span></span></p>
<p><span class="koboSpan" id="kobo.573.1">However, if you pass a callback function to a child component as a prop, it creates a new function every time. </span><span class="koboSpan" id="kobo.573.2">This specific case should be avoided all the time, irrespective of the </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">performance impact.</span></span></p>
<p><span class="koboSpan" id="kobo.575.1">To skip the re-render because of a new prop every time, let’s apply the </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">useCallback</span></strong><span class="koboSpan" id="kobo.577.1"> Hook for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">handleSubmit</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.579.1">callback function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.580.1">
function TaxCalculation({ year, income}) {
  const handleSubmit = useCallback((taxPayerDetails) =&gt; {
    post('/tax/' + year, {
      taxPayerDetails,
    income
    });
  }, [year, income]);
  return (
    &lt;div&gt;
      &lt;TaxPayer onSubmit={handleSubmit} /&gt;
    &lt;/div&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.581.1">In the preceding code, the callback function is going to be memoized until or unless there is a </span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.582.1">change in dependency </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">reactive values.</span></span></p>
<p><span class="koboSpan" id="kobo.584.1">Similar to the Ref API that exists in class components, some Hooks have been created in function components especially to interact with DOM nodes. </span><span class="koboSpan" id="kobo.584.2">The next section talks about important concepts related to accessing the DOM nodes </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">using Hooks.</span></span></p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.586.1">Accessing DOM nodes using ref Hooks</span></h1>
<p><span class="koboSpan" id="kobo.587.1">Refs are useful when you need to work with external systems (or non-React systems) such as </span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.588.1">built-in browser APIs. </span><span class="koboSpan" id="kobo.588.2">There are two built-in ref Hooks available in function components. </span><span class="koboSpan" id="kobo.588.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">useRef</span></strong><span class="koboSpan" id="kobo.590.1"> Hook is used to declare a </span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.591.1">ref to hold any kind of value but is mainly used for DOM nodes. </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">useImperativeHandle</span></strong><span class="koboSpan" id="kobo.593.1"> is used to expose the customized ref with only the </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">required methods.</span></span></p>
<p><span class="koboSpan" id="kobo.595.1">Please note that an introduction to refs has already been covered in </span><a href="B18603_02.xhtml#_idTextAnchor055"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.596.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.597.1">. </span><span class="koboSpan" id="kobo.597.2">In this section, we will go beyond what we have already discussed about refs in </span><a href="B18603_02.xhtml#_idTextAnchor055"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.598.1">Chapter 2</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.599.1">.</span></span></p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.600.1">How do you avoid recreating the Ref contents?</span></h2>
<p><span class="koboSpan" id="kobo.601.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">useRef</span></strong><span class="koboSpan" id="kobo.603.1"> Hook accepts the initial value (or default value) as an argument, like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">useState</span></strong><span class="koboSpan" id="kobo.605.1"> Hook. </span><span class="koboSpan" id="kobo.605.2">The declaration of this Hook should be placed at the top of the </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">enclosed component.</span></span></p>
<p><span class="koboSpan" id="kobo.607.1">React saves </span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.608.1">this initial value at the first render and ignores it for the next renders, but if you create an expensive object for the initial value of the ref, it might be called for every render unnecessarily. </span><span class="koboSpan" id="kobo.608.2">This will impact the performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.610.1">The declaration of the initial ref value and how the ref content is recreated can be explained in a better way with the use of the </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.612.1">
function CreateBlogArticle() {
  // This is an expensive object to create the article
}
function Blog() {
  const articleRef = useRef(new CreateBlogArticle());
  //...
</span><span class="koboSpan" id="kobo.612.2">}</span></pre> <p><span class="koboSpan" id="kobo.613.1">In the preceding code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">CreateBlogArticle()</span></strong><span class="koboSpan" id="kobo.615.1"> function is always invoked to create the </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.616.1">expensive object, even though React ignores this object from the second </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">render onward.</span></span></p>
<p><span class="koboSpan" id="kobo.618.1">This issue can be resolved by restricting the invocation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">CreateBlogArticle()</span></strong><span class="koboSpan" id="kobo.620.1"> function for the subsequent renders, </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.622.1">
function Blog() {
  const articleRef = useRef(null);
  if (articleRef.current === null) {
    articleRef.current = new CreateBlogArticle();
  }
  //...
</span><span class="koboSpan" id="kobo.622.2">}</span></pre> <p><span class="koboSpan" id="kobo.623.1">Now the blog article object is calculated only once during the </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">initial rendering.</span></span></p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.625.1">Is it possible to access a ref in the render method?</span></h2>
<p><span class="koboSpan" id="kobo.626.1">Yes, you </span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.627.1">can access the current value of a ref inside the render method, but it is not recommended to read or write the </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">ref.current</span></strong><span class="koboSpan" id="kobo.629.1"> value during the render process. </span><span class="koboSpan" id="kobo.629.2">This is because the ref value appearing on the screen may not be updated for any events by knowing the fact that changing </span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.630.1">a ref doesn’t trigger re-rendering, unlike the </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">state variable.</span></span></p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.632.1">How do you expose a subset of methods from a ref instance?</span></h2>
<p><span class="koboSpan" id="kobo.633.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">useImperativeHandle</span></strong><span class="koboSpan" id="kobo.635.1"> Hook is used to expose customized methods or only a subset of </span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.636.1">existing methods of a DOM node from a child component to a parent component. </span><span class="koboSpan" id="kobo.636.2">This is useful to restrict a parent ref to access only certain functions or properties without giving access to the entire ref. </span><span class="koboSpan" id="kobo.636.3">The common use case is creating a component to share it under a library and consumers can access only the </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">exposed API.</span></span></p>
<p><span class="koboSpan" id="kobo.638.1">Let’s say you are planning to create a dialog component and want to share some basic features of the dialog in some top-level parent component. </span><span class="koboSpan" id="kobo.638.2">In this case, you can expose </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">open</span></strong><span class="koboSpan" id="kobo.640.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">close</span></strong><span class="koboSpan" id="kobo.642.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">reset</span></strong><span class="koboSpan" id="kobo.644.1"> methods inside child component instead of giving access to the entire dialog </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">DOM node:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.646.1">
useImperativeHandle(ref, () =&gt; ({
  open: () =&gt; ref.current.invokeDialog(),
  close: () =&gt; ref.current.closeDilaog(),
  reset: () =&gt; ref.current.clearData(),
}));</span></pre> <p><span class="koboSpan" id="kobo.647.1">The component which uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">useImperativeHandle</span></strong><span class="koboSpan" id="kobo.649.1"> Hook needs to be wrapped with forwardRef and the ref received as a second argument from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">forwardRef</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.651.1">render function.</span></span></p>
<p><span class="koboSpan" id="kobo.652.1">There are a few more built-in Hooks, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">useId</span></strong><span class="koboSpan" id="kobo.654.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">useDeferred</span></strong><span class="koboSpan" id="kobo.656.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">useTransition</span></strong><span class="koboSpan" id="kobo.658.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">useSyncExternalStore</span></strong><span class="koboSpan" id="kobo.660.1">, that are not covered because of their minimal usage. </span><span class="koboSpan" id="kobo.660.2">Let’s learn about </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">them quickly:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">useId</span></strong><span class="koboSpan" id="kobo.663.1">: This Hook is used to generate unique IDs for the HTML </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">accessibility attributes</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">useDeferred</span></strong><span class="koboSpan" id="kobo.666.1">: This Hook is used to defer updating a part of the UI until the latest data </span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">is available</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">useTransition</span></strong><span class="koboSpan" id="kobo.669.1">: This Hook is helpful to improve user responsiveness by marking some of the state modifications </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">as low-priority</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">useSyncExternalStore</span></strong><span class="koboSpan" id="kobo.672.1">: This Hook is used to subscribe to an external data store that exists outside the </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">React system</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.674.1">There are several built-in Hooks provided by React, but you can go beyond the usage of these Hooks </span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.675.1">and use third-party Hooks created by the React community to cover specific use cases based on your business needs. </span><span class="koboSpan" id="kobo.675.2">In the next section, we will cover questions related to third-party Hooks and their </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">respective answers.</span></span></p>
<h1 id="_idParaDest-141"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.677.1">Learning about popular third-party Hooks</span></h1>
<p><span class="koboSpan" id="kobo.678.1">The Hooks API is </span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.679.1">quite popular among the developer community, and built-in Hooks have existed since 2019. </span><span class="koboSpan" id="kobo.679.2">The developers tried to create many third-party Hooks, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">useImmer</span></strong><span class="koboSpan" id="kobo.681.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">useFetch</span></strong><span class="koboSpan" id="kobo.683.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">useDebounce</span></strong><span class="koboSpan" id="kobo.685.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">useForm</span></strong><span class="koboSpan" id="kobo.687.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">useLocalStorage</span></strong><span class="koboSpan" id="kobo.689.1">, Redux Hooks, and so on, to solve common use cases observed in web development. </span><span class="koboSpan" id="kobo.689.2">If you would like to master the Hooks concepts then you should have a good understanding of third-party Hooks and how they are useful to solve some </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">common problems.</span></span></p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.691.1">What is the useImmer Hook? </span><span class="koboSpan" id="kobo.691.2">What is its purpose?</span></h2>
<p><span class="koboSpan" id="kobo.692.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">useImmer</span></strong><span class="koboSpan" id="kobo.694.1"> Hook is just like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">useState</span></strong><span class="koboSpan" id="kobo.696.1"> Hook but it provides advantages while managing the </span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.697.1">complex state with nested levels of data. </span><span class="koboSpan" id="kobo.697.2">It updates the state as if it were directly mutable, similar to regular JavaScript. </span><span class="koboSpan" id="kobo.697.3">This Hook is based on the Immer library by creating a new copy of the state that can </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">be mutated.</span></span></p>
<p><span class="koboSpan" id="kobo.699.1">This Hook can be installed through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">use-immer</span></strong><span class="koboSpan" id="kobo.701.1"> npm library. </span><span class="koboSpan" id="kobo.701.2">Like </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">useState</span></strong><span class="koboSpan" id="kobo.703.1">, it returns a tuple. </span><span class="koboSpan" id="kobo.703.2">The first value of the tuple is the current state, and the second is the </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">updater function.</span></span></p>
<p><span class="koboSpan" id="kobo.705.1">Let’s see an example of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">UserProfile</span></strong><span class="koboSpan" id="kobo.707.1"> component and update the address details directly, </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.709.1">
import { useImmer } from "use-immer";
function UserProfile() {
  const [user, setUser] = useImmer({
    name: "Tom",
    address: {
      country: "United States",
      city: "Austin",
      postalCode: 73301,
    },
  });
  function updatePostalCode(code) {
    setUser((draft) =&gt; {
      draft.address.postalCode = code;
    });
  }
  return (
    &lt;div className="profile"&gt;
      &lt;h1&gt;
        Hello {user.name}, your latest postal code is ({user.address.
</span><span class="koboSpan" id="kobo.709.2">          postalCode}
        )
      &lt;/h1&gt;
      &lt;input
        onChange={(e) =&gt; {
          updatePostalCode(e.target.value);
        }}
        value={user.address.postalCode}
      /&gt;
    &lt;/div&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.710.1">Under the hood, </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">Immer</span></strong><span class="koboSpan" id="kobo.712.1"> creates a temporary draft object and all the changes are applied to it. </span><span class="koboSpan" id="kobo.712.2">Once all </span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.713.1">the mutations are completed, </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">Immer</span></strong><span class="koboSpan" id="kobo.715.1"> will produce the next </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">state object.</span></span></p>
<p><span class="koboSpan" id="kobo.717.1">If your use case is not fulfilled by built-in Hooks or by any third-party Hook, then you can build your own Hook to provide the solution for your needs. </span><span class="koboSpan" id="kobo.717.2">After the next section, you will be in a position to answer questions related to </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">custom Hooks.</span></span></p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.719.1">Building your own Hooks</span></h1>
<p><span class="koboSpan" id="kobo.720.1">Even though </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.721.1">React provides some built-in Hooks such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">useState</span></strong><span class="koboSpan" id="kobo.723.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">useEffect</span></strong><span class="koboSpan" id="kobo.725.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">useContext</span></strong><span class="koboSpan" id="kobo.727.1">, and so on for common use cases, you may sometimes need to use Hooks for specific requirements that cannot be solved by built-in Hooks or third-party libraries. </span><span class="koboSpan" id="kobo.727.2">By the end of this section, you will be able to answer questions related to custom Hooks and their purpose, and how to avoid traditional approaches to share the </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">component logic.</span></span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.729.1">What are custom Hooks? </span><span class="koboSpan" id="kobo.729.2">How do you create them?</span></h2>
<p><span class="koboSpan" id="kobo.730.1">React comes with several built-in Hooks, but it won’t restrict you from using Hooks for limited scenarios. </span><span class="koboSpan" id="kobo.730.2">It is also possible to create your own Hooks by extracting the component logic </span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.731.1">into separate reusable functions known as </span><strong class="bold"><span class="koboSpan" id="kobo.732.1">custom Hooks</span></strong><span class="koboSpan" id="kobo.733.1">. </span><span class="koboSpan" id="kobo.733.2">These Hooks are helpful in hiding the complex logic from the components. </span><span class="koboSpan" id="kobo.733.3">They cover a wide range of use cases such as data fetching, form handling, online or offline status subscriptions, connecting to a chat room, animations, and </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.735.1">The creation of custom Hooks and their usage can be explained in a better way with the demonstration of a real-time example. </span><span class="koboSpan" id="kobo.735.2">Let’s consider a blogging site application where you list all the posts of a particular user and at the same time display the comments on a particular post. </span><span class="koboSpan" id="kobo.735.3">Here, you need to create two components named </span><strong class="bold"><span class="koboSpan" id="kobo.736.1">Posts</span></strong><span class="koboSpan" id="kobo.737.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.738.1">Comments</span></strong><span class="koboSpan" id="kobo.739.1">. </span><span class="koboSpan" id="kobo.739.2">Both of these components need to fetch the data from the server based on a given URL with an optional query parameter. </span><span class="koboSpan" id="kobo.739.3">Once the response is received, both the components display the data on </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">the screen.</span></span></p>
<p><span class="koboSpan" id="kobo.741.1">Instead of having </span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.742.1">duplicated logic related to data fetching, loading, error handling, and so on in both components, the code can be moved to a separate reusable custom Hook prefixed with the word </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">use</span></strong><span class="koboSpan" id="kobo.744.1">. </span><span class="koboSpan" id="kobo.744.2">The data fetching Hook can be created with the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">useFetchData</span></strong><span class="koboSpan" id="kobo.746.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">useFetchData.js</span></strong><span class="koboSpan" id="kobo.748.1"> file, </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.750.1">
import { useState, useEffect } from "react";
const useFetchData = (url, initialData) =&gt; {
  const [data, setData] = useState(initialData);
  const [loading, setLoading] = useState(false);
  useEffect(() =&gt; {
    setLoading(true);
    fetch(url)
      .then((res) =&gt; res.json())
      .then((data) =&gt; setData(data))
    .catch((err) =&gt; console.log(err))
    .finally(() =&gt; setLoading(false));
  }, [url]);
  return {data, loading};
};
export default useFetchData;</span></pre> <p><span class="koboSpan" id="kobo.751.1">Thereafter, the above custom </span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.752.1">Hook can be used in consumer components created as a part of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">Posts.jsx</span></strong><span class="koboSpan" id="kobo.754.1"> files and </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">Comments.jsx</span></strong><span class="koboSpan" id="kobo.756.1">. </span><span class="koboSpan" id="kobo.756.2">The usage in the </span><strong class="bold"><span class="koboSpan" id="kobo.757.1">Posts</span></strong><span class="koboSpan" id="kobo.758.1"> component would look </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.760.1">
import useFetchData from './useFetchData.js';
export default function Posts() {
  const url = "https://jsonplaceholder.typicode.com/posts?userId=1";
  const { data, loading} = useFetchData(url, []);
  return (
    &lt;&gt;
      {loading &amp;&amp; &lt;p&gt;Loading posts… &lt;/p&gt;}
      {data &amp;&amp; (
    data.map((item) =&gt;
       &lt;div key={item?.title}&gt;
        &lt;p&gt;
          {item?.title}
                  &lt;br/&gt;
          {item?.body}
        &lt;/p&gt;
      &lt;/div&gt;
      )
      )}
    &lt;/&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.761.1">In the same way, you can reuse </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">useFetchData</span></strong><span class="koboSpan" id="kobo.763.1"> in the </span><strong class="bold"><span class="koboSpan" id="kobo.764.1">Comments</span></strong><span class="koboSpan" id="kobo.765.1"> component as well. </span><span class="koboSpan" id="kobo.765.2">After these </span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.766.1">changes, the </span><strong class="bold"><span class="koboSpan" id="kobo.767.1">Posts</span></strong><span class="koboSpan" id="kobo.768.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.769.1">Comments</span></strong><span class="koboSpan" id="kobo.770.1"> components’ code became much simpler, more concise, and </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">more readable.</span></span></p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.772.1">What are the benefits of custom Hooks?</span></h2>
<p><span class="koboSpan" id="kobo.773.1">The main advantage of using custom Hooks is code reusability without writing the duplicated </span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.774.1">logic in many components. </span><span class="koboSpan" id="kobo.774.2">There are a few other advantages as well to considering </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">custom Hooks:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.776.1">Maintainability</span></strong><span class="koboSpan" id="kobo.777.1">: It is easier to maintain code with custom Hooks. </span><span class="koboSpan" id="kobo.777.2">In the future, if you need to change the logic of the Hook, you only need to change the code in one place without disturbing other parts of the code – that is, components </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">or files.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.779.1">Readability</span></strong><span class="koboSpan" id="kobo.780.1">: The application code becomes cleaner and more readable using custom Hooks instead of wrapping layers of HOCs, providers and consumers, and render props around the actual presentation components shown in the UI. </span><span class="koboSpan" id="kobo.780.2">Moreover, the component code becomes much cleaner by moving out specific component logic into </span><span class="No-Break"><span class="koboSpan" id="kobo.781.1">separate Hooks.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.782.1">Testability</span></strong><span class="koboSpan" id="kobo.783.1">: You need to write separate tests for test containers and presentation components in React applications. </span><span class="koboSpan" id="kobo.783.2">This is challenging especially for integration tests if your containers use many HOCs. </span><span class="koboSpan" id="kobo.783.3">The complexity increases because you need to test the containers and the components together to perform integration tests. </span><span class="koboSpan" id="kobo.783.4">This issue can be eliminated with custom Hooks as they allow you to combine containers and components into a </span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">single component.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.785.1">Moreover, it is easier to write unit tests and mock Hooks compared </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">to HOCs.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.787.1">Community-driven Hooks</span></strong><span class="koboSpan" id="kobo.788.1">: The React community is already popular and has created many Hooks for their specific use cases. </span><span class="koboSpan" id="kobo.788.2">The recommended approach is first to check whether the Hook you are looking for has already been created by someone or not before going to create your own Hook. </span><span class="koboSpan" id="kobo.788.3">Some community-driven </span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.789.1">Hooks are available at </span><a href="https://usehooks.com/"><span class="koboSpan" id="kobo.790.1">https://usehooks.com/</span></a> <span class="No-Break"><span class="koboSpan" id="kobo.791.1">and </span></span><a href="https://github.com/imbhargav5/rooks"><span class="No-Break"><span class="koboSpan" id="kobo.792.1">https://github.com/imbhargav5/rooks</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.793.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.794.1">The advantages listed inspire many React developers to create custom Hooks for unique features encountered </span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.795.1">in their React applications. </span><span class="koboSpan" id="kobo.795.2">If any third-party open source library has already provided the Hook to cover your specific scenario, it is suggested to reuse the same Hook instead of reinventing the wheel by building a </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">custom Hook.</span></span></p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.797.1">Should you still consider using render props and HOCs?</span></h2>
<p><span class="koboSpan" id="kobo.798.1">Both render props and HOCs are traditional advanced patterns used in the React ecosystem </span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.799.1">to share the component state logic between components. </span><span class="koboSpan" id="kobo.799.2">However, Hooks are somewhat simpler and sufficient to cover </span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.800.1">use cases compared to these two traditional patterns. </span><span class="koboSpan" id="kobo.800.2">Moreover, using Hooks, you don’t need to change the existing component structure and add more components to end up with a </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">nested tree.</span></span></p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.802.1">Do you recommend moving effects into custom Hooks?</span></h2>
<p><span class="koboSpan" id="kobo.803.1">Effect Hooks are used to perform application side effects when you need to interact with the world outside of React’s scope. </span><span class="koboSpan" id="kobo.803.2">Some non-React systems can access web APIs, invoke external APIs, and so on. </span><span class="koboSpan" id="kobo.803.3">Over time, the number of effects in your code should be reduced by </span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.804.1">implementing specific solutions to your use cases. </span><span class="koboSpan" id="kobo.804.2">The standard guideline is to use effect Hooks when there are no built-in solutions available. </span><span class="koboSpan" id="kobo.804.3">This is because avoiding the effects makes your application simpler, faster to run, and less error-prone. </span><span class="koboSpan" id="kobo.804.4">By moving out your effects to custom Hooks, it becomes easier to upgrade the code related to effects when there are </span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">solutions available.</span></span></p>
<p><span class="koboSpan" id="kobo.806.1">As your application grows with lots of custom Hooks to fulfill the business requirements, the application complexity increases and there is a high chance of encountering bugs in the application. </span><span class="koboSpan" id="kobo.806.2">The next section addresses how to debug React </span><span class="No-Break"><span class="koboSpan" id="kobo.807.1">custom Hooks.</span></span></p>
<h1 id="_idParaDest-148"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.808.1">Troubleshooting and debugging Hooks</span></h1>
<p><span class="koboSpan" id="kobo.809.1">Traditional debugging methods, such as debuggers with an IDE and browser DevTools, are not </span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.810.1">effective for debugging custom Hooks. </span><span class="koboSpan" id="kobo.810.2">React provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">useDebugValue</span></strong><span class="koboSpan" id="kobo.812.1"> Hook to allow developers to debug custom Hooks by assigning </span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.813.1">custom formatted labels to them. </span><span class="koboSpan" id="kobo.813.2">By the end of this section, you will have an idea about debugging </span><span class="No-Break"><span class="koboSpan" id="kobo.814.1">custom Hooks.</span></span></p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.815.1">How do you debug custom Hooks?</span></h2>
<p><span class="koboSpan" id="kobo.816.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">useDebugValue</span></strong><span class="koboSpan" id="kobo.818.1"> Hook is used to extend the visualization of data related to the internal logic of custom Hooks within </span><strong class="bold"><span class="koboSpan" id="kobo.819.1">React DevTools</span></strong><span class="koboSpan" id="kobo.820.1">. </span><span class="koboSpan" id="kobo.820.2">This information appears inside the </span><strong class="bold"><span class="koboSpan" id="kobo.821.1">Component Inspector</span></strong><span class="koboSpan" id="kobo.822.1"> tab of the </span><strong class="bold"><span class="koboSpan" id="kobo.823.1">React </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.824.1">DevTools</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.825.1"> extension.</span></span></p>
<p><span class="koboSpan" id="kobo.826.1">The current </span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.827.1">debug information is limited to displaying the information about in-built Hooks used inside of our custom Hook. </span><span class="koboSpan" id="kobo.827.2">It is hard for developers to read the information by counting each line in the output and identifying which entry map corresponds to Hooks called inside the code. </span><span class="koboSpan" id="kobo.827.3">This difficulty can be rectified by adding additional entries to the </span><strong class="bold"><span class="koboSpan" id="kobo.828.1">React DevTools</span></strong><span class="koboSpan" id="kobo.829.1"> output for our </span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">custom Hook.</span></span></p>
<p><span class="koboSpan" id="kobo.831.1">Let’s understand this in a better way using an example. </span><span class="koboSpan" id="kobo.831.2">The required details can be logged in various places using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">useDebugValue</span></strong><span class="koboSpan" id="kobo.833.1"> Hook inside the custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">useFetchData</span></strong><span class="koboSpan" id="kobo.835.1"> Hook, as created in the </span><em class="italic"><span class="koboSpan" id="kobo.836.1">What are custom Hooks? </span><span class="koboSpan" id="kobo.836.2">How do you create </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.837.1">them?</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.838.1"> section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.839.1">
const useFetchData = (url, initialData) =&gt; {
    useDebugValue(url);
    const [data, setData] = useState(initialData);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState(null);
    useDebugValue(error, (err) =&gt;
      err ? </span><span class="koboSpan" id="kobo.839.2">`fetch is failed with ${err.message}` :
        "fetch is successful"
    );
    useEffect(() =&gt; {
      setLoading(true);
      fetch(url)
        .then((res) =&gt; res.json())
        .then((data) =&gt; setData(data))
        .catch((err) =&gt; setError(err))
        .finally(() =&gt; setLoading(false));
    }, [url]);
    useDebugValue(data, (items) =&gt;
      items.length &gt; 0 ? </span><span class="koboSpan" id="kobo.839.3">items.map((item) =&gt; item.title) :
        "No posts available"
  );
    return {data, loading};
};</span></pre> <p><span class="koboSpan" id="kobo.840.1">In the </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.841.1">preceding code, the second and third debug calls use an </span><em class="italic"><span class="koboSpan" id="kobo.842.1">optional second argument</span></em><span class="koboSpan" id="kobo.843.1"> to format the </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">displayed value.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.845.1">React DevTools</span></strong><span class="koboSpan" id="kobo.846.1"> will list all the additional entries under the label called </span><strong class="bold"><span class="koboSpan" id="kobo.847.1">DebugValue</span></strong><span class="koboSpan" id="kobo.848.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">FetchData</span></strong><span class="koboSpan" id="kobo.850.1"> custom Hook. </span><span class="koboSpan" id="kobo.850.2">For example, if you hover over the </span><strong class="bold"><span class="koboSpan" id="kobo.851.1">Posts</span></strong><span class="koboSpan" id="kobo.852.1"> component, the </span><strong class="bold"><span class="koboSpan" id="kobo.853.1">Hooks</span></strong><span class="koboSpan" id="kobo.854.1"> section on the right side looks </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<span class="koboSpan" id="kobo.856.1"><img alt="Figure 3.2: DebugValue label in DevTools" src="image/Figure_03.02_B18603.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.857.1">Figure 3.2: DebugValue label in DevTools</span></p>
<p><span class="koboSpan" id="kobo.858.1">In the same way, when the API throws an error due to service unavailability, the respective </span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.859.1">root cause can be tracked through the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.860.1">DebugValue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.861.1"> label.</span></span></p>
<p><span class="koboSpan" id="kobo.862.1">So far, we have discussed several questions related to built-in Hooks, followed by topics related to third-party Hooks and custom Hooks. </span><span class="koboSpan" id="kobo.862.2">All these topics have been covered in a specific order to understand the connection between various types </span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">of Hooks.</span></span></p>
<h1 id="_idParaDest-150"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.864.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.865.1">This chapter offered a thorough understanding of Hooks in React applications. </span><span class="koboSpan" id="kobo.865.2">We began by providing an introduction to Hooks, which included the motivation behind Hooks and rules to be followed when using Hooks. </span><span class="koboSpan" id="kobo.865.3">We next looked at state management within components using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">useState</span></strong><span class="koboSpan" id="kobo.867.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">useReducer</span></strong><span class="koboSpan" id="kobo.869.1"> Hooks, and global state management to share data across components using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">useContext</span></strong><span class="koboSpan" id="kobo.871.1"> Hook. </span><span class="koboSpan" id="kobo.871.2">Thereafter, we covered how to perform side effects in applications with the help of </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">effect Hooks.</span></span></p>
<p><span class="koboSpan" id="kobo.873.1">Apart from the frequently used built-in Hooks, we discussed accessing DOM nodes using ref Hooks, doing performance optimizations through Hooks, using third-party Hooks, and creating your own custom Hooks for your </span><span class="No-Break"><span class="koboSpan" id="kobo.874.1">business needs.</span></span></p>
<p><span class="koboSpan" id="kobo.875.1">In the next chapter, we will cover an important navigation library known as React Router to navigate from one page to another, and learn about its rich features. </span><span class="koboSpan" id="kobo.875.2">Another important topic to be discussed in that chapter is supporting internationalization and creating dynamic localized messages by passing </span><span class="No-Break"><span class="koboSpan" id="kobo.876.1">the arguments.</span></span></p>
</div>
</body></html>