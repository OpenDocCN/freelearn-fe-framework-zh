- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structuring Large-Scale, Multi-Platform Projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I wholeheartedly believe that the structure of a software project is one of
    the key factors in deciding success or failure. This includes the application
    architecture, as well as the development process and the whole project organization.
  prefs: []
  type: TYPE_NORMAL
- en: The bigger the project is, the more developers that work on the project, and
    the longer a project runs, the more important it is to have a good project structure.
    But small projects can also fail because of a bad structure. So, most of this
    chapter is also applicable to smaller projects.
  prefs: []
  type: TYPE_NORMAL
- en: The project structure is especially important when using React Native to develop
    an application for multiple platforms, not only for iOS and Android. Different
    platforms have different needs and bring different user expectations. The best
    example to showcase this is the difference between iOS and Android and the web.
  prefs: []
  type: TYPE_NORMAL
- en: As already mentioned in [*Chapter 4*](B16694_04.xhtml#_idTextAnchor079), *Styling,
    Storage, and Navigation in React Native*, the concept of navigation in a mobile
    app and a web app is completely different. This is something you have to think
    about when planning the structure of your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with investing in good architecture and a good project structure
    is that it always creates some overhead in the beginning. The following figure
    shows the dilemma:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Coding productivity reduces when the project grows over time'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16694_10_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – Coding productivity reduces when the project grows over time
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t invest in your architecture in the beginning, you will start with
    higher productivity. If you invest in your architecture, you have to think about
    what should be achieved, in which direction the project could potentially develop,
    and what usage, team size, and requirements you will have when your project reaches
    maximum success.
  prefs: []
  type: TYPE_NORMAL
- en: These considerations take some time, and the implementation and execution of
    standardized processes may take even more time. It’s always faster to just download
    a random template and start coding. But as stated before, it will pay off in the
    end, because with good application architecture and a good project structure,
    you will end up with software that’s easy to maintain, test, and develop.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is why you will learn about the following things in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an app architecture that works for large-scale enterprise projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using React Native to deploy to different platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusing code with your own libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to run the code in this chapter, you have to set up the following
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: A working React Native environment ([bit.ly/prn-setup-rn](https://bit.ly/prn-setup-rn)
    – React Native CLI Quickstart).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the example project in this repository: [https://bit.ly/prn-videoexample](https://bit.ly/prn-videoexample).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While most of this chapter should also work on Windows, I would recommend working
    on a Mac.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter contains some native code. You should have basic knowledge of Java
    or Kotlin and Objective-C or Swift for that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up an app architecture that works for large-scale enterprise projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we are talking about large-scale projects and how to set up a suitable
    app architecture, it makes sense to look at what’s different in these large-scale
    projects compared to small-team or even single-developer projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following points are the most important ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The project team is very big**: In large-scale projects, you usually have
    a big team with lots of developers. Often, these developers are scattered all
    over the world, which means they work in different time zones, have different
    first languages, and have completely different cultural backgrounds. That said,
    it is important to have a clear structure and clear responsibilities. Otherwise,
    your project will fail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiple developers will work on the same part of the application**: At the
    latest stage when a deadline is approaching and a feature has to be finished,
    multiple developers will work on the same feature and the same part of the application.
    This means you should think about how to structure your code so that this is possible
    without having conflicts all the time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Every error will be found by users**: In small projects with only a few users,
    it’s likely that a lot of errors will never be found. In large-scale applications
    with a lot of users, it is nearly impossible that errors will remain unrevealed.
    This means you have to put in a lot more effort to find the errors yourself before
    releasing your application to the public.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The code has to be tested programmatically**: The larger the project is,
    and the longer a project runs, the more important it is to programmatically test
    your code. At some point, it is impossible to handle all testing manually. This
    means you must have an app architecture that supports this automated testing very
    well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The code base will become very large**: As the term large-scale project already
    says, the project and its code base will become very large. This means you must
    provide a structure that makes it as easy as possible for new developers to understand
    what’s going on in the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these points in mind, we’ll try to find some architectural approaches to
    support all of this.
  prefs: []
  type: TYPE_NORMAL
- en: Adapting our example project structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important thing when the project grows is decomposition. This means
    you should try to split your components into small, meaningful segments wherever
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we look at the project structure of our example project, we have already
    done a good job of decomposing our application, and the architecture we chose
    works fine for our use case. It already contains some things I would recommend
    keeping, even in large-scale projects. These are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using services**: Every API, SDK, or third-party connector should be wrapped
    in your own service. That enables you to change SDKs or even services and partners
    with minimal effort.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The separation between components and views**: Reusable components and navigable
    views should be kept in separate folders. This makes it easier for new developers
    to find the views they are working on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, this approach also brings some problems with it, especially when the
    code base grows and multiple developers work on it:'
  prefs: []
  type: TYPE_NORMAL
- en: Components and views are hard to test programmatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The component directory will grow really fast and become really big
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single features will be hard to find and are scattered over the whole code base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code base as a whole will get quite confusing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple developers will have to touch the same files at the same time a lot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, we’ll make some adaptations to our approach. First, we’ll take care of
    the component level. So far, we write our component with its business logic, UI,
    style, and types in one file. This will change now. We’ll split our components
    into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index.tsx`: The `index` file contains the business logic of the component
    such as data fetching, as well as the connection to the global application state.
    It only renders the following `.view` component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<component>.view.tsx`: The `view` file contains the UI. It doesn’t hold its
    own state nor does it connect directly to the global application state. It only
    renders the props it gets from the `index` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<component>.styles.tsx`: The `styles` file contains the React Native StyleSheet
    or the styled-components, depending on which approach you chose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<component>.types.tsx`: The `types` file provides the data type for props
    and the state of the `index` and `view` files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this separation, we enable two things. First, it is much easier to have
    one developer work on the business logic and one on the UI, without creating merge
    conflicts or other problems. Second, our components now have much better support
    for automated testing.
  prefs: []
  type: TYPE_NORMAL
- en: We can use any component testing framework to render and test the views without
    having to mock our global state or our component state. And in addition to that,
    it’s much easier to integrate tools such as Storybook with this approach.
  prefs: []
  type: TYPE_NORMAL
- en: To see that approach in action, you can have a look at the GitHub repository,
    choose the `chapter-10-split-home-view` tag, and check out the `views/home` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Hint
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that everyone sticks to this pattern and to make it simpler to create
    new views and components, you can use file generators. These are small scripts
    that use a template and typically a component name to create the structure you
    want to have. You can see an example in the GitHub repository. Choose the `chapter-10-generator`
    tag and have a look at the `util` folder. You can use the generator with `npm
    run generate <name>` to generate a new view.
  prefs: []
  type: TYPE_NORMAL
- en: After this change on the component level, we’ll take a step back and look at
    the whole project again. The second change I would recommend when your project
    grows is to group your views and components by features. This makes it much easier
    to understand the whole project structure and navigate through the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'I must admit that this depends on personal preferences and some people also
    like the clear separation between components and views even in large-scale projects,
    but I prefer the feature approach. This approach works as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – A React Native feature-grouped architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16694_10_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2 – A React Native feature-grouped architecture
  prefs: []
  type: TYPE_NORMAL
- en: This approach groups the application by features. It also has a component folder,
    which contains very basic general components such as buttons, lists, and avatars
    – basically, things that are used in every feature of your app to provide a consistent
    user experience. But every feature also has its own component folder where you
    can put components that you created only for this feature. There is also a modification
    of this approach, where you put multiple views in one feature.
  prefs: []
  type: TYPE_NORMAL
- en: From my personal experience, I can say that this feature approach makes the
    code base very clearly structured, and it makes it easier to find what you are
    searching for. On the other hand, you’ll always have components where you are
    unsure whether you have to put them into the general components or not.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, you’ll have to find your own approach to how you want to structure
    your application. But in this section, you learned about the most important things
    you have to pay attention to in order to create a structure that works even when
    your project scales.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned how to structure a React Native project in general,
    we’ll go a step further and focus on going multi-platform.
  prefs: []
  type: TYPE_NORMAL
- en: Using React Native to deploy to different platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you’ll learn how to set up your React Native project to be
    able to support multiple platforms. Since it is the most common use case, we’ll
    focus a lot on the web here, but the tips and approaches of these sections are
    also applicable to other platforms such as desktops and TVs.
  prefs: []
  type: TYPE_NORMAL
- en: When creating an application for multiple platforms, there are always two goals.
    First, you want to support as many platform-specific features as possible and
    want to give users the look and feel they are used to on this platform. Second,
    you try to have as much shared code as possible because this makes it easier to
    maintain and develop your application.
  prefs: []
  type: TYPE_NORMAL
- en: At first sight, these goals seem to be concurrent but there are intelligent
    ways to get the best of both worlds. Let’s start with the simplest approach.
  prefs: []
  type: TYPE_NORMAL
- en: Using react-native-web to create a clone for web
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating your application with React Native, you can use a library called
    `react-native-web` to run your React Native app on the web.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start, you have to understand what `react-native-web` does. Basically,
    it maps all React Native components to HTML components. For example, a `<View/>`
    component will get `<div/>`. It also maps the native API calls of React Native
    to use the browser APIs wherever available. This means you’ll get a plain React
    application for the web.
  prefs: []
  type: TYPE_NORMAL
- en: While `react-native-web` is a great library, it is not that easy to get started
    with it because you have to set up a separate build process to use it. This build
    process will create a standalone React web application. Like every React web application,
    it needs a bundler to create optimized browser-readable JavaScript code. A very
    popular solution is Webpack, which we will use for our web app as well. Also,
    every web application needs an entry point. In most cases, this is an `index.html`
    file, which then loads the JavaScript bundle that contains the React application.
    So, we’ll have to add this to our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole process of setting up web support is described in a very detailed
    manner in the `react-native-web` documentation (which you can see here: https://bit.ly/prn-rn-web),
    but at the time of writing, this documentation is missing TypeScript support.'
  prefs: []
  type: TYPE_NORMAL
- en: So, I’ll describe the most important thing while we set up basic web support
    for our example application. You can find the complete working setup in the GitHub
    repository when choosing the `chapter-10-web` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Installing react-native-web
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll start with adding `react-native-web` and `react-dom` to our project.
    Please use the correct version of `react-dom`. Since we are using React 17 in
    our React Native app, we’ll have to use `react-dom@17`. These libraries are necessary
    to create the React app. The installation can be done via `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, it can be done via `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have installed `react-native-web`, we’ll need to handle the build
    process and the development environment for the web.
  prefs: []
  type: TYPE_NORMAL
- en: Installing webpack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To do so, we’ll add Webpack, the corresponding CLI, and a Webpack extension
    called `webpack-dev-server`. This extension provides a built-in development server
    that supports live reloading while you develop your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The installation of these `npm` libraries can be done with the following `npm`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, you can use a `yarn` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to this basic Webpack setup, we’ll also install two loaders. Loaders
    are a core concept of Webpack. They enable you to preprocess files and decide
    how they should be used in your bundle. We’ll make use of the following loaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ts-loader`: This is a loader that preprocesses our TypeScript files and converts
    them to browser-readable JavaScript'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file-loader`: This loader copies our asset binaries such as images in our
    final bundle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last thing we need for our web build process to work is `html-webpack-plugin`.
    This plugin creates our entry point. It writes an `index.html` by loading an HTML
    template and adding the created JavaScript bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'These additions can be installed with the following `npm` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, install with the following `yarn` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have installed all tools, we have to configure our project.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the React Native project to work for web
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, let’s create a JavaScript entry point for our application. To do so,
    we’ll create `index.web.js` in the root folder of the application. This contains
    the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We use React Native `AppRegistry` to load our `<App />` component via the `registerComponent`
    function and then run our application with `runApplication`.
  prefs: []
  type: TYPE_NORMAL
- en: '`runApplication` needs an HTML node as `rootTag` for the web. This HTML node
    will be replaced with the React application during `runApplication`. In our case,
    we’ll get the element with the `movie-root` ID from the HTML document.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll create a `web/` folder in the `root` folder of our project. In
    this folder, we’ll put an `index.html` template with the following content (please
    refer to the GitHub repository for the complete file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the head of the document, we define a title and some styles. The styles are
    important for the `react-native-web` application to show. The body only contains
    an empty `<div />` with the `#movie-root` ID. This is the container we use in
    our JavaScript entry point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll have to configure our Webpack builder. To do so, please create
    `webpack.config.js` in the `web/` folder. The following code snippet shows the
    most important configurations. For the complete file, please look at the GitHub
    repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let’s work through this configuration from top to bottom. First, we defined
    our JavaScript entry point. Here, we put the `index.web.js` file we just created.
    Then, we defined our output. In this case, it’s the `dist/` directory and a JS
    bundle with a hash value in the name to ensure that we have new filenames with
    every new build to prevent browser caching issues.
  prefs: []
  type: TYPE_NORMAL
- en: In the `module` section, we can define rules for which loaders should be used
    to preprocess which files. We use a Regex to test the filenames against and define
    loaders for all matching files. In this example, we use `ts-loader` for all files
    that include `.tsx`, `.ts`, `.jsx`, or `.js`, except everything in the `node_modules`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section of the file, we defined which plugins we’ll use. In our
    case, it’s only `HTMLWebpackPlugin` to create our entry point `index.html` from
    our template HTML file. The last part of the `config` file is the `resolve` section.
    Here is where the magic of the transformation of a React Native to a plain React
    web application is happening.
  prefs: []
  type: TYPE_NORMAL
- en: By creating the `react-native-web` alias for `react-native`, we replace all
    occurrences of `react-native` with `react-native-web`. This means all imports
    that were fetched from `react-native` are now fetched from `react-native-web`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our build process for the web application works, we’ll have to make
    some small adaptations in our TypeScript setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We added `dom` to the `lib` section, changed the `jsx` mode to `react`, and
    switched `noEmit` from `true` to `false`. This is necessary to create the files
    in a way that Webpack can handle. With this step, the setup is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Running the React Native code as a React app in the browser
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we can start our React Native app as a React web application in `dev`
    mode from the command line. You can do so with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows our example movie app running in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Our example movie app running in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16694_10_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – Our example movie app running in the browser
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.3* shows the UI of the example movie app running in the browser.
    It works perfectly fine, running on the same code base as the native app. When
    you inspect the HTML with the browser’s inspection tools, you’ll see that all
    React Native components were transformed into HTML components.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final step of this section and to make development and creating production
    builds easier, we add two commands to the `scripts` section of `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first line is the command we just used to start our application in `dev`
    mode. The second line is to build the application in production mode for deployment.
    This writes the complete bundle to the `dist` folder, as we defined in `webpack.config.js`.
  prefs: []
  type: TYPE_NORMAL
- en: In this subsection, you learned how to create a clone of your React Native app
    for the web. While this may work in some cases, most of the time, this isn’t enough.
    User expectations between web and mobile are different in most areas and you also
    may want to use different libraries for web and mobile that don’t support the
    other platform. A very easy solution for differentiating between different platforms
    is to make use of file endings.
  prefs: []
  type: TYPE_NORMAL
- en: Working with .native and .web file endings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As described in the previous subsection, we have two completely different build
    processes for web and native apps. While we configured our Webpack bundler to
    support `.web.ts` or `.web.tsx` files, the native Metro bundler supports `.native.ts`
    or `.native.tsx` files out of the box. This means that we can write platform-specific
    code by simply creating two versions of a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`App.tsx` and `App.native.tsx` would result in our web application using `App.tsx`
    and our native application using `App.native.tsx`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`App.tsx` and `App.web.tsx` would result in our web application using `App.web.tsx`
    and our native application using `App.tsx`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This approach can be used to share most of the code but make platform-specific
    versions of components. It can also be used to define different navigation stacks
    for the different platforms or use different navigation libraries by creating
    platform-specific `App.tsx` files.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, this approach is quite powerful but has some limits. For example,
    you’ll have to use the same versions of libraries you share between the platforms
    because both platforms share one `package.json` file. If you want to go one step
    further, you could either work with multiple packages in a `monorepo` or create
    your own libraries from the code you want to share, which you then import into
    different platform-specific projects.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at the `monorepo` approach first.
  prefs: []
  type: TYPE_NORMAL
- en: Working with multiple packages in a monorepo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For structuring your multi-platform React Native app as a `monorepo`, I recommend
    using `yarn` workspaces. This is a way to set up multiple JavaScript packages
    in a single repository. `yarn` optimizes the libraries in terms of versions and
    storage. It also allows the packages to be linked together, which is the main
    reason why we are using it here.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on `yarn` workspaces, you can have a look at the official
    documentation ([https://bit.ly/prn-yarn-workspaces](https://bit.ly/prn-yarn-workspaces)).
    The following figure shows the structure of a multi-platform `monorepo` with `yarn`
    workspaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – A multi-platform React Native monorepo based on workspaces'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16694_10_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – A multi-platform React Native monorepo based on workspaces
  prefs: []
  type: TYPE_NORMAL
- en: You have the **Shared Code** package (often also called **App**), which can
    contain most parts of your application such as views, store, services, and components.
    This package isn’t started directly and has no native or web entry point. Then,
    you have one package for every platform.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these packages has its own `package.json` file and can define its own
    libraries and versions. This setup even allows you to use different versions of
    the same library on different platforms, as long as your shared code supports
    all of them.
  prefs: []
  type: TYPE_NORMAL
- en: The platform-specific packages contain the entry points, and I would also recommend
    putting platform-specific things such as navigation and the general application
    structure (layer stack or navigation tree) here. This makes it possible to not
    only create a clone of the same application for every platform but also to use
    very different approaches.
  prefs: []
  type: TYPE_NORMAL
- en: You could, for example, have a completely different layer stack on the web and
    mobile. This makes total sense because most of the time there are completely different
    needs for the different platforms. Some things you need on the web you don’t even
    want to have on your mobile app and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: And there is another advantage of this package approach. There are a lot of
    frameworks based on React that perform a lot of web-specific optimizations such
    as supporting server-side rendering, adding browser history support to routing,
    or extensive web bundle optimizations. The most popular frameworks of this kind
    are **Next.js** and **Gatsby**. With this setup, you can use them for the web.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to start with this `monorepo` setup, I can recommend an excellent
    template that you can find here: [https://bit.ly/prn-rn-universal-monorepo](https://bit.ly/prn-rn-universal-monorepo).
    This template not only supports mobile and the web but also a couple of other
    frameworks and platforms such as Next.js, Electron, desktop, and even browser
    extensions. There is also a good description that guides you through the setup
    process, which you can find here: [https://bit.ly/prn-rn-anywhere](https://bit.ly/prn-rn-anywhere).'
  prefs: []
  type: TYPE_NORMAL
- en: With this approach, we created different packages for different platforms for
    the first time. In this scenario, we only used a single repository, because that
    makes development quite easy. We just have to clone the repository, install the
    dependencies, and we are ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: I really like this approach, but when the code base and the team grow a lot,
    it definitely makes sense to go one step further. To create a clearer separation
    of the different parts of the application with clear responsibilities, you can
    split the application into different projects. This means you will create your
    own libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing code with your own libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many good reasons to create your own library. Sharing code between
    different projects for different platforms is definitely one of them. But with
    your own library, you can also achieve the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ensure consistent design in all your applications**: When you are working
    in a company that provides multiple applications, it’s a good idea to create a
    UI library that provides UI components for all these applications. This ensures
    a consistent design system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplify backend connection**: You can extract your services to a library,
    which can then be used in all your projects. This ensures a unified backend connection
    layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Define responsibilities**: Every library can be maintained by its own maintainer
    or team. With this library approach, you can define clear responsibilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Provide additional functionality**: You can also write your own library to
    provide native functionality that isn’t available in the way you need it from
    any community module. In this case, I would always recommend providing this functionality
    in the form of its own library (and making it available to the community if possible).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice
  prefs: []
  type: TYPE_NORMAL
- en: Most of the community modules out there started because someone had a problem
    that hadn’t been solved. If you are in a position to be able to solve a problem
    with a new library or module, I would highly recommend sharing it with the community.
    Even if you don’t want to do it for altruistic reasons, it can be a very good
    thing. Often, you can find others that share the same challenges and you can create
    a better solution together.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our own library can be quite challenging. You can find a lot of tutorials
    and blog posts online on how to create the perfect setup for your own library.
    Some of them are good – some of them are bad. But instead of using one of them,
    I recommend a wrapper of tools called `react-native-builder-bob`.
  prefs: []
  type: TYPE_NORMAL
- en: Using react-native-builder-bob to write, maintain, and publish our own libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This tool makes the process of writing, maintaining, and publishing your own
    library very easy. It is created and maintained by a company called **Callstack**,
    which is very active in the React Native community and even contributes to the
    core of React Native.
  prefs: []
  type: TYPE_NORMAL
- en: They use `react-native-builder-bob` for their own libraries and a lot of the
    most popular libraries also do.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start creating your own library with `react-native-builder-bob` preconfigured
    using this simple command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will start the setup process and guide you through it with a couple
    of questions. The following screenshot shows this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Creating your own library with create-react-native-library'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16694_10_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.5 – Creating your own library with create-react-native-library
  prefs: []
  type: TYPE_NORMAL
- en: After answering questions about the author and the package, which are needed
    to create the `package.json`, `create-react-native-library` will ask you what
    type of library you want to develop.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can choose between the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Native module/Native view**: You should choose this if your module contains
    native code. These options use the current bridge architecture to communicate
    between JavaScript and native.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JavaScript library**: You should choose this if your module does not contain
    any native code. Most use cases such as simple UI libraries, service SDKs, and
    state providers fall in this category. Also, this is the correct type when you
    use other libraries that contain native code but your own library is a JavaScript-only
    library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Turbo module**: At the time of writing, this type is in the experimental
    phase. This creates a native module based on the new React Native architecture
    (see the *Introducing the new React Native architecture* section from [*Chapter
    3*](B16694_03.xhtml#_idTextAnchor061), *Hello React Native*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll start by creating a JavaScript-only library. Imagine that we created our
    example application as one of many applications for a huge corporation. Because
    the management likes the design, they want all future applications to be able
    to stick to our design system. Therefore, we want to provide our `StyleConstants`
    file in our own library as the first step in setting up our corporate design system.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a JavaScript-only library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To start our own JavaScript-only library, we’ll choose `create-react-native-library`
    dropdown. `create-react-native-library` creates our library with a set of preconfigured
    tools, predefined scripts, a simple multiply function as the source, and even
    an example application to showcase the library. If you want to see a working example,
    you can have a look at the GitHub repository here: [https://bit.ly/prn-repo-styles-library](https://bit.ly/prn-repo-styles-library).'
  prefs: []
  type: TYPE_NORMAL
- en: When we check the `root` folder of our newly created library, we’ll find a lot
    of files we already know from our application. There is a `babel.config.js` file
    to define how Babel should transform our code, a `package.json` file, which contains
    information about the package, as well as all dependencies and scripts, and there
    is a `tsconfig.json` file, which contains all the information for the TypeScript
    compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll have a deeper look at `package.json`. Besides all the predefined
    information and configuration, I want to point out two important things. The first
    one is the information about where to find which parts of our library. This is
    what you see in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'While we are creating our library in TypeScript, it will be compiled to pre-ES6
    JavaScript by `react-native-builder-bob`, so that it will work in every React
    Native project, no matter what stack it is using (TypeScript, Flow, Plain JS,
    or Expo). This means the code of our library ships in different ways. That’s what’s
    defined in the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`main`: This is the main entry point of your library. When you import anything
    from your library, this is the path where your project will look for exports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`types`: Since we are using TypeScript `react-native-builder-bob` creates types
    for our code so that everyone who uses typed JavaScript can work with the types
    we created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`source`: This is where the uncompiled source code can be found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While we are only working in the `source` directory, the projects that use our
    library will only work with `main` and `types`.
  prefs: []
  type: TYPE_NORMAL
- en: The second thing I want you to have a look at is the `scripts` section, above
    all the following scripts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: These scripts are the most essential part of this library setup. With the `prepare`
    script, you can run the `build` command of `react-native-builder-bob`. It will
    compile your library and provide the entry points you have just learned about.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `release` script will use the `release-it` library to create a new release
    of your library. This initiates a guided process that will do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the library version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a changelog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publish your library to `npm`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commit the library version update to `git`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a `git` tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Push the changes to the remote repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a release on GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This script is very useful because it forces you to stick to best practices
    in terms of releasing and tagging your library.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how the library project is structured, let’s use this library
    to publish our styles. Since we already collected all our style information in
    our `StyleConstants` file, this is simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `src/index.tsx` file of the library project and paste the contents
    of the `StyleConstants.ts` file. Next, commit the changes and build and publish
    the library with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice
  prefs: []
  type: TYPE_NORMAL
- en: You need to create a free account at [https://www.npmjs.com/](https://www.npmjs.com/)
    and log in from the command line with `npm login` to be able to publish your library.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you publish your library package, you can install it in your project.
    You can use the regular `npm` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the `yarn` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you are able to access your styles via your library, you can delete
    your `StyleConstants.ts` file and replace all imports with your library. The following
    figure shows the change for `Home.styles.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Importing a change from a local file to a library'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16694_10_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.6 – Importing a change from a local file to a library
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the imports stay the same, only the `from` path changes to the
    library. You have to do this in all files where you used `StyleConstants`.
  prefs: []
  type: TYPE_NORMAL
- en: As you learned in this subsection, the process of creating your own library
    is quite complex, but it gets a lot easier when you work with the right tools.
    But since our example was a JavaScript-only library, it was the easiest type of
    React Native library. It gets more complex when adding native code to your library.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the difference between native libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you already know, React Native has a JavaScript part and a native part. This
    means we can make use of native platform-specific code when we want to. This not
    only works with app projects but also with libraries. Native code is written in
    platform-specific languages such as Kotlin or Java for Android or Swift or Objective-C
    for iOS.
  prefs: []
  type: TYPE_NORMAL
- en: But it isn’t only the language that differs from platform to platform. The process
    of how the application manages its third-party packages and how to build and deploy
    is completely different.
  prefs: []
  type: TYPE_NORMAL
- en: Android uses Gradle to fetch packages and build your app. For iOS, there are
    multiple package managers but React Native relies heavily on CocoaPods. The build
    is done via Xcode.
  prefs: []
  type: TYPE_NORMAL
- en: This means when you are adding native code to your library, you not only have
    to deliver and import your JavaScript code but you also have to provide the native
    code and add it to the native build process that gets included in the native bundle.
  prefs: []
  type: TYPE_NORMAL
- en: With this setup, your native code also gets included in your library bundle.
    To be able to write native code, you have to choose `Native Module` when creating
    your library with `create-react-native-library`. This will create two additional
    folders (`android` and `ios`) that contain the native code, as well as the configuration
    files for the native build process.
  prefs: []
  type: TYPE_NORMAL
- en: For Android, this is a `build.gradle` file, which can be found in the `android`
    folder. For iOS, this is a `.podspec` file, which can be found in the `root` folder
    of the library.
  prefs: []
  type: TYPE_NORMAL
- en: All these files are created for you, so you shouldn’t need to change them. When
    installing your library with native code, React Native autolinking will take care
    of everything for you on Android. On iOS, you’ll have to run `npx pod-install`
    to include the native part of your library in the native project.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are able to create pure JavaScript libraries and libraries with
    native code, we’ll take another look at how to provide them. We used the public
    `npm` registry to host our library as a public package.
  prefs: []
  type: TYPE_NORMAL
- en: While I really like the approach of sharing everything with the community, you
    may have the requirement to keep your libraries private, especially when they
    are important parts of corporate applications. The next subsection will show you
    how to only provide access to your libraries to selected people.
  prefs: []
  type: TYPE_NORMAL
- en: Setting access restrictions on libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some ways to share your library only with selected people. These
    two are the most common ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use a paid npmjs.com plan**: You can define permissions on your packages
    when using a paid [npmjs.com](https://npmjs.com) plan. This means that only people
    you explicitly allow will have access to your package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package.json`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You could even specify tags, branches, or commits your package should be fetched
    from by adding a `#` symbol followed by the tag name, branch name, or commit hash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, I would highly recommend publishing your modules and not keeping them
    private wherever possible. This community with thousands of well-maintained public
    packages is one of the main reasons why React Native is so successful. So, giving
    something back to the community is always a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to structure large-scale or multi-platform
    products. You are now able to create a project structure that works for large-scale
    and long-running projects.
  prefs: []
  type: TYPE_NORMAL
- en: You also created a clone of your example React Native mobile app on the web
    and understood why this isn’t always the best idea. You then learned how to create
    multi-platform applications that meet user expectations while keeping a high percentage
    of shared code.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section of this chapter, you learned how to create, release, and
    maintain your own libraries, what the difference between JavaScript-only libraries
    and libraries with native code is, and how to only publish these libraries to
    selected people.
  prefs: []
  type: TYPE_NORMAL
- en: After focusing on creating a good structure for the code base itself, in the
    next chapter, we’ll focus on how to implement well-working processes and how to
    support these processes with **Continuous Integration** (**CI**) tools.
  prefs: []
  type: TYPE_NORMAL
