- en: Design Patterns in Angular
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular中的设计模式
- en: TypeScript is an object-oriented programming language and, as such, we can leverage
    decades of knowledge on object-oriented architecture. In this chapter, we explore
    some of the most useful object-oriented design patterns and learn how to apply
    them in an Angular way.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript是一种面向对象的编程语言，因此我们可以利用几十年的面向对象架构知识。在这一章中，我们将探讨一些最有用的面向对象设计模式，并学习如何在Angular中应用它们。
- en: Angular is, by itself, an object-oriented framework and it forces you to do
    most of your development in certain ways. For example, you are required to have
    components, services, pipes, and so on. Forcing upon you these building blocks
    contributes to building good architecture. Very much like what the Zend framework
    does for PHP or Ruby on Rails for Ruby. Frameworks are here to make your life
    easier and speed up the development time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Angular本身是一个面向对象的框架，它强制你以某种方式进行大部分开发。例如，你需要有组件、服务、管道等。强制你使用这些构建块有助于构建良好的架构。这很像Zend框架为PHP或Ruby
    on Rails为Ruby所做的事情。框架的存在是为了让你的生活更轻松，加快开发时间。
- en: While the Angular way of designing things is way above average, we can always
    do better. I do not claim that what I present in this chapter is the ultimate
    design, and you will be able to use it to resolve anything from a one pager for
    a bakery to pagers to dashboards for the Mars One mission--such a design does
    not exist--but, it definitely improves your tool belt.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Angular的设计方式远远超出平均水平，但我们总是可以做得更好。我并不是说我在这一章中提出的设计是最终的，你可以用它来解决从面包店的一页纸到火星一号任务的仪表板的任何问题--这样的设计并不存在--但它确实会提高你的工具箱。
- en: 'In this chapter, we will learn to use the following patterns:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将学习使用以下模式：
- en: Model-View-Controller(MVC)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型-视图-控制器（MVC）
- en: Singleton
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例
- en: Dependency Injection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Prototype
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型
- en: Reusable pool
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重用池
- en: Factory
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂
- en: Memento
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备忘录
- en: Model-View-Controller (MVC)
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型-视图-控制器（MVC）
- en: Oh MVC, good old MVC. You served us well for many years. Now, people want you
    to retire, without fuss if possible. Moreover, even I can see how younger unidirectional
    user interface architectures can outsmart you and make you look like a relic from
    the past.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，MVC，好老的MVC。多年来你为我们服务得很好。现在，人们希望你退休，最好不要有麻烦。此外，即使我也能看到，更年轻的单向用户界面架构可以比你更聪明，让你看起来像是过去的遗物。
- en: In this section, we will first describe what the MVC is, regardless of the programming
    language used to implement it, and then we will see the shortcomings of applying
    MVC for frontend programming. Finally, I will present a way to implement an MVC
    that makes sense with Angular regarding ease of implementation, maintenance, and
    performance.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先描述MVC是什么，不管用什么编程语言来实现它，然后我们将看到将MVC应用于前端编程的缺点。最后，我将介绍一种在Angular中实现有意义的MVC的方法，这种方法考虑了实现的便利性、维护性和性能。
- en: MVC at large
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC的大局
- en: 'The whole principle behind the MVC design pattern is fairly straightforward.
    Indeed, as shown in the following figure, it is composed of three blocks: Model,
    View, and Controller. More specifically, the intent of the MVC is to define a
    one-to-many dependency between objects so that when one object changes state,
    all its dependents are notified and updated automatically:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: MVC设计模式的整体原则非常简单。事实上，如下图所示，它由三个部分组成：模型、视图和控制器。更具体地说，MVC的意图是定义对象之间的一对多依赖关系，以便当一个对象改变状态时，所有依赖它的对象都会被通知并自动更新：
- en: '![](assets/bbc1e9fd-1446-480e-aad3-bb764a93e5d1.png)MVC overview'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/bbc1e9fd-1446-480e-aad3-bb764a93e5d1.png)MVC概述'
- en: 'Let us analyze the preceding image block by block:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐块分析前面的图像：
- en: The **Model** stores the data required by the application according to commands
    sent by the **Controller**.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**根据**控制器**发送的命令存储应用程序所需的数据。'
- en: The **Controller** receives actions from the **User** (that is, a click on a
    button) and directs **Model** updates accordingly. It can also set which **View**
    is used at any given moment.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**接收**用户**的操作（即点击按钮）并相应地指导**模型**更新。它还可以设置在任何给定时刻使用哪个**视图**。'
- en: The **View** is generated and updated every time the **Model** changes.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**在**模型**更改时生成和更新。'
- en: And that is it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。
- en: Let's see what a simple MVC implementation would look like in pure TypeScript.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看纯TypeScript中一个简单的MVC实现会是什么样子。
- en: 'First, let''s define a `Movie` class like we did back in [Chapter 10](847dfea0-b857-4423-84fc-e6f719237f1d.xhtml),
    *Material Design in Angular*. In this version of the `Movie` class, we have only
    two attributes, `title` and `release_year` , which are defined using a TypeScript
    constructor:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们像我们在[第10章](847dfea0-b857-4423-84fc-e6f719237f1d.xhtml)中所做的那样定义一个`Movie`类，*在Angular中的Material
    Design*。在这个版本的`Movie`类中，我们只有两个属性，`title`和`release_year`，它们是使用TypeScript构造函数定义的：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we define a `Model` class that imports the `movie.ts` file, containing
    the `Movie` class, using the reference keyword. This `Model` class, which will
    be responsible for updating the view, has a movie array and two methods. The first
    method, `addMovie(title:string, year:number)` is public and appends a new movie
    at the end of the movies attribute. It also calls the second method of the class:
    `appendView(movie:Movie)` which is private. This second method manipulates the
    view as per the MVC definition. The view manipulation is rather simple; we append
    a new `li` tag to the `movie` element of the view. The content of the newly created
    `li` tag is a concatenation of the movie title and release year:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个`Model`类，导入包含`Movie`类的`movie.ts`文件，使用引用关键字。这个`Model`类将负责更新视图，它有一个电影数组和两个方法。第一个方法`addMovie(title:string,
    year:number)`是公共的，它在movies属性的末尾添加一个新的电影。它还调用类的第二个方法：`appendView(movie:Movie)`，这个方法是私有的。这个第二个方法根据MVC定义操纵视图。视图操纵相当简单；我们在视图的`movie`元素中添加一个新的`li`标签。新创建的`li`标签的内容是电影标题和发行年份的连接：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can now define a controller for our pure TypeScript MVC. The Controller
    has a private `model:Model` attribute that is initiated in the constructor. Also,
    a `click` method is defined. This method takes a string and a number in parameters
    for the title and the release year, respectively. As you can see, the `click`
    method forwards the title and the release year to the `addMovie` method of the
    model. Then, the controller''s job is done. It does not manipulate the view. You
    will also notice the last line of the `controller.ts` file: let `controller =
    new Controller()`;. This line allows us to create an instance of the `Controller`
    class that View can bind to:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以为我们的纯TypeScript MVC定义一个控制器。控制器有一个私有的`model:Model`属性，在构造函数中初始化。此外，定义了一个`click`方法。这个方法接受一个字符串和一个数字作为参数，分别用于标题和发行年份。正如你所看到的，`click`方法将标题和发行年份转发给模型的`addMovie`方法。然后，控制器的工作就完成了。它不会操纵视图。你还会注意到`controller.ts`文件的最后一行：`let
    controller = new Controller()`;。这行允许我们创建一个`Controller`类的实例，视图可以绑定到它：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The last piece of our MVC implementation is the view. We have a bare-bones
    HTML form which, on submit, invokes the following: `controller.click(this.title.value,
    this.year.value); return false;.` The controller has been defined in the `controller.ts`
    file with `let controller = new Controller()`*;*. Then, for the parameters, we
    send `this.title.value` and `this.year.value` where this refers to the `<form>`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们MVC实现的最后一部分是视图。我们有一个简单的HTML表单，提交时会调用以下内容：`controller.click(this.title.value,
    this.year.value); return false;.` 控制器在`controller.ts`文件中已经定义为`let controller =
    new Controller()`*;*。然后，对于参数，我们发送`this.title.value`和`this.year.value`，其中this指的是`<form>`。
- en: 'The title and year refer to the field for the title and the release year of
    the movie, respectively. We also have to add return false to prevent the page
    from reloading. Indeed, the default behavior of an HTML form, on submit, is to
    navigate to the action URL:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 标题和年份分别指的是电影的标题和发行年份字段。我们还必须添加`return false`以防止页面重新加载。实际上，HTML表单的默认行为是在提交时导航到操作URL：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the header, we add the `mvc.js` script generated by the following command:
    `tsc--out mvc.jscontroller.ts model.ts movie.ts`. The generated JavaScript looks
    like the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在页眉中，我们添加了通过以下命令生成的`mvc.js`脚本：`tsc--out mvc.jscontroller.ts model.ts movie.ts`。生成的JavaScript如下所示：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'On the execution side, at loading time, the HTML page would look like the following
    screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行方面，在加载时，HTML页面将如下截图所示：
- en: '![](assets/94456d7f-cf35-4038-b636-0d9d10e7873c.png)MVC at loading time.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/94456d7f-cf35-4038-b636-0d9d10e7873c.png)加载时的MVC。'
- en: 'Then, if you use the form and add a movie, it will automatically impact the
    view and display the new movie as shown in the following image:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果您使用表单并添加电影，它将自动影响视图，并显示新的电影，如下图所示：
- en: '![](assets/0b4638a6-1dd7-4c1e-9442-76905de0f3d7.png)MVC after using the form.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/0b4638a6-1dd7-4c1e-9442-76905de0f3d7.png)在使用表单后的MVC。'
- en: MVC limitations for the frontend
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端的MVC限制
- en: 'So, why is the MVC pattern not used that often when it comes to Frontend programming
    supported by a framework such as Angular? First, if you are using Angular for
    an app that provides a service, you are likely to have a Backend with which you
    exchange some information. Then, if your Backend also uses the MVC design pattern,
    you will end up with the following hierarchy:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么在前端编程中使用MVC模式不那么常见，尤其是在像Angular这样的框架支持下？首先，如果您正在为提供服务的应用程序使用Angular，您很可能会有一个与之交换一些信息的后端。然后，如果您的后端也使用MVC设计模式，您将得到以下层次结构：
- en: '![](assets/e0d23afd-59e0-4cf6-9c19-6145cc717c47.png)MVC Frontend and Backend.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/e0d23afd-59e0-4cf6-9c19-6145cc717c47.png)前端和后端的MVC。'
- en: In this hierarchy, we have an MVC implementation on top of another MVC implementation.
    Both implementations communicate with each other via an API service that sends
    requests to the Backend Controller and parses the resulting view. As a concrete
    example, if your user has to sign in to your app, they will see the sign in View
    on the Frontend that is powered by a User Model and a sign Controller. Once all
    the information (email, password) has been entered, the User clicks on the Sign-in
    button.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个层次结构中，我们在另一个MVC实现的顶部有一个MVC实现。这两种实现通过一个API服务进行通信，该服务向后端控制器发送请求并解析生成的视图。具体示例是，如果用户必须登录您的应用程序，他们将在由用户模型和登录控制器提供支持的前端上看到登录视图。一旦输入了所有信息（电子邮件、密码），用户就会点击登录按钮。
- en: This click triggers a Model update and the Model then triggers an API call using
    the API service. The API service makes a request to the `user/signin` endpoint
    of your API. On the Backend side, the request is received by the User Controller
    and forwarded to the User Model. The Backend User Model will query your database
    to see if there is a matching User with the provided user and password. Finally,
    a View will be output, containing the user information if the login was successful.
    Going back on the Frontend, the API service will parse the produced view and return
    the relevant information to the Frontend User Model. In turns, the Frontend User
    Model will update the Frontend View.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个点击触发了模型更新，然后模型使用API服务触发API调用。API服务向您的API的`user/signin`端点发出请求。在后端，请求被用户控制器接收并转发到用户模型。后端用户模型将查询您的数据库，以查看是否有提供的用户和密码匹配的用户。最后，如果登录成功，将输出一个包含用户信息的视图。回到前端，API服务将解析生成的视图并将相关信息返回给前端用户模型。依次，前端用户模型将更新前端视图。
- en: For some developers, that many layers and the fact that the architecture is
    duplicated on the Frontend and the Backend just feels wrong even though it brings
    maintainability through a well-defined separation of concerns.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些开发人员来说，这么多层以及架构在前端和后端上的重复似乎不太对，尽管它通过明确定义的关注点分离带来了可维护性。
- en: The dual MVC is not the only concern. Another problem is that the frontend models
    will not be pure models as they have to account for variables regarding the UI
    itself such as visible tabs, form validity, and so on. Hence, your Frontend Models
    tend to become a hideous blob of code where UI variables rub shoulders with the
    actual representation of your user, for example.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 双重MVC并不是唯一的问题。另一个问题是，前端模型不会是纯模型，因为它们必须考虑UI本身的变量，比如可见标签、表单有效性等等。因此，你的前端模型往往会变成一团丑陋的代码，其中UI变量与用户的实际表示相互交织。
- en: Now, as always, you can avoid these traps and harness the advantages of the
    MVC pattern. Let's see how in the next section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，像往常一样，你可以避免这些陷阱，利用MVC模式的优势。让我们在下一节中看看如何做到这一点。
- en: Angular is MVC
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular是MVC
- en: In this section, I present an architecture for the MVC in Angular that has proved
    itself. I have used this architecture for the past eight months at `toolwatch.io`
    (web, Android, and iOS). Obviously, the features we propose on the web version
    or the mobile apps are the same and work the same way; what changes are the views
    and the navigation scheme.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我提出了一个在Angular中证明有效的MVC架构。我在`toolwatch.io`（Web、Android和iOS）过去的八个月中使用了这个架构。显然，我们在Web版本或移动应用上提出的功能是相同的，工作方式也相同；不同的是视图和导航方案。
- en: 'The following figure presents the overall architecture:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了整体架构：
- en: '![](assets/65d357c3-82da-4505-a136-94c7a3791815.png)MVC for Angular.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/65d357c3-82da-4505-a136-94c7a3791815.png)Angular的MVC。'
- en: From top to bottom, we have the Backend, the reusable pieces of the Frontend,
    and the specialized Frontend (that is, mobile or the web). As you can see, on
    the Backend, nothing changes. We have kept our traditional MVC. Note that the
    Frontend parts would also work with the non-MVC Backend.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从上到下，我们有后端、可重用的前端部分和专门的前端（即移动端或Web端）。正如你所看到的，在后端，没有任何变化。我们保留了传统的MVC。请注意，前端部分也可以与非MVC后端一起工作。
- en: Our Model will use that service to get, put, and delete a plain TypeScript object
    from the remote database through a hypothetic JSON API.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模型将使用该服务通过假想的JSON API从远程数据库获取、放置和删除一个简单的TypeScript对象。
- en: 'Here''s what our user TypeScript object looks like:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户TypeScript对象如下所示：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Nothing too fancy here. Only a plain TypeScript object that contains two attributes:
    `email:_string` and `password:_string`. These two attributes are initialized in
    the Constructor using the TypeScript inline declaration style. We also leverage
    the getter/setter of TypeScript to access the `password:string` and `_email:string`
    attributes. You might have noticed that the TypeScript getter/setter look like
    C# properties. Well, Microsoft is one of the principal industrial investigators
    for TypeScript, so it makes sense.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多花哨的东西。只是一个简单的TypeScript对象，包含两个属性：`email:_string`和`password:_string`。这两个属性在构造函数中使用TypeScript内联声明样式进行初始化。我们还利用了TypeScript的getter/setter来访问`password:string`和`_email:string`属性。你可能已经注意到，TypeScript的getter/setter看起来像C#属性。嗯，微软是TypeScript的主要工业调查者之一，所以这是有道理的。
- en: I do like the conciseness of the writing, especially when combined with inline
    attribute declarations in the constructor. What I do not like, however, is the
    necessity to have underscored variables names. The problem is that, once again,
    this TypeScript will be transpiled to JavaScript, and in JavaScript, variables
    and function are a bit more abstract than, let's say, Java or C#.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我确实喜欢写作的简洁性，特别是在构造函数中与内联属性声明结合在一起时。然而，我不喜欢的是必须使用下划线变量名。问题在于，再次，这个TypeScript将被转译成JavaScript，在JavaScript中，变量和函数比如说Java或C#更加抽象。
- en: 'Indeed, in our current example we could invoke the getter of the `user` class
    as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在我们当前的示例中，我们可以调用`user`类的getter如下：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, TypeScript does not care about the type of the target it is
    calling. It can be a variable named email or a function named `email()`. Either
    way, it works, with different results, but it works. The underlying rationale
    behind this odd behavior, for an object-oriented program, is that, in JavaScript,
    it is acceptable to do:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，TypeScript并不关心它调用的目标的类型。它可以是一个名为email的变量，也可以是一个名为`email()`的函数。无论哪种方式，它都可以工作，产生不同的结果，但它可以工作。这种奇怪行为背后的基本原理是，在面向对象的程序中，在JavaScript中，这是可以接受的：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Consequently, we need to differentiate the actual variables of the function
    with different names. Hence the _.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要用不同的名称区分函数的实际变量。因此有了下划线。
- en: 'Let''s go back to our MVC implementation now that we have a full-proof user
    object to manipulate. Now we can have a `UserModel` that manipulates the user
    **Plain Old TypeScript Object** (**POTO**) and the needed variable for the graphical
    interface:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个完全可靠的用户对象来操作，让我们回到我们的MVC实现。现在我们可以有一个`UserModel`来操作用户**普通旧TypeScript对象**（**POTO**）和图形界面所需的变量：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our model, named `UserModel`, receives an injection of an `APIService`. The
    implementation of the `APIService` is left to the reader as an exercise. However,
    it will be very similar to what we have seen in [Chapter 9](64f5991e-76eb-41dd-818c-0e46c41c168b.xhtml),
    *Advanced Forms in Angular 2*. In addition to the `APIService`, `UserModel` owns
    the `user:User` and `loading:bool` attributes. The `user:User` represents the
    actual user with its password and email. The `loading:bool`, however, will be
    used to determine whether or not a loading spinner should be visible in the view.
    As you can see, `UserModel` defines the `signin` and `signup` methods. In these
    methods, we call the `getUser` and `postUser` methods of the hypothetical `APIService`
    that both take a User in argument and return a Promise containing the said user
    synchronized via the JSON API. On receipt of the promises, we turn off the `loading:bool`
    spinner.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模型，名为`UserModel`，接收了一个`APIService`的注入。`APIService`的实现留给读者作为练习。然而，它将非常类似于我们在[第9章](64f5991e-76eb-41dd-818c-0e46c41c168b.xhtml)中看到的*Angular
    2中的高级表单*。除了`APIService`，`UserModel`拥有`user:User`和`loading:bool`属性。`user:User`代表了实际的用户及其密码和电子邮件。然而，`loading:bool`将用于确定视图中是否应该显示加载旋转器。正如你所看到的，`UserModel`定义了`signin`和`signup`方法。在这些方法中，我们调用了假设的`APIService`的`getUser`和`postUser`方法，它们都接受一个User作为参数，并返回一个包含所述用户通过JSON
    API同步的Promise。收到Promise后，我们关闭`loading:bool`旋转器。
- en: 'Then, let''s have a look at the controller, which will also be a component
    in an Angular environment as Angular components control the view which is displayed,
    and so on:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们来看看控制器，它也将是Angular环境中的一个组件，因为Angular组件控制显示的视图等等。
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, the controller (component) is simple. We only have a reference
    to the model, and we receive an injected `APIService` to be transferred to the
    model. Then, we have the `signinClick` and `signupClick` methods that receive
    user input from the view and transfer them to `model`. The last piece, the view,
    looks like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，控制器（组件）很简单。我们只有一个对模型的引用，并且我们接收一个注入的`APIService`以传递给模型。然后，我们有`signinClick`和`signupClick`方法，从视图接收用户输入并将其传递给`model`。最后一部分，视图，看起来像这样：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we have two forms, one for the signin and one for signup. Both forms
    are alike except for the `onsubmit` method they use. The sign-in form uses the
    `signinClick` method of our controller, and the sign-up form uses the `signupClick`
    method. In addition to these two forms, we also have, on each form, a Font Awesome
    spinner that is only visible once the user model is loading. We achieve this by
    using the `[hidden]` Angular directive: `[hidden]="!model.loading"`. Similarly,
    the submit buttons are hidden when the model is loading.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个表单，一个用于登录，一个用于注册。这两个表单除了它们使用的`onsubmit`方法不同之外，都是相似的。登录表单使用我们控制器的`signinClick`方法，注册表单使用`signupClick`方法。除了这两个表单，我们还在每个表单上有一个Font
    Awesome旋转器，只有在用户模型正在加载时才可见。我们通过使用`[hidden]` Angular指令来实现这一点：`[hidden]="!model.loading"`。同样，当模型正在加载时，提交按钮也是隐藏的。
- en: So, here it is, a functional MVC applied to Angular.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是一个应用于Angular的功能性MVC。
- en: As I said at the beginning of this section, for me, the actual usefulness of
    the MVC pattern in Angular comes from its extensibility. Indeed, leveraging the
    object-oriented aspect (and what comes with it) of TypeScript allows us to specialize
    a controller and model for different Angular applications. For example, if you
    have an Angular website and an Angular mobile application, as I do with `toolwatch.io`,
    then you have business logic you can reuse on both sides. It would be a shame
    to have two sign-ins, two sign-ups, and two of everything to code and maintain
    over time when we could have only one!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本节开头所说的，对我来说，MVC模式在Angular中的实际用处来自于它的可扩展性。事实上，利用TypeScript的面向对象的特性（以及随之而来的内容）允许我们为不同的Angular应用程序专门定制控制器和模型。例如，如果你有一个Angular网站和一个Angular移动应用程序，就像我在`toolwatch.io`中所做的那样，那么你可以在两边重用业务逻辑。当我们本可以只有一个时，如果随着时间的推移，我们需要编写和维护两个登录、两个注册和两个所有内容，那将是一件遗憾的事情！
- en: At `toolwatch.io`, for example, the web application uses standard Angular, and
    we built the mobile applications using Ionic2 and Angular. Obviously, we have
    a lot a frontend logic shared between the mobile apps (Android and iOS) and the
    website. Ultimately, they tend to achieve the same purposes and functionalities.
    The only difference is the medium used to use those functionalities.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在`toolwatch.io`，Web应用程序使用标准的Angular，我们使用Ionic2和Angular构建移动应用程序。显然，我们在移动应用程序（Android和iOS）和网站之间共享了许多前端逻辑。最终，它们倾向于实现相同的目的和功能。唯一的区别是用于使用这些功能的媒介。
- en: 'In the following figure, I loosely represent a complete way of leveraging the
    MVC pattern with a focus on reusability and extensibility:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我粗略地表示了一种利用MVC模式实现重用和可扩展性的完整方式：
- en: '![](assets/055395a5-090b-468e-bf7e-211dc47a51ad.png)Reusable MVC for Angular.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/055395a5-090b-468e-bf7e-211dc47a51ad.png)可重用的Angular MVC。'
- en: 'Once again, the Backend stays as-is. We have the same MVC pattern there. As
    a reminder, the MVC pattern on the Backend is entirely up to you, and you could
    take advantage of the Frontend MVC pattern with a functional Go Backend, for example.
    What differs from the previous version of the MVC exposed here is the introduction
    of the Reusable Frontend part. In this part, we still have an API service in charge
    of consuming our JSON API. Then, we have a model that implements the `IModel`
    interface:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 后端保持不变。我们在那里有相同的MVC模式。作为提醒，后端上的MVC模式完全取决于您，例如，您可以利用前端MVC模式与功能性的Go后端。在此处公开的MVC的先前版本不同的是引入了可重用的前端部分。在这部分中，我们仍然有一个负责消费我们的JSON
    API的API服务。然后，我们有一个实现`IModel`接口的模型：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This interface defines the `put`, `post`, `delete`, and `patch` methods that
    have to be implemented in the subsequent models. The `POTO` type that these methods
    take as parameters and return is the mother class for any domain model you have
    in your program. A domain model represents the synchronizable entity of your business
    logic such as the User we used before. The domain model and the model part of
    MVC are not to be confused. They are not the same thing at all. In this architecture,
    User would extend `POTO`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口定义了必须在随后的模型中实现的`put`、`post`、`delete`和`patch`方法。这些方法接受和返回的`POTO`类型是您程序中任何领域模型的母类。领域模型代表您的业务逻辑中可同步的实体，例如我们之前使用的用户。领域模型和MVC的模型部分不应混淆。它们根本不是同一回事。在这种架构中，用户将扩展`POTO`。
- en: 'The model (of MVC this time) contains a `POTO` also to implement the `IModel`
    interface. Also, it contains the variables and methods you need to update your
    views. The implementation of the model itself is rather straightforward as I have
    shown earlier in this section. However, we can kick things up a notch by leveraging
    the generic aspect of TypeScript and envision the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这次的模型（MVC模式）也包含一个`POTO`来实现`IModel`接口。此外，它包含您需要更新视图的变量和方法。模型本身的实现如我在本节前面所示，相当简单。然而，我们可以通过利用TypeScript的通用方面并设想以下内容来提高一些东西：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we have the generic `AbstractModel` that is constrained by `POTO`. It
    means that the actual instance of the `AbstractModel` generic class (known as
    a template in a language such as C++) is constrained to have a class-specializing
    `POTO`. In other words, only domain models such as `User` can be used. So far,
    the separation of concern is excellent as well as the reusability. The last piece
    of the reusable part is the controller. In our sign-up/sign-in example, it would
    look very much like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个通用的`AbstractModel`，它受到`POTO`的约束。这意味着`AbstractModel`通用类的实际实例（在诸如C++之类的语言中称为模板）受到类专门化的`POTO`的约束。换句话说，只有诸如`User`之类的领域模型才能被使用。到目前为止，关注点的分离以及可重用性都非常出色。可重用部分的最后一部分是控制器。在我们的注册/登录示例中，它看起来会非常像这样：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, why do we need an additional building block here and can't we use a simple
    Angular component as we did for the simpler version of the Angular MVC? Well,
    the thing is that, depending on what you use on top of your Angular core (Ionic,
    Meteor, and so on), the component is not necessarily the main building block.
    For example, in the Ionic2 world, you use pages that are the custom version of
    the classical component.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为什么我们在这里需要一个额外的构建块，不能像我们在Angular MVC的简化版本中那样使用简单的Angular组件呢？嗯，问题在于，取决于您在Angular核心之上使用的内容（Ionic、Meteor等），组件并不一定是主要的构建块。例如，在Ionic2世界中，您使用的是页面，这是经典组件的自定义版本。
- en: 'So, for example, the mobile part would look like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，移动部分会是这样的：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If need be, you can also extend `UserModel` and add some specialization as
    shown in the figure of Reusable MVC for Angular. On the browser side, add this
    piece of code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要的话，你也可以扩展`UserModel`并添加一些专业化，就像在Angular的可重用MVC图中所示的那样。在浏览器端，添加这段代码：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once again you can also extend `UserModel` and add some specialization. The
    only remaining block to cover is the view. To my despair, there is no way to extend
    or add a style file for that. Hence, we are doomed to have a duplication of HTML
    files between clients unless the HTML file is the same between the mobile app
    and the browser app. From experience, this does not happen much.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 再一次，你也可以扩展`UserModel`并添加一些专业化。唯一剩下的要涵盖的部分是视图。令我绝望的是，没有办法扩展或添加样式文件。因此，除非HTML文件在移动应用和浏览器应用之间是相同的，否则我们注定要在客户端之间有HTML文件的重复。根据经验，这种情况并不经常发生。
- en: The whole reusable frontend can be shipped as a Git submodule, standalone library,
    or a `NgModule`. I personally use the Git submodule approach, as it allows me
    to have two separate repositories while enjoying auto-refresh on the client I
    am working on when I do a modification on the shared frontend.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 整个可重用的前端可以作为Git子模块、独立库或`NgModule`进行发布。我个人喜欢使用Git子模块的方法，因为它允许我在进行对共享前端进行修改时，享受客户端自动刷新的同时拥有两个独立的存储库。
- en: Note that this MVC also works if you have several frontends hitting the same
    backend instead of several types of frontend. For example, in an e-commerce setup,
    you might want to have differently branded websites to sell different products
    that are all managed in the same backend, like what's possible with Magento's
    views.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你有几个前端同时访问同一个后端，而不是几种类型的前端，这个MVC也是有效的。例如，在电子商务设置中，你可能希望拥有不同品牌的网站来销售在同一个后端中管理的不同产品，就像Magento的视图所能实现的那样。
- en: Singleton and Dependency Injection
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例模式和依赖注入
- en: Another handy pattern to use for frontend application is the singleton. The
    singleton ensures that only one instance of a given object exists in your program.
    Moreover, it provides a global point of access to the object.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 前端应用程序中使用的另一个方便的模式是单例模式。单例模式确保程序中只存在一个给定对象的实例。此外，它提供了对对象的全局访问点。
- en: 'Here''s what it looks like in practice:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上看起来是这样的：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We have a class that has a `private static instance:MySingleton` attribute.
    Then, we have a `private` constructor that makes the following fail:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个类，它有一个`private static instance:MySingleton`属性。然后，我们有一个`private`构造函数，使以下操作失败：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that it fails because your TypeScript transpiler complains about the visibility.
    However, if you transpile the `MySingleton` class to JavaScript and import it
    in another TypeScript project, you will be able to use the new operator as the
    transpiled JavaScript has no visibility at all.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，它失败是因为你的TypeScript转译器抱怨可见性。然而，如果你将`MySingleton`类转译为JavaScript并在另一个TypeScript项目中导入它，你将能够使用新的操作符，因为转译后的JavaScript根本没有可见性。
- en: 'The problem with this fairly simple implementation of the singleton pattern
    is concurrency. Indeed, if two processes hit the `getInstance():MySingleton` at
    the same time, then we will have two instances of the `MySingleton` on the program.
    To be sure that does not happen, we can use a technique called early instantiation:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这种单例模式的相当简单的实现的问题是并发。确实，如果两个进程同时调用`getInstance():MySingleton`，那么程序中将会有两个`MySingleton`的实例。为了确保这种情况不会发生，我们可以使用一种称为早期实例化的技术：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'While you can implement your singleton in Typescript, you can also leverage
    the Angular way of creating a singleton: services! Indeed, in Angular, services
    are only instantiated once and injected to any components needing them. Here''s
    an example of a service and injection via the `NgModule` we have seen before in
    this book:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在TypeScript中实现你的单例，但你也可以利用Angular创建单例的方式：服务！确实，在Angular中，服务只被实例化一次，并注入到需要它们的任何组件中。这里有一个通过`NgModule`进行服务和注入的例子，我们在本书中之前已经看过：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, we have:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们有：
- en: '`APIService` displays the `@Injectable()` annotation that makes it, well, injectable.
    Also, the `APIService` has an `increment:number` attribute that is incremented
    every time a new instance is created. The `increment:number` being static, it
    will tell us exactly how many instances there are in our program. Finally, the
    `APIService` has a `toString:string` method that returns the current instance
    number.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APIService`显示了`@Injectable()`注解，使其可以被注入。另外，`APIService`有一个`increment:number`属性，每次创建新实例时都会增加。`increment:number`是静态的，它将告诉我们程序中有多少个实例。最后，`APIService`有一个`toString:string`方法，返回当前实例编号。'
- en: '`AppComponent` is a classical component that receives an injection of the `APIService`.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppComponent`是一个经典组件，它接收了`APIService`的注入。'
- en: '`OtherComponent` is another classical component that receives an injection
    of the `APIService`.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OtherComponent`是另一个经典组件，它接收了`APIService`的注入。'
- en: '`/app.module.ts` contains our `NgModule`. In the `NgModule`, most of the declarations
    shown here have already been discussed in this book. The novelty comes from the
    `providers: [APIService]` part. Here, we declare a provider for the `APIService`
    itself. As the `APIService` does not do anything too crazy, it can be provided
    by using a reference to the class. More complex services that, for example, require
    injection need custom-tailored providers.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/app.module.ts`包含我们的`NgModule`。在`NgModule`中，这里显示的大部分声明已经在本书中讨论过。新颖之处来自于`providers:
    [APIService]`部分。在这里，我们声明了`APIService`本身的提供者。由于`APIService`并没有做什么太疯狂的事情，它可以通过引用类来提供。更复杂的服务，例如需要注入的服务，需要定制的提供者。'
- en: 'Now, if we navigate to these two components, the result is:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们导航到这两个组件，结果是：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This proves that only one instance has been created and the same instance has
    been injected to both components. Hence, we have a singleton. However, this singleton,
    while convenient, isn''t safe. Why, you ask. Well, the `APIService` can also be
    provided at the component level, like so:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明只创建了一个实例，并且相同的实例已被注入到两个组件中。因此，我们有一个单例。然而，这个单例虽然方便，但并不安全。你为什么这样问。嗯，`APIService`也可以在组件级别提供，就像这样：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In such a case, two separate instances would be created, resulting in the following
    output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，将创建两个单独的实例，导致以下输出：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Consequently, using Angular services, you cannot enforce the singleton pattern
    contrary to its plain TypeScript counterpart. Also, the plain TypeScript would
    be an order of magnitude faster than the Angular services as we skip the injection
    process altogether. The exact number depends heavily on the CPU/RAM of your machine.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用Angular服务，你无法强制实施单例模式，与其普通的TypeScript对应相反。另外，普通的TypeScript会比Angular服务快上一个数量级，因为我们完全跳过了注入过程。确切的数字严重依赖于你的机器的CPU/RAM。
- en: The only question left to answer in the case of a singleton is when to use it.
    A singleton enforces only one instance of a given class in your program. Consequently,
    it is a very good fit for any sort of communication with a backend or any hardware
    access. For example, in the case of communication with a backend, it might be
    desirable to have only one `APIService` handling API keys, API limits, and CSRF
    tokens across the board without having to make sure we pass the same instance
    of the service throughout all our components, models, and so on. In the case of
    hardware access, you might want to be sure that you have only one connection open
    to the webcam or the microphone of our users so you can properly release them
    when you are done with it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在单例的情况下，唯一剩下的问题是何时使用它。单例强制程序中给定类的唯一实例。因此，它非常适合与后端或任何硬件访问进行通信。例如，在与后端通信的情况下，可能希望只有一个`APIService`处理API密钥、API限制和跨站请求伪造令牌，而无需确保我们在所有组件、模型等中传递相同的服务实例。在硬件访问的情况下，可能希望确保只有一个连接打开到用户的网络摄像头或麦克风，这样在使用完毕后可以正确释放它们。
- en: Prototype and reusable pool
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型和可重用池
- en: Object-oriented developers looked at ways to reduce the cost of creating objects,
    especially, when those objects are expensive to create because they require, for
    example, a database pull or complex mathematical operations. Another reason to
    invest in reducing the creation cost of a particular object is when you create
    a lot of them. Nowadays, backend developers tend to disregard this aspect of optimization
    as on-demand CPU/memory have become cheap and easy to adjust. It will literally
    cost you a few bucks more a month to have an additional core or 256 MB RAM on
    your backend.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的开发人员寻找减少创建对象成本的方法，特别是当这些对象因为需要进行数据库拉取或复杂的数学运算而昂贵时。减少特定对象创建成本的另一个原因是当你创建大量对象时。如今，后端开发人员倾向于忽视优化的这一方面，因为按需的CPU/内存已经变得便宜且易于调整。在你的后端上每月多花几美元就可以获得额外的核心或256MB的RAM。
- en: This used to be a big deal for desktop application developers too. On a client
    desktop, there is no way to add CPU/RAM on demand, but fairly cadenced quad cores
    and a *ridiculous* amount of RAM for consumer PCs made the issue less problematic.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于桌面应用程序开发人员来说曾经是一个大问题。在客户端桌面上，没有办法按需添加CPU/RAM，但是相当规律的四核处理器和消费级PC上*荒谬*的大量RAM使这个问题变得不那么棘手。
- en: Nowadays, only game and intensive analytics solutions developers seem to care.
    So, why should you care about the creation time of your object after all? Well,
    you are building something that is likely to be accessed from old devices (I still
    use an iPad 1 for casual browsing on the kitchen or the couch). While a desktop
    application developer can publish minimum and recommended configurations--and
    enforce them by refusing to install itself--we, as web developers, don't have
    this luxury. Now, if your website does not behave properly, users will not question
    their machines but your skills. Ultimately, they will not use your products, even
    when on a capable machine.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，似乎只有游戏和密集型分析解决方案开发人员似乎关心这个问题。那么，毕竟为什么你应该关心对象的创建时间呢？嗯，你正在构建的东西很可能会被旧设备访问（我仍然在厨房或沙发上使用iPad
    1进行休闲浏览）。虽然桌面应用程序开发人员可以发布最低和推荐配置，并通过拒绝安装来强制执行它们，但作为Web开发人员，我们没有这种奢侈。现在，如果你的网站表现不佳，用户不会质疑他们的设备，而是质疑你的技能。最终，即使在一台性能强大的机器上，他们也不会使用你的产品。
- en: 'Let''s see how to use the `Prototype` design pattern. The `Prototype` design
    pattern allows an object to create customized objects without knowing their class
    or any details of how to create them. The intent is to create new objects by copying
    this prototype rather than actually instantiating a new object. First, we will
    need a `Prototype` interface as so:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`Prototype`设计模式。`Prototype`设计模式允许对象创建定制对象，而无需知道它们的类或任何创建它们的详细信息。其目的是通过复制这个原型来创建新对象，而不是实际实例化一个新对象。首先，我们需要一个`Prototype`接口，如下所示：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `Prototype` interface only defines a `clone` method that returns a `Prototype`--compliant
    object. You will have guessed it, the optimized way of creating objects is to
    clone them when needed! So let''s say you have an object `Movie` that, for some
    reason, takes time to build:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Prototype`接口只定义了一个`clone`方法，该方法返回一个符合`Prototype`的对象。您已经猜到了，创建对象的优化方式是在需要时进行克隆！所以假设您有一个`Movie`对象，由于某种原因，需要花费时间来构建：'
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see the override function in TypeScript is different from most languages.
    Here, the two signatures of the constructor are on top of each other and share
    the same implementation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，TypeScript中的覆盖函数与大多数语言不同。在这里，构造函数的两个签名叠在一起，并共享相同的实现。
- en: Moreover, that is it for the `Prototype` pattern.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这就是`Prototype`模式的全部内容。
- en: 'One other pattern that often goes with the prototype pattern is the object
    pool pattern. While working with expensive-to-create objects, cloning them sure
    makes a difference. What can make an even bigger difference is to not do anything
    at all: no creation, no cloning. To achieve this, we can use the pool pattern.
    In this pattern, we have a pool of objects ready to be shared by any clients or
    components in the case of an Angular application. The pool implementation is simple:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通常与原型模式一起使用的另一个模式是对象池模式。在使用昂贵的创建对象时，克隆它们确实会有所不同。更大的不同之处在于根本不做任何事情：不创建，不克隆。为了实现这一点，我们可以使用池模式。在这种模式下，我们有一组对象池，可以被任何客户端或组件共享，例如在Angular应用程序的情况下。池的实现很简单：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'First and foremost, the pool is also a singleton. Indeed, it would not make
    much sense to have this costly object as a reusable design if anyone can create
    pools at will. Consequently, we have the `static instance:MoviePool` and the private
    constructor to ensure that only one pool can be created. Then, we have the following
    attribute:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，池也是一个单例。事实上，如果任何人都可以随意创建池，那么将不会有太多意义。因此，我们有`static instance:MoviePool`和私有构造函数，以确保只能创建一个池。然后，我们有以下属性：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `movies` attribute stores a collection of movies and a Boolean used to determine
    if anyone is currently using any given movie. As the movie objects are hypothetically
    taxing to create or maintain in memory, it makes sense to have a hard limit on
    how many such objects we can have in our pool. This limit is managed by the private
    `static nbMaxMovie = 10`; attribute. To obtain movies, components would have to
    call the `getMovie():Movie` method. This method does a hard create on the first
    movie and then leverages the prototype pattern to create any subsequent movie.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`movies`属性存储了一系列电影和一个布尔值，用于确定当前是否有人在使用任何给定的电影。由于电影对象在理论上很费力创建或在内存中维护，因此有必要对我们的池中可以拥有多少这样的对象进行硬性限制。这个限制由私有的`static
    nbMaxMovie = 10`属性管理。要获取电影，组件必须调用`getMovie():Movie`方法。这个方法在第一部电影上进行了硬性创建，然后利用原型模式来创建任何后续的电影。'
- en: Every time a movie is checked out of the pool, the `getMovie` method changes
    the used Boolean to true. Note that, in the case where the pool is full and we
    do not have any free movies to give away, then an error is thrown.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每当从池中检出一部电影时，`getMovie`方法会将使用的布尔值更改为true。请注意，在池已满且我们没有任何空闲电影可供赠送的情况下，将抛出错误。
- en: Finally, components need a way to check their movies back to the pool so others
    can use them. This is achieved by the `releaseMovie` method. This method receives
    a checked out movie and iterates over the movies of the pool to set the according
    Boolean to false. Hence, the movie becomes usable for other components.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，组件需要一种方法来将它们的电影归还到池中，以便其他组件可以使用它们。这是通过`releaseMovie`方法实现的。该方法接收一个已检出的电影，并遍历池中的电影，将相应的布尔值设置为false。因此，电影可以供其他组件使用。
- en: Factory pattern
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂模式
- en: 'Let''s assume that we have a `User` class with two private variables: `lastName:string`
    and `firstName:string`. Also, this simple class proposes the method hello that
    prints `"Hi I am", this.firstName, this.lastName`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个`User`类，其中有两个私有变量：`lastName:string`和`firstName:string`。此外，这个简单的类提供了一个打印“Hi
    I am”，this.firstName，this.lastName的方法hello：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, consider that we receive users through a JSON API. Most likely, it will
    look something like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑到我们通过JSON API接收用户。很可能会是这样的：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'With the following snippet, we can create a `User`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下代码片段，我们可以创建一个`User`：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Until now; the TypeScript compiler doesn''t complain, and it executes smoothly.
    It works because the parse method returns `any` (that is, the TypeScript equivalent
    of the Java Object). Sure enough, we can convert the `any` into `User`. However,
    `userFromJSONAPI.hello()`; will yield:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，TypeScript编译器没有抱怨，并且执行顺利。这是因为解析方法返回`any`（即Java对象的TypeScript等价物）。当然，我们可以将`any`转换为`User`。然而，`userFromJSONAPI.hello()`将产生：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Why? Well, the left side of the = statement is defined as `User`, sure, but
    it will be erased when we transpile it to JavaScript.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？嗯，=语句的左侧被定义为`User`，但当我们将其转译为JavaScript时，它将被擦除。
- en: 'The type-safe TypeScript way to do it would be:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型安全的TypeScript方法来做这件事将是：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Interestingly enough, the `typeof` function will not help you either. In both
    cases it will display `Object` instead of `User` as the very concept of `User`
    does not exist in JavaScript.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`typeof`函数也无法帮助你。在这两种情况下，它都会显示`Object`而不是`User`，因为JavaScript中并不存在`User`的概念。
- en: While the direct type-safe approach works, it is not very expansible nor reusable.
    Indeed, the map `callback` method would have to be duplicated everywhere you receive
    a JSON user. The most convenient way to do that is with the `Factory` pattern.
    A `Factory` is used to create objects without exposing the instantiation logic
    to the client.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然直接的类型安全方法可以工作，但它并不是非常可扩展或可重用的。实际上，无论何时接收到一个JSON用户，都必须在每个地方重复使用map `callback`方法。最方便的方法是使用`Factory`模式来做到这一点。`Factory`用于创建对象，而不会将实例化逻辑暴露给客户端。
- en: 'If we were to have a factory to create a user; it would look like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要有一个工厂来创建一个用户；它会是这样的：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we have a static method named `buildUser` that receives a JSON object
    and takes all the required values inside the JSON object to invoke, with the right
    attributes, a hypothetical `User` constructor. The method is static as are all
    the methods of such a factory. Indeed, we do not need to save any states or instance-bound
    variables in a factory; we only encapsulate away the gruesome creation of users.
    Note that your factory will likely be shared with the rest of your POTOs.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个名为`buildUser`的静态方法，它接收一个JSON对象，并从JSON对象中获取所有必需的值，以调用一个假设的`User`构造函数。该方法是静态的，就像工厂的所有方法一样。实际上，我们不需要在工厂中保存任何状态或实例绑定的变量；我们只需要封装用户的创建过程。请注意，您的工厂可能会与您的POTO的其余部分共享。
- en: Memento pattern
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备忘录模式
- en: The memento pattern is a really-really useful pattern in the context of Angular.
    In Angular-powered applications, we use and overuse Two-way Data Binding between
    domain models such as `User` or `Movie`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular的上下文中，备忘录模式是一个非常有用的模式。在由Angular驱动的应用程序中，我们过度使用双向数据绑定，例如`User`或`Movie`等领域模型。
- en: 'Let''s consider two components: one named `Dashboard` and the other one named
    `EditMovie`. On the Dashboard component, you have a list of movies displayed in
    the context of our IMDB-like application. The view of such a dashboard could look
    like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑两个组件：一个名为`Dashboard`，另一个名为`EditMovie`。在Dashboard组件上，您有一个电影列表显示在我们类似IMDB的应用程序的上下文中。这样的仪表板视图可能如下所示：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This simple view owns a `ngFor` directive that iterates over the list of movies
    contained in a model. Then, for each movie, it displays two p elements containing
    the title and the release year, respectively.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的视图拥有一个`ngFor`指令，它遍历模型中包含的电影列表。然后，对于每部电影，它显示两个包含标题和发行年份的p元素。
- en: 'Now, the `EditMovie` components access one of the movies in the `model.movies`
    array and allow the user to edit it:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`EditMovie`组件访问`model.movies`数组中的一部电影，并允许用户对其进行编辑：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Thanks to the Two-way Data Binding used here, the modifications were to the
    movie title and year will directly impact the dashboard. As you can notice, we
    have a cancel button here. While the user might expect that the modification is
    synchronized in realtime*,* he/she also expects that the Cancel button/link cancels
    the modifications that have been done on the movie.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这里使用了双向数据绑定，对电影标题和年份的修改将直接影响仪表板。正如您所注意到的，我们这里有一个取消按钮。虽然用户可能期望修改是实时同步的，但他/她也期望取消按钮/链接取消对电影所做的修改。
- en: 'That is where the Memento pattern comes into play. This pattern allows you
    to perform undo operations on objects. It can be implemented in many ways, but
    the simplest one is to go with cloning. Using cloning, we can store away one version
    of our object, at a given moment, and if need be get it back. Let''s enhance our
    `Movie` object from the `Prototype` pattern as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是备忘录模式发挥作用的地方。这种模式允许您对对象执行撤消操作。它可以以许多种方式实现，但最简单的方式是使用克隆。使用克隆，我们可以在给定时刻存储对象的一个版本，并在需要时取回它。让我们根据`Prototype`模式来增强我们的`Movie`对象：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this new version, we added the `restore(movie:Movie)` method that takes a
    `Movie` as an argument and sets the local attributes to the values of the received
    movie.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新版本中，我们添加了`restore(movie:Movie)`方法，它接受一个`Movie`作为参数，并将本地属性设置为接收到的电影的值。
- en: 'Then, in practice, the constructor of our `EditMovie` component could look
    like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在实践中，我们的`EditMovie`组件的构造函数可能如下所示：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: What's interesting is that you are not limited to one memento over time; you
    can have as many as you want.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，您不限于一次性保存状态；您可以拥有尽可能多的状态。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use some of the classical object-oriented
    patterns that are applicable, and useful, for reusable and easy-to-maintain/extend
    real-world applications. The MVC was adapted to Angular and expanded to enable
    highly reusable business logic between different applications. Then, we saw how
    to control the creation of our object with the singleton with and without Dependency
    Injection and the prototype coupled to a pool to limit the number of expensive
    objects in the system. Finally, we learned how to use the factory patterns to
    avoid the traps in JSON-to-TypeScript automatic (and partial) object conversion
    and saw how to perform *undo* operations with the memento pattern.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用一些经典的面向对象模式，这些模式适用于可重用和易于维护/扩展的现实世界应用程序。MVC被调整为Angular，并扩展以在不同应用程序之间实现高度可重用的业务逻辑。然后，我们看到如何使用单例模式以及依赖注入和原型模式与池相结合来控制对象的创建，以限制系统中昂贵对象的数量。最后，我们学习了如何使用工厂模式来避免在JSON到TypeScript自动（和部分）对象转换中的陷阱，并看到如何使用备忘录模式执行*撤消*操作。
- en: If you want to learn even more about patterns to improve your performance, operations
    costs, and maintainability, you can check out the upcoming *Angular Design Patterns*
    *and Best Practices* book by Packt Publishing. This book goes in-depth into patterns
    and their implementation to find the best fit your application.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想学习更多关于模式来提高你的性能、操作成本和可维护性，你可以查看即将推出的Packt Publishing出版的《Angular设计模式与最佳实践》一书。这本书深入探讨了模式及其实施，以找到最适合你的应用程序。
