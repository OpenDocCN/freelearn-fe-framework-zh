- en: Chapter 9. Creating a Shared App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。创建共享应用
- en: Isomorphic apps are JavaScript applications that can run on both client side
    and server side. The idea is that the backend and the frontend should share as
    much code as possible. With a server-rendered app, you can also present content
    up front without waiting for the JavaScript code to initialize.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 同构应用是可以在客户端和服务器端运行的 JavaScript 应用程序。其理念是后端和前端应该尽可能共享代码。对于服务器渲染的应用，您也可以在不等待 JavaScript
    代码初始化的情况下提前展示内容。
- en: 'This chapter is divided into two parts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为两个部分：
- en: In the first part, we'll extend the setup we created in [Chapter 8](ch08.html
    "Chapter 8. Deploying Your App to the Cloud"), *Deploying Your App to the Cloud*,
    so that it supports the pre-rendering of your components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一部分，我们将扩展我们在 [第 8 章](ch08.html "第 8 章。将您的应用部署到云端") 中创建的设置，即 *将您的应用部署到云端*，以便它支持组件的预渲染
- en: In the second part, we'll add Redux and populate your app with data from the
    server environment
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二部分，我们将添加 Redux 并从服务器环境中填充您的应用数据
- en: 'In brief, these are the topics we''ll cover:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，以下是我们将要涉及的主题：
- en: Server rendering versus client rendering
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器渲染与客户端渲染
- en: Terminology confusion
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 术语混淆
- en: Modifying the setup to enable server rendering
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改设置以启用服务器渲染
- en: Streaming your pre-rendered components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流式传输您的预渲染组件
- en: Deploying a server-rendered app to the cloud
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将服务器渲染的应用部署到云端
- en: Server rendering versus client rendering
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器渲染与客户端渲染
- en: Node.js makes it easy to write JavaScript on your backend as well as frontend.
    We've been writing server code all along, but until now, all our apps have been
    client-rendered.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 使得在您的后端和前端编写 JavaScript 变得非常容易。我们一直在编写服务器代码，但直到现在，我们的所有应用都是客户端渲染的。
- en: Rendering your app as a client-rendered app means bundling your JavaScript files
    and distributing it with your images, CSS, and HTML files. It can be distributed
    on any kind of web server running on any kind of operating system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的应用作为客户端渲染的应用渲染意味着捆绑您的 JavaScript 文件，并将其与您的图像、CSS 和 HTML 文件一起分发。它可以在任何操作系统上运行的任何类型的
    Web 服务器上分发。
- en: 'A client-rendered app is generally loaded in two steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端渲染的应用通常分为两个步骤：
- en: The initial request loads `index.html` and the CSS and JavaScript files either
    synchronously or asynchronously.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始请求加载 `index.html` 以及 CSS 和 JavaScript 文件，要么同步要么异步。
- en: Typically, the app then makes another request and generates the appropriate
    HTML based on the server response.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，应用随后会发出另一个请求，并根据服务器响应生成适当的 HTML。
- en: With a server-rendered app, the second step is generally omitted. The initial
    requests load `index.html`, the CSS, the JavaScript, and the content in one go.
    The app is in memory and ready to serve, with no need to wait for the client to
    parse and execute the JavaScript.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务器渲染的应用，第二步通常被省略。初始请求一次性加载 `index.html`、CSS、JavaScript 和内容。应用在内存中，准备提供服务，无需等待客户端解析和执行
    JavaScript。
- en: You'll sometimes hear the argument that a server-rendered app is a necessity
    to serve users who don't have JavaScript on their device or simply have it turned
    off. This is not a valid argument, because all surveys and statistics known to
    me put the number of users at around 1 percent.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你有时会听到这样的论点，即服务器渲染的应用对于服务于那些设备上没有 JavaScript 或简单地将它关闭的用户是必要的。这不是一个有效的论点，因为我知道的所有调查和统计数据都将用户数量估计在约
    1% 左右。
- en: Another argument is to support search bots, who typically struggle with parsing
    JavaScript-based content. This argument is slightly more valid, but major players
    such as Google and Bing are able to do this, although you may need to add a meta
    tag in order for the content to be indexed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个论点是支持搜索引擎机器人，它们通常在解析基于 JavaScript 的内容时遇到困难。这个论点稍微更有道理，但像 Google 和 Bing 这样的主要玩家能够做到这一点，尽管您可能需要添加一个元标签，以便内容可以被索引。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Verifying that bots can read your site**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**验证机器人是否可以读取您的网站**'
- en: You can use Google's own **Fetch as Googlebot** to verify that your content
    is being indexed properly. The tool is available at [https://www.google.com/webmasters/tools/googlebot-fetch](https://www.google.com/webmasters/tools/googlebot-fetch).
    Alternatively, you can refer to [http://www.browseo.net/](http://www.browseo.net/).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Google 的 **Fetch as Googlebot** 工具来验证您的内容是否被正确索引。该工具可在 [https://www.google.com/webmasters/tools/googlebot-fetch](https://www.google.com/webmasters/tools/googlebot-fetch)
    获取。或者，您可以参考 [http://www.browseo.net/](http://www.browseo.net/)。
- en: 'The benefits of a server-rendered app are as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器渲染应用的优点如下：
- en: Users with a slow computer will not have to wait for the JavaScript code to
    parse.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有慢速计算机的用户不需要等待JavaScript代码解析。
- en: It also provides us with predictable performance. You can measure the time it
    takes to load your web page when you have control of the rendering process.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还为我们提供了可预测的性能。当你控制渲染过程时，你可以测量加载你的网页所需的时间。
- en: Doesn't require the user to have a JavaScript runtime on their device.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要用户在他们的设备上安装JavaScript运行时。
- en: Makes it easier for search bots to crawl your page.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使搜索引擎更容易爬取你的页面。
- en: 'The benefits of a client-rendered app are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端渲染应用程序的好处如下：
- en: Less setup to deal with
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要处理的设置更少
- en: No concurrency issues between the server and the client
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器和客户端之间没有并发问题
- en: Generally easier to develop
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常更容易开发
- en: Making a server-rendered app is more involving than writing a client-rendered
    app, but it comes with tangible benefits. We'll start by making our scaffold ready
    for the cloud before moving on to add server rendering. First of all, we need
    to clear up the terminology, as in the wild, you'll encounter several different
    terms to describe apps that share code between the server and the client.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 制作一个服务器端渲染的应用程序比编写客户端渲染的应用程序更复杂，但它带来了实际的好处。我们首先将我们的脚手架准备好以适应云端，然后再添加服务器渲染功能。首先，我们需要澄清术语，因为在实际应用中，你会遇到几个不同的术语来描述服务器和客户端之间共享代码的应用程序。
- en: Terminology confusion
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 术语混淆
- en: The term **isomorphic** is made up of the Greek words *isos* for *equal* and
    *morph* for *shape*. The idea is that by using the term isomorphic, it's easy
    to understand this as code that's shared between the server and client.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**同构**由希腊语单词*isos*（意为“相等”）和*morph*（意为“形状”）组成。这个想法是通过使用同构这个术语，可以很容易地理解这是服务器和客户端之间共享的代码。
- en: In math, isomorphism is a one-to-one mapping function between two sets that
    preserve the relationships between the sets.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，同构是两个集合之间的一对一映射函数，它保留了集合之间的关系。
- en: 'For instance, an isomorphic code example would look something like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个同构的代码示例可能看起来像这样：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These two functions are not the same, but they produce the same result and are
    thus isomorphic for multiplication.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数不相同，但它们产生相同的结果，因此在乘法中是同构的。
- en: Isomorphism may be a good term in math, but it's clearly not such a good fit
    for developing web apps. We've used the term here as the headline for this chapter
    because it's currently a recognized term for server-rendered apps in the JavaScript
    community. However, it's not a very good term, and the hunt is on for a better
    one.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，同构可能是一个好术语，但显然它并不适合开发Web应用程序。我们在这里使用这个术语作为本章的标题，因为它是JavaScript社区中目前公认的用于服务器端渲染应用程序的术语。然而，它并不是一个非常好的术语，我们正在寻找一个更好的术语。
- en: 'In a search for a replacement, the term **Universal** has cropped up as the
    choice of many. Yet, this is not quite ideal either. For one, it''s easy to misunderstand.
    The closest definition of Universal in relation to web apps is this: used or understood
    by all. Remember, the goal is to describe code sharing. But, Universal can also
    be understood as a term describing JavaScript apps that can run anywhere. This
    includes not only the Web, but also native devices and operating systems. This
    confusion is prevalent throughout the web development sphere.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找替代品的过程中，术语**通用**已成为许多人的选择。然而，这并不完全理想。一方面，它很容易被误解。与Web应用程序相关的通用最接近的定义是：被所有人使用或理解。记住，目标是描述代码共享。但是，通用也可以被理解为描述可以在任何地方运行的JavaScript应用程序的术语。这包括不仅限于Web，还包括原生设备和操作系统。这种混淆在Web开发领域普遍存在。
- en: The third term is **Shared**, as in Shared JavaScript. This is more appropriate
    because it implies there is some meaning to your code. When you're writing Shared
    JavaScript, it's implied that the code you write is intended to be used in more
    than one environment.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个术语是**共享**，即共享JavaScript。这更合适，因为它暗示了你的代码有一定的意义。当你编写共享JavaScript时，意味着你编写的代码打算在多个环境中使用。
- en: When searching through the code on the Web, you'll find all these terms used
    interchangeably to describe the same pattern of developing web apps. Proper naming
    is important because it makes your code more understandable to the outside audience.
    Buzzwords are nice and sounds good on your resume, but the more buzzwords you
    use, the harder it will be for your code base to understand it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在网上搜索代码时，你会发现所有这些术语被交替使用来描述相同的开发 Web 应用的模式。正确的命名很重要，因为它使你的代码对外部观众更容易理解。流行词汇听起来不错，听起来很好听，但使用的流行词汇越多，你的代码库理解起来就越困难。
- en: In this chapter, we'll use the term server-rendered for code that renders HTML
    prior to serving it to the user. We'll use the term client-rendered for code that
    defers the rendering of the HTML to the user's device. And finally, we'll use
    the term shared code to describe code that is used interchangeably on both the
    server and the client.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用“服务器端渲染”一词来表示在将其提供给用户之前渲染 HTML 的代码。我们将使用“客户端渲染”一词来表示将 HTML 的渲染推迟到用户设备的代码。最后，我们将使用“共享代码”一词来描述在服务器和客户端都可以互换使用的代码。
- en: Developing a server-rendered app
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发服务器端渲染应用
- en: Developing a Shared app in ReactJS requires more work than just building a client-rendered
    app. It also necessitates that you think about your data flow requirements.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ReactJS 中开发共享应用比仅仅构建客户端渲染应用需要更多的工作。它还要求你考虑你的数据流需求。
- en: 'There are two components that together make it possible to write a server-rendered
    app in ReactJS. It can be thought of like an equation:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS 中编写服务器端渲染应用有两个组成部分，可以将其视为一个等式：
- en: '*Pre-rendering components in your server instance + One-way data flow from
    the server to your components = good app and happy users*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*在服务器实例中预渲染组件 + 从服务器到组件的单向数据流 = 好的应用程序和快乐的用户*'
- en: In this section, we'll look at the first part of the equation. We'll tackle
    the data flow issue in the final section of this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看等式的第一部分。我们将在本章的最后部分解决数据流问题。
- en: Adding packages
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加包
- en: 'We''re going to need a few more packages from `npm` to add them to our dependencies
    section. This is the list of dependencies that we need:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从 `npm` 获取更多包以将它们添加到依赖项部分。这是我们需要的依赖项列表：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Add any missing packages to `package.json` and update it by executing `npm install`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何缺少的包添加到 `package.json` 并通过执行 `npm install` 来更新它。
- en: Adding CSS
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 CSS
- en: 'We''ll need to style our page, so we''ll use a subset of what we used when
    developing **Reactagram** in [Chapter 7](ch07.html "Chapter 7. Reactagram"), *Reactagram*.
    Replace the contents of `assets/app.css` with this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为我们的页面添加样式，所以我们将使用我们在 [第 7 章](ch07.html "第 7 章。Reactagram") 开发 **Reactagram**
    时使用的子集，*Reactagram*。将 `assets/app.css` 的内容替换为以下内容：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Adding Bootstrap CDN to index.html
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Bootstrap CDN 添加到 index.html
- en: 'Since we''re adding `react-bootstrap`, we need to add the Bootstrap CDN files
    as well. Open `assets/index.html` and replace it with this content:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们添加了 `react-bootstrap`，因此我们需要添加 Bootstrap CDN 文件。打开 `assets/index.html` 并将其替换为以下内容：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating components
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建组件
- en: 'We can''t make an app without some content, so let''s add a few pages and a
    route hierarchy. Start by removing `index.jsx` from the `source` folder and `index-production.html`
    from the `assets` folder. The tree structure will look like this when we''re finished
    with this part of the chapter:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能没有一些内容就制作应用程序，所以让我们添加一些页面和路由层次结构。首先，从 `source` 文件夹中删除 `index.jsx`，从 `assets`
    文件夹中删除 `index-production.html`。完成这一部分章节后，树结构将如下所示：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We need to be diligent in how we structure our app in order to make it easy
    to understand and notice how everything fits together with regards to client-side
    and server-side rendering.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要勤奋地构建我们的应用程序，以便使其易于理解，并注意到客户端和服务器端渲染如何相互配合。
- en: 'Let''s start by adding the source code for `client/index.jsx`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加 `client/index.jsx` 的源代码：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code structure should be very familiar at this point.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，代码结构应该非常熟悉。
- en: 'Let''s add our routes. Create `routes/index.jsx` and add this code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加我们的路由。创建 `routes/index.jsx` 并添加以下代码：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The routes will respond to `/`, `/about`, and `/calculator`, and anything else
    will be routed to the `error` component. The `IndexRoute` function routes the
    app to the `Welcome` component if you visit the app without specifying a route
    (for instance, `http://localhost:8080` without the ending slash).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 路由将响应 `/`、`/about` 和 `/calculator`，其他所有内容都将路由到 `error` 组件。如果你访问应用程序而没有指定路由（例如，`http://localhost:8080`
    没有结束斜杠），`IndexRoute` 函数将应用程序路由到 `Welcome` 组件。
- en: The routes are assigned to a few basic views that we're going to create next.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 路由被分配到我们将要创建的几个基本视图。
- en: 'Create `shared/views/layout.jsx` and add this code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `shared/views/layout.jsx` 并添加以下代码：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We''ll fetch the title from the `Settings` component. The following component
    will create a link path that you can use as a navigation element:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 `Settings` 组件中获取标题。以下组件将创建一个你可以用作导航元素的链接路径：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The parameter `setDocumentTitle` is an argument that will make the component
    change the document title of the window tab to the name of the `child` component
    you''re on, let''s put the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 `setDocumentTitle` 是一个将使组件更改窗口标签页的文档标题为你在的 `child` 组件名称的参数，让我们放置以下代码：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create `shared/views/app.jsx` and add this code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `shared/views/app.jsx` 并添加以下代码：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This component creates a simple list with two links. The first goes to the `About`
    component and the second to the `Calculator` component.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件创建了一个包含两个链接的简单列表。第一个链接到 `About` 组件，第二个链接到 `Calculator` 组件。
- en: 'Create `shared/views/error.jsx` and add this code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `shared/views/error.jsx` 并添加以下代码：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This component will show up if you manually enter a wrong path in the URL locator
    of your browser.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在浏览器的 URL 定位器中手动输入错误路径，此组件将显示出来。
- en: 'Create `shared/views/about.jsx` and add this code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `shared/views/about.jsx` 并添加以下代码：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `About` component is a simple placeholder component in our app. You can
    use it to present some information about your app.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`About` 组件是我们应用中的一个简单占位符组件。你可以用它来展示一些关于你应用的信息。'
- en: 'Create `shared/views/calculator.jsx` and add this code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `shared/views/calculator.jsx` 并添加以下代码：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `getInitialState` element is deprecated when using ES6 classes, so we''ll
    need to set out the initial state in the constructor. We can do this by first
    making an empty `state` variable attached to `this`. Then, we add three states:
    `_input` is the calculator input text box, `_prev` is used to hold the number
    to calculate, `_toZero` is a flag that will be used to zero out the input when
    doing calculations, and `_symbol` is the mathematical operation symbol (plus,
    minus, division, and multiply), let''s take a look at the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 ES6 类时，`getInitialState` 元素已被弃用，因此我们需要在构造函数中设置初始状态。我们可以通过首先将一个空的 `state`
    变量附加到 `this` 上来完成此操作。然后，我们添加三个状态：`_input` 是计算器输入文本框，`_prev` 用于保存要计算的数字，`_toZero`
    是一个在计算时用于将输入置零的标志，`_symbol` 是数学运算符号（加、减、除和乘），让我们看看以下代码：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'These three functions alter the input number directly. Let''s move on to the
    next function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个函数直接修改输入的数字。让我们继续到下一个函数：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This function is invoked when you press the **Calculate** button (**=**). It
    will check whether the user has activated a mathematical symbol, and if so, it
    will check which symbol is active and perform the calculation on the stored number
    and the current number, let''s take a look at the following code snippet:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当你按下 **计算** 按钮（**=**）时，此函数会被调用。它将检查用户是否激活了数学符号，如果是，它将检查哪个符号是激活的，并在存储的数字和当前数字上执行计算，让我们看看以下代码片段：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If the input number needs to be turned into zero, this operation will do that
    and reset the `_toZero` flag. Now we move to `isNaN`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入的数字需要变为零，这个操作将完成这个任务并重置 `_toZero` 标志。现在我们转到 `isNaN`：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Using `isNaN` is an efficient way to check whether the variable is a number.
    If not, it''s a mathematical symbol and we handle this by storing the symbol in
    the state, requiring the input number to be made zero (so that we don''t calculate
    the wrong numbers) and set the current input as the `_prev` value (to be calculated
    on), let''s take a look at the following code snippet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `isNaN` 是检查变量是否为数字的高效方法。如果不是，它是一个数学符号，我们通过将符号存储在状态中，要求输入的数字变为零（这样我们不会计算错误的数字），并将当前输入设置为
    `_prev` 值（用于计算），让我们看看以下代码片段：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If it''s a number, we add it to the `_input` state, let''s take a look at the
    following code snippet:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是一个数字，我们将其添加到 `_input` 状态中，让我们看看以下代码片段：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When using `React.createClass`, all functions are automatically bound to the
    component. Since we''re using ES6 classes, we need to bind our functions manually,
    let''s take a look at the following code snippet:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `React.createClass` 时，所有函数都会自动绑定到组件上。由于我们正在使用 ES6 类，我们需要手动绑定我们的函数，让我们看看以下代码片段：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Some characters are difficult to locate on the standard keyboard. Instead,
    we can render it using the Unicode character code. A list of character code and
    their respective images is readily available on the Internet, let''s take a look
    at the following code snippet:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一些字符在标准键盘上难以定位。相反，我们可以使用 Unicode 字符代码来渲染它。字符代码及其相应图像的列表在互联网上很容易找到，让我们看看以下代码片段：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following screenshot shows the **Calculator** page we just created:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了刚刚创建的 **计算器** 页面：
- en: '![Creating components](img/B04943_09_01.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![创建组件](img/B04943_09_01.jpg)'
- en: 'Next, add two files: `config.js` to the `root` folder and `settings.js` to
    `source/shared`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加两个文件：`config.js` 到 `root` 文件夹，`settings.js` 到 `source/shared`。
- en: 'Add this code to `config.js`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码添加到 `config.js`：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, add this code to `settings.js`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将此代码添加到 `settings.js`：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Setting up a server-rendered Express React server
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置服务器端渲染的 Express React 服务器
- en: We have now finished making our shared components, so it's time to set up server
    rendering. In the preceding file structure, you've probably noticed that we've
    added a file called `server-production.es6`. We'll keep the ordinary ES5 version,
    but to simplify our code, we'll type it up in modern JavaScript and use Babel
    to convert it to ES5.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了共享组件的制作，所以现在是时候设置服务器端渲染了。在前面的文件结构中，你可能已经注意到我们添加了一个名为 `server-production.es6`
    的文件。我们将保留普通的 ES5 版本，但为了简化我们的代码，我们将使用现代 JavaScript 编写它，并使用 Babel 将其转换为 ES5。
- en: Using Babel is something we have to live with until the node implements full
    support for ES6/ECMAScript 2015\. We could optionally use `babel-node` to run
    our express server, but it's not advisable to do this in production because it
    adds significant overhead to each request.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Babel 是我们不得不忍受的事情，直到 node 实现对 ES6/ECMAScript 2015 的完全支持。我们可以选择使用 `babel-node`
    来运行我们的 express 服务器，但在生产环境中不建议这样做，因为它会给每个请求增加显著的开销。
- en: 'Let''s see how it should look. Create `server-production.es6` and add the following
    code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它应该是什么样子。创建 `server-production.es6` 并添加以下代码：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We''re going to use client-side routes in our Express server. We''ll set up
    a catch-all Express route and implement react-router routes within it, let''s
    take a look at the following code snippet:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Express 服务器中使用客户端路由。我们将设置一个通配符 Express 路由，并在其中实现 react-router 路由，让我们看看以下代码片段：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We'll also implement a streaming DOM utility instead of using React's own `renderToString`.
    The `renderToString` method is synchronous and can become a performance bottleneck
    in server-side rendering of React sites. Streams make this process much faster
    because you don't need to pre-render the entire string before sending it. With
    larger pages, `renderToString` can introduce a latency of hundreds of milliseconds
    as well as require more memory because it needs to allocate memory to the entire
    string.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将实现一个流式 DOM 工具，而不是使用 React 自身的 `renderToString`。`renderToString` 方法是同步的，在
    React 网站的服务器端渲染中可能会成为性能瓶颈。流使这个过程变得更快，因为您在发送之前不需要预先渲染整个字符串。对于较大的页面，`renderToString`
    可能会引入数百毫秒的延迟，并需要更多的内存，因为它需要为整个字符串分配内存。
- en: '`ReactDOMStream` renders asynchronously to a stream and lets the browser render
    the page before the entire response is finished. Refer to the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReactDOMStream` 异步渲染到流中，并允许在响应完全完成之前，浏览器先渲染页面。请参考以下代码：'
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When performing server rendering, we need to send 500 responses for errors
    and 302 responses for redirects. We can do this by matching and checking the response
    status. If there are no errors, we proceed with the rendering, let''s take a look
    at the following code snippet:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行服务器端渲染时，我们需要为错误发送 500 响应，为重定向发送 302 响应。我们可以通过匹配和检查响应状态来实现这一点。如果没有错误，我们继续进行渲染，让我们看看以下代码片段：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, we need to send a `404` status if we do not find any properties or
    routes, let''s take a look at the remaining code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们找不到任何属性或路由，我们需要发送一个 `404` 状态码，让我们看看剩余的代码：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When the server starts rendering, it will start by writing out our header information.
    It will load the initial CSS files asynchronously, set up the title and the body,
    and the first div. Then, we switch to `ReactDOMStream`, which will then start
    rendering our app starting from `RoutingContext`. When the stream is finished,
    we close the response by wrapping up our `div` and HTML page. Server-rendered
    content now lives inside `<div id="app"></div>`. When `bundle.js` is loaded, it
    will take over and replace the content of this `div`, unless the device it renders
    on doesn't support JavaScript.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器开始渲染时，它将首先写入我们的头部信息。它将异步加载初始 CSS 文件，设置标题和主体，以及第一个 div。然后，我们切换到 `ReactDOMStream`，它将从
    `RoutingContext` 开始渲染我们的应用。当流完成时，我们通过包裹我们的 `div` 和 HTML 页面来关闭响应。服务器渲染的内容现在位于 `<div
    id="app"></div>` 内。当 `bundle.js` 被加载时，它将接管并替换这个 `div` 的内容，除非渲染的设备不支持 JavaScript。
- en: 'Note that while the CSS files are asynchronous, they still block the rendering
    until they are loaded. It''s possible to get around this by inlining the CSS to
    avoid extra lookups, let''s take a look at the following code snippet:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管 CSS 文件是异步的，但它们仍然会在加载之前阻塞渲染。可以通过内联 CSS 来绕过这个问题，让我们看看以下代码片段：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The final part is the same as before, just modified to use the new JavaScript
    syntax. One thing you have noticed is that we're importing our source components
    from a new folder called `build` rather than `source`. We can get away with converting
    our source code to ES5, with Babel on runtime when developing; however, this won't
    fly in production. Instead, we need to convert our entire source manually.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分与之前相同，只是修改为使用新的 JavaScript 语法。你注意到的一件事是我们从名为 `build` 的新文件夹中导入源组件，而不是 `source`。在开发时，我们可以通过在运行时使用
    Babel 将源代码转换为 ES5 来避免这个问题；然而，在生产环境中这不可行。相反，我们需要手动将整个源代码转换为 ES5。
- en: First, let's change two lines in `webpack.config.dev.js` and verify that it
    builds locally.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在 `webpack.config.dev.js` 中更改两行，并验证它是否在本地构建。
- en: Open the file and replace the line in the entry where it says `./source/index`
    with `./source/client/index`, and the line path `path.join(__dirname, 'public',
    'assets')` to `path.join(__dirname, 'assets')`. Then, run the project by executing
    `npm run dev`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件，将入口处的行 `./source/index` 替换为 `./source/client/index`，并将路径 `path.join(__dirname,
    'public', 'assets')` 替换为 `path.join(__dirname, 'assets')`。然后，通过执行 `npm run dev`
    来运行项目。
- en: 'The following screenshot shows the main page of the app:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了应用的主页：
- en: '![Setting up a server-rendered Express React server](img/B04943_09_02.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![设置服务器渲染的 Express React 服务器](img/B04943_09_02.jpg)'
- en: Your app should now run without problems, and `http://localhost:8080` should
    now present you with the **Shared App** screen. You should be able to edit the
    code in your `source` folder and see it updated live on the screen. You should
    also be able to click on the links and perform math operations with the calculator.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用现在应该没有问题地运行，并且 `http://localhost:8080` 应该现在显示 **共享应用** 屏幕。你应该能够编辑 `source`
    文件夹中的代码，并看到它在屏幕上实时更新。你也应该能够点击链接并使用计算器执行数学运算。
- en: Setting up Webpack for server-rendering
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Webpack 用于服务器渲染
- en: 'Open `Webpack-production.config.js` and replace its content with the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Webpack-production.config.js` 并将其内容替换为以下内容：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We're not going to rely on Babel to convert our code on the fly, so we can remove
    the `module` and `resolve` section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会依赖 Babel 在运行时转换我们的代码，因此我们可以删除 `module` 和 `resolve` 部分。
- en: Setting up npm scripts for server rendering
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置用于服务器渲染的 npm 脚本
- en: 'Open `package.json` and replace the `scripts` section with this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `package.json` 并将 `scripts` 部分替换为以下内容：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here''s what a running `npm start` command will do:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个运行 `npm start` 命令会执行的操作：
- en: Run the build (before it starts).
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行构建（在它开始之前）。
- en: Delete the `public` and `build` folder, and convert the ES2015 source to ES5
    and put it in the `builder` folder (the prebuild process).
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 `public` 和 `build` 文件夹，并将 ES2015 源代码转换为 ES5，然后放入 `builder` 文件夹（预构建过程）。
- en: Run Webpack and create a *bundle* in `public/assets` (the build process).
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Webpack 并在 `public/assets` 中创建一个 *bundle*（构建过程）。
- en: Run convert, which is in order to convert `server-production.es6` to `server-production.js`
    (when it is started).
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行转换，目的是将 `server-production.es6` 转换为 `server-production.js`（当它启动时）。
- en: Run the Express server (after it has started).
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Express 服务器（在它启动之后）。
- en: Phew! That's a huge command chain. After the compilation is over, the server
    starts and you can go to `http://localhost:8080` to test your pre-rendered server.
    You'll probably not even notice the difference at first glance, but try turning
    off JavaScript in your browser and perform the refresh action. The page will still
    load and you'll still be able to navigate. The calculator will not work, however,
    because it requires client-side JavaScript to work. As noted earlier, the goal
    is not to support JavaScript-less browsers (as they are rare). The goal is to
    deliver a pre-rendered page, and that's what this does.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 呼呼！这是一个庞大的命令链。编译完成后，服务器启动，你可以访问 `http://localhost:8080` 来测试你的预渲染服务器。你一开始可能甚至不会注意到任何区别，但尝试在浏览器中关闭JavaScript并执行刷新操作。页面仍然会加载，你仍然可以导航。然而，计算器将无法工作，因为它需要客户端JavaScript才能运行。正如之前所述，目标不是支持无JavaScript的浏览器（因为它们很少见）。目标是提供预渲染的页面，这正是它所做到的。
- en: 'We change `npm deploy` as well. Here''s what this does:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还更改了 `npm deploy`。这是它所做的工作：
- en: Run the build (before it is deployed).
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在部署之前运行构建。
- en: Run convert, in order to convert `server-production.es6` to `server-production.js`
    (once it's deployed).
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行convert，将 `server-production.es6` 转换为 `server-production.js`（一旦部署）。
- en: It will let you know it's done. This step could be replaced with a push to the
    cloud (post its deployment).
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它会通知你已完成。这一步可以被替换为将其部署到云端（在部署后）。
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The server-rendered app is now complete. You can find a demo at [https://reactjsblueprints-srvdeploy.herokuapp.com/](https://reactjsblueprints-srvdeploy.herokuapp.com/).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染的应用现在已经完成。你可以在 [https://reactjsblueprints-srvdeploy.herokuapp.com/](https://reactjsblueprints-srvdeploy.herokuapp.com/)
    找到演示。
- en: Adding Redux to your server-rendered app
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Redux添加到你的服务器端渲染应用中
- en: 'The final piece of the puzzle is the handling of the data flow. In a client-rendered
    app, data flow is generally handled in this way: The user initiates an action,
    for instance, by visiting the index page of your app. The app then routes to the
    view and the render process starts. After the rendering, or during the rendering
    (asynchronously), data is fetched and then displayed to the user.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是处理数据流。在客户端渲染的应用中，数据流通常是这样处理的：用户通过访问应用的主页来启动一个动作。然后应用路由到视图，渲染过程开始。在渲染后或渲染期间（异步），数据被获取并显示给用户。
- en: In a server-rendered app, the data needs to be prefetched before the rendering
    process starts. The responsibility of fetching the data shifts from the client
    to the server. This necessitates a complete rethink of how we structure our apps.
    It's important to make this decision before you start designing your app because
    changing your data flow architecture after you've started implementing the app
    is a costly operation.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端渲染的应用中，需要在渲染过程开始之前预先获取数据。获取数据的责任从客户端转移到服务器。这需要我们对如何构建我们的应用进行彻底的重新思考。在开始设计你的应用之前做出这个决定是很重要的，因为在你开始实现应用之后改变你的数据流架构是一项成本高昂的操作。
- en: Adding packages
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加包
- en: 'We need to add a number of new packages to our project. The `package.json`
    file should now look like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向我们的项目中添加许多新包。`package.json` 文件现在应该看起来像这样：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We're going to perform isomorphic fetching like we did in [Chapter 6](ch06.html
    "Chapter 6. Advanced React"), *Advanced React*, so we need to add the `isomorphic-fetch`
    library. This library adds `fetch` as a global function so that its API is consistent
    between the client and server.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将执行类似于[第6章](ch06.html "第6章。高级React")中所述的异构获取，因此我们需要添加 `isomorphic-fetch` 库。这个库将
    `fetch` 添加为一个全局函数，使其API在客户端和服务器之间保持一致。
- en: We'll also add Redux and a console logger instead of the devtools logger we
    used in [Chapter 6](ch06.html "Chapter 6. Advanced React"), *Advanced React*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加Redux和一个控制台记录器，而不是我们在[第6章](ch06.html "第6章。高级React")中使用的devtools记录器。
- en: Adding files
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加文件
- en: We'll add a number of new files to our project and change a few of the existing
    ones. The functionality we'll implement is the asynchronous fetching of a set
    of news items from an offline news API available at [http://reactjsblueprints-newsapi.herokuapp.com/stories](http://reactjsblueprints-newsapi.herokuapp.com/stories).
    It provides a set of news stories updated at regular intervals.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向我们的项目中添加许多新文件，并更改一些现有文件。我们将实现的功能是从一个离线新闻API异步获取一组新闻条目，该API位于 [http://reactjsblueprints-newsapi.herokuapp.com/stories](http://reactjsblueprints-newsapi.herokuapp.com/stories)。它提供了一系列定期更新的新闻故事。
- en: 'We''ll start with `client/index.jsx`. Open this file and replace the content
    with this code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 `client/index.jsx` 开始。打开这个文件，并用以下代码替换其内容：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we add `polyfill` and the `Redux` setup like we did in [Chapter 6](ch06.html
    "Chapter 6. Advanced React"), *Advanced React*. We also add a check for `window.__INITIAL_STATE__`,
    which is how we'll transfer the server-rendered content to our app.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加 `polyfill` 和与 [第 6 章](ch06.html "第 6 章。高级 React") 中相同的 `Redux` 设置，*高级
    React*。我们还添加了对 `window.__INITIAL_STATE__` 的检查，这是我们如何将服务器渲染的内容传输到我们的应用程序。
- en: 'Next, open `routes/index.jsx` and replace the content with this code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开 `routes/index.jsx` 并用以下代码替换其内容：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'These functions are responsible for transmitting state and functions to our
    `child` components. We''ll use them to pass the news stories to our `News` component
    and the `dispatch` and `fetchPostsIfNeeded` functions. Next, add a new folder
    to `shared` and call it `actions`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数负责将状态和函数传递给我们的 `child` 组件。我们将使用它们将新闻故事传递给 `News` 组件以及 `dispatch` 和 `fetchPostsIfNeeded`
    函数。接下来，在 `shared` 中添加一个新的文件夹，命名为 `actions`：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this folder, add a file called `index.js` with this code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件夹中，添加一个名为 `index.js` 的文件，并添加以下代码：
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This function will check whether the stored state exists and has content; if
    not, it will dispatch a call to `fetchPosts()`. This will make sure we will be
    able to take advantage of the state rendered by the server and fetch the content
    on the client if no such state exists. Refer to the next function in the following
    code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将检查存储的状态是否存在并且有内容；如果没有，它将调用 `fetchPosts()` 的调用。这将确保我们能够利用服务器渲染的状态，并在客户端没有这样的状态时获取内容。参考以下代码中的下一个函数：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This function returns a `fetch` operation from our API file. It dispatches
    the `receivePosts()` function, which is the `Redux` function that tells the Redux
    store to call the `RECEIVE_POSTS` reducer function. Let''s take a look at the
    following code snippet:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数从我们的 API 文件中返回一个 `fetch` 操作。它调用 `receivePosts()` 函数，这是 Redux 函数，告诉 Redux
    存储调用 `RECEIVE_POSTS` 减法器函数。让我们看看下面的代码片段：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The next file we''ll add is `fetch-posts.js`. Create a folder called `api`
    in `shared`, then add the file, and then this code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个我们将添加的文件是 `fetch-posts.js`。在 `shared` 中创建一个名为 `api` 的文件夹，然后添加文件，并添加以下代码：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This function simply returns a set of stories using the fetch API.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数简单地使用 fetch API 返回一组故事。
- en: 'Next, add a folder called `reducers` to `shared`, then add `index.js`, and
    then this code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `shared` 中添加一个名为 `reducers` 的文件夹，然后添加 `index.js` 文件，并添加以下代码：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Our reducer picks up the new state and returns a new object with the set of
    posts that we fetched.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的减法器获取新的状态，并返回一个新的对象，其中包含我们获取的帖子集合。
- en: 'Next, create a folder called `store` in `shared`, add a file and call it `configure-store.js`,
    and then add this content:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `shared` 中创建一个名为 `store` 的文件夹，添加一个文件并命名为 `configure-store.js`，然后添加以下内容：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We create a function that takes `initialState` and returns a store with our
    reducer and adds middleware for asynchronous operation and logging. The logger
    displays log data in the console window of the browser.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个函数，它接受 `initialState` 并返回一个包含我们的减法器和添加异步操作和日志中间件的存储。日志显示在浏览器控制台窗口中的日志数据。
- en: 'The final two files we add should be placed in the `views` folder. The first
    one is `news.jsx`. For this, add the following code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个文件应该放在 `views` 文件夹中。第一个是 `news.jsx`。为此，添加以下代码：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We''ll initialize the state by setting `_activePost` to `-1`. This will prevent
    the component from showing the body of any post before the user has had time to
    click on any post. Refer to the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将 `_activePost` 设置为 `-1` 来初始化状态。这将防止在用户有时间点击任何帖子之前，组件显示任何帖子的正文。参考以下内容：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is our callback handler in `posts.jsx`. When the user clicks on a news
    headline, a new state will be set with the ID of the news item, let''s take a
    look at the following code snippet:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `posts.jsx` 中的回调处理函数。当用户点击新闻标题时，将设置一个新的状态，包含新闻项的 ID，让我们看看下面的代码片段：
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `Posts` component will be given a set of posts, an active post, and an
    `onClick` handler. The `onClick` handler needs to have the `App` context bound
    or else it will not be able to use internal methods, such as `setState`. If we
    don''t bind it, `setState` will apply to the context of the `Posts` component
    instead, let''s take a look at the following code snippet:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`Posts` 组件将获得一组帖子、一个活动帖子和一个 `onClick` 处理器。`onClick` 处理器需要绑定 `App` 上下文，否则它将无法使用内部方法，例如
    `setState`。如果我们不绑定它，`setState` 将应用于 `Posts` 组件的上下文，让我们看看下面的代码片段：'
- en: '[PRE45]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We''ll use `propTypes` so that the React devtools can let us know if any of
    the incoming props are missing or have the wrong type:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`propTypes`，这样React开发者工具就可以告诉我们是否有任何传入的props缺失或类型错误：
- en: '[PRE46]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We export the app state so that it''s available for components importing the
    current one:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导出应用状态，以便当前导入的组件可以使用：
- en: '[PRE47]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The second file we add to `views` is `posts.jsx`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到`views`的第二个文件是`posts.jsx`：
- en: '[PRE48]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The RSS bodies come with their own HTML. We must explicitly allow this HTML
    to be rendered or else ReactJS will escape the content. When the user clicks on
    a headline, the callback executes `handleClickCallback` in `posts.jsx`. It will
    set a new state in `news.jsx`, and this state will be passed to `posts.jsx` as
    a prop, signaling that the body of this headline should be displayed, let''s take
    a look at the following code snippet:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: RSS正文自带HTML。我们必须明确允许渲染此HTML，否则ReactJS将转义内容。当用户点击标题时，`posts.jsx`中的回调将执行`handleClickCallback`。它将在`news.jsx`中设置一个新的状态，并将此状态作为prop传递给`posts.jsx`，表示应该显示此标题的内容，让我们看看以下代码片段：
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We''ll also need to add a link to the news items in our `app.jsx` file. Open
    the file and add this line:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`app.jsx`文件中添加新闻项目的链接。打开文件并添加以下行：
- en: '[PRE50]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'With these changes, you''re ready to run your app. Start it with `npm run dev`.
    You should be able to go to the front page on `http://localhost:8080` and click
    on the news link. It should display **Loading** until the content is fetched from
    the server. Here''s a screenshot illustrating this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，您就可以运行您的应用了。使用`npm run dev`启动它。您应该能够访问`http://localhost:8080`上的首页，并点击新闻链接。它应该显示**加载中**，直到从服务器获取内容。以下是一个说明这一点的截图：
- en: '![Adding files](img/B04943_09_03.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![添加文件](img/B04943_09_03.jpg)'
- en: The screenshot shows that the news data is loaded and displayed even though
    JavaScript is blocked in the browser.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 截图显示，即使在浏览器中阻止了JavaScript，新闻数据也被加载并显示。
- en: Adding server rendering
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加服务器端渲染
- en: We're very close now, but we still have a little bit of work to do before we're
    done. We need to add data fetching to our Express server. Let's open up `server-production.es6`
    and add the code necessary to prefetch data.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经很接近了，但在完成之前我们还需要做一些工作。我们需要在我们的Express服务器中添加数据获取。让我们打开`server-production.es6`并添加必要的代码以预取数据。
- en: 'Add these imports somewhere at the top of the file:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部添加以下导入：
- en: '[PRE51]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, replace `const approutes` with this code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`const approutes`替换为以下代码：
- en: '[PRE52]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here, we start the `fetchPostsAsync` function. When we receive a result, we
    create an initial state with the news items and then create a new Redux store
    instance with this state, let''s take a look at the following code snippet:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们启动了`fetchPostsAsync`函数。当我们收到结果时，我们使用新闻项目创建一个初始状态，然后使用这个状态创建一个新的Redux存储实例，让我们看看以下代码片段：
- en: '[PRE53]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We add the initial state to the global window so that we can pick it up in
    `client/index.jsx`, let''s take a look at the remaining code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将初始状态添加到全局window中，这样我们就可以在`client/index.jsx`中获取它，让我们看看剩余的代码：
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: That's all you need to prefetch the data. You should now be able to execute
    `npm start` and then open `http://localhost:8080`. Try turning off JavaScript
    in your browser, and you should still be able to navigate and see the items in
    the news list.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 预取数据所需的所有内容就是这些。现在您应该能够执行`npm start`，然后打开`http://localhost:8080`。尝试在浏览器中关闭JavaScript，您仍然可以导航并查看新闻列表中的项目。
- en: You can also create a new Heroku instance, run `npm deploy`, and then push it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建一个新的Heroku实例，运行`npm deploy`，然后推送它。
- en: Note
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can view a demo online at [https://reactjsblueprints-shared.herokuapp.com](https://reactjsblueprints-shared.herokuapp.com).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在网上查看一个演示[https://reactjsblueprints-shared.herokuapp.com](https://reactjsblueprints-shared.herokuapp.com)。
- en: Performing faster cloud deployment
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行更快的云部署
- en: When you push to Heroku now, what will happen is that Heroku will execute `npm
    start`, kicking off the entire build process. This is problematic because if the
    build process is too time consuming or demands too much of resources, it will
    fail.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当您现在推送到Heroku时，会发生的情况是Heroku将执行`npm start`，启动整个构建过程。这是有问题的，因为如果构建过程耗时过长或资源需求过高，它将失败。
- en: 'You can prevent this by committing the `build` folder to your repository and
    then simply execute `node server-production.js` on push. You can do this by adding
    a special start up file called `Procfile` to the repository. Create this file
    in the root of your project and add this line:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将`build`文件夹提交到您的仓库，然后在推送时简单地执行`node server-production.js`来防止这种情况。您可以通过向仓库添加一个特殊的启动文件`Procfile`来实现这一点。在项目根目录中创建此文件，并添加以下行：
- en: '[PRE55]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this file is specific to Heroku. Other cloud providers may have a
    different system in place to specify the start up procedure.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个文件是针对Heroku的。其他云服务提供商可能有一个不同的系统来指定启动程序。
- en: The final structure
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终结构
- en: 'This is how our final app structure looks like (excluding the `build` folder,
    which is essentially the same as the `source` folder):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的最终应用程序结构看起来像什么（不包括`build`文件夹，它基本上与`source`文件夹相同）：
- en: '[PRE56]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The server structure remains more or less the same, and the `source` folder
    is the only one that is growing. This is how it should be.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器结构基本上保持不变，`source`文件夹是唯一一个不断增长的文件夹。这正是它应该的样子。
- en: It's worth looking at the structure as you develop your apps. It provides a
    bird's eye view that can help you spot inconsistencies in naming and other structural
    issues. For instance, does the component `layout.jsx` really belong in views?
    How about `posts.jsx`? It's a view component, but it can be argued that it's a
    helper to `news.jsx` and may possibly belong somewhere else.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，值得查看结构。它提供了一个宏观视角，可以帮助你发现命名和其他结构问题的不一致性。例如，组件`layout.jsx`真的属于视图吗？`posts.jsx`又如何？它是一个视图组件，但可以争论说它是`news.jsx`的辅助工具，可能属于其他地方。
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we modified our Webpack scaffold to enable cloud deployment.
    In the second part of the chapter, we added server rendering, and in the third
    part, we added Redux and the prefetching of data asynchronously.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们修改了我们的Webpack脚手架以启用云部署。在章节的第二部分，我们添加了服务器渲染，在第三部分，我们添加了Redux和数据的异步预取。
- en: With these three projects, you should be able to produce any kind of app, be
    they small or large. However, as you may have noticed, writing an app that supports
    server rendering requires a fair amount of thought and organization. As the application
    increases in size, it becomes even more difficult to reason out the organization
    and data-fetching strategies. You'll be able to make really efficient apps with
    this strategy, but I'd advise you to spend time thinking through how you structure
    your application.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这三个项目，你应该能够制作出任何类型的应用程序，无论大小。然而，正如你可能已经注意到的，编写支持服务器渲染的应用程序需要相当多的思考和规划。随着应用程序规模的增加，推理组织和数据获取策略变得更加困难。你将能够使用这种策略制作出非常高效的应用程序，但我建议你花时间思考如何构建你的应用程序。
- en: The demos for this chapter are available at [https://reactjsblueprints-srvdeploy.herokuapp.com/](https://reactjsblueprints-srvdeploy.herokuapp.com/)
    and [https://reactjsblueprints-shared.herokuapp.com](https://reactjsblueprints-shared.herokuapp.com).
    The first link showcases the app as it is when server rendering is added. The
    second shows the final app where we fetch data on the server side and populate
    a Redux store before rendering the app to the user.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的演示可在[https://reactjsblueprints-srvdeploy.herokuapp.com/](https://reactjsblueprints-srvdeploy.herokuapp.com/)和[https://reactjsblueprints-shared.herokuapp.com](https://reactjsblueprints-shared.herokuapp.com)找到。第一个链接展示了添加服务器渲染后的应用程序状态。第二个链接展示了最终的应用程序，我们在服务器端获取数据并在向用户渲染应用程序之前填充Redux存储。
- en: In the next chapter, we'll create a game with ReactJS. We'll use the HTML5 canvas
    technology and add Flowtype for static type checking.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用ReactJS创建一个游戏。我们将使用HTML5 canvas技术，并添加Flowtype进行静态类型检查。
