- en: Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maintaining and controlling state in an app is something that quickly becomes
    complicated as soon as our app is larger than a Todo app, especially if we have
    multiple views, models, and dependencies between them. The situation is complicated
    by multiple types of states, such as cached data, server responses, and data that
    only lives locally when you work with the app. Changing the state is made more
    complicated because multiple actors, synchronous, and asynchronous code can change
    the state. The end result with a growing app is, sooner or later, a non-deterministic
    system. The problem with such a system is that you lose predictability, which
    in turn means you may have bugs that are hard to produce, and it makes the app
    and its data hard to reason with. We crave order and predictability, but we get
    neither.
  prefs: []
  type: TYPE_NORMAL
- en: To try to address the problem, we covered the Flux pattern in a previous chapter.
    All is well and good, right? We don't need another pattern. Or do we? Well, Flux
    has problems. One of the problems is that your data is divided up into several
    stores. Why is that a problem, you wonder? Imagine you have an action that triggers
    in multiple stores. It's easy to forget to handle an action in all stores. So,
    that issue is more of a management problem. Another problem with multiple stores
    is that it's hard to get a good overview of what your state consists of. Updates
    are another problem we have with Flux. Sometimes you have a lot of updates; updating
    the state and the order matters. In Flux, this is handled with a construct called
    `waitFor`. The idea is that you should be able to specify what should happen in
    which order. That's all well and good, but imagine that this is spread out over
    many modules; it becomes hard to keep track of and is thereby error prone.
  prefs: []
  type: TYPE_NORMAL
- en: Mutation and asynchronous behavior are two concepts that are hard to deal with.
    Mutation means we change the data. Asynchronous means something takes time to
    complete; when it does it may mutate a state. Imagine mixing synchronous and asynchronous
    operations that all update state. We realize it's not easy to keep track of the
    code because of this, and mixing that in with state mutation makes it all the
    more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: This leads us to what Redux can do for us, which is to make our mutations predictable,
    but it also gives us one store, one single source of truth.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: The core concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How data flows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to put your skills into practice by building your own mini implementation
    of Redux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to deal with AJAX in the context of Redux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some sound best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Redux rests on three principles:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Single source of truth: We have one place where all our data lives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'State is read-only: No mutation; there is only one way to change state and
    that is through an action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changes are made with pure functions: A new state is produced by taking the
    old state, applying the change, and producing the new state; the old state is
    never changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's explore these bullet points one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Single source of truth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The data lives in a single store in Redux and not a multiple store like in
    Flux. The data is represented by one object tree. This brings about a lot of benefits,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: It is easier to see what your application knows at any given point, so it is
    easy to serialize or deserialize it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easier to work with in development, and easier to debug and inspect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It easier to do things such as undo/redo if all applied actions produce a new
    state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of a single store can look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is just an object.
  prefs: []
  type: TYPE_NORMAL
- en: Read-only states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to ensure we only have one way to alter state, and that is through
    mediators called actions. An action should describe the intent of the action as
    well as the data that should be applied to the current state. An action is dispatched
    by us using a `store.dispatch(action)`. The action itself should look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, let''s try to implement what a store might actually look like
    and what it initially contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that it is an object that consists of two properties, `jedis`, which
    is an array, and `selectedJedi`, which is an object holding an object that we
    select. At this point, we want to dispatch an action, which means we will take
    our old state, as shown in the preceding code, and produce a new state. The action
    we described earlier should change the `jedis` array and replace the empty array
    with the incoming array. Remember, though, we don''t mutate the existing store
    object; we simply take it, apply our change, and produce a new object. Let''s
    dispatch our action and see the end result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is pseudo code as it doesn't actually produce the intended
    result, yet. We will learn to implement a store in later chapters. OK, so now
    our state has changed and our incoming array has replaced the empty array we used
    to have. We again repeat that we have not mutated the existing state, but instead
    produced a new state given the old state and our action. Let's look at the next
    section on *pure functions* and further explain what we mean.
  prefs: []
  type: TYPE_NORMAL
- en: Changing states with pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we introduced the concept of the action and how that
    was the mediator through which we were allowed to change our state. We didn''t
    change the state, though, in the normal sense of the word, but rather took the
    old state, applied the action, and produced a new state. To accomplish this, we
    need to use a pure function. In the context of Redux those are called reducers.
    Let''s write ourselves a `reducer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We highlight the pure aspect of the preceding `reducer`. It takes our `selectedJedi`
    from the `action.payload`, it copies it using the `Object.assign()`, assigns it,
    and returns the new state.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we have written is a `reducer` that switches, depending on the action
    we try to perform, and carries out the change. Let''s put this pure function into
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Core concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In React, we are dealing with three core concepts, which we have already introduced
    the state, the action, and the reducer. Now, let's dive in deeper and really get
    a sense of how they fit together and how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The whole point of the state is to take an existing state, apply an action
    to it, and produce a new state. It can be written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine, if you were performing basic calculations, then you would start writing
    it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The Redux way of doing things, though, is to change the preceding to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We don't mutate anything but rather produce a new state for everything we do.
    Let's look at different constructs and what it means in practice to not mutate.
  prefs: []
  type: TYPE_NORMAL
- en: Changing a list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two operations we can perform on a list:'
  prefs: []
  type: TYPE_NORMAL
- en: Add item(s) to a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove item(s) from a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take the first bullet point and make this change in the old way and
    then make the Redux way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code takes the old list and its items and creates a new list containing
    the old list plus our new member.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our next bullet, to remove an item, we do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we produce a list not containing our item.
  prefs: []
  type: TYPE_NORMAL
- en: Changing an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Changing an object is about changing properties on it as well as adding properties
    to it. First off, let''s look at how to change existing values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'That covers the existing case. What about adding a new property? We can do
    that like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Using reducers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we covered how to change state in the old way and
    how to do it in the new Redux-like way. The reducers are nothing more than pure
    functions; pure in the sense that they don''t mutate but produce a new state.
    A reducer needs an action to work though. Let''s deepen our knowledge on Reducers
    and Actions. Let''s create an action meant to add things to a list and a reducer
    that goes with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, so know we know how to deal with lists; what about objects? We again need
    to define an action and a reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: What we see here is how one object completely replaces the content of another
    object by invoking `SELECT_JEDI`. We also see how we use `Object.assign()` to
    ensure we only copy over the values from the incoming object.
  prefs: []
  type: TYPE_NORMAL
- en: Merging all reducers together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OK, so we now have a reducer for handling our list of `jedis` as well as a
    reducer dedicated to handling selections of a specific `jedis`. We mentioned before
    that, in Redux, we have a single store where all our data lives. Now it''s time
    to create that single store. This can be easily accomplished by creating the following
    function `store()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: From what we can see here, our `store()` function does nothing more than return
    an object. The returned object is our current state. What we choose to call the
    properties of the state object is what we want to refer to when displaying the
    content of the store. If we want to change the state of our store, we need to
    invoke the `store()` function anew and provide it with an action that represents
    the intent of our change.
  prefs: []
  type: TYPE_NORMAL
- en: Data flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OK, so we know about actions, reducers, and manipulating the state in a pure
    way. What about putting all this in practice in a real application? How would
    we do that? Let''s try to model the data flow of our application. Imagine that
    we have a view that handles adding an item to a list and a view that handles showing
    the list. Then, our data flow could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7ea7fcf-2e7a-4661-b129-b18afa23b745.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the case of the create item view, we enter the data we need to create an
    item and then we dispatch an action, create-item, which ends up adding the item
    to the store. In our other data flow, we simply have a list view that selects
    the items from the store, which leads to the list view being populated. We realize
    that in a real application there may be the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: User interaction
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creation of an action that represents our intent
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dispatching an action, which leads to our state changing its state
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding steps are true for our create item view. For our list view, we
    simply want to read from a store and display the data. Let's try to make this
    more tangible and turn at least the Redux part into actual code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by creating an action creator, a helper function that helps us
    create actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Creating a controller class – create-view.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now imagine that we are inside the code of the view that handles creating items;
    it may look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, so, in our `create-view.js` file we create a `CreateItemView` class that
    has a method `saveItem()` method on it. The `saveItem()` method is the first responder
    to a button click on a button with the ID `saveButton`. When the button is clicked,
    our `saveItem()` method is invoked, which ends up calling our dispatch function
    with the `createItem()` action method, which in turn is using the input elements
    value as input, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Creating a store implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have yet to create the `dispatch()` method, so we will do that next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'What we can see from the preceding code is that we have a `dispatch()` function,
    which is one of the things we export from this file. Let''s try to fill in the
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Let's explain what we did there from the top. We first define a reducer 1) called
    `itemsReducer`, which can produce a new state given a new item. Thereafter, we
    create a state variable, which is our state 2). This is followed by the `store()`
    function 3), which is a function to set up which property goes together with which
    reducer. Thereafter, we define a function called `getState()` 4), which returns
    our current state. Lastly, we have our `dispatch()` function 5), which just invokes
    the `store()` function with the action we provide it.
  prefs: []
  type: TYPE_NORMAL
- en: Testing out our store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now it is time to put our code to use; first, we will create a `redux-demo.js`
    file to test out our Redux implementation, then we will polish it a bit, and lastly
    we will use it in the view we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Cleaning up the implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OK, so our Redux implementation seems to be working. It''s time to clean it
    up a bit. We need to move the reducer out into its own file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s also a good idea to add a `select()` function to the store as we sometimes
    don''t want to move a full state back, only part of it. Our list view will benefit
    from the use of the `select()` function. Let''s add that next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Creating our second controller class – list-view.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now shift our focus to our `list-view.js` file that we are yet to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: OK, so we utilize the `select()` method and get a slice of state from our state
    from the `redux.js` file we created. Thereafter, we render the response. As long
    as these views are on different pages, we will always get the latest version of
    `items` arrays from our state. However, if these views are visible at the same
    time, then we have a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Adding subscription capability to our store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Somehow, the list view needs to listen to changes in the store so that it can
    rerender when a change happens. A way to do that is, of course, to set up some
    kind of listener that triggers an event when a change happens. If we, as a view,
    subscribe to such changes, then we can act accordingly and rerender our view.
    There are different ways of accomplishing this: we can either just implement an
    Observable pattern or use a library, such as `EventEmitter`. Let''s update our
    `redux.js` file to make it so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Creating a program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have created a bunch of files, namely, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`redux.js`: Our store implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create-view.js`: A controller that listens to inputs and button presses. The
    controller will read the input on a button press and dispatch the input''s value
    so it is saved in the store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list-view.js`: Our second controller, responsible for showing the content
    of the store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`todo-app.js`: The starter file that creates our entire application (we have
    yet to create this).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index.html`: The UI for our application (we are yet to create this).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up our environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Maybe you have noticed that we are using import statements used for ES6 modules?
    There are many ways to make that work, but we choose a modern option, namely,
    utilizing webpack. We will need to do the following to set up webpack successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the npm libraries `webpack` and `webpack-cli`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `webpack.config.js` file and specify the entry point of your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an entry to the `package.json` file so that we can build and run our app
    with a simple `npm start`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a HTTP server so that we can show the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can install the needed libraries by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Thereafter, we need to create our `config` file, `webpack.config.js`, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are stating that the entry point should be `todo-app.js`
    and also that the output file should be called `bundle.js`. We also ensure our
    bundle will be rebuilt by setting `watch` to `true`. Let''s add the needed entry
    to `package.json` by adding the following to the `script` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are defining a start command that invokes webpack with the flag `-d`,
    which means it will generate source maps, making for a nice debug experience.
  prefs: []
  type: TYPE_NORMAL
- en: For our last setup step, we need a HTTP server so that we can display our app.
    Webpack itself has one called, `webpack-dev-server`, or we could use `http-server`,
    which is an NPM package. This is a pretty simple application so either will do
    fine.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the missing files and running our program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our application needs a UI so let''s create that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: So, here we have an input element and a button that we can press to save a new
    item. This is followed by a list, where our content will be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the `todo-app.js` next. It should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are requiring in the two controllers so we can collect input as well
    as displaying store content. Let''s try out our application by typing `npm start`
    in the Terminal window. This will create the `bundle.js` file in a dist folder.
    To display the app, we need to fire up another terminal window and place ourselves
    in the `dist` folder. Your dist folder should consist of the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bundle.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we are ready to launch the app by typing `http-server -p 5000`. You will
    be able to find your app at `http:localhost:5000` in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4fc348d-1562-40ad-af1f-1438a75d88f7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We see our expected application with an input element and a button, and we
    see our console to the right showing us that both our controllers were loaded.
    Additionally, we see the content of the items property of our store object, which
    points to an empty array. This is expected as we haven''t added any items to it
    yet. Let''s add an item to our store by adding a value to our input element and
    pressing the Save button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a880068f-935e-4247-b91b-bece6c20b24a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the right, we can see that our store now contains an item but our UI is
    not updated. The reason for that is that we don''t actually subscribe to changes.
    We can change that by adding the following piece of code to our list-view.js controller
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our app renders as it should and should look something like this, providing
    that you added a few items:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5dd99207-9a3c-473f-989b-5a3b6886eb2f.png)'
  prefs: []
  type: TYPE_IMG
- en: Dealing with asynchronous calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dispatching actions is always done synchronously. Data is fetched through AJAX
    asynchronously, so how do we get asynchronous to play well with Redux?
  prefs: []
  type: TYPE_NORMAL
- en: 'You should define your Redux states in the following way when setting up an
    asynchronous call:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading: Here, we have the chance to show a spinner, not render part of the
    UI, or convey to the user in some other way that the UI is waiting for something'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data successfully fetched: You should set a state for the fetched data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Error happened: You should record the error somehow so that you are able to
    tell the user that an error occurred'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You, by convention, use the word fetch to indicate that you are fetching data.
    Let''s look at an example of what that might look like. First off, let''s start
    by defining the steps we need to take:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a reducer. This should have the ability to set different states depending
    on whether we are waiting for the response, got the response, or an error happened.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create actions. We need a file of actions that supports our states mentioned
    earlier; creating this is more about convenience.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update our `redux.js` file to use our new reducer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test our creation out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s say we are fetching a book from an API. We should have a reducer that
    looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have covered the reducer bit, let''s move on to the creation of
    actions. It will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to turn to our `store` file and update it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Creating a demo with Redux and asynchronous
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now the time has come to test everything out. What we are interested in here
    is ensuring that our store state behaves the way we want it to. We want the store
    to reflect the fact that we are loading the data, receiving the data, and if there
    is an error, that should be reflected as well. Let''s start out by mimicking an
    AJAX call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As our next order of business, let''s set up some logging for the state and
    dispatch our first action, `fetchBookLoading`, which indicates that an AJAX request
    is underway. This is where, ideally, we would want to reflect this state in the
    UI and show a spinner or similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is about a call to our `fetchBook()` method and setting the store
    state appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We have so far described our demo in pieces from top to bottom. The full code
    should read like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there is really not much to dealing with asynchronous, you just
    need to dispatch the suitable state once the asynchronous action has run its course.
    There are libraries for dealing with asynchronous though. If you are a React user
    it might be worth looking into Sagas and if Angular is your flavor, then NgRx
    and effects is your go-to. The reason for separate libraries existing for this
    is to say that asynchronous interactions, especially AJAX ones, are considered
    side-effects and as such they are outside the *normal* flow. Ultimately, it's
    up to you if you feel you need such a library.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have gone through a lot. We have covered principles, core concepts,
    and even got to build our own Redux implementation. We should be mighty proud
    of ourselves at this point. There is something we have yet to cover, though, and
    that is how we use Redux in an optimal way. There are some key rules we can follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Organize your file system optimally. You should not have a few files when building
    an app but rather many, and usually organized by feature. This leads to the following
    file setup for a feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reducer**: We should have one file, per reducer, for this'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actions**: We should have a file describing all the actions we could possibly
    dispatch'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View/component file**: This has nothing to do with Redux but, regardless
    of the framework we go with, we usually have a file describing the component we
    are trying to build'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is another aspect that is worth doing as well, and that is optimizing
    the setup process of our store. The store normally needs to be initialized with
    a number of reducers. We could write some code that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing wrong with the setup here, but it you have many features,
    and a reducer in each, you will end up with a lot of imports, and your call to
    `combineReducers()` will be longer and longer. An approach that will solve that
    is having each reducer register itself with the `rootReducer`. This way, we can
    switch the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It will be switched with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This forces us to create a new `root-reducer.js` file, which will look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We have highlighted the important part here, the `registerReducer()` method,
    which a reducer can now use to register itself with the `rootReducer`. At this
    point, it''s worth going back to our reducer and updating it to use the `registerReducer()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has been a wild ride, going from describing principles to core
    concepts, to being able to understand and even build our own Redux. Time was spent
    looking at how to deal with AJAX calls and suitable state patterns for that. We
    learned that there was really nothing much to it. We finished off the chapter
    by looking at best practices as well. At this point, we are in a considerably
    better position to be able to understand and appreciate NgRx because we know its
    underlying patterns and reasons for existing. We can say farewell to this chapter
    knowing that we will take on NgRx in the last chapter of the book. The aim is
    to cover the principles and concepts that govern it, how to use it in practice,
    and also to cover some necessary tooling that will ensure we become really successful.
  prefs: []
  type: TYPE_NORMAL
