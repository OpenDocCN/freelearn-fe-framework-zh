<html><head></head><body>
<div id="_idContainer054">
<h1 class="chapter-number" id="_idParaDest-183"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.1.1">12</span></h1>
<h1 id="_idParaDest-184"><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.2.1">Caching Strategies</span></h1>
<p><span class="koboSpan" id="kobo.3.1">“</span><em class="italic"><span class="koboSpan" id="kobo.4.1">There are only two hard things in computer science: cache invalidation and naming things.</span></em><span class="koboSpan" id="kobo.5.1">” – </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">Phil Karlton</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Caching can </span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.8.1">significantly enhance a website’s performance by eliminating or shortening network roundtrips and reusing previously stored data and content. </span><span class="koboSpan" id="kobo.8.2">However, caching is also hard to get right. </span><span class="koboSpan" id="kobo.8.3">As usual, Remix provides a thin abstraction layer on top of the web platform and eases the usage of HTTP </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">caching strategies.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">In this chapter, we will learn about different caching strategies and how to utilize them with Remix. </span><span class="koboSpan" id="kobo.10.2">This chapter is divided into </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">two sections:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.12.1">Working with </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">HTTP caching</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Exploring </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">in-memory caching</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.16.1">First, we will learn about HTTP caching. </span><span class="koboSpan" id="kobo.16.2">We will study different HTTP caching headers and see how we can utilize HTTP caching in the browser and with CDNs. </span><span class="koboSpan" id="kobo.16.3">Next, we will focus on in-memory caching. </span><span class="koboSpan" id="kobo.16.4">We will refer to </span><a href="B17399_03.xhtml#_idTextAnchor043"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.17.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.18.1">, </span><em class="italic"><span class="koboSpan" id="kobo.19.1">Deployment Targets, Adapters, and Stacks</span></em><span class="koboSpan" id="kobo.20.1">, to understand when and where we can cache data in memory. </span><span class="koboSpan" id="kobo.20.2">We will also discuss using services such as Redis to </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">cache data.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">After reading this chapter, you will understand how to utilize caching with Remix to improve the user experience. </span><span class="koboSpan" id="kobo.22.2">You will have also practiced working with HTTP headers and know when to use different caching strategies, such as CDN, browser, </span><strong class="bold"><span class="koboSpan" id="kobo.23.1">entity tags</span></strong><span class="koboSpan" id="kobo.24.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.25.1">ETags</span></strong><span class="koboSpan" id="kobo.26.1">), and </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">in-memory caching.</span></span></p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.28.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.29.1">You can find the code for this chapter here: </span><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/12-caching-strategies"><span class="koboSpan" id="kobo.30.1">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/12-caching-strategies</span></a><span class="koboSpan" id="kobo.31.1">. </span><span class="koboSpan" id="kobo.31.2">You can go ahead and use the end solution from the previous chapter. </span><span class="koboSpan" id="kobo.31.3">No additional setup steps are required for </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">this chapter.</span></span></p>
<h1 id="_idParaDest-186"><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.33.1">Working with HTTP caching</span></h1>
<p><span class="koboSpan" id="kobo.34.1">The</span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.35.1"> web platform utilizes HTTP headers to control caching behavior. </span><span class="koboSpan" id="kobo.35.2">Web </span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.36.1">clients can read caching directives specified in response headers to reuse previously fetched data. </span><span class="koboSpan" id="kobo.36.2">This allows web clients to avoid unnecessary network requests and improve response times. </span><span class="koboSpan" id="kobo.36.3">In this section, you will learn about popular HTTP caching headers and strategies and how to use them in Remix. </span><span class="koboSpan" id="kobo.36.4">First, we will see how we can define HTTP headers for </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">document responses.</span></span></p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.38.1">Adding HTTP headers in Remix</span></h2>
<p><span class="koboSpan" id="kobo.39.1">Remix’s</span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.40.1"> route module API includes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">headers</span></strong><span class="koboSpan" id="kobo.42.1"> export that we can use to add HTTP headers to the route’s document response. </span><span class="koboSpan" id="kobo.42.2">Like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">links</span></strong><span class="koboSpan" id="kobo.44.1"> function, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">headers</span></strong><span class="koboSpan" id="kobo.46.1"> function is only ever executed on </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">the server.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">headers</span></strong><span class="koboSpan" id="kobo.50.1"> function is called after all </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">loader</span></strong><span class="koboSpan" id="kobo.52.1"> functions and all parent </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">headers</span></strong><span class="koboSpan" id="kobo.54.1"> functions. </span><span class="koboSpan" id="kobo.54.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">headers</span></strong><span class="koboSpan" id="kobo.56.1"> function has access to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">parentsHeaders</span></strong><span class="koboSpan" id="kobo.58.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">errorHeaders</span></strong><span class="koboSpan" id="kobo.60.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">actionHeaders</span></strong><span class="koboSpan" id="kobo.62.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">loaderHeaders</span></strong><span class="koboSpan" id="kobo.64.1"> objects to update document headers based on the headers added via parent </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">header</span></strong><span class="koboSpan" id="kobo.66.1"> functions, loader data responses, action data responses, and error responses. </span><span class="koboSpan" id="kobo.66.2">Remix utilizes the most deeply exported </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">headers</span></strong><span class="koboSpan" id="kobo.68.1"> function available and allows you to mix and merge the headers </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">as required.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.70.1">Loader data-based cache control</span></p>
<p class="callout"><span class="koboSpan" id="kobo.71.1">Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">headers</span></strong><span class="koboSpan" id="kobo.73.1"> function receives the </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">loaderHeaders</span></strong><span class="koboSpan" id="kobo.75.1"> parameter, which allows us to specify caching directives for each route based on the loader data for fine-grained </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">cache control.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">Now that we have a theoretical understanding of how to apply HTTP headers with Remix, let’s run through our BeeRich routes to investigate how to </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">utilize caching.</span></span></p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.79.1">Caching public pages in shared caches</span></h2>
<p><span class="koboSpan" id="kobo.80.1">Public pages</span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.81.1"> without user-specific information can be stored in a shared cache such as a CDN. </span><span class="koboSpan" id="kobo.81.2">Adding a CDN in front of your (Remix) web server distributes cached content globally and closer to your users. </span><span class="koboSpan" id="kobo.81.3">It reduces the request response time for cached content and the number of requests the web server has </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">to process.</span></span></p>
<p><span class="koboSpan" id="kobo.83.1">If you aren’t sure what a CDN is, the MDN Web Docs provide a great </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">introduction: </span></span><a href="https://developer.mozilla.org/en-US/docs/Glossary/CDN"><span class="No-Break"><span class="koboSpan" id="kobo.85.1">https://developer.mozilla.org/en-US/docs/Glossary/CDN</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.86.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.87.1">In this section, we will use Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">headers</span></strong><span class="koboSpan" id="kobo.89.1"> route module API to add HTTP caching headers to our public pages </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">on BeeRich.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">BeeRich </span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.92.1">consists of public and private routes. </span><span class="koboSpan" id="kobo.92.2">The public pages are nested inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">_layout</span></strong><span class="koboSpan" id="kobo.94.1"> segment and include the BeeRich home page (</span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">_layout._index.tsx</span></strong><span class="koboSpan" id="kobo.96.1">) and the login and signup pages. </span><span class="koboSpan" id="kobo.96.2">We can identify that these pages are static and do not depend on user-specific data. </span><span class="koboSpan" id="kobo.96.3">We’re okay if the user occasionally sees a stale page version. </span><span class="koboSpan" id="kobo.96.4">We can specify HTTP headers so that we keep serving a cached version of the page for one hour before requesting a </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">new version.</span></span></p>
<p><span class="koboSpan" id="kobo.98.1">Let’s see what this would look like in action. </span><span class="koboSpan" id="kobo.98.2">Add the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">headers</span></strong><span class="koboSpan" id="kobo.100.1"> function export to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">_layout.tsx</span></strong><span class="koboSpan" id="kobo.102.1"> pathless layout </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">route module:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.104.1">
import type { HeadersFunction } from '@remix-run/node';export const headers: HeadersFunction = () =&gt; {
  return {
    </span><strong class="bold"><span class="koboSpan" id="kobo.105.1">'Cache-Control': 'public, max-age=3600'</span></strong><span class="koboSpan" id="kobo.106.1">,
  };
};</span></pre>
<p><span class="koboSpan" id="kobo.107.1">With these changes, we apply a caching header to all child routes that do not themselves export a </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">headers</span></strong><span class="koboSpan" id="kobo.109.1"> function. </span><span class="koboSpan" id="kobo.109.2">The specified caching header includes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">public</span></strong><span class="koboSpan" id="kobo.111.1"> value and a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">max-age</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.113.1"> directive.</span></span></p>
<p><span class="koboSpan" id="kobo.114.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">max-age</span></strong><span class="koboSpan" id="kobo.116.1"> directive defines the number of seconds the available response can be reused before it must be regenerated. </span><span class="koboSpan" id="kobo.116.2">This means the nested routes, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">/</span></strong><span class="koboSpan" id="kobo.118.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">/login</span></strong><span class="koboSpan" id="kobo.120.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">/signup</span></strong><span class="koboSpan" id="kobo.122.1">, are now cached for 3,600 seconds (</span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">1 hour).</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">public</span></strong><span class="koboSpan" id="kobo.126.1"> value communicates that the response data can be stored in a public cache. </span><span class="koboSpan" id="kobo.126.2">We can differentiate between public (shared) and private caches. </span><span class="koboSpan" id="kobo.126.3">Private caches exist on web clients (for example, browsers), while shared caches live on proxy services and CDNs. </span><span class="koboSpan" id="kobo.126.4">By</span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.127.1"> specifying that a document can be cached publicly, we also allow proxies and CDNs to cache the document for all future requests. </span><span class="koboSpan" id="kobo.127.2">This means the cache not only serves one browser (user) but may improve the response times for any subsequent </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">user requests.</span></span></p>
<p><span class="koboSpan" id="kobo.129.1">Let’s investigate this </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">caching behavior:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.131.1">Run </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">npm run dev</span></strong><span class="koboSpan" id="kobo.133.1"> in the root of </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">the project.</span></span></li>
<li><span class="koboSpan" id="kobo.135.1">Next, open the login page in a new browser </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">window (</span></span><a href="http://localhost:3000"><span class="No-Break"><span class="koboSpan" id="kobo.137.1">http://localhost:3000</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.138.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.139.1">Open the developer tools of your browser and navigate to the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.140.1">Network</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.141.1"> tab.</span></span></li>
<li><span class="koboSpan" id="kobo.142.1">Make sure you uncheck the </span><strong class="bold"><span class="koboSpan" id="kobo.143.1">Disable cache</span></strong><span class="koboSpan" id="kobo.144.1"> option if </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">it’s checked.</span></span></li>
<li><span class="koboSpan" id="kobo.146.1">Now, hard-refresh the page to emulate an initial </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">page load:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer050">
<span class="koboSpan" id="kobo.148.1"><img alt="Figure 12.1 – Initial page load of the login page" src="image/Figure_12.01_B17399.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.149.1">Figure 12.1 – Initial page load of the login page</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.150.1">Notice that the specified caching header is returned as part of the </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">response headers.</span></span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.152.1">Refresh the</span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.153.1"> page again; you may see that the document was restored from the disk cache. </span><span class="koboSpan" id="kobo.153.2">Some browsers disable document request caching headers on localhost for a better developer experience. </span><span class="koboSpan" id="kobo.153.3">So, don’t worry if you can’t seem to make it work </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">on localhost.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.155.1">Be cautious not to publicly cache documents with user-specific information. </span><span class="koboSpan" id="kobo.155.2">While CDNs often automatically remove </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">Set-Cookie</span></strong><span class="koboSpan" id="kobo.157.1"> headers, you likely want to avoid caching altogether when a user session cookie is in the server's response. </span><span class="koboSpan" id="kobo.157.2">If you're using a CDN, make sure to cache only for visitors, not logged-in users, to avoid caching conditionally rendered UIs for logged-in users. </span><span class="koboSpan" id="kobo.157.3">For example, the navigation bar in </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">_layout.tsx</span></strong><span class="koboSpan" id="kobo.159.1"> shows a Logout button if a user is logged in. </span><span class="koboSpan" id="kobo.159.2">Caching this could cause layout shifts when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">Logout</span></strong><span class="koboSpan" id="kobo.161.1"> button is replaced by </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">Log in</span></strong><span class="koboSpan" id="kobo.163.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">Sign up</span></strong><span class="koboSpan" id="kobo.165.1"> after React hydrates on the client and re-renders </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">the page.</span></span></p>
<p><span class="koboSpan" id="kobo.167.1">Let’s investigate how Remix uses HTTP caching headers for the public assets of </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">our pages.</span></span></p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.169.1">Understanding Remix’s built-in caching</span></h2>
<p><span class="koboSpan" id="kobo.170.1">Remix </span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.171.1">optimizes many of the served assets out of the box. </span><span class="koboSpan" id="kobo.171.2">In this section, we will review how Remix utilizes HTTP caching headers on static assets to optimize our </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">app’s performance.</span></span></p>
<p><span class="koboSpan" id="kobo.173.1">Follow the steps from the previous section to open the login page of BeeRich in a browser window. </span><span class="koboSpan" id="kobo.173.2">Click on any downloaded JavaScript bundles in the </span><strong class="bold"><span class="koboSpan" id="kobo.174.1">Network</span></strong><span class="koboSpan" id="kobo.175.1"> tab and review the </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">response headers:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer051">
<span class="koboSpan" id="kobo.177.1"><img alt="Figure 12.2 – Remix’s built-in caching behavior" src="image/Figure_12.02_B17399.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.178.1">Figure 12.2 – Remix’s built-in caching behavior</span></p>
<p><span class="koboSpan" id="kobo.179.1">As </span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.180.1">visible in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.181.1">Figure 12</span></em></span><em class="italic"><span class="koboSpan" id="kobo.182.1">.2</span></em><span class="koboSpan" id="kobo.183.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">manifest-*.js</span></strong><span class="koboSpan" id="kobo.185.1"> file was retrieved from the browser’s memory or disk cache. </span><span class="koboSpan" id="kobo.185.2">Remix adds a cache control header to each JavaScript bundle (</span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">Cache-Control: public, max-age=31536000, immutable</span></strong><span class="koboSpan" id="kobo.187.1">). </span><span class="koboSpan" id="kobo.187.2">Each JavaScript bundle is defined to be publicly cached for up to one year – the maximum possible </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">max-age</span></strong><span class="koboSpan" id="kobo.189.1"> value. </span><span class="koboSpan" id="kobo.189.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">immutable</span></strong><span class="koboSpan" id="kobo.191.1"> directive further indicates that the content of the assets never changes, which helps us avoid potential </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">revalidation requests.</span></span></p>
<p><span class="koboSpan" id="kobo.193.1">Next, review the </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">tailwind.css</span></strong><span class="koboSpan" id="kobo.195.1"> stylesheet from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">root.ts</span></strong><span class="koboSpan" id="kobo.197.1"> file’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">links</span></strong><span class="koboSpan" id="kobo.199.1"> export. </span><span class="koboSpan" id="kobo.199.2">Compare the cache control header of the linked stylesheet and the JavaScript bundles. </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">They match!</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">Finally, review the names of the static assets. </span><span class="koboSpan" id="kobo.201.2">Notice that all JavaScript bundles and linked assets include a hash postfix. </span><span class="koboSpan" id="kobo.201.3">The hash is computed based on the content of the asset. </span><span class="koboSpan" id="kobo.201.4">Any time we update any assets, a new version is created. </span><span class="koboSpan" id="kobo.201.5">The hash ensures that there are never two assets with the same name but different content. </span><span class="koboSpan" id="kobo.201.6">This allows Remix to allow clients to cache each </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">asset indefinitely.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.203.1">Remix’s built-in HTTP caching</span></p>
<p class="callout"><span class="koboSpan" id="kobo.204.1">Hash-based filenames of static assets ensure that new versions automatically result in new assets. </span><span class="koboSpan" id="kobo.204.2">This allows Remix to add aggressive caching directives to all linked assets returned from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">links</span></strong><span class="koboSpan" id="kobo.206.1"> route module API. </span><span class="koboSpan" id="kobo.206.2">Remix adds the same directives to all its </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">JavaScript bundles.</span></span></p>
<p><span class="koboSpan" id="kobo.208.1">The </span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.209.1">aggressive caching directives used by Remix allow browsers and CDNs to cache all static assets of your Remix app. </span><span class="koboSpan" id="kobo.209.2">This can significantly </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">improve performance.</span></span></p>
<p><span class="koboSpan" id="kobo.211.1">Next, we will discuss how to cache personalized pages </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">and content.</span></span></p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.213.1">Caching personalized pages in private caches</span></h2>
<p><span class="koboSpan" id="kobo.214.1">Controlling HTTP caching is </span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.215.1">not only about caching responses but also about controlling when not to cache. </span><span class="koboSpan" id="kobo.215.2">Remix offers full control over what should be cached by providing access to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">Response</span></strong><span class="koboSpan" id="kobo.217.1"> object of each document and </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">data request.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">dashboard</span></strong><span class="koboSpan" id="kobo.221.1"> routes of BeeRich are personalized pages that are made up of user-specific data. </span><span class="koboSpan" id="kobo.221.2">User-specific data must not be stored in a shared cache to avoid leakage of private user information. </span><span class="koboSpan" id="kobo.221.3">The content on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">dashboard</span></strong><span class="koboSpan" id="kobo.223.1"> routes is highly dynamic, and we should only cache it briefly to avoid stale </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">UI states.</span></span></p>
<p><span class="koboSpan" id="kobo.225.1">Let’s utilize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">no-cache</span></strong><span class="koboSpan" id="kobo.227.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">private</span></strong><span class="koboSpan" id="kobo.229.1"> directives on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">dashboard.tsx</span></strong><span class="koboSpan" id="kobo.231.1"> route to apply a default for all </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">dashboard</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.233.1"> routes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.234.1">
import type { </span><strong class="bold"><span class="koboSpan" id="kobo.235.1">HeadersFunction</span></strong><span class="koboSpan" id="kobo.236.1">, LoaderFunctionArgs, MetaFunction, SerializeFrom } from '@remix-run/node';export const headers: HeadersFunction = () =&gt; {
  return {
    </span><strong class="bold"><span class="koboSpan" id="kobo.237.1">'Cache-Control': 'no-cache, private'</span></strong><span class="koboSpan" id="kobo.238.1">,
  };
};</span></pre>
<p><span class="koboSpan" id="kobo.239.1">The</span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.240.1"> added cache control header specifies that the HTML documents on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">dashboard</span></strong><span class="koboSpan" id="kobo.242.1"> routes can only be cached in private caches (for example, the browser) and that any request should go to the server </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">for revalidation.</span></span></p>
<p><span class="koboSpan" id="kobo.244.1">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">no-cache</span></strong><span class="koboSpan" id="kobo.246.1"> directives still allow the browser to reuse content when using the browser's back and forward buttons. </span><span class="koboSpan" id="kobo.246.2">This is different from </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">no-store</span></strong><span class="koboSpan" id="kobo.248.1">, which forces the browser to fetch new content even during back and </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">forward navigation.</span></span></p>
<p><span class="koboSpan" id="kobo.250.1">Great – we've now learned how to apply caching headers to document responses. </span><span class="koboSpan" id="kobo.250.2">But how about </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">loader</span></strong><span class="koboSpan" id="kobo.252.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">action</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.254.1">data responses?</span></span></p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.255.1">Caching immutable data responses</span></h2>
<p><span class="koboSpan" id="kobo.256.1">In Remix, we</span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.257.1"> can also control HTTP headers for data responses from </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">loader</span></strong><span class="koboSpan" id="kobo.259.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">action</span></strong><span class="koboSpan" id="kobo.261.1"> functions. </span><span class="koboSpan" id="kobo.261.2">Thus, we can set caching controls not only for documents but also for </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">data responses.</span></span></p>
<p><span class="koboSpan" id="kobo.263.1">Most of the data in BeeRich is highly dynamic. </span><span class="koboSpan" id="kobo.263.2">The invoice and expense data can be edited and must always be fresh. </span><span class="koboSpan" id="kobo.263.3">However, this is different for the expense and invoice attachments. </span><span class="koboSpan" id="kobo.263.4">Each attachment has a unique filename (identifier), which is part of the request URL. </span><span class="koboSpan" id="kobo.263.5">Conclusively, two attachments are never served via the </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">same URL.</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">Let’s update the attachment logic in BeeRich to take advantage of </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">HTTP caching:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.267.1">First, update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">buildFileResponse</span></strong><span class="koboSpan" id="kobo.269.1"> function in </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">app/modules/attachments.server.ts</span></strong><span class="koboSpan" id="kobo.271.1"> so that it supports passing in </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">custom headers:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.273.1">
export function buildFileResponse(fileName: string, </span><strong class="bold"><span class="koboSpan" id="kobo.274.1">headers = new Headers()</span></strong><span class="koboSpan" id="kobo.275.1">): Response {  const localPath = path.join(process.cwd(), 'attachments', fileName);  try {    const file = fs.readFileSync(localPath);    </span><strong class="bold"><span class="koboSpan" id="kobo.276.1">headers.append('Content-Type', 'application/octet-stream');</span></strong><span class="koboSpan" id="kobo.277.1">    </span><strong class="bold"><span class="koboSpan" id="kobo.278.1">headers.append('Content-Disposition', `attachment; filename="${fileName}"`);</span></strong><span class="koboSpan" id="kobo.279.1">    return new Response(file, </span><strong class="bold"><span class="koboSpan" id="kobo.280.1">{ headers }</span></strong><span class="koboSpan" id="kobo.281.1">);  } catch (error) {    console.error(error);    return new Response('Not Found', { status: 404 });  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.282.1">We </span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.283.1">now allow a </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">headers</span></strong><span class="koboSpan" id="kobo.285.1"> object to be passed in so that HTTP headers can be added to the file </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">response object.</span></span></p></li> <li><span class="koboSpan" id="kobo.287.1">Next, update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">loader</span></strong><span class="koboSpan" id="kobo.289.1"> function in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">dashboard.expenses.$id.attachments.$.tsx</span></strong><span class="koboSpan" id="kobo.291.1"> resource </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">route module:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.293.1">
export async function loader({ request, params }: LoaderFunctionArgs) {  const userId = await requireUserId(request);  const { id } = params;  const slug = params['*'];  if (!id || !slug) throw Error('id and slug route parameters must be defined');  const expense = await db.expense.findUnique({ where: { id_userId: { id, userId } } });  if (!expense || !expense.attachment) throw new Response('Not found', { status: 404 });  if (slug !== expense.attachment) return redirect(`/dashboard/expenses/${id}/attachments/${expense.attachment}`);  </span><strong class="bold"><span class="koboSpan" id="kobo.294.1">const headers = new Headers();</span></strong><span class="koboSpan" id="kobo.295.1">  </span><strong class="bold"><span class="koboSpan" id="kobo.296.1">headers.set('Cache-Control', 'private, max-age=31536000, immutable');</span></strong><span class="koboSpan" id="kobo.297.1">  </span><strong class="bold"><span class="koboSpan" id="kobo.298.1">return buildFileResponse(expense.attachment, headers);</span></strong><span class="koboSpan" id="kobo.299.1">}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.300.1">Here, we supply a cache-control header to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">buildFileResponse</span></strong><span class="koboSpan" id="kobo.302.1"> function, which returns the file </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">download response.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.304.1">Since </span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.305.1">we know that the attachment never changes – a new attachment would create a new filename – we apply the </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">immutable</span></strong><span class="koboSpan" id="kobo.307.1"> directive and cache the asset for a year. </span><span class="koboSpan" id="kobo.307.2">Because the attachments contain sensitive user information, we set the cache to </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">private</span></strong><span class="koboSpan" id="kobo.309.1"> to avoid </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">shared caching.</span></span></p></li> <li><span class="koboSpan" id="kobo.311.1">Start BeeRich by executing </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">npm run dev</span></strong><span class="koboSpan" id="kobo.313.1"> and, in your browser, navigate to an expense </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">details page.</span></span></li>
<li><span class="koboSpan" id="kobo.315.1">Next, download an attachment twice and inspect the second network payload in the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.316.1">Network</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.317.1"> tab:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer052">
<span class="koboSpan" id="kobo.318.1"><img alt="Figure 12.3 – Attachment cached on disk" src="image/Figure_12.03_B17399.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.319.1">Figure 12.3 – Attachment cached on disk</span></p>
<p><span class="koboSpan" id="kobo.320.1">Great! </span><span class="koboSpan" id="kobo.320.2">As</span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.321.1"> visible in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.322.1">Figure 12</span></em></span><em class="italic"><span class="koboSpan" id="kobo.323.1">.3</span></em><span class="koboSpan" id="kobo.324.1">, we avoided a request to the web server for the second download request. </span><span class="koboSpan" id="kobo.324.2">Instead, the attachment was downloaded from the disk cache of </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">the browser.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">Caching is hard, especially when you’re trying to cache user-specific data. </span><span class="koboSpan" id="kobo.326.2">Can you think of any potential security concerns with the </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">current implementation?</span></span></p>
<p><span class="koboSpan" id="kobo.328.1">Imagine a user logging in to BeeRich from a public computer to access expense attachments. </span><span class="koboSpan" id="kobo.328.2">The user downloads one of the attachments to print it. </span><span class="koboSpan" id="kobo.328.3">The user then deletes the attachment from the public computer and logs themselves out from BeeRich. </span><span class="koboSpan" id="kobo.328.4">Now, could a malicious actor retrieve the attachment from the browser </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">cache? </span><span class="koboSpan" id="kobo.329.2">Potentially.</span></span></p>
<p><span class="koboSpan" id="kobo.330.1">Copy and paste the </span><strong class="bold"><span class="koboSpan" id="kobo.331.1">Request URL</span></strong><span class="koboSpan" id="kobo.332.1"> property to your attachment from the </span><strong class="bold"><span class="koboSpan" id="kobo.333.1">Headers</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.334.1">Network</span></strong><span class="koboSpan" id="kobo.335.1"> tab. </span><span class="koboSpan" id="kobo.335.2">Now, log out from BeeRich to be redirected to the login page. </span><span class="koboSpan" id="kobo.335.3">Copy and paste the copied request URL into the address bar and hit </span><em class="italic"><span class="koboSpan" id="kobo.336.1">Enter</span></em><span class="koboSpan" id="kobo.337.1">. </span><span class="koboSpan" id="kobo.337.2">Since we allow the browser to cache the document on its private disk cache, the request will not go to the resource route where we would authenticate the user. </span><span class="koboSpan" id="kobo.337.3">Instead, the browser retrieves the document</span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.338.1"> from the memory or disk cache and serves it to the user, a potential </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">security vulnerability.</span></span></p>
<p><span class="koboSpan" id="kobo.340.1">In this section, you learned about the potential security risks of leaking user data using private and public cache control directives. </span><span class="koboSpan" id="kobo.340.2">We can use a different caching strategy instead of caching private data in the browser cache. </span><span class="koboSpan" id="kobo.340.3">Next, we will have a look at </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">entity tags.</span></span></p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.342.1">Caching dynamic data responses with entity tags</span></h2>
<p><span class="koboSpan" id="kobo.343.1">An </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.344.1">HTTP request for a document can result in different HTTP responses. </span><span class="koboSpan" id="kobo.344.2">A response with status code 200 usually includes an HTTP body containing the requested document – for instance, an HTML document, PDF, </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">or image.</span></span></p>
<p><span class="koboSpan" id="kobo.346.1">The HTTP request-response flow allows us to authorize user access and potentially turn down requests with 401 (Unauthorized) responses. </span><span class="koboSpan" id="kobo.346.2">In the previous section, we cached data in private and shared caches, which cuts the request-response flow short from reaching our server on a </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">cache hit.</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">In this section, we will explore how to utilize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">ETag</span></strong><span class="koboSpan" id="kobo.350.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">If-None-Match</span></strong><span class="koboSpan" id="kobo.352.1"> headers so that we can avoid resending full responses but still execute authorization functions on </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">the server.</span></span></p>
<p><span class="koboSpan" id="kobo.354.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">ETag</span></strong><span class="koboSpan" id="kobo.356.1"> header may carry a unique identifier (entity tag) for a response, which the client can use to append subsequent requests to the same URL with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">If-None-Match</span></strong><span class="koboSpan" id="kobo.358.1"> header. </span><span class="koboSpan" id="kobo.358.2">The server can then compute the new response and compare the new tag with the request </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">If-None-Match</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.360.1"> header.</span></span></p>
<p><span class="koboSpan" id="kobo.361.1">Let’s update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">loader</span></strong><span class="koboSpan" id="kobo.363.1"> function in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">dashboard.expenses.$id.attachments.$.tsx</span></strong><span class="koboSpan" id="kobo.365.1"> resource route module to see how this looks like </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">in action:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.367.1">
export async function loader({ request, params }: LoaderFunctionArgs) {  const userId = await requireUserId(request);
  const { id } = params;
  const slug = params['*'];
  if (!id || !slug) throw Error('id and slug route parameters must be defined');
  const expense = await db.expense.findUnique({ where: { id_userId: { id, userId } } });
  if (!expense || !expense.attachment) throw new Response('Not found', { status: 404 });
  if (slug !== expense.attachment) return redirect(`/dashboard/expenses/${id}/attachments/${expense.attachment}`);
  const headers = new Headers();
</span><strong class="bold"><span class="koboSpan" id="kobo.368.1">  headers.set('ETag', expense.attachment);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.369.1">  if (request.headers.get('If-None-Match') === expense.attachment) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.370.1">    return new Response(null, { status: 304, headers });</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.371.1">  }</span></strong><span class="koboSpan" id="kobo.372.1">
  return buildFileResponse(expense.attachment, headers);
}</span></pre>
<p><span class="koboSpan" id="kobo.373.1">We</span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.374.1"> use the attachment identifier as the entity tag and append it to the response headers. </span><span class="koboSpan" id="kobo.374.2">If a client requests the same attachment twice, we can access the previously sent </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">ETag</span></strong><span class="koboSpan" id="kobo.376.1"> header through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">If-None-Match</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.378.1">request header.</span></span></p>
<p><span class="koboSpan" id="kobo.379.1">After authorizing the user in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">loader</span></strong><span class="koboSpan" id="kobo.381.1"> function, we can check whether the request contains an </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">If-None-Match</span></strong><span class="koboSpan" id="kobo.383.1"> header. </span><span class="koboSpan" id="kobo.383.2">In that case, we can communicate to the client that there has been no change to the response using the 304 status code. </span><span class="koboSpan" id="kobo.383.3">The client can then use the cached response body instead of redownloading </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">the attachment.</span></span></p>
<p><span class="koboSpan" id="kobo.385.1">Investigate the new implementation by repeating the steps from the previous sections to download the same attachment twice. </span><span class="koboSpan" id="kobo.385.2">Note that your browser’s guest and incognito modes reset caches on each session, which makes them great tools for testing initial page </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">load times:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer053">
<span class="koboSpan" id="kobo.387.1"><img alt="Figure 12.4 – ETag-based caching of attachments" src="image/Figure_12.04_B17399.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.388.1">Figure 12.4 – ETag-based caching of attachments</span></p>
<p><span class="koboSpan" id="kobo.389.1">As </span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.390.1">visible in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.391.1">Figure 12</span></em></span><em class="italic"><span class="koboSpan" id="kobo.392.1">.4</span></em><span class="koboSpan" id="kobo.393.1">, any subsequent download of the attachment now triggers a request that receives a 304 response. </span><span class="koboSpan" id="kobo.393.2">When inspecting the </span><strong class="bold"><span class="koboSpan" id="kobo.394.1">Headers</span></strong><span class="koboSpan" id="kobo.395.1"> tab, you will see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">ETag</span></strong><span class="koboSpan" id="kobo.397.1"> (response) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">If-None-Match</span></strong><span class="koboSpan" id="kobo.399.1"> (</span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">request) headers.</span></span></p>
<p><span class="koboSpan" id="kobo.401.1">Finally, copy the </span><strong class="bold"><span class="koboSpan" id="kobo.402.1">Request URL</span></strong><span class="koboSpan" id="kobo.403.1"> property and log out. </span><span class="koboSpan" id="kobo.403.2">Now, attempt to access the attachment by navigating to the request URL. </span><span class="koboSpan" id="kobo.403.3">Notice that BeeRich redirects to the login page. </span><span class="koboSpan" id="kobo.403.4">This is because ETag-based caching triggers a request to the server. </span><span class="koboSpan" id="kobo.403.5">The server then checks for the session cookie and </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">redirects accordingly.</span></span></p>
<p><span class="koboSpan" id="kobo.405.1">ETags come with a different set of trade-offs. </span><span class="koboSpan" id="kobo.405.2">When using ETags to revalidate content, we can’t avoid the roundtrip to the web server, but we can still avoid downloading the same response body twice. </span><span class="koboSpan" id="kobo.405.3">This serves as a good middle ground as we can execute authorization and authentication functions on the server but also improve performance by reusing existing </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">response bodies.</span></span></p>
<p><span class="koboSpan" id="kobo.407.1">Great! </span><span class="koboSpan" id="kobo.407.2">We implemented three HTTP caching strategies in BeeRich: public caching of public pages, no caching for the dynamic dashboard pages, and ETags for private static assets. </span><span class="koboSpan" id="kobo.407.3">You also learned how Remix uses HTTP caching for static assets out of </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">the box.</span></span></p>
<p><span class="koboSpan" id="kobo.409.1">Ensure you update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">dashboard.income.$id.attachments.$.tsx</span></strong><span class="koboSpan" id="kobo.411.1"> resource route to take advantage of ETag-based caching for </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">invoice attachments.</span></span></p>
<p><span class="koboSpan" id="kobo.413.1">HTTP caching has much to offer. </span><span class="koboSpan" id="kobo.413.2">In this chapter, you learned about a few common strategies, but there are many more, such as stale-while-revalidate caching strategies. </span><span class="koboSpan" id="kobo.413.3">Refer to the </span><em class="italic"><span class="koboSpan" id="kobo.414.1">Further reading</span></em><span class="koboSpan" id="kobo.415.1"> section for more information about HTTP </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">caching strategies.</span></span></p>
<p><span class="koboSpan" id="kobo.417.1">Next, let’s discuss how to utilize caching on our </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">Remix server.</span></span></p>
<h1 id="_idParaDest-193"><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.419.1">Exploring in-memory caching</span></h1>
<p><span class="koboSpan" id="kobo.420.1">Caching </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.421.1">effectiveness increases the closer the cache is to the </span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.422.1">users. </span><span class="koboSpan" id="kobo.422.2">In-browser caching avoids network requests altogether. </span><span class="koboSpan" id="kobo.422.3">CDN-based caching can significantly shorten network requests. </span><span class="koboSpan" id="kobo.422.4">However, we may also give up more control over the cache the further it is away from our </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">Remix server.</span></span></p>
<p><span class="koboSpan" id="kobo.424.1">In this section, we will discuss in-memory caching strategies and learn about the advantages and disadvantages of in-memory </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">caching options.</span></span></p>
<p><span class="koboSpan" id="kobo.426.1">HTTP caching might not always be the right strategy. </span><span class="koboSpan" id="kobo.426.2">For instance, we already discussed privacy issues when caching user-specified information. </span><span class="koboSpan" id="kobo.426.3">In some cases, it might make sense to implement a custom caching layer on the </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">web server.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">The easiest way is to store computation results or fetched responses in memory on the server itself. </span><span class="koboSpan" id="kobo.428.2">However, as we learned in </span><a href="B17399_03.xhtml#_idTextAnchor043"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.429.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.430.1">, </span><em class="italic"><span class="koboSpan" id="kobo.431.1">Deployment Targets, Adapters, and Stacks</span></em><span class="koboSpan" id="kobo.432.1">, this may not always be possible. </span><span class="koboSpan" id="kobo.432.2">Runtime environments such as the edge and serverless may shut down after every request and may not be capable of sharing memory </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">between requests.</span></span></p>
<p><span class="koboSpan" id="kobo.434.1">In BeeRich, we utilize a long-running Express.js server. </span><span class="koboSpan" id="kobo.434.2">Long-running environments are capable of sharing memory between requests. </span><span class="koboSpan" id="kobo.434.3">Hence, we can use our server’s memory to cache data. </span><span class="koboSpan" id="kobo.434.4">Caching data in memory allows us to avoid database queries and downstream fetch requests. </span><span class="koboSpan" id="kobo.434.5">Caching data in memory is a great way to improve performance. </span><span class="koboSpan" id="kobo.434.6">However, we must also consider memory limitations </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">and overflows.</span></span></p>
<p><span class="koboSpan" id="kobo.436.1">Alternatively, we can utilize services such as Redis, low-latency in-memory databases, to store computation or fetch results. </span><span class="koboSpan" id="kobo.436.2">Utilizing Redis as a cache is also a great solution when running on serverless or edge runtimes, where memory might not be shared </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">between requests.</span></span></p>
<p><span class="koboSpan" id="kobo.438.1">But what about BeeRich? </span><span class="koboSpan" id="kobo.438.2">BeeRich utilizes a SQLite database, which provides very fast responses for simple queries (a few milliseconds). </span><span class="koboSpan" id="kobo.438.3">Using Redis would likely not improve the performance as it would introduce a network request to the </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">Redis server.</span></span></p>
<p><span class="koboSpan" id="kobo.440.1">Unfortunately, in the real world, database and API requests may be much slower. </span><span class="koboSpan" id="kobo.440.2">In these cases, it may make sense to cache the results in Redis or in-memory on the server to reuse fetched results and avoid subsequent </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">slow requests.</span></span></p>
<p><span class="koboSpan" id="kobo.442.1">One great example is our user object. </span><span class="koboSpan" id="kobo.442.2">We fetch the user object on every incoming request in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">root.tsx loader</span></strong><span class="koboSpan" id="kobo.444.1"> function. </span><span class="koboSpan" id="kobo.444.2">We can identify that we read the user object disproportionally more often than updating it. </span><span class="koboSpan" id="kobo.444.3">If responses become slow, this may be a good indication to store the user object in an </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">in-memory cache.</span></span></p>
<p><span class="koboSpan" id="kobo.446.1">In-memory caching</span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.447.1"> requires us to implement custom cache invalidation logic, but it may also improve performance when HTTP caching is not the right tool for the job. </span><span class="koboSpan" id="kobo.447.2">Conclusively, adding a service such as Redis could be a good consideration in case our responses become slow, and we identify that slow database or API queries are the </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">root cause.</span></span></p>
<h1 id="_idParaDest-194"><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.449.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.450.1">In this chapter, you learned about different caching strategies and how to implement them </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">with Remix.</span></span></p>
<p><span class="koboSpan" id="kobo.452.1">Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">headers</span></strong><span class="koboSpan" id="kobo.454.1"> route module API export lets us specify HTTP headers for the HTML document on a per-route level. </span><span class="koboSpan" id="kobo.454.2">We also have access to </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">loaderHeaders</span></strong><span class="koboSpan" id="kobo.456.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">parentHeaders</span></strong><span class="koboSpan" id="kobo.458.1">, which allows us to merge HTTP headers and specify headers based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">loader data.</span></span></p>
<p><span class="koboSpan" id="kobo.460.1">You also learned how to cache both document and data requests in Remix. </span><span class="koboSpan" id="kobo.460.2">You learned how to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">Cache-Control</span></strong><span class="koboSpan" id="kobo.462.1"> header to specify and </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">prevent caching.</span></span></p>
<p><span class="koboSpan" id="kobo.464.1">Then, you applied the </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">private</span></strong><span class="koboSpan" id="kobo.466.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">public</span></strong><span class="koboSpan" id="kobo.468.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">max-age</span></strong><span class="koboSpan" id="kobo.470.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">no-cache</span></strong><span class="koboSpan" id="kobo.472.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">immutable</span></strong><span class="koboSpan" id="kobo.474.1"> directives. </span><span class="koboSpan" id="kobo.474.2">Additionally, you reviewed how Remix implements HTTP caching for static assets out of </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">the box.</span></span></p>
<p><span class="koboSpan" id="kobo.476.1">Next, you learned about the privacy concerns of caching user-specific data and how to use ETags to avoid downloading full responses while sending requests to the server where the user authorization can </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">be checked.</span></span></p>
<p><span class="koboSpan" id="kobo.478.1">Finally, we discussed in-memory caching and using services such as Redis to avoid requests to slow third-party services </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">or databases.</span></span></p>
<p><span class="koboSpan" id="kobo.480.1">In the next chapter, we will learn about deferring loader data. </span><span class="koboSpan" id="kobo.480.2">Like caching, deferring loader data is a great lever to improve the user experience and performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">web applications.</span></span></p>
<h1 id="_idParaDest-195"><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.482.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.483.1">You can learn more about CDNs in the MDN Web </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">Docs: </span></span><a href="https://developer.mozilla.org/en-US/docs/Glossary/CDN"><span class="No-Break"><span class="koboSpan" id="kobo.485.1">https://developer.mozilla.org/en-US/docs/Glossary/CDN</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.486.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.487.1">You can also find an overview of HTTP caching concepts in the MDN Web </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">Docs: </span></span><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching"><span class="No-Break"><span class="koboSpan" id="kobo.489.1">https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.490.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.491.1">The MDN Web Docs also provide detailed information about each HTTP </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">caching header:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">ETag</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">: </span></span><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"><span class="No-Break"><span class="koboSpan" id="kobo.495.1">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">Cache-Control</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">: </span></span><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control"><span class="No-Break"><span class="koboSpan" id="kobo.498.1">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control</span></span></a></li>
</ul>
<p><span class="koboSpan" id="kobo.499.1">Refer to the Remix documentation for more information about Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">headers</span></strong><span class="koboSpan" id="kobo.501.1"> route module </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">API: </span></span><a href="https://remix.run/docs/en/2/route/headers"><span class="No-Break"><span class="koboSpan" id="kobo.503.1">https://remix.run/docs/en/2/route/headers</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.504.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.505.1">Ryan Florence recorded two great videos about caching on the Remix YouTube channel. </span><span class="koboSpan" id="kobo.505.2">Fun fact – they were the very first videos that were uploaded on the Remix YouTube channel, and they are worth </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">checking out:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.507.1">Remix Run – Introduction to HTTP </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.508.1">Caching</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">: </span></span><a href="https://www.youtube.com/watch?v=3XkU_DXcgl0"><span class="No-Break"><span class="koboSpan" id="kobo.510.1">https://www.youtube.com/watch?v=3XkU_DXcgl0</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.511.1">CDN Caching, Static Site Generation, and Server Side </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.512.1">Rendering</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">: </span></span><a href="https://www.youtube.com/watch?v=bfLFHp7Sbkg"><span class="No-Break"><span class="koboSpan" id="kobo.514.1">https://www.youtube.com/watch?v=bfLFHp7Sbkg</span></span></a></li>
</ul>
<p><span class="koboSpan" id="kobo.515.1">You can also find a great guide for using ETags with Remix on Sergio’s </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">blog: </span></span><a href="https://sergiodxa.com/articles/use-etags-in-remix"><span class="No-Break"><span class="koboSpan" id="kobo.517.1">https://sergiodxa.com/articles/use-etags-in-remix</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.518.1">.</span></span></p>
</div>
</body></html>