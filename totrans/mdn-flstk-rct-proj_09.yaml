- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding Authentication with JWT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After developing and deploying our first full-stack application, we now have
    a way for anyone to create posts on our blog. However, since the author is an
    input field, anyone could enter any author, impersonating others! That’s not good.
    In this chapter, we are going to add authentication with **JSON Web Token** (**JWT**)
    and functionalities to sign up and log into our application by adding additional
    routes using React Router.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is JWT?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing login, signup, and authenticated routes in the backend using JWT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating login and signup in the frontend using React Router and JWT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced token handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start, please install all the requirements from [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016),
    *Preparing for Full-Stack Development*, and [*Chapter 2*](B19385_02.xhtml#_idTextAnchor028),
    *Getting to Know Node.js* *and MongoDB*.
  prefs: []
  type: TYPE_NORMAL
- en: The versions listed in those chapters are the ones used in this book. While
    installing a newer version should not be an issue, please note that certain steps
    might work differently. If you are having an issue with the code and steps provided
    in this book, please try using the versions mentioned in [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016)
    and [*Chapter 2*](B19385_02.xhtml#_idTextAnchor028).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch6](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch6).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be found at: [https://youtu.be/LloHmkgRLWk](https://youtu.be/LloHmkgRLWk).'
  prefs: []
  type: TYPE_NORMAL
- en: What is JWT?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JWT, pronounced “jot”, is an open industry standard (RFC 7519) for safely passing
    claims between multiple parties. Claims can be information about a certain party
    or object, such as the email address, user ID, and roles of a user. In our case,
    we will pass JWTs between our backend and frontend.
  prefs: []
  type: TYPE_NORMAL
- en: JWT is used by many products and services and is supported by third-party authentication
    providers, such as Auth0, Okta, and Firebase Auth. It is easy to parse JWTs as
    we only need to base64 decode them and parse the JSON string. After verifying
    the signature, we can be sure that the JWT is authentic and trust the claims within
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'JWTs consist of the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Header**: Containing the algorithm and token type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Payload**: Containing the data/claims of the token'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signature**: For verifying that the token was created by a legit source'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These three components form a JWT as they’re joined into a single string, separated
    by a period (`.`), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s look at each component separately.
  prefs: []
  type: TYPE_NORMAL
- en: JWT header
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The JWT header typically consists of a token type (in our case, JWT), specified
    by the `typ` property, and the algorithm used to create the signature (in our
    case, we will use HMAC SHA256, a SHA256 hash-based message authentication code),
    specified by the `alg` property. The header is defined as a JSON object, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This JSON object is then base64 encoded and forms the first part of the JWT.
  prefs: []
  type: TYPE_NORMAL
- en: JWT payload
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main part of the JWT is the payload, which contains all claims. Claims
    are information about an entity (such as the user) and additional data. The JWT
    standard distinguishes between three types of claims:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Registered claims**: These are predefined claims and it’s recommended that
    they’re set. They include information about the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The issuer (**iss**), which is the entity that created the token.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The expiration time (**exp**), which tells us when the token expires.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The subject (**sub**), which tells us about the entity identified by the token
    (such as the user who generated the token during a login).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The audience (**aud**), which tells us about the intended recipients of the
    token.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The issued at time (**iat**), which tells us when the token was created.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The not before time (**nbf**), which specifies a time before which the token
    is not valid yet.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The JWT ID (**jti**), which provides a unique identifier for the JWT. It’s used
    to prevent JWTs from being replayed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The JSON object properties defined in the JWT standard are all three-letter
    names to keep the JWT as compact as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '**Public claims**: These are additional claims that are commonly used and shared
    across many services. A list of those can be found on the **Internet Assigned
    Numbers Authority** (**IANA**) website: [https://www.iana.org/assignments/jwt/jwt.xhtml](https://www.iana.org/assignments/jwt/jwt.xhtml).
    If we want to store additional information, we should always consult this list
    first to see if we can use a standardized claim name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private claims**: These are custom-defined claims, which are neither registered
    nor public. If we need a special claim that isn’t defined yet, we can make a private
    claim that only our services will understand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All claims are optional, but it makes sense to at least include one claim to
    identify the subject, such as the `sub` registered claim.
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting together what we’ve learned, we can create the following example payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In our example, the `sub` claim is a registered claim, the `name` claim is a
    public claim, and the `admin` claim is a private claim.
  prefs: []
  type: TYPE_NORMAL
- en: The payload is also base64 encoded and forms the second part of the JWT. As
    such, this information is publicly readable by anyone who has access to the token.
    Do not put secret information into the payload or header of a JWT! However, the
    information cannot be *changed* without invalidating the existing signature, making
    all claims tamper-proof. Only a backend service with access to the private key
    can generate a new signature to create a valid JWT.
  prefs: []
  type: TYPE_NORMAL
- en: JWT signature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final part of a JWT is its signature. The signature is what proves that
    all the information that we’ve defined up until now has not been tampered with.
    The signature is created by taking the base64-encoded header and payload, joining
    those strings with a period symbol, and using the specified algorithm to sign
    it with a secret key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve learned about the different components of a JWT, let’s put this
    all together to create a valid JWT.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a JWT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a JWT:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the [https://jwt.io/](https://jwt.io/) website and scroll down to the
    **Debugger** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter our previously defined header and payload.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter **full-stack** as the secret.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The encoded JWT should update on the fly as you’re changing the values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you can see, we have successfully created our first JWT:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Our first JWT, created with the jwt.io debugger](img/B19385_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Our first JWT, created with the jwt.io debugger
  prefs: []
  type: TYPE_NORMAL
- en: The generated JWT consists of three components, each of them base64-encoded
    and separated by periods. In the debugger, they are highlighted in three different
    colors. Try changing the base64 string in the “Encoded” section by removing some
    characters; you will see that the JWT is now invalid due to an ”Invalid Signature”
    issue. Now that we’ve created our first JWT, let’s learn how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Using JWT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the login process, we are going to generate a JWT for the logged-in user
    in the backend. This JWT will be returned to the user’s browser. When the user
    wants to access a protected route, we can send the JWT to the backend server by
    using the `Authorization` header with the `Bearer` schema, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The backend can then check for this header, verify the signature of the token,
    and grant the user access to certain routes. By sending the token in a header
    instead of a cookie, we don’t have to deal with CORS issues that we would have
    when dealing with cookies.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Be careful not to send too much data in the header since some servers do not
    accept more than 8 KB in headers. This means that, for example, complex role information
    should not be stored in the JWT claims as it might take up too much space. Instead,
    this kind of information could be stored in the database associated with a user
    ID from the JWT.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting advantage of using a JWT is that the authentication server and
    the actual backend for our app do not have to be the same. We could have a separate
    authentication service, get a JWT, and in the backend verify the signature of
    the JWTs to guarantee that they were generated by the authentication service.
    This allows us to use external services for authentication, such as Auth0, Okta,
    or Firebase Auth.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the authorization flow for a JWT:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Authorization flow for a JWT](img/B19385_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Authorization flow for a JWT
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the application requests authorization to the authorization server,
    which can also be either a third-party provider, a separate service, or part of
    the backend service. Then, when authorization is granted (if the login details
    are correct), the authorization server returns a JWT. This JWT can then be used
    to access protected routes on APIs. Before granting access, the JWT signature
    is validated to ensure that it has not been tampered with.
  prefs: []
  type: TYPE_NORMAL
- en: Storing JWT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We should take great care about where we store the JWT. Local storage is *not*
    a good way to store authentication information such as a JWT. Cross-site scripting
    can be used to steal all data in local storage. For short-lived tokens, we can
    store them in a JavaScript runtime variable (such as a React context). For longer-term
    storage, we could use an `httpOnly` cookie, which has additional security guarantees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve learned how JWT works, let’s put theory into practice and implement
    login, signup, and authenticated routes in the backend using JWT.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing login, signup, and authenticated routes in the backend using JWTs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve learned about JWTs, we’ll implement them in our backend. First,
    we need to create a user model in our database, after which we can create routes
    to sign up and log into our app. Finally, we will implement authenticated routes
    that are only accessible with a JWT.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the user model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll start the backend implementation by creating a user model, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the **ch5** folder to a new **ch6** folder, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the **ch6** folder in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new **backend/src/db/models/user.js** file and define a new **userSchema**
    inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A user should have a required unique **username** and a required **password**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create and export the model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, let’s also adjust the post model so that we can store a reference
    to a user ID instead of the username as the author. Edit **backend/src/db/models/post.js**,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we’ve successfully created the user model, let’s move on to creating
    the signup service so that we have a way to create new users.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the signup service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a user signs up, we need to hash the password provided by the user before
    storing it in the database. We should never store passwords in plaintext as that
    would mean that if our database gets leaked, an attacker will have access to the
    passwords of all users. Hashing is a one-way function that turns a string into
    a different string in a deterministic way. This means that, for example, if we
    do `hash("password1")`, we get a specific string every time we do it. However,
    if we do `hash("password2")`, we get a completely different string. By choosing
    a good hash function, we can ensure that reversing a hash is so computationally
    expensive that it is impossible to do in a reasonable time. When the user signs
    up, we can store the hash of their password. When a user then enters their password
    to log in, we can hash their entered password again and compare it to the hash
    in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start implementing the signup service with hashed passwords:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the **bcrypt** npm package. We are going to use this to hash the password
    before storing it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new **backend/src/services/users.js** file and import **bcrypt** and
    the **User** model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a **createUser** function that takes **username** and **password** values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside this function, we use the **bcrypt.hash** function to create a hash
    from the plaintext password using 10 salt rounds (repeating the hashing 10 times
    to make it even harder to reverse it):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can create a new user and store it in our database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For brevity, we won’t cover creating tests for the user services. Refer to [*Chapter
    3*](B19385_03_split_000.xhtml#_idTextAnchor050), *Implementing a Backend Service
    Using Express, Mongoose ODM, and Jest*, for information on how to create tests
    for your service functions. You can write similar tests to what we did for the
    posts service functions.
  prefs: []
  type: TYPE_NORMAL
- en: After creating the signup service, we can create the signup route.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the signup route
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s expose the signup service function by adding an API route for it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new **backend/src/routes/users.js** file and import the **createUser**
    service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a new **userRoutes** function and expose a **POST /api/v1/user/signup**
    route. This route creates a new user from the request body and return the username:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this case, we define a singular `user` route instead of calling it `users`
    as we are only dealing with one user at a time. To keep things simple, the error
    handling is very rudimentary. It would be a good idea to distinguish between the
    different errors that can happen and show a different error message, depending
    on the error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Edit **backend/src/app.js** and import the **userRoutes** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same file, call the **userRoutes** function after the **postRoutes**
    function to mount them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure the **dbserver** container is running in Docker.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start the backend by running the following command in a Terminal inside the
    **backend/** folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, make a request to the new **POST /api/v1/user/signup** route. You will
    see that creating a user works if **username** and **password** values are provided
    properly. Enter the following code in your browser console while the backend is
    running, on a blank tab or at **http://localhost:3001/**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we try creating another user with the same username (by executing the same
    fetch again), it will fail because the **username** field is defined to be unique
    in Mongoose.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have successfully created our first user, let’s continue by creating
    the login service to allow our user to log in.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the login service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have only created a user in our database. As we aren’t authorizing
    the user yet, we haven’t dealt with JWTs yet. Let’s start doing that now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new Terminal and install the **jsonwebtoken** library, which contains
    functions to deal with the creation and verification of JWTs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit the **backend/src/services/users.js** file and import **jwt** from the
    **jsonwebtoken** library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a new **loginUser** function, which takes a username and password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, fetch a user with the given **username** from our database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, use **bcrypt.compare** to compare the entered password to the hashed
    password from the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the user correctly enters a username and password, we use **jwt.sign()**
    to create a new JWT and sign it with a secret. For the secret, we use an environment
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the last argument, we also specify that our token should be valid for 24
    hours.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We are using the user ID, not the username, to identify the user. This is done
    to future-proof the system as the user ID is a value that will never change. In
    the future, we might want to add a way to change the username. It would be hard
    to deal with such a change if we always use the username to identify the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we return the token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we define the **JWT_SECRET** environment variable by editing the **.****env**
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure you generate a safe JWT secret for the production environment, which
    you never expose or use in development environments or for debugging! If you want
    to deploy your app to Google Cloud Run again, you would also need to add this
    secret as an environment variable there.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We’ll also add one to **.env.template** as an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After successfully creating a login service to create and sign JWTs, we can
    create the login route.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the login route
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We still need to expose the login service as an API route for users to be able
    to log in. Let’s do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the **backend/src/routes/users.js** file and import the **loginUser**
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new **POST /api/v1/user/login** route inside the **userRoutes** function,
    where we call the **loginUser** function and return the token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the backend is not running anymore, start it again. Then, make a request
    to **/api/v1/user/login** to test it out by entering the following code in your
    browser console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have successfully created a valid JWT! To verify that the JWT is valid,
    we can paste it into the debugger at [https://jwt.io/](https://jwt.io/). Make
    sure that you also change the secret in the **Verify Signature** section on the
    page, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Verifying the JWT created from the login service](img/B19385_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Verifying the JWT created from the login service
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When copying the token from the JSON response in your browser, make sure that
    you are copying the full string value, and not the truncated one (with **…** in
    the middle of the string). Otherwise, the JWT might not decode properly in the
    debugger.
  prefs: []
  type: TYPE_NORMAL
- en: After successfully logging our user in and creating a token for them, we can
    now protect certain routes and make sure that only logged-in users can access
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Defining authenticated routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have successfully created a valid JWT, we can start protecting
    routes. To do so, we are going to use the `express-jwt` library, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the **express-jwt** npm package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new **backend/src/middleware** folder. Inside it, create a new **backend/src/middleware/jwt.js**
    file and import **expressjwt** there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create and export a **requireAuth** middleware by using the **expressjwt**
    function and your secret and algorithm settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need to use a function for the secret because `dotenv` isn’t initialized
    at import time yet, so the environment variable will only be available later.
    Specifying the algorithms is required to prevent potential downgrade attacks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Edit **backend/src/routes/posts.js** and import the **requireAuth** middleware:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the middleware to the create route. Middleware in Express can be added
    to specific routes by passing it as a second argument to the function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Repeat the same for the edit route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, do this for the delete route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try accessing the routes without being logged in. You will see that they fail
    with a **401 Unauthorized** status. Execute the following code into your browser
    console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can see the results of executing the code in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: "![Figure 6.4 – Attempting to access a protected route \uFEFFwithout a JWT and\
    \ then with a JWT](img/B19385_06_4.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Attempting to access a protected route without a JWT and then with
    a JWT
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using the **express-jwt** library, we could also manually extract
    the token from the **Authorization** header and use the **jwt.verify** function
    from the **jsonwebtoken** library to verify it.
  prefs: []
  type: TYPE_NORMAL
- en: The routes are protected now, but we aren’t considering which user accessed
    them. Let’s do that now by accessing the currently logged-in user from the token.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the currently logged-in user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After adding authenticated routes, we successfully protected some routes so
    that they can only be accessed by logged-in users. However, it’s still possible
    to edit posts of other users or create posts under a different username. Let’s
    change that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the **backend/src/services/posts.js** file and add a **userId** argument
    to the **createPost** function, *removing* **author** from the object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instead of setting the author through the request body, we will set the author
    to the ID of the logged-in user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We adjust the **updatePost** and **deletePost** functions similarly (adding
    the **userId** argument, removing the **author** argument, and removing the author
    variable from the **$set** object), ensuring that the currently logged-in user
    is the author of the post:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In our case, we simply fetch a post with the given ID and an author as the current
    user. We could still extend this code to first fetch the post with the given ID,
    check if it exists (if not, return a **404 Not Found** error), and if it does
    exist, verify that the author is the currently logged-in user (if not, return
    a **403** **Forbidden** error).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This is a breaking API change and requires changing the tests. For brevity,
    we will not go through adjusting the tests step by step here, so this is left
    as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the **backend/src/routes/posts.js** file and use the **req.auth.sub**
    variable to pass the user ID to the **createPost** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Do the same for the **updatePost** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, do this for the **deletePost** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try creating a new post; you will see that it is created by the user identified
    in the JWT. You can do this by executing the following code in the browser console
    (don’t forget to replace **<TOKEN>** with your previously generated JWT):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Editing and deleting your posts is also possible, but not for posts from other
    users anymore!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Info
  prefs: []
  type: TYPE_NORMAL
- en: The **express-jwt** middleware stores all decoded claims from the JWT in a **req.auth**
    object. So, we can access any claims made when creating our JWT here. Of course,
    the middleware validates the JWT signature against the defined secret first, to
    ensure that it received an authentic JWT.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up the login, signup, and authenticated routes, let’s continue
    by integrating login and signup in the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating login and signup in the frontend using React Router and JWT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have successfully implemented authorization in the backend, let’s
    start extending the frontend with signup and login pages and connecting them to
    the backend. First, we are going to learn how to implement multiple pages in a
    React app using React Router. Then, we are going to implement the signup UI and
    connect it to the backend. Afterward, we are going to implement a login UI, store
    the token in the frontend, and set up automatic redirects when we are successfully
    logged in. Finally, we are going to update the code for creating posts to pass
    the token in the Authorization header and properly access our authenticated route.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started with the frontend integration by setting up React Router.
  prefs: []
  type: TYPE_NORMAL
- en: Using React Router to implement multiple routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'React Router is a library that allows us to manage routing in our app by defining
    multiple pages on different routes, just like what we have done in Express for
    API routes, but for the frontend! Let’s set up React Router:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the **react-router-dom** library in the frontend project (the root
    of the **ch6** folder, not inside the **backend** folder):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit **src/App.jsx** and import the **createBrowserRouter** function and **RouterProvider**
    component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new **router** and define the routes. First, we’ll define an index
    route for rendering our **Blog** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, in the **App** component, replace the **<Blog>** component with **<RouterProvider>**,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the frontend by running the following command in the root of the **ch6**
    folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The blog should render the same way as before, but now, we can start defining
    new routes! You can verify that React Router is working by going to a page that
    we did not define – for example, **http://localhost:5173/test**. React Router
    will display the default 404 page, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.5 – The default 404 page provided by React Router](img/B19385_06_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – The default 404 page provided by React Router
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have successfully set up React Router, we can move on to creating
    the signup page.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the signup page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by updating our folder structure so that it supports multiple
    pages. Then, we will implement a `Signup` component and define a `/signup` route
    to link to it. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **src/pages/** folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Move the **src/Blog.jsx** file into the **src/pages/** folder. When VS Code
    asks you to update all imports, select **Yes**. Alternatively, update the import
    in **src/App.jsx**, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new **src/api/users.js** file and define an API function for the **signup**
    route, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are checking for `res.ok` here, which will be `false` when the response status
    code is an error code, such as `400`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new **src/pages/Signup.jsx** file, import the **useState**, **useMutation**,
    and **useNavigate** hooks from **react-router-dom**, as well as the **signup**
    function, and define a **Signup** component there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this component, we first create state hooks for the **username** and **password**
    fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we use the **useNavigate** hook to get a function to navigate to a different
    route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also define a **useMutation** hook to send the **signup** request. On success,
    we navigate to the **/login** route, which we will define soon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In case of an error, we could also use the `signupMutation.isError` state and
    the response from the backend to show a more nicely formatted error message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we define a function to handle the submission of the form, as we did
    for the **CreatePost** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we create a simple form to enter a username, password, and a button to
    submit the request, similar to the **CreatePost** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit **src/App.jsx** and import the **Signup** page component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new **/signup** route that points to the **Signup** page component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After defining the signup page, we still need a way to link to it. Let’s add
    the link now.
  prefs: []
  type: TYPE_NORMAL
- en: Linking to other routes using the Link component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have multiple pages in our blog app, we need to link between them.
    To do this, we can use the `Link` component provided by React Router. We could
    also use a normal link by using `<a href="">`, but that would cause a full page
    refresh. The `Link` component uses client-side routing and thus avoids doing a
    full refresh of the page. Instead, it immediately renders the new component on
    the client side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create a link from the index page to the signup page:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new **src/components/Header.jsx** file and import the **Link** component
    from **react-router-dom**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a component and return the **Link** component to define a link to the
    signup route, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit **src/pages/Blog.jsx** and import the **Header** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, render the **Header** component in the **Blog** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit **src/pages/Signup.jsx** and import the **Link** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the **Link** component to link back to the index page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we’ve successfully linked our signup page, let’s continue by creating
    the login page.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the login page and storing the JWT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have successfully defined the signup page, we can create the login
    page. However, first, we need to come up with a way to store the JWT. We shouldn’t
    store it in local storage as a potential attacker can steal the token from there
    (through, for example, script injection). In a **single-page application** (**SPA**),
    where we have no page reloads, a safe and simple way to store the token is to
    store it in the runtime using a React context. Let’s do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new **src/contexts/** folder. Inside it, create a **src/contexts/AuthContext.jsx**
    file and import the **createContext**, **useState**, and **useContext** functions
    from **react**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, define the following context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, define an **AuthContextProvider** component that provides the context
    with a state hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, define a hook to use the context with a **useState**-like API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit **src/App.jsx** and import **AuthContextProvider**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Wrap **RouterProvider** with **AuthContextProvider** to make it available to
    all pages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit **src/api/users.js** and define a new login function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copy over the **src/pages/Signup.jsx** file to a new **src/pages/Login.jsx**
    file and adjust the import and component name. Also, add a new import for the
    **useAuth** hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, edit **src/pages/Login.jsx**, add the **useAuth** hook, adjust the **signupMutation**
    to call login, set the token, and navigate to the index page upon successfully
    logging in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Adjust the submit button, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit **src/App.jsx** and import the **Login** page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, define the **/login** route, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, our signup and login pages are working properly, but we still need
    to link to the login page and show the currently logged-in user on the index page.
    Let’s do that now.
  prefs: []
  type: TYPE_NORMAL
- en: Using the stored JWT and implementing a simple logout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to check if the user is logged in already by checking
    if there is a valid JWT stored in the context. Then, we are going to use the auth
    context hook to log our user out again by simply removing the token from it. This
    is not a full logout as the JWT is still technically valid. For a full logout,
    we would have to invalidate the token in the backend (for example, by blacklisting
    that token in the authentication service database). This process is called **token
    revocation**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start using the stored JWT and implement a simple logout:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the **jwt-decode** library in the root of our project (the frontend):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit **src/components/Header.jsx** and import the **jwtDecode** function and
    the **useAuth** hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the token from the **useAuth** hook in the **Header** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a check for if the token is properly set. If it is, parse the token and
    render the user ID from it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we are only decoding the token in one place. If this functionality
    is used in multiple places, it would make sense to abstract the decoding into
    a separate hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we’ll show a button to log out here, which just resets the token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'While we’re at it, let’s also add a link to the login page to the header, if
    the user isn’t logged in yet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Congratulations! We have successfully implemented a simple JWT user authentication
    flow. However, you may have noticed that all the users in our blog appear as their
    user ID, not with their username. Let’s change that.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching the usernames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To show the usernames instead of the user IDs, we are going to create a `User`
    component that will fetch user information from an endpoint in our backend, which
    we are going to create now. For now, we will only show the username, but in the
    future, this feature could be used to fetch other information, such as the avatar
    or full name of the user.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the backend endpoint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s get started by implementing the backend endpoint for fetching user information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit **backend/src/services/users.js** and add a new function to get user information
    by **id**. As a fallback, we return the user ID if we can’t find a matching user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We specifically make sure we only return the username here, to avoid leaking
    the password or other sensitive user information!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Edit **backend/src/routes/users.js** and import the newly defined function
    there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, define a new route inside the **userRoutes** function, which will get
    a user with a specific ID. For this route, we use the plural **users** as we are
    dealing with multiple users here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we are already working on the backend, let’s also change the existing
    **author** filter so that it works with usernames. Edit **backend/src/services/posts.js**
    and import the **User** model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Refactor the **listPostsByAuthor** function by finding a user with the given
    username, then listing all posts by the user ID (if one was found):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have an endpoint that returns user information for a given user
    ID, let’s use it in the frontend!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a User component to fetch and render the username
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the frontend, we are going to create a component that will fetch and render
    the username. React Query helps us a lot here because we don’t need to worry about
    fetching the same user IDs multiple times – it will cache the result for us and
    instantly return it, instead of making another request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to implement a `User` component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to define the API function. Edit **src/api/users.js** and add
    a function to get the user info by **id**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new **src/components/User.jsx** file and import **useQuery**, **PropTypes**,
    and the API function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, define the component and get the user info via the query hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We render the username if available and fall back to the ID otherwise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we define the prop types for the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can make use of the newly created component and import it in **src/components/Header.jsx**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can edit the existing code to render the **User** component instead
    of directly rendering the user ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we repeat the same process for **src/components/Post.jsx** and import
    the **User** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we adjust the code to render the **User** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, our usernames will all render properly again, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Properly fetching and showing the username](img/B19385_06_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Properly fetching and showing the username
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that usernames show up properly, we need to do one more thing: send the
    JWT header when creating posts.'
  prefs: []
  type: TYPE_NORMAL
- en: Sending the JWT header when creating posts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating a post, we don’t need to send the author anymore. Instead, we
    need to send the JWT with the `Authentication` header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s refactor the code so that we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit **src/api/posts.jsx** and adjust the **createPost** function so that it
    accepts a JWT as the first argument, which is then passed on inside an **Authentication**
    header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit **src/components/CreatePost.jsx** and import the **useAuth** hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the JWT from the **useAuth** hook inside the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Remove* the **author** state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, *remove* the **author** state from the **createPost** function and instead
    pass in the **token** state as the first argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before rendering the component, check if the user is logged in by checking
    if a token exists. If the user is not logged in, we tell them to log in first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Remove* the following code to remove the **author** field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, creating a post works successfully again! It stores the user ID of the
    currently logged-in user in the database as the author and resolves it to the
    username when showing the post.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll learn about advanced token handling.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced token handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may have noticed that our simple authentication solution is still missing
    some features that a fully-fledged solution should have, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using asymmetric keys for the tokens so that we can verify the authenticity
    (using the public key) without exposing our secret (the private key) to all services.
    Up until now, we have been using a symmetric key, which means that we need the
    same secret to generate and verify a JWT.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing tokens in safe **httpOnly** cookies so that they can be accessed again,
    even when the page is refreshed or closed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invalidating tokens after logging out on the backend.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing these things requires a lot of effort manually, so it is best practice
    to use an authentication solution such as Auth0 or Firebase Auth. These solutions
    work similarly to our simple JWT implementation, but they provide an external
    authentication service to create and handle the tokens for us. This chapter intended
    to introduce how those providers work behind the scenes so that you can easily
    understand and integrate any of the providers as you see fit in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: So far, all users have been considered equal, with everyone being allowed to
    create posts, but only update and delete their own posts. For a public blog, it
    would be good to have a way for administrators to delete other people’s posts
    to moderate the content on the platform. A good way to add roles is to store and
    fetch them from the database. While adding roles in the JWT is technically possible,
    it has some downsides, such as the need to invalidate existing tokens and create
    a new token when the roles change.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how JWTs work in depth. First, we learned about
    the theory of authentication and JWTs, and how to manually create them. Then,
    we implemented login, signup, and authenticated routes in the backend. Next, we
    integrated these routes in the frontend by creating new pages and routing between
    them using React Router. Finally, we wrapped up this chapter by learning about
    advanced token handling and giving pointers on more things to learn about authentication
    and role management.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, [*Chapter 7*](B19385_07.xhtml#_idTextAnchor147), *Improving
    the Load Time Using Server-Side Rendering*, we are going to learn how to implement
    server-side rendering to improve the initial load time of our blog. We are already
    doing a lot of requests on the first load (fetching all blog posts, then the usernames
    of each author). We can bundle them together by doing this on the backend.
  prefs: []
  type: TYPE_NORMAL
