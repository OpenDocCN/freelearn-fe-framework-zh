- en: Our First View via Component Building
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've been working hard at framing the base of our app in [Chapter 2](part0037.html#1394Q0-289fe2426d594f99a90e4363b2c9c34d),
    *Feature Modules,* and now it's time to finally get a glimpse of what we're working
    with. This is all about getting that first view from our sketch to the mobile
    device screen.
  prefs: []
  type: TYPE_NORMAL
- en: Building views with NativeScript for Angular is not much different than view
    building for the web. We will use Angular's Component decorator to build various
    components our UI needs to achieve the desired usability we're after. Instead
    of using the HTML markup, we will be using NativeScript XML, which is an extremely
    powerful, yet simple and concise, abstraction of all native view components on
    both iOS and Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'We won''t be covering all the benefits and types of components you have access
    to here; but to learn more, we recommend any of the following books:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/web-development/getting-started-nativescript](https://www.packtpub.com/web-development/getting-started-nativescript)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.manning.com/books/nativescript-in-action](https://www.manning.com/books/nativescript-in-action)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Component decorator to compose our views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating reusable components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom view filter using Pipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the app on the iOS and Android simulators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our first view via component building
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we look at our sketch from [Chapter 1](part0023.html#LTSU0-289fe2426d594f99a90e4363b2c9c34d),
    *Get into Shape with @NgModule*, we can see a header at the top of the app, which
    will contain our app title with the record button to the right. We also see a
    listing of tracks with some player controls at the bottom. We can break these
    key elements of our UI design into essentially three primary components. One component
    is already provided by the NativeScript framework, the ActionBar, which we will
    use to represent the top header.
  prefs: []
  type: TYPE_NORMAL
- en: NativeScript provides many rich view components to build our UI. The markup
    is not HTML but rather XML with an `.html` extension, which may seem unusual.
    The reason the `.html` extension is used for XML view templates with NativeScript
    for Angular is that the custom renderer ([https://github.com/NativeScript/nativescript-angular](https://github.com/NativeScript/nativescript-angular))
    uses a DOM adapter to parse the view template. Each NativeScript XML component
    represents true native view widgets on each respective platform.
  prefs: []
  type: TYPE_NORMAL
- en: For the other two primary components, we will use Angular's Component decorator.
    It's important at this phase of the app development cycle to think about encapsulated
    pieces of UI functionality. We will encapsulate our track listing as a component
    and the player controls as another component. In this exercise, we will use an outside-in
    approach to building our UI from an abstract viewpoint down to the implementation
    details of each component.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, let''s focus on the root component in our Angular app because it
    will define the basic layout of our first view. Open `app/app.component.html`,
    clear its contents, and replace with the following to rough out the initial UI
    concept from our sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We are expressing our view with `ActionBar` and the primary layout container
    for the main view, `GridLayout`. With NativeScript, it''s important that each
    view starts with a layout container as the root node (outside of any `ActionBar`
    or `ScrollView`), much like `div` tags that are used with HTML markup. At the
    time of this writing, there are six layout containers provided by NativeScript:
    `StackLayout`, `GridLayout`, `FlexboxLayout`, `AbsoluteLayout`, `DockLayout`,
    and `WrapLayout`. For our layout here, `GridLayout` will work well.'
  prefs: []
  type: TYPE_NORMAL
- en: All about the GridLayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GridLayout is one of the three most used layouts you will use in your NativeScript
    application (the others are FlexboxLayout and StackLayout). This is the layout
    that allows you to build complex layouts easily.  To use the GridLayout is very
    much like the enhanced table in HTML.  You are basically going to want to take
    your screen area and divide your screen into the pieces you need. It will allow
    you to tell the columns (or rows) to be a percentage of the remaining width (and
    height) of the screen. The grid supports three types of values; **absolute size**,
    a percentage of **remaining space**, and **used space**.
  prefs: []
  type: TYPE_NORMAL
- en: For **absolute size**, you just type in the number. For example, `100` means
    it will use 100 dp of space.
  prefs: []
  type: TYPE_NORMAL
- en: Another name for **dp** is **dip**. They are the same. A device-independent
    pixel (also density-independent pixel, DIP, or DP) is a physical unit of measurement
    based on a coordinate system held by a computer and represents an abstraction
    of a pixel for use by an application that an underlying system then converts to
    physical pixels.
  prefs: []
  type: TYPE_NORMAL
- en: If you take the smallest iOS device supported, it has a screen width of 320dp.
    For other devices, such as tablets, some have a width of 1024 dp. So, 100 dp would
    be almost one third of an iOS phone, where it is one tenth of the screen on a
    tablet. So, this is something you need to think about when using fixed absolute
    values. It is typically better to use the used space over a fixed value, unless
    you are needing to constrain the column to a specific size.
  prefs: []
  type: TYPE_NORMAL
- en: To use **remaining space-**based values , that is, `***`, the `***` tells it
    to use the rest of the remaining space. If the columns (or rows) is set to *`*`, `*`*,
    then space will be divided into two equal remainders of space. Likewise, `rows="*,*,*,*,*"`
    will specify five equal sized rows. You can also specify things, such as `columns="2*,3*,*",`
    and you will get three columns; the first column will be two sixth of the screen,
    the second column will be three sixth of the screen, and the final column will
    be one sixth of the screen (that is, 2+3+1 = 6).  This allows you great flexibility
    in how to use the remainder of the space.
  prefs: []
  type: TYPE_NORMAL
- en: The third type of sizing is **space used**. So what happens is the content inside
    the grid is measured and then the column is assigned the size that is the max
    used in that column (or row). This is very useful when you have a grid where you
    have data but you aren't sure of the size or you don't really care; you just want
    it to look good. So, this is the auto keyword. I might have `columns="auto,auto,*,auto"`.
    This means columns 1,2, and 4 will all be automatically sized based on the content
    inside those columns; and column 3 will use whatever space is left over. This
    is very useful for laying out the entire screen or parts of the screen where you
    are looking for a certain look.
  prefs: []
  type: TYPE_NORMAL
- en: The final reason why the GridLayout is one of the best layouts is that when
    you assign items to the GridLayout, you can actually assign multiple items to
    the same rows and/or columns and you can use row or column spans to allow items
    to use more than one row and/or column.
  prefs: []
  type: TYPE_NORMAL
- en: To assign an object, you just assign it via `row="0"` and/or `col="0"` (keep
    in mind these are index-based positions). You can also use `rowSpan` and `colSpan`
    to make an element span multiple rows and/or columns. Overall, the GridLayout
    is the most versatile layout and allows you to easily create almost any layout
    you will need in your app.
  prefs: []
  type: TYPE_NORMAL
- en: Back to our layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inside the grid, we have declared a `track-list` component to represent our track
    listing, which will flex vertically, taking up all the vertical space and leaving
    only a height of 100 for `player-controls`. We indicate `track-list` as `row="0"
    col="0"`, since rows and columns are index-based. The flexible (remainder) vertical
    height is defined via the GridLayout's `*` in the rows attribute. The bottom section
    of the grid (row 1) will represent the player controls, allowing users to play/pause
    the mix and shuttle the playback position.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app's primary view defined in a rather abstract way, let's
    dive into the two custom components we need to build, `track-list` and `player-controls`.
  prefs: []
  type: TYPE_NORMAL
- en: Building TrackList component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The track list should be a listing of all the recorded tracks. Each row in the
    list should provide a single record button to re-record in addition to a name
    label for displaying the title provided by the user. It should also provide a
    switch to allow the user to solo just that particular track.
  prefs: []
  type: TYPE_NORMAL
- en: We can inject `PlayerService` and declare it `public` to allow us to bind directly
    to the service's tracks collection.
  prefs: []
  type: TYPE_NORMAL
- en: We can also mock out some of our bindings to get things rolling like the `record`
    action. For now, let's just allow a track to be passed in and let's print out
    an inspection of that track via `LogService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating `app/modules/player/components/track-list/ track-list.component.ts`(with
    a matching `.html` template):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For the view template `track-list.component.html`, we are going to employ the
    powerful `ListView` component. This widget represents the native UITableView ([https://developer.apple.com/reference/uikit/uitableview](https://developer.apple.com/reference/uikit/uitableview))
    on iOS and the native ListView ([https://developer.android.com/guide/topics/ui/layout/listview.html](https://developer.android.com/guide/topics/ui/layout/listview.html))
    on Android, offering 60 fps virtual scrolling with reused rows. Its performance
    is unparalleled on mobile devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There's a lot going on with this view template, so let's inspect it a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Since we made `playerService` `public` upon injection into our Component's constructor,
    we can bind directly to its tracks via the `ListView` items' attribute using standard
    Angular binding syntax expressed as `[items]`. This will be the collection our
    list will iterate on.
  prefs: []
  type: TYPE_NORMAL
- en: The `template` node inside allows us to encapsulate how each row of our list
    will be laid out. It also allows us to declare a variable name (`let-track`) for
    use as our iterator reference.
  prefs: []
  type: TYPE_NORMAL
- en: We start with a GridLayout, since each row will contain a Record button (to
    allow a track to be re-recorded), to which we will assign a width of 75\. This
    button will be bound to the `tap` event, which will activate a recording session
    if the user is authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will have a Label to display a user-provided name for the track, which
    we will assign `*` to ensure it expands to fill the horizontal space in between
    our left-hand and right-hand columns. We use the text attribute to bind to `track.name`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we will use `switch` to allow the user to toggle soloing the track in
    the mix. This provides the `checked` attribute to allow us to bind our `track.solo`
    property to.
  prefs: []
  type: TYPE_NORMAL
- en: Building a dialog wrapper service to prompt the user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you recall from [Chapter 1](part0023.html#LTSU0-289fe2426d594f99a90e4363b2c9c34d), *Get
    Into Shape with @NgModule*, recording is a feature that should only be available
    to authenticated users. Therefore, we will want to prompt the user with a login
    dialog when they tap the Record button on each track. If they are already logged
    in, we will want to prompt them to confirm if they want to re-record the track
    for good usability.
  prefs: []
  type: TYPE_NORMAL
- en: We could handle this dialog directly in the Component by importing a NativeScript
    dialog service that provides a consistent API across both platforms. The `ui/dialogs`
    module from the NativeScript framework ([https://docs.nativescript.org/ui/dialogs](https://docs.nativescript.org/ui/dialogs))
    is a very convenient service, allowing you to create native alerts, confirms,
    prompts, actions, and basic login dialogs. However, we may want to provide custom
    native dialog implementations on both iOS and Android down the road for an even
    nicer UX experience. There are several plugins that provide very elegant native
    dialogs, for example, [https://github.com/NathanWalker/nativescript-fancyalert](https://github.com/NathanWalker/nativescript-fancyalert).
  prefs: []
  type: TYPE_NORMAL
- en: To prepare for this enriched user experience, let's build a quick Angular service
    that we can inject and use everywhere, which will allow us to easily implement
    these niceties down the road.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this should be considered a `core` service to our app, let''s create `app/modules/core/services/dialog.service.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, this may appear incredibly wasteful! Why create a wrapper that
    provides the exact same API as a service that already exists from the NativeScript
    framework?
  prefs: []
  type: TYPE_NORMAL
- en: Yes, indeed, at this stage, it appears that way. However, we are preparing for
    greatness in flexibility and power with how we will handle these dialogs in the
    future. Stay tuned for a potential bonus chapter of material covering this fun
    and unique polish to the integration.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do before we move on to use this service is to ensure
    it is added to our core service `PROVIDERS` collection. This will make sure Angular's
    DI system knows our new service is a valid token available for injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `app/modules/core/services/index.ts` and modify as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to inject and use our new service.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating DialogService into our component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s open up `track-list.component.ts` and inject `DialogService` for use
    in our record method. We will also need to determine if the user is logged in
    to conditionally display a login dialog or confirm prompt, so let''s also inject `AuthService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The record method now first checks to see whether a user is authenticated via
    the static `AuthService.CURRENT_USER` reference, which is set when `AuthService`
    is first constructed via Angular's dependency injection upon app launch (see [Chapter
    2](part0037.html#1394Q0-289fe2426d594f99a90e4363b2c9c34d), *Feature Modules*).
  prefs: []
  type: TYPE_NORMAL
- en: If a user is authenticated, we present a confirmation dialog to ensure the action
    was intentional.
  prefs: []
  type: TYPE_NORMAL
- en: If the user is not authenticated, we want to prompt the user to log in. To reduce
    the overload for this book, we will assume the user is already registered via
    a backend API, so we won't be asking the user to register.
  prefs: []
  type: TYPE_NORMAL
- en: We need to implement the `promptLogin` method in `AuthService` to persist the
    user's login credentials, so every time they return to the app, it will automatically
    log them in. The record method now provides an extra optional argument `usernameAttempt`,
    which will be useful to repopulate the username field of the login prompt when
    reinitiating the login sequence after a user input validation error. We won't do
    a thorough validation of user input here, but we can at least do a lightweight
    check for a valid email.
  prefs: []
  type: TYPE_NORMAL
- en: In your own app, you should probably do more user input validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To maintain a clean separation of concerns, open `app/modules/core/services/auth.service.ts`
    to implement `promptLogin`. Here''s the entire service with the modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We use the `dialogService.login` method to open a native login dialog, allowing
    the user to input a username and password. Once they choose ok, we do minimal
    validation of the input and, if successful, proceed to persist the username and
    password via `DatabaseService`. Otherwise, we simply alert the user of an error
    and reject our promise, passing along the username that was entered. This allows
    us to help the user out by redisplaying the login dialog with the failed username
    they entered, so they can more easily make corrections.
  prefs: []
  type: TYPE_NORMAL
- en: With these service level details complete, the `track-list` component is looking
    pretty good. However, there is one additional step we should take while we are
    working on this. If you recall, our TrackModel contains an order property that
    will help the user order the tracks in any way they'd like for convenience.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Angular Pipe - OrderBy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular provides the Pipe decorator for ease in creating view filters. Let''s
    start by showing how we will use this in the view. You can see that it appears
    very similar to a command-line pipe used in Unix shell scripts; hence, it''s named:
    `Pipe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will take the `playerService.tracks` collection and ensure it is ordered
    via the `order` property of each `TrackModel` for the view display.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we may want to use this anywhere in our app views, let''s add this pipe
    as part of `CoreModule`. Create `app/modules/core/pipes/order-by.pipe.ts` and
    here is how we will implement `OrderByPipe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We won''t go into too much detail with what is going on here, since this is
    pretty typical in JavaScript to order a collection. To finish this off, ensure
    `app/modules/core/pipes/index.ts` follows our standard convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, import the preceding collection for use with `app/modules/core/core.module.ts`.
    Here is the full file with all the modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Since pipes are view level implementations, we ensure they are added as part
    of the `exports` collection to allow other modules to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we were to run our app at this point, you would notice that our `OrderBy`
    pipe used on our `track-list.component.html` view template would *NOT* work!
  prefs: []
  type: TYPE_NORMAL
- en: Angular modules compile in isolation of one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a critical point to understand: Angular compiles `PlayerModule` that
    declares `TrackListComponent`unto itself in an isolated sense. Since we declared `OrderByPipe`
    as part of `CoreModule` and `PlayerModule` has no dependency (at the moment) on
    `CoreModule`, the `TrackListComponent` gets compiled with no awareness of `OrderByPipe`!
    You would end up seeing this error generated in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To remedy this, we want to make sure `PlayerModule` is aware of view-related declarations
    (such as pipes or other components) from `CoreModule` by ensuring `CoreModule`
    is added as part of the `imports` collection on `PlayerModule`. This also provides
    us with one additional convenience. If you notice, `CoreModule` specifies `NativeScriptModule`
    as an export, which means any module that imports `CoreModule` will inherently
    get `NativeScriptModule` along with it. Here are the final modifications to `PlayerModule`
    to allow everything to work together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We can now move on to the `player-controls` component.
  prefs: []
  type: TYPE_NORMAL
- en: Building PlayerControls component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our player controls should contain a play/pause toggle button for the entire
    mix. It should also present a slider control to allow us to skip ahead and rewind our
    playback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create `app/modules/player/components/player-controls/player-controls.component.html`(with
    a matching `.ts`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We start with a single row `GridLayout` with an explicit 100 height. Then, the
    first column will be constrained to 75 wide to accommodate our play/pause toggle
    button. Then, the second column will take up the rest of the horizontal space,
    indicated with `*` with the `Slider` component. This component is provided by
    the NativeScript framework and allows us to bind the `maxValue` attribute to the
    total duration of our mix as well as a value to `currentTime` of the playback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, for `player-controls.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: For now, we have placed `currentTime` and `duration` directly on the component,
    however, we will refactor those into  `PlayerService` later. Eventually, all of
    the state related to our player will come from `PlayerService` when we implement
    plugins to handle our audio in subsequent chapters. The `togglePlay` method also
    just stubs out some general behavior, toggling the text of our button to Play
    or Stop.
  prefs: []
  type: TYPE_NORMAL
- en: Quick preview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we will take a quick look at what we have built so far. Currently,
    our player service returns an empty list of tracks. To see the results, we should
    add some dummy data to it. For example, in `PlayerService`, we could add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Don't be surprised if it's not pretty; we'll cover that in the next chapter.
    We also won't cover all the runtime commands available to us yet; we'll cover
    that thoroughly in [Chapter 6](part0072.html#24L8G0-289fe2426d594f99a90e4363b2c9c34d), *Running
    the app on iOS and Android*.
  prefs: []
  type: TYPE_NORMAL
- en: Preview  on iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will have to be on a Mac with XCode installed to preview the iOS app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This should launch the iOS Simulator and you should see the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Preview on Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will have to have the AndroidSDKk and tools installed to preview on an
    Android emulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This should launch an Android emulator and you should see the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! We have our first view.  Well hey, no one said it would be
    pretty yet!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have kicked off Part 2 with the component building, where we have laid out
    our root component `app.component.html` to house our primary view, where you learned
    about `GridLayout`, a very useful layout container.
  prefs: []
  type: TYPE_NORMAL
- en: Angular's Component decorator allowed us to easily build `TrackListComponent`
    as well as `PlayerControlsComponent`.We also learned how to build an Angular `Pipe`
    to aid our view's ability to keep our track list in order. Angular's `NgModule` taught
    us we need to ensure any view-related declarations needed for any components are imported
    properly. This Angular design pattern helps maintain module isolation as standalone
    units of code that can be intermixed by importing modules into each other.
  prefs: []
  type: TYPE_NORMAL
- en: We also enhanced a fair share of our services to support some of the usability
    we desire with our components.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we were able to take a quick peek at what we were building. Even though
    it's not at all pretty at this point, we can see things coming together.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](part0059.html#1O8H60-289fe2426d594f99a90e4363b2c9c34d), *A prettier
    view with CSS*, you will learn how to use CSS to bring out the pretty from our
    views.
  prefs: []
  type: TYPE_NORMAL
