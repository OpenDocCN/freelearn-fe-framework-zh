- en: Chapter 4.  Personal Trainer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 个人教练
- en: Building Personal Trainer The 7 Minute Workout app has been an excellent opportunity
    for us to learn about Angular. Working through the app, we have covered a number
    of Angular constructs. Still, there are areas such as Angular form support and
    client server communication that remain unexplored. This is partially due to the
    fact that 7 Minute Workout from a functional standpoint had limited touchpoints
    with the end user. Interactions were limited to starting, stopping, and pausing
    the workout. Also, the app neither consumes, nor produces any data (except workout
    history).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 构建个人教练 7分钟锻炼应用程序为我们提供了学习Angular的绝佳机会。通过这个应用程序，我们已经涵盖了许多Angular构造。然而，仍有一些领域，如Angular表单支持和客户端服务器通信，尚未被探索。这部分是因为从功能角度来看，“7分钟锻炼”与最终用户的接触点有限。交互仅限于开始、停止和暂停锻炼。此外，该应用程序既不消耗数据，也不生成任何数据（除了锻炼历史记录）。
- en: In this chapter, we plan to delve deeper into one of the two aforementioned
    areas, Angular form support. Keeping up with the health and fitness theme (no
    pun intended), we plan to build a *Personal Trainer* app. The new app will be
    an extension to *7 Minute Workout*, allowing us to build our own customized workout
    plans that are not limited to the *7 Minute Workout* plans that we already have.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们计划深入研究前面提到的两个领域之一，即Angular表单支持。为了跟上健康和健身主题（无意冒犯），我们计划构建一个“个人教练”应用程序。这个新应用程序将是“7分钟锻炼”的延伸，使我们能够构建自己定制的锻炼计划，而不仅限于我们已经拥有的“7分钟锻炼”计划。
- en: This chapter is dedicated to understanding Angular forms and how to put them
    to use as we build out our *Personal Trainer* app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于理解Angular表单以及在构建“个人教练”应用程序时如何使用它们。
- en: 'The topics that we will cover in this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主题如下：
- en: '**Defining Personal Trainer requirements**: Since we are building a new app
    in this chapter, we start with defining the app requirements.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义个人教练需求：由于本章我们正在构建一个新应用程序，因此我们首先要定义应用程序的需求。
- en: '**Defining the Personal Trainer model**: Any app design starts with defining
    its model. We define the model for *Personal Trainer*, which is similar to the
    *7 Minute Workout* app built earlier.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义个人教练模型：任何应用程序设计都始于定义其模型。我们为“个人教练”定义模型，这与之前构建的“7分钟锻炼”应用程序类似。
- en: '**Defining the Personal Trainer layout and navigation**: We define the layout,
    navigation patterns, and views for the new app. We also set up a navigation system
    that is integrated with Angular routes and the main view.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义个人教练布局和导航：我们为新应用程序定义布局、导航模式和视图。我们还设置了一个与Angular路由和主视图集成的导航系统。
- en: '**Adding support pages**: Before we focus on the form capability and build
    a Workout component, we build some supporting components for workout and exercise
    listing.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加支持页面：在我们专注于表单功能并构建一个锻炼组件之前，我们将为锻炼和锻炼列表构建一些支持组件。
- en: '**Defining the Workout Builder component structure**: We lay out the Workout
    Builder components that we will use to manage workouts.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义锻炼构建器组件结构：我们布置了将用于管理锻炼的锻炼构建器组件。
- en: '**Building forms**: We make extensive use of HTML forms and input elements
    to create custom workouts. In the process, we will learn more about Angular Forms.
    The concepts that we cover include:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建表单：我们大量使用HTML表单和输入元素来创建自定义锻炼。在这个过程中，我们将更多地了解Angular表单。我们涵盖的概念包括：
- en: '**Form types**: The two types of form that can be built with Angular are template-driven
    and model-driven. We''re working with both template-driven and model-driven forms
    in this chapter.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单类型：使用Angular可以构建两种类型的表单，即模板驱动型和模型驱动型。本章我们将使用这两种类型的表单。
- en: '**ngModel**: This provides two-way databinding for template driven forms and
    allows us to track changes and validate form input.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ngModel**：这为模板驱动的表单提供了双向数据绑定，并允许我们跟踪更改和验证表单输入。'
- en: '**Model Driven Form Controls**: These include the form builder, form control,
    form group, and form array. These are used to construct forms programmatically.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型驱动表单控件**：这些包括表单构建器、表单控件、表单组和表单数组。这些用于以编程方式构建表单。'
- en: '**Data formatting**: These are the CSS classes that permit us to style our
    feedback to the user.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据格式化**：这些是允许我们为用户样式化反馈的CSS类。'
- en: '**Input validation**: We will learn about the validation capabilities of Angular
    forms.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入验证**：我们将了解Angular表单的验证能力。'
- en: The Personal Trainer app - the problem scope
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个人教练应用 - 问题范围
- en: The *7 Minute Workout* app is good, but what if we could create an app that
    allows us to build more such workout routines customized to our fitness level
    and intensity requirements? With this flexibility, we can build any type of workout
    whether it is 7 minutes, 8 minutes, 15 minutes, or any other variations. The opportunities
    are limitless.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*7分钟锻炼*应用程序很不错，但如果我们能够创建一个允许我们构建更多这样的锻炼计划，以适应我们的健身水平和强度要求的应用程序呢？有了这种灵活性，我们可以构建任何类型的锻炼，无论是7分钟、8分钟、15分钟还是其他变化。机会是无限的。'
- en: With this premise, let's embark on the journey of building our own *Personal
    Trainer* app that helps us to create and manage training/workout plans according
    to our specific needs. Let's start with defining the requirements for the app.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个前提，让我们踏上建立我们自己的*个人教练*应用程序的旅程，这将帮助我们根据我们特定的需求创建和管理训练/锻炼计划。让我们从定义应用程序的要求开始。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The new *Personal Trainer* app will now encompass the existing *7 Minute Workout*
    app. The component that supports workout creation will be referred to as `Workout
    Builder`. The *7 Minute Workout* app itself will also be referred to as `Workout
    Runner`. In the coming chapters, we will fix *Workout Runner*, allowing it to
    run any workout created using *Workout Builder*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 新的*个人教练*应用现在将包括现有的*7分钟锻炼*应用程序。支持锻炼创建的组件将被称为“锻炼构建器”。*7分钟锻炼*应用程序本身也将被称为“锻炼运行器”。在接下来的章节中，我们将修复*锻炼运行器*，使其能够运行使用*锻炼构建器*创建的任何锻炼。
- en: Personal Trainer requirements
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个人教练要求
- en: 'Based on the notion of managing workouts and exercises, these are some of the
    requirements that our *Personal Trainer* app should fulfill:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 基于管理锻炼和练习的概念，这些是我们的*个人教练*应用程序应该满足的一些要求：
- en: The ability to list all available workouts.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有能力列出所有可用的锻炼。
- en: 'The ability to create and edit a workout. While creating and editing a workout,
    it should have:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有能力创建和编辑锻炼。在创建和编辑锻炼时，它应该具有：
- en: The ability to add workout attributes including name, title, description, and
    rest duration
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有能力添加包括名称、标题、描述和休息时间在内的锻炼属性
- en: The ability to add/remove multiple exercises for workouts
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有能力为锻炼添加/移除多个练习
- en: The ability to order exercises in the workout
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有能力对锻炼进行排序
- en: The ability to save workout data
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有能力保存锻炼数据
- en: The ability to list all available exercises.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有能力列出所有可用的练习。
- en: 'The ability to create and edit an exercise. While creating and editing an exercise,
    it should have:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有能力创建和编辑练习。在创建和编辑练习时，它应该具有：
- en: The ability to add exercise attributes such as name, title, description, and
    procedure
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有能力添加练习属性，如名称、标题、描述和步骤
- en: The ability to add pictures for the exercise
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有能力为练习添加图片
- en: The ability to add related videos for the exercise
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为练习添加相关视频的能力
- en: The ability to add audio clues for the exercise
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有能力为练习添加音频提示
- en: All the requirements seem to be self-explanatory; hence, let's start with the
    design of the application. As customary, we first need to think about the model
    that can support these requirements.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所有要求似乎都是不言自明的；因此，让我们从应用程序的设计开始。按照惯例，我们首先需要考虑可以支持这些要求的模型。
- en: The Personal Trainer model
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个人教练模型
- en: No surprises here! The Personal Trainer model itself was defined when we created
    the *7 Minute Workout* app. The two central concepts of workout and exercise hold
    good for *Personal Trainer* too.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么意外！个人教练模型本身是在我们创建*7分钟锻炼*应用程序时定义的。锻炼和练习的两个核心概念对*个人教练*也适用。
- en: The only problem with the existing workout model is that it is in the directory
    for workout-runner. This means that in order to use it, we will have to import
    it from that directory. It makes more sense to move the model into the `service`
    folder so that it is clear that it can be used across features.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的锻炼模型的唯一问题是它位于锻炼运行者目录中。这意味着为了使用它，我们必须从该目录导入它。将模型移动到`service`文件夹中更有意义，这样可以清楚地表明它可以跨功能使用。
- en: Let's understand how we can share the model across the application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解如何在整个应用程序中共享模型。
- en: Sharing the workout model
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分享锻炼模型
- en: We are going to share the workout model as a **service**. As mentioned in the
    previous chapter, a **service** has no particular definition. Basically, it is
    a class that holds functionality that might be useful to have in multiple locations
    throughout our application. Since it will be used in both Workout Runner and Workout
    Builder, our workout model fits that definition. There is not much ceremony involved
    in making our model into a **service** - so let's get started by doing that.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分享锻炼模型作为**服务**。如前一章所述，**服务**没有特定的定义。基本上，它是一个保存功能的类，可能在我们的应用程序中的多个位置有用。由于它将在Workout
    Runner和Workout Builder中使用，我们的锻炼模型符合该定义。将我们的模型转换为**服务**并不需要太多仪式感 - 所以让我们开始做吧。
- en: First, download the base version of the new *Personal Trainer* app from `checkpoint4.1`
    in the GitHub repository for the book.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从GitHub存储库中的`checkpoint4.1`下载新*个人教练*应用程序的基本版本。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code is available on GitHub [https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample)
    for everyone to download. Checkpoints are implemented as branches in GitHub. The
    branch to download is as follows: **GitHub Branch: checkpoint4.1**. If you are
    not using Git, download the snapshot of Checkpoint 4.1 (a ZIP file) from the following
    GitHub location: [https://github.com/chandermani/angular2byexample/archive/checkpoint4.1.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint4.1.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可在GitHub上下载[https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample)。检查点在GitHub中作为分支实现。要下载的分支如下：**GitHub分支：checkpoint4.1**。如果您不使用Git，请从以下GitHub位置下载Checkpoint
    4.1的快照（ZIP文件）：[https://github.com/chandermani/angular2byexample/archive/checkpoint4.1.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint4.1.zip)。首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: 'This code has the complete *7 Minute Workout (Workout Runner)* app. We have
    added some more content to support the new *Personal Trainer* app. Some of the
    relevant updates are:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码包含完整的*7分钟锻炼（锻炼运行者）*应用程序。我们添加了一些内容来支持新的*个人教练*应用程序。一些相关的更新包括：
- en: Adding the new `WorkoutBuilder` feature. This feature contains implementations
    pertaining to *Personal Trainer*.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新的“WorkoutBuilder”功能。此功能包含与*个人教练*相关的实现。
- en: Updating the layout and styles of the app.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新应用程序的布局和样式。
- en: Adding some components and HTML templates with placeholder content for *Personal
    Trainer* in the `workout-builder` folder under `trainer/src/components`.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`trainer/src/components`文件夹下的`workout-builder`文件夹中添加一些组件和带有*个人教练*占位内容的HTML模板。
- en: Defining a new route to the `WorkoutBuilder` feature. We will cover setting
    up this route within the app in the coming section.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个新的路由到`WorkoutBuilder`功能。我们将在接下来的部分中介绍如何设置这个路由。
- en: Let's get back to defining the model.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到定义模型。
- en: The model as a service
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型作为一个服务
- en: In the last chapter, we dedicated a complete section to learning about Angular
    services, and one thing we found out was that services are useful for sharing
    data across controllers and other Angular constructs. We essentially do not have
    any data but a blueprint that describes the shape of the data. The plan, hence,
    is to use services to expose the model structure. Open the `model.ts` file present
    in the `services` folder under `app`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们专门学习了关于Angular服务的一个完整部分，我们发现服务对于在控制器和其他Angular构造之间共享数据非常有用。实际上，我们没有任何数据，只有描述数据形状的蓝图。因此，我们计划使用服务来公开模型结构。打开`app`文件夹下的`services`文件夹中的`model.ts`文件。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `model.ts` file has been moved into the `services` folder as the service
    is shared across the *Workout Builder* and *Workout Runner* apps. Note: in `checkpoint4.1`
    we have updated the import statements in `workout-runner.component.ts`, `workout-audio.component.ts`
    and `workout-audio0.component.ts` in the `workout-runner` folder under `trainer/src/components`
    to reflect this change.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`model.ts`文件已经移动到`services`文件夹中，因为该服务在*Workout Builder*和*Workout Runner*应用程序之间共享。注意：在`trainer/src/components`文件夹下的`workout-runner`文件夹中，我们已经更新了`workout-runner.component.ts`，`workout-audio.component.ts`和`workout-audio0.component.ts`中的导入语句，以反映这一变化。'
- en: In [Chapter 2](part0028.xhtml#QMFO1-edca168d36254bda8a21f611a95615c3 "Chapter 2. 
    Building Our First App - 7 Minute Workout"), *Building Our First App - 7 Minute
    Workout*, we reviewed the class definitions in the model file: `Exercise`, `ExercisePlan`,
    and `WorkoutPlan`. As we then mentioned, these three classes constitute our base
    model. We will now start using this base model in our new app.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0028.xhtml#QMFO1-edca168d36254bda8a21f611a95615c3 "第2章。构建我们的第一个应用
    - 7分钟锻炼")中，*构建我们的第一个应用 - 7分钟锻炼*，我们回顾了模型文件中的类定义：`Exercise`，`ExercisePlan`和`WorkoutPlan`。正如我们之前提到的，这三个类构成了我们的基本模型。我们现在将开始在我们的新应用中使用这个基本模型。
- en: That's all on the model design front. The next thing we are going to do is define
    the structure for the new app.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于模型设计的全部内容。接下来，我们要做的是定义新应用的结构。
- en: The Personal Trainer layout
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个人教练布局
- en: 'The skeleton structure of *Personal Trainer* looks like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*个人教练*的骨架结构如下：'
- en: '![The Personal Trainer layout](../Images/image00452.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![个人教练布局](../Images/image00452.jpeg)'
- en: 'This has the following components:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这有以下组件：
- en: '**Top Nav**: This contains the app branding title and history link.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶部导航**：这包含应用品牌标题和历史链接。'
- en: '**Sub Nav**: This has navigation elements that change based on the active component.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子导航**：这里有导航元素，根据活动组件的不同而变化。'
- en: '**Left Nav**: This contains elements that are dependent upon the active component.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左侧导航**：这包含依赖于活动组件的元素。'
- en: '**Content Area**: This is where the main view for our component will display.
    This is where most of the action happens. We will create/edit exercises and workouts
    and show a list of exercises and workouts here.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容区域**：这是我们组件的主视图显示的地方。这里发生了大部分的动作。我们将在这里创建/编辑练习和锻炼，并显示练习和锻炼的列表。'
- en: Look at the source code files; there is a new folder `workout-builder` under
    `trainer/src/components`. It has files for each component that we described previously,
    with some placeholder content. We will be building these components as we go along
    in this chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 查看源代码文件；在`trainer/src/components`下有一个新的文件夹`workout-builder`。它有我们之前描述的每个组件的文件，带有一些占位内容。我们将在本章节中逐步构建这些组件。
- en: However, we first need to link up these components within the app. This requires
    us to define the navigation patterns for the Workout Builder app and accordingly
    define the app routes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们首先需要在应用程序中连接这些组件。这要求我们定义Workout Builder应用程序的导航模式，并相应地定义应用程序路线。
- en: Personal Trainer navigation with routes
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带路由的私人教练
- en: 'The navigation pattern that we plan to use for the app is the list-detail pattern.
    We will create list pages for the exercises and workouts available in the app.
    Clicking on any list item takes us to the detailed view for the item where we
    can perform all CRUD operations (create/read/update/delete). The following routes
    adhere to this pattern:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划在应用程序中使用的导航模式是列表-详细信息模式。我们将为应用程序中可用的练习和锻炼创建列表页面。单击任何列表项将带我们到该项的详细视图，我们可以在那里执行所有CRUD操作（创建/读取/更新/删除）。以下路线符合此模式：
- en: '| **Route** | **Description** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **路线** | **描述** |'
- en: '| `/builder` | This just redirects to **builder/workouts**. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `/builder` | 这只是重定向到**builder/workouts**。 |'
- en: '| `/builder/workouts` | This lists all the available workouts. It is the landing
    page for *Workout Builder*. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `/builder/workouts` | 这列出了所有可用的锻炼。这是*Workout Builder*的登陆页面。 |'
- en: '| `/builder/workout/new` | This creates a new workout. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `/builder/workout/new` | 这将创建一个新的锻炼。 |'
- en: '| `/builder/workout/:id` | This edits an existing workout with the specific
    ID. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `/builder/workout/:id` | 这将编辑具有特定ID的现有锻炼。 |'
- en: '| `/builder/exercises` | This lists all the available exercises. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `/builder/exercises` | 这列出了所有可用的练习。 |'
- en: '| `/builder/exercise/new` | This creates a new exercise. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `/builder/exercise/new` | 这将创建一个新的练习。 |'
- en: '| `/builder/exercise/:id` | This edits an existing exercise with the specific
    ID. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `/builder/exercise/:id` | 这将编辑具有特定ID的现有练习。 |'
- en: Getting started
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始
- en: At this point, if you look at the route configuration in `app.routes.ts` in
    the `src/components/app` folder, you will find one new route definition - `builder`
    **:**
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，如果您查看`src/components/app`文件夹中的`app.routes.ts`中的路由配置，您将找到一个新的路由定义 - `builder`
    **:**
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: And if you run the application, you will see that the start screen shows another
    link: **Create a Workout:**
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行应用程序，您将看到启动屏幕显示另一个链接：**创建一个锻炼：**
- en: '![Getting started](../Images/image00453.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![入门](../Images/image00453.jpeg)'
- en: 'Behind the scenes, we have added another router link for this link into `start.html`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，我们为此链接添加了另一个路由器链接到`start.html`：
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And if you click on this link, you will be taken to the following view:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击此链接，您将进入以下视图：
- en: '![Getting started](../Images/image00454.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![入门](../Images/image00454.jpeg)'
- en: 'Again behind the scenes, we have added a `WorkoutBuilderComponent` in the `trainer/src/components/workout-builder`
    folder with the following related template in `workout-builder.component.html`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 再次在幕后，我们在`trainer/src/components/workout-builder`文件夹中添加了一个`WorkoutBuilderComponent`，并在`workout-builder.component.html`中添加了以下相关模板：
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And this view is displayed on the screen under the header using the router
    outlet in our `app.component.ts` view template:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 并且这个视图在`app.component.ts`的视图模板中使用路由器出口显示在屏幕上的标题下：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have wrapped this component in a new module named `workout-builder.module.ts:`
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将此组件包装在一个名为`workout-builder.module.ts`的新模块中：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The only thing that might look different here from the other modules that we
    have created is that we are importing `CommonModule` instead of `BrowserModule`.
    This avoids our importing the whole of `BrowserModule` a second time, which would
    generate an error when we get to implementing lazy loading for this module.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一可能与我们创建的其他模块不同的地方是，我们导入的是`CommonModule`而不是`BrowserModule`。这样可以避免第二次导入整个`BrowserModule`，这样在实现此模块的延迟加载时会生成错误。
- en: 'Finally, we have added an import for this module to `app.module.ts`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经在`app.module.ts`中为这个模块添加了一个导入：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So nothing surprising here. These are the basic component building and routing
    patterns that we introduced in the previous chapters. Following these patterns,
    we should now begin to think about adding the additional navigation outlined previously
    for our new feature. However, before we jump into doing that, there are a couple
    of things we need to consider.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里没有什么令人惊讶的。这些是我们在前几章介绍的基本组件构建和路由模式。遵循这些模式，我们现在应该开始考虑为我们的新功能添加先前概述的额外导航。然而，在我们开始做这件事之前，有一些事情我们需要考虑。
- en: First, if we start adding our routes to the `app.routes.ts` file then the number
    of routes stored there will grow. These new routes for *Workout Builder* will
    also be intermixed with the routes for *Workout Runner.* While the number of routes
    we are now adding might seem insignificant, over time this could get to be a maintenance
    problem.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果我们开始将路由添加到`app.routes.ts`文件中，那么存储在那里的路由数量将增加。*Workout Builder*的这些新路由也将与*Workout
    Runner*的路由混合在一起。虽然我们现在添加的路由数量似乎微不足道，但随着时间的推移，这可能会成为一个维护问题。
- en: Second, we need to take into consideration that our application now consists
    of two features - *Workout Runner* and *Workout Builder*. We should be thinking
    about ways to separate these features within our application so that they can
    be developed independently of each other.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要考虑到我们的应用程序现在包括两个功能 - *Workout Runner*和*Workout Builder*。我们应该考虑如何在应用程序中分离这些功能，以便它们可以独立开发。
- en: Put differently, we want **loose-coupling** between the features that we build.
    Using this pattern allows us to swap out a feature within our application without
    affecting the other features. For example, somewhere down the line we may want
    to convert the *Workout Runner* into a mobile app but leave the *Workout Builder*
    intact as a web-based application.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们希望在构建的功能之间实现**松耦合**。使用这种模式允许我们在不影响其他功能的情况下替换应用程序中的功能。例如，将来我们可能希望将*Workout
    Runner*转换为移动应用程序，但保持*Workout Builder*作为基于Web的应用程序不变。
- en: Going back to the first chapter, we emphasized that this ability to separate
    our components from each other is one of the key advantages of using the **component
    design pattern** that Angular implements. Fortunately, Angular's router gives
    us the ability to separate out our routing into logically organized **routing
    configurations** that closely match the features in our application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 回到第一章，我们强调了将组件彼此分离的能力是Angular实现的**组件设计模式**的关键优势之一。幸运的是，Angular的路由器使我们能够将我们的路由分离成逻辑组织良好的**路由配置**，这与我们应用程序中的功能密切匹配。
- en: In order to accomplish this separation, Angular allows us to use **child routing**
    where we can isolate the routing for each of our features. In this chapter, we
    will use **child routing** to separate out the routing for *Workout Builder*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种分离，Angular允许我们使用**子路由**，在这里我们可以隔离每个功能的路由。在本章中，我们将使用**子路由**来分离*Workout
    Builder*的路由。
- en: Introducing child routes to Workout Builder
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向Workout Builder引入子路由
- en: Angular supports our goal of isolating the routing for our new *Workout Builder*
    by providing us with the ability to create a hierarchy of router components within
    our application. We currently have just one router component, which is in the
    root component of our application. But Angular allows us to add what are called
    **child router components** under our root component. This means that one feature
    can be ignorant of the routes the other is using and each is free to adapt its routes
    in response to changes within that feature.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Angular支持我们隔离新的*Workout Builder*路由的目标，通过为我们提供在应用程序中创建路由组件层次结构的能力。目前，我们只有一个路由组件，它位于应用程序的根组件中。但是Angular允许我们在根组件下添加所谓的**子路由组件**。这意味着一个功能可以不知道另一个功能正在使用的路由，并且每个功能都可以自由地根据该功能内部的变化来调整其路由。
- en: 'Getting back to our application, we can use **child routing** in Angular to
    match the routing for the two features of our application with the code that will
    be using them. So in our application we can structure the routing into the following
    routing hierarchy for our *Workout Builder* (at this point, we are leaving the
    *Workout Runner* as-is to show the before and after comparison):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的应用程序，我们可以使用Angular中的**子路由**来匹配我们应用程序的两个功能的路由与将使用它们的代码。因此，在我们的应用程序中，我们可以将路由结构化为以下*Workout
    Builder*的路由层次结构（在这一点上，我们将*Workout Runner*保持不变，以显示之前和之后的比较）：
- en: '![Introducing child routes to Workout Builder](../Images/image00455.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: 介绍将子路由引入到Workout Builder中
- en: With this approach, we can create a logical separation of our routes by feature
    and make them easier to manage and maintain.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方法，我们可以通过功能创建路由的逻辑分离，并使其更易于管理和维护。
- en: So let's get started by adding child routing to our application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们开始通过向我们的应用程序添加子路由来开始。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'From this point on in this section, we''ll be adding to the code that we downloaded
    earlier for this chapter. If you want to see the complete code for this next section,
    you can download it from checkpoint 4.2 in the GitHub repository. If you want
    to work along with us as we build out the code for this section, still be sure
    to add the changes in `app.css` in the `trainer/static/css` folder that are part
    of this checkpoint since we won''t be discussing them here. Also be sure and add
    the files for exercise(s) and workout(s) from the `trainer/src/components/workout-builder`
    folder in the repository. At this stage these are just stub files, which we will
    implement later in this chapter. However, you will need these stub files here
    in order to implement navigation for the *Workout Builder* module. The code is
    available for everyone to download on GitHub at [https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample).
    Checkpoints are implemented as branches in GitHub. The branch to download is as
    follows: **GitHub Branch: checkpoint4.2**. . If you are not using Git, download
    the snapshot of Checkpoint 4.2 (a ZIP file) from the following GitHub location:
    [https://github.com/chandermani/angular2byexample/archive/checkpoint4.2.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint4.2.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，在本节中，我们将继续添加我们在本章早期下载的代码。如果您想查看本节的完整代码，可以从GitHub存储库的检查点4.2中下载。如果您想与我们一起构建本节的代码，请确保在`trainer/static/css`文件夹中添加`app.css`中的更改，因为我们不会在这里讨论它们。还要确保从存储库的`trainer/src/components/workout-builder`文件夹中添加exercise(s)和workout(s)的文件。在这个阶段，这些只是存根文件，我们将在本章后面实现它们。但是，您需要这些存根文件来实现*Workout
    Builder*模块的导航。该代码可供所有人在GitHub上下载：[https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample)。检查点在GitHub中作为分支实现。要下载的分支如下：**GitHub分支：checkpoint4.2**。如果您不使用Git，请从以下GitHub位置下载Checkpoint
    4.2的快照（ZIP文件）：[https://github.com/chandermani/angular2byexample/archive/checkpoint4.2.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint4.2.zip)。首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: Adding the child routing component
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加子路由组件
- en: 'In the `workout-builder` directory, add a new TypeScript file named `workout-builder.routes.ts`
    with the following imports:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在`workout-builder`目录中，添加一个名为`workout-builder.routes.ts`的新的TypeScript文件，其中包含以下导入：
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we are importing the components we just mentioned; they will
    be part of our *Workout Builder* (exercise, exercises, workout, and workouts).
    Along with those imports, we are also importing `ModuleWithProviders` from the
    Angular core module and `Routes` and `RouterModule` from the Angular router module.
    These imports will give us the ability to add and export child routes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们正在导入我们刚刚提到的组件；它们将成为我们的*Workout Builder*（exercise，exercises，workout和workouts）的一部分。除了这些导入之外，我们还从Angular核心模块导入`ModuleWithProviders`，从Angular路由器模块导入`Routes`和`RouterModule`。这些导入将使我们能够添加和导出子路由。
- en: 'Then add the following route configuration to the file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将以下路由配置添加到文件中：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first configuration, path: ''builder'', sets the base URL for the child
    routes so that each of the child routes prepends it. The next configuration identifies
    the `WorkoutBuilder` component as the feature area root component for the child
    components in this file. This means it will be the component in which each of
    the child components is displayed using `router-outlet`. The final configuration
    is a list of one or more children that defines the routing for the child components.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '第一个配置，path: ''builder''，设置了子路由的基本URL，以便每个子路由都会在其前面添加它。下一个配置将`WorkoutBuilder`组件标识为该文件中子组件的功能区根组件。这意味着它将是使用`router-outlet`显示每个子组件的组件。最后一个配置是一个或多个子组件的列表，定义了子组件的路由。'
- en: 'One thing to note here is that we have set up `Workouts` as the default for
    the child routes with the following configuration:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，我们已经将`Workouts`设置为子路由的默认配置：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This configuration indicates that if someone navigates to `builder`, they will
    be redirected to the `builder/workouts` route. The `pathMatch: ''full''` setting
    means that the match will only be made if the path after workout/builder is an
    empty string. This prevents the redirection from happening if the routes are something
    else such as `workout/builder/exercises` or any of the other routes we have configured
    within this file.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '这个配置表示，如果有人导航到`builder`，他们将被重定向到`builder/workouts`路线。`pathMatch: ''full''`设置意味着只有在workout/builder后的路径为空字符串时才会进行匹配。这可以防止在路由为其他内容时发生重定向，比如`workout/builder/exercises`或者我们在这个文件中配置的其他路由。'
- en: 'Finally, add the following `export` statement:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加以下`export`语句：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This export registers our child routes with the router and is very similar
    to the one in app.routes.ts, with one difference: instead of `RouterModule.forRoot`
    we are using `RouterModule.forChild`. The reason for the difference may seem self-explanatory: we
    are creating child routes, not the routes in the root of the application, and
    this is how we signify that. Under the hood, however, there is a significant difference.
    This is because we cannot have more than one router service active in our application.
    `forRoot` creates the router service but `forChild` does not.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个导出将我们的子路由注册到路由器中，与app.routes.ts中的类似，只有一个区别：我们使用的是`RouterModule.forChild`而不是`RouterModule.forRoot`。这种差异的原因似乎很明显：我们正在创建子路由，而不是应用程序根目录中的路由，这是我们表示的方式。然而，在底层，这有着重大的区别。这是因为我们的应用程序中不能有多个路由器服务。`forRoot`创建路由器服务，但`forChild`不会。
- en: Updating the WorkoutBuilder component
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新WorkoutBuilder组件
- en: 'We next need to update the `WorkoutBuilder` component to support our new child
    routes. To do so, change the `@Component` decorator for Workout Builder to:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新`WorkoutBuilder`组件以支持我们的新子路由。为此，将Workout Builder的`@Component`装饰器更改为：
- en: Remove the `selector`
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除`selector`
- en: Replace the reference to a `templateUrl` with a `template` reference
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用`template`引用替换对`templateUrl`的引用
- en: Add a `<sub-nav>` custom element to the template
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板中添加一个`<sub-nav>`自定义元素
- en: Add a `<router-outlet>` tag to the template
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板中添加一个`<router-outlet>`标签
- en: 'The decorator should now look like the following:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器现在应该如下所示：
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are removing the selector because the `WorkoutBuilderComponent` will not
    be embedded in the application root: `app.component.ts`. Instead, it will be reached
    from `app.routes.ts` through routing. And while it will handle incoming routing
    requests from `app.routes.ts`, it will in turn be routing them to the other components
    contained in the Workout Builder feature.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们移除了选择器，因为`WorkoutBuilderComponent`不会嵌入在应用程序根目录`app.component.ts`中。相反，它将通过路由从`app.routes.ts`中到达。虽然它将处理来自`app.routes.ts`的入站路由请求，但它将进一步将它们路由到Workout
    Builder功能中包含的其他组件。
- en: And those components will display their views using the `<router-outlet>` tag
    that we have just added to the `WorkoutBuilder` template. Given that the template
    for `Workout BuilderComponent` will be simple, we are also swapping out the `templateUrl`
    for an inline template.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件将使用我们刚刚添加到`WorkoutBuilder`模板中的`<router-outlet>`标签显示它们的视图。鉴于`Workout BuilderComponent`的模板将是简单的，我们还将内联模板替换为`templateUrl`。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Typically, for a component's view we recommend using a `templateUrl` that points
    to a separate HTML template file. This is especially true when you anticipate
    that the view will involve more than a few lines of HTML. In that situation, it
    is much easier to work with a view inside its own HTML file. The separate HTML
    file allows you to use an HTML editor with features such as color coding and tag
    completion. In contrast, an inline template is simply a string within a TypeScript
    file and the editor does not give you these benefits.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于组件的视图，我们建议使用指向单独的HTML模板文件的`templateUrl`。当您预期视图将涉及多于几行HTML时，这一点尤为重要。在这种情况下，更容易使用单独的HTML文件来处理视图。单独的HTML文件允许您使用具有颜色编码和标记完成等功能的HTML编辑器。相比之下，内联模板只是TypeScript文件中的字符串，编辑器不会给您带来这些好处。
- en: We are also adding a `<sub-nav>` element that will be used to create a secondary
    top-level menu for navigating within the *Workout Builder* feature. We'll discuss
    that a little later in this chapter.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一个`<sub-nav>`元素，用于创建*Workout Builder*功能内部的次级顶级菜单。我们将在本章稍后讨论这一点。
- en: Updating the Workout Builder module
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新Workout Builder模块
- en: Now let's update `WorkoutBuilderModule`. This is going to involve some significant
    changes since we will be turning this module into a feature module. So this module
    will import all the components that we will be using for building a workout. We
    won't cover all those imports here, but be sure to add them from `workout-builder.ts`
    in the `trainer/src/components/workout-builder` folder in `checkpoint 4.2` of
    the GitHub repository.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更新`WorkoutBuilderModule`。这将涉及一些重大变化，因为我们将把这个模块转变为一个功能模块。因此，这个模块将导入我们用于构建锻炼的所有组件。我们不会在这里涵盖所有这些导入，但一定要从GitHub存储库的`checkpoint
    4.2`中的`trainer/src/components/workout-builder`文件夹中的`workout-builder.ts`中添加它们。
- en: 'One import that is worth highlighting is the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是以下导入：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It imports the child routing that we just set up.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 它导入了我们刚刚设置的子路由。
- en: 'Now let''s update the `@NgModule` decorator to the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将`@NgModule`装饰器更新为以下内容：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Updating app.routes
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新app.routes
- en: 'One last step: return to `app.routes.ts` and remove the import of the `WorkoutBuilderComponent`
    and its route from that file.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步：返回到`app.routes.ts`，并从该文件中删除`WorkoutBuilderComponent`及其路由的导入。
- en: Putting it all together
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 把所有东西放在一起
- en: From the previous chapter, we already know how to set up root routing for our
    application. But now what we have instead of root routing is area or feature routing
    that contains child routes. We have been able to achieve the separation of concerns
    we discussed earlier, so that all the routes related to the *Workout Builder*
    are now separately contained in their own routing configuration. This means that
    we can manage all the routing for *Workout Builder* in the `WorkoutBuilderRoutes`
    component without affecting other parts of the application.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一章，我们已经知道如何为我们的应用程序设置根路由。但现在，我们所拥有的不是根路由，而是包含子路由的区域或功能路由。我们已经能够实现我们之前讨论的关注点分离，这样与*Workout
    Builder*相关的所有路由现在都单独包含在它们自己的路由配置中。这意味着我们可以在`WorkoutBuilderRoutes`组件中管理*Workout
    Builder*的所有路由，而不会影响应用程序的其他部分。
- en: We can see how the router combines the routes in `app.routes.ts` with the default
    route in `workout-builder.routes.ts`, if we now navigate from the start page to
    the Workout Builder.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到路由器如何将`app.routes.ts`中的路由与`workout-builder.routes.ts`中的默认路由组合在一起，如果我们现在从起始页面导航到Workout
    Builder。
- en: '![Putting it all together](../Images/image00456.jpeg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![把所有东西放在一起](../Images/image00456.jpeg)'
- en: If we look at the URL in the browser, it is `/builder/workouts`. You'll recall
    that the router link on the start page is `['/builder']`. So how did the router
    takes us to this location?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中查看URL，它是`/builder/workouts`。您会记得起始页面上的路由链接是`['/builder']`。那么路由是如何将我们带到这个位置的呢？
- en: 'It does it this way: when the link is clicked, the Angular router first looks
    to `app.routes.ts` for the `builder` path because that file contains the configuration
    for the root routes in our application. The router does not find that path because
    we have removed it from the routes in that file.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 它是这样做的：当链接被点击时，Angular路由器首先查找`app.routes.ts`中的`builder`路径，因为该文件包含了我们应用程序中根路由的配置。路由器没有在该文件的路由中找到该路径，因为我们已经从该文件的路由中删除了它。
- en: However, the `WorkoutBuilderComponent` has been imported into our `AppModule`
    and that component in turn imports `workoutBuilderRouting` from `workout-builder-routes.ts`.The
    latter file contains the child routes that we just configured. The router finds
    that `builder` is the parent route in that file and so it uses that route. It
    also finds the default setting that redirects to the child path `workouts` in
    the event that the `builder` path ends with an empty string, which it does in
    this case.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`WorkoutBuilderComponent`已经被导入到我们的`AppModule`中，该组件反过来从`workout-builder-routes.ts`导入了`workoutBuilderRouting`。后者文件包含了我们刚刚配置的子路由。路由器发现`builder`是该文件中的父路由，因此它使用了该路由。它还发现了默认设置，即在`builder`路径以空字符串结尾时重定向到子路径`workouts`，在这种情况下就是这样。
- en: If you look at the screen, you will see it is displaying the view for `Workouts`
    (and not as previously *Workout Builder*). This means that the router has successfully
    routed the request to `WorkoutsComponent`, which is the component for the default
    route in the child route configuration that we set up in `workout-builder.routes.ts`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![把所有东西放在一起](../Images/image00457.jpeg)'
- en: 'This process of route resolution is illustrated here:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 路由解析的过程如下所示：
- en: '![Putting it all together](../Images/image00457.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: 如果您看屏幕，您会发现它显示的是`Workouts`的视图（而不是之前的*Workout Builder*）。这意味着路由器已成功地将请求路由到了`WorkoutsComponent`，这是我们在`workout-builder.routes.ts`中设置的子路由配置的默认路由的组件。
- en: One final thought on child routing. When you look at our child routing component, `workout-builder.component.ts`,
    you will see that it has no references to its `parent` component, `app.component.ts`
    (as we mentioned earlier, the `<selector>` tag has been removed, so the `Workout
    Builder` component is not being embedded in the root component). This means that
    we have successfully encapsulated `Workout Builder` (and all of the components
    that it imports) in a way that will allow us to move all of it elsewhere in the
    application or even into a new application.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 关于子路由的最后一个想法。当您查看我们的子路由组件`workout-builder.component.ts`时，您会发现它没有引用其`parent`组件`app.component.ts`（正如我们之前提到的，`<selector>`标签已被移除，因此`Workout
    Builder`组件没有被嵌入到根组件中）。这意味着我们已成功地封装了`Workout Builder`（以及它导入的所有组件），这将使我们能够将其全部移动到应用程序的其他位置，甚至是到一个新的应用程序中。
- en: Now it's time for us to move on to converting our routing for the Workout Builder
    to use lazy loading and building out its navigation menus. If you want to see
    the completed code for this next section, you can download it from the companion
    codebase in `checkpoint 4.3`. Again, if you are working along with us as we build
    the application, be sure and update the `app.css` file, which we are not discussing
    here.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们的训练构建器的路由转换为使用延迟加载，并构建其导航菜单了。如果您想查看下一节的完成代码，可以从`检查点4.3`的伴随代码库中下载。再次强调，如果您正在与我们一起构建应用程序，请确保更新`app.css`文件，这里我们不讨论。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code is also available for everyone to download on GitHub at [https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample).
    Checkpoints are implemented as branches in GitHub. The branch to download is as
    follows: **GitHub Branch: checkpoint4.3** (folder - `trainer`). If you are not
    using Git, download the snapshot of Checkpoint 4.3 (a ZIP file) from the following
    GitHub location: [https://github.com/chandermani/angular2byexample/archive/checkpoint4.3.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint4.3.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码也可供所有人在GitHub上下载：[https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample)。检查点在GitHub中作为分支实现。要下载的分支如下：**GitHub分支：checkpoint4.3**（文件夹
    - `trainer`）。如果您不使用Git，请从以下GitHub位置下载检查点4.3的快照（ZIP文件）：[https://github.com/chandermani/angular2byexample/archive/checkpoint4.3.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint4.3.zip)。首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: Lazy loading of routes
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由的延迟加载
- en: When we roll out our application, we expect that our users will be accessing
    the **Workout Runner** every day (and we know that this will be the case for you!).
    But we anticipate that they will only occasionally be using the *Workout Builder*
    to construct their exercises and workout plans. It would therefore be nice if
    we could avoid the overhead of loading the **Workout Builder** when our users
    are just doing their exercises in the **Workout Runner**. Instead, we would prefer
    to load *Workout Builder* only on demand when a user wants to add to or update
    their exercises and workout plans. This approach is called **lazy loading**.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们推出我们的应用程序时，我们预计我们的用户每天都会访问**训练运行器**（我们知道这对你来说也是如此！）。但我们预计他们只会偶尔使用*训练构建器*来构建他们的练习和训练计划。因此，如果我们的用户只是在**训练运行器**中做练习时，我们最好能避免加载**训练构建器**的开销。相反，我们希望只在用户想要添加或更新他们的练习和训练计划时按需加载*训练构建器*。这种方法称为**延迟加载**。
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Under the hood, Angular uses SystemJS to accomplish this lazy loading. It allows
    us to employ an asynchronous approach when loading our modules. This means that
    we can load just what is required to get the application started and then load
    other modules as we need them.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Angular使用SystemJS来实现这种延迟加载。它允许我们在加载模块时采用异步方法。这意味着我们可以只加载启动应用程序所需的内容，然后根据需要加载其他模块。
- en: So in our *Personal Trainer*, we want to change the application so that it only
    loads the **Workout Builder** on demand. And the Angular router allows us to do
    just that using lazy loading.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的*个人教练*应用程序中，我们希望改变应用程序，使其只在需要时加载**训练构建器**。Angular路由器允许我们使用延迟加载来实现这一点。
- en: 'But before we get started implementing lazy loading, let''s take a look at
    our current application and how it is loading our modules. With the developer
    tools open in the **Sources** tab, start up the application; when the start page
    appears in your browser, you see that all the files in the application have loaded,
    including both the *Workout Runner* and *Workout Builder* files:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 但在开始实现懒加载之前，让我们先看看我们当前的应用程序以及它如何加载我们的模块。在**Sources**选项卡中打开开发者工具，启动应用程序；当应用程序的起始页面出现在您的浏览器中时，您会看到应用程序中的所有文件都已加载，包括*Workout
    Runner*和*Workout Builder*文件：
- en: '![Lazy loading of routes](../Images/image00458.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![路由的懒加载](../Images/image00458.jpeg)'
- en: So even though we may just want to use the *Workout Runner*, we have to load
    the *Workout Builder* as well. In a way, this makes sense if you think of our
    application as a **Single Page Application** (**SPA**). In order to avoid round
    trips to the server, an SPA will typically load all the resources that will be
    needed to use the application when it is first started up by a user. But in our
    case, the important point is that we do not **need** the *Workout Builder* when
    the application is first loaded. Instead, we would like to load those resources
    only when the user decides that they want to add or change a workout or exercise.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使我们可能只想使用*Workout Runner*，我们也必须加载*Workout Builder*。从某种意义上讲，如果你把我们的应用程序看作是一个**单页应用程序**（**SPA**），这是有道理的。为了避免与服务器的往返，SPA通常会在用户首次启动应用程序时加载所有将需要使用应用程序的资源。但在我们的情况下，重要的是当应用程序首次加载时，我们并不**需要**
    *Workout Builder*。相反，我们希望只在用户决定要添加或更改锻炼或练习时才加载这些资源。
- en: So let's get started with making that happen.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始实现这一点。
- en: 'First, modify the `app.routes.ts` to add the following separate route configuration
    for our `workoutBuilderRoutes`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，修改`app.routes.ts`，添加以下单独的路由配置，用于我们的`workoutBuilderRoutes`：
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Notice that the `loadChildren` property is:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`loadChildren`属性是：
- en: '[PRE14]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This configuration provides the information that will be needed to load and
    instantiate our component. Pay particular attention to the file path; it points
    to the location of our code in the `dist` folder when it is deployed as a JavaScript
    file and not to the folder where the TypeScript version of that file is located.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置提供了加载和实例化组件所需的信息。特别注意文件路径；它指向我们的代码在`dist`文件夹中的位置，当它部署为JavaScript文件时，而不是该文件的TypeScript版本所在的文件夹。
- en: 'Next, update the `Routes` configuration to add the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新`Routes`配置以添加以下内容：
- en: '[PRE15]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You will notice that we have added a reference to `WorkoutBuilderRoutes`, which
    we just configured and prepended with three dots. With the three dots we are using
    the ES2015 spread operator to insert an array of routes - specifically the routes
    for the `WorkoutBuilder` feature. These routes will be contained in `WorkoutBuilderRoutes`
    and will be maintained separately and apart from the routes in the root of our
    application. Finally , remove the import of the `WorkoutBuilderComponent` from
    this file.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们已经添加了对`WorkoutBuilderRoutes`的引用，我们刚刚配置并用三个点添加了前缀。通过这三个点，我们使用ES2015扩展运算符来插入一个路由数组
    - 具体来说是`WorkoutBuilder`功能的路由。这些路由将包含在`WorkoutBuilderRoutes`中，并将与我们应用程序根目录中的路由分开维护。最后，从该文件中删除对`WorkoutBuilderComponent`的导入。
- en: 'Next go back to `workout-builder.routes.ts` and change the `path` property
    to an empty string:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来回到`workout-builder.routes.ts`，将`path`属性更改为空字符串：
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We are making this change because we are now setting the path ('`builder`')
    to the `WorkoutBuilderRoutes` in the new configuration for them that we added
    in `app.routes.ts`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行此更改是因为我们现在正在将路径（'`builder`'）设置为`app.routes.ts`中添加的`WorkoutBuilderRoutes`的新配置。
- en: Finally go back to the `app-module.ts` and remove the `WorkoutBuilderModule`
    import in the `@NgModule` configuration in that file. What this means is that
    instead of loading the **Workout Builder** feature when the application first
    starts, we only load it when a user accesses the route to *Workout Builder*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后返回`app-module.ts`，并在该文件的`@NgModule`配置中删除`WorkoutBuilderModule`的导入。这意味着我们不会在应用程序启动时加载**锻炼构建器**功能，而是只有在用户访问*锻炼构建器*路由时才加载它。
- en: 'Let''s go back and run the application again keeping the **Sources** tab open
    in the Chrome developer tools. When the application begins and the start page
    loads, only the files related to the *Workout Runner* appear and not those related
    to the *Workout Builder*, as shown here:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们返回并再次运行应用程序，保持Chrome开发者工具中的**源**选项卡打开。当应用程序开始并加载起始页面时，只有与*锻炼运行器*相关的文件出现，而与*锻炼构建器*相关的文件不会出现，如下所示：
- en: '![Lazy loading of routes](../Images/image00459.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![路由的延迟加载](../Images/image00459.jpeg)'
- en: 'Then, if we clear the **Network** tab and click on the **Create a Workout link**,
    we''ll see only the files related to the *Workout Builder* load:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们清除**网络**选项卡并单击**创建锻炼链接**，我们将只看到与*锻炼构建器*加载相关的文件：
- en: '![Lazy loading of routes](../Images/image00460.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![路由的延迟加载](../Images/image00460.jpeg)'
- en: As we can see, the files that are now loaded all relate to the *Workout Builder.*
    This means that we have achieved encapsulation of our new feature and with asynchronous
    routing we are able to use lazy loading to load all its components only when needed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，现在加载的所有文件都与*锻炼构建器*相关。这意味着我们已经实现了新功能的封装，并且通过异步路由，我们能够使用延迟加载仅在需要时加载所有其组件。
- en: Child and asynchronous routing make it straightforward to implement applications
    that allow us to *have our cake and eat it too*. On one hand, we can build single-page
    applications with powerful client-side navigation, while on the other hand we
    can also encapsulate features in separate child routing components and load them
    only on demand.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 子级和异步路由使我们能够轻松实现允许我们“既能拥有蛋糕，又能吃掉蛋糕”的应用程序。一方面，我们可以构建具有强大客户端导航的单页面应用程序，另一方面，我们还可以将功能封装在单独的子路由组件中，并仅在需要时加载它们。
- en: This power and flexibility of the Angular router give us the ability to meet
    user expectations by closely mapping our application's behavior and responsiveness
    to the ways they will use the application. In this case, we have leveraged these
    capabilities to achieve what we set out to do: immediately load *Workout Runner *so
    that our users can get to work on their exercises right away, but avoid the overhead
    of loading *Workout Builder *and instead only serve it when a user wants to build
    a workout.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Angular路由器的这种强大和灵活性使我们能够通过密切映射应用程序的行为和响应性来满足用户的期望。在这种情况下，我们利用了这些能力来实现我们的目标：立即加载*锻炼运行器*，以便我们的用户可以立即开始锻炼，但避免加载*锻炼构建器*的开销，而只在用户想要构建锻炼时提供它。
- en: Now that we have the routing configuration in place in the *Workout Builder*,
    we will turn our attention to creating the sub-level and left navigation; this
    will enable us to use this routing. The next sections cover implementing this
    navigation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在*锻炼构建器*中放置了路由配置，我们将把注意力转向创建子级和左侧导航；这将使我们能够使用这个路由。接下来的部分将涵盖实现这种导航。
- en: Integrating sub- and side-level navigation
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成子级和侧边导航
- en: The basic idea around integrating sub- and side-level navigation into the app
    is to provide context-aware sub-views that change based on the active view. For
    example, when we are on a list page as opposed to editing an item, we may want
    to show different elements in the navigation. An e-commerce site is a great example
    of this. Imagine Amazon's search result page and product detail page. As the context
    changes from a list of products to a specific product, the navigation elements
    that are loaded also change.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 将子级和侧边导航集成到应用程序中的基本思想是提供基于活动视图而变化的上下文感知子视图。例如，当我们在列表页面而不是编辑项目时，我们可能希望在导航中显示不同的元素。电子商务网站是一个很好的例子。想象一下亚马逊的搜索结果页面和产品详细页面。随着上下文从产品列表变为特定产品，加载的导航元素也会改变。
- en: Sub-level navigation
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子级导航
- en: 'We''ll start by adding sub-level navigation to the *Workout Builder*. We have
    already imported our `SubNavComponent` into the *Workout Builder*. But currently
    it is just displaying placeholder content:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先向*Workout Builder*添加子级导航。我们已经将`SubNavComponent`导入到*Workout Builder*中。但目前它只显示占位内容：
- en: '![Sub-level navigation](../Images/image00461.jpeg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![子级导航](../Images/image00461.jpeg)'
- en: 'We''ll now replace that content with three router links: **Home**, **New Workout**,
    and **New Exercise**.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将用三个路由链接替换该内容：**主页**，**新锻炼**和**新练习**。
- en: 'Open the `sub-nav.component.html` file and change the HTML in it to the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`sub-nav.component.html`文件，并将其中的HTML更改为以下内容：
- en: '[PRE17]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now rerun the application and you will see the three navigation links. If we
    click on the **New Exercise** link button, we will be routed to `ExerciseComponent`
    and its view will appear in the **Router Outlet** in the *Workout Builder* view:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新运行应用程序，您将看到三个导航链接。如果我们点击**新练习**链接按钮，我们将被路由到`ExerciseComponent`，并且其视图将出现在*Workout
    Builder*视图中的**路由出口**中：
- en: '![Sub-level navigation](../Images/image00462.jpeg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![子级导航](../Images/image00462.jpeg)'
- en: The **New Workout** link button will work in a similar fashion; when clicked
    on, it will take the user to the `WorkoutComponent` and display its view in the
    router outlet. Clicking on the **Home** link button will return the user to the
    `WorkoutsComponent` and view.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**新锻炼**链接按钮将以类似的方式工作；当点击时，它将带用户到`WorkoutComponent`并在路由出口显示其视图。点击**主页**链接按钮将把用户返回到`WorkoutsComponent`和视图。'
- en: Side navigation
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 侧边导航
- en: Side level navigation within the *Workout Builder* will vary depending on the
    child component that we navigate to. For instance, when we first navigate to the
    *Workout Builder*, we are taken to the **Workouts** screen because the `WorkoutsComponent`'s
    route is the default route for the *Workout Builder*. That component will need
    side navigation; it will allow us to select to view a list of workouts or a list
    of exercises.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*Workout Builder*内的侧边导航将根据我们导航到的子组件而变化。例如，当我们首次导航到*Workout Builder*时，我们会进入**锻炼**屏幕，因为`WorkoutsComponent`的路由是*Workout
    Builder*的默认路由。该组件将需要侧边导航；它将允许我们选择查看锻炼列表或练习列表。'
- en: 'The component-based nature of Angular gives us an easy way to implement these
    context-sensitive menus. We can define new components for each of the menus and
    then import them into the components that need them. In this case, we have three
    components that will need side menus: **Workouts**, **Exercises**, and **Workout**.
    The first two of these components can actually use the same menu so we really
    only need two side menu components: `LeftNavMainComponent`, which will be like
    the preceding menu and will be used by the `Exercises` and `Workouts` components,
    and `LeftNavExercisesComponent`, which will contain a list of existing exercises
    and will be used by the `Workouts` component.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的基于组件的特性为我们提供了一种实现这些上下文敏感菜单的简单方法。我们可以为每个菜单定义新的组件，然后将它们导入到需要它们的组件中。在这种情况下，我们有三个组件将需要侧边菜单：**锻炼**，**练习**和**锻炼**。前两个组件实际上可以使用相同的菜单，所以我们实际上只需要两个侧边菜单组件：`LeftNavMainComponent`，它将类似于前面的菜单，并将被`Exercises`和`Workouts`组件使用，以及`LeftNavExercisesComponent`，它将包含现有练习列表，并将被`Workouts`组件使用。
- en: We already have files for the two menu components, including template files,
    and have imported them into `WorkoutBuilderModule`. We will now integrate these
    into the components that need them.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为两个菜单组件准备了文件，包括模板文件，并将它们导入到`WorkoutBuilderModule`中。现在我们将把它们整合到需要它们的组件中。
- en: 'First, modify the `workouts.component.html` template to add the selector for
    the menu:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，修改`workouts.component.html`模板以添加菜单的选择器：
- en: '[PRE18]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then replace the placeholder text in the `left-nav-main.component.html` with
    the navigation links to `WorkoutsComponent` and `ExercisesComponent`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`left-nav-main.component.html`中的占位文本替换为导航链接到`WorkoutsComponent`和`ExercisesComponent`：
- en: '[PRE19]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the application and you should see the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，您应该会看到以下内容：
- en: '![Side navigation](../Images/image00463.jpeg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![侧边导航](../Images/image00463.jpeg)'
- en: Follow the exact same steps to complete the side menu for the `Exercises` component.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 按照完全相同的步骤完成`Exercises`组件的侧边菜单。
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We won't show the code for these two menus here but you can find it in the `workout-builder/exercises`
    folder under `trainer/src/components` in `checkpoint 4.3` of the GitHub repository.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里展示这两个菜单的代码，但您可以在GitHub存储库的`checkpoint 4.3`中的`trainer/src/components`文件夹下的`workout-builder/exercises`文件夹中找到它们。
- en: 'For the menu for the **Workouts** screen, the steps are the same except that
    you should change `left-nav-exercises.component.html` to the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**锻炼**屏幕的菜单，步骤是相同的，只是您应该将`left-nav-exercises.component.html`更改为以下内容：
- en: '[PRE20]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We will use this template as the starting point for building out a list of exercises
    that will appear on the left-hand side of the screen and can be selected for inclusion
    in a workout.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个模板作为构建出现在屏幕左侧的练习列表的起点，并可以选择包含在锻炼中的练习。
- en: Implementing workout and exercise lists
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现锻炼和练习列表
- en: Even before we start implementing the **Workout** and **Exercise** list pages,
    we need a data store for exercise and workout data. The current plan is to have
    an in-memory data store and expose it using an Angular service. In [Chapter 5](part0056.xhtml#aid-1LCVG2
    "Chapter 5.  Supporting Server Data Persistence"), *Supporting Server Data Persistence*,
    where we talk about server interaction, we will move this data to a server store
    for long-term persistence. For now, the in-memory store will suffice. Let's add
    the store implementation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至在我们开始实现**锻炼**和**练习**列表页面之前，我们需要一个练习和锻炼数据的数据存储。当前的计划是使用内存数据存储并使用Angular服务来公开它。在[第5章](part0056.xhtml#aid-1LCVG2
    "第5章。支持服务器数据持久性")中，*支持服务器数据持久性*，我们将把这些数据移到服务器存储以实现长期持久性。目前，内存存储就足够了。让我们添加存储实现。
- en: WorkoutService as a workout and exercise repository
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WorkoutService作为锻炼和练习存储库
- en: 'The plan here is to create a `WorkoutService` instance that is responsible
    for exposing the exercise and workout data across the two applications. The main
    responsibilities of the service include:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的计划是创建一个负责在两个应用程序中公开练习和锻炼数据的`WorkoutService`实例。服务的主要职责包括：
- en: '**Exercise-related CRUD operations**: Get all exercises, get a specific exercise
    based on its name, create an exercise, update an exercise, and delete it'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与Exercise相关的CRUD操作**：获取所有练习，根据名称获取特定练习，创建练习，更新练习和删除练习'
- en: '**Workout-related CRUD operations**: These are similar to the exercise-related
    operations, but targeted toward the workout entity'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与Workout相关的CRUD操作**：这些类似于与Exercise相关的操作，但是针对Workout实体'
- en: Note
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code is available to download on GitHub at [https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample).
    The branch to download is as follows: **GitHub Branch: checkpoint4.4** (folder
    - `trainer`). If you are not using Git, download the snapshot of Checkpoint 4.4
    (a ZIP file) from the following GitHub location: [https://github.com/chandermani/angular2byexample/archive/checkpoint4.4.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint4.4.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time. Again, if you are working along with us as we build the application,
    be sure to update the `app.css` file, which we are not discussing here. Because
    some of the files in this section are rather long, rather than showing the code
    here, we are also going to suggest at times that you simply copy the files into
    your solution.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码可在GitHub上下载，网址为[https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample)。要下载的分支如下：**GitHub分支：checkpoint4.4**（文件夹
    - `trainer`）。如果您不使用Git，请从以下GitHub位置下载Checkpoint 4.4的快照（ZIP文件）：[https://github.com/chandermani/angular2byexample/archive/checkpoint4.4.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint4.4.zip)。首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。再次，如果您正在与我们一起构建应用程序，请确保更新`app.css`文件，这里我们不讨论。因为本节中的一些文件相当长，所以我们不会在这里显示代码，有时我们会建议您将文件简单复制到您的解决方案中。
- en: 'Locate `workout-service.ts` in the `trainer/src/services` folder. The code
    in that file should look like the following except for the implementation of the
    two methods `setupInitialExercises` and `setupInitialWorkouts`, which we have
    left out because of their length:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在`trainer/src/services`文件夹中找到`workout-service.ts`。该文件中的代码应该如下所示，除了两个方法`setupInitialExercises`和`setupInitialWorkouts`的实现，由于它们的长度，我们已经省略了：
- en: '[PRE21]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we have mentioned before, the implementation of an Angular service is straightforward.
    Here we are declaring a class with the name `WorkoutService` and decorating it
    with `@Injectable` to support injecting it throughout our application. In the
    class definition, we first create two arrays: one for `Workouts` and one for `Exercises`.
    These arrays are of types `WorkoutPlan` and `Exercise` respectively, and we therefore
    need to import `WorkoutPlan` and `Exericse` from `model.ts` to get the type definitions
    for them.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，实现Angular服务是直截了当的。在这里，我们声明了一个名为`WorkoutService`的类，并用`@Injectable`进行装饰，以支持在整个应用程序中注入它。在类定义中，我们首先创建了两个数组：一个用于`Workouts`，一个用于`Exercises`。这些数组分别是`WorkoutPlan`和`Exercise`类型的，因此我们需要从`model.ts`中导入`WorkoutPlan`和`Exericse`以获取它们的类型定义。
- en: The constructor calls two methods to set up the **Workouts** and **Services
    List**. At the moment, we are just using an in-memory store that populates these
    lists with data.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数调用了两个方法来设置**Workouts**和**Services List**。目前，我们只是使用一个内存存储来填充这些列表的数据。
- en: The two methods, `getExercises` and `getWorkouts`, as the names suggest, return
    a list of exercises and workouts respectively. Since we plan to use the in-memory
    store to store workout and exercise data, the `Workouts` and `Exercises` arrays
    store this data. As we go along, we will be adding more functions to the service.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法，`getExercises`和`getWorkouts`，顾名思义，分别返回练习和锻炼的列表。由于我们计划使用内存存储来存储锻炼和练习数据，`Workouts`和`Exercises`数组存储了这些数据。随着我们的进行，我们将向服务添加更多的函数。
- en: There is one more thing we need to do to make the service available to be injected
    throughout our application.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事情我们需要做，就是使服务可以在整个应用程序中被注入。
- en: 'Open `services.module.ts` in the same folder, and then import `WorkoutService` and
    add it as a provider:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 打开同一文件夹中的`services.module.ts`，然后导入`WorkoutService`并将其添加为提供者：
- en: '[PRE22]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This registers `WorkoutService` as a provider with Angular's **Dependency Injection**
    framework.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`WorkoutService`注册为Angular的**依赖注入**框架的提供者。
- en: Time to add the components for the workout and exercise lists!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候添加锻炼和练习列表的组件了！
- en: Workout and exercise list components
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锻炼和练习列表组件
- en: 'First, open the `workouts.component.ts` file in the `trainer/src/components/workout-builder/workouts`
    folder and update the imports as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开`trainer/src/components/workout-builder/workouts`文件夹中的`workouts.component.ts`文件，并按照以下方式更新导入：
- en: '[PRE23]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This new code imports `OnInit` from the Angular core as well as `Router`, `WorkoutService`
    and the `WorkoutPlan` type.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这段新代码从Angular核心中导入了`OnInit`，以及`Router`，`WorkoutService`和`WorkoutPlan`类型。
- en: 'Next replace the class definition with the following code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，用以下代码替换类定义：
- en: '[PRE24]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code adds a constructor into which we are injecting the `WorkoutService`
    and the `Router`. The `ngOnInit` method then calls the `getWorkouts` method on
    the `WorkoutService` and populates a `workoutList` array with a list of `WorkoutPlans`
    returned from that method call. We'll use that `workoutList` array to populate
    the list of Workout plans that will display in the `Workouts` component's view.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码添加了一个构造函数，我们在其中注入了`WorkoutService`和`Router`。然后`ngOnInit`方法调用`WorkoutService`的`getWorkouts`方法，并用从该方法调用返回的`WorkoutPlans`列表填充了一个`workoutList`数组。我们将使用这个`workoutList`数组来填充在`Workouts`组件的视图中显示的锻炼计划列表。
- en: You'll notice that we are putting the code for calling `WorkoutService` into
    an `ngOnInit` method. We want to avoid placing this code in the constructor. Eventually,
    we will be replacing the in-memory store that this service uses with a call to
    an external data store and we do not want the instantiation of our component to
    be affected by this call. Adding these method calls to the constructor would also
    complicate testing the component.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们将调用`WorkoutService`的代码放入了一个`ngOnInit`方法中。我们希望避免将这段代码放入构造函数中。最终，我们将用外部数据存储的调用替换这个服务使用的内存存储，我们不希望我们组件的实例化受到这个调用的影响。将这些方法调用添加到构造函数中也会使组件的测试变得复杂。
- en: To avoid such unintended side effects, we instead place the code in the `ngOnInit`
    method. This method implements one of Angular's lifecycle hooks, `OnInit`, which
    Angular calls after creating an instance of the service. This way we rely on Angular
    to call this method in a predictable way that does not affect the instantiation
    of the component.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种意外的副作用，我们将代码放在`ngOnInit`方法中。这个方法实现了Angular的生命周期钩子之一，`OnInit`，Angular在创建服务的实例后调用这个方法。这样我们就依赖于Angular以一种可预测的方式调用这个方法，不会影响组件的实例化。
- en: Next we'll make almost identical changes to the `Exercises` component. As with
    the `Workouts` component, this code injects the workout service into our component.
    This time, we then use the workout service to retrieve the exercises.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对`Exercises`组件进行几乎相同的更改。与`Workouts`组件一样，这段代码将锻炼服务注入到我们的组件中。这次，我们使用锻炼服务来检索练习。
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Because it so similar to what we just showed you for the `Workouts` component,
    we won't show that code here. Just add it from the `workout-builder/exercises`
    folder `checkpoint 4.4`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它与我们刚刚为`Workouts`组件展示的内容非常相似，所以我们不会在这里展示代码。只需从`workout-builder/exercises`文件夹的`checkpoint
    4.4`中添加它。
- en: Workout and exercise list views
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锻炼和锻炼列表视图
- en: Now we need to implement the list views that have so far been empty!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要实现到目前为空的列表视图！
- en: Note
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this section, we will be updating the code from `checkpoint 4.3` with what
    is found in `checkpoint 4.4`. So if you are coding along with us, simply follow
    the steps laid out in this section. If you want to see the finished code, then
    just copy the files from `checkpoint 4.4` into your solution.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用`checkpoint 4.4`中找到的代码更新`checkpoint 4.3`中的代码。因此，如果您正在与我们一起编码，只需按照本节中列出的步骤进行。如果您想查看完成的代码，只需将`checkpoint
    4.4`中的文件复制到您的解决方案中。
- en: Workouts list views
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 锻炼列表视图
- en: 'To get the view working, open `workouts.component.html` and add the following
    markup:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要使视图工作，打开`workouts.component.html`并添加以下标记：
- en: '[PRE25]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We are using one of the Angular core directives, `ngFor`, to loop through the
    list of workouts and display them in a list on the page. We add the `*` sign in
    front of `ngFor` to identify it as an Angular directive. Using a `let` statement
    we assign `workout` as a local variable that we use to iterate through the worklist
    and identify the values to be displayed for each workout (for example, `workout.title`).
    We then use one of our custom pipes, `orderBy`, to display a list of workouts
    in alphabetical order by title. We are also using another custom pipe, `secondsToTime`,
    to format the time displayed for the total workout duration.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Angular核心指令之一`ngFor`来循环遍历锻炼列表并在页面上以列表形式显示它们。我们在`ngFor`前面加上`*`号来将其标识为Angular指令。使用`let`语句，我们将`workout`分配为一个本地变量，用于遍历工作列表并识别要为每个锻炼显示的值（例如，`workout.title`）。然后我们使用我们的自定义管道之一`orderBy`，按标题的字母顺序显示锻炼列表。我们还使用另一个自定义管道`secondsToTime`来格式化显示总锻炼持续时间的时间。
- en: Note
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are coding along with us, you will need to move the `secondsToTime` pipe
    into the shared folder and include it in the `SharedModule`. Then add `SharedModule`
    to `WorkoutBuilderModule` as an additional import. That change has already been
    made in `checkpoint 4.4` in the GitHub repository.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在与我们一起编码，您需要将`secondsToTime`管道移动到共享文件夹并将其包含在`SharedModule`中。然后将`SharedModule`作为额外导入添加到`WorkoutBuilderModule`中。这个更改已经在GitHub存储库的`checkpoint
    4.4`中进行了。
- en: 'Finally, we bind the click event to the following `onSelect` method that we
    add to our component:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将点击事件绑定到我们组件中添加的`onSelect`方法：
- en: '[PRE26]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This sets up navigation to the workout detail page. This navigation happens
    when we double-click on an item in the workout list. The selected workout name
    is passed as part of the route/URL to the workout detail page.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了导航到锻炼详细页面。当我们双击锻炼列表中的项目时，将发生此导航。所选锻炼名称作为路由/URL的一部分传递到锻炼详细页面。
- en: 'Go ahead and refresh the builder page (`/builder/workouts`); one workout is
    listed, the 7 Minute Workout. Click on the tile for that workout. You''ll be taken
    to the **Workout** screen and the workout name `7MinWorkout` will appear at the
    end of the URL:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 继续刷新构建器页面(`/builder/workouts`)；列出了一个锻炼，7分钟锻炼。点击该锻炼的瓷砖。您将被带到**锻炼**屏幕，锻炼名称`7MinWorkout`将出现在URL的末尾：
- en: '![Workouts list views](../Images/image00464.jpeg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![锻炼列表视图](../Images/image00464.jpeg)'
- en: Exercises list views
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 锻炼列表视图
- en: 'We are going to follow the same approach for the `Exercises` list view as we
    did for the `Workouts` list view. Except that in this case, we will actually be
    implementing two views: one for the `Exercises` component (which will display
    in the main content area when a user navigates to that component) and one for
    the `LeftNavExercisesComponent` exercises context menu (that will display when
    user navigates to the `Workouts` component to create/edit a workout).'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Exercises`列表视图，我们将采用与`Workouts`列表视图相同的方法。只是在这种情况下，我们实际上将实现两个视图：一个用于`Exercises`组件（当用户导航到该组件时显示在主内容区域），另一个用于`LeftNavExercisesComponent`练习上下文菜单（当用户导航到`Workouts`组件创建/编辑锻炼时显示）。
- en: For the `Exercises` component, we will follow an approach that is almost identical
    to what we did to display a list of workouts in the `Workouts` component. So we
    won't show that code here. Just add the files for `exercise.conponent.ts` and
    `exercise.component.html` from `checkpoint 4.4`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Exercises`组件，我们将采用几乎与在`Workouts`组件中显示锻炼列表时相同的方法。所以我们不会在这里展示那些代码。只需添加来自`checkpoint
    4.4`的`exercise.conponent.ts`和`exercise.component.html`文件。
- en: When you are done copying the files, click on the **Exercises** link in the
    left navigation to load the 12 exercises that you have already configured in `WorkoutService`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成复制文件后，点击左侧导航中的**练习**链接，加载你已经在`WorkoutService`中配置好的12个练习。
- en: As with the `Workouts` list, this sets up the navigation to the exercise detail
    page. Double-clicking on an item in the exercises list takes us to the exercise
    detail page. The selected exercise name is passed as part of the route/URL to
    the exercise detail page.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Workouts`列表一样，这设置了导航到练习详情页面。在练习列表中双击一个项目会带我们到练习详情页面。所选练习的名称作为路由/URL的一部分传递到练习详情页面。
- en: In the final list view, we will add a list of exercises that will display in
    the left context menu for the *Workout Builder* screen. This view is loaded in
    the left navigation when we create or edit a workout. Using Angular's component-based
    approach, we will update the `leftNavExercisesComponent` and its related view
    to provide this functionality. Again we won't show that code here. Just add the
    files for `left-nav-exercises.component.ts` and `left-nav-exercises.component.html`
    from the `trainer/src/components/navigation` folder in `checkpoint 4.4`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终的列表视图中，我们将添加一个练习列表，它将显示在*Workout Builder*屏幕的左侧上下文菜单中。当我们创建或编辑一个锻炼时，这个视图会在左侧导航中加载。使用Angular的基于组件的方法，我们将更新`leftNavExercisesComponent`及其相关视图，以提供这个功能。同样，我们不会在这里展示那些代码。只需添加来自`checkpoint
    4.4`的`left-nav-exercises.component.ts`和`left-nav-exercises.component.html`文件，它们位于`trainer/src/components/navigation`文件夹中。
- en: Once you are done copying those files, click on the **New Workout** button on
    the sub-navigation menu in the *Workout Builder* and you will now see a list of
    exercises, displayed in the left navigation menu exercises that we have already
    configured in `WorkoutService`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了复制这些文件，点击*Workout Builder*子导航菜单中的**新锻炼**按钮，你将会看到一个练习列表，在左侧导航菜单中显示了我们已经在`WorkoutService`中配置好的练习。
- en: Time to add the ability to load, save, and update exercise/workout data!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候添加加载、保存和更新练习/锻炼数据的功能了！
- en: Building a workout
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建锻炼
- en: The core functionality *Personal Trainer* provides centers around workout and
    exercise building. Everything is there to support these two functions. In this
    section, we focus on building and editing workouts using Angular.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*个人教练*的核心功能围绕着锻炼和练习的建立。一切都是为了支持这两个功能。在这一部分，我们将专注于使用Angular构建和编辑锻炼。'
- en: The `WorkoutPlan` model has already been defined, so we are aware of the elements
    that constitute a workout. The *Workout Builder* page facilitates user input and
    lets us build/persist workout data.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: “WorkoutPlan”模型已经定义，所以我们知道构成锻炼的元素。 *Workout Builder*页面促进用户输入，并让我们构建/持久化锻炼数据。
- en: 'Once complete, the *Workout Builder* page will look like this:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，“Workout Builder”页面将如下所示：
- en: '![Building a workout](../Images/image00465.jpeg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![构建锻炼](../Images/image00465.jpeg)'
- en: The page has a left navigation that lists all the exercises that can be added
    to the workout. Clicking on the arrow icon on the right adds the exercise to the
    end of the workout.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 页面有一个左侧导航，列出了可以添加到锻炼中的所有练习。单击右侧的箭头图标将练习添加到锻炼的末尾。
- en: The center area is designated for workout building. It consists of exercise
    tiles laid out in order from top to bottom and a form that allows the user to
    provide other details about the workout such as name, title, description, and
    rest duration.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 中心区域用于构建锻炼。它由按顺序排列的练习瓷砖和一个表单组成，允许用户提供关于锻炼的其他细节，如名称、标题、描述和休息时间。
- en: 'This page operates in two modes:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面有两种模式：
- en: '**Create**/**New**: This mode is used for creating a new workout. The URL is
    `#/ builder/workout/new`.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建**/**新建**：此模式用于创建新的锻炼。URL为`#/ builder/workout/new`。'
- en: '**Edit**: This mode is used for editing the existing workout. The URL is `#/
    builder/workout/:id`, where `:id` maps to the name of the workout.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑**：此模式用于编辑现有的锻炼。URL为`#/ builder/workout/:id`，其中`:id`映射到锻炼的名称。'
- en: With this understanding of the page elements and layout, it's time to build
    each of these elements. We will start with left nav (navigation).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了页面元素和布局，现在是构建每个元素的时候了。我们将从左侧导航开始。
- en: Finishing left nav
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成左侧导航
- en: At the end of the previous section, we updated the left navigation view for
    the `Workout` component to show a list of exercises. Our intention was to let
    the user click on an arrownext to an exercise to add it to the workout. At the
    time, we deferred implementing the `addExercise` method in the `LeftNavExercisesComponent`
    that was bound to that click event. Now we will go ahead and do that.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节的最后，我们更新了“Workout”组件的左侧导航视图，以显示锻炼列表。我们的意图是让用户点击练习旁边的箭头将其添加到锻炼中。当时，我们推迟了在“LeftNavExercisesComponent”中实现“addExercise”方法，该方法绑定到该点击事件。现在我们将继续执行。
- en: We have a couple of options here. The `LeftNavExercisesComponent` is a child
    component of the `WorkoutComponent`, so we can implement child/parent inter-component
    communication to accomplish that. We covered this technique in the previous chapter
    while working on *7 Minute Workout*.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里有几个选择。 “LeftNavExercisesComponent”是“WorkoutComponent”的子组件，因此我们可以实现子/父组件间的通信来完成这一点。在上一章中，我们在*7分钟锻炼*时使用了这种技术。
- en: However, adding an exercise to the workout is part of a larger process of building
    the workout and using child/parent inter-component communication would make the
    implementation of the `AddExercise` method differ from the other functionality
    that we will be adding going forward.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，将练习添加到锻炼中是构建锻炼的一个较大过程的一部分，使用子/父组件间通信将使“AddExercise”方法的实现与我们将要添加的其他功能有所不同。
- en: For this reason, it makes more sense to follow another approach for sharing
    data, one that we can use consistently throughout the process of building a workout.
    That approach involves using a service. As we get into adding the other functionality
    for creating an actual workout, such as save/update logic, and implementing the
    other relevant components, the benefits of going down the service route will become
    increasingly clear.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于共享数据，更有意义的是采用另一种方法，这是我们可以在整个构建锻炼的过程中一致使用的方法。这种方法涉及使用服务。随着我们开始添加用于创建实际锻炼的其他功能，例如保存/更新逻辑，并实现其他相关组件，采用服务路线的好处将变得越来越明显。
- en: So we introduce a new service into the picture: the `WorkoutBuilderService`.
    The ultimate aim of the `WorkoutBuilderService` service is to co-ordinate between
    the `WorkoutService` (which retrieves and persists the workout) and the components
    (such as `LeftNavExercisesComponent` and others we will add later), while the
    workout is being built, hence reducing the amount of code in `WorkoutComponent`
    to the bare minimum.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们引入了一个新的服务：`WorkoutBuilderService`。`WorkoutBuilderService`服务的最终目标是在构建锻炼时协调`WorkoutService`（用于检索和保存锻炼）和组件（例如`LeftNavExercisesComponent`和我们稍后将添加的其他组件），从而将`WorkoutComponent`中的代码量减少到最低限度。
- en: Adding WorkoutBuilderService
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加WorkoutBuilderService
- en: '`WorkoutBuilderService` tracks the state of the workout being built. It:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutBuilderService`跟踪正在构建的锻炼的状态。它：'
- en: Tracks the current workout
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪当前锻炼
- en: Creates a new workout
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的锻炼
- en: Loads the existing workout
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载现有的锻炼
- en: Saves the workout
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存锻炼
- en: Copy `workout-builder-service.ts` from the `workout-builder/builder-services`
    folder under `trainer/src/components` in `checkpoint 4.5`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 从`checkpoint 4.5`中的`trainer/src/components`文件夹下的`workout-builder/builder-services`文件夹中复制`workout-builder-service.ts`。
- en: Note
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code is also available for everyone to download on GitHub at [https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample).
    Checkpoints are implemented as branches in GitHub. The branch to download is as
    follows: **GitHub Branch: checkpoint4.5** (folder - `trainer`). If you are not
    using Git, download the snapshot of Checkpoint 4.5 (a ZIP file) from the following
    GitHub location: [https://github.com/chandermani/angular2byexample/archive/checkpoint4.5.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint4.5.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time. Again, if you are working along with us as we build the application,
    be sure to update the `app.css` file, which we are not discussing here.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码也可供所有人在GitHub上下载[https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample)。检查点在GitHub中作为分支实现。要下载的分支如下：**GitHub分支：checkpoint4.5**（文件夹-`trainer`）。如果您不使用Git，请从以下GitHub位置下载Checkpoint
    4.5的快照（ZIP文件）：[https://github.com/chandermani/angular2byexample/archive/checkpoint4.5.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint4.5.zip)。首次设置快照时，请参阅`trainer`文件夹中的`README.md`文件。再次，如果您正在与我们一起构建应用程序，请确保更新`app.css`文件，这里我们不讨论。
- en: 'While we normally make services available application-wide,  `WorkoutBuilderService`
    will only be used in the *Workout Builder* feature. Therefore, instead of registering
    it with the providers in `AppModule`, we will register it in the provider array
    of `WorkoutBuilderModule` as follows (after adding it as an import at the top
    of the file):'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们通常会在整个应用程序中提供服务，但`WorkoutBuilderService`只会在*Workout Builder*功能中使用。因此，我们将在`WorkoutBuilderModule`的提供程序数组中注册它，而不是在`AppModule`中注册它（在文件顶部添加导入后）：
- en: '[PRE27]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Adding it as a provider here means that it will only be loaded when the *Workout
    Builder* feature is being accessed and it cannot be reached outside this module.
    This means that it can be evolved independently of other modules in the application
    and can be modified without affecting other parts of the application.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里将其添加为提供者意味着只有在访问*Workout Builder*功能时才会加载它，并且无法在此模块之外访问。这意味着它可以独立于应用程序中的其他模块进行演变，并且可以在不影响应用程序其他部分的情况下进行修改。
- en: Let's look at some of the relevant parts of the service.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下服务的一些相关部分。
- en: '`WorkoutBuilderService` needs the type definitions for `WorkoutPlan`, `Exercise`,
    and `WorkoutService`, so we import these into the component:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutBuilderService`需要`WorkoutPlan`，`Exercise`和`WorkoutService`的类型定义，因此我们将其导入到组件中：'
- en: '[PRE28]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`WorkoutBuilderService` has a dependency on `WorkoutService` to provide persistence
    and querying capabilities. We resolve this dependency by injecting `WorkoutService`
    into the constructor for `WorkoutBuilderService` **:**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutBuilderService`依赖于`WorkoutService`来提供持久性和查询功能。我们通过将`WorkoutService`注入到`WorkoutBuilderService`的构造函数中来解决这个依赖关系**：**'
- en: '[PRE29]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`WorkoutBuilderService` also needs to track the workout being built. We use
    the `buildingWorkout` property for this. The tracking starts when we call the
    `startBuilding` method on the service:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutBuilderService`还需要跟踪正在构建的锻炼。我们使用`buildingWorkout`属性来实现这一点。当我们在服务上调用`startBuilding`方法时，跟踪开始：'
- en: '[PRE30]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The basic idea behind this tracking function is to set up a `WorkoutPlan` object
    (`buildingWorkout`) that will be made available to components to manipulate the
    workout details. The `startBuilding` method takes the workout name as a parameter.
    If the name is not provided, it implies we are creating a new workout, and hence
    a new `WorkoutPlan` object is created and assigned; if not, we load the workout
    details by calling `WorkoutService.getWorkout(name)`. In any case, the `buildingWorkout`
    object has the workout being worked on.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 此跟踪功能背后的基本思想是设置一个`WorkoutPlan`对象（`buildingWorkout`），以便让组件可以操纵锻炼的细节。`startBuilding`方法以锻炼名称作为参数。如果未提供名称，则意味着我们正在创建新的锻炼，因此将创建并分配一个新的`WorkoutPlan`对象；如果提供名称，则通过调用`WorkoutService.getWorkout(name)`加载锻炼详情。在任何情况下，`buildingWorkout`对象都包含正在进行的锻炼。
- en: The `newWorkout` object signifies whether the workout is new or an existing
    one. It is used to differentiate between save and update situations when the `save`
    method on this service is called.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`newWorkout`对象表示锻炼是新的还是现有的。在调用此服务的`save`方法时，它用于区分保存和更新情况。'
- en: The rest of the methods, `removeExercise`, `addExercise`, and `moveExerciseTo`, are
    self-explanatory and affect the exercise list that is part of the workout (`buildingWorkout`).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的方法，`removeExercise`，`addExercise`和`moveExerciseTo`，都是不言自明的，并影响锻炼（`buildingWorkout`）的一部分的锻炼列表。
- en: '`WorkoutBuilderService` is calling a new method, `getWorkout`, on `WorkoutService`,
    which we have not added yet. Go ahead and copy the `getWorkout` implementation
    from the `workout-service.ts` file in the `services` folder under `trainer/src`
    in `checkpoint 4.5`. We will not dwell on the new service code as the implementation
    is quite simple.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutBuilderService`正在调用`WorkoutService`上的一个新方法`getWorkout`，我们还没有添加。继续并从`checkpoint
    4.5`中`trainer/src`下的`services`文件夹中的`workout-service.ts`文件中复制`getWorkout`的实现。我们不会深入讨论新服务代码，因为实现非常简单。'
- en: Let's get back to left nav and implement the remaining functionality.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到左侧导航栏并实现剩余的功能。
- en: Adding exercises using ExerciseNav
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ExerciseNav添加锻炼
- en: 'To add exercises to the workout we are building, we just need to import and
    inject `WorkoutBuilderService` into the `LeftNavExercisesComponent` and call its
    `addExercise` method, passing the selected exercise as a parameter:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要将练习添加到我们正在构建的训练中，我们只需要将`WorkoutBuilderService`导入并注入`LeftNavExercisesComponent`，然后调用它的`addExercise`方法，将所选的练习作为参数传递：
- en: '[PRE31]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Internally, `WorkoutBuilderService.addExercise` updates the `buildingWorkout`
    model data with the new exercise.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`WorkoutBuilderService.addExercise`会使用新的练习更新`buildingWorkout`模型数据。
- en: The preceding implementation is a classic case of sharing data between independent
    components. The shared service exposes the data in a controlled manner to any
    component that requests it. While sharing data, it is always a good practice to
    expose the state/data using methods instead of directly exposing the data object.
    We can see that in our component and service implementations too. `LeftNavExercisesComponent`
    does not update the workout data directly; in fact, it does not have direct access
    to the workout being built. Instead, it relies upon the service method, `addExercise`,
    to change the current workout's exercise list.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的实现是共享独立组件之间数据的经典案例。共享服务以受控的方式向任何请求数据的组件公开数据。在共享数据时，最好的做法是使用方法来公开状态/数据，而不是直接公开数据对象。我们在组件和服务的实现中也可以看到这一点。`LeftNavExercisesComponent`并不直接更新训练数据；事实上，它并没有直接访问正在构建的训练。相反，它依赖于服务方法`addExercise`来改变当前训练的练习列表。
- en: Since the service is shared, there are pitfalls to be aware of. As services
    are injectable through the system, we cannot stop any component from taking dependency
    on any service and calling its functions in an inconsistent manner, leading to
    undesired results or bugs. For example, `WorkoutBuilderService` needs to be initialized
    by calling `startBuilding` before `addExercise` is called. What happens if a component
    calls `addExercise` before the initialization takes place?
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务是共享的，需要注意一些潜在的问题。由于服务可以通过系统注入，我们无法阻止任何组件依赖任何服务并以不一致的方式调用其函数，导致不良结果或错误。例如，`WorkoutBuilderService`需要在调用`addExercise`之前通过调用`startBuilding`进行初始化。如果一个组件在初始化之前调用`addExercise`会发生什么？
- en: Implementing the Workout component
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现训练组件
- en: The `Workout` component is responsible for managing a workout. This includes
    creating, editing, and viewing the workout. Due to the introduction of `WorkoutBuilderService`,
    the overall complexity of this component will be reduced. Other than the primary
    responsibility of integrating with, exposing, and interacting with its template
    view, we will delegate most of the other work to `WorkoutBuilderService`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`Workout`组件负责管理训练。这包括创建、编辑和查看训练。由于引入了`WorkoutBuilderService`，这个组件的整体复杂性将会降低。除了与模板视图集成、公开和交互的主要责任外，我们将把大部分其他工作委托给`WorkoutBuilderService`。'
- en: The `Workout` component is associated with two routes/views, namely `/builder/workout/new`
    and `/builder/workout/:id`. These routes handle both creating and editing workout
    scenarios. The first job of the component is to load or create the workout that
    it needs to manipulate.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`Workout`组件与两个路由/视图相关联，即`/builder/workout/new`和`/builder/workout/:id`。这些路由处理创建和编辑训练的情况。组件的第一个任务是加载或创建它需要操作的训练。'
- en: Route parameters
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由参数
- en: But before we get to building out the `WorkoutComponent`and its associated view,
    we need to touch briefly on the navigation that brings a user to the screen for
    that component. This component handles both creating and editing workout scenarios.
    The first job of the component is to load or create the workout that it needs
    to manipulate. We plan to use Angular's routing framework to pass the necessary
    data to the component, so that it will know whether it is editing an existing
    workout or creating a new one, and in the case of an existing workout, which component
    it should be editing.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们开始构建`WorkoutComponent`及其相关视图之前，我们需要简要介绍一下将用户带到该组件屏幕的导航。该组件处理创建和编辑锻炼场景。组件的第一个任务是加载或创建它需要操作的锻炼。我们计划使用Angular的路由框架将必要的数据传递给组件，以便它知道它是在编辑现有的锻炼还是创建新的锻炼，并在现有的锻炼的情况下，应该编辑哪个组件。
- en: How is this done? `WorkoutComponent` is associated with two routes, namely `/builder/workout/new`
    and `/builder/workout/:id`. The difference in these two routes lies in what is
    at the end of these routes; in one case, it is `/new`, and in the other` /:id`.
    These are called **route parameters.** The `:id` in the second route is a token
    for a route parameter. The router will convert the token to the ID for the workout
    component. As we saw earlier, this means that the URL that will be passed to the
    component in the case of *7 Minute Workout* will be `/builder/workout/7MinuteWorkout`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何完成的？`WorkoutComponent`与两个路由相关联，即`/builder/workout/new`和`/builder/workout/:id`。这两个路由的区别在于这些路由的结尾处;
    在一个情况下，是`/new`，在另一个情况下是`/:id`。这些被称为**路由参数**。第二个路由中的`:id`是路由参数的一个标记。路由器将把标记转换为锻炼组件的ID。正如我们之前看到的，这意味着在*7分钟锻炼*的情况下，将传递给组件的URL将是`/builder/workout/7MinuteWorkout`。
- en: 'How do we know that this workout name is the right parameter for the ID? As
    you recall, when we set up the event for handling a click on the **Workout** tiles
    on the **Workouts** screen that takes us to the **Workout** screen, we designated
    the workout name as the parameter for the ID, like so:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道这个锻炼名称是ID的正确参数？正如您回忆的那样，当我们设置处理**锻炼**屏幕上的**锻炼**瓷砖点击的事件时，我们将锻炼名称指定为ID的参数，如下所示：
- en: '[PRE32]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we are constructing the route using the programmatic interface for the
    router (we covered routing in detail in the previous chapter, so we won't go over
    that again here). The `router.navigate` method accepts an array. This is called
    the **link parameters array**. The first item in the array is the path of the
    route, and the second is a route parameter that specifies the ID of the workout.
    In this case, we set the `id` parameter to the workout name. From our discussion
    of routing in the previous chapter, we know that we can also construct the same
    type of URL as part of a router link or simply enter it in the browser to get
    to the **Workouts** screen and edit a particular workout.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在使用路由器的编程接口构建路由（我们在上一章节详细介绍了路由，所以这里不再赘述）。`router.navigate`方法接受一个数组。这被称为**链接参数数组**。数组中的第一项是路由的路径，第二项是指定锻炼的ID的路由参数。在这种情况下，我们将`id`参数设置为锻炼名称。根据我们在上一章节对路由的讨论，我们知道我们也可以构建相同类型的URL作为路由链接的一部分，或者简单地在浏览器中输入它以到达**锻炼**屏幕并编辑特定的锻炼。
- en: The other of the two routes ends with `/new`. Since this route does not have
    a `token` parameter, the router will simply pass the URL unmodified to the `WorkoutComponent`.
    The `WorkoutComponent` will then need to parse the incoming URL to identify that
    it should be creating a new component.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个路由中的一个以`/new`结尾。由于这个路由没有`token`参数，路由器将简单地将URL不加修改地传递给`WorkoutComponent`。然后，`WorkoutComponent`需要解析传入的URL，以确定它应该创建一个新的组件。
- en: Route guards
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由守卫
- en: But before the link takes the user to the `WorkoutComponent`, there is another
    step along the way that we need to consider. The possibility always exists that
    the ID that is passed in the URL for editing a workout could be incorrect or missing.
    In those cases, we do not want the component to load, but instead we want to have
    the user redirected to another page or back to where they came from.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 但在链接将用户带到“WorkoutComponent”之前，还有另一个步骤需要考虑。始终存在一个可能性，即传递到编辑锻炼的URL中的ID可能不正确或丢失。在这些情况下，我们不希望组件加载，而是希望用户被重定向到另一个页面或返回到他们来自的地方。
- en: Angular offers a way to accomplish this result with **route guards**. As the
    name implies, route guards **provide a way to prevent navigation to a route**.
    A route guard can be used to inject custom logic that can do things such as check
    authorization, load data, and make other verifications to determine if the navigation
    to the component needs to be cancelled or not. And all of this is done before
    the component loads so it is never seen if the routing is canceled.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了一种使用路由守卫来实现此结果的方法。顾名思义，路由守卫提供了一种阻止导航到路由的方法。路由守卫可用于注入自定义逻辑，可以执行诸如检查授权、加载数据和进行其他验证等操作，以确定是否需要取消导航到组件。所有这些都是在组件加载之前完成的，因此如果取消了路由，则永远不会看到该组件。
- en: Angular offers several route guards, including `CanActivate`, `CanActivateChild`,
    `CanDeActivate`, `Resolve`, and `CanLoad`. At this point we are interested in
    the first of these these hooks: `CanActivate`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了几种路由守卫，包括`CanActivate`、`CanActivateChild`、`CanDeActivate`、`Resolve`和`CanLoad`。在这一点上，我们对第一个感兴趣：`CanActivate`。
- en: Implementing the CanActivate route guard
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现CanActivate路由守卫
- en: The `CanActivate` guard permits navigation to proceed or stops it based on the
    conditions that we set up in the implementation that we provide. In our case,
    what we want to do is use `CanActivate` to check the validity of any id that is
    passed for an existing workout. Specifically, we will run a check on that ID by
    making a call to the `WorkoutService` to retrieve the Workout Plan and see if
    it exists. If it exists, we will let the navigation proceed; if not we will stop
    it.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`CanActivate`守卫允许导航继续进行或根据我们提供的实现中设置的条件停止它。在我们的情况下，我们要做的是使用`CanActivate`来检查传递给现有锻炼的任何ID的有效性。具体来说，我们将通过调用`WorkoutService`来检查该ID，以检索锻炼计划并查看其是否存在。如果存在，我们将允许导航继续进行；如果不存在，我们将停止它。'
- en: 'Copy `workout.guard.ts` from the workout-builder/workout folder under `trainer/src/components`
    in `checkpoint 4.5` and you will see the following code:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 从`checkpoint 4.5`的`trainer/src/components`下的`workout-builder/workout`文件夹中复制`workout.guard.ts`，您将看到以下代码：
- en: '[PRE33]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see the guard is an injectable class that implements the `CanActivate`
    interface. We implement the interface with the `CanActivate` method. The `CanActivate`
    method accepts two parameters; the `ActivatedRouteSnapshot` and the `RouterStateSnapshot`.
    In this case, we are only interested in the first of these two parameters. This
    parameter contains a `params` array from which we extract the id parameter for
    the route.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，守卫是一个可注入的类，实现了“CanActivate”接口。我们使用“CanActivate”方法实现接口。CanActivate方法接受两个参数；ActivatedRouteSnapshot和RouterStateSnapshot。在这种情况下，我们只对这两个参数中的第一个感兴趣。该参数包含一个params数组，我们从中提取路由的id参数。
- en: The `CanActivate` method can return either a simple `boolean` value or an `Observable<boolean>`.
    The latter is useful if we have to make an asynchronous call as part of the method.
    If we return an `Observable`, the router will wait until the asynchronous call
    is resolved before proceeding with navigation. In this case, however, we are not
    making such an asynchronous call, as we are using a local in-memory data store.
    So we are just returning a simple true/false `boolean`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`CanActivate`方法可以返回简单的`boolean`值或`Observable<boolean>`。如果我们需要在方法中进行异步调用，后者会很有用。如果我们返回`Observable`，则路由将等待异步调用解析后再继续导航。然而，在这种情况下，我们并没有进行这样的异步调用，因为我们使用的是本地内存数据存储。所以我们只是返回一个简单的true/false
    `boolean`。'
- en: Note
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the next chapter, when we start using the HTTP module to make asynchronous
    calls to an external data store, we will refactor this code to return an `Observable<boolean>`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，当我们开始使用HTTP模块向外部数据存储进行异步调用时，我们将重构此代码以返回`Observable<boolean>`。
- en: This code injects the `WorkoutService` into the guard. The `CanActivate` method
    then calls the `GetWorkout` method of the `WorkoutService` using the parameter
    supplied in the route. If the workout exists, then `canActivate` returns true
    and the navigation proceeds; if not, it re-routes the user to the workouts page
    and returns false.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将`WorkoutService`注入到了守卫中。然后，`CanActivate`方法使用路由中提供的参数调用`WorkoutService`的`GetWorkout`方法。如果锻炼存在，则`canActivate`返回true并进行导航；如果不存在，则重新将用户重定向到锻炼页面并返回false。
- en: 'The final step in implementing `WorkoutGuard` is to add it to the route configuration
    for `WorkoutComponent`. So update `workout-builder.routes.ts` as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`WorkoutGuard`的最后一步是将其添加到`WorkoutComponent`的路由配置中。因此，按照以下方式更新`workout-builder.routes.ts`：
- en: '[PRE34]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With this configuration, we are assigning `WorkoutGuard` to the `canActivate`
    property of the route for `WorkoutComponent`. This means that `WorkoutGuard` will
    be called prior to the router navigating to `WorkoutComponent`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个配置，我们将`WorkoutGuard`分配给`WorkoutComponent`路由的`canActivate`属性。这意味着在路由导航到`WorkoutComponent`之前将调用`WorkoutGuard`。
- en: Implementing the Workout component continued...
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续实现Workout组件...
- en: Now that we have established the routing that takes us to the `Workout` component,
    let's turn to completing its implementation. So copy the `workout.component.ts`
    file from the `workout-builder/workout` folder under trainer/src/components in
    `checkpoint 4.5`. (Also copy `workout-builder.module.ts` from the `workout-builder`
    folder. We'll discuss the changes in this file a little later when we get to Angular
    forms.)
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了将我们带到`Workout`组件的路由，让我们转而完成它的实现。因此，从`checkpoint 4.5`中的`trainer/src/components`文件夹下的`workout-builder/workout`文件夹中复制`workout.component.ts`文件。（还要复制`workout-builder.module.ts`文件夹中的`workout-builder`文件夹。当我们开始使用Angular表单时，稍后我们将讨论此文件中的更改。）
- en: 'Open `workout.component.ts` and you''ll see that we have added a constructor
    that injects `ActivatedRoute` and `WorkoutBuilderService`:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`workout.component.ts`，你会看到我们添加了一个构造函数，用于注入`ActivatedRoute`和`WorkoutBuilderService`：
- en: '[PRE35]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In addition, we have added the following `ngOnInit` method:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们添加了以下`ngOnInit`方法：
- en: '[PRE36]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The method subscribes to the route parameters and extracts the `id` parameter
    for the workout. If no ID is found, then we treat it as a new workout since `workout/new`
    is the only path that is configured in `WorkoutBuilderRoutes` that we allow to
    reach this screen without an ID. In that case, we provide an empty string as a
    parameter in the call to the `StartBuilding` method of the `WorkoutBuilderService`, which
    will cause it to return a new Workout.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法订阅路由参数并提取锻炼的`id`参数。如果没有找到ID，则我们将其视为新的锻炼，因为`workout/new`是唯一配置在`WorkoutBuilderRoutes`中允许在没有ID的情况下到达此屏幕的路径。在这种情况下，我们在调用`WorkoutBuilderService`的`StartBuilding`方法时提供一个空字符串作为参数，这将导致它返回一个新的锻炼。
- en: Note
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are subscribing to the route parameters because they are `Observables`, which
    can change during the lifetime of the component. This gives us the ability to
    reuse the same component instance with different parameters even though the `OnInit`
    life cycle event for that component is called only once. We'll cover `Observables`
    in detail in the next chapter.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们订阅路由参数，因为它们是`Observables`，可以在组件的生命周期内发生变化。这使我们能够重用相同的组件实例，即使该组件的`OnInit`生命周期事件只被调用一次。我们将在下一章节详细介绍`Observables`。
- en: In addition to this code, we have also added a series of methods to the `Workout
    Component` for adding, removing,  and moving a workout. These methods all call
    corresponding methods on the `WorkoutBuilderService` and we will not review them
    in detail here. We've also added an array of `durations` for populating the duration
    drop-down list.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这段代码，我们还为`Workout Component`添加了一系列方法，用于添加、删除和移动训练。这些方法都调用了`WorkoutBuilderService`上对应的方法，我们不会在这里详细讨论它们。我们还添加了一个`durations`数组，用于填充持续时间下拉列表。
- en: For now, this is enough for the **component** class implementation. Let's update
    the associated `Workout` template.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这对于**组件**类的实现就足够了。让我们更新相关的`Workout`模板。
- en: Implementing the Workout template
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现训练模板
- en: Now copy the `workout.component.html` files from the `workout-builder/workout`
    folder under `trainer/src/components` in `checkpoint 4.5`. Run the app, navigate
    to `/builder/workouts`, and double-click on the *7 Minute Workout* tile. This
    should load the *7 Minute Workout* details with a view similar to the one shown
    at the start of the *Building a workout* section.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从`checkpoint 4.5`的`trainer/src/components`下的`workout-builder/workout`文件夹中复制`workout.component.html`文件。运行应用程序，导航到`/builder/workouts`，双击*7
    Minute Workout*瓷砖。这应该加载*7 Minute Workout*的详细信息，视图类似于*构建训练*部分开头显示的视图。
- en: Note
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In the event of any problem, you can refer to the `checkpoint4.5` code in the
    **GitHub repository: Branch: checkpoint4.5** (folder - `trainer`).'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现任何问题，您可以参考**GitHub存储库：分支：checkpoint4.5**（文件夹 - `trainer`）中的`checkpoint4.5`代码。
- en: We will be dedicating a lot of time to this view, so let's understand some specifics
    here.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将花费大量时间在这个视图上，所以让我们在这里了解一些具体情况。
- en: 'The exercise list div (`id="exercise-list"`) lists the exercises that are part
    of the workout in order. We display them as top-to-bottom tiles in the left part
    of the content area. Functionally, this template has:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 练习列表div（`id="exercise-list"`）按顺序列出了训练中的练习。我们将它们显示为内容区域左侧的从上到下的瓷砖。从功能上讲，这个模板有：
- en: The Delete button to delete the exercise
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除按钮，用于删除练习
- en: Reorder buttons to move the exercise up and down the list as well as to the
    top and bottom
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新排序按钮，将练习上移和下移列表，以及移到顶部和底部
- en: 'We use `ngFor` to iterate over the list of exercises and display them:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ngFor`来迭代练习列表并显示它们：
- en: '[PRE37]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You will notice that we are using the `*` asterisk in front of `ngFor`,  which
    is shorthand for the `<template>` tag. We are also using `let` to set two local
    variables: `exerisePlan` to identify an item in the list of exercises and `i`
    to set up an index value that we will use to show a number for the exercises as
    they are displayed on the screen. We will also use the index value to manage reordering
    and deleting exercises from the list.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们在`ngFor`前面使用了`*`星号，这是`<template>`标签的简写。我们还使用`let`来设置两个局部变量：`exerisePlan`用于标识练习列表中的项目，`i`用于设置一个索引值，我们将用它来在屏幕上显示练习的编号。我们还将使用索引值来管理重新排序和从列表中删除练习。
- en: The second div element for workout data (`id="workout-data"`) contains the HTML
    input element for details such as name, title, and rest duration and a button
    to save workout changes.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 用于训练数据的第二个div元素（`id="workout-data"`）包含了HTML输入元素，用于名称、标题和休息持续时间的详细信息，以及一个保存训练更改的按钮。
- en: The complete list has been wrapped inside the HTML form element so that we can
    make use of the form-related capabilities that Angular provides. So what are these
    capabilities?
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的列表已经包含在HTML表单元素中，以便我们可以利用Angular提供的与表单相关的功能。那么这些功能是什么呢？
- en: Angular forms
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular表单
- en: Forms are such an integral part of HTML development that any framework that
    targets client-side development just cannot ignore them. Angular provides a small
    but well-defined set of constructs that make standard form-based operations easier.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 表单是HTML开发的一个重要部分，以至于任何针对客户端开发的框架都不能忽视它们。Angular提供了一组小而明确定义的构造，使标准的基于表单的操作更容易。
- en: 'If we think carefully, any form of interaction boils down to:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细思考，任何形式的交互都归结为：
- en: Allowing user inputs
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户输入
- en: Validating those inputs against business rules
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据业务规则验证这些输入
- en: Submitting the data to the backend server
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据提交到后端服务器
- en: Angular has something to offer for all the preceding use cases.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有前述的用例，Angular都有一些东西可以提供。
- en: For user input, it allows us to create two-way bindings between the form input
    elements and the underlying model, hence avoiding any boilerplate code that we
    may have to write for model input synchronization.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入允许我们在表单输入元素和底层模型之间创建双向绑定，从而避免我们可能需要为模型输入同步编写的任何样板代码。
- en: It also provides constructs to validate the input before it can be submitted.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供了在提交之前验证输入的构造。
- en: Lastly, Angular provides `http` services for client-server interaction and persisting
    data to the server. We'll cover those services in [Chapter 5](part0056.xhtml#aid-1LCVG2
    "Chapter 5.  Supporting Server Data Persistence"), *Supporting Server Data Persistence*.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Angular提供了用于客户端-服务器交互和将数据持久化到服务器的`http`服务。我们将在[第5章](part0056.xhtml#aid-1LCVG2
    "第5章。支持服务器数据持久化")中介绍这些服务，*支持服务器数据持久化*。
- en: Since the first two use cases are our main focus in this chapter, let's learn
    more about Angular user input and data validation support.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前两个用例是本章的主要重点，让我们更多地了解一下Angular用户输入和数据验证支持。
- en: Template-driven and model-driven forms
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板驱动和模型驱动表单
- en: 'Angular offers two types of forms: **template-driven** and **model-driven**.
    We''ll be discussing both types of form in this chapter. Because the Angular team
    is indicating that many of us will primarily use **template-driven forms**, that
    is what we will start with in this chapter.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供两种类型的表单：**模板驱动**和**模型驱动**。我们将在本章讨论这两种类型的表单。因为Angular团队表示我们中的许多人主要会使用**模板驱动表单**，这就是我们将在本章开始讨论的内容。
- en: Template-driven forms
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板驱动表单
- en: As the name suggests, **template-driven forms** place the emphasis on developing
    a form within an HTML template and handling most of the logic for the form-inputs,
    data validation, saving, and updating-in form directives placed within that template.
    The result is that very little form-related code is required in the component
    class that is associated with the form's template.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，**模板驱动表单**侧重于在HTML模板中开发表单，并处理大部分与表单输入、数据验证、保存和更新相关的逻辑-在该模板中放置的表单指令中。结果是与与表单相关的代码在与表单模板相关联的组件类中所需的非常少。
- en: '**Template-driven forms** make heavy use of the `ngModel` form directive. We
    will be discussing it in the next sections. It provides two-way databinding for
    form controls, which is a nice feature indeed. It allows us to write much less
    boilerplate code to implement a form. It also helps us to manage the state of
    the form (such as whether the form controls have changed and whether these changes
    have been saved). And it also gives us the ability to easily construct messages
    that display if the validation requirements for a form control have not been met
    (for example, a required field not provided, e-mail not in the right format, and
    so on).'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 模板驱动表单大量使用`ngModel`表单指令。我们将在接下来的部分讨论它。它为表单控件提供了双向数据绑定，这确实是一个很好的功能。它允许我们编写更少的样板代码来实现一个表单。它还帮助我们管理表单的状态（例如，表单控件是否已更改以及这些更改是否已保存）。它还使我们能够轻松构建消息，显示如果表单控件的验证要求未满足（例如，未提供必填字段，电子邮件格式不正确等）。
- en: Getting started
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: 'In order to use Angular forms in our `Workout` component, we must first add
    some additional configurations. First, open the `systemjs.config.js` file in the
    `trainer` folder in `checkpoint 4.5` and add forms to the `ngPackageNames` array:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的`Workout`组件中使用Angular表单，我们必须首先添加一些额外的配置。首先，打开`checkpoint 4.5`中`trainer`文件夹中的`systemjs.config.js`文件，并将表单添加到`ngPackageNames`数组中：
- en: '[PRE38]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: With this in place, SystemJS will download this module for use in our application.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，SystemJS将下载这个模块供我们的应用程序使用。
- en: 'Next, open the copy of `workout-buider.module.ts` from the `workout-builder`
    folder under `trainer/src/components` in `checkpoint 4.5`. You will see that it
    adds the following highlighted code:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开`checkpoint 4.5`中`trainer/src/components`下`workout-builder`文件夹中的`workout-buider.module.ts`的副本。您将看到它添加了以下突出显示的代码：
- en: '[PRE39]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This indicates that we will be using the forms module. Once we make this change,
    we will not have to do any further imports related to forms in the `Workout` component.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们将使用表单模块。一旦我们做出这个改变，我们将不必在`Workout`组件中进行与表单相关的进一步导入。
- en: 'This brings in all the directives that we will need to implement our form including:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这引入了我们实现表单所需的所有指令，包括：
- en: '`NgForm`'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NgForm`'
- en: '`ngModel`'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngModel`'
- en: Let's start using these to build our form.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用这些来构建我们的表单。
- en: Using NgForm
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用NgForm
- en: 'In our template, we have added the following `form` tag:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模板中，我们添加了以下`form`标签：
- en: '[PRE40]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Let's take a look at what we have here. One interesting thing is that we are
    still using a standard `<form>` tag and not a special Angular tag. We've also
    used `#` to define a local variable `#f` to which we have assigned `ngForm`. Creating
    this local variable provides us with the convenience of being able to use it for
    form-related activity in other places within the form. For example, you can see
    that we are using it at the end of the opening `form` tag in a parameter, `f.form`,
    which is being passed to the `onSubmit` event bound to `(ngSubmit)`.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们这里有什么。一个有趣的事情是，我们仍然使用标准的`<form>`标签，而不是特殊的Angular标签。我们还使用`#`来定义一个本地变量`#f`，我们已经分配了`ngForm`。创建这个本地变量使我们能够在表单内的其他地方使用它进行与表单相关的活动。例如，您可以看到我们在开放的`form`标签的末尾使用它作为参数，`f.form`，它被传递给绑定到`(ngSubmit)`的`onSubmit`事件。
- en: That last binding to `(ngSubmit)` should tell us that something different is
    going on here. Even though we did not explicitly add the `NgForm` directive, our
    `<form>` now has additional events such as `ngSubmit` to which we can bind actions.
    How did this happen? Well, this was **not** triggered by our assigning `ngForm`
    to a local variable. Instead, it happened *auto-magically* because we imported
    the forms module into `workout-builder.module.ts`.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 最后绑定到`(ngSubmit)`的内容应该告诉我们这里发生了一些不同的事情。即使我们没有明确添加`NgForm`指令，我们的`<form>`现在有了额外的事件，比如`ngSubmit`，我们可以将动作绑定到这些事件上。这是怎么发生的呢？嗯，这并不是因为我们将`ngForm`分配给了一个本地变量。相反，这是*自动*发生的，因为我们在`workout-builder.module.ts`中导入了表单模块。
- en: With that import in place, Angular scanned our template for a `<form>` tag and
    wrapped that `<form>` tag within an `NgForm` directive. The Angular documentation
    indicates that `<form>` elements in the component will be upgraded to use the
    Angular form system. This is important because it means that various capabilities
    of the `NgForm` directive are now available to use with the form. These include
    the `ngSubmit` event, which signals when a user has triggered a form submission
    and provides the ability to validate the entire form before submitting it.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个导入，Angular扫描我们的模板，找到了一个`<form>`标签，并将该`<form>`标签包装在`NgForm`指令中。Angular文档表明，组件中的`<form>`元素将升级为使用Angular表单系统。这很重要，因为这意味着`NgForm`指令的各种功能现在可以与表单一起使用。其中包括`ngSubmit`事件，该事件在用户触发表单提交时发出信号，并提供在提交之前验证整个表单的能力。
- en: ngModel
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ngModel
- en: One of the fundamental building blocks for template-driven forms is `ngModel`
    **,** and you will find it being used throughout our form. One of the primary
    roles of `ngModel` is to support two-way binding between user input and an underlying
    model. With such a setup, changes in the model are reflected in the view, and
    updates to the view too are reflected back on the model. Most of the other directives
    that we have covered so far only support one-way binding from models to views.
    This is also due to the fact that `ngModel` is only applied to elements that allow
    user input.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 模板驱动表单的基本构建块之一是`ngModel`，你会发现它在我们的表单中被广泛使用。`ngModel`的主要作用之一是支持用户输入和底层模型之间的双向绑定。有了这样的设置，模型中的更改会反映在视图中，视图的更新也会反映在模型上。到目前为止，我们所涵盖的大多数其他指令只支持从模型到视图的单向绑定。这也是因为`ngModel`仅应用于允许用户输入的元素。
- en: 'As you know, we already have a model that we are using for the **Workout**
    page-`WorkoutPlan`. Here is the `WorkoutPlan` model from `model.ts`:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，我们已经有一个模型，我们正在用于**Workout**页面-`WorkoutPlan`。这是`model.ts`中的`WorkoutPlan`模型：
- en: '[PRE41]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note the use of the `?` after `description`. This means that it is an optional
    property in our model and is not required to create a `WorkoutPlan`. In our form,
    this will mean that we will not require that a description be entered and everything
    will work fine without it.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`description`后面使用了`?`。这意味着它是我们模型中的一个可选属性，不需要创建`WorkoutPlan`。在我们的表单中，这意味着我们不需要输入描述，一切都可以正常工作。
- en: 'Within the `WorkoutPlan` model we also have a reference to an array made up
    of instances of another type of model: `ExercisePlan`. `ExercisePlan` in turn
    is made up of a number (`duration`) and another model (`Exercise`), which looks
    like this:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WorkoutPlan`模型中，我们还引用了由另一种类型的模型实例组成的数组：`ExercisePlan`。`ExercisePlan`又由一个数字（`duration`）和另一个模型（`Exercise`）组成，看起来像这样：
- en: '[PRE42]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Notice that we have decorated both model classes with `@Injectable`. This is
    used so that TypeScript will generate the necessary metadata for the entire object
    hierarchy, in this case the nested classes `ExercisePlan` within `WorkoutPlan`
    and `Exercise` within `ExercisePlan`. What this means is that we can create complex
    hierarchies of models that can all be data-bound within our form using `NgModel`.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经用`@Injectable`装饰了两个模型类。这是为了让TypeScript为整个对象层次结构生成必要的元数据，即`WorkoutPlan`中的嵌套类`ExercisePlan`和`ExercisePlan`中的`Exercise`。这意味着我们可以创建复杂的模型层次结构，所有这些模型都可以在我们的表单中使用`NgModel`进行数据绑定。
- en: So throughout the form, whenever we need to update one of the values in a `WorkoutPlan`
    or an `ExercisePlan`, we can use `NgModel` to do that (the `WorkoutPlan` model
    will be represented by a local variable named `workout` in the following examples).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在整个表单中，每当我们需要更新`WorkoutPlan`或`ExercisePlan`中的一个值时，我们可以使用`NgModel`来实现（在以下示例中，`WorkoutPlan`模型将由一个名为`workout`的局部变量表示）。
- en: Using ngModel with input and textarea
  id: totrans-406
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用ngModel与输入和文本区域。
- en: 'Open `workout-component.html` and look for `ngModel.` Here too, it has only
    been applied to HTML elements that allow user data input. These include input,
    textarea, and select. The workout name input setup looks like this:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`workout-component.html`并查找`ngModel`。这里，它只应用于允许用户输入数据的HTML元素。这些包括input、textarea和select。练习名称输入设置如下：
- en: '[PRE43]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The preceding `[(ngModel)]` directive sets up a two-way binding between the
    input control and the `workout.name` model property. The brackets and parentheses
    should each look familiar. Previously we used them separately from each other:
    the `[]` brackets for property binding and the `()` parentheses for event binding.
    In the latter case, we usually bound the event to a call to a method in the component
    associated with the template. You can see an example of this in the form with
    the button that a user clicks on to remove an exercise:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`[(ngModel)]`指令建立了输入控件和`workout.name`模型属性之间的双向绑定。方括号和括号应该都很熟悉。以前，我们将它们分开使用：`[]`方括号用于属性绑定，`()`括号用于事件绑定。在后一种情况下，我们通常将事件绑定到与模板关联的组件中的一个方法的调用。您可以在表单中看到这种情况的一个例子，其中用户单击按钮以删除一个练习：
- en: '[PRE44]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here the click event is explicitly bound to a method called `removeExercise`
    in our `Workout` component class. But for the `workout.name` input, we do not
    have an explicit binding to a method on the component. So what's going on here
    and how does the update happen without us calling a method on the component? The
    answer to that question is that the combination `[( )]` is shorthand for both
    binding a model property to the input element and wiring up an event that updates
    the model.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，点击事件明确绑定到了`Workout`组件类中的一个名为`removeExercise`的方法。但是对于`workout.name`输入，我们没有将其明确绑定到组件上的一个方法。那么这里发生了什么，更新是如何进行的，而不需要我们在组件上调用一个方法呢？这个问题的答案是，组合`[(
    )]`是将模型属性绑定到输入元素并连接更新模型的事件的速记方式。
- en: Put differently, if we reference a model element in our form, `ngModel` is smart
    enough to know that what we want to do is update that element (`workout.name`
    here) when a user enters or changes the data in the input field to which it is
    bound. Under the hood, Angular creates an update method similar to what we would
    otherwise have to write ourselves. Nice! This approach keeps us from having to
    write repetitive code to update our model.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果我们在表单中引用一个模型元素，`ngModel`足够聪明，知道我们想要做的是在用户输入或更改与其绑定的输入字段中的数据时更新该元素（这里是`workout.name`）。在幕后，Angular创建了一个更新方法，类似于我们否则必须自己编写的方法。很好！这种方法使我们不必编写重复的代码来更新我们的模型。
- en: Angular supports most of the HTML5 input types, including text, number, select,
    radio, and checkbox. This means binding between a model and any of these input
    types just works out of the box.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: Angular支持大多数HTML5输入类型，包括文本、数字、选择、单选和复选框。这意味着模型与任何这些输入类型之间的绑定都可以直接使用。
- en: 'The `textarea` element works the same as the input:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`textarea`元素的工作方式与输入框相同：'
- en: '[PRE45]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here we bind `textarea` to `workout.description`. Under the hood, `ngModel`
    updates the workout description in our model with every change we type into the
    text area.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们将`textarea`绑定到`workout.description`。在幕后，`ngModel`会随着我们在文本框中输入的每一次更改而更新我们模型中的锻炼描述。
- en: 'To test out how this works, why don''t we verify this binding? Add a model
    interpolation expression against any of the linked inputs such as this one:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个工作原理，为什么我们不验证一下这个绑定呢？在任何一个链接输入中添加一个模型插值表达式，比如这样一个：
- en: '[PRE46]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Open the **Workout** page, type something in the input, and see how the interpolation
    is updated instantaneously. The magic of two-way binding!
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 打开**锻炼**页面，在输入框中输入一些内容，看看插值是如何立即更新的。双向绑定的魔力！
- en: '![Using ngModel with input and textarea](../Images/image00466.jpeg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![使用ngModel与输入框和文本框](../Images/image00466.jpeg)'
- en: Using ngModel with select
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`ngModel`与选择
- en: 'Let''s look at how select has been set up:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看选择是如何设置的：
- en: '[PRE47]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We are using `ngFor` here to bind to an array, `durations`, which is in the
    `Workout` component class. The array looks like this:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`ngFor`来绑定到一个数组`durations`，它在`Workout`组件类中。数组看起来是这样的：
- en: '[PRE48]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `ngFor` component will loop over the array and populate the dropdown values
    with the corresponding values in the array with the title for each item being
    displayed using interpolation -- `{{duration.title}}`. And `[(ngModel)]` then
    binds the drop-down selection to the `exercisePlan.duration` in the model. Notice
    here that we are binding to the nested model: `ExercisePlan`. This is powerful
    stuff that enables us to create complicated forms with nested models, all of which
    can use `ngModel` for databinding**.**
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngFor`组件将循环遍历数组，并使用插值将下拉框的值与数组中的相应值填充，每个项目的标题都使用插值显示--`{{duration.title}}`。然后`[(ngModel)]`将下拉框选择绑定到模型中的`exercisePlan.duration`。请注意，这里我们绑定到了嵌套模型：`ExercisePlan`。这是一个强大的功能，使我们能够创建具有嵌套模型的复杂表单，所有这些都可以使用`ngModel`进行数据绑定。'
- en: Like input, select too supports two-way binding. We saw how changing select
    updates a model, but the model-to-template binding may not be apparent. To verify
    that a model to a template binding works, open the *7 Minute Workout* app and
    verify the duration dropdowns. Each one has a value that is consistent with the
    model value (30 seconds).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 与输入框一样，选择也支持双向绑定。我们看到改变选择会更新模型，但是从模型到模板的绑定可能不太明显。为了验证模型到模板的绑定是否有效，请打开*7分钟锻炼*应用程序并验证持续时间下拉框。每个下拉框的值都与模型值（30秒）一致。
- en: Angular does an awesome job of keeping the model and view in sync using `ngModel`.
    Change the model and see the view updated; change the view and watch the model
    updated instantaneously.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: Angular通过使用`ngModel`来保持模型和视图同步做得非常棒。改变模型，看到视图更新；改变视图，观察模型立即更新。
- en: Now let's add validation to our form.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们给表单添加验证。
- en: Note
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code is also available for everyone to download on GitHub at [https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample).
    Checkpoints are implemented as branches in GitHub. The branch to download is as
    follows: **GitHub Branch: checkpoint4.6** (folder - `trainer`). Or if you are
    not using Git, download the snapshot of Checkpoint 4.6 (a ZIP file) from the following
    GitHub location: [https://github.com/chandermani/angular2byexample/archive/checkpoint4.5.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint4.5.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time. Again, if you are working along with us as we build the application,
    be sure and update the `app.css` file, which we are not discussing here.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码也可供所有人在GitHub上下载：[https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample)。检查点在GitHub上作为分支实现。要下载的分支如下：**GitHub分支：checkpoint4.6**（文件夹
    - `trainer`）。或者，如果您不使用Git，请从以下GitHub位置下载Checkpoint 4.6的快照（ZIP文件）：[https://github.com/chandermani/angular2byexample/archive/checkpoint4.5.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint4.5.zip)。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。再次强调，如果您正在与我们一起构建应用程序，请确保更新`app.css`文件，这里我们不讨论。
- en: Angular validation
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular验证
- en: As the saying goes, *Never trust user input*. Angular has support for validation,
    including the standard required, min, max, and pattern as well as custom validators.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 俗话说，“不要相信用户输入”。Angular支持验证，包括标准的required、min、max和pattern，以及自定义验证器。
- en: ngModel
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ngModel
- en: '`ngModel` is the building block that we will use to implement validation. It
    does two things for us: it maintains the model state and provides a mechanism
    for identifying validation errors and displaying validation messages.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngModel`是我们用来实现验证的基本组件。它为我们做了两件事：维护模型状态，并提供一种识别验证错误并显示验证消息的机制。'
- en: 'To get started, we need to assign `ngModel` to a local variable in all of our
    form controls that we will be validating. In each case, we need to use a unique
    name for this local variable. For example, for workout name we add `#name="ngModel"`
    within the `input` tag for that control. The workout name `input` tag should now
    look like this:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要在所有需要验证的表单控件中将`ngModel`赋值给一个本地变量。在每种情况下，我们需要为这个本地变量使用一个唯一的名称。例如，对于锻炼名称，我们在该控件的`input`标签中添加`#name="ngModel"`。现在，锻炼名称的`input`标签应该是这样的：
- en: '[PRE49]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Continue through the form, assigning `ngModel` to local variables for each of
    the inputs. Also add the required attribute for all the required fields.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 继续通过表单，为每个输入将`ngModel`分配给本地变量。还为所有必填字段添加`required`属性。
- en: The Angular model state
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Angular模型状态
- en: 'Whenever we use `NgForm`, every element within our form, including input, text
    area, and select, has some states defined on the associated model. `ngModel` tracks
    these states for us. The states tracked are:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们使用`NgForm`时，表单中的每个元素，包括输入、文本区域和选择，都有与关联模型定义的一些状态。`ngModel`为我们跟踪这些状态。跟踪的状态有：
- en: '`pristine`: The value of this is `true` as long as the user does not interact
    with the input. Any update to the `input` field and `ng-pristine` is set to `false`.'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`原始的`：只要用户不与输入交互，这个值就是`true`。对`input`字段进行任何更新，`ng-pristine`就会被设置为`false`。'
- en: '`dirty`: This is the reverse of `ng-pristine`. This is `true` when the input
    data has been updated.'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`脏的`：这是`ng-pristine`的相反。当输入数据已经更新时，这个值就是`true`。'
- en: '`touched`: This is `true` if the control ever had focus.'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`触摸的`：如果控件曾经获得焦点，这个值就是`true`。'
- en: '`untouched`: This is `true` if the control has never lost focus. This is just
    the reverse of `ng-touched`.'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`未触摸的`：如果控件从未失去焦点，这个值就是`true`。这只是`ng-touched`的相反。'
- en: '`valid`: This is `true` if there are validations defined on the `input` element
    and none of them are failing.'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`valid`：如果在`input`元素上定义了验证且它们都没有失败，则为`true`。'
- en: '`invalid`: This is `true` if any of the validations defined on the element
    are failing.'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invalid`：如果元素上定义的任何验证失败，则为`true`。'
- en: '`pristine`\`dirty` or `touched`\`untouched` are useful properties that can
    help us decide when error labels are shown.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '`pristine`\`dirty`或`touched`\`untouched`是有用的属性，可以帮助我们决定何时显示错误标签。'
- en: Angular CSS classes
  id: totrans-448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Angular CSS类
- en: 'Based on the model state, Angular adds some CSS classes to an input element.
    These include the following:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 根据模型状态，Angular会向输入元素添加一些CSS类。这些包括以下内容：
- en: '`ng-valid`: This is used if the model is valid'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-valid`：如果模型有效，则使用此项'
- en: '`ng-invalid`: This is used if the model is invalid'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-invalid`：如果模型无效，则使用此项'
- en: '`ng-pristine`: This is used if the model is pristine'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-pristine`：如果模型是原始的，则使用此项'
- en: '`ng-dirty`: This is used if the model is dirty'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-dirty`：如果模型是脏的，则使用此项'
- en: '`ng-untouched`: This is used when the input is never visited'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-untouched`：当输入从未被访问时使用此项'
- en: '`ng-touched`: This is used when the input has focus'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-touched`：当输入获得焦点时使用此项'
- en: 'To verify it, go back to the `workoutName` input tag and add a template reference
    variable named `spy` inside the `input` tag:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证它，返回到`workoutName`输入标签，并在`input`标签内部添加一个模板引用变量命名为`spy`：
- en: '[PRE50]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, below the tag, add the following label:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在标签下面，添加以下标签：
- en: '[PRE51]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Reload the application and click on the **New Workout** link in the *Workout
    Builder*. Before touching anything on the screen, you will see the following displayed:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载应用程序，然后单击*Workout Builder*中的**New Workout**链接。在屏幕上什么都不触摸之前，您将看到以下内容显示：
- en: '![Angular CSS classes](../Images/image00467.jpeg)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
  zh: '![Angular CSS classes](../Images/image00467.jpeg)'
- en: 'Add some content into the **Name** input box and tab away from it. The label
    changes to this:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Name**输入框中添加一些内容并切换到其他地方。标签会变成这样：
- en: '![Angular CSS classes](../Images/image00468.jpeg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![Angular CSS classes](../Images/image00468.jpeg)'
- en: What we are seeing here is Angular changing the CSS classes that apply to this
    control as the user interacts with it. You can also see these changes by inspecting
    the `input` element in the developer console.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们看到的是Angular随着用户与其交互而改变应用于该控件的CSS类。您还可以通过检查开发者控制台中的`input`元素来看到这些变化。
- en: 'These CSS class transitions are tremendously useful if we want to apply visual
    clues to the element depending on its state. For example, look at this snippet:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要根据其状态向元素应用视觉提示，这些CSS类转换非常有用。例如，看一下这个片段：
- en: '[PRE52]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This draws a red border around any input control that has invalid data.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在任何具有无效数据的输入控件周围绘制红色边框。
- en: As you add more validations to the Workout page, you can observe (in the developer
    console) how these classes are added and removed as the user interacts with the
    `input` element.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 当您向Workout页面添加更多验证时，您可以观察（在开发者控制台中）用户与`input`元素交互时这些类是如何添加和移除的。
- en: Now that we have an understanding of model states and how to use them, let's
    get back to our discussion of validations (before moving on, remove the variable
    name and label that you just added).
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了模型状态以及如何使用它们，让我们回到验证的讨论（在继续之前，删除您刚刚添加的变量名和标签）。
- en: Workout validation
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 训练验证
- en: The workout data needs to be validated for a number of conditions.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 需要对训练数据进行多种条件的验证。
- en: After taking the step of adding the local variable references for `ngModel`
    and the required attribute to our `input` fields, we have been able to see how
    `ngModel`tracks changes in the state of these controls and how it toggles the
    CSS styles.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在为我们的`input`字段添加`ngModel`的本地变量引用和必需属性之后，我们已经能够看到`ngModel`如何跟踪这些控件状态的变化以及如何切换CSS样式。
- en: Displaying appropriate validation messages
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示适当的验证消息
- en: Now the input needs to have a value; otherwise, the validation fails. But how
    can we know if the validation has failed? `ngModel` comes to our rescue here.
    It can provide the validation state of the particular input. And that gives us
    what we need to display an appropriate validation message.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输入需要有一个值；否则，验证失败。但是我们如何知道验证失败了呢？`ngModel`在这里帮了我们。它可以提供特定输入的验证状态。这给了我们显示适当验证消息所需的内容。
- en: 'Let''s go back to the input control for the Workout name. In order to get a
    validation message to display, we have to first modify the input tag to the following:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到锻炼名称的输入控件。为了显示验证消息，我们必须首先修改输入标签如下：
- en: '[PRE53]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We have added a local variable called `#name` and assigned `ngModel` to it.
    This is called a template reference variable and we can use it with the following
    label to display a validation message for the input:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了一个名为`#name`的本地变量，并将`ngModel`分配给它。这被称为模板引用变量，我们可以将其与以下标签一起使用，以显示输入的验证消息：
- en: '[PRE54]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We are showing the validation message in the event that the name is not provided
    **and** the control has not been touched. To check the first condition, we retrieve
    the `hasError` property of the control and see if the error type is `required`.
    We check to see if the name input has been `touched` because we do not want the
    message to display when the form first loads for a new workout.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在事件中显示验证消息，如果名称未提供**且**控件尚未被触摸。为了检查第一个条件，我们检索控件的`hasError`属性，并查看错误类型是否为`required`。我们检查名称输入是否已被`touched`，因为我们不希望在表单首次加载新锻炼时显示消息。
- en: Note
  id: totrans-480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will notice that we are using a somewhat more verbose style to identify
    validation errors than is required in this situation. Instead of `name.control.hasError('required')`,
    we could have used `!name. valid` and it would have worked perfectly fine. However,
    using the more verbose approach allows us to identify validation errors with greater
    specificity, which will be essential when we start adding multiple validators
    to our form controls. We'll look at using multiple validators a little later in
    this chapter. For consistency, we'll stick with the more verbose approach.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，我们在识别验证错误方面使用了一种更加冗长的风格，这比在这种情况下所需的要多。我们可以使用`name.control.hasError('required')`，但使用`!name.
    valid`也可以完美地工作。然而，使用更冗长的方法允许我们更具体地识别验证错误，这在我们开始向表单控件添加多个验证器时将是至关重要的。我们将在本章稍后看一下使用多个验证器。为了保持一致，我们将坚持使用更冗长的方法。
- en: 'Load the new Workout page (`/builder/workouts/new`) now. Enter a value in the
    name input box and then delete it. The error label appears as shown in the following
    screenshot:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 现在加载新的锻炼页面(`/builder/workouts/new`)。在名称输入框中输入一个值，然后删除它。错误标签将如下截图所示出现：
- en: '![Displaying appropriate validation messages](../Images/image00469.jpeg)'
  id: totrans-483
  prefs: []
  type: TYPE_IMG
  zh: '![显示适当的验证消息](../Images/image00469.jpeg)'
- en: Adding more validation
  id: totrans-484
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加更多验证
- en: 'Angular provides four out-of-the-box validators:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了四个开箱即用的验证器：
- en: '`required`'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`required`'
- en: '`minLength`'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minLength`'
- en: '`maxLength`'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxLength`'
- en: '`pattern`'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pattern`'
- en: 'We''ve seen how the `required` validator works. Now let''s look at two of the
    other out-of-the-box validators: `minLength` and `maxLength`. In addition to making
    it required, we want the title of the workout to be between 5 and 20 characters
    (we''ll look at the `pattern` validator a little later in this chapter).'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`required`验证器的工作原理。现在让我们看看另外两个开箱即用的验证器：`minLength`和`maxLength`。除了使其必填外，我们希望锻炼的标题在5到20个字符之间（我们将在本章稍后看一下`pattern`验证器）。
- en: 'So in addition to the `required` attribute we added previously to the title
    input box, we will add the `minLength` attribute and set it to `5`, and add the
    `maxLength` attribute and set it to `20`, like so:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除了我们之前添加到标题输入框的 `required` 属性之外，我们还将添加 `minLength` 属性并将其设置为 `5`，并添加 `maxLength`
    属性并将其设置为 `20`，如下所示：
- en: '[PRE55]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then we add another label with a message that will display when this validation
    is not met:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加另一个标签，当此验证未满足时将显示消息：
- en: '[PRE56]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Managing multiple validation messages
  id: totrans-495
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理多个验证消息
- en: 'You''ll see that the conditions for displaying the message now test for the
    length not being zero. This prevents the message from displaying in the event
    that the control is touched but left empty. In that case, the title required message
    should display. This message only displays if nothing is entered in the field
    and we accomplish this by checking explicitly to see if the control''s `hasError`
    type is `required`:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到显示消息的条件现在测试长度不为零。这可以防止在控件被触摸但保持空白时显示消息。在这种情况下，标题必填消息应该显示。只有在字段中没有输入任何内容时，此消息才会显示，我们通过明确检查控件的
    `hasError` 类型是否为 `required` 来实现这一点：
- en: '[PRE57]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Since we are attaching two validators to this input field, we can consolidate
    the check for the input being touched by wrapping both validators in a div tag
    that checks for that condition being met:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在为此输入字段附加两个验证器，我们可以通过将两个验证器包装在一个检查该条件是否满足的 div 标签中来合并检查输入是否被触摸：
- en: '[PRE58]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note
  id: totrans-500
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: What we just did shows how we can attach multiple validations to a single input
    control and also display the appropriate message in the event that one of the
    validation conditions is not met. However, it's pretty clear that this approach
    will not `scale` for more complicated scenarios. Some inputs contain a lot of
    validations and controlling when a validation message shows up can become complex.
    As the expressions for handling the various displays get more complicated, we
    may want to refactor and move them into a custom directive. Creating a custom
    directive will be covered in detail in [Chapter 6](part0066.xhtml#aid-1UU542 "Chapter 6. 
    Angular 2 Directives in Depth"), *Angular 2 Directives in Depth*.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚展示了如何将多个验证附加到单个输入控件，并在验证条件不满足时显示适当的消息。然而，很明显，这种方法在更复杂的场景下不会“扩展”。一些输入包含许多验证，并且控制验证消息何时显示可能变得复杂。随着处理各种显示的表达式变得更加复杂，我们可能希望重构并将它们移入自定义指令中。如何创建自定义指令将在[第6章](part0066.xhtml#aid-1UU542
    "Chapter 6.  Angular 2 Directives in Depth")中详细介绍，《深入解析 Angular 2 指令》。
- en: Custom validation messages for an exercise
  id: totrans-502
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自定义验证消息用于练习
- en: A workout without any exercise is of no use. There should at least be one exercise
    in the workout and we should validate this restriction.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何练习的锻炼是没有用的。锻炼中至少应该有一个练习，我们应该验证这一限制。
- en: The problem with exercise count validation is that it is not something that
    the user inputs directly and the framework validates. Nonetheless, we still want
    a mechanism to validate the exercise count in a manner similar to other validations
    on this form.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 运动次数验证的问题在于它不是用户直接输入并由框架验证的内容。尽管如此，我们仍希望以类似于表单上其他验证的方式验证运动次数。
- en: 'What we will do is add a hidden input box to the form that contains the count
    of the exercises. We will then bind this to `ngModel` and add a pattern validator
    that will check to make sure that there is more than one exercise. We will set
    the value of the input box to the count of the exercises:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在表单中添加一个包含练习计数的隐藏输入框。然后，我们将将其绑定到 `ngModel` 并添加一个模式验证器，以确保有多于一个练习。我们将设置输入框的值为练习的计数：
- en: '[PRE59]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Then we will attach a validation message to it similar to what we just did
    with our other validators:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将为其附加一个类似于我们刚刚使用其他验证器的验证消息：
- en: '[PRE60]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We are not using `ngModel` in its true sense here. There is no two-way binding
    involved. We are only interested in using it to do custom validation.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里并没有真正使用`ngModel`。这里没有涉及双向绑定。我们只对使用它进行自定义验证感兴趣。
- en: 'Open the new Workout page, add an exercise, and remove it; we should see the
    error:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 打开新的Workout页面，添加一个练习，然后将其删除；我们应该看到错误：
- en: '![Custom validation messages for an exercise](../Images/image00470.jpeg)'
  id: totrans-511
  prefs: []
  type: TYPE_IMG
  zh: '![练习的自定义验证消息](../Images/image00470.jpeg)'
- en: What we did here could have been easily done without involving any model validation
    infrastructure. But by hooking our validation into that infrastructure, we do
    derive some benefits. We can now determine errors with a specific model and errors
    with the overall form in a consistent and familiar manner. Most importantly, if
    our validation fails here, the entire form will be invalidated.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的事情本来可以很容易地在不涉及任何模型验证基础设施的情况下完成。但是通过将我们的验证与该基础设施连接起来，我们确实获得了一些好处。现在，我们可以以一种一致和熟悉的方式确定特定模型的错误以及整个表单的错误。最重要的是，如果我们的验证在这里失败，整个表单将无效。
- en: Note
  id: totrans-513
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Implementing custom validation the way we just did is not what you would want
    to do very often. Instead, it will usually make more sense to implement this kind
    of complicated logic inside a custom directive. We'll cover creating custom directives
    in detail in [Chapter 6](part0066.xhtml#aid-1UU542 "Chapter 6.  Angular 2 Directives
    in Depth"), *Angular 2 Directives in Depth*.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 实现自定义验证的方式通常不是您经常想要做的。相反，通常更合理的做法是在自定义指令中实现这种复杂逻辑。我们将在[第6章](part0066.xhtml#aid-1UU542
    "第6章 Angular 2指令深入解析")中详细介绍创建自定义指令，*Angular 2指令深入解析*。
- en: One nuisance with our newly implemented `Exercise Count` validation is that
    it shows when the screen for a new `Workout` first appears. With this message,
    we are not able to use `ng-touched` to hide the display. This is because the exercises
    are being added programmatically and the hidden input we are using to track their
    count never changes from untouched as exercises are added or removed.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新实现的`Exercise Count`验证的一个麻烦之处是，当新的`Workout`屏幕首次出现时会显示。对于这条消息，我们无法使用`ng-touched`来隐藏显示。这是因为练习是以编程方式添加的，并且我们使用来跟踪它们数量的隐藏输入在添加或删除练习时从未改变过未触摸状态。
- en: 'To fix this problem, we need an additional value to check when the state of
    the exercise list has been reduced to zero except when the form is first loaded.
    The only way that situation can happen is if the user adds and then removes exercises
    from a workout to the point that there are no more exercises. So we''ll add another
    property to our component that we can use to track whether the remove method has
    been called. We call that value `removeTouched` and set its initial value to `false`:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，当练习列表的状态被减少到零时，我们需要一个额外的值来检查，除非表单首次加载。这种情况发生的唯一方式是用户添加然后从锻炼中删除练习，直到没有更多的练习为止。因此，我们将在组件中添加另一个属性，用于跟踪删除方法是否已被调用。我们称这个值为`removeTouched`，并将其初始值设置为`false`：
- en: '[PRE61]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then in the remove method we will set that value to `true`:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在删除方法中，我们将该值设置为`true`：
- en: '[PRE62]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Next will add `removeTouched` to our validation message conditions, like so:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在验证消息条件中添加`removeTouched`，如下所示：
- en: '[PRE63]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now, when we open a new workout screen, the validation message will not display.
    But if the user adds and then removes all the exercises, then it will display.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们打开一个新的锻炼屏幕时，验证消息将不会显示。但是如果用户添加然后删除所有练习，那么它将显示。
- en: To understand how model validation rolls up into form validation, we need to
    understand what form-level validation has to offer. However, even before that,
    we need to implement saving the workout and calling it from the workout form.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解模型验证如何转化为表单验证，我们需要了解表单级验证提供了什么。然而，甚至在此之前，我们需要实现保存锻炼并从锻炼表单中调用它。
- en: Saving the workout
  id: totrans-524
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存锻炼
- en: The workout that we are building needs to be persisted (in-memory only). The
    first thing that we need to do is extend `WorkoutService` and `WorkoutBuilderService`.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建的锻炼需要被持久化（仅在内存中）。我们需要做的第一件事是扩展“WorkoutService”和“WorkoutBuilderService”。
- en: '`WorkoutService` needs two new methods: `addWorkout` and `updateWorkout`:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: “WorkoutService”需要两个新方法：“addWorkout”和“updateWorkout”：
- en: '[PRE64]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `addWorkout` method does a basic check on the workout name and then pushes
    the workout into the workout array. Since there is no backing store involved,
    if we refresh the page, the data is lost. We will fix this in the next chapter
    where we persist the data to a server.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: “addWorkout”方法对锻炼名称进行基本检查，然后将锻炼推入锻炼数组中。由于没有涉及后备存储，如果我们刷新页面，数据就会丢失。我们将在下一章中修复这个问题，将数据持久化到服务器。
- en: The `updateWorkout` method looks for a workout with the same name in the existing
    workouts array and if found, updates and replaces it.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: “updateWorkout”方法在现有的锻炼数组中查找具有相同名称的锻炼，如果找到，则更新并替换它。
- en: 'We only add one save method to `WorkoutBuilderService` as we are already tracking
    the context in which workout construction is going on:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只向“WorkoutBuilderService”添加一个保存方法，因为我们已经在跟踪进行锻炼构建的上下文：
- en: '[PRE65]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `save` method calls either `addWorkout`, or `updateWorkout` in the `Workout`
    service based on whether a new workout is being created or an existing one is
    being edited.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: “save”方法根据是创建新锻炼还是编辑现有锻炼，调用“Workout”服务中的“addWorkout”或“updateWorkout”方法。
- en: From a service perspective, that should be enough. Time to integrate the ability
    to save workouts into the `Workout` component and learn more about the form directive!
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务的角度来看，这应该足够了。是时候将保存锻炼的能力集成到“Workout”组件中，并了解更多关于表单指令的知识！
- en: 'Before we look at - `NgForm` in more detail, let''s add the save method to
    `Workout` to save the workout when the `Save` button is clicked on. Add this code
    to the `Workout` component:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 在更详细地查看“NgForm”之前，让我们向“Workout”添加保存方法，以便在单击“保存”按钮时保存锻炼。将以下代码添加到“Workout”组件中：
- en: '[PRE66]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We check the validation state of the form using its invalid property and then
    call the `WorkoutBuilderService.save` method if the form state is valid.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用其无效属性来检查表单的验证状态，然后如果表单状态有效，调用“WorkoutBuilderService.save”方法。
- en: More on NgForm
  id: totrans-537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于NgForm的更多信息
- en: Forms in Angular have a different role to play as compared to traditional forms
    that post data to the server. If we go back and look again at the form tag, we
    will see that it is missing the standard action attribute. The `novalidate` attribute
    on the form directive tells the browser not to do inbuilt input validations (this
    is not Angular-specific but is an HTML 5 attribute).
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，表单的角色与将数据提交到服务器的传统表单有所不同。如果我们回过头再看一下表单标签，我们会发现它缺少标准的action属性。表单指令上的“novalidate”属性告诉浏览器不要进行内置输入验证（这不是特定于Angular的，而是HTML
    5属性）。
- en: The standard form behavior of posting data to the server using full-page post-back
    does not make sense with an SPA framework such as Angular. In Angular, all server
    requests are made through asynchronous invocations originating from directives
    or services.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 使用全页回传的标准表单行为在Angular这样的SPA框架中是没有意义的。在Angular中，所有服务器请求都是通过指令或服务发起的异步调用。
- en: 'The form here plays a different role. When the form encapsulates a set of input
    elements (such as input, textarea, and select) it provides an API for:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的表单扮演了不同的角色。当表单封装一组输入元素（例如输入、文本区域和选择）时，它提供了一个API：
- en: Determining the state of the form, such as whether the form is dirty or pristine
    based on the input controls on it
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定表单的状态，例如基于其输入控件的脏或原始状态
- en: Checking validation errors at the form or control level
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表单或控件级别检查验证错误
- en: Note
  id: totrans-543
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you still want the standard form behavior, you can add an `ngNoForm` attribute,
    but this will definitely cause a full-page refresh. We'll explore the specifics
    of the `NgForm` API a little later in this chapter when we look at saving the
    form and implementing validation.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仍希望使用标准表单行为，可以添加一个`ngNoForm`属性，但这肯定会导致整个页面刷新。当我们查看保存表单和实现验证时，我们将在本章稍后探讨`NgForm`
    API的具体内容。
- en: The state of the `FormControl` objects within the form is being monitored by
    `NgForm`. If any of them are invalid, then `NgForm` sets the entire form to invalid.
    In this case, we have been able to use `NgForm` to determine that one or more
    of the `FormControl` objects is invalid and therefore the state of the form as
    a whole is invalid too.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 表单内的`FormControl`对象的状态由`NgForm`监视。如果其中任何一个无效，那么`NgForm`会将整个表单设置为无效。在这种情况下，我们已经能够使用`NgForm`确定一个或多个`FormControl`对象无效，因此整个表单的状态也是无效的。
- en: Let's look at one more issue before we finish this chapter.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成本章之前，让我们再看一个问题。
- en: Fixing the saving of forms and validation messages
  id: totrans-547
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复表单保存和验证消息
- en: 'Open a new Workout page and directly click on the **Save** button. Nothing
    is saved as the form is invalid, but validations on individual form input do not
    show up at all. It now becomes difficult to know what elements have caused validation
    failure. The reason behind this behavior is pretty obvious. If we look at the
    error message binding for the name input element, it looks like this:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的锻炼页面，直接单击**保存**按钮。由于表单无效，所以什么都没有保存，但是单个表单输入的验证根本不显示出来。现在很难知道是哪些元素导致了验证失败。这种行为背后的原因非常明显。如果我们看一下名称输入元素的错误消息绑定，它看起来是这样的：
- en: '[PRE67]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Remember that earlier in the chapter, we explicitly disabled showing validation
    messages until the user has touched the input control. The same issue has come
    back to bite us and we need to fix it now.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在本章的早些时候，我们明确禁用了在用户触摸输入控件之前显示验证消息。同样的问题又回来找我们了，现在我们需要解决它。
- en: 'We do not have a way to explicitly change the touched state of our controls
    to untouched. Instead, we will resort to a little trickery to get the job done.
    We''ll introduce a new property called `submitted`. Add it at the top of `Workout`
    class definition and set its initial value to `false`, like so:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有办法明确地将控件的触摸状态更改为未触摸。相反，我们将采取一些小技巧来完成这项工作。我们将在`Workout`类定义的顶部引入一个名为`submitted`的新属性，并将其初始值设置为`false`，如下所示：
- en: '[PRE68]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The variable will be set to true on the `Save` button click. Update the save
    implementation by adding the highlighted code:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 变量将在单击“保存”按钮时设置为true。通过添加突出显示的代码来更新保存实现：
- en: '[PRE69]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Nonetheless, how does this help? Well, there is another part to this fix that
    requires us to change the error message for each of the controls we are validating.
    The expression now changes to:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这有什么帮助呢？好吧，这个修复的另一部分需要我们更改每个正在验证的控件的错误消息。表达式现在变成了：
- en: '[PRE70]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: With this fix, the error message is shown when the control is touched or the
    form submit button is pressed (`submitted` is `true`). This expression fix now
    has to be applied to every validation message where a check appears.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个修复，当控件被触摸或表单提交按钮被按下（`submitted`为`true`）时，错误消息将被显示。现在，这个表达式修复现在必须应用于每个验证消息，其中出现了检查。
- en: 'If we now open the new **Workout** page and click on the **Save** button, we
    should see all validation messages on the input controls:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在打开新的**Workout**页面并点击**保存**按钮，我们应该能够在输入控件上看到所有的验证消息：
- en: '![Fixing the saving of forms and validation messages](../Images/image00471.jpeg)'
  id: totrans-559
  prefs: []
  type: TYPE_IMG
  zh: '![修复表单保存和验证消息](../Images/image00471.jpeg)'
- en: Model-driven forms
  id: totrans-560
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型驱动表单
- en: The other type of form that Angular supports is called **model-driven** forms.
    As the name implies **model-driven forms** start with a model that is constructed
    in a component class. With this approach, we use the **form builder API** to create
    a form in code and associate it with a model.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: Angular支持的另一种表单类型称为**模型驱动**表单。顾名思义，**模型驱动表单**从在组件类中构建的模型开始。通过这种方法，我们使用**表单构建器API**在代码中创建一个表单并将其与模型关联起来。
- en: Given the minimal code we have to write to get template-driven forms working,
    why and when should we consider using model-driven forms? There are several situations
    in which we might want to use them. These include cases where we want to take
    programmatic control of creating the form. This is especially beneficial, as we
    will see, when we are trying to create form controls dynamically based on data
    we are retrieving from the server.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们必须编写的最少代码来使模板驱动表单工作，为什么以及何时应该考虑使用模型驱动表单？有几种情况下我们可能想要使用它们。这些情况包括我们想要以编程方式控制创建表单的情况。正如我们将看到的那样，这是特别有益的，当我们试图根据从服务器检索的数据动态创建表单控件时。
- en: If our validation gets complicated, it is often easier to handle it in code.
    Using model-driven forms we can keep this complicated logic out of the HTML template,
    making the template syntax simpler.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的验证变得复杂，通常更容易在代码中处理。使用模型驱动表单，我们可以将这种复杂的逻辑从HTML模板中剥离出来，使模板语法更简单。
- en: Another significant advantage of model-driven forms, is that they make unit-testing
    the form possible, which is not the case with **template-driven forms.** We can
    simply instantiate our form controls in our tests and then test them outside the
    markup on our page.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 模型驱动表单的另一个重要优势是，它使得对表单进行单元测试成为可能，而这在**模板驱动表单**中是不可能的。我们可以简单地在测试中实例化我们的表单控件，然后在页面上的标记之外对它们进行测试。
- en: '**Model-driven forms** use three new form directives that we haven''t discussed
    before: `FormGroup`, `FormControl`, and `FormArray`. These directives allow the
    form object that is constructed in code to be tied directly to the HTML markup
    in the template. The form controls that are created in the component class are
    then directly available in the form itself. Technically speaking, this means that
    we don''t need to use `ngModel` (which is integral to template-driven forms) with
    model-driven forms (although it can be used). The overall approach is a cleaner
    and less cluttered template with more focus on the code that drives the form.
    Let''s get started with building a model-driven form.'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 模型驱动表单使用了三个我们之前没有讨论过的新表单指令：`FormGroup`、`FormControl`和`FormArray`。这些指令允许在代码中构建的表单对象直接与模板中的HTML标记绑定。在组件类中创建的表单控件可以直接在表单中使用。从技术上讲，这意味着我们不需要在模型驱动表单中使用`ngModel`（这是模板驱动表单的一部分），尽管它可以使用。总体上，这种方法可以使模板更清洁、更简洁，更专注于驱动表单的代码。让我们开始构建一个模型驱动表单。
- en: Getting started with model-driven forms
  id: totrans-566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始使用模型驱动表单。
- en: 'We''ll make use of model-driven forms to build the form to add and edit **Exercises**.
    Among other things this form will allow the user to add links to exercise videos
    on YouTube. And since they can add any number of video links, we will need to
    be able to add controls for these video links dynamically. This challenge will
    present a good test of how effective model-driven forms can be in developing more
    complex forms. Here is how the form will look:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用模型驱动表单来构建添加和编辑**练习**的表单。除其他外，该表单将允许用户添加YouTube上的练习视频链接。由于他们可以添加任意数量的视频链接，我们需要能够动态添加这些视频链接的控件。这个挑战将是模型驱动表单在开发更复杂表单时的有效性的一个很好的测试。这就是表单的样子：
- en: '![Getting started with model-driven forms](../Images/image00472.jpeg)'
  id: totrans-568
  prefs: []
  type: TYPE_IMG
  zh: '![使用模型驱动表单入门](../Images/image00472.jpeg)'
- en: 'To get started, open `workout-builder.module.ts` and add the following `import`:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请打开`workout-builder.module.ts`并添加以下`import`：
- en: '[PRE71]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`ReactiveFormsModule` contains what we will need to build model-driven forms.'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReactiveFormsModule`包含了我们构建模型驱动表单所需的内容。'
- en: 'Next copy `exercise-builder-service.ts` from the `workout-builder/builder-services`
    folder under `trainer/src/components` in `checkpoint 4.6` and import it into `workout-builder.module.ts`:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从`checkpoint 4.6`的`trainer/src/components`文件夹下的`workout-builder/builder-services`文件夹中复制`exercise-builder-service.ts`并将其导入到`workout-builder.module.ts`中：
- en: '[PRE72]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Then add it as an additional provider to the providers array in that same file:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将其作为提供者添加到同一文件中的提供者数组中：
- en: '[PRE73]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note
  id: totrans-576
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will notice here that we also have added `ExerciseGuard` as a provider.
    We won't be covering that here, but you should copy it from the `exercise` folder
    as well and also copy the updated `workout-builder.routes.ts`, which adds it as
    a route guard for the navigation to `ExerciseComponent`.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们还将`ExerciseGuard`添加为提供者。我们不会在这里涵盖它，但您也应该从`exercise`文件夹中复制它，并复制更新后的`workout-builder.routes.ts`，将其添加为导航到`ExerciseComponent`的路由守卫。
- en: 'Now open `exercise.component.ts` and add the following import statement at
    the top of the file:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开`exercise.component.ts`并在文件顶部添加以下导入语句：
- en: '[PRE74]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This brings in the following, which we will use to construct our form:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 这将引入以下内容，我们将使用它来构建我们的表单：
- en: '`FormBuilder`'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormBuilder`'
- en: '`FormGroup`'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormGroup`'
- en: '`FormControl`'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormControl`'
- en: '`FormArray`'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormArray`'
- en: 'Finally, we inject `FormBuilder` (as well as `Router`, `ActivatedRoute`, and
    `ExerciseBuilderService`) into the constructor of our class:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`FormBuilder`（以及`Router`，`ActivatedRoute`和`ExerciseBuilderService`）注入到我们类的构造函数中：
- en: '[PRE75]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: With these preliminary steps out of the way, we can now go ahead and start building
    out our form.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些初步步骤后，我们现在可以开始构建我们的表单了。
- en: Using the FormBuilder API
  id: totrans-588
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用FormBuilder API
- en: 'The `FormBuilder` API is the foundation for model-driven forms. You can think
    of it as a factory for turning out the forms we are constructing in our code.
    Go ahead and add the `ngOnInit` lifecycle hook to your class, as follows:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormBuilder` API是模型驱动表单的基础。您可以将其视为一个工厂，用于生产我们在代码中构建的表单。继续并将`ngOnInit`生命周期钩子添加到您的类中，如下所示：'
- en: '[PRE76]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: When `ngOnInit` fires it will call a method for building our form (in addition
    to setting up the exercise we are building). So, at this stage of the component
    lifecycle, we are starting the process of constructing our form in code.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ngOnInit`触发时，它将调用一个用于构建我们的表单的方法（除了设置我们正在构建的练习）。因此，在组件生命周期的这个阶段，我们正在开始在代码中构建我们的表单的过程。
- en: 'Now let''s implement the `buildExerciseForm` method by adding the following
    code:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过添加以下代码来实现`buildExerciseForm`方法：
- en: '[PRE77]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Let''s examine this code. To start with, we are using the injected instance
    of `FormBuilder` to construct the form and assign it to a local variable `exerciseForm`.
    Using `formBuilder.group`, we add several form controls to our form. We add each
    of them by a simple key/value mapping:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这段代码。首先，我们使用注入的“FormBuilder”实例来构建表单，并将其分配给一个本地变量“exerciseForm”。使用“formBuilder.group”，我们向我们的表单添加了几个表单控件。我们通过简单的键/值映射添加了每一个：
- en: '[PRE78]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The left side of the mapping is the name of the `FormControl`, and the right
    is an array containing as its first element the value of the control (in our case,
    the corresponding element on our exercise model) and the second a validator (in
    this case, the out-of-the-box required validator). Nice and neat! It's definitely
    easier to see and reason about our form controls with setting them up outside
    the template.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 映射的左侧是“FormControl”的名称，右侧是一个数组，其第一个元素是控件的值（在我们的情况下，是我们练习模型上对应的元素），第二个是验证器（在这种情况下是现成的必填验证器）。清晰明了！在模板外设置它们确实更容易看到和理解我们的表单控件。
- en: 'We can not only build up `FormControls` in our form this way, but also add
    `FormControlGroups` and `FormControlArray` that contain `FormControls` within
    them. This means we can create complex forms that contain nested input controls.
    In our case, as we have mentioned, we are going to need to accommodate the possibility
    of our users adding multiple videos to an exercise. We can do this by adding the
    following code:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以以这种方式在我们的表单中构建“FormControls”，还可以添加包含其中的“FormControls”的“FormControlGroups”和“FormControlArray”。这意味着我们可以创建包含嵌套输入控件的复杂表单。在我们的情况下，正如我们已经提到的，我们需要考虑用户向练习添加多个视频的可能性。我们可以通过添加以下代码来实现这一点：
- en: '[PRE79]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'What we are doing here is assigning a `FormArray` to videos, which means we
    can assign multiple controls in this mapping. To construct this new `FormArray`,
    we add the following `addVideoArray` method to our class:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是将一个“FormArray”分配给视频，这意味着我们可以在这个映射中分配多个控件。为了构建这个新的“FormArray”，我们在我们的类中添加了以下“addVideoArray”方法：
- en: '[PRE80]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This method constructs a `FormControl` for each video; each is then added each
    to a `FormArray` that is assigned to the videos control in our form.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法为每个视频构造一个“FormControl”；然后将每个视频添加到我们表单中的视频控件中的“FormArray”中。
- en: Adding the form model to our HTML view
  id: totrans-602
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将表单模型添加到我们的HTML视图
- en: 'So far, we have been working behind the scenes in our class to construct our
    form. The next step is to wire up our form to the view. To do this, we use the
    same controls that we used to build the form in our code: `formGroup`, `formControl`,
    and `formArray`.'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在我们的类中幕后工作来构建我们的表单。下一步是将我们的表单与视图连接起来。为此，我们使用了与我们在代码中构建表单时使用的相同控件：“formGroup”、“formControl”和“formArray”。
- en: 'Open `exercise.component.html` and add a `form` tag as follows:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 打开“exercise.component.html”并添加以下“form”标签：
- en: '[PRE81]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Within the tag we are first assigning the `exerciseForm` that we just built
    in code to `formGroup`. This establishes the connection between our coded model
    and the form in the view. We also wire up the `ngSubmit` event to an `onSubmit`
    method in our code (we'll discuss this method a little later). Finally we turn
    off the browser's form validation using `novalidate`.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 在标签中，我们首先将我们刚刚在代码中构建的“exerciseForm”分配给“formGroup”。这建立了我们编码模型与视图中表单之间的连接。我们还将“ngSubmit”事件与我们代码中的“onSubmit”方法连接起来（稍后我们将讨论这个方法）。最后，我们使用“novalidate”关闭浏览器的表单验证。
- en: Adding form controls to our form inputs
  id: totrans-607
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向我们的表单输入添加表单控件
- en: 'Next we start constructing the inputs for our form. We''ll start with the input
    for the name of our exercise:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始构建表单的输入。我们将从我们的练习名称输入开始：
- en: '[PRE82]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: We assign the name of our coded form control to `formControlName`. This establishes
    the link between the control in our code and the `input` field in the markup.
    Another item of interest here is that we do not use the `required` attribute.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们编码的表单控件的名称分配给`formControlName`。这在我们的代码中的控件与标记中的`input`字段之间建立了链接。这里的另一个有趣的地方是我们不使用`required`属性。
- en: Adding validation
  id: totrans-611
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加验证
- en: 'The next thing that we do is add a validation message to the control that will
    display in the event of a validation error:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要做的事情是向控件添加一个验证消息，以在验证错误发生时显示：
- en: '[PRE83]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Notice that this markup is very similar to what we used in template-driven forms
    for validation, except that the syntax for identifying the control is somewhat
    more verbose Again, it checks the state of the `hasError` property of the control
    to make sure it is valid.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个标记与我们在模板驱动表单中用于验证的标记非常相似，只是用于识别控件的语法有点更冗长。同样，它检查控件的`hasError`属性的状态，以确保它是有效的。
- en: 'But wait a minute! How can we validate this input? Haven''t we have removed
    the required attribute from our tag? This is where the control mappings that we
    added in our code come into play. If you look back at the code for the form model,
    you can see the following mapping for the `name` control:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 但等一下！我们如何验证这个输入？我们不是已经从标签中删除了`required`属性吗？这就是我们在代码中添加的控件映射发挥作用的地方。如果你回顾一下表单模型的代码，你会看到以下映射适用于`name`控件：
- en: '[PRE84]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The second element in the mapping array assigns the required validator to the
    name form control. This means that we don't have to add anything to our template;
    instead, the form control itself is attached to the template with a required validator.
    The ability to add a validator in our code enables us to conveniently add validators
    outside our template. This is especially useful when it comes to writing custom
    validators with complex logic behind them.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 映射数组中的第二个元素将必填验证器分配给名称表单控件。这意味着我们不必在模板中添加任何内容；相反，表单控件本身附加到了具有必填验证器的模板。在我们的代码中添加验证器的能力使我们能够方便地在模板之外添加验证器。当涉及编写具有复杂逻辑的自定义验证器时，这是特别有用的。
- en: Adding dynamic form controls
  id: totrans-618
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加动态表单控件
- en: 'As we mentioned earlier, the **Exercise** form that we are building requires
    that we allow the user to add one or more videos to the exercise. Since we don''t
    know how many videos the user may want to add, we will have to build the `input`
    fields for these videos dynamically as the user clicks on the **Add Video** button.
    Here''s how it will look:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们正在构建的**练习**表单要求我们允许用户向练习中添加一个或多个视频。由于我们不知道用户可能想要添加多少个视频，我们将不得不在用户点击**添加视频**按钮时动态构建这些视频的`input`字段。它将是这样的：
- en: '![Adding dynamic form controls](../Images/image00473.jpeg)'
  id: totrans-620
  prefs: []
  type: TYPE_IMG
  zh: '![添加动态表单控件](../Images/image00473.jpeg)'
- en: We have already seen the code in our component class that we use to do this.
    Now let's take a look at how it is implemented in our template.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在组件类中看到了用于执行此操作的代码。现在让我们看看它是如何在我们的模板中实现的。
- en: 'We first use `ngFor` to loop through our list of videos. Then we assign the
    index in our videos to a local variable, `i`. No surprises so far:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`ngFor`循环遍历我们的视频列表。然后我们将视频的索引分配给一个本地变量`i`。到目前为止没有什么意外的：
- en: '[PRE85]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Inside the loop we do three things. First, we add a button to allow the user
    to delete a video:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，我们做三件事。首先，我们添加一个按钮，允许用户删除视频：
- en: '[PRE86]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We bind a `deleteVideo` method in our component class to the button's `click`
    event and pass to it the index of the video being deleted.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将组件类中的`deleteVideo`方法绑定到按钮的`click`事件，并将视频的索引传递给它。
- en: 'Next, we dynamically add a video `input` field for each of the videos currently
    in our exercise:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为每个当前练习中的视频动态添加一个视频`input`字段：
- en: '[PRE87]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: We then add a validation message for each of the video `input` fields.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 然后为每个视频`input`字段添加验证消息。
- en: '[PRE88]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The validation message follows the same pattern for displaying the message that
    we have used elsewhere in this chapter. We drill into the `exerciseFormControls`
    group to find the particular control by its index. Again, the syntax is verbose
    but easy enough to understand.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 验证消息遵循本章其他地方使用的显示消息的相同模式。我们深入到`exerciseFormControls`组中，通过其索引找到特定的控件。再次，语法冗长但足够容易理解。
- en: Saving the form
  id: totrans-632
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存表单
- en: 'The final step in building out our model-driven form is to handle saving the
    form. When we constructed the form tag earlier, we bound the `ngSubmit` event
    to the following `onSubmit` method in our code:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 构建模型驱动表单的最后一步是处理保存表单。当我们之前构建表单标签时，我们将`ngSubmit`事件绑定到我们代码中的以下`onSubmit`方法：
- en: '[PRE89]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'This method sets `submitted` to `true`, which will trigger the display of any
    validation messages that might have been previously hidden because the form had
    not been touched. It also returns without saving in the event that there are any
    validation errors on the form. If there are none, then it calls the following
    `mapFormValues` method, which assigns the values from our form to the `exercise`
    that will be saved:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法将`submitted`设置为`true`，这将触发显示任何可能之前因为表单未被触摸而被隐藏的验证消息。如果表单上有任何验证错误，它也会返回而不保存。如果没有错误，它将调用以下`mapFormValues`方法，该方法将表单中的值分配给将要保存的`exercise`：
- en: '[PRE90]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: It then calls the save method in `ExerciseBuilderService` and routes the user
    back to the exercise list screen (remember that any new exercise will not display
    in that list because we have not yet implemented data persistence in our application).
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用`ExerciseBuilderService`中的保存方法，并将用户路由回练习列表屏幕（请记住，任何新练习都不会显示在该列表中，因为我们尚未在应用程序中实现数据持久性）。
- en: We hope this makes it clear; model-driven forms offer many advantages when we
    are trying to build more complicated forms. They allow programming logic to be
    removed from the template. They permit validators to be added to the form programmatically.
    And they support building forms dynamically at runtime.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这一点很清楚；当我们试图构建更复杂的表单时，模型驱动的表单提供了许多优势。它们允许将编程逻辑从模板中移除。它们允许以编程方式向表单添加验证器。它们支持在运行时动态构建表单。
- en: Custom validators
  id: totrans-639
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义验证器
- en: Now we'll take a look at one more thing before we conclude this chapter. As
    anyone who has worked on building web forms (either in Angular or any other web
    technology) knows, we are often called on to create validations that are unique
    to the application we are building. Angular provides us with the flexibility to
    enhance our model-driven form validation by building custom validators.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在我们结束本章之前，让我们再看一件事。任何在构建Web表单（无论是在Angular还是其他Web技术中）上工作过的人都知道，我们经常被要求创建特定于我们正在构建的应用程序的验证。Angular为我们提供了灵活性，通过构建自定义验证器来增强我们的模型驱动表单验证。
- en: In building our exercise form, we need to be sure about what is entered, as
    a name contains only alphanumeric characters and no spaces. This is because when
    we get to storing the exercises in a remote data store, we are going to use the
    name of the exercise as its key. So, in addition to the standard required field
    validator, let's build another validator that checks to make sure that the name
    entered is in alphanumeric form only.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们的练习表单时，我们需要确保输入的内容，因为名称只包含字母数字字符，不包含空格。这是因为当我们开始将练习存储在远程数据存储中时，我们将使用练习的名称作为其键。因此，除了标准的必填字段验证器之外，让我们构建另一个验证器，以确保输入的名称只是字母数字形式。
- en: 'Creating a custom control is quite straightforward. In its simplest form, an
    Angular custom validator is a function that takes a control as an input parameter,
    runs the validation check, and returns true or false. So let''s start by adding
    a TypeScript file with the name `alphanumeric-validator.ts`. In that file, first
    import `FormControl` from `@angular/forms`; then add the following class to that
    file:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义控件非常简单。在其最简单的形式中，Angular自定义验证器是一个函数，它以控件作为输入参数，运行验证检查，并返回true或false。所以让我们首先添加一个名为`alphanumeric-validator.ts`的TypeScript文件。在该文件中，首先从`@angular/forms`中导入`FormControl`；然后将以下类添加到该文件中：
- en: '[PRE91]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The code follows the pattern for creating a validator that we just mentioned.
    The only thing that may be a little surprising is that it returns true when the
    validation fails! As long as you are clear on this one quirk, you should have
    no problem writing your own custom validator.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 代码遵循了我们刚提到的创建验证器的模式。唯一可能有点令人惊讶的是，当验证失败时它返回true！只要你清楚了这个怪癖，你应该没有问题编写自己的自定义验证器。
- en: Integrating a custom validator into our forms
  id: totrans-645
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将自定义验证器整合到我们的表单中
- en: 'So how do we plug our custom validator into our form? If we are using model-driven
    forms, the answer is pretty simple. We add it just like a built-in validator when
    we build our form in code. Let''s do that. Open `exercise.component.ts` and first
    add an import for our custom validator:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何将我们的自定义验证器插入到我们的表单中呢？如果我们使用模型驱动表单，答案非常简单。当我们在代码中构建我们的表单时，我们就像添加内置验证器一样添加它。让我们这样做。打开`exercise.component.ts`并首先为我们的自定义验证器添加一个导入：
- en: '[PRE92]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Then, modify the form builder code to add the validator to the `name` control:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，修改表单构建器代码，将验证器添加到`name`控件中：
- en: '[PRE93]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Since the name control already has a required validator, we add `AlphaNumericValidator`
    as a second validator using an array that contains both validators. The array
    can be used to add any number of validators to a control.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 由于名称控件已经有一个必填验证器，我们使用一个包含两个验证器的数组将`AlphaNumericValidator`作为第二个验证器添加进去。该数组可用于向控件添加任意数量的验证器。
- en: 'The final step is to incorporate the appropriate validation message for the
    control into our template. Open `workout.component.html` and add the following
    label just below the label that displays the message for the required validator:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将控件的适当验证消息整合到我们的模板中。打开`workout.component.html`并在显示必填验证器消息的标签下方添加以下标签：
- en: '[PRE94]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The exercise screen will now display a validation message if a non-alphanumeric
    value is entered in the name input box:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 运动屏幕现在将显示一个验证消息，如果在名称输入框中输入了非字母数字值：
- en: '![Integrating a custom validator into our forms](../Images/image00474.jpeg)'
  id: totrans-654
  prefs: []
  type: TYPE_IMG
  zh: '![将自定义验证器整合到我们的表单中](../Images/image00474.jpeg)'
- en: As we hope you can see, model-driven forms give us the ability to add custom
    validators to our forms in a straightforward manner that allows us to maintain
    the validation logic in our code and easily integrate it into our templates.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们希望您所看到的，模型驱动表单使我们能够以一种简单的方式向我们的表单添加自定义验证器，这样我们就可以在我们的代码中保持验证逻辑，并轻松地将其集成到我们的模板中。
- en: Note
  id: totrans-656
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may have noticed that in this chapter, we have not covered how to use custom
    validators in template-driven forms. That is because implementing them requires
    the additional step of building a custom directive. We'll cover that in [Chapter
    6](part0066.xhtml#aid-1UU542 "Chapter 6.  Angular 2 Directives in Depth"), *Angular
    2 Directives in Depth*.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在本章中，我们还没有涵盖如何在模板驱动表单中使用自定义验证器。这是因为实现它们需要额外的步骤来构建自定义指令。我们将在[第6章](part0066.xhtml#aid-1UU542
    "第6章。深入了解Angular 2指令")中进行介绍，*深入了解Angular 2指令*。
- en: Summary
  id: totrans-658
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We now have a *Personal Trainer* app. The process of converting a specific *7
    Minute Workout* app to a generic *Personal Trainer* app helped us learn a number
    of new concepts.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个*个人教练*应用程序。将特定的*7分钟训练*应用程序转换为通用的*个人教练*应用程序的过程帮助我们学习了许多新概念。
- en: We started the chapter by defining the new app requirements. Then, we designed
    the model as a shared service.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过定义新的应用程序要求开始了本章。然后，我们将模型设计为一个共享服务。
- en: We defined some new views and corresponding routes for the *Personal Trainer*
    app. We also used both child and asynchronous routing to separate out *Workout
    Builder* from the rest of the app.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为*个人教练*应用程序定义了一些新视图和相应的路由。我们还使用了子路由和异步路由，将*训练构建器*与应用程序的其余部分分开。
- en: We then turned our focus to workout building. One of the primary technological
    focuses in this chapter was on Angular forms. The *Workout Builder* employed a
    number of form input elements and we implemented a number of common form scenarios
    using both template-driven and model-driven forms. We also explored Angular validation
    in depth, and implemented a custom validator.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将重点转向训练构建。本章的主要技术重点之一是Angular表单。*训练构建器*使用了许多表单输入元素，我们使用了模板驱动和模型驱动的形式实现了许多常见的表单场景。我们还深入探讨了Angular验证，并实现了自定义验证器。
- en: The next chapter is all about client-server interaction. The workouts and exercises
    that we create need to be persisted. In the next chapter, we build a persistence
    layer, which will allow us to save workout and exercise data on the server.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节将全面讨论客户端-服务器交互。我们创建的训练和练习需要被持久化。在下一章中，我们将构建一个持久化层，这将允许我们在服务器上保存训练和练习数据。
- en: Before we conclude this chapter, here is a friendly reminder. If you have not
    completed the exercise building routine for *Personal Trainer*, go ahead and do
    it. You can always compare your implementation with what has been provided in
    the companion code base. There are also things you can add to the original implementation,
    such as file uploads for the exercise image, and once you are more familiar with
    client-server interaction, a remote check to determine whether the YouTube videos
    actually exist.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，这里有一个友好的提醒。如果您还没有完成*个人教练*的练习构建例程，请继续完成。您可以随时将您的实现与伴随代码库中提供的内容进行比较。您还可以添加一些原始实现中没有的内容，比如为练习图片上传文件，以及一旦您更熟悉客户端-服务器交互，就可以进行远程检查，以确定YouTube视频是否真实存在。
