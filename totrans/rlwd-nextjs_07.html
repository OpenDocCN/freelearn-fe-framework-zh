<html><head></head><body>
		<div id="_idContainer020">
			<h1 id="_idParaDest-69"><em class="italic"><a id="_idTextAnchor068"/>Chapter 5</em>: Managing Local and Global States in Next.js</h1>
			<p>State management is one of the central parts of any React application, Next.js apps included. When talking about state, we refer to those dynamic pieces of information that allow us to create highly interactive <strong class="bold">user interfaces</strong> (<strong class="bold">UIs</strong>), making our customers' experience as beautiful and enjoyable as possible.</p>
			<p>Thinking about modern websites, we can spot state changes in many parts of the UI: switching from light to dark theme means that we're changing the UI theme state, filling an e-commerce form with our shipping information means that we're changing that form state, even clicking on a simple button can potentially change a local state, as it can lead our UI to react in many different ways, depending on how the developers decided to manage that state update.</p>
			<p>Even though state management allows us to create beautiful interactions inside our applications, it comes with some extra complexities. Many developers have come up with very different solutions to manage them, allowing us to manage the application state in more straightforward and organized ways.</p>
			<p>Talking about React specifically, since the first versions of the library, we had access to the class components, where the class kept a local state, allowing us to interact with it via the <strong class="source-inline">setState</strong> method. With more modern React versions (&gt;16.8.0), that process has been simplified with the introduction of React Hooks, including the <strong class="source-inline">useState</strong> Hook.</p>
			<p>The most significant difficulty in managing state in a React application is that the data flow should be unidirectional, meaning that we can pass a given state as a prop to a child component, but we cannot do the same with a parent element. That means that local state management can be effortless thanks to class components and Hooks, but global state management can become really convoluted.</p>
			<p>In this chapter, we will take a look at two different approaches for managing the global application state. First, we will see how to use React Context APIs; then, we will rewrite the application using <strong class="bold">Redux</strong>, which will let us understand how to initialize an external library for state management both on the client and server side.</p>
			<p>We will look in detail at the following topics:</p>
			<ul>
				<li>Local state management</li>
				<li>Managing the application state via the Context APIs</li>
				<li>Managing the application state via Redux</li>
			</ul>
			<p>By the end of this chapter, you will learn the differences between local and global state management. You will also learn how to manage the global application state using the React built-in Context APIs or an external library such as Redux.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor069"/>Technical requirements</h1>
			<p>To run the code examples in this chapter, you need to have both Node.js and npm installed on your local machine. If you prefer, you can use an online IDE such as <a href="https://repl.it">https://repl.it</a> or https://codesandbox.io, as they both support Next.js, and you don't need to install any dependency on your computer.</p>
			<p>As with the other chapters, you can find the code base for this chapter on GitHub: <a href="https://github.com/PacktPublishing/Real-World-Next.js">https://github.com/PacktPublishing/Real-World-Next.js</a>.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor070"/>Local state management</h1>
			<p>When talking<a id="_idIndexMarker272"/> about local state management, we're referring to application state that is <em class="italic">component-scoped</em>. We can summarize that concept with an elementary <strong class="source-inline">Counter</strong> component:</p>
			<p class="source-code">import React, { useState } from "react";</p>
			<p class="source-code">function Counter({ initialCount = 0 }) {</p>
			<p class="source-code"><strong class="bold">  const [count, setCount] = useState(initialCount);</strong></p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;div&gt;</p>
			<p class="source-code">      &lt;b&gt;Count is: <strong class="bold">{count}</strong>&lt;/b&gt;&lt;br /&gt;</p>
			<p class="source-code">      &lt;button <strong class="bold">onClick={() =&gt; setCount(count + 1</strong>)}&gt;</p>
			<p class="source-code">        Increment +</p>
			<p class="source-code">      &lt;/button&gt;</p>
			<p class="source-code">      &lt;button <strong class="bold">onClick={() =&gt; setCount(count - 1)}&gt;</strong></p>
			<p class="source-code">        Decrement -</p>
			<p class="source-code">      &lt;/button&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p class="source-code">export default Counter;</p>
			<p>When we <a id="_idIndexMarker273"/>click on the <strong class="source-inline">Increment</strong> button, we will add <strong class="source-inline">1</strong> to the current <strong class="source-inline">count</strong> value. Vice-versa, we will subtract <strong class="source-inline">1</strong> to that value when we click on the <strong class="source-inline">Decrement</strong> button; nothing special!</p>
			<p>But while it's easy for a parent component to pass an <strong class="source-inline">initialCount</strong> value as a prop for the <strong class="source-inline">Counter</strong> element, it can be way more challenging to do the opposite: passing the current <strong class="source-inline">count</strong> value to the parent component. There are many cases where we need to manage just the local state, and the React <strong class="source-inline">useState</strong> Hook can be an excellent way to do so. Those cases can include (but are not limited to) the following:</p>
			<ul>
				<li><strong class="bold">Atom components</strong>: As seen in <a href="B16985_04_Final_SB_epub.xhtml#_idTextAnchor053"><em class="italic">Chapter 4</em></a>,<em class="italic"> Organizing the Code Base and Fetching Data in Next.js</em>, atoms are the most essential React components we can encounter, and they're likely to manage little local states only. More complex states can be delegated to <strong class="bold">molecules</strong> or <strong class="bold">organisms</strong> in many cases.</li>
				<li><strong class="bold">Loading states</strong>: When fetching external data on the client side, we always have a moment when we have neither some data nor an error, as we're still waiting for the HTTP request to complete. We can decide to handle that by setting a <strong class="source-inline">loading</strong> state to <strong class="source-inline">true</strong> until the fetch request is completed to display a nice loading spinner on the UI.</li>
			</ul>
			<p>React Hooks such as <strong class="source-inline">useState</strong> and <strong class="source-inline">useReducer</strong> make local state management effortless, and most of the time, you don't need any external library to handle it.</p>
			<p>Things can change once you need to maintain a global application state across all of your components. A typical example could be an e-commerce website, where once you add an item to<a id="_idIndexMarker274"/> the shopping cart, you may want to display the number of products you're buying with an icon inside your navigation bar.</p>
			<p>We will talk about this specific example right in the next section.</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor071"/>Global state management</h1>
			<p>When talking about<a id="_idIndexMarker275"/> the global application state, we refer to a state shared between all the components for a given web application that is, therefore, reachable and modifiable by any component.</p>
			<p>As seen in the previous section, the React data flow is unidirectional, meaning that components can pass data to their children components, but not to their parents (unlike Vue or Angular). That makes our components less error prone, easier to debug, and more efficient, but adds extra complexity: by default, there cannot be a global state.</p>
			<p>Let's take a look at the following scenario:</p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/Figure_5.01_B16985.jpg" alt="Figure 5.1 – A link between product cards and items in the cart&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – A link between product cards and items in the cart</p>
			<p>In the web application shown in the preceding screenshot, we want to display many products and let our users put them in the shopping cart. The biggest problem here is that there's no link between the data shown in the navigation bar and the product cards, and it can be non-trivial to update the number of products in the cart as soon as the user clicks on the "add" button for a given product. And what if we want to keep this information on page change? It would be lost as soon as the single card components get unmounted with their local state.</p>
			<p>Today, many libraries make it a bit easier to manage those situations: <strong class="bold">Redux</strong>, <strong class="bold">Recoil</strong>, and <strong class="bold">MobX</strong> are just some of the most popular solutions, but there are also other approaches. In fact, with React Hooks' introduction, we can use the <em class="italic">Context APIs</em> for managing the global application state without the need for external libraries. There's also a less popular approach that I'd like to take into consideration: using <strong class="bold">Apollo Client </strong>(and its <strong class="bold">in-memory cache</strong>). That <a id="_idIndexMarker276"/>would change the way we think of our state and gives us a formal query language for interacting with the global application data. If you're interested in that approach, I'd highly recommend reading the official Apollo GraphQL tutorial: <a href="https://www.apollographql.com/docs/react/local-state/local-state-management">https://www.apollographql.com/docs/react/local-state/local-state-management</a>.</p>
			<p>Starting from the next section, we will be building a very minimal storefront, just like the one we saw in the previous figure. Once the user adds one or more products to the shopping cart, we will <a id="_idIndexMarker277"/>update the count inside of the navigation bar. Once the user decides to proceed with the checkout, we will need to display the selected products on the checkout page.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor072"/>Using the Context APIs</h2>
			<p>With <strong class="bold">React v16.3.0</strong>, released <a id="_idIndexMarker278"/>back in 2018, we finally got <a id="_idIndexMarker279"/>access to stable Context APIs. They give us a straightforward way to share data between all the components inside a given context without explicitly having to pass it via props from one component to another, even from children to a parent component. If you want to learn more about React Context, I highly recommend reading the official React documentation: https://reactjs.org/docs/context.html.</p>
			<p>Starting with this section, we will always use the same boilerplate code for approaching global state management with<a id="_idIndexMarker280"/> different libraries. You can find this boilerplate code here: https://github.com/PacktPublishing/Real-World-Next.js/tree/main/05-state-management-made-easy/boilerplate.</p>
			<p>We will also keep the same approach for storing the selected products in the global state for simplicity's sake; our state will be a JavaScript object. Each property is the ID of a product, and its value will represent the number of products that the user has selected. If you open the <strong class="source-inline">data/items.js</strong> file, you will find an array of objects representing our products. If a user selects four carrots and two onions, our state will look like this:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "8321-k532": 4,</p>
			<p class="source-code">  "9126-b921": 2</p>
			<p class="source-code">}</p>
			<p>That being said, let's start by creating the context for our shopping cart. We can do that by<a id="_idIndexMarker281"/> creating a <a id="_idIndexMarker282"/>new file: <strong class="source-inline">components/context/cartContext.js</strong>:</p>
			<p class="source-code">import { createContext } from 'react';</p>
			<p class="source-code">const ShoppingCartContext = createContext({</p>
			<p class="source-code">  items: {},</p>
			<p class="source-code">  setItems: () =&gt; null,</p>
			<p class="source-code">});</p>
			<p class="source-code">export default ShoppingCartContext;</p>
			<p>Just like in a typical client-side rendered React app, we now want to wrap all the components that need to share the cart data under the same context. For instance, the <strong class="source-inline">/components/Navbar.js</strong> component needs to be mounted inside the same context as the <strong class="source-inline">/components/ProductCard.js</strong> component.</p>
			<p>We should also consider that we want our global state to be persistent when changing the page, as we want to display the number of products selected by the user on the checkout page. That said, we can customize the <strong class="source-inline">/pages/_app.js</strong> page, as seen in <a href="B16985_03_Final_SB_epub.xhtml#_idTextAnchor038"><em class="italic">Chapter 3</em></a><em class="italic">, Next.js Basics and Built-In Components</em>, to wrap the entire application under the<a id="_idIndexMarker283"/> same <a id="_idIndexMarker284"/>React context:</p>
			<p class="source-code">import { useState } from 'react';</p>
			<p class="source-code">import Head from 'next/head';</p>
			<p class="source-code"><strong class="bold">import CartContext from</strong></p>
			<p class="source-code"><strong class="bold">  '../components/context/cartContext';</strong></p>
			<p class="source-code">import Navbar from '../components/Navbar';</p>
			<p class="source-code">function MyApp({ Component, pageProps }) {</p>
			<p class="source-code"><strong class="bold">  const [items, setItems] = useState({});</strong></p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;&gt;</p>
			<p class="source-code">      &lt;Head&gt;</p>
			<p class="source-code">        &lt;link</p>
			<p class="source-code">href="https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css"</p>
			<p class="source-code">          rel="stylesheet"</p>
			<p class="source-code">        /&gt;</p>
			<p class="source-code">      &lt;/Head&gt;</p>
			<p class="source-code">      <strong class="bold">&lt;CartContext.Provider value={{ items, setItems }}&gt;</strong></p>
			<p class="source-code">        &lt;Navbar /&gt;</p>
			<p class="source-code">        &lt;div className="w-9/12 m-auto pt-10"&gt;</p>
			<p class="source-code">          &lt;Component {...pageProps} /&gt;</p>
			<p class="source-code">        &lt;/div&gt;</p>
			<p class="source-code">      <strong class="bold">&lt;/CartContext.Provider&gt;</strong></p>
			<p class="source-code">    &lt;/&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default MyApp;</p>
			<p>As you can see, we're wrapping both <strong class="source-inline">&lt;Navbar /&gt;</strong> and <strong class="source-inline">&lt;Component {...pageProps /&gt;</strong> under the same context. That way, they gain access to the same global state, creating a link between all the components rendered on every page and the <a id="_idIndexMarker285"/>navigation<a id="_idIndexMarker286"/> bar.</p>
			<p>Now let's take a quick look at the <strong class="source-inline">/pages/index.js</strong> page:</p>
			<p class="source-code">import ProductCard from '../components/ProductCard';</p>
			<p class="source-code">import products from '../data/items';</p>
			<p class="source-code">function Home() {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;div className="grid grid-cols-4 gap-4"&gt;</p>
			<p class="source-code">      {products.map((product) =&gt; (</p>
			<p class="source-code">        &lt;ProductCard key={product.id} {...product} /&gt;</p>
			<p class="source-code">      ))}</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default Home;</p>
			<p>To make it simpler, we're importing all the products from a local JavaScript file, but of course, they could also come from a remote API. For each product, we render the <strong class="source-inline">ProductCard</strong> component, which will allow the users to add them to the shopping cart and then proceed to the checkout.</p>
			<p>Let's take <a id="_idIndexMarker287"/>a<a id="_idIndexMarker288"/> look at the <strong class="source-inline">ProductCard</strong> component:</p>
			<p class="source-code">function ProductCard({ id, name, price, picture }) {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;div className="bg-gray-200 p-6 rounded-md"&gt;</p>
			<p class="source-code">    &lt;div className="relative 100% h-40 m-auto"&gt;</p>
			<p class="source-code">      &lt;img src={picture} alt={name} className="object-cover" /&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">    &lt;div className="flex justify-between mt-4"&gt;</p>
			<p class="source-code">    &lt;div className="font-bold text-l"&gt; {name} &lt;/div&gt;</p>
			<p class="source-code">    &lt;div className="font-bold text-l text-gray-500"&gt; ${price}       per kg &lt;/div&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">    &lt;div className="flex justify-between mt-4 w-2/4 m-auto"&gt;</p>
			<p class="source-code">      &lt;button</p>
			<p class="source-code">      className="pl-2 pr-2 bg-red-400 text-white rounded-md"</p>
			<p class="source-code">      disabled={false <strong class="bold">/* To be implemented */}</strong></p>
			<p class="source-code">      onClick={() =&gt; {} <strong class="bold">/* To be implemented */}&gt;</strong></p>
			<p class="source-code">        -</p>
			<p class="source-code">      &lt;/button&gt;</p>
			<p class="source-code">    &lt;div&gt;{<strong class="bold">/* To be implemented */}&lt;/</strong>div&gt;</p>
			<p class="source-code">      &lt;button</p>
			<p class="source-code">      className="pl-2 pr-2 bg-green-400 text-white rounded-md"      onClick={()  =&gt; {} <strong class="bold">/* To be implemented */}&gt;</strong></p>
			<p class="source-code">        +</p>
			<p class="source-code">      &lt;/button&gt;</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default ProductCard;</p>
			<p>As you can see, we are already building the UI for that component, but nothing happens when clicking on <a id="_idIndexMarker289"/>both the <strong class="source-inline">increment</strong> and <strong class="source-inline">decrement</strong> buttons. We<a id="_idIndexMarker290"/> now need to link that component to the <strong class="source-inline">cartContext</strong> context and then update the context state as soon as the user clicks on one of the two buttons:</p>
			<p class="source-code"><strong class="bold">import { useContext } from 'react';</strong></p>
			<p class="source-code"><strong class="bold">import cartContext from '../components/context/cartContext';</strong></p>
			<p class="source-code">function ProductCard({ id, name, price, picture }) {</p>
			<p class="source-code"><strong class="bold">const { setItems, items } = useContext(cartContext);</strong></p>
			<p class="source-code">// ...</p>
			<p>Using the <strong class="source-inline">useContext</strong> Hook, we're linking both <strong class="source-inline">setItems</strong> and <strong class="source-inline">items</strong> from the <strong class="source-inline">_app.js</strong> page to our <strong class="source-inline">ProductCard</strong> component. Every time we call <strong class="source-inline">setItems</strong> on that component, we will be updating the global <strong class="source-inline">items</strong> object, and that change will be propagated to all the components living under the same context and linked to the same global state. That also means that we don't need to keep a local state for each <strong class="source-inline">ProductCard</strong> component, as the information about the number of single products added to the shopping cart already exists in our context state. Therefore, if we want to know the number of products added to the shopping cart, we can proceed as follows:</p>
			<p class="source-code">import { useContext } from 'react';</p>
			<p class="source-code">import cartContext from '../components/context/cartContext';</p>
			<p class="source-code">function ProductCard({ id, name, price, picture })</p>
			<p class="source-code">  const { setItems, items } = useContext(cartContext);</p>
			<p class="source-code"><strong class="bold">  const productAmount = id in items ? items[id] : 0;</strong></p>
			<p class="source-code">// ...</p>
			<p>That way, every<a id="_idIndexMarker291"/> time <a id="_idIndexMarker292"/>the user clicks on the <strong class="source-inline">increment</strong> button for a given product, the global <strong class="source-inline">items</strong> state will change, the <strong class="source-inline">ProductCard</strong> component will be re-rendered, and the <strong class="source-inline">productAmount</strong> constant will end up having a new value.</p>
			<p>Talking again about handling both <strong class="source-inline">increment</strong> and <strong class="source-inline">decrement</strong> actions, we need to control the user clicks on those buttons. We can write a generic <strong class="source-inline">handleAmount</strong> function taking a single argument that can be either <strong class="source-inline">"increment"</strong> or <strong class="source-inline">"decrement"</strong>. If the passed parameter is <strong class="source-inline">"increment"</strong>, we need to check if the current product already exists inside the global state (remember, an initial global state is an empty object). If it exists, we only need to increment its value by one; otherwise, we need to create a new property inside the <strong class="source-inline">items</strong> object where the key will be our product ID, and its value will be set to <strong class="source-inline">1</strong>.</p>
			<p>If the parameter is <strong class="source-inline">"decrement"</strong>, we should check whether the current product already exists inside of the global <strong class="source-inline">items</strong> object. If that's the case, and the value is greater than <strong class="source-inline">0</strong>, we can just decrement it. In all other cases, we can just exit the function, as we cannot have a negative number as a value for an amount of our products:</p>
			<p class="source-code">import { useContext } from 'react';</p>
			<p class="source-code">import cartContext from '../components/context/cartContext';</p>
			<p class="source-code">function ProductCard({ id, name, price, picture }) {</p>
			<p class="source-code">  const { setItems, items } = useContext(cartContext);</p>
			<p class="source-code">  const productAmount = items?.[id] ?? 0;</p>
			<p class="source-code"><strong class="bold">  const handleAmount = (action) =&gt; {</strong></p>
			<p class="source-code"><strong class="bold">    if (action === 'increment') {</strong></p>
			<p class="source-code"><strong class="bold">      const newItemAmount = id in items ? items[id] + 1 : 1;</strong></p>
			<p class="source-code"><strong class="bold">      setItems({ ...items, [id]: newItemAmount });</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">    if (action === 'decrement') {</strong></p>
			<p class="source-code"><strong class="bold">      if (items?.[id] &gt; 0) {</strong></p>
			<p class="source-code"><strong class="bold">        setItems({ ...items, [id]: items[id] - 1 });</strong></p>
			<p class="source-code"><strong class="bold">      }</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">  };</strong></p>
			<p class="source-code">// ...</p>
			<p>We now just <a id="_idIndexMarker293"/>need<a id="_idIndexMarker294"/> to update the <strong class="source-inline">increment</strong> and <strong class="source-inline">decrement</strong> buttons to trigger the <strong class="source-inline">handleAmount</strong> function on click:</p>
			<p class="source-code">&lt;div className="flex justify-between mt-4 w-2/4 m-auto"&gt;</p>
			<p class="source-code">&lt;button</p>
			<p class="source-code">  className="pl-2 pr-2 bg-red-400 text-white rounded-md"</p>
			<p class="source-code"><strong class="bold">  disabled={productAmount === 0}</strong></p>
			<p class="source-code"><strong class="bold">  onClick={() =&gt; handleAmount('decrement')}&gt;</strong></p>
			<p class="source-code">    -</p>
			<p class="source-code">&lt;/button&gt;</p>
			<p class="source-code"><strong class="bold">  &lt;div&gt;{productAmount}&lt;/div&gt;</strong></p>
			<p class="source-code">&lt;button</p>
			<p class="source-code">  className="pl-2 pr-2 bg-green-400 text-white rounded-md"</p>
			<p class="source-code"><strong class="bold">  onClick={() =&gt; handleAmount('increment')}&gt;</strong></p>
			<p class="source-code">    +</p>
			<p class="source-code">&lt;/button&gt;</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p>If we now try <a id="_idIndexMarker295"/>to<a id="_idIndexMarker296"/> increment and decrement our products' amount, we will see the number inside of the <strong class="source-inline">ProductCard</strong> component changing after each button click! But looking at the navigation bar, the value will remain set to <strong class="source-inline">0</strong>, as we haven't linked the global items state to the <strong class="source-inline">Navbar</strong> component. Let's open the <strong class="source-inline">/components/Navbar.js</strong> file and type the following:</p>
			<p class="source-code"><strong class="bold">import { useContext } from 'react';</strong></p>
			<p class="source-code">import Link from 'next/link';</p>
			<p class="source-code"><strong class="bold">import cartContext from '../components/context/cartContext';</strong></p>
			<p class="source-code">function Navbar() {</p>
			<p class="source-code"><strong class="bold">  const { items } = useContext(cartContext);</strong></p>
			<p class="source-code">// ...</p>
			<p>We don't need to update the global <strong class="source-inline">items</strong> state from our navigation bar, so, in that case, we don't need to declare the <strong class="source-inline">setItems</strong> function. In that component, we only want to display the total amount of products added to the shopping cart (for instance, if we add two carrots and one onion, we should see <strong class="source-inline">3</strong> as the total in our <strong class="source-inline">Navbar</strong>). We can do that quite easily:</p>
			<p class="source-code">import { useContext } from 'react';</p>
			<p class="source-code">import Link from 'next/link';</p>
			<p class="source-code">import cartContext from '../components/context/cartContext';</p>
			<p class="source-code">function Navbar() {</p>
			<p class="source-code">  const { items } = useContext(cartContext);</p>
			<p class="source-code"><strong class="bold">  const totalItemsAmount = Object.values(items)</strong></p>
			<p class="source-code"><strong class="bold">    .reduce((x, y) =&gt; x + y, 0);</strong></p>
			<p class="source-code">// ...</p>
			<p>Now let's<a id="_idIndexMarker297"/> just <a id="_idIndexMarker298"/>display the <strong class="source-inline">totalItemsAmount</strong> variable inside of the resulting HTML:</p>
			<p class="source-code">// ...</p>
			<p class="source-code">&lt;div className="font-bold underline"&gt;</p>
			<p class="source-code">  &lt;Link href="/cart" passHref&gt;</p>
			<p class="source-code"><strong class="bold">    &lt;a&gt;{totalItemsAmount} items in cart&lt;/a&gt;</strong></p>
			<p class="source-code">  &lt;/Link&gt;</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p class="source-code">// ...</p>
			<p>Great! We just missed one last thing: clicking on the <strong class="source-inline">Navbar</strong> link to the checkout page, we can't see any products displayed on the page. We can fix that by fixing the <strong class="source-inline">/pages/cart.js</strong> page:</p>
			<p class="source-code"><strong class="bold">import { useContext } from 'react';</strong></p>
			<p class="source-code"><strong class="bold">import cartContext from '../components/context/cartContext';</strong></p>
			<p class="source-code">import data from '../data/items';</p>
			<p class="source-code">function Cart() {</p>
			<p class="source-code"><strong class="bold">  const { items } = useContext(cartContext);</strong></p>
			<p class="source-code">// ...</p>
			<p>As you can <a id="_idIndexMarker299"/>see, we're <a id="_idIndexMarker300"/>importing the context objects as usual and the complete product list. That's because we need to get the complete product info (inside the state, we only have the relationship between a product ID and product amount) for displaying the name of the product, the amount, and the total price for that product. We then need a way to get the whole product object given a product ID. We can write a <strong class="source-inline">getFullItem</strong> function (outside of our component) that only takes an ID and returns the entire product object:</p>
			<p class="source-code">import { useContext } from 'react';</p>
			<p class="source-code">import cartContext from '../components/context/cartContext';</p>
			<p class="source-code">import data from '../data/items';</p>
			<p class="source-code"><strong class="bold">function getFullItem(id) {</strong></p>
			<p class="source-code"><strong class="bold">  const idx = data.findIndex((item) =&gt; item.id === id);</strong></p>
			<p class="source-code"><strong class="bold">  return data[idx];</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code">function Cart() {</p>
			<p class="source-code">  const { items } = useContext(cartContext);</p>
			<p class="source-code">// ...</p>
			<p>Now that we have access to the complete product object, we can get the total price for all of our<a id="_idIndexMarker301"/> products<a id="_idIndexMarker302"/> inside of the shopping cart:</p>
			<p class="source-code">// ...</p>
			<p class="source-code">function Cart() {</p>
			<p class="source-code">  const { items } = useContext(cartContext);</p>
			<p class="source-code"><strong class="bold">  const total = Object.keys(items)</strong></p>
			<p class="source-code"><strong class="bold">    .map((id) =&gt; getFullItem(id).price * items[id])</strong></p>
			<p class="source-code"><strong class="bold">    .reduce((x, y) =&gt; x + y, 0);</strong></p>
			<p class="source-code">// ...</p>
			<p>We also want to display a list of products inside of the shopping cart in the format of <em class="italic">x2 Carrots ($7)</em>. We can easily create a new array called <strong class="source-inline">amounts</strong> and fill it with all the products we've added to the cart, plus the amount for every single product:</p>
			<p class="source-code">// ...</p>
			<p class="source-code">function Cart() {</p>
			<p class="source-code">  const { items } = useContext(cartContext);</p>
			<p class="source-code">  const total = Object.keys(items)</p>
			<p class="source-code">    .map((id) =&gt; getFullItem(id).price * items[id])</p>
			<p class="source-code">    .reduce((x, y) =&gt; x + y, 0);</p>
			<p class="source-code"><strong class="bold">  const amounts = Object.keys(items).map((id) =&gt; {</strong></p>
			<p class="source-code"><strong class="bold">    const item = getFullItem(id);</strong></p>
			<p class="source-code"><strong class="bold">    return { item, amount: items[id] };</strong></p>
			<p class="source-code"><strong class="bold">  });</strong></p>
			<p class="source-code">// ...</p>
			<p>Now, we <a id="_idIndexMarker303"/>only <a id="_idIndexMarker304"/>need to update the returning template for that component:</p>
			<p class="source-code">// ...</p>
			<p class="source-code">&lt;div&gt;</p>
			<p class="source-code"><strong class="bold">&lt;h1 className="text-xl font-bold"&gt; Total: ${total} &lt;/h1&gt;</strong></p>
			<p class="source-code">&lt;div&gt;</p>
			<p class="source-code"><strong class="bold">  {amounts.map(({ item, amount }) =&gt; (</strong></p>
			<p class="source-code"><strong class="bold">    &lt;div key={item.id}&gt;</strong></p>
			<p class="source-code"><strong class="bold">      x{amount} {item.name} (${amount * </strong></p>
			<p class="source-code"><strong class="bold">        item.price})</strong></p>
			<p class="source-code"><strong class="bold">&lt;/div&gt;</strong></p>
			<p class="source-code"><strong class="bold">  ))}</strong></p>
			<p class="source-code">&lt;/div&gt;</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p class="source-code">// ...</p>
			<p>And we're done! After booting the server, we can add as many products as we want to the shopping cart and see the total price going to the <strong class="source-inline">/cart</strong> page.</p>
			<p>Using the context APIs in Next.js is not that difficult, as the concepts are the same for the vanilla React <a id="_idIndexMarker305"/>applications. In the next section, we will see how to achieve the same results using<a id="_idIndexMarker306"/> Redux as a global state manager.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor073"/>Using Redux</h2>
			<p>In 2015, two <a id="_idIndexMarker307"/>years <a id="_idIndexMarker308"/>after the initial React public release, there weren't asmany frameworks and libraries as today for handling large-scale application states. The most advanced way for handling unidirectional data flow was Flux, which, as time has passed, has been superseded by more straightforward and modern libraries <a id="_idIndexMarker309"/>such as <strong class="bold">Redux</strong> and <strong class="bold">MobX</strong>.</p>
			<p>Redux, in particular, had a significant impact on the React community and quickly became a de facto state manager for building large-scale applications in React.</p>
			<p>In this section, we will be using plain Redux (without middlewares<a id="_idIndexMarker310"/> such as <strong class="bold">redux-thunk</strong> or <strong class="bold">redux-saga</strong>) fo<a id="_idIndexMarker311"/>r managing the storefront state instead of using the React Context APIs.</p>
			<p>Let's start by cloning the boilerplate code from <a href="https://github.com/PacktPublishing/Real-World-Next.js/tree/main/05-managing-local-and-global-states-in-nextjs/boilerplate">https://github.com/PacktPublishing/Real-World-Next.js/tree/main/05-managing-local-and-global-states-in-nextjs/boilerplate</a><a href="https://github.com/PacktPublishing/Real-World-Next.js/tree/main/05-managing-local-and-global-states-in-nextjs/boilerplate "/>(just like we did in the previous section).</p>
			<p>At this point, we will need to install two new dependencies:</p>
			<p class="source-code">yarn add redux react-redux</p>
			<p>We can also install the <strong class="bold">Redux DevTools extension</strong>, which allows us to inspect and debug the application state from our browser:</p>
			<p class="source-code">yarn add -D redux-devtools-extension</p>
			<p>Now we can start coding our Next.js + Redux application.</p>
			<p>First of all, we will need to initialize the global store, which is the part of our application containing the application state. We can do that by creating a new folder inside of the root of our project, calling it <strong class="source-inline">redux/</strong>. Here we can write a new <strong class="source-inline">store.js</strong> file containing the logic for initializing our store on both the client side and server side:</p>
			<p class="source-code">import { useMemo } from 'react';</p>
			<p class="source-code">import { createStore, applyMiddleware } from 'redux';</p>
			<p class="source-code">import { composeWithDevTools } from 'redux-devtools-extension';</p>
			<p class="source-code">let store;</p>
			<p class="source-code">const initialState = {};</p>
			<p class="source-code">// ...</p>
			<p>As you can see, we start by instantiating a new variable, <strong class="source-inline">store</strong>, which (as you may have guessed) will be used later on for keeping the Redux store.</p>
			<p>Then, we<a id="_idIndexMarker312"/> initialize<a id="_idIndexMarker313"/> the <strong class="source-inline">initialState</strong> for our Redux store. In that case, it will be an empty object, as we will add more properties depending on which product our users select on the storefront.</p>
			<p>We now need to create our first and only reducer. In a real-world application, we would write many different reducers in many different files, making things more manageable in terms of maintainability for our project. In that case, we will write just one reducer (as it is the only one we need), and we will include that in the <strong class="source-inline">store.js</strong> file for simplicity's sake:</p>
			<p class="source-code">//...</p>
			<p class="source-code">const reducer = (state = initialState, action) =&gt; {</p>
			<p class="source-code">  const itemID = action.id;</p>
			<p class="source-code">  switch (action.type) {</p>
			<p class="source-code">    case 'INCREMENT':</p>
			<p class="source-code">      const newItemAmount = itemID in state ? </p>
			<p class="source-code">        state[itemID] + 1 : 1;</p>
			<p class="source-code">      return {</p>
			<p class="source-code">        ...state,</p>
			<p class="source-code">        [itemID]: newItemAmount,</p>
			<p class="source-code">      };</p>
			<p class="source-code">    case 'DECREMENT':</p>
			<p class="source-code">      if (state?.[itemID] &gt; 0) {</p>
			<p class="source-code">        return {</p>
			<p class="source-code">          ...state,</p>
			<p class="source-code">          [itemID]: state[itemID] - 1,</p>
			<p class="source-code">        };</p>
			<p class="source-code">      }</p>
			<p class="source-code">      return state;</p>
			<p class="source-code">    default:</p>
			<p class="source-code">      return state;</p>
			<p class="source-code">  }</p>
			<p class="source-code">};</p>
			<p>The reducer's<a id="_idIndexMarker314"/> logic<a id="_idIndexMarker315"/> is not that different from the one we wrote in the previous section inside the <strong class="source-inline">handleAmount</strong> function for our <strong class="source-inline">ProductCard</strong> component.</p>
			<p>Now we need to initialize our store, and we can do that by creating two different functions. The first one will be a simple helper function called <strong class="source-inline">initStore</strong>, and it will make things easier later on:</p>
			<p class="source-code">// ...</p>
			<p class="source-code">function initStore(preloadedState = initialState) {</p>
			<p class="source-code">  return createStore(</p>
			<p class="source-code">    reducer,</p>
			<p class="source-code">    preloadedState,</p>
			<p class="source-code">    composeWithDevTools(applyMiddleware())</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p>The second function we need to create is the one we will use for properly initializing the store, and<a id="_idIndexMarker316"/> we're <a id="_idIndexMarker317"/>going to call it <strong class="source-inline">initializeStore</strong>:</p>
			<p class="source-code">// ...</p>
			<p class="source-code">export const initializeStore = (preloadedState) =&gt; {</p>
			<p class="source-code">  let _store = store ?? initStore(preloadedState);</p>
			<p class="source-code">  if (preloadedState &amp;&amp; store) {</p>
			<p class="source-code">    _store = initStore({</p>
			<p class="source-code">      ...store.getState(),</p>
			<p class="source-code">      ...preloadedState,</p>
			<p class="source-code">    });</p>
			<p class="source-code">    store = undefined;</p>
			<p class="source-code">  }</p>
			<p class="source-code">  //Return '_store' when initializing Redux on the server-side</p>
			<p class="source-code">  if (typeof window === 'undefined') return _store;</p>
			<p class="source-code">  if (!store) store = _store;</p>
			<p class="source-code">  return _store;</p>
			<p class="source-code">};</p>
			<p>Now that we have our store set up, we can create one last function, a Hook we'll be using in our components. We'll wrap it inside a <strong class="source-inline">useMemo</strong> function to take advantage of the React built-in memoization system, which will cache complex initial states, avoiding the system re-parsing it on every <strong class="source-inline">useStore</strong> function call:</p>
			<p class="source-code">// ...</p>
			<p class="source-code">export function useStore(initialState) {</p>
			<p class="source-code">  return useMemo(</p>
			<p class="source-code">    () =&gt; initializeStore(initialState), [initialState]</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p>Great! We're <a id="_idIndexMarker318"/>now<a id="_idIndexMarker319"/> ready to move on and attach Redux to our Next.js application.</p>
			<p>Just as we did with the Context APIs in the previous section, we will need to edit our <strong class="source-inline">_app.js</strong> file so that Redux will be globally available for every component living inside of our Next.js app:</p>
			<p class="source-code">import Head from 'next/head';</p>
			<p class="source-code"><strong class="bold">import { Provider } from 'react-redux';</strong></p>
			<p class="source-code"><strong class="bold">import { useStore } from '../redux/store';</strong></p>
			<p class="source-code">import Navbar from '../components/Navbar';</p>
			<p class="source-code">function MyApp({ Component, pageProps }) {</p>
			<p class="source-code"><strong class="bold">  const store = useStore(pageProps.initialReduxState);</strong></p>
			<p class="source-code">  return (</p>
			<p class="source-code">  &lt;&gt;</p>
			<p class="source-code">&lt;Head&gt;</p>
			<p class="source-code">  &lt;link href="https://unpkg.com/tailwindcss@^2/dist/tailwind.    min.css" rel="stylesheet" /&gt;</p>
			<p class="source-code">&lt;/Head&gt;</p>
			<p class="source-code"><strong class="bold">  &lt;Provider store={store}&gt;</strong></p>
			<p class="source-code">&lt;Navbar /&gt;</p>
			<p class="source-code">  &lt;div className="w-9/12 m-auto pt-10"&gt;</p>
			<p class="source-code">    &lt;Component {...pageProps} /&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code"><strong class="bold">  &lt;/Provider&gt;</strong></p>
			<p class="source-code">&lt;/&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default MyApp;</p>
			<p>If you <a id="_idIndexMarker320"/>compare<a id="_idIndexMarker321"/> this <strong class="source-inline">_app.js</strong> file with the one we created in the previous section, you may notice some similarities. From this moment, the two implementations will look very similar, as Context APIs try to make global state management more accessible and easier for everyone, and the Redux influence in shaping those APIs is visible.</p>
			<p>We now need to implement the <strong class="source-inline">increment</strong>/<strong class="source-inline">decrement</strong> logic for our <strong class="source-inline">ProductCard</strong> component using Redux. Let's start by opening the <strong class="source-inline">components/ProductCard.js</strong> file and add the following imports:</p>
			<p class="source-code">import { useDispatch, useSelector, shallowEqual } from 'react-redux';</p>
			<p class="source-code">// ...</p>
			<p>Now, let's create a Hook that will come in handy when we need to fetch all the products in our Redux store:</p>
			<p class="source-code">import { useDispatch, useSelector, shallowEqual } from 'react-redux';</p>
			<p class="source-code"><strong class="bold">function useGlobalItems() {</strong></p>
			<p class="source-code"><strong class="bold">  return useSelector((state) =&gt; state, shallowEqual);</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code">// ...</p>
			<p>Staying inside <a id="_idIndexMarker322"/>the <a id="_idIndexMarker323"/>same file, let's edit the <strong class="source-inline">ProductCard</strong> component by integrating the Redux Hooks we need:</p>
			<p class="source-code">// ...</p>
			<p class="source-code">function ProductCard({ id, name, price, picture }) {</p>
			<p class="source-code">  const dispatch = useDispatch();</p>
			<p class="source-code">  const items = useGlobalItems();</p>
			<p class="source-code">  const productAmount = items?.[id] ?? 0;</p>
			<p class="source-code">  return (</p>
			<p class="source-code">// ...</p>
			<p>Finally, we need to trigger a dispatch when the user clicks on one of our component's buttons. Thanks to the <strong class="source-inline">useDispatch</strong> Hook we previously imported, that operation will be straightforward to implement. We just need to update the <strong class="source-inline">onClick</strong> callback for our HTML buttons <a id="_idIndexMarker324"/>inside the render function as<a id="_idIndexMarker325"/> follows:</p>
			<p class="source-code">// ...</p>
			<p class="source-code">&lt;div className="flex justify-between mt-4 w-2/4 m-auto"&gt;</p>
			<p class="source-code">  &lt;button</p>
			<p class="source-code">    className="pl-2 pr-2 bg-red-400 text-white rounded-md"</p>
			<p class="source-code"><strong class="bold">    disabled={productAmount === 0}</strong></p>
			<p class="source-code"><strong class="bold">    onClick={() =&gt; dispatch({ type: 'DECREMENT', id })}&gt;</strong></p>
			<p class="source-code">      -</p>
			<p class="source-code">  &lt;/button&gt;</p>
			<p class="source-code"><strong class="bold">&lt;div&gt;{productAmount}&lt;/div&gt;</strong></p>
			<p class="source-code">  &lt;button</p>
			<p class="source-code">    className="pl-2 pr-2 bg-green-400 text-white rounded-md"</p>
			<p class="source-code"><strong class="bold">    onClick={() =&gt; dispatch({ type: 'INCREMENT', id })}&gt;</strong></p>
			<p class="source-code">      +</p>
			<p class="source-code">  &lt;/button&gt;</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p class="source-code">// ...</p>
			<p>Suppose you've installed the Redux DevTools extension for your browser. In that case, you can now start to increment or decrement a product and see the action as it is dispatched directly inside your debugging tools.</p>
			<p>By the way, we still need to update the navigation bar when we add or remove a product from our cart. We can easily do that by editing the <strong class="source-inline">components/NavBar.js</strong> component <a id="_idIndexMarker326"/>just as we did <a id="_idIndexMarker327"/>for the <strong class="source-inline">ProductCard</strong> one:</p>
			<p class="source-code"><strong class="bold">import Link from 'next/link';</strong></p>
			<p class="source-code"><strong class="bold">import { useSelector, shallowEqual } from 'react-redux';</strong></p>
			<p class="source-code"><strong class="bold">function useGlobalItems() {</strong></p>
			<p class="source-code"><strong class="bold">  return useSelector((state) =&gt; state, shallowEqual);</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code">function Navbar() {</p>
			<p class="source-code"><strong class="bold">  const items = useGlobalItems();</strong></p>
			<p class="source-code"><strong class="bold">  const totalItemsAmount = Object.keys(items)</strong></p>
			<p class="source-code"><strong class="bold">    .map((key) =&gt; items[key])</strong></p>
			<p class="source-code"><strong class="bold">    .reduce((x, y) =&gt; x + y, 0);</strong></p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;div className="w-full bg-purple-600 p-4 text-white"&gt;</p>
			<p class="source-code">    &lt;div className="w-9/12 m-auto flex justify-between"&gt;</p>
			<p class="source-code">    &lt;div className="font-bold"&gt;</p>
			<p class="source-code">      &lt;Link href="/" passHref&gt;</p>
			<p class="source-code">        &lt;a&gt; My e-commerce &lt;/a&gt;</p>
			<p class="source-code">      &lt;/Link&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">    &lt;div className="font-bold underline"&gt;</p>
			<p class="source-code">      &lt;Link href="/cart" passHref&gt;</p>
			<p class="source-code"><strong class="bold">        &lt;a&gt;{totalItemsAmount} items in cart&lt;/a&gt;</strong></p>
			<p class="source-code">      &lt;/Link&gt;</p>
			<p class="source-code">     &lt;/div&gt;</p>
			<p class="source-code">     &lt;/div&gt;</p>
			<p class="source-code">     &lt;/div&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default Navbar;</p>
			<p>We can now <a id="_idIndexMarker328"/>try to <a id="_idIndexMarker329"/>add and remove products from our storefront and see the state change reflected in the navigation bar.</p>
			<p>One last thing before we can consider our e-commerce app complete: we need to update the <strong class="source-inline">/cart</strong> page so that we can see a summary of the shopping cart before moving to the checkout step. It will be incredibly easy, as we will combine what we learned from the previous section using the Context APIs and the knowledge of Redux Hooks we've just gained. Let's open the <strong class="source-inline">pages/Cart.js</strong> file and import the same Redux Hook we used for the other components:</p>
			<p class="source-code"><strong class="bold">import { useSelector, shallowEqual } from 'react-redux';</strong></p>
			<p class="source-code">import data from '../data/items';</p>
			<p class="source-code"><strong class="bold">function useGlobalItems() {</strong></p>
			<p class="source-code"><strong class="bold">  return useSelector((state) =&gt; state, shallowEqual);</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code">// ...</p>
			<p>At this point, we can just replicate the <strong class="source-inline">getFullItem</strong> function we created for the Context APIs in the previous section:</p>
			<p class="source-code">// ...</p>
			<p class="source-code">function getFullItem(id) {</p>
			<p class="source-code">  const idx = data.findIndex((item) =&gt; item.id === id);</p>
			<p class="source-code">  return data[idx];</p>
			<p class="source-code">}</p>
			<p class="source-code">// ...</p>
			<p>The same happens for the <strong class="source-inline">Cart</strong> component. We will basically replicate what we did in the <a id="_idIndexMarker330"/>previous <a id="_idIndexMarker331"/>section, with a simple difference: the <strong class="source-inline">items</strong> object will come from the Redux store instead of a React context:</p>
			<p class="source-code">function Cart() {</p>
			<p class="source-code"><strong class="bold">  const items = useGlobalItems();</strong></p>
			<p class="source-code">  const total = Object.keys(items)</p>
			<p class="source-code">    .map((id) =&gt; getFullItem(id).price * items[id])</p>
			<p class="source-code">    .reduce((x, y) =&gt; x + y, 0);</p>
			<p class="source-code">  const amounts = Object.keys(items).map((id) =&gt; {</p>
			<p class="source-code">    const item = getFullItem(id);</p>
			<p class="source-code">    return { item, amount: items[id] };</p>
			<p class="source-code">  });</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;div&gt;</p>
			<p class="source-code">      &lt;h1 className="text-xl font-bold"&gt; Total: ${total}  </p>
			<p class="source-code">      &lt;/h1&gt;</p>
			<p class="source-code">    &lt;div&gt;</p>
			<p class="source-code">        {amounts.map(({ item, amount }) =&gt; (</p>
			<p class="source-code">          &lt;div key={item.id}&gt;</p>
			<p class="source-code">            x{amount} {item.name} (${amount * item.price})</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">        ))}</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default Cart;</p>
			<p>If you now try to add a couple of products to your shopping cart, then move to the <strong class="source-inline">/cart</strong> page, you will see a summary of your expenses.</p>
			<p>As you may have noticed, there aren't many differences between Context APIs and plain Redux (without using any middleware). By using Redux, by the way, you'll gain access to an <a id="_idIndexMarker332"/>incredibly <a id="_idIndexMarker333"/>vast ecosystem of plugins, middleware, and debugging tools that will make your developer experience way more effortless once you need to scale and handle very complex business logic inside of your web application.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/>Summary</h1>
			<p>In this chapter, we focused on state management using both React built-in APIs (the Context APIs and Hooks) and external libraries (Redux). There are many other tools and libraries for managing an application's global state (<strong class="bold">MobX</strong>, <strong class="bold">Recoil</strong>, <strong class="bold">XState</strong>, <strong class="bold">Unistore</strong>, to name just a few). You can use all of them inside your Next.js application by initializing them for both client-side and server-side usage, just like we did with Redux.</p>
			<p>Also, you can use Apollo GraphQL and its in-memory cache for managing your application state, gaining access to a formal query language for mutating and querying your global data.</p>
			<p>We can now create more complex and interactive web applications, managing different kinds of state with any library we want.</p>
			<p>But once you have your data well organized and ready to use, you need to display it and render your application UI depending on your application state. In the next chapter, you will see how to style your web app by configuring and using different CSS and JavaScript libraries.</p>
		</div>
	</body></html>