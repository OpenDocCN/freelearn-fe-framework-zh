<html><head></head><body>
		<div id="_idContainer179">
			<h1 id="_idParaDest-292" class="chapter-number"><a id="_idTextAnchor294"/>12</h1>
			<h1 id="_idParaDest-293"><a id="_idTextAnchor295"/>Unit Testing with Jest and React Testing Library</h1>
			<p>In this chapter, we learn how to use Jest and React Testing Library, two popular automated testing tools that can be used together in React applications. We will create tests on the checklist component we created in <a href="B19051_11.xhtml#_idTextAnchor273"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <span class="No-Break"><em class="italic">Reusable Components</em></span><span class="No-Break">.</span></p>
			<p>We will start by focusing on Jest and using it to test simple functions, learning about Jest’s common <strong class="bold">matcher</strong> functions for writing expectations, and how to execute tests to check whether <span class="No-Break">they pass.</span></p>
			<p>We will then move on to learning about component testing using React Testing Library. We’ll understand the different query types and variants and how they help us create <span class="No-Break">robust tests.</span></p>
			<p>After that, we will learn the most accurate way to simulate user interactions using a React Testing Library companion package. We will use this to create tests for items being checked in the <span class="No-Break">checklist component.</span></p>
			<p>At the end of the chapter, we will learn how to determine which code is covered by tests and, more importantly, which code is uncovered. We use Jest’s code coverage tool to do this and understand all the different coverage stats it <span class="No-Break">gives us.</span></p>
			<p>So, in this chapter, we’ll cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Testing <span class="No-Break">pure functions</span></li>
				<li><span class="No-Break">Testing components</span></li>
				<li>Simulating <span class="No-Break">user interactions</span></li>
				<li>Getting <span class="No-Break">code coverage</span></li>
			</ul>
			<h1 id="_idParaDest-294"><a id="_idTextAnchor296"/>Technical requirements</h1>
			<p>We will use the following technologies in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li><strong class="bold">Node.js</strong> and <strong class="bold">npm</strong>: You can install them <span class="No-Break">from </span><a href="https://nodejs.org/en/download/"><span class="No-Break">https://nodejs.org/en/download/</span></a></li>
				<li><strong class="bold">Visual Studio Code</strong>: You can install it <span class="No-Break">from </span><a href="https://code.visualstudio.com/"><span class="No-Break">https://code.visualstudio.com/</span></a></li>
			</ul>
			<p>We will start with a modified version of the code we finished in the last chapter. The modified code contains logic extracted into pure functions, which will be ideal to use in the first tests we write. This code can be found online <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter12/start"><span class="No-Break">https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter12/start</span></a><span class="No-Break">.</span></p>
			<p>Carry out the following steps to download this to your <span class="No-Break">local computer:</span></p>
			<ol>
				<li>Go to <a href="https://download-directory.github.io/">https://download-directory.github.io/</a> in <span class="No-Break">a browser.</span></li>
				<li>In the textbox on the web page, enter the following <span class="No-Break">URL: </span><a href="https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter12/start"><span class="No-Break">https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter12/start</span></a><span class="No-Break">.</span></li>
				<li>Press the <em class="italic">Enter</em> key. A ZIP file containing the <strong class="source-inline">start</strong> folder will now <span class="No-Break">be downloaded.</span></li>
				<li>Extract the ZIP file to a folder of your choice and open that folder in Visual <span class="No-Break">Studio Code.</span></li>
				<li>In Visual Studio Code’s terminal, execute the following command to install all <span class="No-Break">the dependencies:</span><pre class="source-code">
npm i</pre></li>
			</ol>
			<p>You are now ready to start writing tests for the <span class="No-Break">checklist component.</span></p>
			<h1 id="_idParaDest-295"><a id="_idTextAnchor297"/>Testing pure functions</h1>
			<p>In this section, we will start by understanding the fundamental parts of a Jest test. Then, we will put this into <a id="_idIndexMarker926"/>practice by implementing tests on a pure function in the <span class="No-Break">checklist component.</span></p>
			<p>A pure function has a consistent output value for a given set of parameter values. These functions depend only on the function parameters and nothing outside the function, and also don’t change any argument values passed into them. So, pure functions are nice for learning how to write tests because there are no tricky side effects to <span class="No-Break">deal with.</span></p>
			<p>In this section, we will also cover how to test exceptions, which is useful for testing type assertion functions. Finally, at the end of this section, we will learn how to run the tests in a <span class="No-Break">test suite.</span></p>
			<h2 id="_idParaDest-296"><a id="_idTextAnchor298"/>Understanding a Jest test</h2>
			<p>Jest is preinstalled in a Create React App project and configured to look for tests in files with particular extensions. These<a id="_idIndexMarker927"/> file extensions are <strong class="source-inline">.test.ts</strong> for tests on pure functions and <strong class="source-inline">.test.tsx</strong> for tests on components. Alternatively, a <strong class="source-inline">.spec.*</strong> file extension could <span class="No-Break">be used.</span></p>
			<p>A test is defined using Jest’s <span class="No-Break"><strong class="source-inline">test</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
test('your test name', () =&gt; {
  // your test implementation
});</pre>
			<p>The <strong class="source-inline">test</strong> function has two parameters for the test name and implementation. It is common practice for the test implementation to be an anonymous function. The test implementation can be asynchronous by placing the <strong class="source-inline">async</strong> keyword in front of the <span class="No-Break">anonymous function:</span></p>
			<pre class="source-code">
test('your test name', <strong class="bold">async</strong> () =&gt; {
  // your test implementation
});</pre>
			<p>The test implementation will consist of calling the function with arguments being tested and checking the result is as <span class="No-Break">we expect:</span></p>
			<pre class="source-code">
test('your test name', async () =&gt; {
<strong class="bold">  const someResult = yourFunction('someArgument');</strong>
<strong class="bold">  expect(someResult).toBe('something');</strong>
});</pre>
			<p>Jest’s <strong class="source-inline">expect</strong> function is used to define our expectations. The result of the function call is passed into <strong class="source-inline">expect</strong>, and it returns an object containing methods we can use to define specific expectations for the <a id="_idIndexMarker928"/>result. These methods are referred to as <strong class="bold">matchers</strong>. If the expectation <a id="_idIndexMarker929"/>fails, Jest will fail <span class="No-Break">the test.</span></p>
			<p>The preceding test uses the <strong class="source-inline">toBe</strong> matcher. The <strong class="source-inline">toBe</strong> matcher checks that primitive values are equal, and the preceding test uses it to check that the <strong class="source-inline">someResults</strong> variable is equal to <strong class="source-inline">"something"</strong>. Other common matchers are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">toStrictEqual</strong> for checking the values in an object or array. This recursively checks every property in the object or array. Here’s <span class="No-Break">an example:</span><pre class="source-code">
expect(someResult).<strong class="bold">toStrictEqual</strong>({</pre><pre class="source-code">
  field1: 'something',</pre><pre class="source-code">
  field2: 'something else'</pre><pre class="source-code">
});</pre></li>
				<li><strong class="source-inline">not</strong> for checking the opposite of a matcher. Here’s <span class="No-Break">an example:</span><pre class="source-code">
expect(someResult).<strong class="bold">not</strong>.toBe('something');</pre></li>
				<li><strong class="source-inline">toMatch</strong> for checking<a id="_idIndexMarker930"/> strings against <strong class="bold">regular expressions</strong> (<strong class="bold">regexes</strong>). Here’s <span class="No-Break">an example:</span><pre class="source-code">
expect(someResult).toMatch(/error/);</pre></li>
				<li><strong class="source-inline">toContain</strong> for checking if an element is in an array. Here’s <span class="No-Break">an example:</span><pre class="source-code">
expect(someResult).toContain(99);</pre></li>
			</ul>
			<p>A complete list of all the standard matchers can be found in the Jest documentation <span class="No-Break">at </span><a href="https://jestjs.io/docs/expect"><span class="No-Break">https://jestjs.io/docs/expect</span></a><span class="No-Break">.</span></p>
			<p>Now that we understand the basics of a Jest test, we will create our first <span class="No-Break">Jest test.</span></p>
			<h2 id="_idParaDest-297"><a id="_idTextAnchor299"/>Testing isChecked</h2>
			<p>The first function we will test is <strong class="source-inline">isChecked</strong>. This function<a id="_idIndexMarker931"/> has <span class="No-Break">two parameters:</span></p>
			<ul>
				<li><strong class="source-inline">checkedIds</strong>: This is an array of IDs that are <span class="No-Break">currently checked</span></li>
				<li><strong class="source-inline">idValue</strong>: This is the ID to determine whether it <span class="No-Break">is checked</span></li>
			</ul>
			<p>We will write a test for when the list item is checked and another for when it <span class="No-Break">isn’t checked:</span></p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">isChecked.test.ts</strong> in the <strong class="source-inline">src/Checklist</strong> folder that will contain <span class="No-Break">the tests.</span></li>
			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">It is best practice to place test files adjacent to the source file being tested. This allows the developers to navigate to the test for a <span class="No-Break">function quickly.</span></p>
			<ol>
				<li value="2">Open <strong class="source-inline">isChecked.test.ts</strong> and import the <span class="No-Break"><strong class="source-inline">isChecked</strong></span><span class="No-Break"> function:</span><pre class="source-code">
import { isChecked } from './isChecked';</pre></li>
				<li>Start to create the first test <span class="No-Break">as follows:</span><pre class="source-code">
test('', () =&gt; {</pre><pre class="source-code">
});</pre></li>
			</ol>
			<p>Jest puts the <strong class="source-inline">test</strong> function in the global scope, so there is no need to <span class="No-Break">import it.</span></p>
			<ol>
				<li value="4">Add the test name <span class="No-Break">as follows:</span><pre class="source-code">
test('<strong class="bold">should return true when in checkedIds</strong>', () =&gt; {</pre><pre class="source-code">
);</pre></li>
			</ol>
			<p>Forming a naming convention for test names is good practice so that they are consistent and easy to understand. Here, we have used the following <span class="No-Break">naming structure:</span></p>
			<p><strong class="bold">should {expected output / behaviour} when {input / </strong><span class="No-Break"><strong class="bold">state condition}</strong></span></p>
			<ol>
				<li value="5">Now, let’s start to implement the logic inside the test. The first step in the test is to call the function being <a id="_idIndexMarker932"/>tested with the arguments we want <span class="No-Break">to test:</span><pre class="source-code">
test('should return true when in checkedIds', () =&gt; {</pre><pre class="source-code">
  <strong class="bold">const result = isChecked([1, 2, 3], 2);</strong></pre><pre class="source-code">
});</pre></li>
				<li>The second (and last) step in the test is to check that the result is what we expect, which is <strong class="source-inline">true</strong> for <span class="No-Break">this test:</span><pre class="source-code">
test('should return true when in checkedIds', () =&gt; {</pre><pre class="source-code">
  const result = isChecked([1, 2, 3], 2);</pre><pre class="source-code">
<strong class="bold">  expect(result).toBe(true);</strong></pre><pre class="source-code">
});</pre></li>
			</ol>
			<p>Since the result is a primitive value (a Boolean), we use the <strong class="source-inline">toBe</strong> matcher to verify <span class="No-Break">the result.</span></p>
			<ol>
				<li value="7">Add a second test to cover the case when the ID isn’t in the <span class="No-Break">checked IDs:</span><pre class="source-code">
test('should return false when not in checkedIds', () =&gt; {</pre><pre class="source-code">
  const result = isChecked([1, 2, 3], 4);</pre><pre class="source-code">
  expect(result).toBe(false);</pre><pre class="source-code">
});</pre></li>
			</ol>
			<p>That completes the tests on the <strong class="source-inline">isChecked</strong> function. Next, we will learn how to test exceptions that are raised. We will check that our tests work <span class="No-Break">after that.</span></p>
			<h2 id="_idParaDest-298"><a id="_idTextAnchor300"/>Testing exceptions</h2>
			<p>We are going to test the <strong class="source-inline">assertValueCanBeRendered</strong> type assertion function. This is a little<a id="_idIndexMarker933"/> different from the last function we tested because we want to test whether an exception is raised rather than the <span class="No-Break">returned value.</span></p>
			<p>Jest has a <strong class="source-inline">toThrow</strong> matcher that can be used to check whether an exception has been raised. For this to catch exceptions, the function being tested has to be executed inside the expectation, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
test('some test', () =&gt; {
  expect(<strong class="bold">() =&gt; {</strong>
<strong class="bold">    someAssertionFunction(someValue);</strong>
<strong class="bold">  }</strong>).<strong class="bold">toThrow('some error message')</strong>;
});</pre>
			<p>We will use this approach to add three tests on the <strong class="source-inline">assertValueCanBeRendered</strong> type assertion function. Carry out the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">assertValueCanBeRendered.test.ts</strong> in the <strong class="source-inline">src/Checklist</strong> folder for the tests and import the <strong class="source-inline">assertValueCanBeRendered</strong> type <span class="No-Break">assertion function:</span><pre class="source-code">
import { assertValueCanBeRendered } from './assertValueCanBeRendered';</pre></li>
				<li>The first test we will add is to check whether an exception is raised when the value isn’t a string <span class="No-Break">or number:</span><pre class="source-code">
test('should raise exception when not a string or number', () =&gt; {</pre><pre class="source-code">
  expect(() =&gt; {</pre><pre class="source-code">
    assertValueCanBeRendered(</pre><pre class="source-code">
      true</pre><pre class="source-code">
    );</pre><pre class="source-code">
  }).toThrow(</pre><pre class="source-code">
    'value is not a string or a number'</pre><pre class="source-code">
  );</pre><pre class="source-code">
});</pre></li>
			</ol>
			<p>We pass the <strong class="source-inline">true</strong> Boolean value, which should cause <span class="No-Break">an error.</span></p>
			<ol>
				<li value="3">Next, we will test whether an<a id="_idIndexMarker934"/> exception isn’t raised when the value is <span class="No-Break">a string:</span><pre class="source-code">
test('should not raise exception when string', () =&gt; {</pre><pre class="source-code">
  expect(() =&gt; {</pre><pre class="source-code">
    assertValueCanBeRendered(</pre><pre class="source-code">
      'something'</pre><pre class="source-code">
    );</pre><pre class="source-code">
  }).not.toThrow();</pre><pre class="source-code">
});</pre></li>
			</ol>
			<p>We use the <strong class="source-inline">not</strong> matcher with <strong class="source-inline">toThrow</strong> to check that an exception is <span class="No-Break">not raised.</span></p>
			<ol>
				<li value="4">The last test will test an exception isn’t raised when the value is <span class="No-Break">a number:</span><pre class="source-code">
test('should not raise exception when number', () =&gt; {</pre><pre class="source-code">
  expect(() =&gt; {</pre><pre class="source-code">
    assertValueCanBeRendered(</pre><pre class="source-code">
      99</pre><pre class="source-code">
    );</pre><pre class="source-code">
  }).not.toThrow();</pre><pre class="source-code">
});</pre></li>
			</ol>
			<p>That completes the tests for the <strong class="source-inline">assertValueCanBeRendered</strong> type <span class="No-Break">assertion function.</span></p>
			<p>Now that we have<a id="_idIndexMarker935"/> implemented some tests, we will learn how to run <span class="No-Break">them next.</span></p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor301"/>Running tests</h2>
			<p>Create React App has an <a id="_idIndexMarker936"/>npm script called <strong class="source-inline">test</strong> that runs the tests. After the tests are run, a watcher will rerun the tests when the source code or test <span class="No-Break">code changes.</span></p>
			<p>Carry out the following steps to run all the tests and experiment with the test <span class="No-Break">watcher options:</span></p>
			<ol>
				<li value="1">Open the terminal and execute the <span class="No-Break">following command:</span><pre class="source-code">
npm run test</pre></li>
			</ol>
			<p><strong class="source-inline">test</strong> is a very common npm script, so the <strong class="source-inline">run</strong> keyword can be omitted. In addition, <strong class="source-inline">test</strong> can be shortened to <strong class="source-inline">t</strong>. So, a shortened version of the previous command is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
npm t</pre>
			<p>The tests will be run, and the following summary will appear in <span class="No-Break">the terminal:</span></p>
			<div>
				<div id="_idContainer165" class="IMG---Figure">
					<img src="image/B19051_12_01.jpg" alt="Figure 12.1 – First test run"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – First test run</p>
			<p>Notice that there is no Command Prompt in the terminal like there usually is after a command has finished executing. This is because the command hasn’t fully completed as the test watcher is<a id="_idIndexMarker937"/> running—this is called <strong class="bold">watch mode</strong>. The command won’t complete until watch mode is exited using the <em class="italic">q</em> key. Leave the terminal in watch mode and carry on to the <span class="No-Break">next step.</span></p>
			<ol>
				<li value="2">All the tests pass<a id="_idIndexMarker938"/> at the moment. Now, we will deliberately make a test fail so that we can see the information Jest provides us. So, open <strong class="source-inline">assertValueCanBeRendered.ts</strong> and change the expected error message on the first test <span class="No-Break">as follows:</span><pre class="source-code">
test('should raise exception when not a string or number', () =&gt; {</pre><pre class="source-code">
  expect(() =&gt; {</pre><pre class="source-code">
    assertValueCanBeRendered(true);</pre><pre class="source-code">
  }).toThrow('value is not a string or a number<strong class="bold">X</strong>');</pre><pre class="source-code">
});</pre></li>
			</ol>
			<p>As soon as the test file is saved, the tests are rerun, and a failing test is reported <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer166" class="IMG---Figure">
					<img src="image/B19051_12_02.jpg" alt="Figure 12.2 – Failing test"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Failing test</p>
			<p>Jest provides valuable information about the failure that helps us quickly resolve test failures. It tells <span class="No-Break">us this:</span></p>
			<ul>
				<li>Which <span class="No-Break">test failed</span></li>
				<li>What the expected result was, in comparison to the <span class="No-Break">actual result</span></li>
				<li>The line in our code where the <span class="No-Break">failure occurred</span></li>
			</ul>
			<p>Resolve the test failure by reverting the test to check for the correct error message. The test<a id="_idIndexMarker939"/> should be as <span class="No-Break">follows now:</span></p>
			<pre class="source-code">
test('should raise exception when not a string or number', () =&gt; {
  expect(() =&gt; {
    assertValueCanBeRendered(true);
  }).toThrow('value is not a string or a number');
});</pre>
			<ol>
				<li value="3">We will now start to explore some of the options on the test watcher. Press the <em class="italic">w</em> key in the terminal, where the test watcher is still running. The test watcher options will be listed <span class="No-Break">as follows:</span></li>
			</ol>
			<div>
				<div id="_idContainer167" class="IMG---Figure">
					<img src="image/B19051_12_03.jpg" alt="Figure 12.3 – Test watcher options"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Test watcher options</p>
			<ol>
				<li value="4">We can filter the test files that Jest executes by using the <em class="italic">p</em> watch option. Press the <em class="italic">p</em> key and enter <strong class="source-inline">isChecked</strong> when prompted for the pattern. The pattern can be any regex. Jest will search for test files that match the regex pattern and execute them. So, Jest runs the tests in <strong class="source-inline">isChecked.test.ts</strong> in our <span class="No-Break">test suite:</span></li>
			</ol>
			<div>
				<div id="_idContainer168" class="IMG---Figure">
					<img src="image/B19051_12_04.jpg" alt="Figure 12.4 – Jest running a test file checking for a matching pattern"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – Jest running a test file checking for a matching pattern</p>
			<ol>
				<li value="5">To clear the filename filter, press the <span class="No-Break"><em class="italic">c</em></span><span class="No-Break"> key.</span></li>
				<li>We can also filter the<a id="_idIndexMarker940"/> tests that Jest executes by the test name using the <em class="italic">t</em> watch option. Press <em class="italic">t</em> and enter <strong class="source-inline">should return false when not in checkedIds</strong> when prompted for the test name. Jest will search for test names that match the regex pattern and execute them. So, Jest runs the <strong class="source-inline">should return false when not in checkedIds</strong> test in our <span class="No-Break">test suite:</span></li>
			</ol>
			<div>
				<div id="_idContainer169" class="IMG---Figure">
					<img src="image/B19051_12_05.jpg" alt="Figure 12.5 – Jest running test name matching a pattern"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – Jest running test name matching a pattern</p>
			<ol>
				<li value="7">Press the <em class="italic">c</em> key to clear the test name filter and then press the <em class="italic">q</em> key to exit the <span class="No-Break">test watcher.</span></li>
			</ol>
			<p>That completes our exploration of running Jest tests and this section on testing pure functions. Here’s a quick recap of the <span class="No-Break">key points:</span></p>
			<ul>
				<li>Tests are defined using Jest’s <span class="No-Break"><strong class="source-inline">test</strong></span><span class="No-Break"> function.</span></li>
				<li>Expectations within the test are defined using Jest’s <strong class="source-inline">expect</strong> function in combination with one or <span class="No-Break">more matchers.</span></li>
				<li>The <strong class="source-inline">expect</strong> function argument can be a function that executes the function being tested. This is useful for testing exceptions with the <span class="No-Break"><strong class="source-inline">toThrow</strong></span><span class="No-Break"> matcher.</span></li>
				<li>Jest’s test runner has a<a id="_idIndexMarker941"/> comprehensive set of options for running tests. The test watcher is particularly useful on large code bases because it only runs tests impacted by changes <span class="No-Break">by default.</span></li>
			</ul>
			<p>Next, we will learn how to test <span class="No-Break">React components.</span></p>
			<h1 id="_idParaDest-300"><a id="_idTextAnchor302"/>Testing components</h1>
			<p>Testing components is important <a id="_idIndexMarker942"/>because this is what the user interacts with. Having automated tests on components gives us confidence that the app is working correctly and helps prevent regressions when we <span class="No-Break">change code.</span></p>
			<p>In this section, we will learn how to test components with Jest and React Testing Library. Then, we will create some tests on the checklist component we developed in the <span class="No-Break">last chapter.</span></p>
			<h2 id="_idParaDest-301"><a id="_idTextAnchor303"/>Understanding React Testing Library</h2>
			<p>React Testing Library is a popular <a id="_idIndexMarker943"/>companion library for testing React components. It provides functions to render components and then select internal elements. Those internal elements can then be checked using special matchers provided by another companion library <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">jest-dom</strong></span><span class="No-Break">.</span></p>
			<h3>A basic component test</h3>
			<p>Here’s an example of a <a id="_idIndexMarker944"/><span class="No-Break">component test:</span></p>
			<pre class="source-code">
test('should render heading when content specified', () =&gt; {
  render(&lt;Heading&gt;Some heading&lt;/Heading&gt;);
  const heading = screen.getByText('Some heading');
  expect(heading).toBeInTheDocument();
});</pre>
			<p>Let’s explain <span class="No-Break">the test:</span></p>
			<ul>
				<li>React Testing Library’s <strong class="source-inline">render</strong> function renders the component we want to test. We pass in all the appropriate attributes and content so that the component is in the required state for the checks. In this test, we have specified some text in <span class="No-Break">the content.</span></li>
				<li>The next line selects an internal element of the component. There are lots of methods on React Testing Library’s <strong class="source-inline">screen</strong> object that allow the selection of elements. These methods<a id="_idIndexMarker945"/> are referred to as <strong class="bold">queries</strong>. <strong class="source-inline">getByText</strong> selects an element by matching the text content specified. In this test, an element with <strong class="source-inline">Some heading</strong> text content will be selected and assigned to the <span class="No-Break"><strong class="source-inline">heading</strong></span><span class="No-Break"> variable.</span></li>
				<li>The last line in the test is the expectation. The <strong class="source-inline">toBeInTheDocument</strong> matcher is a special matcher from <strong class="source-inline">jest-dom</strong> that checks whether the element in the expectation is in <span class="No-Break">the DOM.</span></li>
			</ul>
			<h3>Understanding queries</h3>
			<p>A React Testing Library query<a id="_idIndexMarker946"/> is a method that selects a DOM element within the component being rendered. There are many different queries that find the element in <span class="No-Break">different ways:</span></p>
			<ul>
				<li><strong class="source-inline">ByRole</strong>: Queries elements by <span class="No-Break">their role.</span></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">DOM elements have a <strong class="source-inline">role</strong> attribute that allows assistive technologies such as screen readers to understand what they are. Many DOM elements have this attribute preset—for example, the <strong class="source-inline">button</strong> element automatically has the role of <strong class="source-inline">'button'</strong>. For more information on roles, <span class="No-Break">see </span><a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles</span></a><span class="No-Break">.</span></p>
			<ul>
				<li><strong class="source-inline">ByLabelText</strong>: Queries elements by their associated label. See this page in the React Testing Library documentation for the different ways elements can be associated with a <span class="No-Break">label: </span><a href="https://testing-library.com/docs/queries/bylabeltext"><span class="No-Break">https://testing-library.com/docs/queries/bylabeltext</span></a><span class="No-Break">.</span></li>
				<li><strong class="source-inline">ByPlaceholderText</strong>: Queries elements by their <span class="No-Break">placeholder text.</span></li>
				<li><strong class="source-inline">ByText</strong>: Queries elements by their <span class="No-Break">text content.</span></li>
				<li><strong class="source-inline">ByDisplayValue</strong>: Queries <strong class="source-inline">input</strong>, <strong class="source-inline">textarea</strong>, and <strong class="source-inline">select</strong> elements by <span class="No-Break">their value.</span></li>
				<li><strong class="source-inline">ByAltText</strong>: Queries <strong class="source-inline">img</strong> elements by their <span class="No-Break"><strong class="source-inline">alt</strong></span><span class="No-Break"> attribute.</span></li>
				<li><strong class="source-inline">ByTitle</strong>: Queries <a id="_idIndexMarker947"/>elements by their <span class="No-Break"><strong class="source-inline">title</strong></span><span class="No-Break"> attribute.</span></li>
				<li><strong class="source-inline">ByTestId</strong>: Queries elements by their test ID (the <span class="No-Break"><strong class="source-inline">data-testid</strong></span><span class="No-Break"> attribute).</span></li>
			</ul>
			<p>There are also different types of queries that behave slightly differently on the found element. Each query type has a particular prefix on the query <span class="No-Break">method name:</span></p>
			<ul>
				<li><strong class="source-inline">getBy</strong>: Throws an error if a single element is not found. This is ideal for synchronously getting a <span class="No-Break">single element.</span></li>
				<li><strong class="source-inline">getAllBy</strong>: Throws an error if at least one element is not found. This is ideal for synchronously getting <span class="No-Break">multiple elements.</span></li>
				<li><strong class="source-inline">findBy</strong>: Throws an error if a single element is not found. The check for an element is repeated for a certain amount of time (1 second by default). So, this is ideal for asynchronously getting a single element that might not be immediately in <span class="No-Break">the DOM.</span></li>
				<li><strong class="source-inline">findAllBy</strong>: Throws an error if at least one element is not found within a certain time (1 second by default). This is ideal for asynchronously getting multiple elements that might not be immediately in <span class="No-Break">the DOM.</span></li>
				<li><strong class="source-inline">queryBy</strong>: This returns <strong class="source-inline">null</strong> if an element is not found. This is ideal for checking that an element does <span class="No-Break"><em class="italic">not</em></span><span class="No-Break"> exist.</span></li>
				<li><strong class="source-inline">queryAllBy</strong>: This is the same as <strong class="source-inline">queryBy</strong>, but returns an array of elements. This is ideal for checking multiple elements do <span class="No-Break"><em class="italic">not</em></span><span class="No-Break"> exist.</span></li>
			</ul>
			<p>So, the <strong class="source-inline">getByText</strong> query we used in<a id="_idIndexMarker948"/> the preceding test finds the element by the text content specified and raises an error if no elements <span class="No-Break">are found.</span></p>
			<p>For more information on queries, see<a id="_idIndexMarker949"/> the following page in the React Testing Library <span class="No-Break">documentation: </span><a href="https://testing-library.com/docs/queries/about/"><span class="No-Break">https://testing-library.com/docs/queries/about/</span></a><span class="No-Break">.</span></p>
			<p>Notice that none of these queries references implementation details such as an element name, ID, or CSS class. If those implementation details change due to code refactoring, the tests shouldn’t break, which is precisely what <span class="No-Break">we want.</span></p>
			<p>Now that we understand React Testing Library, we will use it to write our first <span class="No-Break">component test.</span></p>
			<h2 id="_idParaDest-302"><a id="_idTextAnchor304"/>Implementing checklist component tests</h2>
			<p>The first component test we <a id="_idIndexMarker950"/>will write is to check that list items are rendered correctly. The second component test will check list items are rendered correctly when <span class="No-Break">custom rendered.</span></p>
			<p>React Testing Library and <strong class="source-inline">jest-dom</strong> are preinstalled in a Create React App project, which means we can get straight to writing the test. Carry out the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">Create a new file in the <strong class="source-inline">src/Checklist</strong> folder called <strong class="source-inline">Checklist.test.tsx</strong> and add the following <span class="No-Break">import statements:</span><pre class="source-code">
import { render, screen } from '@testing-library/react';</pre><pre class="source-code">
import { Checklist } from './Checklist';</pre></li>
				<li>Start to create the test <span class="No-Break">as follows:</span><pre class="source-code">
test('should render correct list items when data specified', () =&gt; {</pre><pre class="source-code">
});</pre></li>
				<li>In the test, render <strong class="source-inline">Checklist</strong> with <span class="No-Break">some </span><span class="No-Break"><a id="_idIndexMarker951"/></span><span class="No-Break">data:</span><pre class="source-code">
test('should render correct list items when data specified', () =&gt; {</pre><pre class="source-code">
  <strong class="bold">render(</strong></pre><pre class="source-code">
<strong class="bold">    &lt;Checklist</strong></pre><pre class="source-code">
<strong class="bold">      data={[{ id: 1, name: 'Lucy', role: 'Manager' }]}</strong></pre><pre class="source-code">
<strong class="bold">      id="id"</strong></pre><pre class="source-code">
<strong class="bold">      primary="name"</strong></pre><pre class="source-code">
<strong class="bold">      secondary="role"</strong></pre><pre class="source-code">
<strong class="bold">    /&gt;</strong></pre><pre class="source-code">
<strong class="bold">  );</strong></pre><pre class="source-code">
});</pre></li>
			</ol>
			<p>We’ve rendered a single list item that should have primary text <strong class="source-inline">Lucy</strong> and secondary <span class="No-Break">text </span><span class="No-Break"><strong class="source-inline">Manager</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="4">Let’s check <strong class="source-inline">Lucy</strong> has <span class="No-Break">been rendered:</span><pre class="source-code">
test('should render correct list items when data specified', () =&gt; {</pre><pre class="source-code">
  render(</pre><pre class="source-code">
    &lt;Checklist</pre><pre class="source-code">
      data={[{ id: 1, name: 'Lucy', role: 'Manager' }]}</pre><pre class="source-code">
      id="id"</pre><pre class="source-code">
      primary="name"</pre><pre class="source-code">
      secondary="role"</pre><pre class="source-code">
    /&gt;</pre><pre class="source-code">
  );</pre><pre class="source-code">
<strong class="bold">  expect(screen.getByText('Lucy')).toBeInTheDocument();</strong></pre><pre class="source-code">
});</pre></li>
			</ol>
			<p>We have selected the element using the <strong class="source-inline">getByText</strong> query and fed that directly into the expectation. We use the <strong class="source-inline">toBeInTheDocument</strong> matcher to check that the found <a id="_idIndexMarker952"/>element is in <span class="No-Break">the DOM.</span></p>
			<ol>
				<li value="5">Complete the test by adding a similar expectation for checking <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">Manager</strong></span><span class="No-Break">:</span><pre class="source-code">
test('should render correct list items when data specified', () =&gt; {</pre><pre class="source-code">
  render(</pre><pre class="source-code">
    &lt;Checklist</pre><pre class="source-code">
      data={[{ id: 1, name: 'Lucy', role: 'Manager' }]}</pre><pre class="source-code">
      id="id"</pre><pre class="source-code">
      primary="name"</pre><pre class="source-code">
      secondary="role"</pre><pre class="source-code">
    /&gt;</pre><pre class="source-code">
  );</pre><pre class="source-code">
  expect(screen.getByText('Lucy')).toBeInTheDocument();</pre><pre class="source-code">
<strong class="bold">  expect(screen.getByText('Manager')).    toBeInTheDocument();</strong></pre><pre class="source-code">
});</pre></li>
			</ol>
			<p>That completes our first <span class="No-Break">component test.</span></p>
			<ol>
				<li value="6">We will add the<a id="_idIndexMarker953"/> second test in one go, <span class="No-Break">as follows:</span><pre class="source-code">
test('should render correct list items when renderItem specified', () =&gt; {</pre><pre class="source-code">
  render(</pre><pre class="source-code">
    &lt;Checklist</pre><pre class="source-code">
      data={[{ id: 1, name: 'Lucy', role: 'Manager' }]}</pre><pre class="source-code">
      id="id"</pre><pre class="source-code">
      primary="name"</pre><pre class="source-code">
      secondary="role"</pre><pre class="source-code">
      renderItem={(item) =&gt; (</pre><pre class="source-code">
        &lt;li key={item.id}&gt;</pre><pre class="source-code">
          {item.name}-{item.role}</pre><pre class="source-code">
        &lt;/li&gt;</pre><pre class="source-code">
      )}</pre><pre class="source-code">
    /&gt;</pre><pre class="source-code">
  );</pre><pre class="source-code">
  expect(</pre><pre class="source-code">
    screen.getByText('Lucy-Manager')</pre><pre class="source-code">
  ).toBeInTheDocument();</pre><pre class="source-code">
});</pre></li>
			</ol>
			<p>We render a single list item with the same data as the previous test. However, this test custom renders the list items with a hyphen between the name and role. We use the same <strong class="source-inline">getByText</strong> query to check that the list item with the correct text is found in <span class="No-Break">the DOM.</span></p>
			<ol>
				<li value="7">If the tests aren’t automatically<a id="_idIndexMarker954"/> running, run them by running <strong class="source-inline">npm test</strong> in the terminal. Use the <em class="italic">p</em> option to run these two new tests—they should <span class="No-Break">both pass:</span></li>
			</ol>
			<div>
				<div id="_idContainer170" class="IMG---Figure">
					<img src="image/B19051_12_06.jpg" alt="Figure 12.6 – Component tests passing"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6 – Component tests passing</p>
			<p>That completes our first two component tests. See how easy React Testing Library <span class="No-Break">makes this!</span></p>
			<h2 id="_idParaDest-303"><a id="_idTextAnchor305"/>Using test IDs</h2>
			<p>The next test we will implement is to<a id="_idIndexMarker955"/> check that a list item is checked when specified. This test will be slightly trickier and requires a test ID on the checkboxes. Carry out the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">Start by opening <strong class="source-inline">Checklist.tsx</strong> and notice the following test ID on the <span class="No-Break"><strong class="source-inline">input</strong></span><span class="No-Break"> element:</span><pre class="source-code">
&lt;input</pre><pre class="source-code">
  ...</pre><pre class="source-code">
  <strong class="bold">data-testid={`Checklist__input__${idValue.toString()}`}</strong></pre><pre class="source-code">
/&gt;</pre></li>
			</ol>
			<p>Test IDs are added to elements using a <strong class="source-inline">data-testid</strong> attribute. We can concatenate the list item ID so that the test ID is unique for each <span class="No-Break">list item.</span></p>
			<ol>
				<li value="2">Now, return <a id="_idIndexMarker956"/>to the <strong class="source-inline">Checklist.test.tsx</strong> file and begin to write <span class="No-Break">the test:</span><pre class="source-code">
test('should render correct checked items when specified', () =&gt; {</pre><pre class="source-code">
  render(</pre><pre class="source-code">
    &lt;Checklist</pre><pre class="source-code">
      data={[{ id: 1, name: 'Lucy', role: 'Manager' }]}</pre><pre class="source-code">
      id="id"</pre><pre class="source-code">
      primary="name"</pre><pre class="source-code">
      secondary="role"</pre><pre class="source-code">
      checkedIds={[1]}</pre><pre class="source-code">
    /&gt;</pre><pre class="source-code">
  );</pre><pre class="source-code">
});</pre></li>
			</ol>
			<p>We have rendered the checklist with the same data as the previous tests. However, we have specified that the list item is checked using the <span class="No-Break"><strong class="source-inline">checkedIds</strong></span><span class="No-Break"> prop.</span></p>
			<ol>
				<li value="3">Now, on to the expectation for <span class="No-Break">the test:</span><pre class="source-code">
test('should render correct checked items when specified', () =&gt; {</pre><pre class="source-code">
  render(</pre><pre class="source-code">
    &lt;Checklist</pre><pre class="source-code">
      data={[{ id: 1, name: 'Lucy', role: 'Manager' }]}</pre><pre class="source-code">
      id="id"</pre><pre class="source-code">
      primary="name"</pre><pre class="source-code">
      secondary="role"</pre><pre class="source-code">
      checkedIds={[1]}</pre><pre class="source-code">
    /&gt;</pre><pre class="source-code">
  );</pre><pre class="source-code">
<strong class="bold">  expect(</strong></pre><pre class="source-code">
<strong class="bold">    screen.getByTestId('Checklist__input__1')</strong></pre><pre class="source-code">
<strong class="bold">  ).toBeChecked();</strong></pre><pre class="source-code">
});</pre></li>
			</ol>
			<p>We select the checkbox by its test ID using the <strong class="source-inline">getByTestId</strong> query. We then use the <strong class="source-inline">toBeChecked</strong> matcher <a id="_idIndexMarker957"/>to verify the checkbox is checked. <strong class="source-inline">toBeChecked</strong> is another special matcher from the <span class="No-Break"><strong class="source-inline">jest-dom</strong></span><span class="No-Break"> package.</span></p>
			<p>This new test should pass, leaving us with three passing tests <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">Checklist</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer171" class="IMG---Figure">
					<img src="image/B19051_12_07.jpg" alt="Figure 12.7 – All three component tests passing"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7 – All three component tests passing</p>
			<ol>
				<li value="4">Stop the test runner by pressing the <span class="No-Break"><em class="italic">q</em></span><span class="No-Break"> key.</span></li>
			</ol>
			<p>That completes this section on testing components. Here’s a <span class="No-Break">quick recap:</span></p>
			<ul>
				<li>React Testing Library contains lots of useful queries for selecting DOM elements. Different query types will find single or many elements and will or won’t error if an element isn’t found. There<a id="_idIndexMarker958"/> is even a query type for repeatedly searching for elements <span class="No-Break">rendered asynchronously.</span></li>
				<li><strong class="source-inline">jest-dom</strong> contains lots of useful matchers for checking DOM elements. A common matcher is <strong class="source-inline">toBeInTheDocument</strong>, which verifies an element is in the DOM. However, <strong class="source-inline">jest-dom</strong> contains many other useful matchers, such as <strong class="source-inline">toBeChecked</strong> for checking whether an element is checked <span class="No-Break">or not.</span></li>
			</ul>
			<p>Next, we will learn how to simulate user interactions <span class="No-Break">in tests.</span></p>
			<h1 id="_idParaDest-304"><a id="_idTextAnchor306"/>Simulating user interactions</h1>
			<p>So far, our tests have simply<a id="_idIndexMarker959"/> rendered the checklist component with various props set. Users can interact with the checklist component by checking and unchecking items. In this section, we will first learn how to simulate user interactions in tests. We will then use this knowledge to test whether list items are checked when clicked and that <strong class="source-inline">onCheckedIdsChange</strong> <span class="No-Break">is raised.</span></p>
			<h2 id="_idParaDest-305"><a id="_idTextAnchor307"/>Understanding fireEvent and user-event</h2>
			<p>React Testing Library<a id="_idIndexMarker960"/> has a <strong class="source-inline">fireEvent</strong> function that <a id="_idIndexMarker961"/>can raise events on DOM elements. The following example raises a <strong class="source-inline">click</strong> event on a <span class="No-Break"><strong class="bold">Save</strong></span><span class="No-Break"> button:</span></p>
			<pre class="source-code">
render(&lt;button&gt;Save&lt;/button&gt;);
<strong class="bold">fireEvent.click(screen.getByText('Save'));</strong></pre>
			<p>This is okay, but what if logic was implemented using a <strong class="source-inline">mousedown</strong> event rather than <strong class="source-inline">click</strong>? The test would then need to be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
render(&lt;button&gt;Save&lt;/button&gt;);
<strong class="bold">fireEvent.mouseDown(screen.getByText('Save'));</strong></pre>
			<p>Fortunately, there is an alternative approach to performing user interactions in tests. The alternative approach is to use the <strong class="source-inline">user-event</strong> package, which is a React Testing Library companion package that simulates user interactions rather than specific events. The same test <a id="_idIndexMarker962"/>using <strong class="source-inline">user-event</strong> looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
<strong class="bold">const user = userEvent.setup();</strong>
render(&lt;button&gt;Save&lt;/button&gt;);
<strong class="bold">await user.click(screen.getByText('Save'));</strong></pre>
			<p>The test would cover logic implemented using a <strong class="source-inline">click</strong> event or <strong class="source-inline">mousedown</strong> event. So, it is less coupled to implementation details, which is good. For this reason, we’ll use the <strong class="source-inline">user-event</strong> package to write interactive tests on our <span class="No-Break">checklist component.</span></p>
			<p>The <strong class="source-inline">user-event</strong> package can simulate interactions other than clicks. See the documentation at the following link for more <span class="No-Break">information: </span><a href="https://testing-library.com/docs/user-event/intro"><span class="No-Break">https://testing-library.com/docs/user-event/intro</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-306"><a id="_idTextAnchor308"/>Implementing checklist tests for checking items</h2>
			<p>We will now write two interactive tests <a id="_idIndexMarker963"/>on the checklist component. The first test will check items are checked when clicked. The <a id="_idIndexMarker964"/>second test will check <strong class="source-inline">onCheckedIdsChange</strong> is called when items are clicked. Carry out the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">Create React App does preinstall the <strong class="source-inline">user-event</strong> package, but it may be a version before version 14, which has a different API. Open <strong class="source-inline">package.json</strong>, and then find the <strong class="source-inline">@testing-library/user-event</strong> dependency and check the version. If the version isn’t 14 or above, then run the following command in the terminal to <span class="No-Break">update it:</span><pre class="source-code">
npm i @testing-library/user-event@latest</pre></li>
				<li>We will add the interactive tests in the same test file as the other component tests. So, open <strong class="source-inline">Checklist.test.tsx</strong> and add an import statement <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">user-event</strong></span><span class="No-Break">:</span><pre class="source-code">
import userEvent from '@testing-library/user-event';</pre></li>
				<li>The first test will test that items are checked when clicked. Start to implement this <span class="No-Break">as follows:</span><pre class="source-code">
test('should check items when clicked', async () =&gt; {</pre><pre class="source-code">
});</pre></li>
			</ol>
			<p>We have marked the test as asynchronous because the simulated user interactions in <strong class="source-inline">user-event</strong> <span class="No-Break">are asynchronous.</span></p>
			<ol>
				<li value="4">Next, initialize the<a id="_idIndexMarker965"/> user simulation <span class="No-Break">as follows:</span><pre class="source-code">
test('should check items when clicked', async () =&gt; {</pre><pre class="source-code">
  <strong class="bold">const user = userEvent.setup();</strong></pre><pre class="source-code">
});</pre></li>
				<li>We can now render a list item as <a id="_idIndexMarker966"/>we have done in previous tests. We will also get a reference to the checkbox in the rendered list item and check that it <span class="No-Break">isn’t checked:</span><pre class="source-code">
test('should check items when clicked', async () =&gt; {</pre><pre class="source-code">
  const user = userEvent.setup();</pre><pre class="source-code">
  <strong class="bold">render(</strong></pre><pre class="source-code">
<strong class="bold">    &lt;Checklist</strong></pre><pre class="source-code">
<strong class="bold">      data={[{ id: 1, name: 'Lucy', role: 'Manager' }]}</strong></pre><pre class="source-code">
<strong class="bold">      id="id"</strong></pre><pre class="source-code">
<strong class="bold">      primary="name"</strong></pre><pre class="source-code">
<strong class="bold">      secondary="role"</strong></pre><pre class="source-code">
<strong class="bold">    /&gt;</strong></pre><pre class="source-code">
<strong class="bold">  );</strong></pre><pre class="source-code">
<strong class="bold">  const lucyCheckbox = screen.getByTestId(</strong></pre><pre class="source-code">
<strong class="bold">    'Checklist__input__1'</strong></pre><pre class="source-code">
<strong class="bold">  );</strong></pre><pre class="source-code">
<strong class="bold">  expect(lucyCheckbox).not.toBeChecked();</strong></pre><pre class="source-code">
});</pre></li>
				<li>Now, on to the user interaction. Simulate<a id="_idIndexMarker967"/> the user clicking the list item by calling the <strong class="source-inline">click</strong> method on the <strong class="source-inline">user</strong> object; the checkbox to be clicked needs to be<a id="_idIndexMarker968"/> passed into the <span class="No-Break"><strong class="source-inline">click</strong></span><span class="No-Break"> argument:</span><pre class="source-code">
test('should check items when clicked', async () =&gt; {</pre><pre class="source-code">
  const user = userEvent.setup();</pre><pre class="source-code">
  render(</pre><pre class="source-code">
    &lt;Checklist</pre><pre class="source-code">
      data={[{ id: 1, name: 'Lucy', role: 'Manager' }]}</pre><pre class="source-code">
      id="id"</pre><pre class="source-code">
      primary="name"</pre><pre class="source-code">
      secondary="role"</pre><pre class="source-code">
    /&gt;</pre><pre class="source-code">
  );</pre><pre class="source-code">
  const lucyCheckbox = screen.getByTestId(</pre><pre class="source-code">
    'Checklist__input__1'</pre><pre class="source-code">
  );</pre><pre class="source-code">
  expect(lucyCheckbox).not.toBeChecked();</pre><pre class="source-code">
  <strong class="bold">await user.click(lucyCheckbox);</strong></pre><pre class="source-code">
});</pre></li>
				<li>The last step<a id="_idIndexMarker969"/> in the test is to <a id="_idIndexMarker970"/>check that the checkbox is <span class="No-Break">now checked:</span><pre class="source-code">
test('should check items when clicked', async () =&gt; {</pre><pre class="source-code">
  const user = userEvent.setup();</pre><pre class="source-code">
  render(</pre><pre class="source-code">
    &lt;Checklist</pre><pre class="source-code">
      data={[{ id: 1, name: 'Lucy', role: 'Manager' }]}</pre><pre class="source-code">
      id="id"</pre><pre class="source-code">
      primary="name"</pre><pre class="source-code">
      secondary="role"</pre><pre class="source-code">
    /&gt;</pre><pre class="source-code">
  );</pre><pre class="source-code">
  const lucyCheckbox = screen.getByTestId(</pre><pre class="source-code">
    'Checklist__input__1'</pre><pre class="source-code">
  );</pre><pre class="source-code">
  expect(lucyCheckbox).not.toBeChecked();</pre><pre class="source-code">
  await user.click(lucyCheckbox);</pre><pre class="source-code">
<strong class="bold">  expect(lucyCheckbox).toBeChecked();</strong></pre><pre class="source-code">
});</pre></li>
				<li>The next test will test that the function assigned to the <strong class="source-inline">onCheckedIdsChange</strong> prop is called when a list item is clicked. Here is <span class="No-Break">the test:</span><pre class="source-code">
test('should call onCheckedIdsChange when clicked', async () =&gt; {</pre><pre class="source-code">
  const user = userEvent.setup();</pre><pre class="source-code">
  let calledWith: IdValue[] | undefined = undefined;</pre><pre class="source-code">
  render(</pre><pre class="source-code">
    &lt;Checklist</pre><pre class="source-code">
      data={[{ id: 1, name: 'Lucy', role: 'Manager' }]}</pre><pre class="source-code">
      id="id"</pre><pre class="source-code">
      primary="name"</pre><pre class="source-code">
      secondary="role"</pre><pre class="source-code">
      onCheckedIdsChange={(checkedIds) =&gt;</pre><pre class="source-code">
        (calledWith = checkedIds)</pre><pre class="source-code">
      }</pre><pre class="source-code">
    /&gt;</pre><pre class="source-code">
  );</pre><pre class="source-code">
  await user.click(screen.getByTestId('Checklist__input__1'));</pre><pre class="source-code">
  expect(calledWith).toStrictEqual([1]);</pre><pre class="source-code">
});</pre></li>
			</ol>
			<p>We set a <strong class="source-inline">calledWith</strong> variable to<a id="_idIndexMarker971"/> the value of the <strong class="source-inline">onCheckedIdsChange</strong> parameter. After the list item is clicked, we check the value of the <strong class="source-inline">calledWith</strong> variable<a id="_idIndexMarker972"/> using the <strong class="source-inline">toStrictEqual</strong> matcher. The <strong class="source-inline">toStrictEqual</strong> matcher is a standard Jest matcher that is ideal for checking arrays <span class="No-Break">and objects.</span></p>
			<ol>
				<li value="9">The second test references the <strong class="source-inline">IdValue</strong> type, so add an import statement <span class="No-Break">for this:</span><pre class="source-code">
import { IdValue } from './types';</pre></li>
				<li>Run the tests by running <strong class="source-inline">npm test</strong> in the<a id="_idIndexMarker973"/> terminal. Press the <em class="italic">p</em> key to run all the tests in the <strong class="source-inline">Checklist.test.tsx</strong> file. We should now have five passing<a id="_idIndexMarker974"/> <span class="No-Break">component tests:</span></li>
			</ol>
			<div>
				<div id="_idContainer172" class="IMG---Figure">
					<img src="image/B19051_12_08.jpg" alt="Figure 12.8 – Five passing component tests"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.8 – Five passing component tests</p>
			<ol>
				<li value="11">Stop the test runner by pressing the <span class="No-Break"><em class="italic">q</em></span><span class="No-Break"> key.</span></li>
			</ol>
			<p>That completes the tests for clicking items and this section on simulating user interactions. We learned that React Testing Library’s <strong class="source-inline">fireAction</strong> function raises a particular event that couples tests to implementation details. A better approach is to use the <strong class="source-inline">user-event</strong> package to simulate user interactions, potentially raising several events in <span class="No-Break">the process.</span></p>
			<p>Next, we will learn how to quickly determine any code that isn’t covered <span class="No-Break">by tests.</span></p>
			<h1 id="_idParaDest-307"><a id="_idTextAnchor309"/>Getting code coverage</h1>
			<p>Code coverage is how we refer to how much of our app code is covered by unit tests. As we write our unit tests, we’ll have a fair idea of what code is covered and not covered, but as the app grows and time passes, we’ll lose track <span class="No-Break">of this.</span></p>
			<p>In this section, we’ll learn how to use Jest’s code coverage option so that we don’t have to keep what is covered<a id="_idIndexMarker975"/> in our heads. We will use the code coverage option to determine the code coverage on the checklist component and understand all the different statistics in the report. We will use the code coverage report to find some uncovered code in our checklist component. We will then extend the tests on the checklist component to achieve full <span class="No-Break">code coverage.</span></p>
			<h2 id="_idParaDest-308"><a id="_idTextAnchor310"/>Running code coverage</h2>
			<p>To get code coverage, we run the <strong class="source-inline">test</strong> command with a <strong class="source-inline">--coverage</strong> option. We also include a <strong class="source-inline">--watchAll=false</strong> option that tells<a id="_idIndexMarker976"/> Jest not to run in watch mode. So, run the following command in a terminal to determine code coverage on <span class="No-Break">our app:</span></p>
			<pre class="source-code">
npm run test -- --coverage --watchAll=false</pre>
			<p>The tests take a little longer to run because of the code coverage calculations. When the tests have finished, a code coverage report is output in the terminal with the <span class="No-Break">test results:</span></p>
			<div>
				<div id="_idContainer173" class="IMG---Figure">
					<img src="image/B19051_12_09.jpg" alt="Figure 12.9 – Terminal code coverage report"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.9 – Terminal code coverage report</p>
			<p>Next, we will take some time to understand this code <span class="No-Break">coverage report.</span></p>
			<h2 id="_idParaDest-309"><a id="_idTextAnchor311"/>Understanding the code coverage report</h2>
			<p>The coverage report lists<a id="_idIndexMarker977"/> the coverage for each file and aggregates coverage in a folder for all the files in the project. So, the whole app has between 57.44% and 62.5% code coverage, depending on which statistic <span class="No-Break">we take.</span></p>
			<p>Here’s an explanation of all the <span class="No-Break">statistic columns:</span></p>
			<ul>
				<li><strong class="bold">% Stmts</strong>: This is <strong class="bold">statement coverage</strong>, which is how <a id="_idIndexMarker978"/>many source code statements have been executed during <span class="No-Break">test execution</span></li>
				<li><strong class="bold">% Branch</strong>: This is <strong class="bold">branch coverage</strong>, which is how<a id="_idIndexMarker979"/> many of the branches of conditional logic have been executed during <span class="No-Break">test execution</span></li>
				<li><strong class="bold">% Funcs</strong>: This is <strong class="bold">function coverage</strong>, which is how<a id="_idIndexMarker980"/> many functions have been called during <span class="No-Break">test execution</span></li>
				<li><strong class="bold">% Lines</strong>: This is <strong class="bold">line coverage</strong>, which is how <a id="_idIndexMarker981"/>many lines of source code have been executed during <span class="No-Break">test execution</span></li>
			</ul>
			<p>The rightmost column in the report is very useful. It gives the lines of source code that aren’t covered by tests. For example, the <strong class="source-inline">getNewCheckedIds.ts</strong> file in the checklist component has lines 9 and 10, which <span class="No-Break">are uncovered.</span></p>
			<p>There is another version of the report that is generated in HTML format. This file is automatically generated every time a test is run with the <strong class="source-inline">--coverage</strong> option. So, this report has already been generated because we have just run the tests with the <strong class="source-inline">--coverage</strong> option. Carry out the following steps to explore the <span class="No-Break">HTML report:</span></p>
			<ol>
				<li value="1">The report can be found in an <strong class="source-inline">index.html</strong> file in the <strong class="source-inline">coverage\lcov-report</strong> folder. Double-click on the file so that it opens in <span class="No-Break">a browser:</span></li>
			</ol>
			<div>
				<div id="_idContainer174" class="IMG---Figure">
					<img src="image/B19051_12_10.jpg" alt="Figure 12.10 – HTML coverage report"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.10 – HTML coverage report</p>
			<p>The report contains the same data as the terminal report, but this one <span class="No-Break">is interactive.</span></p>
			<ol>
				<li value="2">Click on the <strong class="bold">src/Checklist</strong> link in the<a id="_idIndexMarker982"/> second row of the report. The page now shows the coverage for the files in the <span class="No-Break">checklist component:</span></li>
			</ol>
			<div>
				<div id="_idContainer175" class="IMG---Figure">
					<img src="image/B19051_12_11.jpg" alt="Figure 12.11 – Coverage report for checklist component files"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.11 – Coverage report for checklist component files</p>
			<ol>
				<li value="3">Click on the <strong class="source-inline">getNewCheckedIds.ts</strong> link to drill into the coverage for <span class="No-Break">that file:</span></li>
			</ol>
			<div>
				<div id="_idContainer176" class="IMG---Figure">
					<img src="image/B19051_12_12.jpg" alt="Figure 12.12 – Coverage report for getNewCheckedIds.ts"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.12 – Coverage report for getNewCheckedIds.ts</p>
			<p>We can see that the uncovered lines 9 and 10 are very clearly highlighted in the <span class="No-Break"><strong class="source-inline">getNewCheckedIds.ts</strong></span><span class="No-Break"> file.</span></p>
			<p>So, the HTML coverage report is useful in a<a id="_idIndexMarker983"/> large code base because it starts with high-level coverage and allows you to drill into coverage on specific folders and files. When viewing a file in the report, we can quickly determine where the uncovered code is because it is <span class="No-Break">clearly highlighted.</span></p>
			<p>Next, we will update our tests so that lines 9 and 10 in <strong class="source-inline">getNewCheckedIds.ts</strong> <span class="No-Break">are covered.</span></p>
			<h2 id="_idParaDest-310"><a id="_idTextAnchor312"/>Gaining full coverage on the checklist component</h2>
			<p>The logic not currently <a id="_idIndexMarker984"/>being checked by tests is the logic used when a list item is clicked but has already been checked. We will extend the <strong class="source-inline">'should check items when clicked'</strong> test to cover this logic. Carry out the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">Open <strong class="source-inline">Checklist.test.tsx</strong> and rename the <strong class="source-inline">'should check items when clicked'</strong> test <span class="No-Break">as follows:</span><pre class="source-code">
test('<strong class="bold">should check and uncheck items when clicked</strong>', async () =&gt; {</pre><pre class="source-code">
  ...</pre><pre class="source-code">
});</pre></li>
				<li>Add the following highlighted <a id="_idIndexMarker985"/>lines at the end of the test to click the checkbox for a second time and check it <span class="No-Break">is unchecked:</span><pre class="source-code">
test('should check and uncheck items when clicked', async () =&gt; {</pre><pre class="source-code">
  const user = userEvent.setup();</pre><pre class="source-code">
  render(</pre><pre class="source-code">
    &lt;Checklist</pre><pre class="source-code">
      data={[{ id: 1, name: 'Lucy', role: 'Manager' }]}</pre><pre class="source-code">
      id="id"</pre><pre class="source-code">
      primary="name"</pre><pre class="source-code">
      secondary="role"</pre><pre class="source-code">
    /&gt;</pre><pre class="source-code">
  );</pre><pre class="source-code">
  const lucyCheckbox = screen.getByTestId(</pre><pre class="source-code">
    'Checklist__input__1'</pre><pre class="source-code">
  );</pre><pre class="source-code">
  expect(lucyCheckbox).not.toBeChecked();</pre><pre class="source-code">
  await user.click(lucyCheckbox);</pre><pre class="source-code">
  expect(lucyCheckbox).toBeChecked();</pre><pre class="source-code">
  <strong class="bold">await user.click(lucyCheckbox);</strong></pre><pre class="source-code">
<strong class="bold">  expect(lucyCheckbox).not.toBeChecked();</strong></pre><pre class="source-code">
});</pre></li>
				<li>In the terminal, rerun the<a id="_idIndexMarker986"/> tests <span class="No-Break">with coverage:</span><pre class="source-code">
npm run test -- --coverage --watchAll=false</pre></li>
			</ol>
			<p>All the tests still pass, and the coverage on the checklist component is now reported as 100% on all <span class="No-Break">the statistics:</span></p>
			<div>
				<div id="_idContainer177" class="IMG---Figure">
					<img src="image/B19051_12_13.jpg" alt="Figure 12.13 – 100% coverage on the checklist component"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.13 – 100% coverage on the checklist component</p>
			<p>The checklist component is now well covered. However, it is a little annoying that <strong class="source-inline">index.ts</strong> and <strong class="source-inline">types.ts</strong> appear in the report with zero coverage. We’ll resolve <span class="No-Break">this next.</span></p>
			<h2 id="_idParaDest-311"><a id="_idTextAnchor313"/>Ignoring files in the coverage report</h2>
			<p>We will remove <strong class="source-inline">index.ts</strong> and <strong class="source-inline">types.ts</strong> from the coverage report because they don’t contain any logic and create unnecessary <a id="_idIndexMarker987"/>noise. Carry out the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">Open the <strong class="source-inline">package.json</strong> file. We can configure Jest in the <strong class="source-inline">package.json</strong> file in a <strong class="source-inline">jest</strong> field, and there is a <strong class="source-inline">coveragePathIgnorePatterns</strong> configuration option for removing files from the coverage report. Add the following Jest configuration to <strong class="source-inline">package.json</strong> to ignore the <strong class="source-inline">types.ts</strong> and <span class="No-Break"><strong class="source-inline">index.ts</strong></span><span class="No-Break"> files:</span><pre class="source-code">
{</pre><pre class="source-code">
  ...,</pre><pre class="source-code">
  <strong class="bold">"jest": {</strong></pre><pre class="source-code">
<strong class="bold">    "coveragePathIgnorePatterns": [</strong></pre><pre class="source-code">
<strong class="bold">      "types.ts",</strong></pre><pre class="source-code">
<strong class="bold">      "index.ts"</strong></pre><pre class="source-code">
<strong class="bold">    ]</strong></pre><pre class="source-code">
<strong class="bold">  }</strong></pre><pre class="source-code">
}</pre></li>
				<li>In the terminal, rerun the<a id="_idIndexMarker988"/> tests <span class="No-Break">with coverage:</span><pre class="source-code">
npm run test -- --coverage --watchAll=false</pre></li>
			</ol>
			<p>The <strong class="source-inline">types.ts</strong> and <strong class="source-inline">index.ts</strong> files are removed from the <span class="No-Break">coverage report:</span></p>
			<div>
				<div id="_idContainer178" class="IMG---Figure">
					<img src="image/B19051_12_14.jpg" alt="Figure 12.14 – types.ts and index.ts files removed from the coverage report"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.14 – types.ts and index.ts files removed from the coverage report</p>
			<p>That completes this section on code coverage. Here’s a <span class="No-Break">quick recap:</span></p>
			<ul>
				<li>The <strong class="source-inline">--coverage</strong> option outputs a code coverage report after the tests <span class="No-Break">have run.</span></li>
				<li>An interactive HTML code coverage report is generated in addition to the one in the terminal. This is useful on a large test suite to drill into <span class="No-Break">uncovered code.</span></li>
				<li>Both report formats<a id="_idIndexMarker989"/> highlight uncovered code, giving us valuable information to improve our <span class="No-Break">test suite.</span></li>
			</ul>
			<h1 id="_idParaDest-312"><a id="_idTextAnchor314"/>Summary</h1>
			<p>In this chapter, we created tests on a checklist component using Jest and React Testing Library. In addition, we learned about common Jest matchers in Jest’s core package and useful matchers for component testing in a companion package <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">jest-dom</strong></span><span class="No-Break">.</span></p>
			<p>We used Jest’s test runner and used options to run certain tests. This is particularly useful on large <span class="No-Break">code bases.</span></p>
			<p>We learned about the wide variety of queries available in React Testing Library to select elements in different ways. We used the <strong class="source-inline">getByText</strong> query extensively in the checklist tests. We also created a test ID on list item checkboxes so that the <strong class="source-inline">getByTestId</strong> query could be used to select <span class="No-Break">them uniquely.</span></p>
			<p>We learned that the <strong class="source-inline">user-event</strong> package is an excellent way of simulating user interactions that are decoupled from the implementation. We used this to simulate a user clicking a list <span class="No-Break">item checkbox.</span></p>
			<p>We learned how to produce code coverage reports and understood all the statistics in the report. The report included information about uncovered code, which we used to gain 100% coverage on the <span class="No-Break">checklist component.</span></p>
			<p>So, we have reached the end of this book. You are now comfortable with both React and TypeScript and have excellent knowledge in areas outside React core, such as styling, client-side routing, forms, and web APIs. You will be able to develop components that are reusable across different pages and even different apps. On top of that, you will now be able to write a robust test suite so that you can ship new features <span class="No-Break">with confidence.</span></p>
			<p>In summary, the knowledge from this book will allow you to efficiently build the frontend of large and complex apps with React and TypeScript. I hope you have enjoyed reading this book as much as I did <span class="No-Break">writing it!</span></p>
			<h1 id="_idParaDest-313"><a id="_idTextAnchor315"/>Questions</h1>
			<p>Answer the following questions to check what you have learned in <span class="No-Break">this chapter:</span></p>
			<ol>
				<li value="1">We have written some tests for a <strong class="source-inline">HomePage</strong> component and placed them in a file called <strong class="source-inline">HomePage.tests.tsx</strong>. However, the tests aren’t run when the <strong class="source-inline">npm test</strong> command is executed—not even when the <em class="italic">a</em> key is pressed to run all the tests. What do you think the problem <span class="No-Break">might be?</span></li>
				<li>Why doesn’t the following expectation pass? How could this <span class="No-Break">be resolved?</span><pre class="source-code">
expect({ name: 'Bob' }).toBe({ name: 'Bob' });</pre></li>
				<li>Which matcher can be used to check that a variable <span class="No-Break">isn’t </span><span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break">?</span></li>
				<li>Here’s an expectation that checks whether a <strong class="bold">Save</strong> button <span class="No-Break">is disabled:</span><pre class="source-code">
expect(</pre><pre class="source-code">
  screen.getByText('Save').hasAttribute('disabled')</pre><pre class="source-code">
).toBe(true);</pre></li>
			</ol>
			<p>The expectation passes as expected, but is there a different matcher that can be used to <span class="No-Break">simplify this?</span></p>
			<ol>
				<li value="5">Write a test for the <strong class="source-inline">getNewCheckedIds</strong> function we used in this chapter. The test should check if an ID is removed from the array of checked IDs if it is already in <span class="No-Break">the array.</span></li>
				<li>We have a <strong class="source-inline">form</strong> element containing a <strong class="bold">Save</strong> button only when data has been loaded into fields from a server API. We have used the <strong class="source-inline">findBy</strong> query type so that the query retries until the data has <span class="No-Break">been fetched:</span><pre class="source-code">
expect(screen.findByText('Save')).toBeInTheDocument();</pre></li>
			</ol>
			<p>However, the expectation doesn’t work—can you spot <span class="No-Break">the problem?</span></p>
			<ol>
				<li value="7">The following expectation attempts to check that a <strong class="bold">Save</strong> button isn’t in <span class="No-Break">the DOM:</span><pre class="source-code">
expect(screen.getByText('Save')).toBe(null);</pre></li>
			</ol>
			<p>This doesn’t work as expected, though. Instead, an error is raised because the <strong class="bold">Save</strong> button can’t be found. How can this <span class="No-Break">be resolved?</span></p>
			<h1 id="_idParaDest-314"><a id="_idTextAnchor316"/>Answers</h1>
			<ol>
				<li value="1">The problem is that the file extension is <strong class="source-inline">tests.tsx</strong> rather <span class="No-Break">than </span><span class="No-Break"><strong class="source-inline">test.tsx</strong></span><span class="No-Break">.</span></li>
				<li>The <strong class="source-inline">toBe</strong> matcher should only be used for checking primitive values such as numbers and strings—this is an object. The <strong class="source-inline">toStrictEqual</strong> matcher should be used to check objects because it checks the values of all its properties instead of the <span class="No-Break">object reference:</span><pre class="source-code">
expect({ name: 'Bob' }).toStrictEqual({ name: 'Bob' });</pre></li>
				<li>The <strong class="source-inline">not</strong> and <strong class="source-inline">toBeNull</strong> matchers can be combined to check a variable <span class="No-Break">isn’t </span><span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break">:</span><pre class="source-code">
expect(something).<strong class="bold">not</strong>.<strong class="bold">toBeNull</strong>();</pre></li>
				<li>The <strong class="source-inline">toBeDisabled</strong> matcher can be used <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">jest-dom</strong></span><span class="No-Break">:</span><pre class="source-code">
expect(screen.getByText('Save')).toBeDisabled();</pre></li>
				<li>Here’s <span class="No-Break">a test:</span><pre class="source-code">
test('should remove id when already in checked ids', () =&gt; {</pre><pre class="source-code">
  const result = getNewCheckedIds([1, 2, 3], 2);</pre><pre class="source-code">
  expect(result).toStrictEqual([1, 3]);</pre><pre class="source-code">
});</pre></li>
				<li>The <strong class="source-inline">findBy</strong> query type requires awaiting because it <span class="No-Break">is asynchronous:</span><pre class="source-code">
expect(<strong class="bold">await</strong> screen.findByText('Save')).toBeInTheDocument();</pre></li>
				<li>The <strong class="source-inline">queryBy</strong> query type can be used because it doesn’t throw an exception when an element isn’t found. In addition, the <strong class="source-inline">not</strong> and <strong class="source-inline">toBeInTheDocument</strong> matchers can be used to check that the element isn’t in <span class="No-Break">the DOM:</span><pre class="source-code">
expect(screen.<strong class="bold">queryByText</strong>('Save')).<strong class="bold">not.toBeInTheDocument</strong>();</pre></li>
			</ol>
		</div>
		<div>
			<div id="_idContainer180" class="Content">
			</div>
		</div>
	</body></html>