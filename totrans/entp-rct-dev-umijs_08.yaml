- en: 'Chapter 6: Testing Front-End Applications'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing software is an essential part of software development. We can prevent
    errors and ensure that new features don't introduce bugs by implementing well-designed
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you'll understand software testing by learning how to design
    integration and end-to-end tests and apply them in the development process. After
    that, you'll learn how to write tests using **Jest**, a JavaScript test framework
    focused on simplicity that works well with React. You'll also learn how to test
    interfaces by simulating user actions with **Puppeteer** and **Headless Chrome**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding software testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tests with Jest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing interfaces with Puppeteer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll have learned how to design integration and
    end-to-end tests and how to apply them to improve software quality. You'll have
    learned how to write tests using Jest, a tool to write and run tests in JavaScript
    projects. You'll also know how to test interfaces with Puppeteer and Headless
    Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete this chapter's exercises, you just need a computer with any OS (I
    recommend Ubuntu 20.04 or higher) and the software installed in [*Chapter 1*](B18503_01_Final_JM_ePub.xhtml#_idTextAnchor014),
    *Environment Setup and Introduction to UmiJS* (Visual Studio Code, Node.js, and
    Yarn).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the complete project in the `Chapter06` folder in the GitHub repository
    available at the following link: [https://github.com/PacktPublishing/Enterprise-React-Development-with-UmiJs](https://github.com/PacktPublishing/Enterprise-React-Development-with-UmiJs)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding software testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll discuss software testing and how to design **integration**
    and **end-to-end tests** to ensure your application works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are numerous types of software testing, which we can divide into two
    categories: functional tests, which ensure that functional requirements and specifications
    are satisfied, and non-functional tests, which focus on testing the behavior and
    performance of the system. We''ll talk about two types of functional tests in
    this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Integration tests**: We write this type of test to ensure that different
    software components integrate and work correctly to deliver the specified feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**End-to-end tests**: We write this type of test to cover complete user flows,
    ensuring that features satisfy user expectations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's important to mention that coding the test is only one task of implementing
    software testing, and it's not worth it if you don't have solid feature specifications
    and test plans.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start discussing integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding integration testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We perform integration tests to ensure that the different modules present in
    the application work correctly and communicate to deliver the requested feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take our CRM application as an example. We implemented a feature to
    show the application in different languages by configuring the Umi locale plugin.
    We could execute an integration test to ensure that the `SelectLang` component
    works correctly with `plugin-locale` to show the application in the language selected.
    In that case, we would need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Hover over the user's name in the upper-right corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **English** from the drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether the page is in English.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can manually execute the integration test following a test plan depending
    on the test strategy. Still, a better option is to write our tests using automated
    testing tools for repeating the tests, as necessary, with more agility.
  prefs: []
  type: TYPE_NORMAL
- en: We'll learn how to use automated test tools to develop integration and end-to-end
    tests in the upcoming sections. Next, let's learn more about end-to-end tests.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding end-to-end testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the name suggests, an end-to-end test covers the user journey to execute
    a task from beginning to end. We need to perform the same actions an actual user
    must perform, validating the system integrity and alignment with requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine that our CRM application has a feature to print the report
    on the reposts page. An end-to-end test to validate this scenario should cover
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log into the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the reports menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the charts to load and validate whether they were correctly rendered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the print button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the generated PDF and validate the report.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, this type of test involves several steps depending on the complexity
    of the system and the task. We can perform end-to-end tests manually following
    a test plan or automate this process using automated testing tools.
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end tests usually require robust testing tools and are written by **quality
    assurance** (**QA**) professionals. Still, we can write end-to-end tests during
    the development phase. This approach will reduce the issues during the QA phase
    and accelerate the fixing of issues.
  prefs: []
  type: TYPE_NORMAL
- en: We'll learn how to use Puppeteer to write and automate end-to-end tests in the
    upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing software testing is an extensive subject. If you want to learn
    more about this topic, I recommend the article at [https://www.ibm.com/topics/software-testing](https://www.ibm.com/topics/software-testing).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed software testing by learning how to design integration
    and end-to-end tests. Next, you'll learn how to write tests in JavaScript projects
    using Jest.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests with Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: "In this section, you'll learn how to write tests using the **Jest framework**\
    \ in \LJavaScript projects."
  prefs: []
  type: TYPE_NORMAL
- en: Jest is a fast and reliable test framework for JavaScript projects focusing
    on simplicity. It works with Babel, TypeScript, Node, React, Angular, Vue, and
    other tools.
  prefs: []
  type: TYPE_NORMAL
- en: After installing it, we can start using Jest without any extra configuration.
    In our case, we can write a test and run the `test` command configured in our
    project without even installing Jest, as Umi already provides Jest with the `umi-test`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this end-to-end test written with Jest to test the login flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this test, all instructions are written inside the `it` method. You can also
    use the `test` method instead if you want. The difference between these two methods
    is just semantics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the `it` method receives two arguments: the first argument is the test
    name and the second is an async function that executes the test instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the `expect` method combined with the `toBeTruthy` `loggeduser` ID exists
    on the page.
  prefs: []
  type: TYPE_NORMAL
- en: We use matchers to test values against different conditions. You can find a
    complete list of available Jest matchers at [https://jestjs.io/docs/expect](https://jestjs.io/docs/expect).
  prefs: []
  type: TYPE_NORMAL
- en: Next, you'll see how to organize related tests by creating a test suite.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the describe method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When writing multiple related tests, you should organize them within a test
    suite using the `describe` method, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we used the `describe` method to create a group for two tests
    related to math problems.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how we can execute some setup work before and after the entire test
    suite or each test run.
  prefs: []
  type: TYPE_NORMAL
- en: Executing instructions before and after tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you''ll have some setup to do before running tests, such as initializing
    a database connection or generating mock data. You can do that by defining the
    instructions in the `beforeAll` method to execute before all the tests run or
    the `beforeEach` method to execute instructions before each test run. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, before all the tests ran, we opened the database connection,
    and before each test run, we used the connection to query the product in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, in this example, we need to close the database connection after running
    the test suite. We can do that by adding the `afterAll` method, as shown in the
    next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Like the `afterAll` method, you can use the `afterEach` method to execute instructions
    after each test run.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to write tests using the Jest framework. You
    learned how to create test suites and execute instructions before and after the
    tests run.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's learn about Puppeteer and write integration and end-to-end tests
    for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Testing interfaces with Puppeteer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll learn how to write integration and end-to-end tests
    using **Puppeteer** and the **Headless Chrome browser**.
  prefs: []
  type: TYPE_NORMAL
- en: Puppeteer is a Node library to control the Chrome, Chromium, or Firefox browser
    over the DevTools protocol (or remote protocol for Firefox), which makes it an
    excellent tool for simulating real scenarios during tests.
  prefs: []
  type: TYPE_NORMAL
- en: When we launch a new browser instance, Puppeteer will default to using **Chrome's
    headless mode**. Chrome's headless mode only includes the browser engine, with
    no user interface. Puppeteer uses the Chrome DevTools protocol to control the
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: With Puppeteer, we can take screenshots of the page, test responsiveness by
    simulating numerous mobile devices, such as tablets and smartphones, and more.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about Puppeteer on the document page available at [https://developers.google.com/web/tools/puppeteer](https://developers.google.com/web/tools/puppeteer).
  prefs: []
  type: TYPE_NORMAL
- en: We'll write an integration test and an end-to-end test to demonstrate the use
    of Puppeteer and Jest.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the access and layout plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by installing Puppeteer by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Puppeteer's configuration is as simple as Jest's. By running this command, Puppeteer
    will install the latest version of the Chromium browser, and we can start using
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, follow these steps to create the integration test:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder named `tests` in the project's root folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `tests` folder, create a new file named `integration.test.ts`. Jest will
    execute all files with a name that includes `.test.ts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `integration.test.ts` file, create a test suite, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, before all tests run, we launch Puppeteer and store the instance in the
    `browser` variable. By default, Puppeteer will launch Chromium in headless mode.
    Still, you can launch the full browser version by setting the `headless` option,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: By setting the `headless` option to `false`, you can see Puppeteer opening windows
    and executing the tests.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Running an integration test in the full browser version'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.01_B18503.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Running an integration test in the full browser version
  prefs: []
  type: TYPE_NORMAL
- en: We create an anonymous browser context by opening an incognito window before
    each test run to execute them in an isolated environment and store the incognito
    window in the `context` variable. After each test run, we close the incognito
    window, and after the entire suite run, we close the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll notice that TypeScript can''t find Jest types. We must install the
    declaration file by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let's create an integration test to ensure that the Umi access plugin correctly
    works with the layout plugin to show the 403 error page when unauthorized users
    try to access a restricted page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test to the test suite in the `integration.test.ts` file
    under the `tests` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this test, after opening a page and setting the default timeout for `async`
    operations to `10000` milliseconds, Puppeteer performs the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Logs into the application as John Doe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Goes to the workflow page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selects the element with the `unauthorized` ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluates the text message inside the element and tests whether the message
    is correct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that we used the `waitForSelector` method to ensure that the element
    is already rendered when selecting it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to create the `login` function. Add the `login` function before
    the `describe` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function will perform the steps to log in to the application as John Doe.
    We can reuse the `login` function in other tests within the test suite. Notice
    we used the `waitForNavigation` method to ensure that the components are rendered
    before performing the steps.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to add the `unauthorized` ID to the element containing the text
    that we'll validate when running the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app.tsx` file located in the `src` folder and modify the layout `unAccessible`
    configuration option, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We enclosed the text with a `span` tag containing the `id` property we need.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to add the `id` properties to the login form inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `index.tsx` file located under `src/pages/Login/LoginForm` and modify
    the username input by adding the `username` ID, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, modify the password input by adding the `password` ID, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the `loginbtn` ID to the login button, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can execute the test by running the `yarn test` command. The result should
    look as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Integration test result'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.02_B18503.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – Integration test result
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's create an end-to-end test to ensure that the feature for editing
    an opportunity works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the opportunity editing feature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create the end-to-end test to ensure the editing feature
    works as expected on the opportunities page:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create a separate file for end-to-end tests. In the `tests` folder,
    create a file named `end2end.test.ts`, and create the `describe` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the end-to-end test to the `describe` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have written the instructions for Puppeteer to open a new page and set the
    default timeout to `1000`, go to the login page, and wait for the page to load.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the instructions to log into the application, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Puppeteer will type the user's email address in the input with the `username`
    ID and the password in the input with the `password` ID, then click on the button
    with the `loginbtn` ID. Finally, Puppeteer will navigate to the opportunities
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the steps to edit the opportunity topic, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Puppeteer will wait for the element with the id equal to `editopportunity` to
    be rendered before clicking on it and selecting the text by triple-clicking the
    input element. Next, Puppeteer will type new text in the topic input and save
    the opportunity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add the steps to evaluate the result, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Puppeteer will select the topic cell in the first row of the opportunities table
    and evaluate its text content. Next, Jest will test the value to ensure it's correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s add the `id` property to the elements we need to find during
    the test. In the `columns.tsx` file, under the `pages/Opportunities` folder, add
    the `id` property to the edit option anchor, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `index.ts` file, in the same folder, add the `saveText` property to
    the editable attribute of the `ProTable` component, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before executing the test, let''s add the `--runInBand` flag to the `umi-test`
    command in the `package.json` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This flag will prevent a race condition between these two tests as we are using
    the mock API to simulate the backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can execute the test by running the `yarn test` command. The result
    should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – End-to-end test result'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.03_B18503.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – End-to-end test result
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to write integration tests and end-to-end tests
    using Puppeteer. To demonstrate the use of Puppeteer with Jest, we created an
    integration test to ensure the Umi locale plugin works correctly with the layout
    plugin to render the 403 error page. We also created an end-to-end test to ensure
    the feature to edit an opportunity works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed software testing by learning how to design integration
    and end-to-end tests. You learned how to use the Jest framework to write tests
    in React projects. You saw how to use the `describe` and `test` (or `it`) methods
    to write and organize related tests. You also learned how to execute instructions
    before and after tests run using the `beforeAll`, `beforeEach`, `afterAll`, and
    `afterEach` methods.
  prefs: []
  type: TYPE_NORMAL
- en: You then learned how to write tests using Puppeteer and Headless Chrome by simulating
    user interaction on your interface. To demonstrate the use of Puppeteer with Jest,
    we created an integration test to ensure the Umi locale plugin works correctly
    with the layout plugin and also created an end-to-end test to ensure the feature
    to edit an opportunity works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to compile and deploy our applications
    to online services.
  prefs: []
  type: TYPE_NORMAL
