<html><head></head><body>
<div id="_idContainer028">
<h1 class="chapter-number" id="_idParaDest-112"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-113"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.2.1">Mastering Reactive Programming in Angular</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Reactive programming helps improve your applications’ performance and allows Angular to make better use of the change detection mechanism, reducing the number of times your application needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">be re-rendered.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, you’ll learn about reactive programming. </span><span class="koboSpan" id="kobo.5.2">You will learn what reactive programming is and how it can be used to improve your Angular applications. </span><span class="koboSpan" id="kobo.5.3">You will also learn about the RxJS library and how it can manage asynchronous data streams reactively. </span><span class="koboSpan" id="kobo.5.4">This chapter will teach you how to use different RxJS operators, create reusable RxJS operators, reuse sets of RxJS operators, and map other Observables into view models </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">using RxJS.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">You will also learn about Angular Signals and how Signals are used to reactively manage synchronous data streams. </span><span class="koboSpan" id="kobo.7.2">Lastly, you will learn how to combine RxJS and Signals, when to use RxJS, and when Signals </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">reign supreme.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">By the end of this chapter, you’ll be able to reactively manage data streams and know everything there is to know about </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">Angular Signals.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">This chapter will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">What is </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">reactive programming?</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Reactive programming </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">using RxJS</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Reactive programming using </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Angular Signals</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Combining Signals </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">and RxJS</span></span></li>
</ul>
<h1 id="_idParaDest-114"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.21.1">What is reactive programming?</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.22.1">Reactive programming</span></strong><span class="koboSpan" id="kobo.23.1"> is a declarative </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.24.1">programming paradigm like functional, modular, procedural, or </span><strong class="bold"><span class="koboSpan" id="kobo.25.1">object-orientated programming</span></strong><span class="koboSpan" id="kobo.26.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.27.1">OOP</span></strong><span class="koboSpan" id="kobo.28.1">). </span><span class="koboSpan" id="kobo.28.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.29.1">programming paradigm</span></strong><span class="koboSpan" id="kobo.30.1"> is a set</span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.31.1"> of rules</span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.32.1"> and principles specifying how you write your code. </span><span class="koboSpan" id="kobo.32.2">It is similar to architectural and design patterns, but they operate on a different level </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">of abstraction.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">Programming paradigms are high-level concepts that dictate the overall style, structure, and approach to writing code, whereas architectural and design patterns provide reusable templates or</span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.35.1"> blueprints for structuring code, handling communication between components, managing relationships, and solving other common design challenges within your </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">Reactive programming deals with data streams and the propagation of changes. </span><span class="koboSpan" id="kobo.37.2">In simple terms, reactive programming dictates how you handle events and data changes that can happen at any given time, also known as </span><strong class="bold"><span class="koboSpan" id="kobo.38.1">asynchronous changes</span></strong><span class="koboSpan" id="kobo.39.1">. </span><span class="koboSpan" id="kobo.39.2">As the name already implies, you are reacting to changes</span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.40.1"> with reactive programming. </span><span class="koboSpan" id="kobo.40.2">With reactive programming, the dependent parts of your code will automatically be notified of events and data changes so that these parts can react to changes automatically. </span><span class="koboSpan" id="kobo.40.3">You can think of reactive programming as a system where changes are pushed to the parts of your code that need to react upon the changes instead of you pulling the current state, checking if it changed, and then updating the dependent </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">code accordingly.</span></span></p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.42.1">Highlights of reactive programming</span></h2>
<p><span class="koboSpan" id="kobo.43.1">Reactive systems optimize resource allocation by subscribing to and processing data only when it changes, reducing unnecessary</span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.44.1"> processing and improving overall system performance. </span><span class="koboSpan" id="kobo.44.2">This approach allows for a more responsive and scalable system while conserving computational resources, making it particularly advantageous for handling asynchronous data streams efficiently. </span><span class="koboSpan" id="kobo.44.3">Some common examples where you can use reactive programming to handle data streams and events are HTTP requests, form changes, and browser events such as clicks, mouse movements, and </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">keyboard events.</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">Reactive programming also promotes composability by enabling developers to easily compose complex behaviors from simpler ones. </span><span class="koboSpan" id="kobo.46.2">Through operators such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">map</span></strong><span class="koboSpan" id="kobo.48.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">filter</span></strong><span class="koboSpan" id="kobo.50.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">merge</span></strong><span class="koboSpan" id="kobo.52.1">, and more, reactive systems allow you to transform, combine, and manipulate </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">data streams.</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">This inherent modularity empowers developers to build more modular and flexible applications where different data streams can be seamlessly integrated, transformed, and adapted to create sophisticated and easily maintainable systems. </span><span class="koboSpan" id="kobo.54.2">This emphasis on composability fosters code reusability and promotes the creation of highly scalable and </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">adaptable applications.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">Another important part of reactive programming is handling events and data changes that are non-blocking; this is mainly where the performance boost comes from when you start programming reactively. </span><strong class="bold"><span class="koboSpan" id="kobo.57.1">Non-blocking code</span></strong><span class="koboSpan" id="kobo.58.1"> ensures </span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.59.1">multiple tasks, events, and data changes can be executed in parallel. </span><span class="koboSpan" id="kobo.59.2">In other words, non-blocking code runs the code without waiting for</span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.60.1"> the task to finish, so your code continues to the next lines of code directly after the task has started. </span><span class="koboSpan" id="kobo.60.2">In </span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.61.1">contrast, </span><strong class="bold"><span class="koboSpan" id="kobo.62.1">blocking code</span></strong><span class="koboSpan" id="kobo.63.1"> will wait until the code has finished before moving to the next line </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">of code.</span></span></p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.65.1">Drawbacks of reactive programming</span></h2>
<p><span class="koboSpan" id="kobo.66.1">Reactive programming is great, but it is </span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.67.1">not only sunshine and roses; there are also some drawbacks to </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">reactive programming.</span></span></p>
<p><span class="koboSpan" id="kobo.69.1">Reactive systems can become complex, and the learning curve, especially for junior developers, can be steep. </span><span class="koboSpan" id="kobo.69.2">Besides some difficult concepts, reactive programming can be complicated to debug and harder to test with automated tests. </span><span class="koboSpan" id="kobo.69.3">Especially when you’re writing unit testing for your applications, a highly reactive system can give you </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">some headaches.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">You now know what reactive programming is and how it can improve your application’s performance and allow you to handle events and data streams effectively. </span><span class="koboSpan" id="kobo.71.2">Reactive programming provides easy composability of data streams and events and runs your code in a non-blocking approach. </span><span class="koboSpan" id="kobo.71.3">You also know what challenges reactive programming can bring to your code base and that it can be challenging for junior developers to understand some reactive patterns. </span><span class="koboSpan" id="kobo.71.4">Now, let’s learn more about how reactive programming is used within </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">Angular applications.</span></span></p>
<h1 id="_idParaDest-117"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.73.1">Reactive programming in Angular</span></h1>
<p><span class="koboSpan" id="kobo.74.1">Reactive programming is integral to the </span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.75.1">Angular framework. </span><span class="koboSpan" id="kobo.75.2">Angular heavily relies on </span><em class="italic"><span class="koboSpan" id="kobo.76.1">Observables</span></em><span class="koboSpan" id="kobo.77.1"> (we will explain Observables in detail in the next section) and has the </span><strong class="bold"><span class="koboSpan" id="kobo.78.1">RxJS</span></strong><span class="koboSpan" id="kobo.79.1"> library built into it to </span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.80.1">manage Observable data streams in a robust and composable manner. </span><strong class="bold"><span class="koboSpan" id="kobo.81.1">Observables</span></strong><span class="koboSpan" id="kobo.82.1"> are a reactive design pattern because you have the Observable, or publisher of data, and the subscribers or receivers of the data stream. </span><span class="koboSpan" id="kobo.82.2">Subscribers are automatically notified when the Observable emits a new value and can act upon </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">it accordingly.</span></span></p>
<p><span class="koboSpan" id="kobo.84.1">Observables are utilized in many </span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.85.1">different aspects within the Angular framework. </span><span class="koboSpan" id="kobo.85.2">Here are some examples where </span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.86.1">you can find Observables within the </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">Angular framework:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.88.1">HTTP requests</span></strong><span class="koboSpan" id="kobo.89.1">: Within the Angular framework, HTTP requests return Observables by default. </span><span class="koboSpan" id="kobo.89.2">HTTP requests in vanilla JavaScript are handled </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">with Promises.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.91.1">Router events</span></strong><span class="koboSpan" id="kobo.92.1">: The Angular Router class exposes an </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">events</span></strong><span class="koboSpan" id="kobo.94.1"> Observable. </span><span class="koboSpan" id="kobo.94.2">With the router </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">events</span></strong><span class="koboSpan" id="kobo.96.1"> Observable, you can listen for events such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">NavigationStart</span></strong><span class="koboSpan" id="kobo.98.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">NavigationEnd</span></strong><span class="koboSpan" id="kobo.100.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">GuardCheckStart</span></strong><span class="koboSpan" id="kobo.102.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">GuardCheckEnd</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.106.1">Reactive forms changes</span></strong><span class="koboSpan" id="kobo.107.1">: Within reactive forms and form controls, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">valueChanges</span></strong><span class="koboSpan" id="kobo.109.1"> Observable is exposed by the Angular framework. </span><span class="koboSpan" id="kobo.109.2">With this Observable, you can react to changes within the form or </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">form fields.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.111.1">ViewChildren changes</span></strong><span class="koboSpan" id="kobo.112.1">: When you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">ViewChildren</span></strong><span class="koboSpan" id="kobo.114.1"> decorator, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">QueryList</span></strong><span class="koboSpan" id="kobo.116.1"> object it returns has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">changes</span></strong><span class="koboSpan" id="kobo.118.1"> event. </span><span class="koboSpan" id="kobo.118.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">changes</span></strong><span class="koboSpan" id="kobo.120.1"> event is an Observable that notifies you when the selection that’s made by </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">ViewChildren</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.122.1">has changed.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.123.1">These examples are just some instances where the Angular framework relies on Observables. </span><span class="koboSpan" id="kobo.123.2">In the code of applications made with Angular and within libraries that are commonly used in combination with Angular, you’ll come across Observables in </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">many instances.</span></span></p>
<p><span class="koboSpan" id="kobo.125.1">Besides Observables, Angular also uses reactive programming in other ways, such as when handling browser events with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">Hostlistener()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.128.1"> decorator:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.129.1">@HostListener</span></strong><span class="koboSpan" id="kobo.130.1">('document:keydown', ['$event'])
handleTheKeyboardEvent(event: KeyboardEvent) { …… }</span></pre> <p><span class="koboSpan" id="kobo.131.1">In the preceding code snippet, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">@Hostlistener()</span></strong><span class="koboSpan" id="kobo.133.1"> decorator to listen for </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">keydown</span></strong><span class="koboSpan" id="kobo.135.1"> events and handle them reactively. </span><span class="koboSpan" id="kobo.135.2">Another place where Angular uses the reactive programming paradigm is with </span><strong class="bold"><span class="koboSpan" id="kobo.136.1">Angular Signals</span></strong><span class="koboSpan" id="kobo.137.1">, which was introduced in Angular 16. </span><span class="koboSpan" id="kobo.137.2">Angular Signals is a system that tracks </span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.138.1">value changes and notifies interested consumers accordingly. </span><span class="koboSpan" id="kobo.138.2">The Signals API comes with computed properties and effects that are automatically updated </span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.139.1">or run when a Signal value changes. </span><span class="koboSpan" id="kobo.139.2">Signals are excellent for handling synchronous</span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.140.1"> values reactively, whereas RxJS shines in handling asynchronous data streams. </span><span class="koboSpan" id="kobo.140.2">We will dive deeper into the topic of Signals in the </span><em class="italic"><span class="koboSpan" id="kobo.141.1">Reactive programming with Angular Signals</span></em><span class="koboSpan" id="kobo.142.1"> section of </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.144.1">Now that you know that Angular has reactive programming embedded within the framework, from Observables and RxJS to event handling and the new Angular Signals, let’s move on to the next section and learn how to use RxJS to its fullest within </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">Angular applications.</span></span></p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.146.1">Reactive programming using RxJS</span></h1>
<p><span class="koboSpan" id="kobo.147.1">Regarding reactive programming in the context of Angular applications, RxJS stands at its core. </span><strong class="bold"><span class="koboSpan" id="kobo.148.1">RxJS</span></strong><span class="koboSpan" id="kobo.149.1"> is short for </span><strong class="bold"><span class="koboSpan" id="kobo.150.1">Reactive Extensions Library for JavaScript</span></strong><span class="koboSpan" id="kobo.151.1">. </span><span class="koboSpan" id="kobo.151.2">As the name reveals, it’s a library for handling </span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.152.1">reactivity within JavaScript, and it is </span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.153.1">built-in and used by default within the </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">Angular framework.</span></span></p>
<p><span class="koboSpan" id="kobo.155.1">RxJS is used to create, consume, modify, and compose asynchronous and event-based data streams. </span><span class="koboSpan" id="kobo.155.2">At its core, RxJS revolves around four major concepts: Observables, Observers, Subjects, and operators. </span><span class="koboSpan" id="kobo.155.3">Let’s dive deep into these concepts individually, starting </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">with Observables.</span></span></p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.157.1">What are Observables?</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.158.1">Observables</span></strong><span class="koboSpan" id="kobo.159.1"> are the cornerstone </span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.160.1">of RxJS. </span><span class="koboSpan" id="kobo.160.2">You can see Observables as a stream or a pipeline that emits different values over time in an asynchronous manner. </span><span class="koboSpan" id="kobo.160.3">To receive the values emitted by the Observable data stream, you subscribe to </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">the Observable.</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">Now, imagine an Observable data stream as a water pipe. </span><span class="koboSpan" id="kobo.162.2">When you turn on the tap (subscribe), water (data) flows through the pipe (Observable), and you receive drops of water (values) at your end. </span><span class="koboSpan" id="kobo.162.3">The water (data) might already be flowing before you turn on the tab (subscribe) unless you installed a special system; you will only receive water (data) from the moment you have your tab running (subscribe) up to the moment you close the tab (unsubscribe). </span><span class="koboSpan" id="kobo.162.4">The </span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.163.1">water (data) might keep running to other tabs (subscribers) if they are open. </span><span class="koboSpan" id="kobo.163.2">So, in short, to receive values from the data flow, you need to subscribe, and all values emitted before you subscribe are lost unless you have special logic in place to store these values. </span><span class="koboSpan" id="kobo.163.3">To stop receiving values, you need to unsubscribe and the data emitting the values flows like </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">a stream.</span></span></p>
<p><span class="koboSpan" id="kobo.165.1">Observables come in two types: </span><em class="italic"><span class="koboSpan" id="kobo.166.1">hot and cold Observables</span></em><span class="koboSpan" id="kobo.167.1">. </span><strong class="bold"><span class="koboSpan" id="kobo.168.1">Cold Observables</span></strong><span class="koboSpan" id="kobo.169.1"> are unicast, meaning they start fresh for each subscriber. </span><span class="koboSpan" id="kobo.169.2">It’s like</span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.170.1"> a movie on Netflix; when someone starts the movie, the movie will start from the beginning. </span><span class="koboSpan" id="kobo.170.2">If someone else starts the same movie on another account or TV, the movie will also start from the beginning. </span><span class="koboSpan" id="kobo.170.3">Everyone watching gets their own unique viewing experience from the moment they </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">start watching.</span></span></p>
<p><span class="koboSpan" id="kobo.172.1">On the other hand, </span><strong class="bold"><span class="koboSpan" id="kobo.173.1">hot Observables</span></strong><span class="koboSpan" id="kobo.174.1"> are multicast, meaning there is one stream of data broadcasted to every subscriber. </span><span class="koboSpan" id="kobo.174.2">Hot </span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.175.1">Observables can be compared to live television. </span><span class="koboSpan" id="kobo.175.2">Different people can tune in to the live show (the data stream), but everything you already missed is gone and will not be replayed for you. </span><span class="koboSpan" id="kobo.175.3">Everyone watching experiences the same content simultaneously, even if they didn’t start watching from </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">the beginning.</span></span></p>
<p><span class="koboSpan" id="kobo.177.1">Now that you clearly understand Observables and know the difference between hot and cold Observables, let’s learn </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">about Observers.</span></span></p>
<h3><span class="koboSpan" id="kobo.179.1">Subscribing to Observables with Observers</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.180.1">Observers</span></strong><span class="koboSpan" id="kobo.181.1"> are the entities that subscribe to an Observable and receive the Observable values in the data stream. </span><span class="koboSpan" id="kobo.181.2">You can think</span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.182.1"> of the Observer as the person (or subscriber) watching </span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.183.1">a live show or putting on a Netflix movie. </span><span class="koboSpan" id="kobo.183.2">Subscribers have two tasks: subscribing to the streams they want to receive and unsubscribing from streams they do not want or need to </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">receive anymore.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">One of the most crucial parts is successfully unsubscribing from subscriptions the Observer doesn’t need anymore. </span><span class="koboSpan" id="kobo.185.2">Not unsubscribing Observables is probably the most considerable risk when using Observables in your code and is the most common source of problems. </span><span class="koboSpan" id="kobo.185.3">You will run into memory leaks if you don’t clean up your subscription correctly. </span><span class="koboSpan" id="kobo.185.4">Memory leaks will result in strange behavior and a slower application and can eventually crash your application if it runs out </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">of memory.</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">Let’s imagine that you have a subscription to a magazine that is delivered to your house every week. </span><span class="koboSpan" id="kobo.187.2">If you move to a new address, you need to </span><em class="italic"><span class="koboSpan" id="kobo.188.1">unsubscribe</span></em><span class="koboSpan" id="kobo.189.1"> from the subscription and create a </span><em class="italic"><span class="koboSpan" id="kobo.190.1">new subscription</span></em><span class="koboSpan" id="kobo.191.1"> on the new address. </span><span class="koboSpan" id="kobo.191.2">If you don’t unsubscribe from the old</span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.192.1"> address and only begin a new subscription for the new address, you will start to pay</span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.193.1"> double, and the magazine will be delivered to both addresses. </span><span class="koboSpan" id="kobo.193.2">If you keep repeating this process, you will eventually run out of money, and your life will crash. </span><span class="koboSpan" id="kobo.193.3">Within your applications, it’s the same, only you don’t pay with money but </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">with memory.</span></span></p>
<p><span class="koboSpan" id="kobo.195.1">When you create a subscription inside a component, you must unsubscribe when the component is destroyed. </span><span class="koboSpan" id="kobo.195.2">Otherwise, the subscription will keep running. </span><span class="koboSpan" id="kobo.195.3">The next time you open the same component, a second subscription starts because the old one is still running. </span><span class="koboSpan" id="kobo.195.4">As a result, all values will be received by two Observers. </span><span class="koboSpan" id="kobo.195.5">If you keep repeating this process, you’ll end up with many Observers receiving the same value while you only need a single Observer to receive the values. </span><span class="koboSpan" id="kobo.195.6">When there are too many Observers, the application will run out of memory to process all the values, and the app </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">will crash.</span></span></p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.197.1">Unsubscribing from Observables</span></h2>
<p><span class="koboSpan" id="kobo.198.1">Unsubscribing from Observables can be done in many different ways. </span><span class="koboSpan" id="kobo.198.2">Most commonly, in an Angular application, you can </span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.199.1">unsubscribe inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">ngOnDestroy</span></strong><span class="koboSpan" id="kobo.201.1"> life cycle hook. </span><span class="koboSpan" id="kobo.201.2">You can unsubscribe manually </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.203.1">
ngOnInit() {
  this.observable$.subscribe(…)
}
ngOnDestroy() {
  this.observable$.unsubscribe();
  this.observable$.complete();
}</span></pre> <p><span class="koboSpan" id="kobo.204.1">In the preceding code, we subscribed to an Observable inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">ngOnInit</span></strong><span class="koboSpan" id="kobo.206.1"> life cycle hook and manually unsubscribed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">ngOnDestroy</span></strong><span class="koboSpan" id="kobo.208.1"> life cycle hook by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">unsubscribe()</span></strong><span class="koboSpan" id="kobo.210.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">complete()</span></strong><span class="koboSpan" id="kobo.212.1"> methods on </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">the Observable.</span></span></p>
<p><span class="koboSpan" id="kobo.214.1">This approach may not be the best option when multiple Observables are inside your component. </span><span class="koboSpan" id="kobo.214.2">If you have five </span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.215.1">Observables, you must unsubscribe and complete all five Observables manually. </span><span class="koboSpan" id="kobo.215.2">Doing all subscriptions manually increases the risk of missing an Observable, and it will result in a large </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">ngOnDestroy</span></strong><span class="koboSpan" id="kobo.217.1"> method with a lot of repetitive </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">code inside.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">You also need a local property for all Observables, further polluting your file with boilerplate code. </span><span class="koboSpan" id="kobo.219.2">In that case, you would need to save the Observable subscription in a property so that you can unsubscribe from the subscription in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">ngOnDestroy</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.221.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.222.1">Another better option is to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">Subscription</span></strong><span class="koboSpan" id="kobo.224.1"> object and add all your subscriptions to this object by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">add()</span></strong><span class="koboSpan" id="kobo.226.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">Subscription</span></strong><span class="koboSpan" id="kobo.228.1"> object. </span><span class="koboSpan" id="kobo.228.2">In this case, you only have to unsubscribe from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">Subscription</span></strong><span class="koboSpan" id="kobo.230.1"> object, and it will unsubscribe and complete all subscriptions that have been added to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">Subscription</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.232.1"> object.</span></span></p>
<p><span class="koboSpan" id="kobo.233.1">Here’s an example of how you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">Subscription</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.235.1">object approach:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.236.1">
subscriptions = new </span><strong class="bold"><span class="koboSpan" id="kobo.237.1">Subscription</span></strong><span class="koboSpan" id="kobo.238.1">()
ngOnInit() {
  this.subscriptions.</span><strong class="bold"><span class="koboSpan" id="kobo.239.1">add</span></strong><span class="koboSpan" id="kobo.240.1">(this.observableA$.subscribe(…));
  this.subscriptions.</span><strong class="bold"><span class="koboSpan" id="kobo.241.1">add</span></strong><span class="koboSpan" id="kobo.242.1">(this.observableB$.subscribe(…));
}
ngOnDestroy() {
  this.subscriptions.unsubscribe();
}</span></pre> <p><span class="koboSpan" id="kobo.243.1">In the preceding code snippet, we created a </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">subscriptions</span></strong><span class="koboSpan" id="kobo.245.1"> property and assigned it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">Subscription</span></strong><span class="koboSpan" id="kobo.247.1"> object. </span><span class="koboSpan" id="kobo.247.2">Next, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">subscriptions</span></strong><span class="koboSpan" id="kobo.249.1"> property and added all the subscriptions to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">subscriptions</span></strong><span class="koboSpan" id="kobo.251.1"> property using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">add</span></strong><span class="koboSpan" id="kobo.253.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">Subscription</span></strong><span class="koboSpan" id="kobo.255.1"> class. </span><span class="koboSpan" id="kobo.255.2">Lastly, inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">ngOnDestroy</span></strong><span class="koboSpan" id="kobo.257.1">, we called the </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">unsubscribe()</span></strong><span class="koboSpan" id="kobo.259.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">subscriptions</span></strong><span class="koboSpan" id="kobo.261.1"> object, which will unsubscribe and complete all the </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">inner subscriptions.</span></span></p>
<p><span class="koboSpan" id="kobo.263.1">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">Subscription</span></strong><span class="koboSpan" id="kobo.265.1"> class is a good approach, but the syntax of adding the active subscriptions to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">Subscription</span></strong><span class="koboSpan" id="kobo.267.1"> class </span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.268.1">looks messy. </span><span class="koboSpan" id="kobo.268.2">When you start to use RxJS pipeable operators, there is an approach that is more in line with the rest of your code. </span><span class="koboSpan" id="kobo.268.3">We will discuss pipeable operators in more detail later in this section, but for now, I want to show you how you can use them to unsubscribe automatically from </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">your subscriptions.</span></span></p>
<h3><span class="koboSpan" id="kobo.270.1">Unsubscribing with the takeUntil() operator</span></h3>
<p><span class="koboSpan" id="kobo.271.1">First, we will take a look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">takeUntil()</span></strong><span class="koboSpan" id="kobo.273.1"> operator. </span><span class="koboSpan" id="kobo.273.2">You can add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">takeUntil()</span></strong><span class="koboSpan" id="kobo.275.1"> operator inside the RxJS pipe </span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.276.1">method, which is changed on your Observables. </span><span class="koboSpan" id="kobo.276.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">takeUntil()</span></strong><span class="koboSpan" id="kobo.278.1"> operator</span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.279.1"> unsubscribes your subscriptions automatically upon a trigger. </span><span class="koboSpan" id="kobo.279.2">This trigger is commonly an RxJS </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">Subject</span></strong><span class="koboSpan" id="kobo.281.1"> (we will discuss </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">Subject</span></strong><span class="koboSpan" id="kobo.283.1"> in more detail later in this section). </span><span class="koboSpan" id="kobo.283.2">When we call the next method on this </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">Subject</span></strong><span class="koboSpan" id="kobo.285.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">takeUntil()</span></strong><span class="koboSpan" id="kobo.287.1"> operator will be triggered and unsubscribe from </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">the subscription:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.289.1">
private </span><strong class="bold"><span class="koboSpan" id="kobo.290.1">destroy$</span></strong><span class="koboSpan" id="kobo.291.1"> = new </span><strong class="bold"><span class="koboSpan" id="kobo.292.1">Subject</span></strong><span class="koboSpan" id="kobo.293.1">&lt;void&gt;();
ngOnInit() {
  this.observable$.pipe(</span><strong class="bold"><span class="koboSpan" id="kobo.294.1">takeUntil</span></strong><span class="koboSpan" id="kobo.295.1">(this.destroy$))
  .subscribe(……)
}
ngOnDestroy() {
  </span><strong class="bold"><span class="koboSpan" id="kobo.296.1">this.destroy$.next();</span></strong><span class="koboSpan" id="kobo.297.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.298.1">this.destroy$.complete();</span></strong><span class="koboSpan" id="kobo.299.1">
}</span></pre> <p><span class="koboSpan" id="kobo.300.1">In the preceding example, we created a </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">Subject</span></strong><span class="koboSpan" id="kobo.302.1"> Observable and named it </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">destroy$</span></strong><span class="koboSpan" id="kobo.304.1">. </span><span class="koboSpan" id="kobo.304.2">Next, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">pipe()</span></strong><span class="koboSpan" id="kobo.306.1"> function on our Observable, and inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">pipe()</span></strong><span class="koboSpan" id="kobo.308.1"> function, we added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">takeUntil()</span></strong><span class="koboSpan" id="kobo.310.1"> operator. </span><span class="koboSpan" id="kobo.310.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">takeUntil()</span></strong><span class="koboSpan" id="kobo.312.1"> operator received the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">destroy$</span></strong><span class="koboSpan" id="kobo.314.1"> property as a parameter and will be triggered once we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">next()</span></strong><span class="koboSpan" id="kobo.316.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">destroy$</span></strong><span class="koboSpan" id="kobo.318.1"> property. </span><span class="koboSpan" id="kobo.318.2">Lastly, inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">ngOnDestroy</span></strong><span class="koboSpan" id="kobo.320.1"> life cycle</span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.321.1"> method, we called the </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">next()</span></strong><span class="koboSpan" id="kobo.323.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">destroy$</span></strong><span class="koboSpan" id="kobo.325.1"> property and finished by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">complete()</span></strong><span class="koboSpan" id="kobo.327.1"> method to complete </span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.328.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">destroy$</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.330.1">Observable itself.</span></span></p>
<p><span class="koboSpan" id="kobo.331.1">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">takeUntil()</span></strong><span class="koboSpan" id="kobo.333.1"> operator is the preferred solution for many Angular developers to unsubscribe. </span><span class="koboSpan" id="kobo.333.2">This is because it works perfectly well in combination with the RxJS </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">pipe</span></strong><span class="koboSpan" id="kobo.335.1"> function and other pipeable operators. </span><span class="koboSpan" id="kobo.335.2">There is one last option to unsubscribe that I want to show: the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">takeUntilDestroyed()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.337.1"> operator.</span></span></p>
<h3><span class="koboSpan" id="kobo.338.1">Unsubscribing with the takeUntilDestroyed() operator</span></h3>
<p><span class="koboSpan" id="kobo.339.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">takeUntilDestroyed()</span></strong><span class="koboSpan" id="kobo.341.1"> operator was</span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.342.1"> added by Angular in version 16. </span><span class="koboSpan" id="kobo.342.2">It can be used to automatically unsubscribe when the </span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.343.1">component is destroyed. </span><span class="koboSpan" id="kobo.343.2">When you declare your subscription inside the injection context (inside the constructor or where you declare your properties), you only have to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">takeUntilDestroyed()</span></strong><span class="koboSpan" id="kobo.345.1"> operator, and it will manage everything </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">for you:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.347.1">
data = observable$.pipe(</span><strong class="bold"><span class="koboSpan" id="kobo.348.1">takeUntilDestroyed()</span></strong><span class="koboSpan" id="kobo.349.1">).subscribe(…);</span></pre> <p><span class="koboSpan" id="kobo.350.1">When you declare the subscription in another place, such as inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">ngOnInit</span></strong><span class="koboSpan" id="kobo.352.1">, you must provide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">takeUntilDestroyed()</span></strong><span class="koboSpan" id="kobo.354.1"> operator with a reference, </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">DestroyRef</span></strong><span class="koboSpan" id="kobo.356.1">. </span><span class="koboSpan" id="kobo.356.2">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">DestroyRef</span></strong><span class="koboSpan" id="kobo.358.1"> is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">ngOnDestroy</span></strong><span class="koboSpan" id="kobo.360.1"> life cycle in the form of </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">an injectable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.362.1">
protected readonly destroy = inject(</span><strong class="bold"><span class="koboSpan" id="kobo.363.1">DestroyRef</span></strong><span class="koboSpan" id="kobo.364.1">);
ngOnInit() {
  this.observable$.pipe(</span><strong class="bold"><span class="koboSpan" id="kobo.365.1">takeUntilDestroyed(this.destroy)</span></strong><span class="koboSpan" id="kobo.366.1">).subscribe(…);
}</span></pre> <p><span class="koboSpan" id="kobo.367.1">As you can see, we created a property and assigned it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">DestroyRef</span></strong><span class="koboSpan" id="kobo.369.1">. </span><span class="koboSpan" id="kobo.369.2">We add this property as a function parameter to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">takeUntilDestroyed()</span></strong><span class="koboSpan" id="kobo.371.1"> operator. </span><span class="koboSpan" id="kobo.371.2">That is all you need to do, and it will unsubscribe and complete your </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">subscriptions automatically.</span></span></p>
<p><span class="koboSpan" id="kobo.373.1">You now know why it’s essential to </span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.374.1">unsubscribe from Observables and how to do so using different approaches. </span><span class="koboSpan" id="kobo.374.2">Now, we will move</span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.375.1"> on to the next major concept of </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">RxJS: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">Subject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.379.1">Using special Observables – RxJS Subjects</span></h3>
<p><span class="koboSpan" id="kobo.380.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.381.1">RxJS Subject</span></strong><span class="koboSpan" id="kobo.382.1"> is a special type of Observable. </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">Subject</span></strong><span class="koboSpan" id="kobo.384.1"> Observables are </span><strong class="bold"><span class="koboSpan" id="kobo.385.1">multicast Observables</span></strong><span class="koboSpan" id="kobo.386.1">, allowing you to </span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.387.1">emit values to multiple Observers simultaneously. </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">Subject</span></strong><span class="koboSpan" id="kobo.389.1"> Observables are like </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">EventEmitter</span></strong><span class="koboSpan" id="kobo.391.1"> Observables, which maintain a registry of </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">all</span></span><span class="No-Break"><a id="_idIndexMarker652"/></span><span class="No-Break"><span class="koboSpan" id="kobo.393.1"> listeners.</span></span></p>
<p><span class="koboSpan" id="kobo.394.1">Every </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">Subject</span></strong><span class="koboSpan" id="kobo.396.1"> is an Observable, meaning you can subscribe to </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">Subject</span></strong><span class="koboSpan" id="kobo.398.1"> to receive the values it emits. </span><span class="koboSpan" id="kobo.398.2">Each </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">Subject</span></strong><span class="koboSpan" id="kobo.400.1"> is also an internal Observer object with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">next()</span></strong><span class="koboSpan" id="kobo.402.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">error()</span></strong><span class="koboSpan" id="kobo.404.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">complete()</span></strong><span class="koboSpan" id="kobo.406.1"> methods. </span><span class="koboSpan" id="kobo.406.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">next()</span></strong><span class="koboSpan" id="kobo.408.1"> method is called to emit the next value in the data stream, </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">error()</span></strong><span class="koboSpan" id="kobo.410.1"> is called automatically when an error occurs, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">complete()</span></strong><span class="koboSpan" id="kobo.412.1"> can be called to complete the </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">data stream.</span></span></p>
<p><span class="koboSpan" id="kobo.414.1">Within RxJS, there are four different </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">Subjects</span></strong><span class="koboSpan" id="kobo.416.1">. </span><span class="koboSpan" id="kobo.416.2">Let’s take </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">a look.</span></span></p>
<h4><span class="koboSpan" id="kobo.418.1">Subject</span></h4>
<p><span class="koboSpan" id="kobo.419.1">This is the basic RxJS </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">Subject</span></strong><span class="koboSpan" id="kobo.421.1"> type. </span><span class="koboSpan" id="kobo.421.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">Subject</span></strong><span class="koboSpan" id="kobo.423.1"> class allows you to create a hot Observable data stream. </span><span class="koboSpan" id="kobo.423.2">You can emit a </span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.424.1">new value using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">next()</span></strong><span class="koboSpan" id="kobo.426.1"> method; the </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">Subject</span></strong><span class="koboSpan" id="kobo.428.1"> class has no initial value or memory of the values that have already been emitted. </span><span class="koboSpan" id="kobo.428.2">Subscribers will only receive values that are emitted after they are subscribed; anything emitted before that point will not </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">be received:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.430.1">
const subject = </span><strong class="bold"><span class="koboSpan" id="kobo.431.1">new Subject&lt;number&gt;()</span></strong><span class="koboSpan" id="kobo.432.1">;
subject.subscribe({next: (v) =&gt; console.log(`A: ${v}`)});
subject.</span><strong class="bold"><span class="koboSpan" id="kobo.433.1">next</span></strong><span class="koboSpan" id="kobo.434.1">(1);
subject.subscribe({next: (v) =&gt; console.log(`B: ${v}`)});
subject.</span><strong class="bold"><span class="koboSpan" id="kobo.435.1">next</span></strong><span class="koboSpan" id="kobo.436.1">(2);
// Logs:
// A:1, A:2, B:2</span></pre> <p><span class="koboSpan" id="kobo.437.1">As shown in the preceding example, we use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">Subject</span></strong><span class="koboSpan" id="kobo.439.1"> class to emit two values (</span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">1</span></strong><span class="koboSpan" id="kobo.441.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">2</span></strong><span class="koboSpan" id="kobo.443.1">). </span><span class="koboSpan" id="kobo.443.2">The first value is emitted after the first subscriber (</span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">A</span></strong><span class="koboSpan" id="kobo.445.1">), and the second value is emitted after both subscribers </span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.446.1">have subscribed. </span><span class="koboSpan" id="kobo.446.2">Because of this, subscriber </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">A</span></strong><span class="koboSpan" id="kobo.448.1"> receives both values, while subscriber </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">B</span></strong><span class="koboSpan" id="kobo.450.1"> only receives the </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">second value.</span></span></p>
<p><span class="koboSpan" id="kobo.452.1">A good use case for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">Subject</span></strong><span class="koboSpan" id="kobo.454.1"> class is when multiple Observers must respond to a specific event, such as a selection or a changing toggle. </span><span class="koboSpan" id="kobo.454.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">Subject</span></strong><span class="koboSpan" id="kobo.456.1"> class can be used if components only have to react to the change if the components are active during the event. </span><span class="koboSpan" id="kobo.456.2">Now that you know how </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">Subject</span></strong><span class="koboSpan" id="kobo.458.1"> works, let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">examine </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">BehaviorSubject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">.</span></span></p>
<h4><span class="koboSpan" id="kobo.462.1">BehaviorSubject</span></h4>
<p><span class="koboSpan" id="kobo.463.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.465.1"> class extends </span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.466.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">Subject</span></strong><span class="koboSpan" id="kobo.468.1"> class and has two main differences from the regular </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">Subject</span></strong><span class="koboSpan" id="kobo.470.1">. </span><span class="koboSpan" id="kobo.470.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.472.1"> class receives an initial value and stores the last emitted value. </span><span class="koboSpan" id="kobo.472.2">When a subscriber subscribes to </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.474.1">, the subscriber will immediately receive the last emitted value. </span><span class="koboSpan" id="kobo.474.2">When no value is emitted, the subscriber will receive the initial </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">value instead.</span></span></p>
<p><span class="koboSpan" id="kobo.476.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">Subject</span></strong><span class="koboSpan" id="kobo.478.1"> class is good for emitting values that have to notify subscribers when an event happens, such as when multiple Observers need to react when something is added. </span><span class="koboSpan" id="kobo.478.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.480.1"> class, on the other hand, is well suited for values with state, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">lastAddedItem</span></strong><span class="koboSpan" id="kobo.482.1">, where subscribers receive the last added item. </span><span class="koboSpan" id="kobo.482.2">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">lastAddedItem</span></strong><span class="koboSpan" id="kobo.484.1"> will always emit the last item that has been added. </span><span class="koboSpan" id="kobo.484.2">In contrast, an </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">itemAdded</span></strong><span class="koboSpan" id="kobo.486.1"> event using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">Subject</span></strong><span class="koboSpan" id="kobo.488.1"> class will only notify subscribed Observers the moment the item is added and not after </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">the fact:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.490.1">
const subject = </span><strong class="bold"><span class="koboSpan" id="kobo.491.1">new BehaviorSubject(0)</span></strong><span class="koboSpan" id="kobo.492.1">; //initial value 0
subject.subscribe({next: (v) =&gt; console.log(`A: ${v}`)});
subject.</span><strong class="bold"><span class="koboSpan" id="kobo.493.1">next</span></strong><span class="koboSpan" id="kobo.494.1">(1);
subject.subscribe({next: (v) =&gt; console.log(`B: ${v}`)});
subject.</span><strong class="bold"><span class="koboSpan" id="kobo.495.1">next</span></strong><span class="koboSpan" id="kobo.496.1">(2);
// Logs:
// A:0, A:1, B:1, A:2, B:2</span></pre> <p><span class="koboSpan" id="kobo.497.1">As you can see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.499.1"> class receives an initial value; in our case, the initial value is </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">0</span></strong><span class="koboSpan" id="kobo.501.1">. </span><span class="koboSpan" id="kobo.501.2">When </span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.502.1">subscriber </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">A</span></strong><span class="koboSpan" id="kobo.504.1"> subscribes to </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.506.1">, the subscriber immediately gets the initial value, </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">0</span></strong><span class="koboSpan" id="kobo.508.1">, and logs the value. </span><span class="koboSpan" id="kobo.508.2">After subscriber </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">A</span></strong><span class="koboSpan" id="kobo.510.1"> has subscribed, we emit a new value: </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">1</span></strong><span class="koboSpan" id="kobo.512.1">. </span><span class="koboSpan" id="kobo.512.2">This new value is received and logged by </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">subscriber </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">A</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.516.1">Next, subscriber </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">B</span></strong><span class="koboSpan" id="kobo.518.1"> subscribes to </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.520.1">. </span><span class="koboSpan" id="kobo.520.2">Because </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">1</span></strong><span class="koboSpan" id="kobo.522.1"> is the last emitted value, subscriber </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">B</span></strong><span class="koboSpan" id="kobo.524.1"> gets and logs it. </span><span class="koboSpan" id="kobo.524.2">Lastly, we emit a new value, </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">2</span></strong><span class="koboSpan" id="kobo.526.1">, which is received and logged by subscribers </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">A</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.528.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">B</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.531.1">Now that you know how </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.533.1"> works and how it differs from the regular </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">Subject</span></strong><span class="koboSpan" id="kobo.535.1">, let’s learn </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">about </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">ReplaySubject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">.</span></span></p>
<h4><span class="koboSpan" id="kobo.539.1">ReplaySubject</span></h4>
<p><span class="koboSpan" id="kobo.540.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">ReplaySubject</span></strong><span class="koboSpan" id="kobo.542.1"> class is also an</span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.543.1"> extension of the regular </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">Subject</span></strong><span class="koboSpan" id="kobo.545.1"> class and behaves a bit like </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.547.1"> with some differences. </span><span class="koboSpan" id="kobo.547.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">ReplaySubject</span></strong><span class="koboSpan" id="kobo.549.1"> class also stores values, just like </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.551.1">, but unlike </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.553.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">ReplaySubject</span></strong><span class="koboSpan" id="kobo.555.1"> can store more than one value and doesn’t have an </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">initial value.</span></span></p>
<p><span class="koboSpan" id="kobo.557.1">Instead of an initial value, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">ReplaySubject</span></strong><span class="koboSpan" id="kobo.559.1"> class receives a buffer size as a parameter. </span><span class="koboSpan" id="kobo.559.2">The buffer size determines how many values the </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">ReplaySubject</span></strong><span class="koboSpan" id="kobo.561.1"> class stores and shares with a new subscriber upon subscription. </span><span class="koboSpan" id="kobo.561.2">Besides the buffer size, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">ReplaySubject</span></strong><span class="koboSpan" id="kobo.563.1"> class can take a second parameter to determine how long the </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">ReplaySubject</span></strong><span class="koboSpan" id="kobo.565.1"> class will store the emitted values in the buffer </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">ReplaySubject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.569.1">
const subject = </span><strong class="bold"><span class="koboSpan" id="kobo.570.1">new ReplaySubject(100, 500)</span></strong><span class="koboSpan" id="kobo.571.1">;
subject.subscribe({
  next: (v) =&gt; console.log(`A: ${v}`),
});
let i = 1;
setInterval(() =&gt; subject.next(i++), 200);
setTimeout(() =&gt; {
  subject.subscribe({
    next: (v) =&gt; console.log(`B: ${v}`),
  });
}, 1000);
// Logs
// A:1, A:2, A:3, A:4, A:5, B:3, B:4, B:5, A:6, B:6
// ...</span></pre> <p><span class="koboSpan" id="kobo.572.1">In the preceding example, we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">ReplaySubject</span></strong><span class="koboSpan" id="kobo.574.1"> class with a buffer of </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">100</span></strong><span class="koboSpan" id="kobo.576.1"> and a time window of </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">500</span></strong><span class="koboSpan" id="kobo.578.1"> milliseconds. </span><span class="koboSpan" id="kobo.578.2">Subscriber </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">A</span></strong><span class="koboSpan" id="kobo.580.1"> subscribes before we emit the first value. </span><span class="koboSpan" id="kobo.580.2">Next, we create an interval</span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.581.1"> that emits a new number every 200 milliseconds. </span><span class="koboSpan" id="kobo.581.2">As a result, subscriber </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">A</span></strong><span class="koboSpan" id="kobo.583.1"> will receive and log a new value every </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">200 milliseconds.</span></span></p>
<p><span class="koboSpan" id="kobo.585.1">Lastly, we create a timeout of </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">1</span></strong><span class="koboSpan" id="kobo.587.1"> second and add the second subscriber. </span><span class="koboSpan" id="kobo.587.2">Because we have a time window of </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">500</span></strong><span class="koboSpan" id="kobo.589.1"> milliseconds, subscriber </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">B</span></strong><span class="koboSpan" id="kobo.591.1"> will immediately receive all values that are emitted after the first </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">500</span></strong><span class="koboSpan" id="kobo.593.1"> milliseconds – that is, the timeout of </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">1</span></strong><span class="koboSpan" id="kobo.595.1"> second that has passed minus the time window of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">ReplaySubject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.597.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.598.1">As a result, subscriber </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">A</span></strong><span class="koboSpan" id="kobo.600.1"> logs </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">1</span></strong><span class="koboSpan" id="kobo.602.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">5</span></strong><span class="koboSpan" id="kobo.604.1">; after 1 second, subscriber </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">B</span></strong><span class="koboSpan" id="kobo.606.1"> joins and immediately receives values </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">3</span></strong><span class="koboSpan" id="kobo.608.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">4</span></strong><span class="koboSpan" id="kobo.610.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">5</span></strong><span class="koboSpan" id="kobo.612.1">. </span><span class="koboSpan" id="kobo.612.2">After subscriber </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">B</span></strong><span class="koboSpan" id="kobo.614.1"> receives the replay values, both subscribers receive all values emitted after </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">that point.</span></span></p>
<h4><span class="koboSpan" id="kobo.616.1">AsyncSubject</span></h4>
<p><span class="koboSpan" id="kobo.617.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">AsyncSubject</span></strong><span class="koboSpan" id="kobo.619.1"> class is also an extension of the regular </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">Subject</span></strong><span class="koboSpan" id="kobo.621.1"> class. </span><span class="koboSpan" id="kobo.621.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">AsyncSubject</span></strong><span class="koboSpan" id="kobo.623.1"> class only emits the last </span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.624.1">value to all its subscribers and only when the Observable data stream </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">is completed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.626.1">
const subject = </span><strong class="bold"><span class="koboSpan" id="kobo.627.1">new AsyncSubject()</span></strong><span class="koboSpan" id="kobo.628.1">;
subject.subscribe({
 next: (v) =&gt; console.log(`A: ${v}`),
});
subject.</span><strong class="bold"><span class="koboSpan" id="kobo.629.1">next</span></strong><span class="koboSpan" id="kobo.630.1">(1);
subject.</span><strong class="bold"><span class="koboSpan" id="kobo.631.1">next</span></strong><span class="koboSpan" id="kobo.632.1">(2);
subject.subscribe({
  next: (v) =&gt; console.log(`B: ${v}`),
});
subject.</span><strong class="bold"><span class="koboSpan" id="kobo.633.1">next</span></strong><span class="koboSpan" id="kobo.634.1">(3);
subject.</span><strong class="bold"><span class="koboSpan" id="kobo.635.1">complete</span></strong><span class="koboSpan" id="kobo.636.1">();
// Logs:
// A:3, B3</span></pre> <p><span class="koboSpan" id="kobo.637.1">In the preceding example, you can see that </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">AsyncSubject</span></strong><span class="koboSpan" id="kobo.639.1"> only emitted the last value that was emitted before we completed the data stream. </span><span class="koboSpan" id="kobo.639.2">First, subscriber </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">A</span></strong><span class="koboSpan" id="kobo.641.1"> subscribed to </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">AsyncSubject</span></strong><span class="koboSpan" id="kobo.643.1">. </span><span class="koboSpan" id="kobo.643.2">Next, we emitted two values, and then subscriber </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">B</span></strong><span class="koboSpan" id="kobo.645.1"> subscribed to </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">AsyncSubject</span></strong><span class="koboSpan" id="kobo.647.1">. </span><span class="koboSpan" id="kobo.647.2">Lastly, we emitted the third value and completed the Observable stream. </span><span class="koboSpan" id="kobo.647.3">After we complete the stream, the last value is emitted to and logged by subscribers </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">A</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.649.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">B</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.652.1">Now, you know about Observables, Observers, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">Subjects</span></strong><span class="koboSpan" id="kobo.654.1">. </span><span class="koboSpan" id="kobo.654.2">You know that there are hot and cold Observables and the difference between the two. </span><span class="koboSpan" id="kobo.654.3">You also learned that Observers subscribe to Observables and how to unsubscribe from Observable data streams. </span><span class="koboSpan" id="kobo.654.4">You discovered that </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">Subjects</span></strong><span class="koboSpan" id="kobo.656.1"> is a special kind of Observable that’s used to multicast values and that they can emit values using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">next()</span></strong><span class="koboSpan" id="kobo.658.1"> method. </span><span class="koboSpan" id="kobo.658.2">Lastly, you learned about the four different </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">Subject</span></strong><span class="koboSpan" id="kobo.660.1"> types and saw how you can visualize their differences. </span><span class="koboSpan" id="kobo.660.2">Next, we will learn </span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.661.1">about the last major concept in </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">RxJS: operators.</span></span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.663.1">Using and creating RxJS operators</span></h2>
<p><span class="koboSpan" id="kobo.664.1">In this section, you will learn about </span><strong class="bold"><span class="koboSpan" id="kobo.665.1">RxJS operators</span></strong><span class="koboSpan" id="kobo.666.1">. </span><span class="koboSpan" id="kobo.666.2">You will learn what operators are, what types of operators there</span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.667.1"> are, and how to use some of the most commonly used operators in the RxJS library. </span><span class="koboSpan" id="kobo.667.2">You will also learn how to create your own RxJS operators and combine multiple operators into a </span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">single operator.</span></span></p>
<p><span class="koboSpan" id="kobo.669.1">While Observables are the foundation of the RxJS library, operators are what make the library so useful and powerful for handling Observable data streams. </span><span class="koboSpan" id="kobo.669.2">Operators allow you to easily compose and handle complex asynchronous </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">code declaratively.</span></span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.671.1">Types of operators</span></h2>
<p><span class="koboSpan" id="kobo.672.1">RxJS operators come in two </span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.673.1">different types: creational and </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">pipeable operators</span></span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.676.1">In short, creational operators can be used to create new Observables with a standalone function, whereas pipeable  operators can be used to modify the Observable stream. </span><span class="koboSpan" id="kobo.676.2">Let’s explore both in more detail, starting with </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">creational operators.</span></span></p>
<h3><span class="koboSpan" id="kobo.678.1">Creational operators</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.679.1">Creational operators</span></strong><span class="koboSpan" id="kobo.680.1"> can be used to create a simple Observable and to create a new Observable by combining multiple </span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.681.1">existing Observables. </span><span class="koboSpan" id="kobo.681.2">The simplest and most straightforward example of a creational operator is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">of()</span></strong><span class="koboSpan" id="kobo.683.1"> operator. </span><span class="koboSpan" id="kobo.683.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">of()</span></strong><span class="koboSpan" id="kobo.685.1"> operator takes in</span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.686.1"> one or more comma-separated values and turns these values into an Observable stream that emits one value after </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">the other:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.688.1">of(1, 2, 3)</span></strong><span class="koboSpan" id="kobo.689.1">.subscribe((v) =&gt; console.log(`value: ${v}`));</span></pre> <p><span class="koboSpan" id="kobo.690.1">In the preceding example, we declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">of()</span></strong><span class="koboSpan" id="kobo.692.1"> operator with three values: </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">1</span></strong><span class="koboSpan" id="kobo.694.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">2</span></strong><span class="koboSpan" id="kobo.696.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">3</span></strong><span class="koboSpan" id="kobo.698.1">. </span><span class="koboSpan" id="kobo.698.2">We subscribed to the Observable stream that was created with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">of()</span></strong><span class="koboSpan" id="kobo.700.1"> operator and logged the values. </span><span class="koboSpan" id="kobo.700.2">This subscription will result in three separate logs: </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">value: 1</span></strong><span class="koboSpan" id="kobo.702.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">value: 2</span></strong><span class="koboSpan" id="kobo.704.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">value: 3</span></strong><span class="koboSpan" id="kobo.706.1">. </span><span class="koboSpan" id="kobo.706.2">As you can see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">of()</span></strong><span class="koboSpan" id="kobo.708.1"> operator is a pretty simple and straightforward way to create an </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">Observable stream.</span></span></p>
<p><span class="koboSpan" id="kobo.710.1">Another commonly used creational operator is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">from()</span></strong><span class="koboSpan" id="kobo.712.1"> operator. </span><span class="koboSpan" id="kobo.712.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">from()</span></strong><span class="koboSpan" id="kobo.714.1"> operator creates an Observable stream of an array, iterable, Promise, or strings. </span><span class="koboSpan" id="kobo.714.2">If you transform a string into an </span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.715.1">Observable stream using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">from()</span></strong><span class="koboSpan" id="kobo.717.1"> operator, the string will be emitted character by </span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.718.1">character. </span><span class="koboSpan" id="kobo.718.2">Here’s an example of using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">from()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.720.1"> operator:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.721.1">from([1, 2, 3, 4, 5])</span></strong><span class="koboSpan" id="kobo.722.1">.subscribe(val =&gt; console.log(val));
//output: 1,2,3,4,5
</span><strong class="bold"><span class="koboSpan" id="kobo.723.1">from(new Promise(resolve =&gt; resolve('Promise to Observbale!')))</span></strong><span class="koboSpan" id="kobo.724.1">.subscribe(val =&gt; console.log(val));
//output: Promise to Observbale!</span></pre> <p><span class="koboSpan" id="kobo.725.1">In the preceding example, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">from()</span></strong><span class="koboSpan" id="kobo.727.1"> operator to create an Observable stream from an array and </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">a Promise.</span></span></p>
<p><span class="koboSpan" id="kobo.729.1">Another useful creational operator is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">fromEvent()</span></strong><span class="koboSpan" id="kobo.731.1"> operator. </span><span class="koboSpan" id="kobo.731.2">The</span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1"> fromEvent()</span></strong><span class="koboSpan" id="kobo.733.1"> operator creates an Observable from an event target such as </span><em class="italic"><span class="koboSpan" id="kobo.734.1">click</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.735.1">or </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.736.1">hover</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.738.1">fromEvent</span></strong><span class="koboSpan" id="kobo.739.1">(document, 'click')</span></pre> <p><span class="koboSpan" id="kobo.740.1">As you can see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">fromEvent()</span></strong><span class="koboSpan" id="kobo.742.1"> operator takes two arguments. </span><span class="koboSpan" id="kobo.742.2">The first is the target element – in our case, we took the document. </span><span class="koboSpan" id="kobo.742.3">Then, you declared the event you wanted to listen for; in our example, this is a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">click</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.744.1"> event.</span></span></p>
<p><span class="koboSpan" id="kobo.745.1">With that, you’ve learned how to create a new Observable stream from scratch using creational operators. </span><span class="koboSpan" id="kobo.745.2">Next, you will learn how to create a new Observable stream by combining multiple existing </span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">Observable streams.</span></span></p>
<h4><span class="koboSpan" id="kobo.747.1">Creating an Observable from multiple Observable streams</span></h4>
<p><span class="koboSpan" id="kobo.748.1">As your Angular applications grow and the state</span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.749.1"> of these applications becomes more complex, you often find yourself in a situation where you need the result of multiple Observable streams simultaneously. </span><span class="koboSpan" id="kobo.749.2">When you need the result from various Observable streams, you may be tempted to create nested subscriptions, but this isn’t a good solution since nested subscriptions can lead to strange behavior and </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">hard-to-debug bugs.</span></span></p>
<p><span class="koboSpan" id="kobo.751.1">In scenarios where you need the result of multiple Observables, you can use creational RxJS operators that focus on combining various Observables into a new single Observable stream. </span><span class="koboSpan" id="kobo.751.2">When using these operators, the combined Observables are referred to as </span><strong class="bold"><span class="koboSpan" id="kobo.752.1">inner Observables</span></strong><span class="koboSpan" id="kobo.753.1">, and the</span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.754.1"> new combined Observable is called the </span><strong class="bold"><span class="koboSpan" id="kobo.755.1">outer Observable</span></strong><span class="koboSpan" id="kobo.756.1">. </span><span class="koboSpan" id="kobo.756.2">Let’s examine some </span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.757.1">of the most commonly used operators that create a new Observable based on multiple other Observables, starting with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">combineLatest()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.759.1"> operator.</span></span></p>
<p><span class="koboSpan" id="kobo.760.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">combineLatest()</span></strong><span class="koboSpan" id="kobo.762.1"> operator is</span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.763.1"> best used when you have multiple long-lived Observables and need the values of all these Observables to construct the object or perform the logic you want. </span><span class="koboSpan" id="kobo.763.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">combineLatest()</span></strong><span class="koboSpan" id="kobo.765.1"> operator will only output its first value when all of its inner Observables output at least one value; after that, </span><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">combineLatest()</span></strong><span class="koboSpan" id="kobo.767.1"> outputs another value each time one of the inner Observables emits a new value. </span><span class="koboSpan" id="kobo.767.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">combineLatest()</span></strong><span class="koboSpan" id="kobo.769.1"> operator will always use the last emitted value of all its </span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">inner Observables:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.771.1">
const amountExclVat = of(100);
const vatPercentage = of(20);
</span><strong class="bold"><span class="koboSpan" id="kobo.772.1">combineLatest([amountExclVat, vatPercentage])</span></strong><span class="koboSpan" id="kobo.773.1">.subscribe({
  next: ([amount, percentage]) =&gt; {
    console.log(‹Total:', amount * (percentage / 100 + 1));
  }
});</span></pre> <p><span class="koboSpan" id="kobo.774.1">As you can see, we provided </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">combineLatest()</span></strong><span class="koboSpan" id="kobo.776.1"> with an array containing two Observables: one Observable with the amount excluding VAT and another Observable containing the VAT percentage. </span><span class="koboSpan" id="kobo.776.2">We need both Observable values to log the amount, including VAT. </span><span class="koboSpan" id="kobo.776.3">Instead of creating a nested subscription, we handled this </span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">combineLatest()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.780.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">combineLatest()</span></strong><span class="koboSpan" id="kobo.782.1"> subscription, we also declare an array for the value of the Observable stream. </span><span class="koboSpan" id="kobo.782.2">We used </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">amount</span></strong><span class="koboSpan" id="kobo.784.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">percentage</span></strong><span class="koboSpan" id="kobo.786.1"> as values, but you can name these properties however you like. </span><span class="koboSpan" id="kobo.786.2">Alternatively, you can use a different syntax and provide an object to </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">combineLatest()</span></strong><span class="koboSpan" id="kobo.788.1"> instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">an array:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.790.1">
combineLatest({ amount: amountExclVat, percentage: vatPercentage }).subscribe({
  next: (data) =&gt; { console.log('Total:', data.amount * (data.percentage / 100 + 1)) }
});</span></pre> <p><span class="koboSpan" id="kobo.791.1">Now, let’s consider another</span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.792.1"> example where we emit different values over time so that you get a better understanding of how </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">combineLatest()</span></strong><span class="koboSpan" id="kobo.794.1"> works and when and what values it </span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">will emit:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.796.1">
const a = new Subject();
const b = new Subject();
combineLatest([a, b]).subscribe({
  next: ([a, b]) =&gt; { console.log(‹data›, a, b) }
});
a.next(1);
setTimeout(() =&gt; { b.next(2) }, 5000);
setTimeout(() =&gt; { a.next(10) }, 10000);</span></pre> <p><span class="koboSpan" id="kobo.797.1">In the preceding example, it takes 5 seconds before the </span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">combineLatest()</span></strong><span class="koboSpan" id="kobo.799.1"> operator emits the first value; this is because, after 5 seconds, both Observable </span><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">a</span></strong><span class="koboSpan" id="kobo.801.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">b</span></strong><span class="koboSpan" id="kobo.803.1"> have emitted a value. </span><span class="koboSpan" id="kobo.803.2">Even though Observable A directly emits a value, </span><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">combineLatest()</span></strong><span class="koboSpan" id="kobo.805.1"> will only emit a value after both A and B have emitted at least </span><span class="No-Break"><span class="koboSpan" id="kobo.806.1">one value.</span></span></p>
<p><span class="koboSpan" id="kobo.807.1">After 5 seconds have passed and both Observables have emitted a value, </span><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">combineLatest()</span></strong><span class="koboSpan" id="kobo.809.1"> will emit a value, and we log </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">data: 1, 2</span></strong><span class="koboSpan" id="kobo.811.1">. </span><span class="koboSpan" id="kobo.811.2">After both Observables emit a value, </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">combineLatest()</span></strong><span class="koboSpan" id="kobo.813.1"> will emit a new value whenever one of its Observables emits a new value. </span><span class="koboSpan" id="kobo.813.2">So, when Observable A emits a new value after another 5 seconds have passed, we log </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">data: 10, 2</span></strong><span class="koboSpan" id="kobo.815.1"> inside the subscription </span><span class="No-Break"><span class="koboSpan" id="kobo.816.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">combineLatest()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.818.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.819.1">If, for example, you first emitted two values with Observable A (</span><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">1</span></strong><span class="koboSpan" id="kobo.821.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">10</span></strong><span class="koboSpan" id="kobo.823.1">) and then emitted a value with Observable B (</span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">2</span></strong><span class="koboSpan" id="kobo.825.1">), </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">combineLatest()</span></strong><span class="koboSpan" id="kobo.827.1"> will only emit one value, </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">data: 10, 2</span></strong><span class="koboSpan" id="kobo.829.1">. </span><span class="koboSpan" id="kobo.829.2">This is the case because both A and B need to emit a value before </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">combineLatest()</span></strong><span class="koboSpan" id="kobo.831.1"> starts </span><span class="No-Break"><span class="koboSpan" id="kobo.832.1">emitting values.</span></span></p>
<p><span class="koboSpan" id="kobo.833.1">Now that you have a good idea of how </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">combineLatest()</span></strong><span class="koboSpan" id="kobo.835.1"> works and how to use RxJS to create a new Observable based on multiple Observables, let’s explore other operators that create an</span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.836.1"> Observable from </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">multiple Observables:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.838.1">forkJoin</span></strong><span class="koboSpan" id="kobo.839.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">forkJoin()</span></strong><span class="koboSpan" id="kobo.841.1"> operator is best used when you have multiple Observables and are only interested in the</span><a id="_idIndexMarker673"/><span class="koboSpan" id="kobo.842.1"> final value of each of these Observables. </span><span class="koboSpan" id="kobo.842.2">This means that each Observable has to be completed before </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">forkJoin()</span></strong><span class="koboSpan" id="kobo.844.1"> emits a value. </span><span class="koboSpan" id="kobo.844.2">A good example of when </span><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">forkJoin()</span></strong><span class="koboSpan" id="kobo.846.1"> is useful is when you must make multiple HTTP requests and only want to do something when all requests return a result. </span><span class="koboSpan" id="kobo.846.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">forkJoin()</span></strong><span class="koboSpan" id="kobo.848.1"> operator can be compared with </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">Promise.all()</span></strong><span class="koboSpan" id="kobo.850.1">. </span><span class="koboSpan" id="kobo.850.2">It’s important to note that if one or more of the inner Observables has an error (and you don’t catch that error correctly), </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">forkJoin()</span></strong><span class="koboSpan" id="kobo.852.1"> will not emit </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">a value:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.854.1">forkJoin</span></strong><span class="koboSpan" id="kobo.855.1">({ posts: this.http.get('…'), post2: this.http.get('…)}).subscribe(console.log);
</span><strong class="bold"><span class="koboSpan" id="kobo.856.1">// Logs: { posts: …… , post2: …… }</span></strong></pre></li> <li><strong class="bold"><span class="koboSpan" id="kobo.857.1">concat</span></strong><span class="koboSpan" id="kobo.858.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">concat()</span></strong><span class="koboSpan" id="kobo.860.1"> operator is </span><a id="_idIndexMarker674"/><span class="koboSpan" id="kobo.861.1">used when you have multiple inner Observables, and the order of the emission and completion of these inner Observables is essential. </span><span class="koboSpan" id="kobo.861.2">So, if you have two inner Observables, </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">concat()</span></strong><span class="koboSpan" id="kobo.863.1"> will emit all the values of the first inner Observable until that Observable is completed. </span><span class="koboSpan" id="kobo.863.2">All the values that have been emitted by the second Observable before the first Observable has been completed will not be emitted </span><span class="No-Break"><span class="koboSpan" id="kobo.864.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">concat()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.866.1">.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.867.1">When the first Observable has been completed, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">concat()</span></strong><span class="koboSpan" id="kobo.869.1"> operator subscribes to the second Observable and starts to emit the values emitted by the second Observable. </span><span class="koboSpan" id="kobo.869.2">If you have even more inner Observables, this process will be repeated, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">concat()</span></strong><span class="koboSpan" id="kobo.871.1"> will subscribe </span><a id="_idIndexMarker675"/><span class="koboSpan" id="kobo.872.1">to the next Observable when the previous Observable </span><span class="No-Break"><span class="koboSpan" id="kobo.873.1">is completed:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.874.1">
const a = new Subject();
const b = new Subject();
</span><strong class="bold"><span class="koboSpan" id="kobo.875.1">concat(a, b)</span></strong><span class="koboSpan" id="kobo.876.1">.subscribe(console.log);
a.next(1);
a.next(2);
b.next(3);
a.complete();
b.next(4);
b.complete();
</span><strong class="bold"><span class="koboSpan" id="kobo.877.1">// Logs: 1, 2, 4</span></strong></pre></li> <li><strong class="bold"><span class="koboSpan" id="kobo.878.1">merge</span></strong><span class="koboSpan" id="kobo.879.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">merge()</span></strong><span class="koboSpan" id="kobo.881.1"> operator </span><a id="_idIndexMarker676"/><span class="koboSpan" id="kobo.882.1">combines all inner</span><a id="_idIndexMarker677"/><span class="koboSpan" id="kobo.883.1"> Observables and emits the values as they come in. </span><span class="koboSpan" id="kobo.883.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.884.1">merge()</span></strong><span class="koboSpan" id="kobo.885.1"> operator doesn’t wait for all Observables to emit a value, nor does it care about the order. </span><span class="koboSpan" id="kobo.885.2">When one of the Observables emits a value, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">merge()</span></strong><span class="koboSpan" id="kobo.887.1"> operator will </span><span class="No-Break"><span class="koboSpan" id="kobo.888.1">process it:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.889.1">
const a = new Subject();
const b = new Subject();
</span><strong class="bold"><span class="koboSpan" id="kobo.890.1">merge(a, b)</span></strong><span class="koboSpan" id="kobo.891.1">.subscribe(console.log);
b.next('B:1');
a.next('A:1');
a.next('A:2');
b.next('B:2');
</span><strong class="bold"><span class="koboSpan" id="kobo.892.1">// Logs: B:1, A:1, A:2, B:2</span></strong></pre></li> </ul>
<p><span class="koboSpan" id="kobo.893.1">You now know how to create Observables with creational operators. </span><span class="koboSpan" id="kobo.893.2">You know there are creational operators</span><a id="_idIndexMarker678"/><span class="koboSpan" id="kobo.894.1"> such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">of()</span></strong><span class="koboSpan" id="kobo.896.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">from()</span></strong><span class="koboSpan" id="kobo.898.1"> to create simple Observables and creational operators such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">combineLatest()</span></strong><span class="koboSpan" id="kobo.900.1"> to create a new Observable based on multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.901.1">inner Observables.</span></span></p>
<p><span class="koboSpan" id="kobo.902.1">Next, we will learn about </span><a id="_idIndexMarker679"/><span class="koboSpan" id="kobo.903.1">pipeable operators and how they can be used to filter, modify, and transform </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">Observable streams.</span></span></p>
<h3><span class="koboSpan" id="kobo.905.1">Pipeable operators</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.906.1">Pipeable operators</span></strong><span class="koboSpan" id="kobo.907.1"> take in an Observable as input and return a new and modified Observable without modifying the original Observable. </span><span class="koboSpan" id="kobo.907.2">When you subscribe or unsubscribe to the piped Observable, you</span><a id="_idIndexMarker680"/><span class="koboSpan" id="kobo.908.1"> also subscribe or unsubscribe to the original Observable. </span><span class="koboSpan" id="kobo.908.2">Pipeable operators can filter, map, transform, flatten, or modify the </span><a id="_idIndexMarker681"/><span class="koboSpan" id="kobo.909.1">Observable stream. </span><span class="koboSpan" id="kobo.909.2">For example, pipeable operators can be used to unsubscribe upon a trigger automatically, take the first or last emission of an Observable steam, only emit an Observable value if specific conditions are met, or map the output of the Observable stream into a </span><span class="No-Break"><span class="koboSpan" id="kobo.910.1">new object.</span></span></p>
<p><span class="koboSpan" id="kobo.911.1">Using pipeable operators starts with using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">pipe()</span></strong><span class="koboSpan" id="kobo.913.1"> function on an Observable. </span><span class="koboSpan" id="kobo.913.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">pipe()</span></strong><span class="koboSpan" id="kobo.915.1"> function acts like a path for your Observable data, guiding it through different tools called operators. </span><span class="koboSpan" id="kobo.915.2">It’s like how materials in a factory move through various stations before becoming a finished product. </span><span class="koboSpan" id="kobo.915.3">Here, your data can go through these operators, where you can change it, pick out specific parts, or make it fit your needs. </span><span class="koboSpan" id="kobo.915.4">It’s a common scenario that developers use four, five, or even more operators inside a single </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.916.1">pipe()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.917.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.918.1">Let’s examine an example and learn about some commonly used </span><span class="No-Break"><span class="koboSpan" id="kobo.919.1">pipeable operators:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.920.1">
const observable = of(1, 1, 2, 3, 4, 4, 5);
observable.</span><strong class="bold"><span class="koboSpan" id="kobo.921.1">pipe</span></strong><span class="koboSpan" id="kobo.922.1">(
  </span><strong class="bold"><span class="koboSpan" id="kobo.923.1">distinctUntilChanged(),</span></strong><span class="koboSpan" id="kobo.924.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.925.1">filter(value =&gt; value &lt; 5),</span></strong><span class="koboSpan" id="kobo.926.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.927.1">map(value =&gt; value as number * 10)</span></strong><span class="koboSpan" id="kobo.928.1">
).subscribe(results =&gt; {console.log('results:', results)});
// Logs: 10, 20, 30, 40</span></pre> <p><span class="koboSpan" id="kobo.929.1">In the preceding code, we created an Observable using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">of()</span></strong><span class="koboSpan" id="kobo.931.1"> operator. </span><span class="koboSpan" id="kobo.931.2">On the Observable, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">pipe()</span></strong><span class="koboSpan" id="kobo.933.1"> function with three different pipeable operators declared inside the pipe function: </span><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">distinctUntilChanged()</span></strong><span class="koboSpan" id="kobo.935.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">filter()</span></strong><span class="koboSpan" id="kobo.937.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">map()</span></strong><span class="koboSpan" id="kobo.939.1">. </span><span class="koboSpan" id="kobo.939.2">At the end of the pipe </span><a id="_idIndexMarker682"/><span class="koboSpan" id="kobo.940.1">function, we subscribe to the Observable stream. </span><span class="koboSpan" id="kobo.940.2">The values of the Observable stream move through the pipe and perform the operators on them one by one before ending up in the subscribe block of </span><span class="No-Break"><span class="koboSpan" id="kobo.941.1">our code.</span></span></p>
<p><span class="koboSpan" id="kobo.942.1">The first </span><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">distinctUntilChanged()</span></strong><span class="koboSpan" id="kobo.944.1"> operator checks if the Observable value differs from the previous and filters it out if the value is the same as the last emitted value. </span><span class="koboSpan" id="kobo.944.2">Next, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.945.1">filter()</span></strong><span class="koboSpan" id="kobo.946.1"> operator </span><a id="_idIndexMarker683"/><span class="koboSpan" id="kobo.947.1">works similarly to the filter function on an array; in our case, we filter out all values that aren’t smaller than </span><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">5</span></strong><span class="koboSpan" id="kobo.949.1">. </span><span class="koboSpan" id="kobo.949.2">Lastly, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">map()</span></strong><span class="koboSpan" id="kobo.951.1"> operator; this is also similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">map</span></strong><span class="koboSpan" id="kobo.953.1"> function on an array and lets you map the value to a new value; in our case, we multiply by a factor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">10</span></strong><span class="koboSpan" id="kobo.955.1">. </span><span class="koboSpan" id="kobo.955.2">After applying all our operators, the Observable values that are logged in the subscription are </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">10</span></strong><span class="koboSpan" id="kobo.957.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.958.1">20</span></strong><span class="koboSpan" id="kobo.959.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.960.1">30</span></strong><span class="koboSpan" id="kobo.961.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">40</span></strong><span class="koboSpan" id="kobo.963.1">; all other values of our Observable are </span><span class="No-Break"><span class="koboSpan" id="kobo.964.1">filtered out.</span></span></p>
<p><span class="koboSpan" id="kobo.965.1">As you can see, the pipeable operators are performed one after another, guiding the Observable value through a pipe where changes are applied to the value until it reaches the subscription or is filtered out. </span><span class="koboSpan" id="kobo.965.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">distinctUntilChanged()</span></strong><span class="koboSpan" id="kobo.967.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.968.1">filter()</span></strong><span class="koboSpan" id="kobo.969.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.970.1">map()</span></strong><span class="koboSpan" id="kobo.971.1"> operators are some of the most commonly used operators. </span><span class="koboSpan" id="kobo.971.2">In this chapter, you also learned about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.972.1">takeUntil()</span></strong><span class="koboSpan" id="kobo.973.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.974.1">takeUntilDestroyed()</span></strong><span class="koboSpan" id="kobo.975.1"> operators, which are also </span><span class="No-Break"><span class="koboSpan" id="kobo.976.1">commonly used.</span></span></p>
<p><span class="koboSpan" id="kobo.977.1">Now, let’s continue by exploring some other powerful and commonly used operators and scenarios when pipeable operators are helpful, starting with </span><span class="No-Break"><span class="koboSpan" id="kobo.978.1">flattening operators.</span></span></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.979.1">Flattening multiple Observable streams using flattening operators</span></h2>
<p><span class="koboSpan" id="kobo.980.1">As we’ve seen earlier in this section, sometimes, you </span><a id="_idIndexMarker684"/><span class="koboSpan" id="kobo.981.1">need the value of multiple Observables. </span><span class="koboSpan" id="kobo.981.2">In some cases, you need all these values at once; in these scenarios, you can use the creational operators that create a new Observable based on multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.982.1">inner Observables.</span></span></p>
<p><span class="koboSpan" id="kobo.983.1">But in other scenarios, you first need the value of one Observable to pass as an argument to another Observable. </span><span class="koboSpan" id="kobo.983.2">These scenarios where you have an outer Observable and an inner Observable, where the inner Observable relies on the value of the outer Observable, are commonly referred to as </span><strong class="bold"><span class="koboSpan" id="kobo.984.1">higher-order Observables</span></strong><span class="koboSpan" id="kobo.985.1">. </span><span class="koboSpan" id="kobo.985.2">In most cases, the correct way to handle </span><a id="_idIndexMarker685"/><span class="koboSpan" id="kobo.986.1">higher-order Observables is to flatten them into a single Observable stream. </span><span class="koboSpan" id="kobo.986.2">You</span><a id="_idIndexMarker686"/><span class="koboSpan" id="kobo.987.1"> can achieve this using </span><strong class="bold"><span class="koboSpan" id="kobo.988.1">flattening operators</span></strong><span class="koboSpan" id="kobo.989.1"> such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">concatAll()</span></strong><span class="koboSpan" id="kobo.991.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">mergeAll()</span></strong><span class="koboSpan" id="kobo.993.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.994.1">swtichAll()</span></strong><span class="koboSpan" id="kobo.995.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.996.1">exhaustAll()</span></strong><span class="koboSpan" id="kobo.997.1">. </span><span class="koboSpan" id="kobo.997.2">To get a better understanding of this concept, let’s look at </span><span class="No-Break"><span class="koboSpan" id="kobo.998.1">some examples.</span></span></p>
<p><span class="koboSpan" id="kobo.999.1">Let’s say you have an </span><a id="_idIndexMarker687"/><span class="koboSpan" id="kobo.1000.1">Observable yielding an API URL. </span><span class="koboSpan" id="kobo.1000.2">Next, you want to use this URL to make an HTTP request. </span><span class="koboSpan" id="kobo.1000.3">In actuality, you’re only interested in the result of the API request and not so much in the result of the Observable yielding the URL. </span><span class="koboSpan" id="kobo.1000.4">The URL is only needed to make the API request, and the API response is required to render your page or perform some logic. </span><span class="koboSpan" id="kobo.1000.5">One approach would be to nest the two subscriptions, but as you’ve learned, this isn’t a good approach. </span><span class="koboSpan" id="kobo.1000.6">The correct solution is to use a flattening operator to flatten the Observable stream into a </span><span class="No-Break"><span class="koboSpan" id="kobo.1001.1">single stream:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1002.1">
ngOnInit() {
  this.urlObservable.pipe(
    map((url) =&gt; this.http.get(url)),
    </span><strong class="source-inline"><span class="koboSpan" id="kobo.1003.1">concatAll()</span></strong><span class="koboSpan" id="kobo.1004.1">
  ).subscribe((data) =&gt; { console.log('data ==&gt;', data) })
}</span></pre> <p><span class="koboSpan" id="kobo.1005.1">As you can see, we have an outer Observable receiving an API URL and using two pipeable operators on this Observable. </span><span class="koboSpan" id="kobo.1005.2">First, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1006.1">map()</span></strong><span class="koboSpan" id="kobo.1007.1"> operator to take the result of the URL Observable and use it to make the API request, which results in our second Observable. </span><span class="koboSpan" id="kobo.1007.2">Next, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1008.1">concatAll()</span></strong><span class="koboSpan" id="kobo.1009.1"> operator to flatten the two Observables into a single Observable, only returning the result of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1010.1">API request.</span></span></p>
<p><span class="koboSpan" id="kobo.1011.1">Inside the subscription, we log the result, which will be the data that’s returned by the API call. </span><span class="koboSpan" id="kobo.1011.2">You can simplify this code even more by using the combined operator, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">concatMap()</span></strong><span class="koboSpan" id="kobo.1013.1">, which combines the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">map()</span></strong><span class="koboSpan" id="kobo.1015.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1016.1">concatAll()</span></strong><span class="koboSpan" id="kobo.1017.1"> operators into a </span><span class="No-Break"><span class="koboSpan" id="kobo.1018.1">single operator:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1019.1">
this.urlObservable.pipe(
  </span><strong class="bold"><span class="koboSpan" id="kobo.1020.1">concatMap</span></strong><span class="koboSpan" id="kobo.1021.1">((url) =&gt; this.http.get(url)),
).subscribe(……)</span></pre> <p><span class="koboSpan" id="kobo.1022.1">These combined operators </span><a id="_idIndexMarker688"/><span class="koboSpan" id="kobo.1023.1">exist for all four flattening operators, so you have the </span><span class="No-Break"><span class="koboSpan" id="kobo.1024.1">following operators:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1025.1">concatMap()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1026.1">mergeMap()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1027.1">switchMap()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1028.1">exhaustMap()</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1029.1">Now that you’ve seen how you can use a flattening operator and that there are map operators that combine the map and flattening operators, let’s learn about the difference </span><span class="No-Break"><span class="koboSpan" id="kobo.1030.1">between them.</span></span></p>
<h4><span class="koboSpan" id="kobo.1031.1">The concatMap() operator</span></h4>
<p><span class="koboSpan" id="kobo.1032.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1033.1">concatAll()</span></strong><span class="koboSpan" id="kobo.1034.1"> operator is used when you want the first value of the outer Observable and all its inner concatenated Observables to complete before the second value of the outer Observable and its inner </span><a id="_idIndexMarker689"/><span class="koboSpan" id="kobo.1035.1">Observables are processed. </span><span class="koboSpan" id="kobo.1035.2">Let’s consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.1036.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1037.1">
const clicks = fromEvent(document, 'click');
clicks.pipe(
  </span><strong class="bold"><span class="koboSpan" id="kobo.1038.1">concatMap</span></strong><span class="koboSpan" id="kobo.1039.1">(() =&gt; interval(1000).pipe(take(4))),
).subscribe(number =&gt; console.log(number));</span></pre> <p><span class="koboSpan" id="kobo.1040.1">In the preceding code, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1041.1">fromEvent()</span></strong><span class="koboSpan" id="kobo.1042.1"> creational operator to create an Observable whenever we click the browser document (that would be any place in our app). </span><span class="koboSpan" id="kobo.1042.2">Next, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1043.1">concatMap()</span></strong><span class="koboSpan" id="kobo.1044.1"> to map the result of the click Observable into a new Observable using the RxJS </span><strong class="source-inline"><span class="koboSpan" id="kobo.1045.1">interval()</span></strong><span class="koboSpan" id="kobo.1046.1"> creational operator. </span><span class="koboSpan" id="kobo.1046.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">interval()</span></strong><span class="koboSpan" id="kobo.1048.1"> operator will emit sequential numbers starting at zero; in our case, it will emit the following number every </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1049.1">1000</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1050.1"> milliseconds.</span></span></p>
<p><span class="koboSpan" id="kobo.1051.1">We also used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1052.1">take()</span></strong><span class="koboSpan" id="kobo.1053.1"> pipeable operator on the interval Observable. </span><span class="koboSpan" id="kobo.1053.2">This limits the number of emissions we take to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1054.1">4</span></strong><span class="koboSpan" id="kobo.1055.1">, so the interval Observable will emit </span><strong class="source-inline"><span class="koboSpan" id="kobo.1056.1">0</span></strong><span class="koboSpan" id="kobo.1057.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1058.1">1</span></strong><span class="koboSpan" id="kobo.1059.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1060.1">2</span></strong><span class="koboSpan" id="kobo.1061.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1062.1">3</span></strong><span class="koboSpan" id="kobo.1063.1"> as values and be unsubscribed and</span><a id="_idIndexMarker690"/><span class="koboSpan" id="kobo.1064.1"> completed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1065.1">take()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1066.1">operator afterward.</span></span></p>
<p><span class="koboSpan" id="kobo.1067.1">Because we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1068.1">concatMap()</span></strong><span class="koboSpan" id="kobo.1069.1"> flattening operator, when we click twice on the screen, both the outer and inner Observables will be triggered two times, but the first click Observable and its inner Observables will be processed first and only when that is completed the second sequence will start. </span><span class="koboSpan" id="kobo.1069.2">So, our subscription part will log </span><strong class="source-inline"><span class="koboSpan" id="kobo.1070.1">0, 1, 2, 3, 0, 1, </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1071.1">2, 3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1072.1">.</span></span></p>
<h4><span class="koboSpan" id="kobo.1073.1">The mergeMap() operator</span></h4>
<p><span class="koboSpan" id="kobo.1074.1">Now, let’s consider the same scenario with the</span><a id="_idIndexMarker691"/><span class="koboSpan" id="kobo.1075.1"> other flattening operators, starting with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1076.1">mergeMap()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1077.1"> operator:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1078.1">
const clicks = fromEvent(document, 'click');
clicks.pipe(
  </span><strong class="bold"><span class="koboSpan" id="kobo.1079.1">mergeMap</span></strong><span class="koboSpan" id="kobo.1080.1">(() =&gt; interval(1000).pipe(take(4))),
).subscribe(x =&gt; console.log(x));</span></pre> <p><span class="koboSpan" id="kobo.1081.1">In the preceding example, we only changed </span><strong class="source-inline"><span class="koboSpan" id="kobo.1082.1">concatMap()</span></strong><span class="koboSpan" id="kobo.1083.1"> for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1084.1">mergeMap()</span></strong><span class="koboSpan" id="kobo.1085.1"> operator, yet the result will be completely different. </span><span class="koboSpan" id="kobo.1085.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1086.1">mergeMap()</span></strong><span class="koboSpan" id="kobo.1087.1"> operator will not wait for the first inner and outer Observables to complete but will process the values as they </span><span class="No-Break"><span class="koboSpan" id="kobo.1088.1">come in.</span></span></p>
<p><span class="koboSpan" id="kobo.1089.1">So, if you click on the screen, wait for 2 seconds, and then click on the screen again, the values of the second click and its inner interval Observable will start to come in before the first stream has completed. </span><span class="koboSpan" id="kobo.1089.2">If you click the first time on the screen, the first log will come in after one second and another one for </span><span class="No-Break"><span class="koboSpan" id="kobo.1090.1">every second.</span></span></p>
<p><span class="koboSpan" id="kobo.1091.1">Then, when you click again after a second, the first log of the second stream will come in and log another value for every second after that. </span><span class="koboSpan" id="kobo.1091.2">In this case, the result of all logs would be </span><strong class="source-inline"><span class="koboSpan" id="kobo.1092.1">0, 1, 2, 0, 3, 1, 2, 3</span></strong><span class="koboSpan" id="kobo.1093.1">. </span><span class="koboSpan" id="kobo.1093.2">As you can see, the result is entirely different from the result we had with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1094.1">concatMap()</span></strong><span class="koboSpan" id="kobo.1095.1">. </span><span class="koboSpan" id="kobo.1095.2">Now, let’s see what happens when we change </span><strong class="source-inline"><span class="koboSpan" id="kobo.1096.1">mergeMap()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1097.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">switchMap()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1099.1">.</span></span></p>
<h4><span class="koboSpan" id="kobo.1100.1">The switchMap() operator</span></h4>
<p><span class="koboSpan" id="kobo.1101.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1102.1">switchMap()</span></strong><span class="koboSpan" id="kobo.1103.1"> operator will switch the Observable stream from the first to the second stream when the second stream </span><a id="_idIndexMarker692"/><span class="koboSpan" id="kobo.1104.1">starts to emit values. </span><span class="koboSpan" id="kobo.1104.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1105.1">switchMap()</span></strong><span class="koboSpan" id="kobo.1106.1"> operator will unsubscribe and complete the first stream so that the first stream will stop emitting values; the next stream will keep emitting until that stream is completed or until another </span><span class="No-Break"><span class="koboSpan" id="kobo.1107.1">stream comes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1108.1">
const clicks = fromEvent(document, 'click');
clicks.pipe(
  </span><strong class="bold"><span class="koboSpan" id="kobo.1109.1">switchMap</span></strong><span class="koboSpan" id="kobo.1110.1">(() =&gt; interval(1000).pipe(take(4))),
).subscribe(x =&gt; console.log(x));</span></pre> <p><span class="koboSpan" id="kobo.1111.1">So, with the preceding code, if we click on the screen now, wait for 2 seconds, and then click another time, our log will look like </span><strong class="source-inline"><span class="koboSpan" id="kobo.1112.1">0, 1, 0, 1, 2, 3</span></strong><span class="koboSpan" id="kobo.1113.1">. </span><span class="koboSpan" id="kobo.1113.2">As you can see in the logs, the first stream is completed the moment the second stream starts to emit values. </span><span class="koboSpan" id="kobo.1113.3">Lastly, we have the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1114.1">exhaustMap()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1115.1"> operator.</span></span></p>
<h4><span class="koboSpan" id="kobo.1116.1">The exhaustMap() operator</span></h4>
<p><span class="koboSpan" id="kobo.1117.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1118.1">exhaustMap()</span></strong><span class="koboSpan" id="kobo.1119.1"> operator will start to </span><a id="_idIndexMarker693"/><span class="koboSpan" id="kobo.1120.1">emit the values of the first Observable stream as soon as it starts to emit values. </span><span class="koboSpan" id="kobo.1120.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1121.1">exhaustMap()</span></strong><span class="koboSpan" id="kobo.1122.1"> operator will not process any other Observable streams that come in while the first stream is still running. </span><span class="koboSpan" id="kobo.1122.2">Only when the stream has been completed will new values be processed, so if you click while the first stream is still running, it will never </span><span class="No-Break"><span class="koboSpan" id="kobo.1123.1">be processed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1124.1">
const clicks = fromEvent(document, 'click');
clicks.pipe(
  </span><strong class="bold"><span class="koboSpan" id="kobo.1125.1">exhaustMap</span></strong><span class="koboSpan" id="kobo.1126.1">(() =&gt; interval(1000).pipe(take(4))),
).subscribe(x =&gt; console.log(x));</span></pre> <p><span class="koboSpan" id="kobo.1127.1">In the preceding example, where we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1128.1">exhaustMap()</span></strong><span class="koboSpan" id="kobo.1129.1"> operator and clicked and waited for 2 seconds before we made another click, only the first click will be processed because the first stream takes 4 seconds to complete. </span><span class="koboSpan" id="kobo.1129.2">So, when we make the second click, the first stream is not completed yet, so </span><strong class="source-inline"><span class="koboSpan" id="kobo.1130.1">exhaustMap()</span></strong><span class="koboSpan" id="kobo.1131.1"> doesn’t process the second stream. </span><span class="koboSpan" id="kobo.1131.2">The log of the preceding code will look like </span><strong class="source-inline"><span class="koboSpan" id="kobo.1132.1">0, 1, </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1133.1">3, 4</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1134.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1135.1">Lastly, it’s important to note that when you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1136.1">take()</span></strong><span class="koboSpan" id="kobo.1137.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1138.1">takeUntil()</span></strong><span class="koboSpan" id="kobo.1139.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1140.1">takeUntilDestroyed()</span></strong><span class="koboSpan" id="kobo.1141.1"> operators inside the pipe of the outer Observable and also use flattening operators in the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.1142.1">pipe()</span></strong><span class="koboSpan" id="kobo.1143.1"> function, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1144.1">take()</span></strong><span class="koboSpan" id="kobo.1145.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1146.1">takeUntil()</span></strong><span class="koboSpan" id="kobo.1147.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1148.1">takeUntilDestroyed()</span></strong><span class="koboSpan" id="kobo.1149.1"> operators need to be declared after the flattening operators. </span><span class="koboSpan" id="kobo.1149.2">The flattening operators will create their own Observables, and if you declare </span><strong class="source-inline"><span class="koboSpan" id="kobo.1150.1">take()</span></strong><span class="koboSpan" id="kobo.1151.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1152.1">takeUntil()</span></strong><span class="koboSpan" id="kobo.1153.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1154.1">takeUntilDestroyed()</span></strong><span class="koboSpan" id="kobo.1155.1"> before the flattening operator, the Observables created by the flattening operators will not be unsubscribed and closed by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1156.1">take()</span></strong><span class="koboSpan" id="kobo.1157.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1158.1">takeUntil()</span></strong><span class="koboSpan" id="kobo.1159.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1160.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1161.1">takeUntilDestroyed()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1162.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1163.1">You now know what higher-order</span><a id="_idIndexMarker694"/><span class="koboSpan" id="kobo.1164.1"> Observables are and how you can handle them using flattening operators. </span><span class="koboSpan" id="kobo.1164.2">You learned about combined operators that combine the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1165.1">map()</span></strong><span class="koboSpan" id="kobo.1166.1"> and flattening operators, and you learned about using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1167.1">take()</span></strong><span class="koboSpan" id="kobo.1168.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1169.1">takeUntil()</span></strong><span class="koboSpan" id="kobo.1170.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1171.1">takeUntilDestroyed()</span></strong><span class="koboSpan" id="kobo.1172.1"> in combination with the flattening operators. </span><span class="koboSpan" id="kobo.1172.2">Lastly, you learned about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1173.1">interval()</span></strong><span class="koboSpan" id="kobo.1174.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1175.1">take()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1176.1"> operators.</span></span></p>
<p><span class="koboSpan" id="kobo.1177.1">Now, let’s start exploring other useful pipeable operators that serve a few more straightforward use cases </span><span class="No-Break"><span class="koboSpan" id="kobo.1178.1">and scenarios.</span></span></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.1179.1">Powerful and useful RxJS operators</span></h2>
<p><span class="koboSpan" id="kobo.1180.1">You have already learned much about RxJS and seen how you can handle some complex Observable scenarios by combining or flattening Observables. </span><span class="koboSpan" id="kobo.1180.2">You’ve also seen how to unsubscribe Observables or filter values using pipeable </span><a id="_idIndexMarker695"/><span class="koboSpan" id="kobo.1181.1">operators. </span><span class="koboSpan" id="kobo.1181.2">We will now walk through some commonly used pipeable operators that are useful in more </span><span class="No-Break"><span class="koboSpan" id="kobo.1182.1">straightforward scenarios:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1183.1">debounceTime()</span></strong><span class="koboSpan" id="kobo.1184.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1185.1">debounceTime()</span></strong><span class="koboSpan" id="kobo.1186.1"> operator takes a pause and waits for another value to come in within the defined timeframe. </span><span class="koboSpan" id="kobo.1186.2">A good real-world example of this is a search or filter input</span><a id="_idIndexMarker696"/><span class="koboSpan" id="kobo.1187.1"> field. </span><span class="koboSpan" id="kobo.1187.2">Instead of bombarding your system with an update for every keystroke, a more efficient solution would be waiting until the user stops typing for a specific interval. </span><span class="koboSpan" id="kobo.1187.3">This waiting can be done by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1188.1">debounceTime()</span></strong><span class="koboSpan" id="kobo.1189.1">. </span><span class="koboSpan" id="kobo.1189.2">You provide </span><strong class="source-inline"><span class="koboSpan" id="kobo.1190.1">debounceTime()</span></strong><span class="koboSpan" id="kobo.1191.1"> with a parameter indicating the milliseconds it should wait (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1192.1">debounceTime(300)</span></strong><span class="koboSpan" id="kobo.1193.1">) before processing the value; only when no new value is received within the specified timeframe will the value be passed on to the next operator or the </span><span class="No-Break"><span class="koboSpan" id="kobo.1194.1">subscription block.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1195.1">Skip()</span></strong><span class="koboSpan" id="kobo.1196.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1197.1">skip()</span></strong><span class="koboSpan" id="kobo.1198.1"> operator can skip a fixed number of emissions. </span><span class="koboSpan" id="kobo.1198.2">Let’s say you have </span><strong class="source-inline"><span class="koboSpan" id="kobo.1199.1">ReplaySubject</span></strong><span class="koboSpan" id="kobo.1200.1">, and for one of </span><a id="_idIndexMarker697"/><span class="koboSpan" id="kobo.1201.1">your subscriptions on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1202.1">ReplaySubject</span></strong><span class="koboSpan" id="kobo.1203.1">, you aren’t interested in the replayed emissions, only in the new emission. </span><span class="koboSpan" id="kobo.1203.2">In this scenario, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1204.1">skip()</span></strong><span class="koboSpan" id="kobo.1205.1"> operator and define the number of emissions you want to skip inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.1206.1">operator: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1207.1">skip(5)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1208.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1209.1">skipUntil()</span></strong><span class="koboSpan" id="kobo.1210.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1211.1">skipUntil()</span></strong><span class="koboSpan" id="kobo.1212.1"> operator </span><a id="_idIndexMarker698"/><span class="koboSpan" id="kobo.1213.1">works a bit like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1214.1">takeUntil()</span></strong><span class="koboSpan" id="kobo.1215.1"> operator; only it will skip the emissions until the inner Observable of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1216.1">skipUntil()</span></strong><span class="koboSpan" id="kobo.1217.1"> receives a value. </span><span class="koboSpan" id="kobo.1217.2">You could provide </span><strong class="source-inline"><span class="koboSpan" id="kobo.1218.1">skipUntil()</span></strong><span class="koboSpan" id="kobo.1219.1"> with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1220.1">Subject</span></strong><span class="koboSpan" id="kobo.1221.1"> class or something like an RxJS timer so that you only take values after a predefined interval has </span><span class="No-Break"><span class="koboSpan" id="kobo.1222.1">passed: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1223.1">skipUntil(timer(5000))</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1224.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1225.1">find()</span></strong><span class="koboSpan" id="kobo.1226.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1227.1">find()</span></strong><span class="koboSpan" id="kobo.1228.1"> operator works</span><a id="_idIndexMarker699"/><span class="koboSpan" id="kobo.1229.1"> similarly to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1230.1">find</span></strong><span class="koboSpan" id="kobo.1231.1"> method on an array. </span><span class="koboSpan" id="kobo.1231.2">It will only emit the first value it finds that matches the condition you provide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1232.1">find()</span></strong><span class="koboSpan" id="kobo.1233.1"> operator with. </span><span class="koboSpan" id="kobo.1233.2">So, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1234.1">find((item: any) =&gt; item.size === 'large')</span></strong><span class="koboSpan" id="kobo.1235.1"> will only pass on the first item through the pipe where the size property is equal </span><span class="No-Break"><span class="koboSpan" id="kobo.1236.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1237.1">large</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1238.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1239.1">scan()</span></strong><span class="koboSpan" id="kobo.1240.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1241.1">scan()</span></strong><span class="koboSpan" id="kobo.1242.1"> operator is comparable to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1243.1">reduce</span></strong><span class="koboSpan" id="kobo.1244.1"> function on an array. </span><span class="koboSpan" id="kobo.1244.2">It gives you access to the</span><a id="_idIndexMarker700"/><span class="koboSpan" id="kobo.1245.1"> previous and current value and allows you to emit a new value based on the previous and current value. </span><span class="koboSpan" id="kobo.1245.2">For example, you can combine the results or take the lowest or highest result of the two: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1246.1">scan((prev, curr) =&gt; `${prev} ${curr}`, '')</span></strong><span class="koboSpan" id="kobo.1247.1">. </span><span class="koboSpan" id="kobo.1247.2">Here, we combined the previous and current values using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1248.1">scan()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1249.1"> operator.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1250.1">With that, we have covered some of the more commonly used operators and learned how to filter, map, limit, or transform the value stream with pipeable operators. </span><span class="koboSpan" id="kobo.1250.2">You can find them in the official documentation if you want to learn more about operators and check out a complete </span><span class="No-Break"><span class="koboSpan" id="kobo.1251.1">list: </span></span><a href="https://rxjs.dev/guide/operators"><span class="No-Break"><span class="koboSpan" id="kobo.1252.1">https://rxjs.dev/guide/operators</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1253.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1254.1">Before we move on to the next section and start to learn about Angular Signals, let’s finish this section on RxJS by creating combined and </span><span class="No-Break"><span class="koboSpan" id="kobo.1255.1">reusable operators.</span></span></p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.1256.1">Creating combined and reusable RxJS operators</span></h2>
<p><span class="koboSpan" id="kobo.1257.1">Creating a reusable operator or combining multiple operators can easily be done by creating a function that returns an RxJS </span><strong class="source-inline"><span class="koboSpan" id="kobo.1258.1">pipe()</span></strong><span class="koboSpan" id="kobo.1259.1"> function. </span><span class="koboSpan" id="kobo.1259.2">Let’s say you find yourself making a filter pipe that filters odd</span><a id="_idIndexMarker701"/><span class="koboSpan" id="kobo.1260.1"> numbers multiple times. </span><span class="koboSpan" id="kobo.1260.2">Creating a function that does this would be easier so that you don’t have to repeat the logic numerous times. </span><span class="koboSpan" id="kobo.1260.3">You can do this by creating a function that returns an RxJS pipe implementing the filter operator with the filter logic predefined in </span><span class="No-Break"><span class="koboSpan" id="kobo.1261.1">the operator:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1262.1">
export const discardOdd = () =&gt; pipe(
  filter((v: number) =&gt; !(v % 2)),
);</span></pre> <p><span class="koboSpan" id="kobo.1263.1">You can now use this pipeable operator like any </span><span class="No-Break"><span class="koboSpan" id="kobo.1264.1">other operator:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1265.1">
of(1, 2, 4, 5, 6, 7).pipe(discardOddDoubleEven()).subscribe(console.log);</span></pre> <p><span class="koboSpan" id="kobo.1266.1">If you want to combine multiple operators, it works the same way: you must create a function that returns an RxJS pipe and declares all the operators you want to use inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.1267.1">pipe function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1268.1">
const discardOddDoubleEven = () =&gt; pipe(
  filter((v: number) =&gt; !(v % 2)),
  map((v: number) =&gt; v * 2)
);</span></pre> <p><span class="koboSpan" id="kobo.1269.1">With that, you’ve learned all about operators and how to use pipeable and creational operators. </span><span class="koboSpan" id="kobo.1269.2">You know how to combine and flatten multiple Observable streams and create reusable and combined operators using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1270.1">pipe()</span></strong><span class="koboSpan" id="kobo.1271.1"> function. </span><span class="koboSpan" id="kobo.1271.2">You’ve seen how to create Observable streams and handle code reactively and asynchronously with Observables </span><span class="No-Break"><span class="koboSpan" id="kobo.1272.1">and RxJS.</span></span></p>
<p><span class="koboSpan" id="kobo.1273.1">Since the introduction of Angular Signals, you can also handle reactivity more synchronously, allowing you to do almost everything in your Angular applications in a reactive manner, both with</span><a id="_idIndexMarker702"/><span class="koboSpan" id="kobo.1274.1"> synchronous and </span><span class="No-Break"><span class="koboSpan" id="kobo.1275.1">asynchronous code.</span></span></p>
<p><span class="koboSpan" id="kobo.1276.1">In the next section, you will learn everything about Angular Signals. </span><span class="koboSpan" id="kobo.1276.2">You will learn what Signals are and how and when to </span><span class="No-Break"><span class="koboSpan" id="kobo.1277.1">use them.</span></span></p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.1278.1">Reactive programming using Angular Signals</span></h1>
<p><span class="koboSpan" id="kobo.1279.1">We briefly discussed </span><strong class="bold"><span class="koboSpan" id="kobo.1280.1">Angular Signals</span></strong><span class="koboSpan" id="kobo.1281.1"> in </span><a href="B21625_02.xhtml#_idTextAnchor033"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1282.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.1283.1">, but let’s reiterate that and dive a bit deeper so that you can get a good grasp of Angular </span><a id="_idIndexMarker703"/><span class="koboSpan" id="kobo.1284.1">Signals and how they can help you handle code </span><span class="No-Break"><span class="koboSpan" id="kobo.1285.1">more reactively.</span></span></p>
<p><span class="koboSpan" id="kobo.1286.1">Angular Signals was introduced in Angular 16, and it’s one of the most significant changes for the framework since it went </span><a id="_idIndexMarker704"/><span class="koboSpan" id="kobo.1287.1">from AngularJS to Angular. </span><span class="koboSpan" id="kobo.1287.2">With Signals, the Angular framework now has a reactive primitive in the Angular framework that allows you to declare, compute, mutate, and consume synchronous values </span><a id="_idIndexMarker705"/><span class="koboSpan" id="kobo.1288.1">reactively. </span><span class="koboSpan" id="kobo.1288.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.1289.1">reactive primitive</span></strong><span class="koboSpan" id="kobo.1290.1"> is an immutable value that alerts consumers when the primitive is set with a new value. </span><span class="koboSpan" id="kobo.1290.2">Because all consumers are notified, the consumers can automatically track and react to changes in this </span><span class="No-Break"><span class="koboSpan" id="kobo.1291.1">reactive primitive.</span></span></p>
<p><span class="koboSpan" id="kobo.1292.1">Because Signals are reactive primitives, the Angular framework can better detect changes and optimize rendering, resulting in better performance. </span><span class="koboSpan" id="kobo.1292.2">Signals are the first step to an Angular version with fully fine-grained and local change detection that doesn’t need Zone.js to detect changes based on </span><span class="No-Break"><span class="koboSpan" id="kobo.1293.1">browser events.</span></span></p>
<p><span class="koboSpan" id="kobo.1294.1">At the time of writing, Angular assumes that any triggered browser event handler can change any data bound to an HTML template. </span><span class="koboSpan" id="kobo.1294.2">Because of that, each time a browser event is triggered, Angular checks the entire component tree for changes because it can’t detect changes in a fine-grained manner. </span><span class="koboSpan" id="kobo.1294.3">This is a significant drain on resources and impacts </span><span class="No-Break"><span class="koboSpan" id="kobo.1295.1">performance negatively.</span></span></p>
<p><span class="koboSpan" id="kobo.1296.1">Because Signals notify interested parties of changes, Angular doesn’t have to check the entire component tree and can perform change detection more efficiently. </span><span class="koboSpan" id="kobo.1296.2">While we aren’t at a stage yet where Angular can perform fully local change detection and only update components or properties with changes, by</span><span class="Annotation-reference"> </span><span class="koboSpan" id="kobo.1297.1">using Signals combined with OnPush change detection, you reduce the number of components Angular has to check for changes. </span><span class="koboSpan" id="kobo.1297.2">Eventually, Signals will allow the framework to perform local change detection, where the framework only has to check</span><a id="_idIndexMarker706"/><span class="koboSpan" id="kobo.1298.1"> and update components and properties that have </span><span class="No-Break"><span class="koboSpan" id="kobo.1299.1">changed values.</span></span></p>
<p><span class="koboSpan" id="kobo.1300.1">Besides change detection, Signals</span><a id="_idIndexMarker707"/><span class="koboSpan" id="kobo.1301.1"> bring more advantages. </span><span class="koboSpan" id="kobo.1301.2">Signal allows for a more reactive approach within your Angular code. </span><span class="koboSpan" id="kobo.1301.3">While RxJS already does a fantastic job facilitating reactive programming within your Angular applications, RxJS focuses on handling asynchronous Observable data streams and isn’t suited to handle </span><span class="No-Break"><span class="koboSpan" id="kobo.1302.1">synchronous code.</span></span></p>
<p><span class="koboSpan" id="kobo.1303.1">On the other hand, Signals shine where RxJS falls short; Signals reactively handle synchronous code by automatically notifying all consumers when the synchronous value changes. </span><span class="koboSpan" id="kobo.1303.2">All dependent code can then react and update accordingly when the Signal pushes a new value. </span><span class="koboSpan" id="kobo.1303.3">Especially when you start to utilize Signal effects and computed Signals, you can take your reactivity to the next level! </span><span class="koboSpan" id="kobo.1303.4">Signal effects and computed Signals will automatically compute new values or run side effects when the Signal value changes, making it easy to automatically update and run logic as a reaction to the changed value of </span><span class="No-Break"><span class="koboSpan" id="kobo.1304.1">synchronous code.</span></span></p>
<p><span class="koboSpan" id="kobo.1305.1">Another problem that Signals solves is the infamous and </span><span class="No-Break"><span class="koboSpan" id="kobo.1306.1">dreaded </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1307.1">ExpressionChanged</span></strong></span><strong class="source-inline"><span class="koboSpan" id="kobo.1308.1">
AfterItHasBeenCheckedError</span></strong><span class="koboSpan" id="kobo.1309.1"> error. </span><span class="koboSpan" id="kobo.1309.2">If you’ve worked with Angular, changes are pretty significant you’ve seen this error before. </span><span class="koboSpan" id="kobo.1309.3">This error occurs because of how Angular currently detects changes. </span><span class="koboSpan" id="kobo.1309.4">Because the change detection on Signals is different, as Angular knows when they change and doesn’t have to check for changes, the dreaded </span><strong class="source-inline"><span class="koboSpan" id="kobo.1310.1">ExpressionChangedAfterItHasBeenCheckedError</span></strong><span class="koboSpan" id="kobo.1311.1"> error will not occur when working with </span><span class="No-Break"><span class="koboSpan" id="kobo.1312.1">Signal values.</span></span></p>
<p><span class="koboSpan" id="kobo.1313.1">Signals wrap around values such as strings, numbers, arrays, and objects. </span><span class="koboSpan" id="kobo.1313.2">The Signal then exposes the value through a getter, which allows the Angular framework to track who is consuming the Signal and notify the consumers when the value changes. </span><span class="koboSpan" id="kobo.1313.3">Signals can wrap around simple values or complex data structures such as objects or arrays with nested structures. </span><span class="koboSpan" id="kobo.1313.4">Signals can be read-only and writable. </span><span class="koboSpan" id="kobo.1313.5">As you might expect, writeable Signals can be modified, whereas read-only Signals can only </span><span class="No-Break"><span class="koboSpan" id="kobo.1314.1">be read.</span></span></p>
<p><span class="koboSpan" id="kobo.1315.1">Now that you understand the theory behind Signals, let’s dive into some examples and learn how and when to use Angular Signals within </span><span class="No-Break"><span class="koboSpan" id="kobo.1316.1">Angular applications.</span></span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.1317.1">Using Signals, computed Signals, and Signals effects</span></h2>
<p><span class="koboSpan" id="kobo.1318.1">The best way to better </span><a id="_idIndexMarker708"/><span class="koboSpan" id="kobo.1319.1">understand something is to use it. </span><span class="koboSpan" id="kobo.1319.2">So, without further ado, let’s start learning about Signals by writing some code. </span><span class="koboSpan" id="kobo.1319.3">Start by cleaning up your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1320.1">expenses-overview</span></strong><span class="koboSpan" id="kobo.1321.1"> component, clear the entire HTML template, and remove any logic you still have in the component class. </span><span class="koboSpan" id="kobo.1321.2">Your component class and the corresponding HTML template should be empty when </span><span class="No-Break"><span class="koboSpan" id="kobo.1322.1">you’re done.</span></span></p>
<p><span class="koboSpan" id="kobo.1323.1">To explain Signals step by step, we will initially use hardcoded expenses inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1324.1">expenses-overview</span></strong><span class="koboSpan" id="kobo.1325.1"> component. </span><span class="koboSpan" id="kobo.1325.2">We’ll start by creating an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1326.1">expenses</span></strong><span class="koboSpan" id="kobo.1327.1"> Signals with an initial value containing an array with some </span><span class="No-Break"><span class="koboSpan" id="kobo.1328.1">expenses inside:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1329.1">
expenses = signal&lt;ExpenseModel[]&gt;([ …… ]);</span></pre> <p><span class="koboSpan" id="kobo.1330.1">As you can see, we created a property and assigned it a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1331.1">signal()</span></strong><span class="koboSpan" id="kobo.1332.1"> function. </span><span class="koboSpan" id="kobo.1332.2">This function receives a parameter that sets the initial value of the Signal. </span><span class="koboSpan" id="kobo.1332.3">In our example, we have added an array with some expenses for the initial value (you can create the mocked expenses based on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1333.1">ExpenseModel</span></strong><span class="koboSpan" id="kobo.1334.1">). </span><span class="koboSpan" id="kobo.1334.2">You can manually add a type for your Signal using the arrow syntax, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1335.1">&lt;ExpenseModel[]&gt;</span></strong><span class="koboSpan" id="kobo.1336.1">, but the Signal also infers the type from the initial value. </span><span class="koboSpan" id="kobo.1336.2">Let’s use this Signal inside our HTML template to output </span><span class="No-Break"><span class="koboSpan" id="kobo.1337.1">the expenses.</span></span></p>
<p><span class="koboSpan" id="kobo.1338.1">You can access a Signal like any other function – you use the property name of the Signal and add function brackets after it. </span><span class="koboSpan" id="kobo.1338.2">In general, I don’t recommend using functions inside your HTML template, but Signals are an exception as they are non-computational functions; they return a value without computing anything. </span><span class="koboSpan" id="kobo.1338.3">So, let’s output our Signal inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.1339.1">HTML template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1340.1">
&lt;div class="container"&gt;
  &lt;h1&gt;Expenses Overview&lt;/h1&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;th&gt;Description&lt;/th&gt;
      ……
    &lt;/tr&gt;
    @for (expense of expenses(); track expense.id){
    &lt;tr&gt;
      &lt;td&gt;{{ expense.description }}&lt;/td&gt;
      ……
    &lt;/tr&gt;
    }
  &lt;/table&gt;
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.1341.1">Here, we’ve created an HTML table and used the control flow syntax to output a table row for each expense within our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1342.1">expenses</span></strong><span class="koboSpan" id="kobo.1343.1"> Signal. </span><span class="koboSpan" id="kobo.1343.2">We accessed the expenses by calling our Signal with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1344.1">expenses()</span></strong><span class="koboSpan" id="kobo.1345.1">. </span><span class="koboSpan" id="kobo.1345.2">You can compose your own table headers and data rows or copy the HTML and CSS from</span><a id="_idIndexMarker709"/><span class="koboSpan" id="kobo.1346.1"> this book’s GitHub repository. </span><span class="koboSpan" id="kobo.1346.2">Now that you know how to create and use Signal values, next, you will learn how to update </span><span class="No-Break"><span class="koboSpan" id="kobo.1347.1">your Signals.</span></span></p>
<h3><span class="koboSpan" id="kobo.1348.1">Updating Signals</span></h3>
<p><span class="koboSpan" id="kobo.1349.1">A Signal can be updated by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1350.1">set()</span></strong><span class="koboSpan" id="kobo.1351.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1352.1">update()</span></strong><span class="koboSpan" id="kobo.1353.1"> method on it. </span><span class="koboSpan" id="kobo.1353.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1354.1">set()</span></strong><span class="koboSpan" id="kobo.1355.1"> method sets an entirely new</span><a id="_idIndexMarker710"/><span class="koboSpan" id="kobo.1356.1"> value, whereas the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1357.1">update()</span></strong><span class="koboSpan" id="kobo.1358.1"> method allows you to use the current Signal value and construct a new value based on the current value of </span><span class="No-Break"><span class="koboSpan" id="kobo.1359.1">the Signal.</span></span></p>
<p><span class="koboSpan" id="kobo.1360.1">To demonstrate this, let’s add a modal with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1361.1">AddExpenseComponent</span></strong><span class="koboSpan" id="kobo.1362.1"> inside the modal. </span><span class="koboSpan" id="kobo.1362.2">Before you add the form inside the template, let’s update </span><strong class="source-inline"><span class="koboSpan" id="kobo.1363.1">AddExpenseComponent</span></strong><span class="koboSpan" id="kobo.1364.1"> so that it uses our new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1365.1">ExpenseModel</span></strong><span class="koboSpan" id="kobo.1366.1"> instead of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1367.1">AddExpenseReactive</span></strong><span class="koboSpan" id="kobo.1368.1"> model we used in </span><a href="B21625_04.xhtml#_idTextAnchor072"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1369.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.1370.1">. </span><span class="koboSpan" id="kobo.1370.2">Replace all instances of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1371.1">AddExpenseReactive</span></strong><span class="koboSpan" id="kobo.1372.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1373.1">ExpenseModel</span></strong><span class="koboSpan" id="kobo.1374.1">. </span><span class="koboSpan" id="kobo.1374.2">Now, change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1375.1">date</span></strong><span class="koboSpan" id="kobo.1376.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1377.1">tags</span></strong><span class="koboSpan" id="kobo.1378.1"> fields in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1379.1">addExpenseForm</span></strong><span class="koboSpan" id="kobo.1380.1"> property </span><span class="No-Break"><span class="koboSpan" id="kobo.1381.1">to this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1382.1">
date: new FormControl&lt;string | null&gt;(null, [Validators.required]),
tags: new FormArray&lt;FormControl&lt;string | null&gt;&gt;([
  new FormControl(''),
])</span></pre> <p><span class="koboSpan" id="kobo.1383.1">Now that we’ve updated the form so that it uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.1384.1">ExpenseModel</span></strong><span class="koboSpan" id="kobo.1385.1">, let’s import </span><strong class="source-inline"><span class="koboSpan" id="kobo.1386.1">AddExpenseComponent</span></strong><span class="koboSpan" id="kobo.1387.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1388.1">ModalComponent</span></strong><span class="koboSpan" id="kobo.1389.1"> into </span><strong class="source-inline"><span class="koboSpan" id="kobo.1390.1">ExpensesOverviewComponent</span></strong><span class="koboSpan" id="kobo.1391.1"> so that we can use them inside the HTML template. </span><span class="koboSpan" id="kobo.1391.2">Next, create a new Signal in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1392.1">ExpensesOverviewComponent</span></strong><span class="koboSpan" id="kobo.1393.1"> to control the state of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1394.1">modal component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1395.1">
showAddExpenseModal = signal(false);</span></pre> <p><span class="koboSpan" id="kobo.1396.1">After adding the Signal to </span><a id="_idIndexMarker711"/><span class="koboSpan" id="kobo.1397.1">control the modal state, you can add both the modal and expense components to the HTML template, </span><span class="No-Break"><span class="koboSpan" id="kobo.1398.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1399.1">
&lt;bt-libs-modal [shown]=" showAddExpenseModal()" (shownChange)=" showAddExpenseModal.</span><strong class="bold"><span class="koboSpan" id="kobo.1400.1">set</span></strong><span class="koboSpan" id="kobo.1401.1">(false)" [title]="'Add expenses'"&gt;
  &lt;bt-libs-ui-add-expense-form #form (addExpense)="</span><strong class="bold"><span class="koboSpan" id="kobo.1402.1">onAddExpense($event)" </span></strong><span class="koboSpan" id="kobo.1403.1">/&gt;
&lt;/bt-libs-modal&gt;</span></pre> <p><span class="koboSpan" id="kobo.1404.1">As you can see, when the modal outputs the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1405.1">shownChange</span></strong><span class="koboSpan" id="kobo.1406.1"> event, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1407.1">set()</span></strong><span class="koboSpan" id="kobo.1408.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1409.1">showAddExpenseModal</span></strong><span class="koboSpan" id="kobo.1410.1"> Signal to set a new value for the Signal. </span><span class="koboSpan" id="kobo.1410.2">In this scenario, we don’t care about the previous signal value because we know we want to close the modal when this event is fired. </span><span class="koboSpan" id="kobo.1410.3">Because we don’t care about the previous value, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1411.1">set()</span></strong><span class="koboSpan" id="kobo.1412.1"> method on the Signal to set a new value. </span><span class="koboSpan" id="kobo.1412.2">Inside the component class, we need to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1413.1">onAddExpense</span></strong><span class="koboSpan" id="kobo.1414.1"> method so that we can the expense we submit in the add </span><span class="No-Break"><span class="koboSpan" id="kobo.1415.1">expense form:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1416.1">
onAddExpense(expenseToAdd: ExpenseModel) {
  this.expenses.</span><strong class="bold"><span class="koboSpan" id="kobo.1417.1">update</span></strong><span class="koboSpan" id="kobo.1418.1">(expenses =&gt; [...expenses, expenseToAdd]);
  this. </span><span class="koboSpan" id="kobo.1418.2">showAddExpenseModal.</span><strong class="bold"><span class="koboSpan" id="kobo.1419.1">set</span></strong><span class="koboSpan" id="kobo.1420.1">(false);
}</span></pre> <p><span class="koboSpan" id="kobo.1421.1">In the preceding code, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1422.1">update()</span></strong><span class="koboSpan" id="kobo.1423.1"> method to change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1424.1">expenses</span></strong><span class="koboSpan" id="kobo.1425.1"> Signal and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1426.1">set()</span></strong><span class="koboSpan" id="kobo.1427.1"> method for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1428.1">showAddExpenseModal</span></strong><span class="koboSpan" id="kobo.1429.1"> Signal. </span><span class="koboSpan" id="kobo.1429.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1430.1">update()</span></strong><span class="koboSpan" id="kobo.1431.1"> method for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1432.1">expenses</span></strong><span class="koboSpan" id="kobo.1433.1"> Signal to access the current state of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1434.1">expenses</span></strong><span class="koboSpan" id="kobo.1435.1"> and add the new expense to the existing expenses. </span><span class="koboSpan" id="kobo.1435.2">When we submit the form, we also want to close the modal. </span><span class="koboSpan" id="kobo.1435.3">For this, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1436.1">set()</span></strong><span class="koboSpan" id="kobo.1437.1"> method because we just wish to change the Signal to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1438.1">false</span></strong><span class="koboSpan" id="kobo.1439.1"> value and are not interested in the current value of the Signal. </span><span class="koboSpan" id="kobo.1439.2">Lastly, we need a button to open </span><span class="No-Break"><span class="koboSpan" id="kobo.1440.1">the modal:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1441.1">
&lt;button (click)="showAddExpenseModal.set(true)"&gt;Add expense&lt;/button&gt;</span></pre> <p><span class="koboSpan" id="kobo.1442.1">After adding the button, you can open the modal and create a new expense </span><span class="No-Break"><span class="koboSpan" id="kobo.1443.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1444.1">addExpenseForm</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1445.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1446.1">Lastly, it’s good to know that when you</span><a id="_idIndexMarker712"/><span class="koboSpan" id="kobo.1447.1"> update a Signal using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1448.1">set()</span></strong><span class="koboSpan" id="kobo.1449.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1450.1">update()</span></strong><span class="koboSpan" id="kobo.1451.1"> in a component with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1452.1">OnPush</span></strong><span class="koboSpan" id="kobo.1453.1"> change detection, the component will automatically be marked by Angular to be checked for changes. </span><span class="koboSpan" id="kobo.1453.2">As a result, Angular will automatically update the component on the next change </span><span class="No-Break"><span class="koboSpan" id="kobo.1454.1">detection cycle.</span></span></p>
<p><span class="koboSpan" id="kobo.1455.1">Now that you know how to create and update Signals, let’s learn about </span><span class="No-Break"><span class="koboSpan" id="kobo.1456.1">computed Signals.</span></span></p>
<h3><span class="koboSpan" id="kobo.1457.1">Computed Signals</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.1458.1">Computed Signals</span></strong><span class="koboSpan" id="kobo.1459.1"> are one of the concepts that make Signals so powerful. </span><span class="koboSpan" id="kobo.1459.2">A computed Signal is a read-only Signal that derives its</span><a id="_idIndexMarker713"/><span class="koboSpan" id="kobo.1460.1"> value from other Signals. </span><span class="koboSpan" id="kobo.1460.2">Because computed Signals are read-only, you can’t use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1461.1">set()</span></strong><span class="koboSpan" id="kobo.1462.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1463.1">update()</span></strong><span class="koboSpan" id="kobo.1464.1"> method on them. </span><span class="koboSpan" id="kobo.1464.2">Instead, computed Signals automatically update when one or more Signals they derive their value </span><span class="No-Break"><span class="koboSpan" id="kobo.1465.1">from changes.</span></span></p>
<p><span class="koboSpan" id="kobo.1466.1">Let’s start with a basic example to better understand computed Signals and how they work. </span><span class="koboSpan" id="kobo.1466.2">You don’t have to add this example inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1467.1">ExpensesOverviewComponent</span></strong><span class="koboSpan" id="kobo.1468.1">; it’s just for </span><span class="No-Break"><span class="koboSpan" id="kobo.1469.1">demonstration purposes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1470.1">
const count: WritableSignal&lt;number&gt; = signal(0);
const double: Signal&lt;number&gt; = </span><strong class="bold"><span class="koboSpan" id="kobo.1471.1">computed</span></strong><span class="koboSpan" id="kobo.1472.1">(() =&gt; count() * 2);</span></pre> <p><span class="koboSpan" id="kobo.1473.1">In the preceding example, we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1474.1">count</span></strong><span class="koboSpan" id="kobo.1475.1"> Signal and a computed Signal named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1476.1">double</span></strong><span class="koboSpan" id="kobo.1477.1">. </span><span class="koboSpan" id="kobo.1477.2">The computed Signal uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1478.1">computed</span></strong><span class="koboSpan" id="kobo.1479.1"> function, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1480.1">count</span></strong><span class="koboSpan" id="kobo.1481.1"> Signal is used inside the callback of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1482.1">computed</span></strong><span class="koboSpan" id="kobo.1483.1"> function. </span><span class="koboSpan" id="kobo.1483.2">When the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1484.1">count</span></strong><span class="koboSpan" id="kobo.1485.1"> Signal changes to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1486.1">1</span></strong><span class="koboSpan" id="kobo.1487.1">, the value of the computed Signal is automatically updated </span><span class="No-Break"><span class="koboSpan" id="kobo.1488.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1489.1">2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1490.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1491.1">It’s important to know that the computed Signal will only update when the Signal it depends on has a new stable value. </span><span class="koboSpan" id="kobo.1491.2">Notice how I say </span><em class="italic"><span class="koboSpan" id="kobo.1492.1">stable value</span></em><span class="koboSpan" id="kobo.1493.1">; this is because Signals provide their updates asynchronously and work a bit like the RxJS </span><strong class="source-inline"><span class="koboSpan" id="kobo.1494.1">switchMap</span></strong><span class="koboSpan" id="kobo.1495.1"> operator, which cancels the previous data stream if a new stream comes in before the old stream is finished. </span><span class="koboSpan" id="kobo.1495.2">So, if you update the Signal multiple times in a row without pause in between, the Signal will not stabilize its value, and as a result, the computed Signal will only run on the last value change of </span><span class="No-Break"><span class="koboSpan" id="kobo.1496.1">the Signal.</span></span></p>
<p><span class="koboSpan" id="kobo.1497.1">Computed signals are very powerful and also very efficient. </span><span class="koboSpan" id="kobo.1497.2">The computed Signal will not compute a value until the computed value is read for the first time. </span><span class="koboSpan" id="kobo.1497.3">Next, the computed Signal will cache its value, and when you read the computed Signal again, it will simply return the cached</span><a id="_idIndexMarker714"/><span class="koboSpan" id="kobo.1498.1"> value without running any computations. </span><span class="koboSpan" id="kobo.1498.2">If the Signal value that the computed signal uses to derive its value from changes, the computed Signal will run a new computation and update </span><span class="No-Break"><span class="koboSpan" id="kobo.1499.1">its value.</span></span></p>
<p><span class="koboSpan" id="kobo.1500.1">Because computed Signals cache their results, you can safely use computationally expensive operations such as filtering and mapping arrays inside the callback function of your computed Signals. </span><span class="koboSpan" id="kobo.1500.2">Just like regular Signals, computational Signals notify all consumers when their values change. </span><span class="koboSpan" id="kobo.1500.3">As a result, all consumers of computed Signals will show the latest </span><span class="No-Break"><span class="koboSpan" id="kobo.1501.1">computed value.</span></span></p>
<p><span class="koboSpan" id="kobo.1502.1">Now, let’s add a computed Signal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1503.1">ExpensesOverviewComponent</span></strong><span class="koboSpan" id="kobo.1504.1"> for the total amount, </span><span class="No-Break"><span class="koboSpan" id="kobo.1505.1">including VAT:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1506.1">
totalInclVat = computed(() =&gt; this.expenses().reduce((total, { amount: { amountExclVat, vatPercentage } }) =&gt; amountExclVat / 100 * (100 + vatPercentage) + total, 0));</span></pre> <p><span class="koboSpan" id="kobo.1507.1">As you can see, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1508.1">computed</span></strong><span class="koboSpan" id="kobo.1509.1"> function, and inside the callback of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1510.1">computed</span></strong><span class="koboSpan" id="kobo.1511.1"> function, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1512.1">expenses</span></strong><span class="koboSpan" id="kobo.1513.1"> Signal to retrieve the current list of expenses. </span><span class="koboSpan" id="kobo.1513.2">We can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1514.1">Array.reduce</span></strong><span class="koboSpan" id="kobo.1515.1"> function on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1516.1">expenses</span></strong><span class="koboSpan" id="kobo.1517.1"> array to retrieve the total costs, including VAT. </span><span class="koboSpan" id="kobo.1517.2">You can access the computed signal the same as you would a </span><span class="No-Break"><span class="koboSpan" id="kobo.1518.1">regular signal:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1519.1">
this.totalInclVat()</span></pre> <p><span class="koboSpan" id="kobo.1520.1">Let’s create a new table row in the HTML template to display the total value. </span><span class="koboSpan" id="kobo.1520.2">You can add the table row below the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1521.1">for</span></strong><span class="koboSpan" id="kobo.1522.1"> loop in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1523.1">HTML template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1524.1">
&lt;tr class="summary"&gt;
  &lt;td&gt;Total: {{totalInclVat()}}&lt;/td&gt;
&lt;/tr&gt;</span></pre> <p><span class="koboSpan" id="kobo.1525.1">Suppose you add a new expense using the add expense form. </span><span class="koboSpan" id="kobo.1525.2">In that case, you’ll notice that the total amount is automatically updated because the computed Signal uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1526.1">expenses</span></strong><span class="koboSpan" id="kobo.1527.1"> Signal to evaluate the total amount. </span><span class="koboSpan" id="kobo.1527.2">When the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1528.1">expenses</span></strong><span class="koboSpan" id="kobo.1529.1"> Signal changes, the computed Signal will also be updated based on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1530.1">expenses</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1531.1"> Signal.</span></span></p>
<p><span class="koboSpan" id="kobo.1532.1">One last thing that is good to know </span><a id="_idIndexMarker715"/><span class="koboSpan" id="kobo.1533.1">about computed Signals is that only Signals that are used during the computation are tracked. </span><span class="koboSpan" id="kobo.1533.2">For example, let’s say you add a Signal to control if you show or hide the table row summary and another for the corresponding </span><span class="No-Break"><span class="koboSpan" id="kobo.1534.1">button text:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1535.1">
showSummary = signal(false);
summaryBtnText = computed(() =&gt; this.showSummary() ? </span><span class="koboSpan" id="kobo.1535.2">'Hide summary' : 'Show summary');</span></pre> <p><span class="koboSpan" id="kobo.1536.1">You can now use the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.1537.1">showSummary</span></strong><span class="koboSpan" id="kobo.1538.1"> Signal inside the computed Signal </span><span class="No-Break"><span class="koboSpan" id="kobo.1539.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1540.1">
totalInclVat = computed(() =&gt; this.showSummary() ? </span><span class="koboSpan" id="kobo.1540.2">this.expenses().reduce(
    (total, { amount: { amountExclVat, vatPercentage } }) =&gt; amountExclVat / 100 * (100 + vatPercentage) + total,
    0
  ) : null);</span></pre> <p><span class="koboSpan" id="kobo.1541.1">In this scenario, the computed Signal will only track the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1542.1">expenses</span></strong><span class="koboSpan" id="kobo.1543.1"> Signal if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1544.1">showSummary</span></strong><span class="koboSpan" id="kobo.1545.1"> Signal is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1546.1">true</span></strong><span class="koboSpan" id="kobo.1547.1">. </span><span class="koboSpan" id="kobo.1547.2">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1548.1">showSummary</span></strong><span class="koboSpan" id="kobo.1549.1"> Signal is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1550.1">false</span></strong><span class="koboSpan" id="kobo.1551.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1552.1">expenses</span></strong><span class="koboSpan" id="kobo.1553.1"> Signal is never reached within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1554.1">computed</span></strong><span class="koboSpan" id="kobo.1555.1"> function, and because of that, it will not be tracked for changes. </span><span class="koboSpan" id="kobo.1555.2">So, if you update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1556.1">expenses</span></strong><span class="koboSpan" id="kobo.1557.1"> Signal while the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1558.1">showSummary</span></strong><span class="koboSpan" id="kobo.1559.1"> Signal is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1560.1">false</span></strong><span class="koboSpan" id="kobo.1561.1">, the computed Signal will not calculate a </span><span class="No-Break"><span class="koboSpan" id="kobo.1562.1">new value.</span></span></p>
<p><span class="koboSpan" id="kobo.1563.1">Now that you know what computed Signals are, how to use them within your code, and how computed Signals update their values, let’s explore </span><span class="No-Break"><span class="koboSpan" id="kobo.1564.1">Signal effects.</span></span></p>
<h3><span class="koboSpan" id="kobo.1565.1">Signal effects</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.1566.1">Signal effects</span></strong><span class="koboSpan" id="kobo.1567.1"> are side effects that run each time </span><a id="_idIndexMarker716"/><span class="koboSpan" id="kobo.1568.1">a Signal changes. </span><span class="koboSpan" id="kobo.1568.2">You can perform any logic you want inside a Signal effect. </span><span class="koboSpan" id="kobo.1568.3">Some use cases for a Signal effect would be logging, updating local storage, showing notifications, or performing DOM manipulations that can’t be handled from within the </span><span class="No-Break"><span class="koboSpan" id="kobo.1569.1">HTML template.</span></span></p>
<p><span class="koboSpan" id="kobo.1570.1">You can create a Signal effect by </span><a id="_idIndexMarker717"/><span class="koboSpan" id="kobo.1571.1">using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1572.1">effect</span></strong><span class="koboSpan" id="kobo.1573.1"> function and providing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1574.1">effect</span></strong><span class="koboSpan" id="kobo.1575.1"> function with </span><span class="No-Break"><span class="koboSpan" id="kobo.1576.1">a callback:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1577.1">effect</span></strong><span class="koboSpan" id="kobo.1578.1">(() =&gt; { console.log(`Count is: ${count()}`) } );</span></pre> <p><span class="koboSpan" id="kobo.1579.1">Signal effects always run when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1580.1">effect</span></strong><span class="koboSpan" id="kobo.1581.1"> function is initialized. </span><span class="koboSpan" id="kobo.1581.2">Furthermore, when you use a Signal inside the callback of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1582.1">effect</span></strong><span class="koboSpan" id="kobo.1583.1"> function, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1584.1">effect</span></strong><span class="koboSpan" id="kobo.1585.1"> function becomes dependent on that Signal, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1586.1">effect</span></strong><span class="koboSpan" id="kobo.1587.1"> function will run each time one of the Signals it depends on has a new </span><span class="No-Break"><span class="koboSpan" id="kobo.1588.1">stable value.</span></span></p>
<p><span class="koboSpan" id="kobo.1589.1">It is also good to know that just as with computed Signals, a Signal effect only runs if the Signal within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1590.1">effect</span></strong><span class="koboSpan" id="kobo.1591.1"> function can </span><span class="No-Break"><span class="koboSpan" id="kobo.1592.1">be reached:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1593.1">
effect(() =&gt; {
  if (this.showSummary()) {
    console.log(‹Updated expenses:›, this.expenses());
  }
});</span></pre> <p><span class="koboSpan" id="kobo.1594.1">In the preceding example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1595.1">effect</span></strong><span class="koboSpan" id="kobo.1596.1"> function will not run if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1597.1">expenses</span></strong><span class="koboSpan" id="kobo.1598.1"> signal updates while the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1599.1">showSummary</span></strong><span class="koboSpan" id="kobo.1600.1"> signal is evaluated to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.1601.1">false</span></strong><span class="koboSpan" id="kobo.1602.1">. </span><span class="koboSpan" id="kobo.1602.2">Besides unreached Signals, you can also prevent the Signal’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1603.1">effect</span></strong><span class="koboSpan" id="kobo.1604.1"> function from reacting to a Signal by wrapping that Signal in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1605.1">untracked</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1606.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1607.1">
effect = effect(() =&gt; {
  console.log(Summary:', this. </span><span class="koboSpan" id="kobo.1607.2">showSummary ());
  console.log('Expenses:', </span><strong class="bold"><span class="koboSpan" id="kobo.1608.1">untracked</span></strong><span class="koboSpan" id="kobo.1609.1">(this.expenses()));
});</span></pre> <p><span class="koboSpan" id="kobo.1610.1">Another good thing to know about Signal effects is that they need access to the injection context. </span><span class="koboSpan" id="kobo.1610.2">This means you need to declare the Signal inside the constructor or directly assign it to a property where you declare your component properties. </span><span class="koboSpan" id="kobo.1610.3">An error will be thrown when you create a Signal effect outside the injection context. </span><span class="koboSpan" id="kobo.1610.4">If you need to declare a Signal effect outside the injection context, you can provide the effect with the injection context </span><span class="No-Break"><span class="koboSpan" id="kobo.1611.1">like so:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1612.1">injector = inject(Injector);</span></strong><span class="koboSpan" id="kobo.1613.1">
effect(() =&gt; {
  console.log(‹Updated expenses:›, this.expenses());
}, { </span><strong class="bold"><span class="koboSpan" id="kobo.1614.1">injector: this.injector</span></strong><span class="koboSpan" id="kobo.1615.1"> });</span></pre> <p><span class="koboSpan" id="kobo.1616.1">By default, effects clean up when</span><a id="_idIndexMarker718"/><span class="koboSpan" id="kobo.1617.1"> the injection context where the effect is declared is destroyed. </span><span class="koboSpan" id="kobo.1617.2">If you don’t want this to happen and you need manual control over the destruction of the signal effect, you can configure the effect so that it uses </span><span class="No-Break"><span class="koboSpan" id="kobo.1618.1">manual cleanup:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1619.1">
expenseEffect = effect(() =&gt; {
  console.log(‹Updated expenses:›, this.expenses());
}, { </span><strong class="bold"><span class="koboSpan" id="kobo.1620.1">manualCleanup: true</span></strong><span class="koboSpan" id="kobo.1621.1"> });</span></pre> <p><span class="koboSpan" id="kobo.1622.1">After setting </span><strong class="source-inline"><span class="koboSpan" id="kobo.1623.1">manualCleanup</span></strong><span class="koboSpan" id="kobo.1624.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1625.1">true</span></strong><span class="koboSpan" id="kobo.1626.1">, you have to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1627.1">destroy()</span></strong><span class="koboSpan" id="kobo.1628.1"> function on </span><span class="No-Break"><span class="koboSpan" id="kobo.1629.1">the effect:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1630.1">
expenseEffect.destroy();</span></pre> <p><span class="koboSpan" id="kobo.1631.1">You can also hook into the cleanup of a Signal effect by using a callback function. </span><span class="koboSpan" id="kobo.1631.2">This can be useful when you want to perform some logic when the Signal effect is cleaned up. </span><span class="koboSpan" id="kobo.1631.3">Here’s an example of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1632.1">onCleanup</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1633.1"> callback:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1634.1">
effect((</span><strong class="bold"><span class="koboSpan" id="kobo.1635.1">onCleanup</span></strong><span class="koboSpan" id="kobo.1636.1">) =&gt; {
  </span><strong class="bold"><span class="koboSpan" id="kobo.1637.1">onCleanup</span></strong><span class="koboSpan" id="kobo.1638.1">(() =&gt; { console.log('Cleanup logic')})
})</span></pre> <p><span class="koboSpan" id="kobo.1639.1">Besides </span><strong class="source-inline"><span class="koboSpan" id="kobo.1640.1">manualCleanup</span></strong><span class="koboSpan" id="kobo.1641.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1642.1">onCleanup</span></strong><span class="koboSpan" id="kobo.1643.1"> callback, there is one last configuration option for the Signal effects. </span><span class="koboSpan" id="kobo.1643.2">By default, you are not allowed to update Signals inside a Signal effect; this is because this can easily result in infinite executions of the Signal effect. </span><span class="koboSpan" id="kobo.1643.3">However, you can circumvent this by setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1644.1">allowSignalWrites</span></strong><span class="koboSpan" id="kobo.1645.1"> property on the </span><span class="No-Break"><span class="koboSpan" id="kobo.1646.1">Signal effect:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1647.1">
expenseEffect = effect(() =&gt; {
  console.log(‹Updated expenses:›, this.expenses());
}, { </span><strong class="source-inline"><span class="koboSpan" id="kobo.1648.1">allowSignalWrites: true</span></strong><span class="koboSpan" id="kobo.1649.1"> });</span></pre> <p><span class="koboSpan" id="kobo.1650.1">Now that you know all about Signal effects, how to use them, and how you can trigger or configure them, let’s learn</span><a id="_idIndexMarker719"/><span class="koboSpan" id="kobo.1651.1"> about Signal </span><span class="No-Break"><span class="koboSpan" id="kobo.1652.1">component inputs.</span></span></p>
<h3><span class="koboSpan" id="kobo.1653.1">Signal component inputs</span></h3>
<p><span class="koboSpan" id="kobo.1654.1">Since Angular 17.1, you can also use Signals as component input instead of using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1655.1">@Input()</span></strong><span class="koboSpan" id="kobo.1656.1"> decorator. </span><span class="koboSpan" id="kobo.1656.2">Using the </span><strong class="bold"><span class="koboSpan" id="kobo.1657.1">Signal input</span></strong><span class="koboSpan" id="kobo.1658.1"> makes your component more readable and helps you eliminate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1659.1">ngOnChanges</span></strong><span class="koboSpan" id="kobo.1660.1"> life </span><span class="No-Break"><span class="koboSpan" id="kobo.1661.1">cycle hook.</span></span></p>
<p><span class="koboSpan" id="kobo.1662.1">Let’s see an example of a Signal input and compare</span><a id="_idIndexMarker720"/><span class="koboSpan" id="kobo.1663.1"> it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1664.1">@Input()</span></strong><span class="koboSpan" id="kobo.1665.1"> decorator (you don’t have to add the example in the monorepo, it’s just for </span><span class="No-Break"><span class="koboSpan" id="kobo.1666.1">explanatory purposes):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1667.1">
@Input() data!: DataModel; // The old way of doing things
data = </span><strong class="source-inline"><span class="koboSpan" id="kobo.1668.1">input&lt;DataModel&gt;()</span></strong><span class="koboSpan" id="kobo.1669.1">; // The signal input</span></pre> <p><span class="koboSpan" id="kobo.1670.1">As you can see, the Signal input has a much more straightforward approach to declaring input properties. </span><span class="koboSpan" id="kobo.1670.2">You declare a property and assign it with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1671.1">input()</span></strong><span class="koboSpan" id="kobo.1672.1"> function; optionally, you can add the arrow syntax to add a type to the Signal input. </span><span class="koboSpan" id="kobo.1672.2">If you want to provide an initial value to your Signal input, you can provide it as a function parameter, </span><span class="No-Break"><span class="koboSpan" id="kobo.1673.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1674.1">
data = input({ values: [……], id: 1 });</span></pre> <p><span class="koboSpan" id="kobo.1675.1">Just as with the input decorator, you can also make the input required, use an input alias, or create a transform function on </span><span class="No-Break"><span class="koboSpan" id="kobo.1676.1">the input:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1677.1">
data = input.</span><strong class="bold"><span class="koboSpan" id="kobo.1678.1">required</span></strong><span class="koboSpan" id="kobo.1679.1">&lt;DataModel&gt;();
data = input({ values: [……], id: 1 }, </span><strong class="bold"><span class="koboSpan" id="kobo.1680.1">{ alias: 'product'}</span></strong><span class="koboSpan" id="kobo.1681.1">);
data = input({ values: [……], id: 1 }, </span><strong class="bold"><span class="koboSpan" id="kobo.1682.1">transform: sort&lt;DataModel&gt;</span></strong><span class="koboSpan" id="kobo.1683.1">);
export function sort&lt;T&gt;(data: T[]): T[] {
  return data.sort((a, b) =&gt; a.id - b.id)
}</span></pre> <p><span class="koboSpan" id="kobo.1684.1">As you can see, you can make the input required and provide the Signal input with a configuration object to give it an alias and transform function. </span><span class="koboSpan" id="kobo.1684.2">The Signal input uses a simpler syntax, helps improve the change detection mechanism, and allows you to remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1685.1">ngOnChanges</span></strong><span class="koboSpan" id="kobo.1686.1"> life </span><span class="No-Break"><span class="koboSpan" id="kobo.1687.1">cycle hook.</span></span></p>
<p><span class="koboSpan" id="kobo.1688.1">When you combine the Signal input with computed Signals, you can remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1689.1">ngOnChanges</span></strong><span class="koboSpan" id="kobo.1690.1"> life cycle hook because all properties that need to be updated upon the input of a specific property can now automatically be updated by using a computed Signal based on the input Signal. </span><span class="koboSpan" id="kobo.1690.2">Any</span><a id="_idIndexMarker721"/><span class="koboSpan" id="kobo.1691.1"> additional logic you want to run can be declared inside a Signal effect that reacts to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1692.1">Signal input.</span></span></p>
<p><span class="koboSpan" id="kobo.1693.1">Now that you know more about Signal inputs, let’s learn about Signal queries, which are used to interact with HTML </span><span class="No-Break"><span class="koboSpan" id="kobo.1694.1">elements reactively.</span></span></p>
<h3><span class="koboSpan" id="kobo.1695.1">Signal queries</span></h3>
<p><span class="koboSpan" id="kobo.1696.1">Often, you need to select HTML</span><a id="_idIndexMarker722"/><span class="koboSpan" id="kobo.1697.1"> elements from your template and interact with them inside your component class. </span><span class="koboSpan" id="kobo.1697.2">In Angular, this is commonly achieved by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1698.1">@ContentChild</span></strong><span class="koboSpan" id="kobo.1699.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1700.1">@ContentChildren</span></strong><span class="koboSpan" id="kobo.1701.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1702.1">@ViewChild</span></strong><span class="koboSpan" id="kobo.1703.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1704.1">@ViewChildren</span></strong><span class="koboSpan" id="kobo.1705.1"> decorator. </span><span class="koboSpan" id="kobo.1705.2">In Angular 17.2, a new Signal-based approach was introduced that allows you to interact with HTML elements reactively and combine them with computed Signals and Signal effects. </span><span class="koboSpan" id="kobo.1705.3">Using the Signal-based approach instead of decorators offers some </span><span class="No-Break"><span class="koboSpan" id="kobo.1706.1">additional advantages:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1707.1">You can make the query results </span><span class="No-Break"><span class="koboSpan" id="kobo.1708.1">more predictable.</span></span></li>
<li><span class="koboSpan" id="kobo.1709.1">All Signal-based queries return a Signal and when there are multiple values, the Signals returns a regular array. </span><span class="koboSpan" id="kobo.1709.2">The decorators return a variety of return types and when your query returns multiple values, they return a query list instead of a </span><span class="No-Break"><span class="koboSpan" id="kobo.1710.1">regular array.</span></span></li>
<li><span class="koboSpan" id="kobo.1711.1">Signal-based queries can be used for HTML elements that change over time because they are rendered conditionally or outputted in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1712.1">for</span></strong><span class="koboSpan" id="kobo.1713.1"> loop. </span><span class="koboSpan" id="kobo.1713.2">The directive approach has issues with both scenarios and doesn’t automatically notify you when the template </span><span class="No-Break"><span class="koboSpan" id="kobo.1714.1">is updated.</span></span></li>
<li><span class="koboSpan" id="kobo.1715.1">TypeScript can automatically infer the type of the queried HTML element </span><span class="No-Break"><span class="koboSpan" id="kobo.1716.1">or component.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1717.1">Now that you know about the advantages of query-based Signals compared to the directive approach, let’s explore the syntax of query-based Signals. </span><span class="koboSpan" id="kobo.1717.2">Instead of defining a directive, the Signal-based approach works with simple functions. </span><span class="koboSpan" id="kobo.1717.3">There are four different functions: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1718.1">viewChild()</span></strong><span class="koboSpan" id="kobo.1719.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1720.1">contentChild()</span></strong><span class="koboSpan" id="kobo.1721.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1722.1">viewChildren()</span></strong><span class="koboSpan" id="kobo.1723.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1724.1">contentChildren()</span></strong><span class="koboSpan" id="kobo.1725.1">. </span><span class="koboSpan" id="kobo.1725.2">You provide the functions with your query selector, similar to the query selectors you can use in </span><a id="_idIndexMarker723"/><span class="koboSpan" id="kobo.1726.1">combination with decorators. </span><span class="koboSpan" id="kobo.1726.2">Here’s an example of how to use </span><span class="No-Break"><span class="koboSpan" id="kobo.1727.1">Signal queries:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1728.1">
@Component({
  template: `
      &lt;div #el&gt;&lt;/div&gt;
      &lt;my-component /&gt;
  `
})
export class TestComponent {
  divEl = viewChild&lt;ElementRef&gt;('el');
  cmp = viewChild(MyComponent);
}</span></pre> <p><span class="koboSpan" id="kobo.1729.1">In the preceding example, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1730.1">viewChild()</span></strong><span class="koboSpan" id="kobo.1731.1"> query Signal to retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1732.1">&lt;div&gt;</span></strong><span class="koboSpan" id="kobo.1733.1"> element with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1734.1">#el</span></strong><span class="koboSpan" id="kobo.1735.1"> ID defined on it and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1736.1">&lt;my-component&gt;</span></strong><span class="koboSpan" id="kobo.1737.1"> element. </span><span class="koboSpan" id="kobo.1737.2">Alternatively, if you want to retrieve multiple elements with the same selector, you can use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1738.1">viewChildren()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1739.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.1740.1">With that, you know how to query template elements using the new Signal-based approach. </span><span class="koboSpan" id="kobo.1740.2">You also learned what advantages the new Signals-based approach has over decorators. </span><span class="koboSpan" id="kobo.1740.3">Decorators can still be used if you prefer them or have them within </span><span class="No-Break"><span class="koboSpan" id="kobo.1741.1">your codebase.</span></span></p>
<p><span class="koboSpan" id="kobo.1742.1">In this section, you learned about Signals. </span><span class="koboSpan" id="kobo.1742.2">You learned how to create, read, and update Signals using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1743.1">set()</span></strong><span class="koboSpan" id="kobo.1744.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1745.1">update()</span></strong><span class="koboSpan" id="kobo.1746.1"> methods. </span><span class="koboSpan" id="kobo.1746.2">Then, we added some Signals in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1747.1">ExpensesOverviewComponent</span></strong><span class="koboSpan" id="kobo.1748.1"> and learned about computed Signals. </span><span class="koboSpan" id="kobo.1748.2">Lastly, you learned about Signal effects, Signal component inputs, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1749.1">query Signals.</span></span></p>
<p><span class="koboSpan" id="kobo.1750.1">In the previous section, you learned about RxJS; in the next section, you will learn how you can combine RxJS </span><span class="No-Break"><span class="koboSpan" id="kobo.1751.1">and Signals.</span></span></p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.1752.1">Combining Signals and RxJS</span></h1>
<p><span class="koboSpan" id="kobo.1753.1">In this chapter, you’ve seen how Signals and RxJS can help you manage data changes reactively. </span><span class="koboSpan" id="kobo.1753.2">Both Signals and RxJS allow</span><a id="_idIndexMarker724"/><span class="koboSpan" id="kobo.1754.1"> you to react when values change and create new values by combining multiple data streams or performing side effects based on</span><a id="_idIndexMarker725"/><span class="koboSpan" id="kobo.1755.1"> data changes. </span><span class="koboSpan" id="kobo.1755.2">So, the following questions might arise: Do signals replace RxJS? </span><span class="koboSpan" id="kobo.1755.3">And when do I use Signals, and when do I </span><span class="No-Break"><span class="koboSpan" id="kobo.1756.1">use RxJS?</span></span></p>
<p><span class="koboSpan" id="kobo.1757.1">RxJS can sometimes feel daunting and complex, so some developers might be tempted to replace RxJS with Signals completely. </span><span class="koboSpan" id="kobo.1757.2">While this might be possible for some applications, both RxJS and Signals have their place within your applications and solve different problems and needs. </span><span class="koboSpan" id="kobo.1757.3">In many scenarios, you can devise a solution for your problem using Signals or RxJS, but one of the two will do a better job at solving the problem and will handle it with much fewer lines of code. </span><span class="koboSpan" id="kobo.1757.4">Signals are not here to replace RxJS, yet Signals will complement it and, in many scenarios, work together with your </span><span class="No-Break"><span class="koboSpan" id="kobo.1758.1">RxJS code.</span></span></p>
<p><span class="koboSpan" id="kobo.1759.1">Because Signals and RxJS are supposed to co-exist, Angular created two RxJS interoperability functions: </span><strong class="bold"><span class="koboSpan" id="kobo.1760.1">toSignal</span></strong><span class="koboSpan" id="kobo.1761.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.1762.1">toObservable</span></strong><span class="koboSpan" id="kobo.1763.1">. </span><span class="koboSpan" id="kobo.1763.2">While these functions are still in developer preview and might change before they are stable, you can already use them within your applications. </span><span class="koboSpan" id="kobo.1763.3">As the names of the two functions already imply, they are used to convert a Signal into an Observable or to convert an Observable into a Signal, respectively. </span><span class="koboSpan" id="kobo.1763.4">Let’s learn about both, starting with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1764.1">toSignal</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1765.1"> function.</span></span></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.1766.1">Using toSignal</span></h2>
<p><span class="koboSpan" id="kobo.1767.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1768.1">toSignal</span></strong><span class="koboSpan" id="kobo.1769.1"> function is used to </span><a id="_idIndexMarker726"/><span class="koboSpan" id="kobo.1770.1">transform an Observable into a Signal. </span><span class="koboSpan" id="kobo.1770.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1771.1">toSignal</span></strong><span class="koboSpan" id="kobo.1772.1"> function is very similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1773.1">ASYNC</span></strong><span class="koboSpan" id="kobo.1774.1"> pipe, only with more flexibility and configuration options, and it can be </span><a id="_idIndexMarker727"/><span class="koboSpan" id="kobo.1775.1">used anywhere in the application. </span><span class="koboSpan" id="kobo.1775.2">The syntax is pretty straightforward; you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1776.1">toSignal</span></strong><span class="koboSpan" id="kobo.1777.1"> function and supply it with </span><span class="No-Break"><span class="koboSpan" id="kobo.1778.1">an Observable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1779.1">
counter = </span><strong class="bold"><span class="koboSpan" id="kobo.1780.1">toSignal</span></strong><span class="koboSpan" id="kobo.1781.1">(this.countObs$);</span></pre> <p><span class="koboSpan" id="kobo.1782.1">In the preceding example, we converted </span><strong class="source-inline"><span class="koboSpan" id="kobo.1783.1">counterObservable$</span></strong><span class="koboSpan" id="kobo.1784.1"> into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1785.1">counter</span></strong><span class="koboSpan" id="kobo.1786.1"> Signal. </span><span class="koboSpan" id="kobo.1786.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1787.1">toSignal</span></strong><span class="koboSpan" id="kobo.1788.1"> function will immediately subscribe to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1789.1">counterObservable$</span></strong><span class="koboSpan" id="kobo.1790.1">, receiving any values the Observable emits from that point. </span><span class="koboSpan" id="kobo.1790.2">As with regular Signals, you can use the Signals that were created with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1791.1">toSignal</span></strong><span class="koboSpan" id="kobo.1792.1"> function inside computed Signals and Signal effects. </span><span class="koboSpan" id="kobo.1792.2">When </span><strong class="source-inline"><span class="koboSpan" id="kobo.1793.1">toSignal</span></strong><span class="koboSpan" id="kobo.1794.1"> changes its value because the Observable emits a new value, any Signal effect or computed Signal depending on that Signal will </span><span class="No-Break"><span class="koboSpan" id="kobo.1795.1">be triggered.</span></span></p>
<p><span class="koboSpan" id="kobo.1796.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1797.1">toSignal</span></strong><span class="koboSpan" id="kobo.1798.1"> function will also automatically unsubscribe from the Observable, given that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1799.1">toSignal</span></strong><span class="koboSpan" id="kobo.1800.1"> function is used within the injection context. </span><span class="koboSpan" id="kobo.1800.2">When you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1801.1">toSignal</span></strong><span class="koboSpan" id="kobo.1802.1"> function outside the</span><a id="_idIndexMarker728"/><span class="koboSpan" id="kobo.1803.1"> injection context or want to make it dependent on a different injection context, you can provide</span><a id="_idIndexMarker729"/><span class="koboSpan" id="kobo.1804.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1805.1">toSignal</span></strong><span class="koboSpan" id="kobo.1806.1"> function with an injection context, </span><span class="No-Break"><span class="koboSpan" id="kobo.1807.1">like so:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1808.1">injector = inject(Injector);</span></strong><span class="koboSpan" id="kobo.1809.1">
counter = toSignal(this.countObs$, </span><strong class="bold"><span class="koboSpan" id="kobo.1810.1">{injector: this.injector}</span></strong><span class="koboSpan" id="kobo.1811.1">);</span></pre> <p><span class="koboSpan" id="kobo.1812.1">Here, we supplied the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1813.1">toSignal</span></strong><span class="koboSpan" id="kobo.1814.1"> function with an additional configuration object in which we provided the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1815.1">injector</span></strong><span class="koboSpan" id="kobo.1816.1"> property. </span><span class="koboSpan" id="kobo.1816.2">There may also be scenarios where you don’t want the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1817.1">toSignal</span></strong><span class="koboSpan" id="kobo.1818.1"> function to automatically unsubscribe the Observable when the component or injection context </span><span class="No-Break"><span class="koboSpan" id="kobo.1819.1">is destroyed.</span></span></p>
<p><span class="koboSpan" id="kobo.1820.1">You might want to stop the Observable earlier or later, depending on your system’s needs. </span><span class="koboSpan" id="kobo.1820.2">For this scenario, you can provide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1821.1">toSignal</span></strong><span class="koboSpan" id="kobo.1822.1"> function with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1823.1">manualCleanup</span></strong><span class="koboSpan" id="kobo.1824.1"> configuration, similar to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1825.1">Signal effect:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1826.1">
counter = toSignal(this.countObs$, {</span><strong class="bold"><span class="koboSpan" id="kobo.1827.1">manualCleanup: true</span></strong><span class="koboSpan" id="kobo.1828.1">});</span></pre> <p><span class="koboSpan" id="kobo.1829.1">When you set </span><strong class="source-inline"><span class="koboSpan" id="kobo.1830.1">manualCleanup</span></strong><span class="koboSpan" id="kobo.1831.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1832.1">true</span></strong><span class="koboSpan" id="kobo.1833.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1834.1">toSignal</span></strong><span class="koboSpan" id="kobo.1835.1"> function will receive values up to the point the Observable it depends on is completed. </span><span class="koboSpan" id="kobo.1835.2">When the inner Observable has been completed, the Signal will keep returning the last emitted value; this is also the case if you don’t use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1836.1">manualCleanup</span></strong><span class="koboSpan" id="kobo.1837.1"> configuration. </span><span class="koboSpan" id="kobo.1837.2">Besides having control over the unsubscribe process of the Observable used by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1838.1">toSignal</span></strong><span class="koboSpan" id="kobo.1839.1"> function, you can also provide an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1840.1">initialValue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1841.1"> configuration.</span></span></p>
<p><span class="koboSpan" id="kobo.1842.1">The Observable you convert into a Signal might not immediately and synchronously emit a value upon subscription. </span><span class="koboSpan" id="kobo.1842.2">Yet Signals always require an initial value, and if one isn’t provided or the value comes in asynchronously, the initial value of the Signal will be </span><strong class="source-inline"><span class="koboSpan" id="kobo.1843.1">undefined</span></strong><span class="koboSpan" id="kobo.1844.1">. </span><span class="koboSpan" id="kobo.1844.2">Because the initial value of the Signal is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1845.1">undefined</span></strong><span class="koboSpan" id="kobo.1846.1">, the type of the Signal will also be </span><strong class="source-inline"><span class="koboSpan" id="kobo.1847.1">undefined</span></strong><span class="koboSpan" id="kobo.1848.1">. </span><span class="koboSpan" id="kobo.1848.2">To prevent </span><strong class="source-inline"><span class="koboSpan" id="kobo.1849.1">undefined</span></strong><span class="koboSpan" id="kobo.1850.1"> being the initial, you can provide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1851.1">toSignal</span></strong><span class="koboSpan" id="kobo.1852.1"> function with an initial value using </span><span class="No-Break"><span class="koboSpan" id="kobo.1853.1">this syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1854.1">
counter = toSignal(this.countObs$, {</span><strong class="bold"><span class="koboSpan" id="kobo.1855.1">initialValue: 0</span></strong><span class="koboSpan" id="kobo.1856.1">});</span></pre> <p><span class="koboSpan" id="kobo.1857.1">In this scenario, the initial value will be what you have set it to be until a new asynchronous value is received through the Observable. </span><span class="koboSpan" id="kobo.1857.2">Having </span><strong class="source-inline"><span class="koboSpan" id="kobo.1858.1">undefined</span></strong><span class="koboSpan" id="kobo.1859.1"> as your initial value might cause problems inside computed signals or Signal effects that use the Signal with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1860.1">undefined</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1861.1"> value.</span></span></p>
<p><span class="koboSpan" id="kobo.1862.1">On the other hand, some Observables </span><a id="_idIndexMarker730"/><span class="koboSpan" id="kobo.1863.1">emit a synchronous value upon subscription; think of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1864.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.1865.1">, for example. </span><span class="koboSpan" id="kobo.1865.2">If you </span><a id="_idIndexMarker731"/><span class="koboSpan" id="kobo.1866.1">use an Observable that emits a synchronous value upon subscription, you also need to configure this inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1867.1">toSignal</span></strong><span class="koboSpan" id="kobo.1868.1"> function using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1869.1">requireSync</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1870.1"> configuration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1871.1">
counter = toSignal(this.countObs$, {</span><strong class="source-inline"><span class="koboSpan" id="kobo.1872.1">requireSync: true</span></strong><span class="koboSpan" id="kobo.1873.1">});</span></pre> <p><span class="koboSpan" id="kobo.1874.1">By setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1875.1">requireSync</span></strong><span class="koboSpan" id="kobo.1876.1"> option to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1877.1">true</span></strong><span class="koboSpan" id="kobo.1878.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1879.1">toSignal</span></strong><span class="koboSpan" id="kobo.1880.1"> function enforces that the initial value upon subscription is received synchronously, skipping the initial </span><strong class="source-inline"><span class="koboSpan" id="kobo.1881.1">undefined</span></strong><span class="koboSpan" id="kobo.1882.1"> value and typing the Signal as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1883.1">undefined</span></strong><span class="koboSpan" id="kobo.1884.1">. </span><span class="koboSpan" id="kobo.1884.2">Lastly, you can configure how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1885.1">toSignal</span></strong><span class="koboSpan" id="kobo.1886.1"> function should handle errors that happen in </span><span class="No-Break"><span class="koboSpan" id="kobo.1887.1">the Observable.</span></span></p>
<p><span class="koboSpan" id="kobo.1888.1">By default, if the Observable throws an error, the Signal will throw the error whenever the Signal is read. </span><span class="koboSpan" id="kobo.1888.2">You can also set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1889.1">rejectErrors</span></strong><span class="koboSpan" id="kobo.1890.1"> option to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1891.1">true</span></strong><span class="koboSpan" id="kobo.1892.1">; in that case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1893.1">toSignal</span></strong><span class="koboSpan" id="kobo.1894.1"> function will ignore the error and keep returning the last good value the </span><span class="No-Break"><span class="koboSpan" id="kobo.1895.1">Observable emitted:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1896.1">
counter = toSignal(this.countObs$, {</span><strong class="bold"><span class="koboSpan" id="kobo.1897.1">rejectErrors: true</span></strong><span class="koboSpan" id="kobo.1898.1">});</span></pre> <p><span class="koboSpan" id="kobo.1899.1">When you set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1900.1">rejectErrors</span></strong><span class="koboSpan" id="kobo.1901.1"> option to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1902.1">true</span></strong><span class="koboSpan" id="kobo.1903.1">, errors are handled in the same way the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1904.1">ASYNC</span></strong><span class="koboSpan" id="kobo.1905.1"> pipe handles errors </span><span class="No-Break"><span class="koboSpan" id="kobo.1906.1">within Observables.</span></span></p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.1907.1">Using toObservable</span></h2>
<p><span class="koboSpan" id="kobo.1908.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1909.1">toObservable</span></strong><span class="koboSpan" id="kobo.1910.1"> function is used to</span><a id="_idIndexMarker732"/><span class="koboSpan" id="kobo.1911.1"> convert a Signal into </span><a id="_idIndexMarker733"/><span class="koboSpan" id="kobo.1912.1">an Observable. </span><span class="koboSpan" id="kobo.1912.2">Here’s an example of how you can use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1913.1">toObservable</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1914.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1915.1">
counter = toSignal(this.countObs$);
countObs$ = </span><strong class="bold"><span class="koboSpan" id="kobo.1916.1">toObservable(this.counter)</span></strong><span class="koboSpan" id="kobo.1917.1">;</span></pre> <p><span class="koboSpan" id="kobo.1918.1">When you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1919.1">toObservable</span></strong><span class="koboSpan" id="kobo.1920.1"> function behind the scenes, Angular will use a Signal effect to track the values of the Signal you use inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1921.1">toObservable</span></strong><span class="koboSpan" id="kobo.1922.1"> function and emit the updated values to the Observable. </span><span class="koboSpan" id="kobo.1922.2">Because Angular uses a Signal effect to update the values of the Observable, it will only emit stabilized changes in the Signal. </span><span class="koboSpan" id="kobo.1922.3">So, if you set the Signal multiple</span><a id="_idIndexMarker734"/><span class="koboSpan" id="kobo.1923.1"> times in a row without an interval, the Observable that’s created with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1924.1">toObservable</span></strong><span class="koboSpan" id="kobo.1925.1"> will only emit the last value when the Signal </span><span class="No-Break"><span class="koboSpan" id="kobo.1926.1">is stabilized.</span></span></p>
<p><span class="koboSpan" id="kobo.1927.1">By default, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1928.1">toObservable</span></strong><span class="koboSpan" id="kobo.1929.1"> function uses the current injection context to create the Signal effect; if you declare</span><a id="_idIndexMarker735"/><span class="koboSpan" id="kobo.1930.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1931.1">toObservable</span></strong><span class="koboSpan" id="kobo.1932.1"> function outside the injection context or if you want to create the Signal effect inside another injection context, you can provide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1933.1">toObservable</span></strong><span class="koboSpan" id="kobo.1934.1"> function with an </span><span class="No-Break"><span class="koboSpan" id="kobo.1935.1">injection context:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1936.1">injector = inject(Injector);</span></strong><span class="koboSpan" id="kobo.1937.1">
countObs$ = toObservable(this.counter, {</span><strong class="bold"><span class="koboSpan" id="kobo.1938.1">injector: this.injector</span></strong><span class="koboSpan" id="kobo.1939.1">});</span></pre> <p><span class="koboSpan" id="kobo.1940.1">That’s all there is to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1941.1">toObservable</span></strong><span class="koboSpan" id="kobo.1942.1"> function – there are no other configuration options; you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1943.1">toObservable</span></strong><span class="koboSpan" id="kobo.1944.1"> function and provide the function with your Observable to convert the Signal into an Observable. </span><span class="koboSpan" id="kobo.1944.2">You can also combine both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1945.1">toSignal</span></strong><span class="koboSpan" id="kobo.1946.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1947.1">toObservable</span></strong><span class="koboSpan" id="kobo.1948.1"> functions in </span><span class="No-Break"><span class="koboSpan" id="kobo.1949.1">one go.</span></span></p>
<p><span class="koboSpan" id="kobo.1950.1">Here’s an example of how you could use a Signal input and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1951.1">toObservable</span></strong><span class="koboSpan" id="kobo.1952.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1953.1">toSignal</span></strong><span class="koboSpan" id="kobo.1954.1"> functions to fetch a new product and convert it into a Signal each time the component receives a new </span><span class="No-Break"><span class="koboSpan" id="kobo.1955.1">ID input:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1956.1">
id = input(0);
product = </span><strong class="bold"><span class="koboSpan" id="kobo.1957.1">toSignal</span></strong><span class="koboSpan" id="kobo.1958.1">(
  </span><strong class="bold"><span class="koboSpan" id="kobo.1959.1">toObservable</span></strong><span class="koboSpan" id="kobo.1960.1">(this.id).pipe(
  switchMap((id) =&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.1961.1">this.service.getProduct(id as number)</span></strong><span class="koboSpan" id="kobo.1962.1">),
 ),
 { initialValue: null }
);</span></pre> <p><span class="koboSpan" id="kobo.1963.1">Now that you know how to combine RxJS and Signals by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1964.1">toSignal</span></strong><span class="koboSpan" id="kobo.1965.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1966.1">toObservable</span></strong><span class="koboSpan" id="kobo.1967.1"> functions, let’s finish this </span><a id="_idIndexMarker736"/><span class="koboSpan" id="kobo.1968.1">chapter by providing a bit more clarity about when to use Signals and when to </span><span class="No-Break"><span class="koboSpan" id="kobo.1969.1">use RxJS.</span></span></p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.1970.1">Choosing between Signals and RxJS</span></h2>
<p><span class="koboSpan" id="kobo.1971.1">As mentioned previously, neither Signals nor RxJS are one-size-fits-all solutions. </span><span class="koboSpan" id="kobo.1971.2">When you’re building an application, chances are you’ll need both Signals and RxJS to create the most optimal code. </span><span class="koboSpan" id="kobo.1971.3">The most</span><a id="_idIndexMarker737"/><span class="koboSpan" id="kobo.1972.1"> straightforward distinction is that Signals handle synchronous code, and RxJS is used to handle synchronous code, but things aren’t always as simple. </span><span class="koboSpan" id="kobo.1972.2">You could also convert synchronous code using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1973.1">toSignal</span></strong><span class="koboSpan" id="kobo.1974.1"> function. </span><span class="koboSpan" id="kobo.1974.2">For clarity, we’ll go through some examples at face value and determine if using</span><a id="_idIndexMarker738"/><span class="koboSpan" id="kobo.1975.1"> Signals or RxJS would be better. </span><span class="koboSpan" id="kobo.1975.2">In the real world, there are always nuances, and you should take whatever best fits your scenario, the team, and the existing code of </span><span class="No-Break"><span class="koboSpan" id="kobo.1976.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.1977.1">Let’s start with an HTML template. </span><span class="koboSpan" id="kobo.1977.2">In an HTML template, you can use an RxJS Observable by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1978.1">ASYNC</span></strong><span class="koboSpan" id="kobo.1979.1"> pipe, or you can use a Signal. </span><span class="koboSpan" id="kobo.1979.2">I would try to use Signals in the HTML template as this simplifies the HTML template by maintaining a synchronous approach. </span><span class="koboSpan" id="kobo.1979.3">Using Signals will also help improve the change detection mechanism Angular uses, which can improve your </span><span class="No-Break"><span class="koboSpan" id="kobo.1980.1">application’s performance.</span></span></p>
<p><span class="koboSpan" id="kobo.1981.1">There are more gray areas in the component classes where it might be more complex to determine whether to use a Signal or RxJS Observable. </span><span class="koboSpan" id="kobo.1981.2">If we look at the local component state, I would use Signals and computed Signals to define the component state; this also allows you to consume the component state as signals inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.1982.1">HTML template.</span></span></p>
<p><span class="koboSpan" id="kobo.1983.1">When it comes to handling user events, it depends a bit on how you need to process the values of the event. </span><span class="koboSpan" id="kobo.1983.2">If it’s a simple event such as handling a form submission or a button click, a Signal will work perfectly fine to update the correlating values. </span><span class="koboSpan" id="kobo.1983.3">If you need more control over the delivery of the value stream, combine multiple events, or map, filter, and transform the data stream before it reaches your application logic, RxJS will be a </span><span class="No-Break"><span class="koboSpan" id="kobo.1984.1">better fit.</span></span></p>
<p><span class="koboSpan" id="kobo.1985.1">A typical example is when you have a search input field that makes API requests. </span><span class="koboSpan" id="kobo.1985.2">You don’t want to make too many API requests by firing an API call on each key-up event. </span><span class="koboSpan" id="kobo.1985.3">Instead, you want to check if the user stopped typing for a specified interval. </span><span class="koboSpan" id="kobo.1985.4">Using RxJS, this can be done using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1986.1">debounceTime</span></strong><span class="koboSpan" id="kobo.1987.1"> operator. </span><span class="koboSpan" id="kobo.1987.2">You can handle the same functionality using a Signal, but this requires a lot more code, and it becomes more complex and less readable. </span><span class="koboSpan" id="kobo.1987.3">Depending on your architecture, most other scenarios that are handled inside your components are connected with your facade services or </span><span class="No-Break"><span class="koboSpan" id="kobo.1988.1">state management.</span></span></p>
<p><span class="koboSpan" id="kobo.1989.1">Now, let’s discuss some </span><a id="_idIndexMarker739"/><span class="koboSpan" id="kobo.1990.1">different scenarios and compare Signals with RxJS. </span><span class="koboSpan" id="kobo.1990.2">Events that have to be distributed throughout the application and where different parts of your application have to react differently are also best handled using RxJS, more specifically an RxJS </span><strong class="source-inline"><span class="koboSpan" id="kobo.1991.1">Subject</span></strong><span class="koboSpan" id="kobo.1992.1">. </span><span class="koboSpan" id="kobo.1992.2">Using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1993.1">Subject</span></strong><span class="koboSpan" id="kobo.1994.1"> class, each part of your application can listen for the Observable and react how it needs </span><span class="No-Break"><span class="koboSpan" id="kobo.1995.1">to react.</span></span></p>
<p><span class="koboSpan" id="kobo.1996.1">Defining simple synchronous </span><a id="_idIndexMarker740"/><span class="koboSpan" id="kobo.1997.1">global application states can be done using Signals and computed Signals. </span><span class="koboSpan" id="kobo.1997.2">The current value of the state can be retrieved by using Signals. </span><span class="koboSpan" id="kobo.1997.3">Additionally, you can define change events using RxJS subjects if different application parts need to perform different logic when the values change. </span><span class="koboSpan" id="kobo.1997.4">You can trigger the RxJS subjects inside your state management using a signal effect. </span><span class="koboSpan" id="kobo.1997.5">Using the Signal effect might only work if reacting on stabilized value changes is enough; if you need to react to multiple changes that follow on from each other, this approach will not work </span><span class="No-Break"><span class="koboSpan" id="kobo.1998.1">for you.</span></span></p>
<p><span class="koboSpan" id="kobo.1999.1">When you have more complex state or asynchronous sources that need to be modified, combined, filtered, or mapped before you can provide the values to the rest of your application, RxJS is the best solution to handle the data streams. </span><span class="koboSpan" id="kobo.1999.2">Especially when you need to handle multiple nested Observables or if you want to combine various streams and need control over when and how the values of these different streams are processed, RxJS offers many more tools to handle </span><span class="No-Break"><span class="koboSpan" id="kobo.2000.1">this gracefully.</span></span></p>
<p><span class="koboSpan" id="kobo.2001.1">Inside your facade services, you can combine RxJS and Signals. </span><span class="koboSpan" id="kobo.2001.2">Depending on the complexity and setup of your state, a good approach is to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2002.1">toObservable</span></strong><span class="koboSpan" id="kobo.2003.1"> function and RxJS to create the models you need to expose to the view layer. </span><span class="koboSpan" id="kobo.2003.2">Once you’ve mapped all the data streams into the models and values you need, you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.2004.1">toSignal</span></strong><span class="koboSpan" id="kobo.2005.1">, Signals, and computed Signals to expose the values to the view layer. </span><span class="koboSpan" id="kobo.2005.2">Then, inside the view layer, you can consume the Signals synchronously while the facade service updates </span><span class="No-Break"><span class="koboSpan" id="kobo.2006.1">them asynchronously.</span></span></p>
<p><span class="koboSpan" id="kobo.2007.1">Now that you have a better idea of when to use Signals and when to use RxJS, let’s move on to the next chapter and start learning about </span><span class="No-Break"><span class="koboSpan" id="kobo.2008.1">state management.</span></span></p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.2009.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.2010.1">In this chapter, you learned about reactive programming. </span><span class="koboSpan" id="kobo.2010.2">You learned what reactive programming is, how the Angular framework uses it, and how it can be utilized to make your code efficient, event-driven, </span><span class="No-Break"><span class="koboSpan" id="kobo.2011.1">and performant.</span></span></p>
<p><span class="koboSpan" id="kobo.2012.1">Next, we did a deep dive into RxJS and saw how it can be used to create and handle Observable streams. </span><span class="koboSpan" id="kobo.2012.2">You learned about different types of Observables and how to combine, flatten, and modify Observable streams using RxJS operators. </span><span class="koboSpan" id="kobo.2012.3">We also explored some of the most used RxJS operators and learned how to create operators using the </span><span class="No-Break"><span class="koboSpan" id="kobo.2013.1">pipe function.</span></span></p>
<p><span class="koboSpan" id="kobo.2014.1">After understanding RxJS, we moved on to Angular Signals. </span><span class="koboSpan" id="kobo.2014.2">You learned why Angular introduced Signals into the framework and how they help simplify your Angular code and improve the performance of your applications. </span><span class="koboSpan" id="kobo.2014.3">You learned about Signals, computed Signals, the Signal effect, and interoperability functions for Signals and RxJS. </span><span class="koboSpan" id="kobo.2014.4">We finished this chapter by exploring when you should use Signals and when to use RxJS within </span><span class="No-Break"><span class="koboSpan" id="kobo.2015.1">your applications.</span></span></p>
<p><span class="koboSpan" id="kobo.2016.1">In the next chapter, we will take a deep dive into </span><span class="No-Break"><span class="koboSpan" id="kobo.2017.1">state management.</span></span></p>
</div>
</body></html>