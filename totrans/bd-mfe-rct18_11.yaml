- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Deploying Microfrontends to Kubernetes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将微前端部署到Kubernetes
- en: In the previous chapter, we learned how to manually deploy our microfrontends
    to a static storage provider such as Firebase.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何手动将我们的微前端部署到静态存储提供商，如Firebase。
- en: In this chapter, we will go deeper into cloud and DevOps territory by learning
    how to deploy our apps to a managed Kubernetes cluster. Kubernetes has become
    the de facto choice to deploy enterprise-grade web apps (both backend and frontend)
    to the cloud.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过学习如何将我们的应用程序部署到托管Kubernetes集群来深入了解云和DevOps领域。Kubernetes已成为将企业级Web应用程序（包括后端和前端）部署到云中的事实标准。
- en: When it comes to deploying SPAs, we run usually the webpack `build` command
    to generate our JavaScript bundles and assets in the `/build` or `/dist` folder,
    which we then simply copy to a static website hosting provider to make our app
    available to our users. However, deploying microfrontends is a bit more complex.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到部署单页应用程序（SPAs）时，我们通常运行webpack的`build`命令来生成我们的JavaScript包和资产在`/build`或`/dist`文件夹中，然后我们只需将其复制到静态网站托管提供商，以便我们的应用程序可供用户使用。然而，部署微前端要复杂得多。
- en: In this chapter, we will see how to deploy our module-federated microfrontend
    to a managed Kubernetes cluster.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何将我们的模块联邦微前端部署到托管Kubernetes集群。
- en: 'We will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: How to containerize our apps using Docker
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Docker容器化我们的应用程序
- en: The basics of Kubernetes and its various components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes及其各种组件的基本知识
- en: Some basic commands to manage our Kubernetes cluster
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些基本命令来管理我们的Kubernetes集群
- en: DevOps and how to automate deploying our micro-apps to Kubernetes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DevOps以及如何自动化部署我们的微应用程序到Kubernetes
- en: By the end of this chapter, we will have our microfrontend apps running on a
    Kubernetes cluster in Azure. We will deploy them via an automated **Continuous
    Integration** (**CI**) and **Continuous Delivery** (**CD**) pipeline that will
    automatically build and deploy the necessary apps whenever code is merged.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将使我们的微前端应用程序在Azure上的Kubernetes集群中运行。我们将通过自动化的**持续集成**（**CI**）和**持续交付**（**CD**）管道来部署它们，该管道将在代码合并时自动构建和部署必要的应用程序。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In addition to all the standard technical requirements that we mentioned in
    the previous chapters, you will need the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在前几章中提到的所有标准技术要求之外，你还需要以下内容：
- en: An Azure cloud subscription
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure云订阅
- en: Access to GitHub and GitHub Actions
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问GitHub和GitHub Actions
- en: A high-level understanding of CI and CD concepts
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对CI和CD概念的高级理解
- en: Knowledge of Docker and containerizing apps will be helpful
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Docker和应用程序容器化将有所帮助
- en: 'The code files for this chapter can be found at the following URL, where we
    essentially started with the microfrontend we built in [*Chapter* *6*](B18987_06.xhtml#_idTextAnchor093):
    [https://github.com/PacktPublishing/Building-Micro-Frontends-with-React](https://github.com/PacktPublishing/Building-Micro-Frontends-with-React).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下URL找到，我们基本上从[*第6章*](B18987_06.xhtml#_idTextAnchor093)中构建的微前端开始：[https://github.com/PacktPublishing/Building-Micro-Frontends-with-React](https://github.com/PacktPublishing/Building-Micro-Frontends-with-React)。
- en: We also assume you have a basic working knowledge of Git, such as branching
    committing code and raising a pull request.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还假设你具备Git的基本操作知识，例如分支、提交代码和发起拉取请求。
- en: Introduction to Kubernetes
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes简介
- en: '**Kubernetes**, also known as **K8s**, has taken the cloud and DevOps world
    by storm. Originally developed by Google and now part of the Cloud Native Computing
    Foundation, Kubernetes provides all the tools necessary to deploy and manage large-scale,
    mission-critical applications on the cloud from a single interface.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kubernetes**，也称为**K8s**，已经席卷了云和DevOps世界。最初由谷歌开发，现在成为云原生计算基金会的一部分，Kubernetes提供所有必要的工具，通过单一界面在云上部署和管理大规模、关键任务应用程序。'
- en: Traditionally, managing a large-scale, production-grade application on the cloud
    meant having to deal with things such as web servers, load balancers, auto-scaling,
    and internal and external traffic routing. Kubernetes now brings all of that under
    a single umbrella and provides a consistent way to manage all the components of
    a cloud environment.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，在云上管理大规模、生产级应用程序意味着必须处理诸如Web服务器、负载均衡器、自动扩展以及内部和外部流量路由等问题。现在，Kubernetes将所有这些整合到一个统一的框架下，并提供了一种一致的方式来管理云环境中的所有组件。
- en: The premise of Kubernetes is that you tell it the end state of what you want
    via a spec file, and Kubernetes will go about getting it done for you. For example,
    if you tell Kubernetes that you want three replicas for your application with
    a service load balancer, Kubernetes will figure out how to spin up the three replicas
    and ensure that the traffic is equally distributed between the three replicas.
    If, for some reason, one of the pods restarts or shuts down, Kubernetes will automatically
    spin up a new pod to ensure that, at any given time, three replicas of the pod
    service traffic. Similarly, when you deploy a new version of the app, Kubernetes
    will take over the responsibility of gradually spinning up new pods with the latest
    version of the app, while gracefully shutting down the pods with the older version
    of the application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的前提是您通过规范文件告诉它您想要的最终状态，然后 Kubernetes 会着手为您完成。例如，如果您告诉 Kubernetes
    您想要三个具有服务负载均衡器的应用程序副本，Kubernetes 将会计算出如何启动三个副本，并确保流量在三个副本之间均匀分布。如果由于某种原因，其中一个
    Pod 重新启动或关闭，Kubernetes 将自动启动一个新的 Pod，以确保在任何给定时间都有三个 Pod 副本的服务流量。同样，当您部署应用程序的新版本时，Kubernetes
    将负责逐步启动具有最新应用程序版本的新的 Pod，同时优雅地关闭具有旧版本应用程序的 Pod。
- en: Through the rest of this section, we will look at some of the key components
    of Kubernetes that apply to us, along with the architecture to deploy our microfrontend
    on Kubernetes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的剩余部分，我们将探讨 Kubernetes 的关键组件，以及如何在 Kubernetes 上部署我们的微前端架构。
- en: What is Kubernetes?
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 Kubernetes？
- en: Kubernetes is a platform-agnostic container orchestration platform that enables
    the deployment, scaling, and management of containerized applications in a cluster
    of machines.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个平台无关的容器编排平台，它能够在机器集群中部署、扩展和管理容器化应用程序。
- en: It abstracts the underlying infrastructure, allowing you to run your applications
    in a variety of environments, including on-premises data centers, public cloud
    providers such as Microsoft Azure, Google Cloud Platform, and Amazon Web Services,
    and even on your own laptop.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 它抽象了底层基础设施，允许您在各种环境中运行应用程序，包括本地数据中心、公共云提供商（如微软 Azure、谷歌云平台和亚马逊网络服务），甚至在自己的笔记本电脑上。
- en: Kubernetes is designed to be highly modular and extensible, and it integrates
    with a variety of tools and services to support the complete life cycle of an
    application, including deployment, scaling, monitoring, and maintenance. It is
    widely adopted in the industry and has become the de facto standard for container
    orchestration.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 被设计成高度模块化和可扩展的，并且它集成了各种工具和服务，以支持应用程序的完整生命周期，包括部署、扩展、监控和维护。它在业界得到了广泛的应用，并已成为容器编排的事实标准。
- en: Key concepts of Kubernetes
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 的关键概念
- en: 'Kubernetes can be quite a vast topic and would need a dedicated area of focus
    to go deep into it. You can go into the details of the various components of Kubernetes
    here: [https://kubernetes.io/docs/concepts/overview/components](https://kubernetes.io/docs/concepts/overview/components).
    However, as a frontend engineer and for the scope of this book, there are six
    basic concepts and terms that you need to be aware of:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 可以是一个非常广泛的话题，需要专门的领域来深入探讨。您可以在以下链接中查看 Kubernetes 各个组件的详细信息：[https://kubernetes.io/docs/concepts/overview/components](https://kubernetes.io/docs/concepts/overview/components)。然而，作为一个前端工程师，以及本书的范围，您需要了解以下六个基本概念和术语：
- en: '**Nodes**: A node is a worker machine in a Kubernetes cluster. It can be a
    physical or virtual machine, and it is responsible for running the containerized
    applications deployed to it.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Nodes**：节点是 Kubernetes 集群中的工作机器。它可以是物理机或虚拟机，负责运行部署到其上的容器化应用程序。'
- en: '**Pods**: A pod is the basic execution unit of a Kubernetes application. It
    is a logical host for one or more containers, as well as all containers in a pod
    run on the same node. Pods provide a shared context for containers, such as shared
    storage and networking.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pods**：Pod 是 Kubernetes 应用程序的基本执行单元。它是一个或多个容器的逻辑宿主，Pod 中的所有容器都在同一节点上运行。Pod
    为容器提供了一个共享的上下文，例如共享存储和网络。'
- en: '**Services**: A service is a logical abstraction over a group of pods. It defines
    a policy to access the pods, typically via a stable IP address or DNS name. Services
    allow you to decouple the dependencies between your applications, enabling you
    to scale or update a group of pods without affecting the consumers of the service.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Services**：服务是一组 Pod 上的逻辑抽象。它定义了访问 Pod 的策略，通常是通过一个稳定的 IP 地址或 DNS 名称。服务允许您解耦应用程序之间的依赖关系，使您能够在不影响服务消费者的情况下扩展或更新一组
    Pod。'
- en: '**Deployments**: A deployment is a declarative way to manage a ReplicaSet,
    which is a set of identical pods that are deployed to the cluster. Deployments
    allow you to specify the desired state of your application, and Kubernetes will
    ensure that the actual state matches the desired state. This includes rolling
    updates, rollbacks, and self-healing.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Deployments**：部署是一种声明式管理 ReplicaSet 的方式，ReplicaSet 是一组部署到集群中的相同 Pod。部署允许您指定应用程序的期望状态，Kubernetes
    将确保实际状态与期望状态相匹配。这包括滚动更新、回滚和自我修复。'
- en: '**Ingress**: Ingress is a way to expose your services to the external world.
    It provides a way to map external traffic to a specific service in your cluster,
    typically via a stable IP address or DNS name. Ingress can also provide additional
    features, such as SSL termination and load balancing. Think of it as a router
    where a URL is mapped to a service.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ingress**：Ingress 是将您的服务暴露给外部世界的一种方式。它提供了一种将外部流量映射到集群中特定服务的方法，通常是通过一个稳定的
    IP 地址或 DNS 名称。Ingress 还可以提供额外的功能，例如 SSL 终止和负载均衡。将其想象成一个将 URL 映射到服务的路由器。'
- en: '**Namespaces**: A namespace is a logical partition in a Kubernetes cluster.
    It allows you to use the same resources (such as names) in different contexts,
    and it can be used to isolate resources within a cluster.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Namespaces**：命名空间是 Kubernetes 集群中的一个逻辑分区。它允许您在不同的上下文中使用相同的资源（例如名称），并且可以用于在集群内隔离资源。'
- en: Kubernetes architecture for microfrontends
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 微前端架构
- en: When deploying our microfrontends on Kubernetes, we create a pod for each micro
    app, and this micro app is exposed internally via an Ingress service.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 Kubernetes 上部署微前端时，为每个微应用创建一个 Pod，并且这个微应用通过 Ingress 服务内部暴露。
- en: 'The home app module federates all these micro-apps. The following diagram helps
    to explain the architecture better:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 主应用模块将所有这些微应用联邦起来。以下图表有助于更好地解释架构：
- en: '![Figure 8.1 – Kubernetes topology architecture to deploy microfrontends](img/Figure_8.01_B18987.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 部署微前端使用的 Kubernetes 拓扑架构](img/Figure_8.01_B18987.jpg)'
- en: Figure 8.1 – Kubernetes topology architecture to deploy microfrontends
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 部署微前端使用的 Kubernetes 拓扑架构
- en: As you can see in *Figure 8**.1*, each of our micro-apps is deployed within
    its own pod. These pods can be replicated or set to auto-scale as traffic increases.
    This is denoted by the dotted box around the pod. These pods are exposed via a
    service, which acts as a sort of load balancer. Therefore, the home app service
    is the single endpoint for all the replications of the home micro app pod.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在 *图 8**.1* 中所见，我们的每个微应用都部署在其自己的 Pod 中。这些 Pod 可以根据流量增加进行复制或设置为自动扩展。这由围绕 Pod
    的虚线框表示。这些 Pod 通过服务暴露，该服务充当一种负载均衡器。因此，主页应用服务是所有主页微应用 Pod 复制的单一端点。
- en: Each of the services is exposed via an Ingress route. This is where we define
    the URL for our micro app, which eventually will be used in our module federation
    configuration. This is what the overall Kubernetes architecture will look like.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务都通过 Ingress 路由暴露。这是我们定义微应用 URL 的地方，这最终将用于我们的模块联邦配置。这就是整体 Kubernetes 架构将看起来像什么。
- en: With this, we come to the end of this section, where we learned about some of
    the key concepts of Kubernetes, such as nodes, pods, services, Ingress, and the
    architecture of our micro-apps within a Kubernetes cluster. In the next section,
    we will see how to go about containerizing our app so that it can be deployed
    into a Kubernetes cluster.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一点，我们来到了本节的结尾，在这里我们了解了一些 Kubernetes 的关键概念，例如节点、Pod、服务、Ingress 以及我们 Kubernetes
    集群内微应用的架构。在下一节中，我们将看到如何将我们的应用容器化，以便它可以部署到 Kubernetes 集群中。
- en: Containerizing our micro-apps with Docker
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 容器化我们的微应用
- en: Containers are a way to package software applications in a standardized and
    portable way, allowing them to run consistently across different environments.
    They provide a lightweight and efficient way to run applications and are particularly
    well-suited for microservices architectures, where an application is composed
    of multiple, independently deployable services.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是一种以标准化和可移植的方式打包软件应用程序的方法，允许它们在不同的环境中一致地运行。它们提供了一种轻量级且高效的运行应用程序的方式，特别适合于由多个独立可部署服务组成的微服务架构。
- en: In this section, we will look at how to install Docker and create a Docker image
    by creating a Dockerfile.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何通过创建Dockerfile来安装Docker并创建Docker镜像。
- en: Installing Docker
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Docker
- en: 'Docker Engine is available for personal use on multiple Linux, Mac, and Windows
    systems via Docker Desktop. You can follow the instructions here to install the
    Docker engine: [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Engine可以通过Docker Desktop在多个Linux、Mac和Windows系统上供个人使用。您可以按照以下说明安装Docker引擎：[https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)。
- en: Note
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you don’t want to or can’t use Docker Desktop on your Windows or Mac, there
    are alternatives, such as Rancher Desktop, Podman, and Colima.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在Windows或Mac上使用Docker Desktop，有一些替代方案，例如Rancher Desktop、Podman和Colima。
- en: 'Once you have Docker installed, verify it by running the following command
    in the terminal:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了Docker，请在终端中运行以下命令以验证它：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If it returns the version of Docker, then you are all set, and it means that
    Docker was installed successfully on your system.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它返回Docker的版本，那么你就设置好了，这意味着Docker已经在你的系统上成功安装。
- en: Creating standalone app builds
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建独立应用构建
- en: 'Before we can start creating a Docker image, we will first need to ensure that
    the build outputs of our micro apps are self-contained and can run in standalone
    mode. We do this by adding the following lines in each of the `next.config.js`
    files, like so:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建Docker镜像之前，我们首先需要确保我们的微应用的构建输出是自包含的，并且可以以独立模式运行。我们通过在每个`next.config.js`文件中添加以下行来实现这一点，如下所示：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`outputFileTracingRoot` is an experimental feature introduced in Next.js 12+
    onward; this helps reduce the size of the build outputs, especially when we want
    to try and reduce our Docker image sizes.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`outputFileTracingRoot`是Next.js 12+版本中引入的一个实验性功能；这有助于减少构建输出的体积，尤其是在我们想要尝试减少Docker镜像大小时。'
- en: Make sure to add these lines to the `next.config.js` file for each of the micro
    apps.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将这些行添加到每个微应用的`next.config.js`文件中。
- en: Creating a Dockerfile
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Dockerfile
- en: The next step is to create our Dockerfile, which contains the instructions for
    Docker to create our Docker image.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建我们的Dockerfile，其中包含Docker创建我们的Docker镜像的指令。
- en: Since we need to create a Docker image for each micro app, we will create a
    Dockerfile within `apps/home`. The default filename we usually give to this is
    `Dockerfile`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要为每个微应用创建一个Docker镜像，我们将在`apps/home`中创建一个Dockerfile。我们通常给这个文件取的名字是`Dockerfile`。
- en: Let's add the following commands to this Dockerfile. We will use the default
    Dockerfile provided by Turborepo and Next.js.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Dockerfile中添加以下命令。我们将使用Turborepo和Next.js提供的默认Dockerfile。
- en: We will build our Dockerfile as a multi-stage file, which allows us to leverage
    the caching of the layers and also ensures that the size of the Docker image is
    as small as possible.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个多阶段Dockerfile，这允许我们利用层的缓存，同时也确保Docker镜像的大小尽可能小。
- en: 'We will build it in three stages, starting with the builder stage:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分三个阶段来构建它，首先是构建阶段：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, we use a base image of Node Alpine 18.14, and we call it the
    builder stage. Alpine is the most minimalistic version of Node.js.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用Node Alpine 18.14作为基础镜像，并将其称为构建阶段。Alpine是Node.js最简约的版本。
- en: Now, we install the `libc6-compact` library and run the `update` command. Then,
    we set the working directory for the app and install turbo.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们安装`libc6-compact`库并运行`update`命令。然后，我们设置应用程序的工作目录并安装turbo。
- en: Then, we copy everything from our repo (note the space between the two periods
    in the `COPY` command).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将从我们的repo复制所有内容（注意`COPY`命令中两个点之间的空格）。
- en: Finally, we run the `turbo prune` command to extract all the files necessary
    for the home micro app.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们运行`turbo prune`命令以提取所有必要的文件，用于主微应用。
- en: 'Now, we will move on to the installer stage and continue writing the following
    code immediately after the previous code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将进入安装阶段，并在上一段代码之后立即编写以下代码：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Again, we start by defining the base image as the installer, running the regular
    `apk add` and `update` commands, and setting the working directory.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们首先定义基础镜像为安装程序，运行常规的`apk add`和`update`命令，并设置工作目录。
- en: Then, we copy the `.gitignore` file as well as the relevant files from the `/app/out`
    folder from the builder stage.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`.gitignore`文件以及从`/app/out`文件夹中的相关文件从构建阶段复制过来。
- en: We then install `pnpm` and run the `pnpm` install command.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着安装`pnpm`并运行`pnpm` install命令。
- en: Then, we copy all the files from the `app/out/full` folder from our builder
    stage and run the `turbo` `build` command.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将从我们的构建阶段的`app/out/full`文件夹中复制所有文件并运行`turbo` `build`命令。
- en: 'Then, we move on to the final runner stage where we write the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续到最后一个运行阶段，在那里我们编写以下代码：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we basically create a user group to avoid the security
    risks of running the code as root, and then we copy the relevant files from our
    installer stage and run the `node` command.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们基本上创建了一个用户组来避免以root身份运行代码的安全风险，然后我们复制了从我们的安装阶段的相关文件并运行了`node`命令。
- en: 'Now, we need to create a `.dockerignore` file in the root of the repo, where
    we list the files and folders that we don’t want Docker to copy to the image:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在仓库的根目录中创建一个`.dockerignore`文件，其中我们列出我们不希望Docker复制到镜像中的文件和文件夹：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s test the Dockerfile to see whether it builds. From the root of the application,
    run the following command in the terminal:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试Dockerfile，看看它是否能够构建。从应用程序的根目录，在终端中运行以下命令：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`-t` stands for the tag name, and it will create a Docker image with the name
    `home`. The `-f` part is the path to the Dockerfile.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`-t`代表标签名称，它将创建一个名为`home`的Docker镜像。`-f`部分是Dockerfile的路径。'
- en: Note the space and period at the end of the command, which is important. The
    period at the end denotes the build context – that is, the set of files and folders
    Docker should use to build the image. The period also denotes that we want to
    package all the files and folders in the current directory.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意命令末尾的空格和句号，这是很重要的。命令末尾的句号表示构建上下文——即Docker构建镜像时应使用的文件和文件夹集合。句号还表示我们想要打包当前目录中的所有文件和文件夹。
- en: This command will take several minutes to run on its first time, as Docker will
    download the base node image and other dependencies. The subsequent builds will
    be a lot faster, as Docker will cache the layers and reuse them if the layer hasn’t
    changed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令在第一次运行时可能需要几分钟，因为Docker将下载基础节点镜像和其他依赖项。后续的构建将会快得多，因为Docker将缓存层并重用它们，如果层没有变化的话。
- en: 'You can run the Docker image locally by running the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令在本地运行Docker镜像：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once we’ve verified that this works fine, we will need to create similar Dockerfiles
    for each of our apps.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们验证了它运行正常，我们还需要为我们的每个应用程序创建类似的Dockerfile。
- en: So, in `apps/catalog` and `apps/checkout`, copy and paste the Dockerfile and
    replace all instances of `home` with the relevant micro app name.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`apps/catalog`和`apps/checkout`中，复制并粘贴Dockerfile，并将所有`home`实例替换为相关的微应用名称。
- en: Note that each of these micro apps runs on the same port, `3000`, so to test
    them locally, we can test only one image at a time, unless you change the `hostPort`
    value to something different or use a docker-compose file.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些微应用都在相同的端口`3000`上运行，因此为了在本地测试它们，我们一次只能测试一个镜像，除非您将`hostPort`值更改为不同的值或使用docker-compose文件。
- en: Now that we have learned how to dockerize our micro apps and run them locally,
    we will move on to the next section on setting up Docker Hub.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何将我们的微应用docker化并在本地运行，我们将继续到下一节，即设置Docker Hub。
- en: Setting up Docker Hub to store Docker images
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Docker Hub以存储Docker镜像
- en: 'In the previous section, we created Docker images of our apps and were able
    to run them locally. For us to be able to deploy them on Kubernetes, we need to
    store them in a container library from where our DevOps pipelines can pull the
    images. We will use a free artifact registry solution such as Docker Hub for this.
    Alternatively, you can use other container registry solutions provided by various
    hosting providers, such as Azure Container Registry, Google Container Registry,
    and Amazon Elastic Container Registry:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了应用程序的Docker镜像并能够在本地运行它们。为了能够在Kubernetes上部署它们，我们需要将它们存储在一个容器库中，以便我们的DevOps管道可以从中拉取镜像。我们将使用像Docker
    Hub这样的免费工件注册解决方案来完成这项工作。或者，您可以使用各种托管提供商提供的其他容器注册解决方案，例如Azure Container Registry、Google
    Container Registry和Amazon Elastic Container Registry：
- en: 'Log in/register at [https://hub.docker.com](https://hub.docker.com), and then
    create three public repositories one for each micro-app. We will call them the
    following:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[https://hub.docker.com](https://hub.docker.com)登录/注册，然后为每个微应用创建三个公共仓库。我们将它们命名为以下：
- en: '**ebuy-home**'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ebuy-home**'
- en: '**ebuy-catalog**'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ebuy-catalog**'
- en: '**ebuy-checkout**'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ebuy-checkout**'
- en: Make a note of the Docker registry paths, which are usually of the **<your-username>/ebuy-home**
    format, **<your-username>/ebuy-catalog** format, and so on.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记下Docker注册表的路径，通常为**<你的用户名>/ebuy-home**格式，**<你的用户名>/ebuy-catalog**格式，等等。
- en: Then, let's create an access token that will be needed for our CI and CD pipelines.
    Go to **Account Settings**, and on the **Security** page, create a new access
    token and give it a description. Under **Access permissions**, select **Read and
    Write**, as our pipelines will need to push and pull the Docker images.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们创建一个访问令牌，它将用于我们的CI和CD管道。转到**账户设置**，在**安全**页面创建一个新的访问令牌，并为其提供描述。在**访问权限**下，选择**读取和写入**，因为我们的管道需要推送和拉取Docker镜像。
- en: Once the token is generated, copy and keep it safe, as it will never be displayed
    again. (You can always generate a new token if you’ve lost the old one.)
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦生成令牌，请复制并妥善保管，因为它将不会再显示。（如果您丢失了旧令牌，您始终可以生成新令牌。）
- en: Our work on Docker Hub is done!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Docker Hub上的工作完成了！
- en: In the next section, we will create our Kubernetes configuration files that
    will be used to spin up our Kubernetes cluster.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将创建用于启动我们的Kubernetes集群的Kubernetes配置文件。
- en: Creating a Kubernetes configuration file
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Kubernetes配置文件
- en: Earlier in this chapter, in the *Introduction to Kubernetes* section, we learned
    about the various Kubernetes services that we will use to deploy our microfrontends.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，在*Kubernetes简介*部分，我们学习了我们将使用来部署我们的微前端的各种Kubernetes服务。
- en: Deploying these services on Kubernetes is commonly done by defining the various
    configuration settings in a `.yaml` file and then applying the configuration to
    the Kubernetes cluster.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes上部署这些服务通常是通过在`.yaml`文件中定义各种配置设置，然后将配置应用到Kubernetes集群来完成的。
- en: In this section, we will learn about the structure of these Kubernetes spec
    files and how to go about creating them for our deployments, services, and Ingress.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解这些Kubernetes规范文件的结构以及如何为我们的部署、服务和Ingress创建它们。
- en: The structure of a Kubernetes spec file
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes规范文件的结构
- en: A Kubernetes spec file is a YAML document that describes the desired state of
    a Kubernetes object, such as a Deployment, Pod, Service, or ConfigMap. The structure
    of a Kubernetes spec file generally consists of two main parts – the metadata
    section and the spec section. Each file always starts by defining the `apiVersion`
    and the `kind` of spec file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes规范文件是一个YAML文档，它描述了Kubernetes对象（如Deployment、Pod、Service或ConfigMap）的期望状态。Kubernetes规范文件的结构通常由两个主要部分组成——元数据部分和规范部分。每个文件始终从定义`apiVersion`和规范文件的`kind`开始。
- en: The metadata section includes information about the object, such as its name,
    labels, and annotations. This section is used by Kubernetes to manage the object
    and enable other objects to reference it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据部分包括有关对象的信息，例如其名称、标签和注解。该部分由Kubernetes用于管理对象并允许其他对象引用它。
- en: The spec section includes the desired state of the object, such as the container
    image, resource requests and limits, networking configuration, and any other relevant
    settings. This section is used by Kubernetes to create and manage the object according
    to its desired state.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 规范部分包括对象期望的状态，例如容器镜像、资源请求和限制、网络配置以及任何其他相关设置。该部分由Kubernetes用于根据其期望状态创建和管理对象。
- en: Creating spec files to deploy our microfrontends
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建部署我们的微前端的规范文件
- en: As we saw earlier, the structure of a Kubernetes spec file follows a hierarchical
    format, with each section and its corresponding properties nested under the appropriate
    heading. Additionally, many Kubernetes objects have properties that are specific
    to their type, so the structure of the spec file may vary depending on the object
    being described.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，Kubernetes规范文件的结构遵循分层格式，每个部分及其相应的属性都嵌套在适当的标题下。此外，许多Kubernetes对象具有特定于其类型的属性，因此规范文件的结构可能因描述的对象而异。
- en: Let's start by creating these files in a folder called `k8s` within each of
    the micro apps folders.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在每个微应用文件夹中的`k8s`文件夹内创建这些文件开始。
- en: 'Let’s start by creating the `/apps/home/k8s/deployment.yml` file with the following
    code. The `deployment.yml` file contains the configuration to set up and configure
    the Kubernetes pods within which our micro app will run:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为`/apps/home/k8s/deployment.yml`的文件开始，并包含以下代码。`deployment.yml`文件包含了设置和配置Kubernetes
    pods的配置，我们的微应用将在其中运行：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you read through the `deployment.yml` configuration file, you will see that
    we label the app as `home` and also use the same name to define the name of our
    container. We define the number of replicas as one, which means it will spin up
    one pod; increase this number to two or more if you want multiple replicas of
    the pod. Then, within the container section of the file, we define the name of
    the path of the Docker image it should use and the ports and protocols that it
    should use. Replace this with the values of your Docker repository. Note `:latest`
    at the end of the Docker image value; this is something we add to ensure that
    Kubernetes always picks up the latest version of the Docker image.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当你阅读`deployment.yml`配置文件时，你会看到我们将应用程序标记为`home`，并使用相同的名称来定义我们的容器名称。我们定义副本数量为1，这意味着它将启动一个pod；如果你想有多个pod副本，请将此数字增加到2或更多。然后，在文件的容器部分，我们定义它应使用的Docker镜像路径名称以及它应使用的端口和协议。用你的Docker仓库的值替换这些值。注意Docker镜像值末尾的`:latest`；这是我们添加的，以确保Kubernetes总是获取Docker镜像的最新版本。
- en: Now, we define the service, which acts as a sort of load balancer over one or
    more replicas of the pod.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们定义服务，它作为负载均衡器，在pod的一个或多个副本上工作。
- en: 'Create a new file called `/apps/home/k8s/service.yml` with the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，名为`/apps/home/k8s/service.yml`，并包含以下代码：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `service.yml` file is quite straightforward, wherein we provide the necessary
    metadata such as the `name`, `label`, and `namespace` for the Kubernetes cluster.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`service.yml`文件相当简单，其中我们提供了必要的元数据，例如Kubernetes集群的`name`、`label`和`namespace`。'
- en: Then, within the specs, we define what type of service this is; we will set
    it as a `LoadBalancer`. This will help expose a public IP address that we will
    need later and, finally, within the `ports` section, the protocol and port numbers
    on which we will expose the service.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在规格中，我们定义了这种服务的类型；我们将将其设置为`LoadBalancer`。这将帮助我们暴露一个公共IP地址，我们稍后会用到，最后，在`ports`部分，我们定义了我们将在此上暴露服务的协议和端口号。
- en: Finally, we need to define the `ingress.yml` file where we will assign a URL
    to the service. Create a file called `/apps/home/k8s/ingress.yml` with the following
    code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要定义一个`ingress.yml`文件，我们将在这里为服务分配一个URL。创建一个名为`/apps/home/k8s/ingress.yml`的文件，并包含以下代码。
- en: 'The Ingress within Kubernetes essentially runs nginx under the hood, so if
    you are familiar with nginx, configuring this should be easy:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的Ingress本质上在底层运行nginx，所以如果你熟悉nginx，配置这个应该很容易：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is generally a bit of a tricky file to configure, as this is where you
    define the URL structures and rewrite rules and other nginx configurations as
    you’d do for a web server. As you can see, we define the regular metadata information
    under annotations, and we define the various rewrite rules and nginx configurations,
    such as CORS. Then, we set the `regex` path, which tells Kubernetes through which
    URLs it should direct traffic to this service and pod. Finally we need to copy
    and paste the K8s folder into each of our micro apps and update the relevant paths
    and app names to match the name of the micro app.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件配置起来通常有点棘手，因为这是你定义URL结构和重写规则以及其他nginx配置的地方，就像为Web服务器做的那样。正如你所看到的，我们在注释下定义了常规元数据信息，并定义了各种重写规则和nginx配置，例如CORS。然后，我们设置`regex`路径，它告诉Kubernetes通过哪些URL将流量导向此服务和pod。最后，我们需要将K8s文件夹复制粘贴到我们的每个微应用中，并更新相关路径和应用程序名称以匹配微应用的名称。
- en: As we come to the end of this section, we’ve seen how to create Kubernetes spec
    files to deploy pods, how to set up a service that sits over these pods, and finally,
    the ingress that provides routing to these pods. In the next section, we will
    create an Azure Kubernetes cluster, against which we will execute these specs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入本节的结尾时，我们已经看到了如何创建Kubernetes规范文件来部署pod，如何设置位于这些pod之上的服务，以及最后提供这些pod路由的ingress。在下一节中，我们将创建一个Azure
    Kubernetes集群，我们将针对这些规范执行。
- en: Setting up a managed Kubernetes Cluster on Azure
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Azure上设置托管Kubernetes集群
- en: In this section, we will learn how to set up a managed Kubernetes cluster on
    Azure. The reason it’s called *managed* is because the master node, which is sort
    of the brain of Kubernetes, is managed by Azure, and we only need to spin up the
    worker nodes. We will see how to log in to Azure and create a subscription key,
    and we will install Azure CLI and collect the various credentials that we need
    for our DevOps pipeline.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在Azure上设置一个托管Kubernetes集群。之所以称之为*托管*，是因为Kubernetes的大脑，即主节点，由Azure管理，我们只需要启动工作节点。我们将了解如何登录Azure并创建订阅密钥，以及我们将安装Azure
    CLI并收集我们DevOps管道所需的各项凭证。
- en: For this chapter, we will use **Azure Kubernetes Service** (**AKS**) to set
    up our cloud-based managed Kubernetes cluster. You can also set up a managed Kubernetes
    cluster on Google Cloud using **Google Kubernetes Engine** (**GKE**), or you can
    use Amazon **Elastic Kubernetes Service** (**EKS**) on AWS.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将使用**Azure Kubernetes服务**（**AKS**）来设置我们的基于云的托管Kubernetes集群。您也可以在Google
    Cloud上使用**Google Kubernetes Engine**（**GKE**）设置托管Kubernetes集群，或者您可以在AWS上使用Amazon
    **Elastic Kubernetes Service**（**EKS**）。
- en: Irrespective of whichever hosting provider you use to set up your Kubernetes
    cluster, the Dockerfile and the Kubernetes configuration `.yaml` files remain
    the same.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用哪个托管提供商来设置您的Kubernetes集群，Dockerfile和Kubernetes配置`.yaml`文件都保持不变。
- en: Logging into the Azure portal and setting up a subscription key
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 登录Azure门户并设置订阅密钥
- en: 'To carry out any activity on the Azure platform, you need to have the login
    credentials for the platform and a subscription key. All the resources that we
    create within Azure need to be mapped to a subscription key, which eventually
    is used by Azure to calculate the hosting charges. To do this, follow these steps:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Azure平台上执行任何活动，您需要该平台的登录凭据和订阅密钥。我们在Azure中创建的所有资源都需要映射到一个订阅密钥，该密钥最终由Azure用来计算托管费用。为此，请按照以下步骤操作：
- en: Head over to [https://portal.azure.com](https://portal.azure.com) and log in
    with a Microsoft login; if you don’t have one, you can always sign up for one.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到[https://portal.azure.com](https://portal.azure.com)并使用Microsoft登录；如果您没有，您始终可以注册一个。
- en: Once logged into the portal, search for **Subscriptions** and add a **Pay-As-You-Go**
    subscription. If you have an **Azure for Student** or free trial subscription
    in your list, feel free to select either one of them as well. This subscription
    will be used for all the hosting costs that will be incurred as part of the various
    services you run within Azure.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到门户后，搜索**订阅**并添加一个**按量付费**订阅。如果您列表中有**Azure for Student**或免费试用订阅，也可以随意选择其中一个。此订阅将用于您在Azure中运行的各项服务所产生的所有托管费用。
- en: Then, in the search box, search for **Resource Group** and create a resource
    group. Let’s call it **ebuy-rg**; the **rg** suffix stands for **resource group**.
    It would have selected the default subscription that you created in the earlier
    step. For the region, you can select **US East** or a region of your choice; for
    the sake of consistency in this chapter, we will stick with **US East**.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在搜索框中搜索**资源组**并创建一个资源组。让我们称它为**ebuy-rg**；**rg**后缀代表**资源组**。它将选择您在早期步骤中创建的默认订阅。对于区域，您可以选择**美国东部**或您选择的区域；为了保持本章的一致性，我们将坚持使用**美国东部**。
- en: In Azure, it is always a good practice to create a resource group for a project
    and then have all the various services associated with that project within the
    resource group. This allows us to easily manage the resources within the resource
    group, especially when we want to shut down all the services for the project.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Azure中，为项目创建一个资源组，然后在该资源组中拥有与该项目相关的所有各种服务，始终是一个好习惯。这使我们能够轻松管理资源组内的资源，尤其是在我们想要关闭项目中的所有服务时。
- en: 'Next, we will create our AKS cluster; search for **Azure Kubernetes Service
    (AKS)**, click on the **Create** button in the top-left corner, and then select
    the **Create a Kubernetes cluster** menu item. You will be presented with a screen,
    as shown in the following screenshot:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的AKS集群；搜索**Azure Kubernetes Service (AKS**)，点击左上角的**创建**按钮，然后选择**创建Kubernetes集群**菜单项。您将看到一个屏幕，如下面的截图所示：
- en: '![Figure 8.2 – The Create Kubernetes cluster screen](img/Figure_8.02_B18987.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 创建Kubernetes集群屏幕](img/Figure_8.02_B18987.jpg)'
- en: Figure 8.2 – The Create Kubernetes cluster screen
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 创建Kubernetes集群屏幕
- en: Select the subscription and resource group we created in the earlier steps,
    and then, in the Cluster preset configuration, select **Production Standard**
    as the preset configuration. You can also choose other higher configurations;
    however, note that the AKS cluster is the most expensive component of your Azure
    monthly billing.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们在早期步骤中创建的订阅和资源组，然后在集群预设配置中，选择**生产标准**作为预设配置。您也可以选择其他更高的配置；然而，请注意，AKS集群是您Azure每月账单中最昂贵的组件。
- en: Provide the Kubernetes cluster name as **ebuy**, and select the same region
    where you have your resource group created; in our case, it is **(US) East US**.
    For the Kubernetes version, you can choose to leave it as default or select **1.26.6**
    to ensure the settings are consistent with the code and configuration defined
    in the chapter. For the scale method, set it to **Autoscale**, and for the maximum
    number of nodes, leave it at **1** or **2**. Finally, hit **Review + Create**,
    and then after the validation check is done, hit **Create**.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Kubernetes集群名称指定为**ebuy**，并选择您创建资源组的相同区域；在我们的案例中，它是**(US) East US**。对于Kubernetes版本，您可以选择将其保留为默认值或选择**1.26.6**以确保设置与章节中定义的代码和配置保持一致。对于缩放方法，将其设置为**自动缩放**，对于最大节点数，保留为**1**或**2**。最后，点击**审查
    + 创建**，然后在进行验证检查后，点击**创建**。
- en: We now have our Kubernetes cluster running within AKS.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经在AKS中运行了我们的Kubernetes集群。
- en: Accessing your Kubernetes cluster via the Azure CLI
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过Azure CLI访问您的Kubernetes集群
- en: The de facto approach to interacting with your Kubernetes cluster on Azure is
    via the Azure CLI at [https://learn.microsoft.com/en-us/cli/azure/](https://learn.microsoft.com/en-us/cli/azure/).
    If you are working with Kubernetes it is best to also install kubectl, the instructions
    for which you can find here [https://kubernetes.io/docs/tasks/tools/install-kubectl-macos/](https://kubernetes.io/docs/tasks/tools/install-kubectl-macos/)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与Azure上的Kubernetes集群交互的事实上方法是使用Azure CLI，您可以在[https://learn.microsoft.com/en-us/cli/azure/](https://learn.microsoft.com/en-us/cli/azure/)找到它。如果您正在使用Kubernetes，最好也安装kubectl，安装说明请在此处查看[https://kubernetes.io/docs/tasks/tools/install-kubectl-macos/](https://kubernetes.io/docs/tasks/tools/install-kubectl-macos/)
- en: Follow the documentation at the preceding URL to get the Azure CLI set up on
    your system.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 按照前述URL的文档在您的系统上设置Azure CLI。
- en: 'Once you have the Azure CLI up and running, the next step is to log in using
    the following command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Azure CLI启动并运行，下一步就是使用以下命令登录：
- en: '[PRE11]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once you’ve successfully logged in, it will display the details of the subscription
    and tenant details for your subscription.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 成功登录后，它将显示您的订阅和租户详情。
- en: 'Run a couple of the following commands to get a feel for the Azure CLI and
    the basic Kubernetes commands:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令中的几个，以了解Azure CLI和基本Kubernetes命令：
- en: '**az aks list** //: To get a list of all your aks clusters'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**az aks list** //: 获取所有aks集群的列表'
- en: '**az aks get-credentials --resource-group ebuy-rg --name ebuy** //: To connect
    to your aks cluster'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**az aks get-credentials --resource-group ebuy-rg --name ebuy** //: 连接到您的aks集群'
- en: '**kubectl get nodes** //: To get a list of all the nodes'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kubectl get nodes** //: 获取所有节点的列表'
- en: '**kubectl get pods** //: To get a list of all the pods running (we don’t have
    any pods running yet, so don’t worry if you get an error message)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kubectl get pods** //: 获取所有正在运行的Pods的列表（我们还没有运行任何Pods，所以如果您收到错误消息请不要担心）'
- en: 'These are just a few commands to help you get started; if you are keen to learn
    about the rest of the kubectl commands head over to the official *kubectl Cheat*
    *Sheet*: [https://kubernetes.io/docs/reference/kubectl/cheatsheet/](https://kubernetes.io/docs/reference/kubectl/cheatsheet/).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是一些帮助您开始的命令；如果您想了解kubectl命令的其余部分，请前往官方*kubectl Cheatsheet*：[https://kubernetes.io/docs/reference/kubectl/cheatsheet/](https://kubernetes.io/docs/reference/kubectl/cheatsheet/).
- en: Once you are happy trying out the different kubectl commands and comfortable
    interacting with your Kubernetes cluster, we will proceed to the next step of
    gathering the necessary credentials to automate deployments.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您对不同的kubectl命令感到满意，并且与您的Kubernetes集群交互感到舒适，我们将继续下一步，收集自动化部署所需的必要凭证。
- en: Generating credentials for your DevOps pipelines
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为您的DevOps管道生成凭证
- en: For any DevOps pipeline to access the various resources on Azure to spin up
    Kubernetes clusters, it will need access permissions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何DevOps管道要访问Azure上的各种资源以启动Kubernetes集群，它将需要访问权限。
- en: We will now collect the necessary access permissions. Ensure that you are logged
    in at [https://portal.azure.com](https://portal.azure.com), or log in via the
    `az login` CLI command.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将收集必要的访问权限。请确保您已登录到[https://portal.azure.com](https://portal.azure.com)，或者通过`az
    login` CLI命令登录。
- en: 'The following is a list of IDs and secrets that we need from Azure and the
    process to find them within the Azure portal:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们从Azure获取的ID和密钥列表以及如何在Azure门户中找到它们的过程：
- en: '**Subscription ID**: Search for **Subscriptions** and select your subscription
    to display the subscription ID.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订阅ID**：搜索**订阅**并选择您的订阅以显示订阅ID。'
- en: '**Tenant ID**: Search for **Azure Active Directory** and note the Tenant_ID
    displayed'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**租户ID**：搜索**Azure Active Directory**并记录显示的Tenant_ID'
- en: 'Then, we need to create a service principle that can create and manage resources
    within our resource group; we do that using the az CLI. In the terminal, fire
    the following command, replacing **{subscriptionid}** with the value you noted
    in the previous steps, and **{resource-group}** with the name of the resource
    group; in this case, it is **ebuy-rg**:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们需要创建一个服务主体，以便在我们的资源组内创建和管理资源；我们使用az CLI来完成这项工作。在终端中，执行以下命令，将**{subscriptionid}**替换为上一步骤中记录的值，将**{resource-group}**替换为资源组的名称；在这种情况下，它是**ebuy-rg**：
- en: '[PRE12]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Run the command, and if all goes well, it will publish a list of configuration
    variables, as shown in *Figure 8**.3*, which you can easily save for further use.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行命令，如果一切顺利，它将发布一个配置变量的列表，如图*图8.3*所示，您可以轻松保存以供进一步使用。
- en: '![Figure 8.3 – Output from running the command to create a service principle](img/Figure_8.03_B18987.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 创建服务主体命令的输出](img/Figure_8.03_B18987.jpg)'
- en: Figure 8.3 – Output from running the command to create a service principle
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 创建服务主体命令的输出
- en: Note down the configurations from the preceding output, as we will need it in
    the following steps.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 记录前一步输出的配置，因为我们将在后续步骤中使用它。
- en: Now that we have all the necessary credentials we need, let's proceed to the
    next section on setting up the CI and CD pipelines where we will use these credentials.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有必要的凭证，让我们继续下一节，设置CI和CD管道，我们将使用这些凭证。
- en: Setting up CI/CD with GitHub Actions
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GitHub Actions设置CI/CD
- en: In this section, we will learn how to go about setting up a DevOps pipeline
    using GitHub Actions. A DevOps pipeline is a series of steps that we define to
    automate the build and deployment of our apps. In this section, we will learn
    how to set up GitHub secrets and the workflow .`yml` file.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用GitHub Actions设置DevOps管道。DevOps管道是我们定义的一系列步骤，用于自动化我们应用程序的构建和部署。在本节中，我们将学习如何设置GitHub密钥和`.yml`工作流程文件。
- en: GitHub Actions is an automation and workflow tool provided by GitHub that allows
    developers to automate software development workflows and streamline their software
    development process. With GitHub Actions, you can create custom workflows that
    automate tasks such as building, testing, deploying, and releasing code directly
    from your GitHub repository. Other tools that we can use for CI and CD are Jenkins,
    Azure DevOps, Google Cloud Build, and so on. For the purpose of this chapter,
    we will use GitHub Actions.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions是GitHub提供的一个自动化和工作流程工具，允许开发者自动化软件开发工作流程并简化软件开发过程。使用GitHub Actions，您可以直接从GitHub仓库创建自定义工作流程来自动化构建、测试、部署和发布代码。我们还可以使用Jenkins、Azure
    DevOps、Google Cloud Build等工具进行持续集成和持续部署。在本章中，我们将使用GitHub Actions。
- en: Setting up GitHub secrets
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置GitHub密钥
- en: As part of the CI and CD steps, GitHub Actions needs to push the Docker image
    to Docker Hub and spin up new Kubernetes pods, and so on. For all these activities,
    it needs to be able to log in to the systems with the right credentials. As a
    rule and for security purposes, we should never directly hardcode the usernames
    or passwords directly into the DevOps pipelines. The correct way is to create
    GitHub secrets and use those in your pipelines.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 作为CI和CD步骤的一部分，GitHub Actions需要将Docker镜像推送到Docker Hub并启动新的Kubernetes pod等。对于所有这些活动，它需要能够使用正确的凭证登录到系统。作为规则和安全起见，我们绝不应该直接将用户名或密码硬编码到DevOps管道中。正确的方式是创建GitHub密钥并在您的管道中使用它们。
- en: First and foremost, make sure you have committed and pushed the latest changes
    we’ve made so far to GitHub.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保您已将我们迄今为止所做的最新更改提交并推送到GitHub。
- en: 'Let''s create our GitHub secrets by first going to the **Settings** tab on
    the GitHub repo and then to the **Secrets and variables** section. Then, under
    **Actions**, we will create the following secrets along with the corresponding
    values that we noted down earlier from Docker and the Azure subscription:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先转到 GitHub 仓库的 **设置** 选项卡，然后转到 **秘密和变量** 部分，来创建我们的 GitHub secrets。然后，在 **动作**
    下，我们将创建以下秘密，以及之前从 Docker 和 Azure 订阅中记录的相应值：
- en: '[PRE13]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We will create these as secrets in our DevOps pipeline. These secrets can be
    accessed in the pipeline as `${{` `secrets.<variable-name> }}`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 DevOps 管道中创建这些作为秘密。这些秘密可以在管道中通过 `${{` `secrets.<variable-name> }}` 访问。
- en: Getting started with GitHub Actions
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用 GitHub Actions
- en: GitHub Actions is a relatively new feature provided by GitHub that allows you
    to create workflows to automate tasks. It can also be used to set up an automated
    CI and CD pipeline, which is exactly what we will use it for in this chapter.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 是 GitHub 提供的一个相对较新的功能，允许您创建工作流程来自动化任务。它也可以用来设置自动化的 CI/CD 管道，这正是我们在本章中将要使用的。
- en: Note
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can read more about GitHub Actions in detail here: [https://docs.github.com/en/actions](https://docs.github.com/en/actions).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处详细了解 GitHub Actions：[https://docs.github.com/en/actions](https://docs.github.com/en/actions)。
- en: 'Creating a GitHub action is straightforward. All we need to do is, at the root
    of our project folder, create a folder called `.github/workflows` and then a `.yaml`
    file. Once pushed to GitHub, it will automatically detect that you have a workflow
    file and it will execute it as per the triggers:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 GitHub action 非常简单。我们只需要在我们的项目文件夹根目录下创建一个名为 `.github/workflows` 的文件夹，然后创建一个
    `.yaml` 文件。一旦推送到 GitHub，它将自动检测到您有一个工作流程文件，并按照触发器执行它：
- en: 'Let''s create our **.yaml** file at **.github/workflows/home-build-deploy.yml**,
    and within it, let’s write the following code:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `.github/workflows/home-build-deploy.yml` 中创建我们的 **.yaml** 文件，并在其中编写以下代码：
- en: '[PRE14]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will provide a name for our GitHub action; which is what will be shown in
    GitHub Actions. Then, we define the triggers, `on push:` and `on:workflow_dispatch`.
    The `workflow_dispatch` trigger allows you to manually trigger a pipeline when
    needed (especially when testing your pipelines), and as you can see, `on push`
    has further options for `branches: main` and `paths: apps/catalog/**`. This means
    a change to any file within the `home micro-app` that is pushed to the `main`
    branch will trigger this pipeline. The `paths` section is critical to ensure that
    the pipeline builds and deploys only the changed micro app.'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '我们将为我们的 GitHub action 提供一个名称；这是在 GitHub Actions 中显示的名称。然后，我们定义触发器，`on push:`
    和 `on:workflow_dispatch`。`workflow_dispatch` 触发器允许您在需要时手动触发管道（尤其是在测试您的管道时），如您所见，`on
    push` 有进一步的选项 `branches: main` 和 `paths: apps/catalog/**`。这意味着对推送到 `main` 分支的
    `home micro-app` 中的任何文件的更改将触发此管道。`paths` 部分对于确保管道只构建和部署更改的微应用至关重要。'
- en: 'Now, we need to define the list of jobs that GitHub actions should run; we
    will do this as follows:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要定义 GitHub actions 应该运行的作业列表；我们将如下进行：
- en: '[PRE15]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For every job we define in the pipeline, we need to define what operating system
    the DevOps pipeline needs to run on, any strategies, what permissions to provide,
    and finally, the steps that it needs to run.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于我们在管道中定义的每个作业，我们需要定义 DevOps 管道需要运行的操作系统、任何策略、提供的权限，以及最后需要运行的步骤。
- en: Now, we will expand into each of these sections.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们将扩展到这些部分的每一个。
- en: 'Since the commands to build and deploy the micro apps remain the same, we will
    use a matrix strategy that allows us to define variables that can be used later
    in these steps. Within the strategy section, write the following code:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于构建和部署微应用的命令保持不变，我们将使用一种矩阵策略，允许我们定义可以在这些步骤中使用的变量。在策略部分，编写以下代码：
- en: '[PRE16]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We set the `fail-fast` option to `false` so that GitHub action continues to
    run the pipeline for the other micro apps, even if one of them fails. Then, we
    define the matrix of our variables, which are as follows:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将 `fail-fast` 选项设置为 `false`，这样即使其中一个微应用失败，GitHub action 也会继续运行其他微应用的管道。然后，我们定义我们的变量矩阵，如下所示：
- en: '**Dockerfile**: The path to where the micro app’s Dockerfile is located in
    your code base'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dockerfile**: 微应用的 Dockerfile 在您的代码库中的路径'
- en: '**Image**: The path to the Docker image in Docker Hub'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像**: Docker Hub 中 Docker 图像的路径'
- en: '**k8sManifestPath**: The location of the Kubernetes manifest files needed to
    spin up your micro app pod, services, and ingress'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**k8sManifestPath**: 启动微应用 pod、服务和 ingress 所需的 Kubernetes 清单文件的存储位置'
- en: 'For permissions, we set the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于权限，我们设置以下内容：
- en: '[PRE17]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We set the `contents` scope to read and the `packages` scope to write.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`contents`范围设置为读取，将`packages`范围设置为写入。
- en: The next series of steps is where the actual work happens.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤系列是实际工作发生的地方。
- en: As we will see, every step has two to three properties – the first is `name`;
    then `uses`, which is the component that is used to perform the step; and finally,
    `with`, which is optional and defines the additional properties required to perform
    the step.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，每个步骤都有两个到三个属性——第一个是`name`；然后是`uses`，这是执行步骤所使用的组件；最后是`with`，它是可选的，定义了执行步骤所需的附加属性。
- en: 'All of the code in the following steps will be in the `steps:` section of the
    `.``yml` file:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤中的所有代码都将位于`.yml`文件的`steps:`部分：
- en: 'We start by checking out the repository:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先检出仓库：
- en: '[PRE18]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we log in to Docker Hub, passing our username and the access token as
    the password. Note that we pass them as secrets, which we defined earlier:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们登录到Docker Hub，使用用户名和访问令牌作为密码。注意，我们将它们作为秘密传递，这是我们之前定义的：
- en: '[PRE19]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the next step, we extract the **git SHA** value, which we will use to tag
    our Docker images:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，我们提取**git SHA**值，我们将使用它来标记我们的Docker镜像：
- en: '[PRE20]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next step is the build and push command, where we build the Docker image
    by passing the micro app name via the matrix variable, and then we push that build
    Docker image to Docker Hub, using the **git** SHA value as the image tag:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个步骤是构建和推送命令，通过传递矩阵变量中的微应用名称来构建Docker镜像，然后使用**git** SHA值作为镜像标签将其构建的Docker镜像推送到Docker
    Hub：
- en: '[PRE21]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once the Docker images are pushed to Docker Hub, it’s time for us to set up
    our Kubernetes pods and services, for which we first need to set up **Kubectl**:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Docker镜像推送到Docker Hub，我们就需要设置我们的Kubernetes pods和services，为此我们首先需要设置**Kubectl**：
- en: '[PRE22]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'First, we log in to Azure using the client ID and client secrets:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用客户端ID和客户端密钥登录Azure：
- en: '[PRE23]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we set up the Kubernetes context:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们设置Kubernetes上下文：
- en: '[PRE24]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we run the Kubernetes deploy commands:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们运行Kubernetes部署命令：
- en: '[PRE25]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once you’ve verified that all the indentation in the file is correct, go ahead
    and commit the file to the main branch.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦你验证了文件中的所有缩进都是正确的，就提交文件到主分支。
- en: Then, make a small change to any one of the code files within the home app,
    commit it, and push it to GitHub. After committing your change, head over to the
    actions tab at [github.com](https://github.com), and you should be able to see
    the GitHub pipeline begin to run.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，对home应用中的任何一个代码文件进行微小修改，提交更改，并将其推送到GitHub。提交更改后，转到[github.com](https://github.com)上的操作标签页，你应该能看到GitHub管道开始运行。
- en: Follow the steps as GitHub Actions goes step by step through the jobs. If there
    are any errors, the jobs will fail, so look through the errors and make the necessary
    fixes. Feel free to seek help from your friends and the community as you navigate
    through this critical step, and keep testing until the pipeline runs successfully.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 按照GitHub Actions的步骤逐步通过作业。如果有任何错误，作业将失败，因此请检查错误并进行必要的修复。在导航这个关键步骤时，随时向朋友和社区寻求帮助，并不断测试直到管道成功运行。
- en: Once the pipeline builds successfully, make copies of the workflow file within
    the `.github/workflows` folder to build and deploy the other micro apps. We will
    call these files `.github/workflows/catalog-build-deploy.yml` and .`github/workflows/checkout-build-deploy.yml`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦管道成功构建，复制`.github/workflows`文件夹内的工作流程文件以构建和部署其他微应用。我们将这些文件命名为`.github/workflows/catalog-build-deploy.yml`和`.github/workflows/checkout-build-deploy.yml`。
- en: 'In the respective files, change all occurrences of the word `home` to `catalog`
    and `checkout`. For example, in your `catalog-build-deploy.yml` file, you will
    have the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在相应的文件中，将所有出现“home”一词的地方更改为“catalog”和“checkout”。例如，在你的`catalog-build-deploy.yml`文件中，你将看到以下内容：
- en: '[PRE26]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `matrix` section under strategies will look as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 策略下的`matrix`部分将如下所示：
- en: '[PRE27]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Similarly, the `checkout-build-deploy.yml` file will have the following changes:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`checkout-build-deploy.yml`文件将进行以下更改：
- en: '[PRE28]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Also, the `matrix` section under `strategies` will be as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`strategies`下的`matrix`部分将如下所示：
- en: '[PRE29]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Then, make a small change, commit files to the checkout and catalog apps, and
    verify that only the relevant pipeline is triggered.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，进行微小修改，提交checkout和catalog应用的文件，并验证是否只触发了相关的管道。
- en: We can also verify the micro app pods have been successfully created within
    the `ebuy-ssr` Kubernetes cluster by running the following `kubectl get pods`
    command in the terminal.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过在终端中运行以下`kubectl get pods`命令来验证在`ebuy-ssr` Kubernetes集群内微应用Pod是否已成功创建。
- en: If any of the pods don’t show a ready status or have a high restart count, you
    can look into the pod logs using the `kubectl logs <pod-name>` command in the
    terminal.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何Pod没有显示就绪状态或重启次数过高，您可以使用终端中的`kubectl logs <pod-name>`命令查看Pod日志。
- en: With this, we have successfully created our DevOps pipeline using GitHub Actions,
    where we learned how to securely save our credentials as GitHub action secrets,
    created an individual workflow .`yml` file for each micro app, and configured
    it so that they are triggered only when the corresponding micro app has changed.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已成功使用GitHub Actions创建了我们的DevOps管道，我们学习了如何安全地将凭据保存为GitHub操作密钥，为每个微应用创建了单独的工作流程`.yml`文件，并配置了它们仅在相应的微应用发生变化时触发。
- en: While these micro apps are individually running, they will not work with module
    federation, as the remotes on Kubernetes are different from what we ran locally.
    In the next section, we will update the remotes to ensure that it works on the
    cloud as well.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些微应用单独运行时，它们将无法与模块联邦一起工作，因为Kubernetes上的远程与我们本地运行的不同。在下一节中，我们将更新远程以确保它也能在云上工作。
- en: Updating the remotes
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新远程
- en: Once you have your pipelines deployed successfully, log in to [portal.azure.com](https://portal.azure.com),
    go to the Kubernetes services, select your Kubernetes cluster, go to the Services
    and Ingress link, and note the external IP address for the service of the micro
    apps.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的管道成功部署，请登录到[portal.azure.com](https://portal.azure.com)，转到Kubernetes服务，选择您的Kubernetes集群，转到服务和入口链接，并记录微应用服务的公网IP地址。
- en: You can achieve the same by running the `kubectl get services` command in the
    terminal.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在终端中运行`kubectl get services`命令来实现相同的功能。
- en: Once we have the IP address, we need to update our module federation remotes
    with the updated URLs.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了IP地址，我们需要更新我们的模块联邦远程以包含更新的URL。
- en: 'Now, as you may have figured out, the URLs for our microapps are different
    locally and on Kubernetes. Since we want to be able to run our apps locally as
    well as on Kubernetes, we will need to conditionally load in the remotes based
    on whether the app is running in `dev` or `production` mode. We do this as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如您所想，我们的微应用的URL在本地和Kubernetes上是不同的。由于我们希望能够在本地以及Kubernetes上运行我们的应用，我们需要根据应用是在`dev`或`production`模式下运行来有条件地加载远程。我们这样做如下：
- en: 'In the `apps/home/next.config.js` file within the `remotes` object, we update
    the code as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在`apps/home/next.config.js`文件中的`remotes`对象内，我们按照以下方式更新代码：
- en: '[PRE30]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: What we do here is define a new variable called `ENV` that captures whether
    the app is running in dev or prod mode, then we create the consts for `LOCAL URL`
    and `PROD URLS` for our micro apps, and conditionally set the values of the `CATALOG_REMOTE_HOST`
    and `CHECKOUT_REMOTE_HOST` values based on the `ENV` values.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里定义了一个名为`ENV`的新变量，用于捕获应用是在开发模式还是生产模式下运行，然后我们为微应用创建了`LOCAL URL`和`PROD URLS`常量，并根据`ENV`值有条件地设置`CATALOG_REMOTE_HOST`和`CHECKOUT_REMOTE_HOST`的值。
- en: Make the same set of changes to the `next.config.js` files in the checkout and
    catalog apps, and then save the changes.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 将相同的更改应用到检查和目录应用的`next.config.js`文件中，然后保存更改。
- en: Now, we can and build the apps locally to verify that things work fine.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以本地构建应用以验证一切是否正常。
- en: Run the `pnpm dev` command from the root of the project.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 从项目的根目录运行`pnpm dev`命令。
- en: Once this works locally, let us commit the changes to Git and let the GitHub
    actions auto-trigger and deploy the new apps to our Kubernetes cluster.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦本地运行成功，让我们将更改提交到Git，并让GitHub Actions自动触发并部署新应用到我们的Kubernetes集群。
- en: Once it’s all done, head over to the URL of the home micro app (`http://<your-k8s-ip-address>/`)
    and verify that the app is working.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一切完成后，前往主微应用的URL（`http://<your-k8s-ip-address>/`）并验证应用是否正常工作。
- en: Important note
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Make sure the catalog and checkout apps are deployed first before the home app
    pipeline starts. This is because, in prod mode, the home app now expects the **remoteEntry.js**
    files to be present at the URLs we defined in the **CATALOG_URL_PROD** and **CHECKOUT_URL_PROD**
    constants.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在主应用管道开始之前先部署目录和检查应用。这是因为，在生产模式下，主应用现在期望**remoteEntry.js**文件存在于我们在**CATALOG_URL_PROD**和**CHECKOUT_URL_PROD**常量中定义的URL上。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: And with that, we have come to the end of this chapter. I hope you have been
    able to follow along and enjoyed the joys and pains of wearing a DevOps engineer’s
    hat.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们来到了这一章的结尾。希望您能够跟上进度，并享受作为一名DevOps工程师帽子的喜悦与痛苦。
- en: As you can see, we covered a lot in this chapter. We learned about Kubernetes
    and its various key components. We saw how you spin up an empty Kubernetes cluster
    on Azure and learned about the Kubernetes spec files that deploy our micro apps
    into a Kubernetes cluster. We learned how to containerize our micro apps using
    Docker and how to set up Docker Hub as a remote image repository. Then, we went
    through the detailed steps of setting up a CI/CD pipeline using GitHub Actions,
    and finally, we made the necessary tweaks to our code base so that we can run
    our module-federated microfrontend on Kubernetes. Now that you have managed to
    complete this chapter, give yourself a pat on the back and take a well-deserved
    break before we start with the next chapter, where we will see how to manage our
    microfrontend in production.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在这一章中涵盖了大量的内容。我们学习了Kubernetes及其各种关键组件。我们看到了如何在Azure上启动一个空的Kubernetes集群，并了解了部署我们的微应用到Kubernetes集群中的Kubernetes规范文件。我们学习了如何使用Docker容器化我们的微应用，以及如何设置Docker
    Hub作为远程镜像仓库。然后，我们详细介绍了使用GitHub Actions设置CI/CD管道的步骤，最后，我们对代码库进行了必要的调整，以便我们可以在Kubernetes上运行我们的模块联邦微前端。现在，您已经成功完成了这一章，给自己鼓掌吧，在开始下一章之前，好好休息一下，下一章我们将探讨如何在生产中管理我们的微前端。
