<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Tooling and Development Experience"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Tooling and Development Experience</h1></div></div></div><p>We are already familiar with all the core concepts of Angular. We know how to develop a component-based user interface, taking advantage of all the building blocks that the framework provides – directives, components, dependency injections, pipes, forms, and the brand new router.</p><p>For the final step, we'll look at where to begin when we want to build a <span class="strong"><strong>single-page application</strong></span> (<span class="strong"><strong>SPA</strong></span>) from scratch. This chapter describes how to do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use Web Workers for performance-sensitive applications.</li><li class="listitem" style="list-style-type: disc">Build SEO-friendly applications with server-side rendering.</li><li class="listitem" style="list-style-type: disc">Bootstrap a project as quickly as possible.</li><li class="listitem" style="list-style-type: disc">Enhance our experience as developers.</li><li class="listitem" style="list-style-type: disc">What is <span class="strong"><strong>Ahead-of-Time</strong></span> (<span class="strong"><strong>AoT</strong></span>) compilation and how to use it.</li></ul></div><p>So, let's begin!</p><div class="section" title="Running an application in a Web Worker"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec65"/>Running an application in a Web Worker</h1></div></div></div><p>When talking about performance in the context of frontend Web development, we can either mean network, computational, or rendering performance. In this section, we'll concentrate on rendering and computational performance, which are very tightly related.</p><p>First, let's draw parallels between a Web application and a video file, and between a browser and a video player. The biggest difference between the Web application running in the browser and the video file playing in the video player is that the web page needs to be generated dynamically, in contrast to the video which has been recorded, encoded, and distributed. However, in both cases, the user of the application sees a sequence of frames; the core difference is in how these frames are generated. In the world of video processing, when we play a video, we have it already recorded; it is the responsibility of the video decoder to extract the individual frames based on the compression algorithm. In contrast to this, on the Web, JavaScript, HTML, and CSS are in charge of producing frames that are rendered later by the browser's rendering engine.</p><p>In the context of the browser, we can think of each frame as a snapshot of the web page at a given moment. The different frames are rendered fast, one after the other; so, in theory, the end user of the application should see them smoothly incorporated together, just like a video played in a video player.</p><p>On the Web, we try to reach 60 fps (frames per second), which means that each frame has about 16 milliseconds to be computed and rendered on the screen. This duration includes the time required by the browser to make all the necessary calculations for the layout and the rendering of the page (the browser's internal computations), and the time that our JavaScript needs to execute.</p><p>In the end, we have less than 16 milliseconds (because of the browser's internal computations) for our JavaScript to finish its execution. If it doesn't fit in this duration, the frame rate will drop by half. Since JavaScript is a single-threaded language, all the calculations need to happen in the main UI thread, which can lead to a very poor user experience because of the frame drop.</p><p>HTML5 introduced an API called <span class="strong"><strong>Web Workers</strong></span>, which allows the execution of client-side code into multiple threads. For the sake of simplicity, the standard doesn't allow shared memory between individual threads, but instead allows communication with message passing. The messages exchanged between Web Workers and the main UI thread must be strings, which often require the serialization and deserialization of JSON strings.</p><p>The lack of shared memory between the individual workers, and the workers and the main UI thread brings a couple of limitations, some of which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Disabled access to the DOM by the worker threads.</li><li class="listitem" style="list-style-type: disc">Global variables cannot be shared among the individual computational units (that is, worker threads and main UI threads and vice versa).</li></ul></div><div class="section" title="Web Workers and Angular"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec107"/>Web Workers and Angular</h2></div></div></div><p>On account of the platform agnostic design of Angular, the core team decided to take advantage of this API; during the summer of 2015, Google embedded Web Workers support into the framework. This feature allows most of the Angular applications to be run on a separate thread, making the main UI thread responsible only for rendering. This helps us achieve the goal of 60 fps much more easily than running the entire application in a single thread.</p><p>Web Workers support is not enabled by default. When enabling it, we need to keep something in mind-in a Web Worker-ready application, the components will not be run in the main UI thread, which does not allow us to directly manipulate the DOM. In this case, we need to use APIs on a higher-level of abstraction, provided by Angular, for establishing data binding or manipulating the elements' properties.</p></div><div class="section" title="Bootstrapping an application running in a Web Worker"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec108"/>Bootstrapping an application running in a Web Worker</h2></div></div></div><p>Let's make the to-do application that we developed in <a class="link" href="ch04.html" title="Chapter 4. Getting Started with Angular Components and Directives">
Chapter 4</a>, <span class="emphasis"><em>Getting Started with Angular Components and Directives</em></span> work in a Web Worker. You can find the example that we'll explore at <code class="literal">ch8/ts/todo_webworkers/</code>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note48"/>Note</h3><p>Note that the Web Worker module is not finalized yet, so its API may change in future versions of Angular. On the other hand, the conceptual idea and the architecture are mature enough, so most likely there will not be any fundamental differences.</p></div></div><p>First of all, let's discuss the changes that we will need to make. Take a look at <code class="literal">ch4/ts/inputs-outputs/app.ts</code>. Note that, inside <code class="literal">app.ts</code>, we include the <code class="literal">platformBrowserDynamic</code> function from the <code class="literal">@angular/platform-browser-dynamic</code> module. This is the first thing we need to modify. The bootstrap process of an application running in a background process is different.</p><p>Before refactoring our code, let's take a look at a diagram that illustrates the bootstrap process of a typical Angular application running in Web Workers:</p><p>
</p><div class="mediaobject"><img alt="Bootstrapping an application running in a Web Worker" src="graphics/web-workers.jpg"/></div><p>
</p><p>Figure 1</p><p>This diagram has two parts: <span class="strong"><strong>UI</strong></span> and <span class="strong"><strong>WebWorker</strong></span>. <span class="strong"><strong>UI</strong></span> shows the actions performed during initialization in the main UI thread; the <span class="strong"><strong>WebWorker</strong></span> part of the diagram shows how the application is bootstrapped in the background thread. Now, let's explain the bootstrap process step-by-step.</p><p>First, the user opens the <code class="literal">index.html</code> page, which triggers the download of the following two files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The UI bundle of Angular used for applications running in Web Worker.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">system.js</code> bundle (we talked about the global object <code class="literal">System</code> in <a class="link" href="ch03.html" title="Chapter 3. TypeScript Crash Course">
Chapter 3</a>, <span class="emphasis"><em>TypeScript Crash Course</em></span>. We can think of the <code class="literal">system.js</code> bundle as a polyfill for the module loader).</li></ul></div><p>Using <code class="literal">system.js</code>, we download the script used for the initialization of the part of the application running in the main UI thread (<code class="literal">bootstrap.js</code>). This script starts <code class="literal">loader.js</code> in Web Worker. This is the first script that runs in a background thread. Once the worker is started, <code class="literal">loader.js</code> will download <code class="literal">system.js</code> and the bundle of Angular, which is meant to be run in the background thread. The first request will usually hit the cache because <code class="literal">system.js</code> is already requested by the main thread. Using the module loader, we download the script that is responsible for bootstrapping the background app <code class="literal">background_bootstrap.js</code>, which will finally start the functionality of our application, in Web Worker.</p><p>From now on, the entire application that we built will be run in Web Worker and will exchange messages with the main UI thread to respond to user events and render instructions.</p><p>Now that we are aware of the basic flow of events during initialization when using workers, let's refactor our to-do application to take advantage of them.</p></div><div class="section" title="Migrating an application to Web Worker"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec109"/>Migrating an application to Web Worker</h2></div></div></div><p>Let's show how we can make an application compatible with Web Workers. This way, we can reduce the frame drop in computationally intensive apps, since we'll free the main UI thread and let it be responsible only for rendering.</p><p>Inside <code class="literal">index.html</code>, we will need to add the following scripts:</p><pre class="programlisting">  &lt;!-- ch8/ts/todo_webworkers/index.html --&gt; &#13;
  ... &#13;
  &lt;script src="/node_modules/systemjs/dist/system.src.js"&gt; &#13;
  &lt;/script&gt; &#13;
  &lt;script src="/node_modules/reflect-metadata/Reflect.js"&gt;&lt;/script&gt; &#13;
  &lt;script src="/node_modules/zone.js/dist/zone.js"&gt; &#13;
  &lt;/script&gt; &#13;
  &lt;!- &#13;
    Contains some basic SystemJS configuration in order to &#13;
    allow us to load Angular &#13;
  --&gt; &#13;
  &lt;script src="./config.js"&gt;&lt;/script&gt; &#13;
  &lt;script&gt; &#13;
  System.import('./bootstrap.js') &#13;
    .catch(function () { &#13;
      console.log('Report this error to https://github.com/mgechev/getting-started-with-angular/issues', e); &#13;
    }); &#13;
  &lt;/script&gt; &#13;
  ... &#13;
</pre><p>In the preceding snippet, we've included references to <code class="literal">system.js</code>, <code class="literal">zone.js</code>, and <code class="literal">reflect-metadata</code>. <code class="literal">zone.js</code> is a polyfill for the zones that Angular exclusively uses, that we mentioned earlier in the book. <code class="literal">reflect-metadata</code> contains another polyfill for the Metadata Reflection API, which at the moment of writing is not yet available in browsers.</p><p>For the next step, we will explicitly import the <code class="literal">bootstrap.js</code> file, which contains the logic used to start the <code class="literal">loader.js</code> script in Web Worker.</p><p>Let's explore <code class="literal">bootstrap.ts</code>, which is the original TypeScript version of the transpiled <code class="literal">bootstrap.js</code>:</p><pre class="programlisting">// ch8/ts/todo_webworkers/bootstrap.ts &#13;
&#13;
//main entry point&#13;
import {bootstrapWorkerUi} from '@angular/platform-webworker';&#13;
&#13;
bootstrapWorkerUi('loader.js');&#13;
</pre><p>We pass <code class="literal">'loader.js'</code> to the invocation of <code class="literal">bootstrapWorkerUi</code>. This way, Angular knows that <code class="literal">loader.js</code> will run in a background thread. The script is located in the application's root.</p><p>Now, we can move to the right-hand side of the diagram shown in the <span class="emphasis"><em>Bootstrapping an application running in a Web Worker</em></span> section. The logic in <code class="literal">loader.ts</code> (the original TypeScript version of <code class="literal">loader.js</code>) is quite simple:</p><pre class="programlisting">// ch8/ts/todo_webworkers/loader.ts&#13;
 &#13;
importScripts('/node_modules/systemjs/dist/system.src.js', &#13;
      '/node_modules/reflect-metadata/Reflect.js', &#13;
      '/node_modules/zone.js/dist/zone.js', &#13;
      './config.js'); &#13;
 &#13;
System.import('./background_app.js') &#13;
.then(() =&gt; console.log('The application has started successfully'), &#13;
  error =&gt; console.error('error loading background', error)); &#13;
</pre><p>As the first step, we import <code class="literal">SystemJS</code>, <code class="literal">ReflectMetadata</code> polyfils, <code class="literal">zone.js</code>, and the configuration for <code class="literal">SystemJS</code>. As this script is already run in Web Workers, we have the <code class="literal">importScripts</code> function, which allows us to load the listed files synchronously. As the last step, with <code class="literal">System</code>, we import the script that contains our application.</p><p>Now, let's explore how we bootstrap the application inside of the Web Worker:</p><pre class="programlisting">// ch8/ts/todo_webworkers/background_app.ts&#13;
&#13;
import {platformWorkerAppDynamic} &#13;
  from '@angular/platform-webworker-dynamic';&#13;
&#13;
// Logic for the application... &#13;
&#13;
platformWorkerAppDynamic().bootstrapModule(AppModule)&#13;
  .catch(err =&gt; console.error(err));&#13;
</pre><p>The preceding process is quite similar to what we used to do when bootstrapping an Angular application running in the main UI thread. We import the <code class="literal">platformWorkerAppDynamic</code> function and invoke it with the root module of the application as its first argument.</p></div><div class="section" title="Making an application compatible with Web Workers"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec110"/>Making an application compatible with Web Workers</h2></div></div></div><p>As we said, the code that runs in the context of Web Worker does not have access to the DOM. Let's see what changes we need to make in order to address this limitation.</p><p>This is the original implementation of the <code class="literal">InputBox</code> component:</p><pre class="programlisting">// ch4/ts/inputs-outputs/app.ts&#13;
 &#13;
@Component({ &#13;
  selector: 'input-box', &#13;
  template: ` &#13;
    &lt;input #todoInput [placeholder]="inputPlaceholder"&gt; &#13;
    &lt;button (click)="emitText(todoInput.value); &#13;
      todoInput.value = '';"&gt; &#13;
      {{buttonLabel}} &#13;
    &lt;/button&gt; &#13;
  ` &#13;
}) &#13;
class InputBox { &#13;
  @Input() inputPlaceholder: string; &#13;
  @Input() buttonLabel: string; &#13;
  @Output() inputText = new EventEmitter&lt;string&gt;();&#13;
 &#13;
  emitText(text: string) { &#13;
    this.inputText.emit(text); &#13;
  } &#13;
} &#13;
</pre><p>Note that, inside the template, we reference the input element with the identifier <code class="literal">todoInput</code> and use the reference within the expression set as the handler of the click event. This code will not be able to run in Web Worker, since we directly access a DOM element inside the template. In order to take care of this, we will need to refactor the snippet, so it uses Angular data binding instead of directly touching any element. We can either use inputs when a single direction binding makes sense or <code class="literal">NgModel</code> to achieve two-way data binding, which is a bit more computationally intensive.</p><p>Let's use <code class="literal">NgModel</code>:</p><pre class="programlisting">// ch8/ts/todo_webworkers/background_app.ts &#13;
import {NgModel} from '@angular/common'; &#13;
&#13;
@Component({ &#13;
  selector: 'input-box', &#13;
  template: ` &#13;
    &lt;input [placeholder]="inputPlaceholder" [(ngModel)]="input"&gt; &#13;
    &lt;button (click)="emitText()"&gt; &#13;
      {{buttonLabel}} &#13;
    &lt;/button&gt; &#13;
  ` &#13;
}) &#13;
class InputBox { &#13;
  @Input() inputPlaceholder: string; &#13;
  @Input() buttonLabel: string; &#13;
  @Output() inputText = new EventEmitter&lt;string&gt;(); &#13;
  input: string;&#13;
 &#13;
  emitText() { &#13;
    this.inputText.emit(this.input); &#13;
    this.input = ''; &#13;
  } &#13;
} &#13;
</pre><p>In this version of the <code class="literal">InputBox</code> component, we create a two-way data binding between the input element and the <code class="literal">input</code> property of the <code class="literal">InputBox</code> component. Once the user clicks on the button, the <code class="literal">emitText</code> method will be invoked, which will trigger a new event emitted by <code class="literal">inputText</code>
<code class="literal">EventEmitter</code>. In order to reset the value of the input element, we take advantage of the two-way data binding mechanism of Angular and set the value of the <code class="literal">input</code> property to the empty string; this will automatically update the UI.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note49"/>Note</h3><p>Moving the entire logic from the templates of the components to their controllers brings a lot of benefits, such as improved testability, maintainability, code reuse, and clarity.</p></div></div><p>The preceding code is compatible with the Web Worker environment, as the <code class="literal">NgModel</code> directive is based on an abstraction that does not manipulate the DOM directly. Instead, it delegates this responsibility to another abstraction called <code class="literal">Renderer</code>, which when running in a Web Worker exchanges messages asynchronously with the main UI thread.</p><p>To recap, we can say that, while running applications in the context of Web Workers, we need to keep the following two things in mind:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We need to use a different bootstrap process.</li><li class="listitem" style="list-style-type: disc">We should not access the DOM directly.</li></ul></div><p>Typical scenarios that violate the second point are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Changing the DOM of the page by selecting an element and manipulating it directly with the browser's native APIs or with a third-party library.</li><li class="listitem" style="list-style-type: disc">Accessing native elements injected using <code class="literal">ElementRef</code>.</li><li class="listitem" style="list-style-type: disc">Creating a reference to an element in the template and passing it as an argument to methods.</li><li class="listitem" style="list-style-type: disc">Directly manipulating an element referenced within the template.</li></ul></div><p>In all these scenarios, we would need to use the higher-level APIs provided by Angular. If we build our applications according to this practice, we will benefit not only from being able to run them in Web Workers, but also from increasing the code reuse in case we want to use them across different platforms.</p><p>Keeping this in mind and following best practices will also allow us to take advantage of server-side rendering.</p></div></div></div>
<div class="section" title="Initial load of a SPA"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec66"/>Initial load of a SPA</h1></div></div></div><p>In this section, we will explore what a server-side rendering is, why we need it in our applications, and how we can use it with Angular.</p><p>For our purpose, we'll explain the typical flow of events when a user opens a SPA implemented in Angular. First, we'll trace the events with the server-side rendering disabled, and after that, we'll see how we can benefit from this feature by enabling it. Our example will be illustrated in the context of HTTP 1.1:</p><p>
</p><div class="mediaobject"><img alt="Initial load of a SPA" src="graphics/2-3.jpg"/></div><p>
</p><p>Figure 2</p><p>
<span class="emphasis"><em>Figure 2</em></span> shows the first request by the browser and the corresponding server's response when loading a typical SPA. The result that the client will see initially is the content of the HTML page without any rendered components.</p><p>Let's suppose that we deploy the to-do application we built in <a class="link" href="ch04.html" title="Chapter 4. Getting Started with Angular Components and Directives">
Chapter 4</a>, <span class="emphasis"><em>Getting Started with Angular Components and Directives</em></span>, to a web server that has the <code class="literal">example.com</code> domain associated with it.</p><p>Once the user navigates to <code class="literal">https://example.com/</code>, the browser will open a new HTTP GET request, fetching the root resource (<code class="literal">/</code>). When the server receives the request, it will respond with an HTML file that, in our case, will look something like this:</p><pre class="programlisting">&lt;!DOCTYPE html&gt; &#13;
&lt;html lang="en"&gt; &#13;
&lt;head&gt; &#13;
  &lt;title&gt;...&lt;/title&gt; &#13;
  &lt;link rel="stylesheet" href="bootstrap.min.css"&gt; &#13;
&lt;/head&gt; &#13;
&lt;body&gt; &#13;
  &lt;app&gt;Loading...&lt;/app&gt; &#13;
  &lt;script src="es6-shim.min.js"&gt;&lt;/script&gt; &#13;
  &lt;script src="Reflect.js"&gt;&lt;/script&gt; &#13;
  &lt;script src="system.src.js"&gt;&lt;/script&gt; &#13;
  &lt;script src="angular-polyfills.js"&gt;&lt;/script&gt; &#13;
  &lt;script src="Rx.min.js"&gt;&lt;/script&gt; &#13;
  &lt;script src="angular.js"&gt;&lt;/script&gt; &#13;
  &lt;script src="router.js"&gt;&lt;/script&gt; &#13;
  &lt;script src="http.min.js"&gt;&lt;/script&gt; &#13;
  &lt;script&gt;...&lt;/script&gt; &#13;
&lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>The browser will receive this content as the body of the response. When the markup is rendered onto the screen, all that the user will see is the <span class="strong"><strong>Loading...</strong></span> label.</p><p>In the next step, the browser will find all the references in the HTML file's external resources, such as styles and scripts, and start to download them. In our case, some of them are <code class="literal">bootstrap.css</code>, <code class="literal">es6-shim.min.js</code>, <code class="literal">Reflect.js</code>, <code class="literal">system.src.js</code>, and <code class="literal">angular-polyfills.js</code>.</p><p>Once all the referenced resources are available, there still won't be any significant visual progress for the user (except if the styles from the downloaded CSS file are applied to the page). This won't change until the JavaScript virtual machine processes all the referenced scripts related to the application's implementation. At this point, Angular will know which component needs to be rendered based on the current URL and configuration.</p><p>If the component associated with the page is defined in a separate file outside of our main application bundle, the framework will need to download it together with its entire dependency graph.</p><p>If we're using JiT compilation, in case the template and the styles of the component are externalized, Angular will need to download them as well before it is able to render the requested page. Right after this, the framework will be able to compile the template associated with the target component and render the page.</p><p>In this scenario, these are the two main pitfalls:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In case of large applications and/or poor Internet connection, the user experience will be poor.</li><li class="listitem" style="list-style-type: disc">Search engines are not that good at indexing dynamic content generated by JavaScript; this means that the <span class="strong"><strong>SEO</strong></span> (<span class="strong"><strong>Search Engine Optimization</strong></span>) of our SPA will suffer.</li></ul></div><p>In the past, we solved the SEO issue in the applications built with AngularJS with different workarounds, such as using a headless browser for rendering the requested page, caching it onto the disk, and later providing it to search engines. However, there's a more elegant solution.</p><div class="section" title="Initial load of a SPA with server-side rendering"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec111"/>Initial load of a SPA with server-side rendering</h2></div></div></div><p>A couple of years ago, libraries such as <span class="emphasis"><em>Rendr</em></span>, <span class="emphasis"><em>Derby</em></span>, <span class="emphasis"><em>Meteor</em></span>, and the others introduced the concept of <span class="strong"><strong>isomorphic</strong></span> JavaScript applications, which were later renamed <span class="strong"><strong>universal</strong></span>. In essence, universal applications could be run both on the client and on the server. Such portability is only possible in the case of low coupling between the SPA and the browser's APIs. The greatest benefit of this paradigm is that the application can be rendered on the server and sent to the client.</p><p>Universal applications are not framework specific; we can take advantage of them in any framework that can be run outside of the environment of the browser. Conceptually, the practice of server-side rendering is very similar across platforms and libraries; only its implementation details may differ. For instance, the Angular Universal module, which implements server-side rendering, supports node.js as well as ASP.NET.</p><p>
</p><div class="mediaobject"><img alt="Initial load of a SPA with server-side rendering" src="graphics/3-3.jpg"/></div><p>
</p><p>Figure 3</p><p>
<span class="emphasis"><em>Figure 3</em></span> shows the response by the server to the initial browser GET request. This time, in contrast to the typical scenario of loading a SPA, the browser will receive the HTML of the rendered page.</p><p>Let's trace the flow of the events in the same application with the server-side rendering feature enabled. In this case, once the server receives the HTTP GET request by the browser, it will run the SPA on the server in the environment of node.js. All the DOM calls will be redirected to a server-side DOM implementation and executed in the context of the used platform. Similarly, all the AJAX calls with the Angular HTTP module will be handled by the server-side implementation of the module. This way, the application will not make any difference, whether it is running in the context of the browser or the server.</p><p>Once the rendered version of the SPA is available, it can be serialized to HTML and sent to the browser. This time, during the application's initialization, instead of the <span class="strong"><strong>Loading...</strong></span> label, the user will see the page they requested right away.</p><p>Note that, at this point, the client will have the rendered version of the application, but all the referenced external resources, such as scripts and styles, still need to be available. This means that, initially, none of the CSS styles declared in the external files will be applied and the application will not be responsive to any user-related interactions, such as the mouse and keyboard events.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note50"/>Note</h3><p>Note that in case the scripts are inlined on the server-side rendered page, the application will be responsive to user events. However, inlining big chunks of JavaScript is generally considered a bad practice, as it will increase the page's size dramatically and prevent the scripts from caching; both will influence the network performance.</p></div></div><p>When the JavaScript virtual machine processes the JavaScript associated with the page, our SPA will be ready to use.</p></div><div class="section" title="Server-side rendering with Angular"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec112"/>Server-side rendering with Angular</h2></div></div></div><p>During the first half of 2015, Patrick Stapleton and Jeff Whelpley announced that they had started the development of the module, <span class="strong"><strong>Universal</strong></span>. Universal is a library that allows us to build universal (also called isomorphic) JavaScript applications with Angular; in other words, it provides server-side rendering support.</p><p>Applications using Angular Universal and rendered on the server will not be responsive to user interaction until all the JavaScript belonging to the requested page has been processed. This is a drawback that we already mentioned, which is valid for all server-side rendered applications. To handle this problem, Patrick and Jeff introduced <span class="strong"><strong>preboot.js</strong></span>, which is a lightweight library that will be inlined on the page rendered by the server and available after the initial client request.</p><p>Preboot.js has several strategies for the management of the received client events before the application is completely initialized; they are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Recording and playing back events.</li><li class="listitem" style="list-style-type: disc">Responding immediately to events.</li><li class="listitem" style="list-style-type: disc">Maintaining focus when a page is re-rendered.</li><li class="listitem" style="list-style-type: disc">Buffering client-side re-rendering for smoother transition.</li><li class="listitem" style="list-style-type: disc">Freezing a page until the bootstrap is complete if a user clicks on a button.</li></ul></div><p>At the time of writing this book, the Universal module was still being actively developed. You can give it a try using the Angular universal starter at <a class="ulink" href="https://github.com/angular/universal-starter">
https://github.com/angular/universal-starter
</a>.</p></div></div>
<div class="section" title="Enhancing our development experience"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec67"/>Enhancing our development experience</h1></div></div></div><p>Our experience as developers can be enhanced in terms of productivity or by allowing us to have more fun while working on our projects. This can be achieved with all the tools, IDEs, text editors, and more, which we use on a daily basis. In this section, we'll take a brief look at popular IDEs and text editors that take advantage of the statically analyzable syntax that Angular provides. We'll also mention the language service that the Angular team developed.</p><div class="section" title="Text editors and IDEs"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec113"/>Text editors and IDEs</h2></div></div></div><p>As we have already said at the beginning of the book, the core team put a lot of effort into enhancing the tooling support in Angular. First of all, the framework is built with TypeScript, which naturally allows us to use static typing during our development process. Some of the text editors and IDEs that have great TypeScript support are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>IntelliJ Idea</strong></span>: A general-purpose IDE by JetBrains.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>WebStorm</strong></span>: An IDE specialized for Web development by JetBrains.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>VSCode</strong></span>: A cross-platform text editor written in TypeScript and developed by Microsoft.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Sublime Text</strong></span>: A cross-platform text editor.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Atom</strong></span>: A cross-platform text editor written in JavaScript, based on Electron.</li></ul></div><p>Recently, JetBrains announced advanced Angular support in IntelliJ Idea and WebStorm, which supports autocompletion for components and bindings.</p><p>Although not all the mentioned IDEs and text editors have Angular-specific features at the time of writing this book, the framework comes with tooling in mind. It allows us to perform advanced static code analysis on the application's code base for the development of sophisticated refactoring and productivity tools in the near future. </p></div><div class="section" title="Angular language service"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec114"/>Angular language service</h2></div></div></div><p>Taking advantage of the analyzable nature of Angular, Google developed a <span class="strong"><strong>language service</strong></span> for the framework. We can think of this service as a server, which indexes our project and provides autocompletion suggestions, type checking in templates, based on requests from a client. This client can be a plugin of our text editor or IDE.</p><p>The language service can keep track of the context of the given component that is in focus in your text editor and provide context-specific suggestions. For instance, it can provide autocompletion suggestions for directive selectors based on the available set of directives at the given part of the component tree.</p><p>The best thing about the language service is that it is not coupled to any specific text editor or IDE, which means that, with a thin plugin, it can be reused in any development environment.</p></div><div class="section" title="Bootstrapping a project with angular-cli"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec115"/>Bootstrapping a project with angular-cli</h2></div></div></div><p>During AngularConnect 2015, Brad Green and Igor Minar, part of the Angular team, announced <code class="literal">angular-cli</code>-a <span class="strong"><strong>CLI</strong></span> (<span class="strong"><strong>command-line interface</strong></span>) tool to ease starting and managing Angular applications. For those who have used Ruby on Rails, the idea behind the CLI tool might be familiar. The basic purpose of the tool is to allow the quick setup of new projects and scaffolding of new directives, components, pipes, and services.</p><p>At the time of writing, the tool is based on webpack and is in the early stages of development, so we'll demonstrate only its basic usage.</p></div><div class="section" title="Using angular-cli"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec116"/>Using angular-cli</h2></div></div></div><p>In order to install the CLI tool, run the following command on your terminal:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install -g angular-cli</strong></span>
</pre><p>Right after this, the <code class="literal">ng</code> command will appear as global executable in your system. For creating a new Angular project, use the following commands:</p><pre class="programlisting">
<span class="strong"><strong># May take a while, depending on your Internet connection &#13;
$ ng new angular-cli-project &#13;
$ cd angular-cli-project &#13;
$ ng serve</strong></span>
</pre><p>The preceding commands will perform the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Create a new Angular project and install all of its node.js dependencies.</li><li class="listitem" style="list-style-type: disc">Enter your project's directory.</li><li class="listitem" style="list-style-type: disc">Start a development web server that will let you open the application you have just created in your web browser.</li></ul></div><p>For further reading, take a look at the project's repository, located at <a class="ulink" href="https://github.com/angular/angular-cli">
https://github.com/angular/angular-cli
</a>.</p></div></div>
<div class="section" title="Angular quick starters"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec68"/>Angular quick starters</h1></div></div></div><p>If you prefer to not get coupled with the CLI tool, there are a lot of starter projects developed by the community that can provide a great starting point for your next Angular project.</p><div class="section" title="Angular Seed"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec117"/>Angular Seed</h2></div></div></div><p>If you enjoy static typing, you can give the <span class="strong"><strong>angular-seed</strong></span> project a try. It is hosted on GitHub at <a class="ulink" href="https://github.com/mgechev/angular-seed">
https://github.com/mgechev/angular-seed
</a>.</p><p>The Angular Seed provides the following key features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Easy for extend, modular, and statically typed build systems.</li><li class="listitem" style="list-style-type: disc">AoT compilation support.</li><li class="listitem" style="list-style-type: disc">Supports multiple Angular applications with a shared code base in a single instance of the seed.</li><li class="listitem" style="list-style-type: disc">Production and development builds.</li><li class="listitem" style="list-style-type: disc">Sample unit tests with Jasmine and Karma.</li><li class="listitem" style="list-style-type: disc">End-to-end tests with Protractor.</li><li class="listitem" style="list-style-type: disc">A development server with LiveReload.</li><li class="listitem" style="list-style-type: disc">Uses codelyzer for static code analysis, which verifies that your project follows the Angular style guide to some extent.</li><li class="listitem" style="list-style-type: disc">Follows the best practices for your applications' and files' organization.</li><li class="listitem" style="list-style-type: disc">Manager for the TypeScript-related type definitions.</li><li class="listitem" style="list-style-type: disc">Provides full Docker support for both development and production environment.</li></ul></div><p>The code distributed with the book is based on this seed project.</p><p>For <code class="literal">angular-seed</code>, you will need to have node.js, npm, and git installed and will need to run the following list of commands:</p><pre class="programlisting">
<span class="strong"><strong>$ git clone --depth 1 https://github.com/mgechev/angular-seed.git &#13;
$ cd angular-seed &#13;
$ npm install &#13;
$ npm start</strong></span>
</pre><p>After you have run the preceding commands, your browser will automatically open the home page of the seed. Upon the change of any of the files in your project, the application will be automatically rebuilt, and your browser will be refreshed.</p><p>By default, the production build produces a single bundle that contains a minified version of the application and all the referenced libraries. Angular Seed also supports AoT compilation and extensible build systems.</p></div><div class="section" title="Angular 2 Webpack starter"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec118"/>Angular 2 Webpack starter</h2></div></div></div><p>If you prefer Webpack, you can use <span class="emphasis"><em>angular2-webpack-starter</em></span>. It is a starter project developed by <span class="emphasis"><em>AngularClass</em></span> and hosted on GitHub. You can find it at <a class="ulink" href="https://github.com/AngularClass/angular2-webpack-starter">
https://github.com/AngularClass/angular2-webpack-starter
</a>.</p><p>This starter provides the following features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The best practices in file and application organization for Angular.</li><li class="listitem" style="list-style-type: disc">Ready-to-go build system using Webpack for working with TypeScript.</li><li class="listitem" style="list-style-type: disc">Testing Angular code with Jasmine and Karma.</li><li class="listitem" style="list-style-type: disc">Coverage with Istanbul and Karma.</li><li class="listitem" style="list-style-type: disc">End-to-end Angular code using Protractor.</li><li class="listitem" style="list-style-type: disc">Type manager with Typings.</li></ul></div><p>In order to give it a try, you will need to have node.js, npm, and git installed and run the following commands:</p><pre class="programlisting">
<span class="strong"><strong>$ git clone --depth 1 https://github.com/angularclass/angular2-webpack-starter.git &#13;
$ cd angular2-webpack-starter &#13;
$ npm install &#13;
$ npm start</strong></span>
</pre></div></div>
<div class="section" title="AoT compilation in Angular"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec69"/>AoT compilation in Angular</h1></div></div></div><p>In this section, we'll briefly explain what AoT compilation is in the context of Angular and what implication it may have on our projects, without going into deep technical details. </p><p>The key focus in Angular is it's extremely fast change detection mechanism. After exploring different options for performing change detection, the Angular team discovered that the change detection mechanism used in AngularJS can be improved dramatically using <span class="strong"><strong>code generation</strong></span>. It turns out that generating code, which performs change detection and rendering and on top of that is very well optimized for the JavaScript virtual machine, runs much faster compared to the traditional (also known as dynamic) change detection mechanism.</p><div class="section" title="How code generation works"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec119"/>How code generation works</h2></div></div></div><p>The Angular code generator is known as the Angular compiler. What it does is compile the templates of the Angular components to JavaScript or TypeScript (depending on the use case). When we compile the templates to TypeScript, we allow the TypeScript compiler to perform type checking, not only within the imperative logic of our components, directives, services and pipes, but also in the components' templates! Performing type checking in the templates helps us find even more potential issues in our application.</p><p>On top of code generation for templates, the Angular compiler also generates code for the injectors in our application. This improves the performance of the dependency injection mechanism even further.</p><p>Based on the static analysis of the bindings in the templates, the generated code for the templates performs the most efficient change detection and most optimal update of the DOM tree, depending on the changed values. On top of that, the produced code takes advantage of the inline caching mechanism of JavaScript virtual machines, which brings an additional performance boost.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note51"/>Note</h3><p>For further reading about inline caching, take a look at the article <span class="emphasis"><em>Explaining JavaScript VMs in JavaScript - Inline Caches</em></span> located at <a class="ulink" href="http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html">http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html</a>.</p></div></div><p>The code generation could be either performed at runtime, known as <span class="strong"><strong>Just-in-Time </strong></span>(<span class="strong"><strong>JiT</strong></span>) compilation or build time, known as <span class="strong"><strong>Ahead-of-Time</strong></span> (<span class="strong"><strong>AoT</strong></span>) compilation. Since the JiT compilation involves the evaluation of code at runtime, it is recommended that you use AoT in environments with strict <span class="strong"><strong>CSP</strong></span> (<span class="strong"><strong>Content-Security-Policy</strong></span>), where <code class="literal">eval</code> is not available.</p></div><div class="section" title="Introducing AoT compilation"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec120"/>Introducing AoT compilation</h2></div></div></div><p>From AoT, we get a couple of improvements. Firstly, if we compile our Angular application as part of the build process, we don't need to compile it at runtime. This has two implications. Firstly, we don't have the runtime performance hit that we get when using JiT. This way, AoT offers faster initial rendering of the application because Angular has to do less work during initialization.</p><p>On top of that, since we don't have to perform compilation at runtime anymore, we can drop the entire <code class="literal">@angular/compiler</code> module out of the final application bundle and decrease the bundle size.</p><p>Finally, we can perform much more efficient dead code elimination in terms of <span class="strong"><strong>tree-shaking</strong></span>. Tree-shaking means dropping unused exports, which is one of the great properties of the static nature of the ES2015 modules. When relaying on JiT compilation, we can reference different components by their selectors inside the templates. However, the templates are in HTML-like format, which the modern minifiers (such as uglifyjs, Google Closure Compiler, and so on) don't understand. This means that they cannot eliminate all the unused exports (for instance, unused components), since they are not sure what exactly is used within the templates. Once at build time, the Angular compiler translates the templates to TypeScript or JavaScript, with static ES2015 imports, bundlers can apply traditional dead-code elimination techniques, and so reduce the bundle size even further!</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note52"/>Note</h3><p>If you're interested in further reading, you can take a look at the article <span class="emphasis"><em>Ahead-of-Time Compilation in Angular</em></span> at <a class="ulink" href="https://goo.gl/eXieJl">https://goo.gl/eXieJl</a>.</p></div></div></div><div class="section" title="Constraints of the AoT compilation"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec121"/>Constraints of the AoT compilation</h2></div></div></div><p>Keep in mind that the Angular compiler needs type metadata in order to perform the process of compilation. This means that you cannot perform AoT compilation if you're not using TypeScript. </p><p>AoT compilation is performed without any data collected at runtime. This means that, in some cases, your code may work with JiT but may not work in AoT in case you have dynamic constructs, which cannot be resolved at build time.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note53"/>Note</h3><p>For further details, take a look at this repository at 
 <a class="ulink" href="https://goo.gl/F7cV1s">https://goo.gl/F7cV1s</a>.</p></div></div><p>Finally, the generated code for the templates is not part of the components' controllers themselves. This means that we cannot bind to non-public fields because, during compilation, TypeScript will throw an error.</p></div><div class="section" title="How to use the AoT compilation of Angular"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec122"/>How to use the AoT compilation of Angular</h2></div></div></div><p>The Angular's AoT compilation is already supported in the most popular starters and the CLI.</p><p>At the time of writing, Angular CLI does not perform an AoT compilation by default. You can enable it using the <code class="literal">--aot</code> flag:</p><pre class="programlisting">
<span class="strong"><strong>$ ng build --prod --aot</strong></span>
</pre><p>Angular Seed introduced AoT compilation when Angular 2.0.0-rc.5 was released. With the seed, you can take advantage of all the benefits that come with it by performing:</p><pre class="programlisting">
<span class="strong"><strong>$ npm run build.prod.aot</strong></span>
</pre><p>By running the commands above, you'll get a well-optimized production build of your application.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note54"/>Note</h3><p>Since web tooling changes quite frequently, we didn't go into details of how Angular Seed or Angular CLI produce the production build. If you're interested in further reading on what is going on under the hood, you can take a look at an article at <a class="ulink" href="https://goo.gl/kAiJUJ">https://goo.gl/kAiJUJ</a>.</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec70"/>Summary</h1></div></div></div><p>We started our journey by introducing the reasons behind the rewrite of Angular, which was followed by a conceptual overview that gave us a general idea about the building blocks that the framework provides. In the next step, we went through a TypeScript crash course that prepared us for <a class="link" href="ch04.html" title="Chapter 4. Getting Started with Angular Components and Directives">
Chapter 4</a>, <span class="emphasis"><em>Getting Started with Angular Components and Directives</em></span>, where we went deep into Angular's directives, components, and change detection.</p><p>In <a class="link" href="ch05.html" title="Chapter 5. Dependency Injection in Angular">
Chapter 5</a>, <span class="emphasis"><em>Dependency Injection in Angular</em></span>,<span class="emphasis"><em> </em></span>we explained the dependency injection mechanism and saw how it's related to the component hierarchy. In the next chapters, we saw how we can build forms and pipes and take advantage of Angular's router.</p><p>By completing this chapter, we have finished our journey into the framework. At the time of writing, the design decisions and the ideas behind Angular's core are solid and finalized. Although the framework is still brand new, in the past couple of months, its ecosystem reached a level where we can develop production-ready, high-performance, SEO-friendly applications, and on top of this, have a great development experience with static typing and IDE support.</p></div></body></html>