- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Latest Trends in Microfrontends
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微前端的最新趋势
- en: The world of frontend engineering is constantly evolving, and as we go about
    building microfrontends following the currently available tools, approaches, and
    best practices, it is important to keep an eye on the latest trends that are evolving
    in this space and keep exploring and experimenting with them to see how they can
    help us become more efficient and build better apps.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 前端工程的世界不断演变，当我们根据目前可用的工具、方法和最佳实践构建微前端时，关注这个领域正在演变的最新的趋势，并不断探索和实验它们，以了解它们如何帮助我们提高效率并构建更好的应用程序，这一点非常重要。
- en: 'In this chapter, we will cover some trends that can influence how we build
    microfrontends in the future. Some of the trends we will explore are the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些可能影响我们未来构建微前端趋势。我们将探讨的一些趋势如下：
- en: The name *microfrontends* itself and what is a better term for it
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 术语*微前端*本身以及更好的术语是什么
- en: The island pattern of mixing static content with dynamic content
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合静态内容和动态内容的孤岛模式
- en: Looking at other build tools beyond Webpack
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看Webpack之外的构建工具
- en: WebAssembly
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebAssembly
- en: Cloud or edge functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云或边缘函数
- en: How generative AI can influence our work
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成式AI如何影响我们的工作
- en: By the end of this chapter, we will have learned about the latest trends in
    the frontend engineering space that impact how we build microfrontends.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将了解影响我们构建微前端的前端工程领域的最新趋势。
- en: Microfrontends – decoupled modular frontends
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微前端 – 解耦模块化前端
- en: The term *microfrontends* has obviously become very popular, and this entire
    book uses it, but to be honest, I’ve always felt it was poorly coined and unfortunately,
    it has stuck within the community. As mentioned a couple of times, the word *microfrontend*
    has led to a lot of misinterpretation, leading to bad architectural patterns that
    cause more harm than good. A new proposal has been put forward to start calling
    them **composable decoupled frontends** ([https://microfrontend.dev/](https://microfrontend.dev/)),
    which I think is apt and clearly explains the intent and purpose of what we are
    building. I really hope the community starts picking this term up and that we
    collectively all start moving to building and calling microfrontends what they
    really are and defining what they are really supposed to do.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*微前端*显然已经变得非常流行，整本书都在使用它，但说实话，我一直觉得这个术语用得不好，而且不幸的是，它已经在社区中根深蒂固。正如提到过几次，*微前端*这个词导致了很多误解，导致了不良的架构模式，反而比好的影响更大。已经提出了一个新的建议，开始称它们为**可组合解耦前端**([https://microfrontend.dev/](https://microfrontend.dev/))，我认为这是恰当的，并且清楚地解释了我们正在构建的内容的意图和目的。我真心希望社区开始采用这个术语，并且我们共同开始转向构建和称呼微前端为它们真正是的样子，并定义它们真正应该做什么。
- en: I’m sure many of you will wonder how simply changing the name helps and what’s
    really in a name; however, I feel that, in this case, a name that clearly articulates
    the architecture pattern greatly reduces the misconceptions, misinterpretation,
    and complications arising from wrongly architected systems. As you will have realized
    through the course of this book, it is all about building modular applications
    that are decoupled from each other and hence they should be rightfully called
    **Decoupled** **Modular Frontends**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你们中的许多人会想知道仅仅改变名称如何有帮助，以及名称中真正包含的是什么；然而，我觉得在这种情况下，一个清楚地阐述架构模式的名称可以大大减少由错误架构的系统引起的误解、误释和复杂性。正如你们通过本书的学习过程所意识到的那样，这全部关于构建模块化应用程序，这些应用程序相互解耦，因此它们应该正确地被称为**解耦**
    **模块化前端**。
- en: The island pattern
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 孤岛模式
- en: Statically generated pages are gaining a lot of popularity as they ship very
    little to no JavaScript; however, the challenge with them has always been on how
    to serve dynamic content.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 静态生成的页面越来越受欢迎，因为它们几乎不包含JavaScript；然而，它们的挑战始终在于如何提供动态内容。
- en: The **island pattern** aims to solve this problem. It was made popular by the
    Astro build framework, wherein we have our application published as a set of statically
    generated HTML pages, within which the dynamic parts of the page are imported
    as islands.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**孤岛模式**旨在解决这个问题。它由Astro构建框架推广，其中我们的应用程序被发布为一系列静态生成的HTML页面，页面的动态部分作为孤岛导入。'
- en: Here is an example of how this can be achieved using Astro, a popular framework
    for building statically generated sites.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用Astro的例子，Astro是一个用于构建静态网站的流行框架，展示如何实现这一点。
- en: 'You can read more about this at [https://docs.astro.build/en/concepts/islands/](https://docs.astro.build/en/concepts/islands/):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://docs.astro.build/en/concepts/islands/](https://docs.astro.build/en/concepts/islands/)
    上了解更多关于此的信息。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Run the Astro build command, test the app locally, and look into your `Inspect`
    command; you will notice that while the rest of the page is plain HTML with little
    to no JavaScript, `MyReactComponent` is a small JavaScript element and executes
    on the client side.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Astro 构建命令，在本地测试应用，并查看你的 `Inspect` 命令；你会注意到，尽管页面的其余部分是带有少量或没有 JavaScript
    的纯 HTML，但 `MyReactComponent` 是一个小的 JavaScript 元素，并在客户端执行。
- en: As you can see, with the island pattern, we get a clear distinction between
    static and dynamic content with the potential added benefit of not being locked
    down to a single framework for all parts of the application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用岛屿模式，我们可以在静态和动态内容之间获得清晰的区分，并且可能带来不将所有应用部分锁定到单个框架的额外好处。
- en: 'Having said that, there are a few differences between the island pattern and
    microfrontends, including the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，岛屿模式和微前端之间有一些差异，包括以下内容：
- en: Islands in Astro are components that are hydrated/rendered on the client side,
    while microfrontends are independent applications with their own code bases, routing,
    and backends. Microfrontends are more isolated and decoupled.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Astro 中的岛屿是客户端的水合/渲染组件，而微前端是具有自己的代码库、路由和后端的独立应用。微前端更加隔离和松耦合。
- en: Astro builds the entire app and islands at build time. Microfrontends are built
    and deployed independently. Astro has a unified build, while microfrontends can
    have separate builds.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Astro 在构建时构建整个应用和岛屿。微前端是独立构建和部署的。Astro 有统一的构建，而微前端可以有独立的构建。
- en: Routing in Astro happens in the shell, while each microfrontend manages its
    own routing. Astro islands don’t have independent routing.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Astro 中的路由发生在外壳中，而每个微前端管理自己的路由。Astro 岛屿没有独立的路由。
- en: Astro islands can communicate with each other via Astro integration, while microfrontends
    typically communicate via well-defined APIs and events. Islands have tighter coupling
    and integration with the Astro app.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Astro 岛屿可以通过 Astro 集成相互通信，而微前端通常通过定义良好的 API 和事件进行通信。岛屿与 Astro 应用有更紧密的耦合和集成。
- en: Beyond Webpack with ES Modules
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越 Webpack 与 ES 模块
- en: With the dawn of JavaScript-based frameworks, Webpack rose in popularity, and
    it became the de facto module bundler for all JavaScript frameworks. However,
    bundling/compiling large applications with Webpack can be very slow, and manually
    configuring it to efficiently bundle an app is very complex. Recently, a new breed
    of bundler tools that takes advantage of ES modules has taken the frontend world
    by storm, promising compilation over 20 times faster than Webpack.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 随着基于 JavaScript 的框架的兴起，Webpack 的受欢迎程度上升，并成为所有 JavaScript 框架的事实上的模块打包器。然而，使用
    Webpack 打包/编译大型应用可能会非常慢，手动配置以高效打包应用非常复杂。最近，一种利用 ES 模块的新一代打包工具在前端世界掀起了一场风暴，承诺编译速度比
    Webpack 快 20 倍以上。
- en: ES modules are a standardized way to define and import modules in JavaScript.
    They allow for modular code organization, which can make it easier to develop
    and maintain large applications. ES modules also provide a clear and explicit
    syntax for importing and exporting code, making it easier to reason about the
    dependencies between different modules.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ES 模块是定义和导入 JavaScript 模块的标准方式。它们允许模块化代码组织，这可以使开发大型应用更容易，也更容易维护。ES 模块还提供了清晰和明确的语法来导入和导出代码，使得推理不同模块之间的依赖关系更容易。
- en: Each of our micro apps can be exported as ES modules, and by using dynamic imports,
    we can embed them into our host application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将每个微应用导出为 ES 模块，并通过使用动态导入，将它们嵌入到我们的宿主应用中。
- en: The entire microfrontend application can be bundled using an ES build-based
    module bundler such as Vite ([https://vitejs.dev/](https://vitejs.dev/)). Monorepo
    frameworks such as Nx allow you to easily configure using Vite as your module
    bundler.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 整个微前端应用可以使用基于 ES 构建的模块打包器，如 Vite ([https://vitejs.dev/](https://vitejs.dev/))
    进行打包。Monorepo 框架如 Nx 允许你轻松配置使用 Vite 作为模块打包器。
- en: 'We can scaffold out a React app using Vite as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Vite 搭建一个 React 应用，如下所示：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is a rough example of how this can be achieved:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个如何实现这一点的粗略示例：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the host app, we use the classic React `suspense` and `lazy` functions to
    load in `CatalogApp` at runtime:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在宿主应用中，我们使用经典的 React `suspense` 和 `lazy` 函数在运行时加载 `CatalogApp`：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you will have noticed, we have managed to get our app working without using
    Webpack or Webpack’s module federation, and I’m sure you will also notice how
    fast the app builds after any changes that you make.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所注意到的，我们已经设法在不使用 Webpack 或 Webpack 的模块联邦的情况下使我们的应用工作，我相信你也会注意到你做出任何更改后应用构建的速度有多快。
- en: We believe ES modules and ES build systems will soon replace Webpack to become
    the de facto tools of choice for building all modern frontends. What is also interesting
    to note is that while React’s `lazy` and `suspense` functions are commonly thought
    of as performance optimization techniques, we take advantage of their ability
    to load modules in real time to build microfrontends.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们相信 ES 模块和 ES 构建系统将很快取代 Webpack，成为构建所有现代前端的事实上首选工具。值得注意的是，虽然 React 的 `lazy`
    和 `suspense` 函数通常被认为是性能优化技术，但我们利用它们实时加载模块的能力来构建微前端。
- en: Using WebAssembly Modules
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 WebAssembly 模块
- en: '**WebAssembly** (**Wasm**) has been around for many years now. Despite its
    huge benefits in terms of performance and low bundle size, it hasn’t gained much
    popularity, primarily because it wasn’t easy for developers to build a WASM module.
    However, now that people are starting to work with tools such as Rust, it gets
    fairly easy to build WebAssembly modules with Rust. We anticipate that WebAssembly
    will become mainstream when building applications that require a high level of
    computation on the browser.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**WebAssembly** (**Wasm**) 已经存在很多年了。尽管它在性能和低包大小方面具有巨大的优势，但它并没有获得太多的普及，主要是因为开发者构建
    WASM 模块并不容易。然而，现在随着人们开始使用 Rust 等工具，使用 Rust 构建 WebAssembly 模块变得相当容易。我们预计，当构建需要在浏览器上进行高度计算的应用时，WebAssembly
    将成为主流。'
- en: WASM modules can work really well in a microfrontend architecture, where the
    critical compute-intensive modules are built in WASM wrapped as a micro app and
    imported into a microfrontend architecture in which the rest of the micro apps
    in the microfrontend are built using the standard React.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: WASM 模块在微前端架构中可以工作得非常好，其中关键的计算密集型模块是用 WASM 封装作为微应用构建的，并导入到微前端架构中，在该架构中，微前端中的其余微应用使用标准的
    React 构建。
- en: Here is a rough approach of how you could set this up in your module federated
    Next.js app. Use our module federation code from [*Chapter 6*](B18987_06.xhtml#_idTextAnchor093).
    First build a Rust app using `wasm_bindgen` within a `/rust` folder.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个大致的方法，你可以用它来设置你的模块联邦 Next.js 应用。使用我们来自 [*第 6 章*](B18987_06.xhtml#_idTextAnchor093)
    的模块联邦代码。首先，在 `/rust` 文件夹内使用 `wasm_bindgen` 构建一个 Rust 应用。
- en: 'To compile the rust app to wasm we need to install the `wasm-pack-plugin` as
    using `pnpm install @wasm-tool/wasm-pack-plugin` and use it in the `next.config.js`
    configuration as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Rust 应用编译为 wasm，我们需要安装 `wasm-pack-plugin`，使用 `pnpm install @wasm-tool/wasm-pack-plugin`
    安装它，并在 `next.config.js` 配置中使用它，如下所示：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then using dynamic imports, import the wasm module into the index page of the
    remote app. And finally using the approaches we used in [*Chapter 6*](B18987_06.xhtml#_idTextAnchor093)
    import the remote app into the host app.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用动态导入，将 wasm 模块导入远程应用的索引页面。最后，使用我们在 [*第 6 章*](B18987_06.xhtml#_idTextAnchor093)
    中使用的方法将远程应用导入主机应用。
- en: 'WASM is already being used in some very popular web-based tools such as Figma,
    AutoCAD, Google Earth, the Unity game engine, and so on. Combining WebAssembly
    modules with microfrontends helps bring the best of both worlds: the power and
    performance of WASM, and the ease of use and modularity of microfrontends.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: WASM 已经被用于一些非常流行的基于网络的工具中，如 Figma、AutoCAD、Google Earth、Unity 游戏引擎等。将 WebAssembly
    模块与微前端结合使用，有助于将两者的优点结合起来：WASM 的力量和性能，以及微前端的易用性和模块化。
- en: Edge Functions or Cloud functions
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Edge 函数或云函数
- en: Edge functions are gaining a lot of popularity, as they provide the power to
    compute on the edge. Think of them like a **Content Delivery Network** (**CDN**)
    but with the power and ability to run computations.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Edge 函数越来越受欢迎，因为它们提供了在边缘进行计算的能力。想象一下，它们就像一个 **内容分发网络** (**CDN**)，但具有运行计算的能力和力量。
- en: The primary benefits of edge functions are that they provide very low latency,
    which greatly helps improve performance, and they use an automatic distributed
    deployment, which mitigates single points of failure and helps improve scalability.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Edge 函数的主要好处是它们提供了非常低的延迟，这极大地帮助提高了性能，并且它们使用自动分布式部署，这有助于减轻单点故障并提高可扩展性。
- en: Edge functions and microfrontends work quite well hand in hand, where you can
    have each micro app deployed within a cloud function; this automatically allows
    for modular deployments, and each team can manage its cloud functions independently.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘函数和微前端配合得相当好，你可以将每个微应用部署在云函数中；这自动允许模块化部署，每个团队可以独立管理其云函数。
- en: Cloudflare is one of the most popular providers that support cloud functions.
    Cloudflare Workers and most recently Cloudflare Pages support computing on the
    edge. Here is an example of how to deploy a Next.js App on Cloudflare Pages using
    Edge Runtime.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Cloudflare是最受欢迎的云函数提供商之一。Cloudflare Workers和最近推出的Cloudflare Pages支持边缘计算。以下是如何使用Edge
    Runtime在Cloudflare Pages上部署Next.js应用的示例。
- en: Start with any of the existing Next.js apps we’ve built.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们构建的任何现有Next.js应用开始。
- en: '[PRE5]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Commit your changes and push them into a Git repo.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交你的更改并将它们推送到Git仓库。
- en: Login into the Cloudflare dashboard and go to **Workers & Pages | Create Application
    | Pages | Connect** **to Git**.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录Cloudflare仪表板，转到**Workers & Pages | 创建应用 | Pages | 连接到Git**。
- en: 4\. Select the repo where you pushed the code and in the Setup builds and deployments,
    select Next.js as your Framework. Leave the rest of the settings as default.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4. 选择你推送代码的仓库，在设置构建和部署中，选择Next.js作为你的框架。其余的设置保持默认。
- en: Next we need to set the Compatibility Flags which we do by going into the `nodejs_compat`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置兼容性标志，这通过进入`nodejs_compat`来实现。
- en: From the Deployment Details section go to the **Manage Deployment** and select
    **Retry deployment** from the dropdown.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从部署详情部分进入**管理部署**，从下拉菜单中选择**重试部署**。
- en: Thanks to the low costs and ease of deployments, we believe there is a great
    potential to deploy all frontend applications, irrespective of whether they are
    microfrontends or not, on platforms such as Vercel, Cloudflare, Fastly, and so
    on.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于成本低廉和部署简便，我们相信在Vercel、Cloudflare、Fastly等平台上部署所有前端应用，无论它们是否是微前端，都具有巨大的潜力。
- en: 'Most edge function providers have very good support for the JavaScript ecosystem;
    however, it is important to keep in mind that based on the vendor/platform you
    are working on, there may be certain restrictions. For example, Cloudflare limits
    the size of each worker to be under 1 MB, or it explicitly supports package versions
    that are compatible with the broader Node.js runtime environments. For Cloudflare,
    you can read more about Node.js compatibility here: [https://developers.cloudflare.com/pages/framework-guides/](https://developers.cloudflare.com/pages/framework-guides/).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数边缘函数提供商对JavaScript生态系统都有非常好的支持；然而，重要的是要记住，根据你正在工作的供应商/平台，可能会有某些限制。例如，Cloudflare限制每个worker的大小不超过1
    MB，或者它明确支持与更广泛的Node.js运行时环境兼容的包版本。对于Cloudflare，你可以在这里了解更多关于Node.js兼容性的信息：[https://developers.cloudflare.com/pages/framework-guides/](https://developers.cloudflare.com/pages/framework-guides/)。
- en: Generative AI and Microfrontends
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成式AI和微前端
- en: Generative AI has clearly taken the world by storm. We are seeing amazing examples
    of generative AI being able to generate complete end-to-end applications.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 生成式AI显然已经席卷了整个世界。我们看到许多令人惊叹的例子，生成式AI能够生成完整的端到端应用。
- en: When it comes to building microfrontends, it will be very interesting to see
    how things evolve. While I believe generative AI can’t take over a developer’s
    job, I do see interesting use cases of how generative AI can work hand in hand
    with microfrontends in building unique customer experiences.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到构建微前端时，看到事情如何发展将非常有趣。虽然我相信生成式AI不能取代开发者的工作，但我确实看到了生成式AI如何与微前端携手共建独特客户体验的有趣用例。
- en: Generative AI can be leveraged to dynamically generate and assemble various
    parts of a web application. By intelligently analyzing user behavior, preferences,
    and real-time context, AI can create microfrontends that are tailor-made for individual
    users, resulting in a highly personalized and optimized user experience. This
    approach also simplifies the development process by allowing developers to focus
    on creating modular, composable micro apps, while the AI system takes care of
    the overall assembly and rendering of the web application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 生成式AI可以被用来动态生成和组装Web应用的各个部分。通过智能分析用户行为、偏好和实时上下文，AI可以创建为单个用户量身定制的微前端，从而实现高度个性化和优化的用户体验。这种方法还通过允许开发者专注于创建模块化、可组合的微应用，同时AI系统负责整个Web应用的组装和渲染，从而简化了开发过程。
- en: New AI-powered tools such as GPT-Engineer, smol-ai, and Auto-GPT are emerging,
    which allow developers to describe application requirements using plain text or
    Markdown. These tools then scaffold and generate code for the full application
    based on the developer’s specifications. This removes the need for manually writing
    all of the code, and instead, lets the AI handle much of the initial setup. These
    kinds of AI developer assistants are still at quite an early stage; developers
    will need to learn skills such as crafting effective prompts to get the most consistent
    and accurate results from the AI, but the potential is there for AI to significantly
    enhance and accelerate development workflows. The key will be continuing to improve
    the AI’s code generation abilities while also helping developers provide the right
    input and guidance.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 新的AI工具，如GPT-Engineer、smol-ai和Auto-GPT正在出现，这些工具允许开发者使用纯文本或Markdown描述应用程序需求。然后，这些工具根据开发者的规格构建和生成整个应用程序的代码。这消除了手动编写所有代码的需要，相反，让AI处理大部分初始设置。这类AI开发者助手还处于相当初级的阶段；开发者需要学习如何制作有效的提示，以从AI中获得最一致和最准确的结果，但AI显著增强和加速开发工作流程的潜力是存在的。关键在于继续提高AI的代码生成能力，同时帮助开发者提供正确的输入和指导。
- en: The use of AI in microfrontends can lead to more efficient resource utilization
    and improved performance, as the system can adaptively load and unload components
    based on user interactions and needs. This innovative integration of AI and microfrontends
    has the potential to revolutionize the way web applications are designed, developed,
    and delivered to users.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在微前端中使用人工智能可以导致更有效的资源利用和性能提升，因为系统可以根据用户交互和需求自适应地加载和卸载组件。这种人工智能与微前端的创新集成有可能彻底改变网络应用的设计、开发和交付给用户的方式。
- en: Summary
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With this, we have come to the end of this chapter and the book. We really hope
    you’ve enjoyed the journey.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经到达了本章和本书的结尾。我们真心希望您已经享受了这次旅程。
- en: In this chapter, we looked at a few new trends that will influence the way we
    build and deploy microfrontends. We saw how concepts such as the island pattern
    can help interlace dynamic content blocks within a statically generated multipage
    app. We saw how the new Rust-based bundler can be many times faster than Webpack.
    We learned about WebAssembly and how it can be used within microfrontends, and
    finally, we looked at cloud functions, which have the potential to become the
    default solution for deploying all modern frontend applications.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了几个将影响我们构建和部署微前端的新趋势。我们看到了如何使用岛屿模式帮助将动态内容块交织在静态生成的多页应用中。我们看到了基于新Rust打包器的工具可以比Webpack快许多倍。我们了解了WebAssembly及其在微前端中的应用，最后，我们探讨了云函数，它们有可能成为部署所有现代前端应用的默认解决方案。
- en: I’m truly excited about how quickly technology is evolving and how it affects
    the way we build our applications. I can’t wait to see you go out in the wild
    and build things that make this world a better place.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我对技术发展之快以及它如何影响我们构建应用程序的方式感到非常兴奋。我迫不及待地想看到您走出家门，构建出让这个世界变得更美好的事物。
- en: In closing, it is essential to remember that the world of microfrontends, much
    like our dynamic digital landscape, is in a constant state of evolution. The concepts,
    techniques, and technologies we have unraveled throughout this journey, such as
    Module Federation and the intriguing practice of deploying microfrontends to the
    cloud, are just the beginning of this ever-evolving tapestry. They provide us
    with the building blocks to construct high-performing, scalable, and maintainable
    frontend architectures. Yet, the future beckons with promises of newer trends
    and advancements that will continue to redefine the horizon.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须记住，微前端的世界，就像我们动态的数字景观一样，始终处于不断演变的状态。我们在这次旅程中揭示的概念、技术和方法，例如模块联邦和将微前端部署到云端的引人入胜实践，只是这个不断演变的画卷的起点。它们为我们提供了构建高性能、可扩展和可维护的前端架构的基石。然而，未来充满了新的趋势和进步的承诺，这些将继续重新定义我们的视野。
- en: I encourage you, the next generation of developers, to step into this exciting
    journey and build upon the foundational knowledge this book has attempted to provide.
    Challenge the status quo, experiment with the latest trends, and mold them to
    fit the unique demands of your projects. It’s a grand time to be a frontend engineer,
    and the world awaits the innovative solutions you will create using React and
    microfrontends. Remember, every line of code you write is an opportunity to improve,
    innovate, and inspire. So, go forth and build for the future.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你们，新一代的开发者，踏进这个激动人心的旅程，并在此基础上构建这本书所尝试提供的知识基础。挑战现状，尝试最新的趋势，并将它们塑造成适合你们项目独特需求的形式。现在是成为一名前端工程师的伟大时刻，世界等待着你们使用React和微前端创造的革新性解决方案。记住，你写的每一行代码都是一个改进、创新和启发的机会。所以，勇往直前，为未来而构建。
