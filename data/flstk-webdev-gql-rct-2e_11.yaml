- en: '*Chapter 9*: Implementing Server-Side Rendering'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 9 章*：实现服务器端渲染'
- en: With our progress from the last chapter, we are now serving multiple pages under
    different paths with our **React** application. Currently, all of the routing
    happens directly on the client. In this chapter, we will look at the advantages
    and disadvantages of **server-side rendering** (**SSR**). By the end of the chapter,
    you will have configured **Graphbook** to serve all pages as pre-rendered HTML
    from the server instead of the client.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章的进展基础上，我们现在使用我们的 **React** 应用在不同的路径下服务多个页面。目前，所有路由都在客户端直接进行。在本章中，我们将探讨 **服务器端渲染**（**SSR**）的优缺点。到本章结束时，你将配置
    **Graphbook** 以从服务器而不是客户端作为预渲染的 HTML 来服务所有页面。
- en: 'This chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Introducing SSR
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 SSR
- en: Setting up SSR in **Express.js** to render React on the server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **Express.js** 中设置 SSR 以在服务器上渲染 React
- en: Enabling **JSON Web Token** (**JWT**) authentication in connection with SSR
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 SSR 中启用 **JSON Web Token**（**JWT**）认证
- en: Running all of our **GraphQL** queries in the React tree
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 React 树中运行所有我们的 **GraphQL** 查询
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The source code for this chapter is available in the following **GitHub** repository:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在以下 **GitHub** 仓库中找到：
- en: '[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter09)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter09)'
- en: Introducing SSR
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 SSR
- en: First, you have to understand the differences between using a server-side-rendered
    and a client-side-rendered application. There are numerous things to bear in mind
    when transforming a pure client-side-rendered application to support SSR. In our
    application, the current user flow begins with the client requesting a standard
    `index.html` file. This file includes only a small number of things, such as a
    small `body` object with one `div` element, a `head` tag with some very basic
    `meta` tags, and a vital `script` tag that downloads the bundled `index.html`
    and the `bundle.js` files. Then, the client's browser begins processing the React
    markup that we wrote. When React has finished evaluating the code, we see the
    HTML of the application that we wanted to see. All CSS files or images are also
    downloaded from our server, but only when React has inserted the HTML into the
    browser's **Document Object Model** (**DOM**). During the rendering by React,
    the **Apollo** components are executed and all of the queries are sent. These
    queries are, of course, handled by our backend and database.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须理解使用服务器端渲染和客户端渲染应用之间的区别。在将纯客户端渲染应用转换为支持服务器端渲染（SSR）时，有许多事情需要考虑。在我们的应用中，当前的用户流程从客户端请求一个标准的
    `index.html` 文件开始。这个文件只包含少量内容，例如一个包含一个 `div` 元素的少量 `body` 对象，一个带有一些非常基本的 `meta`
    标签的 `head` 标签，以及一个至关重要的 `script` 标签，该标签下载捆绑的 `index.html` 和 `bundle.js` 文件。然后，客户端的浏览器开始处理我们编写的
    React 标记。当 React 完成代码评估后，我们看到的就是我们想要看到的应用的 HTML。所有 CSS 文件或图像都是从我们的服务器下载的，但只有在
    React 将 HTML 插入浏览器 **文档对象模型**（**DOM**）之后才会下载。在 React 的渲染过程中，**Apollo** 组件被执行，所有查询都被发送。当然，这些查询由我们的后端和数据库处理。
- en: In comparison with SSR, the client-side approach is straightforward. Before
    the development of **Angular**, **Ember**, **React**, and other JavaScript frameworks,
    the conventional approach was to have a backend that implemented all of the business
    logic and also a high number of templates or functions that returned valid HTML.
    The backend queried the database, processed the data, and inserted the data into
    the HTML. The HTML was directly served at the request of the client. The browser
    then downloaded the JavaScript, CSS, and image files according to the HTML. Most
    of the time, the JavaScript was only responsible for allowing dynamic content
    or layout changes, rather than rendering the entire application. This could include
    drop-down menus, accordions, or just pulling new data from the backend via **Ajax**.
    The main HTML of the application, however, was directly returned from the backend,
    which resulted in a monolith application. A significant benefit of this solution
    is that the client does not need to process all of the business logic, as it has
    already been done on the server.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与SSR相比，客户端方法更为直接。在**Angular**、**Ember**、**React**和其他JavaScript框架开发之前，传统的方法是拥有一个后端，它实现了所有的业务逻辑，并且有大量的模板或函数返回有效的HTML。后端查询数据库，处理数据，并将数据插入到HTML中。HTML直接在客户端请求时提供。然后浏览器根据HTML下载JavaScript、CSS和图像文件。大多数情况下，JavaScript只负责允许动态内容或布局变化，而不是渲染整个应用程序。这可能包括下拉菜单、手风琴或只是通过**Ajax**从后端拉取新数据。然而，应用程序的主要HTML直接从后端返回，这导致了一个单体应用程序。这个解决方案的一个显著优点是客户端不需要处理所有的业务逻辑，因为这一切已经在服务器上完成了。
- en: However, when we talk about SSR in the context of React applications, we are
    referring to something different. At this point in the book, we have written a
    React application that renders on the client. We do not want to re-implement the
    rendering for the backend in a slightly different way. We also don't want to lose
    the ability to change data, pages, or the layout dynamically in the browser, as
    we already have an excellent working application with many interaction possibilities
    for the user.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们谈论React应用程序中的SSR时，我们指的是不同的事情。在本书的这一部分，我们已经编写了一个在客户端渲染的React应用程序。我们不想以稍微不同的方式重新实现后端的渲染。我们也不希望失去在浏览器中动态更改数据、页面或布局的能力，因为我们已经有一个功能完善的应用程序，它为用户提供了许多交互可能性。
- en: An approach that allows us to make use of the pre-rendered HTML – as well as
    the dynamic features provided by React – is called **universal rendering**. With
    universal rendering, the first request of the client includes a pre-rendered HTML
    page. The HTML should be the exact HTML that the client generates when processing
    it on its own. If this is the case, React can reuse the HTML provided by the server.
    Since SSR not only involves reusing HTML but also saving requests made by Apollo,
    the client also needs a starting cache that React can rely on. The server makes
    all of the requests before sending the rendered HTML and inserts a state variable
    for Apollo and React into the HTML. The result is that on the first request by
    the client, our frontend should not need to rerender or refresh any HTML or data
    that is returned by the server. For all following actions, such as navigating
    to other pages or sending messages, the same client-side React code from before
    is used. In other words, SSR is only used on the first page load. Afterward, these
    features do not require SSR because the client-side code continues to work dynamically,
    as it did before.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一种允许我们利用预渲染的HTML以及React提供的动态功能的方法被称为**通用渲染**。在通用渲染中，客户端的第一个请求包括一个预渲染的HTML页面。HTML应该是客户端在自行处理时生成的确切HTML。如果是这样，React可以重用服务器提供的HTML。由于SSR不仅涉及重用HTML，还涉及节省Apollo发出的请求，因此客户端也需要一个React可以依赖的起始缓存。服务器在发送渲染的HTML之前发出所有请求，并将Apollo和React的状态变量插入到HTML中。结果是，在客户端的第一个请求中，我们的前端不应该需要重新渲染或刷新服务器返回的任何HTML或数据。对于所有后续操作，如导航到其他页面或发送消息，之前使用的相同客户端React代码仍然适用。换句话说，SSR仅在第一次页面加载时使用。之后，这些功能不需要SSR，因为客户端代码将继续像之前一样动态工作。
- en: Let's get started with writing some code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写一些代码。
- en: Setting up SSR in Express.js to render React on the server
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Express.js中设置SSR以在服务器上渲染React
- en: 'In this example, the first step is to implement basic SSR on the backend. We
    are going to extend this functionality later to validate the authentication of
    the user. An authenticated user allows us to execute Apollo or GraphQL requests
    rather than only render the pure React markup. First, we need some new packages.
    Because we are going to use universally rendered React code, we require an advanced
    webpack configuration. Therefore, we will install the following packages:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，第一步是在后端实现基本的SSR。我们将在稍后扩展这个功能以验证用户的身份验证。经过身份验证的用户允许我们执行Apollo或GraphQL请求，而不仅仅是渲染纯React标记。首先，我们需要一些新的包。因为我们将使用通用渲染的React代码，我们需要一个高级的webpack配置。因此，我们将安装以下包：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s quickly go through the packages that we are installing. We only need
    these packages for development:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下我们要安装的包。我们只需要这些包进行开发：
- en: The first webpack module, called `webpack-dev-middleware`, allows the backend
    to serve bundles that are generated by webpack, but from memory and without creating
    files. This is convenient for cases in which we need to run JavaScript directly
    and do not want to use separate files.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个webpack模块，称为`webpack-dev-middleware`，允许后端服务由webpack生成的包，但仅从内存中生成，而不创建文件。这对于需要直接运行JavaScript而不想使用单独文件的情况非常有用。
- en: The second package, called `webpack-hot-middleware`, only handles client-side
    updates. If a new version of a bundle is created, the client is notified, and
    the bundle is exchanged.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个包，称为`webpack-hot-middleware`，仅处理客户端更新。如果创建了新的包版本，客户端会收到通知，并交换包。
- en: The last package, called `@babel/cli`, allows us to introduce the great features
    that **Babel** provides to our backend. We are going to use React code that has
    to be transpiled.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个包，称为`@babel/cli`，允许我们引入**Babel**为我们后端提供的出色功能。我们将使用需要转译的React代码。
- en: In a production environment, it is not recommended to use these packages. Instead,
    the bundle is built once before deploying the application. The client downloads
    the bundle when the application has gone live.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，不建议使用这些包。相反，在部署应用程序之前，一次性构建包。当应用程序上线时，客户端下载包。
- en: For development with SSR enabled, the backend uses these packages to distribute
    the bundled React code to the client after the SSR has finished. The server itself
    relies on the plain `src` files and not on the webpack bundle that the client
    receives.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用SSR的开发中，后端使用这些包在SSR完成后将打包的React代码分发到客户端。服务器本身依赖于普通的`src`文件，而不是客户端接收的webpack包。
- en: 'We also depend on one further essential package, shown as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还依赖于一个额外的关键包，如下所示：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To set up `window.fetch` method. Apollo Client uses this to send GraphQL requests,
    which is why we install `node-fetch` as a polyfill. We are going to set up Apollo
    Client for the backend later in this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置`window.fetch`方法。Apollo Client使用它来发送GraphQL请求，这就是为什么我们要安装`node-fetch`作为polyfill。我们将在本章后面设置Apollo
    Client以用于后端。
- en: Before starting with the primary work, ensure that your `NODE_ENV` environment
    variable is set to `development`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始主要工作之前，请确保您的`NODE_ENV`环境变量设置为`development`。
- en: Then, head over to the server's `index.js` file, where all of the Express.js
    magic happens. We didn't cover this file in the previous chapter because we are
    going to adjust it now to support SSR including the routing directly.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，转到服务器的`index.js`文件，所有Express.js的魔法都在这里发生。我们之前没有涵盖这个文件，因为我们现在要调整它以支持SSR，包括直接的路由。
- en: 'First, we will set up the development environment for SSR, as this is essential
    for our next tasks. Follow these steps to get your development environment ready
    for SSR:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为SSR设置开发环境，因为这对我们接下来的任务至关重要。按照以下步骤准备您的开发环境以支持SSR：
- en: 'The first step is to import two new webpack modules: `webpack-dev-middleware`
    and `webpack-hot-middleware`. These should only be used in a development environment,
    so we should require them conditionally by checking the environment variables.
    In a production environment, we generate the webpack bundles in advance. In order
    to only use the new packages in development, put the following code underneath
    the setup for the Express.js helmet:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是导入两个新的webpack模块：`webpack-dev-middleware`和`webpack-hot-middleware`。这些模块应该只在开发环境中使用，因此我们应该通过检查环境变量有条件地引入它们。在生产环境中，我们提前生成webpack包。为了只在开发中使用新包，请将以下代码放在Express.js
    helmet设置下方：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After loading these packages, we will also require webpack, as we will parse
    a new webpack configuration file. The new configuration file is only used for
    the SSR.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在加载这些包之后，我们还将需要webpack，因为我们将解析一个新的webpack配置文件。新的配置文件仅用于SSR。
- en: After both webpack and the configuration file have been loaded, we will use
    the `webpack(config)` command to parse the configuration and create a new webpack
    instance.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在加载webpack和配置文件之后，我们将使用`webpack(config)`命令解析配置并创建一个新的webpack实例。
- en: Next, we are going to create the webpack configuration file. To do this, we
    pass the created webpack instance to our two new modules. When a request reaches
    the server, the two packages take action according to the configuration file.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建webpack配置文件。为此，我们将创建的webpack实例传递给我们的两个新模块。当一个请求到达服务器时，这两个包将根据配置文件采取行动。
- en: 'The new configuration file has only a few small differences as compared to
    the original configuration file, but these have a big impact. Create the new `webpack.server.config.js`
    file, and enter the following configuration:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始配置文件相比，新的配置文件只有几个小的差异，但这些差异影响很大。创建新的`webpack.server.config.js`文件，并输入以下配置：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We have made three changes in the preceding configuration in comparison to
    the original `webpack.client.config.js` file, and these are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始的`webpack.client.config.js`文件相比，我们在前面的配置中做了三项更改，具体如下：
- en: In the `entry` property, we now have multiple entry points. The `index` file
    for the frontend code, as before, is one entry point. The second one is the new
    `webpack-hot-middleware` module, which initiates the connection between the client
    and the server. The connection is used to send the client notifications to update
    the bundle to a newer version.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`entry`属性中，我们现在有多个入口点。前端代码的`index`文件，如之前一样，是一个入口点。第二个入口点是新的`webpack-hot-middleware`模块，它启动客户端和服务器之间的连接。这个连接用于发送客户端通知，以更新到新版本的bundle。
- en: I removed the `devServer` field, as this configuration does not require webpack
    to start its own server. Express.js is the web server, which we are already using
    when loading the configuration.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我已经移除了`devServer`字段，因为这个配置不需要webpack启动自己的服务器。Express.js是我们要使用的web服务器，当加载配置时我们已经在使用它了。
- en: The plugins are entirely different from those of the client's webpack configuration.
    We do not need `CleanWebpackPlugin`, as this cleans the `dist` folder, nor the
    `HtmlWebpackPlugin` plugin, which inserts the webpack bundles into the `index.html`
    file; this is handled by the server differently. These plugins are only useful
    for client-side development. Now, we have `HotModuleReplacementPlugin` , which
    enables `NamedModulesPlugin` displays the relative paths for modules injected
    by HMR. Both plugins are only recommended for use in development.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件与客户端的webpack配置中的插件完全不同。我们不需要`CleanWebpackPlugin`，因为它会清理`dist`文件夹，也不需要`HtmlWebpackPlugin`插件，该插件会将webpack打包文件插入到`index.html`文件中；这由服务器以不同的方式处理。这些插件仅适用于客户端开发。现在，我们有`HotModuleReplacementPlugin`，它启用了`NamedModulesPlugin`，显示由HMR注入的模块的相对路径。这两个插件仅推荐在开发中使用。
- en: The webpack preparation is now finished.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: webpack的准备工作现在已完成。
- en: 'Now, we have to focus on how to render React code and how to serve the generated
    HTML. However, we cannot use the existing React code that we have written. First,
    there are specific adjustments that we have to make to the main files: `index.js`,
    `App.js`, `router.js`, and `apollo/index.js`. Many packages that we use, such
    as **React Router** or Apollo Client, have default settings or modules that we
    have to configure differently when they are executed on the server.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须关注如何渲染React代码以及如何服务生成的HTML。然而，我们不能使用我们已编写的现有React代码。首先，我们必须对主文件进行特定的调整：`index.js`、`App.js`、`router.js`和`apollo/index.js`。我们使用的许多包，如**React
    Router**或Apollo Client，都有默认设置或模块，当它们在服务器上执行时，我们必须进行不同的配置。
- en: We will begin with the root of our React application, which is the `index.js`
    file. We are going to implement an individual SSR `index` file, as there are server-specific
    adjustments to do.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从React应用程序的根目录开始，即`index.js`文件。我们将实现一个单独的SSR `index`文件，因为需要进行特定的服务器调整。
- en: 'Create a new folder called `ssr` inside the `server` folder. Then, insert the
    following code into an `index.js` file inside the `ssr` folder:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server`文件夹内创建一个名为`ssr`的新文件夹。然后，将以下代码插入到`ssr`文件夹内的`index.js`文件中：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code is a modified version of our client `index.js` root file.
    The changes that the file has gone through are listed as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是我们客户端 `index.js` 根文件的修改版本。该文件所经历的变化如下列所示：
- en: Instead of using the `ReactDOM.render` function to insert the HTML into the
    DOMNode with the `root` ID, we are now exporting a React component. The returned
    component is called `ServerClient`. There is no DOM that we can access to let
    `ReactDOM` render anything, so we skip this step when rendering on the server.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在不再使用 `ReactDOM.render` 函数将 HTML 插入具有 `root` ID 的 DOMNode 中，而是导出一个 React
    组件。返回的组件被称为 `ServerClient`。我们没有可以访问的 DOM 来让 `ReactDOM` 渲染任何内容，所以在服务器端渲染时我们跳过这一步。
- en: The `ApolloProvider` component now receives Apollo Client directly from the
    `ServerClient` properties, whereas we previously set up Apollo Client directly
    inside this file by importing the `index.js` file from the `apollo` folder and
    passing it to the provider. You will soon see why we are doing this.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApolloProvider` 组件现在直接从 `ServerClient` 属性接收 Apollo Client，而之前我们是直接在这个文件内部通过从
    `apollo` 文件夹导入 `index.js` 文件并将其传递给提供者来设置 Apollo Client。你很快就会看到我们为什么要这样做。'
- en: The last change we made was to extract a `location` and a `context` property.
    We pass these properties to the `App` component. In the original version, there
    were no properties passed to the `App` component. Both properties are required
    in order to configure React Router to work with SSR. We are going to implement
    the properties later in the chapter.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们所做的最后一个变化是提取了一个 `location` 和一个 `context` 属性。我们将这些属性传递给 `App` 组件。在原始版本中，没有向
    `App` 组件传递任何属性。这两个属性都是配置 React Router 以与 SSR 一起工作所必需的。我们将在本章后面实现这些属性。
- en: 'Before looking at why we made these changes in more detail, let''s create the
    new `App` component for the backend. Create an `app.js` file next to the `index.js`
    file in the `ssr` folder, and insert the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在更详细地查看我们为什么要进行这些更改之前，让我们为后端创建一个新的 `App` 组件。在 `ssr` 文件夹中 `index.js` 文件旁边创建一个
    `app.js` 文件，并插入以下代码：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following are a few changes that we made:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们所做的几个更改：
- en: The first change, in comparison to the original client-side `App` component,
    was to adjust the `import` statements to load the router and the `fontawesome`
    component from the `client` folder, as they do not exist in the `server` folder.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与原始的客户端 `App` 组件相比，第一个变化是调整了 `import` 语句，以便从 `client` 文件夹中加载路由器和 `fontawesome`
    组件，因为它们不存在于 `server` 文件夹中。
- en: The second change was to remove the `useEffect` Hooks and the `localStorage`
    access. We did this because the authentication that we built uses the `localStorage`
    access. This is fine for client-side authentication. Neither `useEffect` Hook
    is only called on the client side. This is why we remove the authentication when
    moving our application to SSR. We are going to replace the `localStorage` implementation
    with cookies in a later step. For the moment, the user stays logged out of the
    server.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个变化是移除了 `useEffect` 钩子和 `localStorage` 访问。我们这样做是因为我们构建的认证使用了 `localStorage`
    访问。这对于客户端认证来说是可行的。这两个 `useEffect` 钩子仅在客户端调用。这就是为什么我们在将我们的应用程序移动到 SSR 时移除认证。我们将在稍后的步骤中将
    `localStorage` 实现替换为 cookies。目前，用户保持从服务器端注销状态。
- en: The last change involves passing the two new properties, `context` and `location`,
    to the `Router` component in the preceding code.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个变化是将两个新属性 `context` 和 `location` 传递给前面代码中的 `Router` 组件。
- en: 'React Router provides instant support for SSR. Nevertheless, we need to make
    some adjustments. The best way is that we use the same router for the backend
    and frontend, so we do not need to define routes twice, which is inefficient and
    can lead to problems. Open the `router.js` file inside the `client` folder and
    follow these steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 提供了对 SSR 的即时支持。尽管如此，我们仍需要进行一些调整。最好的方式是我们在后端和前端使用相同的路由器，这样我们就不需要定义两次路由，这既低效又可能导致问题。打开
    `client` 文件夹内的 `router.js` 文件，按照以下步骤操作：
- en: 'Change the `import` statement for the `react-router-dom` package to look like
    the following:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `react-router-dom` 包的 `import` 语句更改为以下形式：
- en: '[PRE6]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Insert the following code to extract the correct router:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入以下代码以提取正确的路由：
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After importing the React Router package, we check whether the file is executed
    on the server or the client by looking for the `window` object. Since there is
    no `window` object in Node.js, this is a sufficient check. An alternative approach
    would be to set up the `Switch` component, including the routes, in a separate
    file. This approach would allow us to import the routes directly into the correct
    router if we create two separate router files for client-side and server-side
    rendering.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在导入React Router包后，我们通过查找`window`对象来检查文件是在服务器端还是客户端执行。由于Node.js中没有`window`对象，这是一个足够的检查。另一种方法是在一个单独的文件中设置`Switch`组件，包括路由。这种方法允许我们在为客户端和服务器端渲染创建两个单独的路由器文件时，直接将路由导入到正确的路由器中。
- en: If we are on the client side, we use `BrowserRouter`, and if not, we use `StaticRouter`.
    Here, the logic is that with `StaticRouter`, we are in a stateless environment,
    where we render all routes with a fixed location. The `StaticRouter` component
    does not allow for the location to be changed by redirects because no user interaction
    can happen when using SSR. The other components, `Route`, `Redirect`, and `Switch`,
    can be used as before.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们在客户端，我们使用`BrowserRouter`，如果不是，我们使用`StaticRouter`。在这里，逻辑是，使用`StaticRouter`时，我们处于一个无状态的环境，其中我们使用固定的位置渲染所有路由。`StaticRouter`组件不允许通过重定向更改位置，因为在使用SSR时无法发生用户交互。其他组件`Route`、`Redirect`和`Switch`可以像以前一样使用。
- en: Regardless of which routers are extracted, we save them in the `Router` variable.
    We then use them in the return statement of the `routing` component.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 无论提取哪个路由器，我们都会将它们保存在`Router`变量中。然后我们在`routing`组件的返回语句中使用它们。
- en: 'We prepared the `context` and `location` properties, which are passed from
    the top `ServerClient` component to the `Router` variable. If we are on the server,
    these properties should be filled, because the `StaticRouter` object requires
    them. You can replace the `Router` tag in the bottom `Routing` component, as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们准备了`context`和`location`属性，这些属性从顶层的`ServerClient`组件传递给`Router`变量。如果我们处于服务器端，这些属性应该被填充，因为`StaticRouter`对象需要它们。你可以在底部的`Routing`组件中替换`Router`标签，如下所示：
- en: '[PRE8]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `location` object holds the path that the router should render. The `context`
    variable stores all of the information the `Router` component processes, such
    as redirects. We can inspect this variable after rendering the `Router` component
    to trigger the redirects manually. This behavior is the big difference between
    `BrowserRouter` and `StaticRouter`. In the first case, `BrowserRouter` redirects
    the user automatically, but `StaticRouter` does not.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`location`对象包含路由应该渲染的路径。`context`变量存储`Router`组件处理的所有信息，例如重定向。我们可以在渲染`Router`组件后检查这个变量，以手动触发重定向。这是`BrowserRouter`和`StaticRouter`之间的一大区别。在前一种情况下，`BrowserRouter`会自动重定向用户，但`StaticRouter`不会。'
- en: The crucial components to render our React code successfully have now been prepared.
    However, there are still some modules that we have to initialize before rendering
    anything with React. Open the `index.js` server file again. At the moment, we
    are serving the `dist` path statically on the root/path for `http://localhost:8000`.
    When moving to SSR, we have to serve the HTML generated by our React application
    at the `/` path instead.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 成功渲染我们的React代码的关键组件现在已经准备好了。然而，还有一些模块在我们使用React渲染任何内容之前必须初始化。再次打开`index.js`服务器文件。目前，我们正在为`http://localhost:8000`根路径上的`dist`路径提供静态服务。当我们转向SSR时，我们必须在`/`路径上提供由我们的React应用程序生成的HTML。
- en: 'Furthermore, any other path, such as `/app`, should also use SSR to render
    those paths on the server. Remove the current `app.get` method at the bottom of
    the file, which is right before the `app.listen` method. Then, insert the following
    code as a replacement:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，任何其他路径，如`/app`，也应该使用SSR在服务器上渲染这些路径。删除文件底部的当前`app.get`方法，该方法位于`app.listen`方法之前。然后，插入以下代码作为替代：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first line of the code should replace the old static route. It introduces
    a new option called `index`, which will disable serving the `index.html` file
    at the root path.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一行应该替换旧的静态路由。它引入了一个名为`index`的新选项，这将禁用在根路径上提供`index.html`文件。
- en: The asterisk (`*`) that we are using in the preceding code can overwrite any
    path that is defined later in the Express.js routing. Always remember that the
    `services` routine that we use in Express.js can implement new paths, such as
    `/graphql`, that we do not want to overwrite. To avoid this, put the code at the
    bottom of the file, below the `services` setup. The route catches any requests
    sent to the backend.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在先前的代码中使用星号 (`*`) 可以覆盖 Express.js 路由中定义的任何路径。始终记住，我们在 Express.js 中使用的 `services`
    例程可以实现新的路径，例如 `/graphql`，我们不希望覆盖。为了避免这种情况，将代码放在文件的底部，在 `services` 设置下方。该路由捕获发送到后端的任何请求。
- en: You can try out this route by running the `npm run server` command. Just visit
    `http://localhost:8000` to do this.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行 `npm run server` 命令来尝试此路由。只需访问 `http://localhost:8000` 即可。
- en: Currently, the preceding catch-all route only returns an empty site, with a
    status of `200`. Let's change this. The logical step would be to load and render
    the `ServerClient` component from the `index.js` file of the `ssr` folder, as
    it is the starting point of the React SSR code. The `ServerClient` component,
    however, requires an initialized Apollo Client instance, as we explained before.
    We are going to create a special Apollo Client instance for SSR next.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，前面的通配符路由仅返回一个空的站点，状态为 `200`。让我们改变这一点。逻辑步骤将是加载并渲染 `ssr` 文件夹中的 `index.js` 文件中的
    `ServerClient` 组件，因为它是 React SSR 代码的起点。然而，`ServerClient` 组件需要一个初始化的 Apollo Client
    实例，正如我们之前解释的那样。我们将为 SSR 创建一个特殊的 Apollo Client 实例。
- en: 'Create a `ssr/apollo.js` file, as it does not exist yet. We will set up Apollo
    Client in this file. The content is nearly the same as the original setup for
    the client:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `ssr/apollo.js` 文件，因为它还不存在。我们将在该文件中设置 Apollo Client。内容几乎与客户端原始设置相同：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'However, there are a few changes that we made to get the client working on
    the server. These changes were pretty big, so we created a separate file for the
    server-side Apollo Client setup. Take a look at the changes (as follows) to understand
    the differences between the frontend and the SSR setup for Apollo Client:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们进行了一些更改，以便在服务器上使客户端工作。这些更改相当大，因此我们为服务器端 Apollo Client 设置创建了一个单独的文件。查看以下更改（如下）以了解前端和
    SSR 设置之间的差异：
- en: Instead of using the `createUploadLink` function that we introduced to allow
    the user to upload images or other files, we are now using the standard `HttpLink`
    class again. You could use the `UploadClient` function, but the functionalities
    it provides won't be used on the server, as the server won't upload files.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不再使用我们之前引入的 `createUploadLink` 函数来允许用户上传图片或其他文件，而是再次使用标准的 `HttpLink` 类。您可以使用
    `UploadClient` 函数，但它在服务器上提供的功能将不会使用，因为服务器不会上传文件。
- en: The `AuthLink` function skips to the next link, as we have not implemented server-side
    authentication yet.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthLink` 函数跳转到下一个链接，因为我们尚未实现服务器端身份验证。'
- en: The `HttpLink` object receives the `fetch` property, which is filled by the
    `node-fetch` package that we installed at the beginning of the chapter. This is
    used instead of the `window.fetch` method, which is not available in Node.js.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpLink` 对象接收 `fetch` 属性，该属性由我们在本章开头安装的 `node-fetch` 包填充。这用于替代在 Node.js 中不可用的
    `window.fetch` 方法。'
- en: Rather than exporting the `client` object directly, we export a wrapping function
    that accepts a `request` object. We pass it as a parameter in the Express.js route.
    As you can see in the preceding code example, we haven't used the object yet,
    but that will change soon.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不是直接导出 `client` 对象，而是导出一个包装函数，它接受一个 `request` 对象。我们将其作为参数传递给 Express.js 路由。如您在先前的代码示例中看到的，我们尚未使用该对象，但很快就会改变。
- en: 'Import the `ApolloClient` component at the top of the server `index.js` file,
    as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器 `index.js` 文件顶部导入 `ApolloClient` 组件，如下所示：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The imported `ApolloClient` function accepts the `request` object of our Express.js
    server.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 导入的 `ApolloClient` 函数接受我们的 Express.js 服务器的 `request` 对象。
- en: 'Add the following line to the top of the new Express.js catch-all route:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的 Express.js 通配符路由顶部添加以下行：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This way, we set up a new `client` instance that we can hand over to our `ServerClient`
    component.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就设置了一个新的 `client` 实例，我们可以将其传递给我们的 `ServerClient` 组件。
- en: 'We can continue and implement the rendering of our `ServerClient` component.
    To make the future code work, we have to load React and, of course, the `ServerClient`
    component itself:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续并实现 `ServerClient` 组件的渲染。为了使未来的代码工作，我们必须加载 React 和当然，`ServerClient` 组件本身：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `ServerClient` component is imported under the `Graphbook` name. We import
    React because we use the standard **JSX** syntax when rendering our React code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServerClient` 组件以 `Graphbook` 的名称导入。我们导入 React 是因为我们使用标准的 **JSX** 语法来渲染我们的
    React 代码。'
- en: 'Now that we have access to Apollo Client and the `ServerClient` component,
    insert the following two lines below the `ApolloClient` setup in the Express.js
    route:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以访问 Apollo Client 和 `ServerClient` 组件，在 Express.js 路由中的 `ApolloClient`
    设置下方插入以下两行代码：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We pass the initialized `client` variable to the `Graphbook` component. We use
    the regular React syntax to pass all properties. Furthermore, we set the `location`
    property to the request object's `url` object, to tell the router which path to
    render. The `context` property is passed as an empty object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将初始化的 `client` 变量传递给 `Graphbook` 组件。我们使用常规的 React 语法传递所有属性。此外，我们将 `location`
    属性设置为请求对象的 `url` 对象，以告诉路由器要渲染哪个路径。`context` 属性被传递为一个空对象。
- en: However, why do we pass an empty object as `context` to the router at the end?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为什么我们在最后将一个空对象作为 `context` 传递给路由器呢？
- en: The reason is that after rendering the `Graphbook` component to HTML, we can
    access the `context` object and see whether a redirect (or something else) would
    have been triggered regularly. As we mentioned before, redirects have to be implemented
    by the backend code. The `StaticRouter` component of React Router does not make
    assumptions about the Node.js web server that you are using. That is why `StaticRouter`
    does not execute them automatically. Tracking and post-processing these events
    is possible with the `context` variable.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是，在将 `Graphbook` 组件渲染成 HTML 之后，我们可以访问 `context` 对象并查看是否通常会触发重定向（或其他操作）。正如我们之前提到的，重定向必须由后端代码实现。React
    Router 的 `StaticRouter` 组件不会对您使用的 Node.js 网络服务器做出假设。这就是为什么 `StaticRouter` 不会自动执行它们。使用
    `context` 变量跟踪和后处理这些事件是可能的。
- en: 'The resulting React object is saved to a new variable, which is called `App`.
    Now, there should be no errors if you start the server with `npm run server` and
    visit `http://localhost:8000`. Still, we see an empty page. That happens because
    we only return an empty HTML page; we haven''t rendered the React `App` object
    to HTML. To render the object to HTML, import the following package at the top
    of the server `index.js` file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 React 对象被保存到一个新的变量中，该变量被命名为 `App`。现在，如果你使用 `npm run server` 启动服务器并访问 `http://localhost:8000`，应该不会出现任何错误。然而，我们仍然看到一个空页面。这是因为我们只返回了一个空的
    HTML 页面；我们还没有将 React 的 `App` 对象渲染成 HTML。要将对象渲染成 HTML，请在服务器 `index.js` 文件的顶部导入以下包：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `react-dom` package not only provides bindings for the browser but also
    provides a special module for the server, which is why we use the `/server` suffix
    when importing it. The returned module provides a number of server-only functions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-dom` 包不仅为浏览器提供了绑定，还提供了一个专门用于服务器的模块，这就是为什么我们在导入它时使用 `/server` 后缀。返回的模块提供了一系列仅适用于服务器的函数。'
- en: Note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To learn some more advanced features of SSR and the dynamics behind it, you
    should read up on the official documentation of the server package of `react-dom`
    at [https://reactjs.org/docs/react-dom-server.html](https://reactjs.org/docs/react-dom-server.html).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解一些更高级的 SSR 特性和其背后的动态，你应该阅读 `react-dom` 服务器包的官方文档，请参阅 [https://reactjs.org/docs/react-dom-server.html](https://reactjs.org/docs/react-dom-server.html)。
- en: 'We can translate the React `App` object into HTML by using the `ReactDOM.rendertoString`
    function. Insert the following line of code beneath the `App` object:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `ReactDOM.rendertoString` 函数将 React 的 `App` 对象转换成 HTML。在 `App` 对象下方插入以下代码行：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This function generates HTML and stores it inside the `content` variable. The
    HTML can be returned to the client now. If you return pre-rendered HTML from the
    server, the client goes through it and checks whether its current state would
    match the returned HTML. The comparison is made by identifying certain points
    in the HTML, such as the `data-reactroot` property.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数生成 HTML 并将其存储在 `content` 变量中。现在可以将 HTML 返回给客户端。如果您从服务器返回预渲染的 HTML，客户端会遍历它并检查其当前状态是否与返回的
    HTML 匹配。比较是通过识别 HTML 中的某些点来进行的，例如 `data-reactroot` 属性。
- en: If, at any point, the markup between the server-rendered HTML and that which
    the client would generate does not match, an error is thrown. The application
    will still work, but the client will not be able to make use of SSR; the client
    will replace the complete markup returned from the server by rendering everything
    again. In this case, the server's HTML response is thrown away. This is, of course,
    very inefficient and not what we are aiming for.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在任何时候，服务器渲染的HTML和客户端将生成的HTML之间的标记不匹配，则会抛出错误。应用程序仍然可以工作，但客户端将无法使用SSR；客户端将用重新渲染的一切替换从服务器返回的完整标记。在这种情况下，服务器的HTML响应被丢弃。这当然是非常低效的，并不是我们想要的结果。
- en: 'We have to return the rendered HTML to the client. The HTML that we have rendered
    begins with the root `div` tag and not the `html` tag. We must wrap the `content`
    variable inside a template that includes the surrounding HTML tags. So, create
    a `template.js` file inside the `ssr` folder, and enter the following code to
    implement the template for our rendered HTML:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将渲染的HTML返回给客户端。我们渲染的HTML以根`div`标签开始，而不是以`html`标签开始。我们必须将`content`变量包裹在一个包含周围HTML标签的模板中。因此，在`ssr`文件夹内创建一个`template.js`文件，并输入以下代码以实现我们渲染的HTML的模板：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code is pretty much the same HTML markup as that in the `index.html`
    file that we usually serve to the client. The difference is that here, we use
    React and `ReactDOM` .
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码基本上与通常提供给客户端的`index.html`文件中的HTML标记相同。区别在于这里我们使用了React和`ReactDOM`。
- en: First, we export a function, which accepts the `content` variable with the rendered
    HTML.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导出一个函数，该函数接受带有渲染后的HTML的`content`变量。
- en: Then, we render a `link` tag inside the `head` tag, which downloads the CSS
    bundle if we are in a production environment. For our current development scenario,
    there is no bundled CSS.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`head`标签内渲染一个`link`标签，如果我们在生产环境中，这个标签会下载CSS包。对于我们的当前开发场景，没有打包的CSS。
- en: The important part is that we use a new `ReactDOM` function called `rendertoStaticMarkup`
    inside the `body` tag. This function inserts the React `root` tag into the body
    of our HTML template. Before, we used the `renderToString` method, which included
    special React tags, such as the `data-reactroot` property. Now, we use the `rendertoStaticMarkup`
    function to generate standard HTML without special React tags. The only parameter
    that we pass to the function is the `div` tag with the `root` ID and a new property,
    `dangerouslySetInnerHTML`. This attribute is a replacement for the regular `innerHTML`
    attribute, but for use in React. It lets React insert the HTML inside the root
    `div` tag. As the name suggests, it is dangerous to do this, but only if it is
    done on the client, as there is no possibility for `ReactDOM.renderToStaticMarkup`
    function to make use of the attribute. The inserted HTML was initially rendered
    with the `renderToString` function so that it would include all of the critical
    React HTML attributes and the wrapping `div` tag with the `root` ID. It can then
    be reused in the browser by the frontend code without any problems.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，我们在`body`标签内使用了一个新的`ReactDOM`函数，名为`rendertoStaticMarkup`。这个函数将React的`root`标签插入到我们的HTML模板的body中。之前，我们使用的是`renderToString`方法，它包含了特殊的React标签，例如`data-reactroot`属性。现在，我们使用`rendertoStaticMarkup`函数生成没有特殊React标签的标准HTML。我们传递给函数的唯一参数是带有`root`
    ID的`div`标签和一个新属性`dangerouslySetInnerHTML`。这个属性是常规`innerHTML`属性的替代品，但用于React。它允许React在根`div`标签内插入HTML。正如其名所示，这样做是有风险的，但只有在客户端这样做时才有风险，因为`ReactDOM.renderToStaticMarkup`函数无法使用这个属性。插入的HTML最初是用`renderToString`函数渲染的，以便包含所有的关键React
    HTML属性和带有`root` ID的包装`div`标签。然后，它可以在浏览器中被前端代码无问题地重用。
- en: 'We require this `template.js` file in the server `index` file, at the top of
    the file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在服务器`index`文件中引入这个`template.js`文件，文件顶部如下：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The template function can now be used directly in the `res.send` method, as
    follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 模板函数现在可以直接在`res.send`方法中使用，如下所示：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We do not only return a `doctype` object anymore; we also respond with the return
    value of the `template` function. As you should see, the `template` function accepts
    the rendered `content` variable as a parameter and composes it to a valid HTML
    document.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不仅返回一个`doctype`对象，还响应`template`函数的返回值。正如您应该看到的，`template`函数接受作为参数的渲染后的`content`变量并将其组合成一个有效的HTML文档。
- en: At this point, we have managed to get our first version of a server-side-rendered
    React application working. You can prove this by right-clicking in your browser
    window and choosing to view the source code. The window shows you the original
    HTML that is returned by the server. The output equals the HTML from the `template`
    function, including the login and signup forms.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经成功使我们的第一个服务器端渲染的React应用程序版本工作。你可以通过在浏览器窗口中右键单击并选择查看源代码来证明这一点。窗口显示服务器返回的原始HTML。输出等于`template`函数的HTML，包括登录和注册表单。
- en: 'Nevertheless, there are two problems that we face:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们面临两个问题：
- en: There is no description meta `head` tag included in the server response. Something
    must have gone wrong with React `Helmet`.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器响应中没有包含描述性meta `head`标签。React `Helmet`肯定出了些问题。
- en: When logged in on the client side and, for example, viewing the news feed under
    the `/app` path, the server responds without having rendered the news feed or
    the login form. Normally, React Router would have redirected us to the login form
    since we are not logged in on the server side. However, since we use `StaticRouter`,
    we have to initiate the redirect separately, as we explained before. We are going
    to implement the authentication in a separate step.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在客户端登录，例如在`/app`路径下查看新闻源时，服务器响应没有渲染新闻源或登录表单。通常，React Router会重定向我们到登录表单，因为我们没有在服务器端登录。然而，由于我们使用了`StaticRouter`，我们必须单独发起重定向，正如我们之前解释的那样。我们将分步骤实现身份验证。
- en: 'We will start with the first issue. To fix the problem with React `Helmet`,
    import it at the top of the server `index.js` file, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从第一个问题开始。要修复React `Helmet`的问题，在服务器`index.js`文件的顶部导入它，如下所示：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, before setting the response status with `res.status`, you can extract
    the React `Helmet` status, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在设置响应状态`res.status`之前，你可以提取React `Helmet`的状态，如下所示：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `renderStatic` method is specially made for SSR. We can use it after having
    rendered the React application with the `renderToString` function. It gives us
    all of the `head` tags that would have been inserted throughout our code. Pass
    this `head` variable to the `template` function as a second parameter, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderStatic`方法专门用于SSR。我们可以在使用`renderToString`函数渲染React应用程序后使用它。它给我们提供了在整个代码中插入的所有`head`标签。将这个`head`变量作为第二个参数传递给`template`函数，如下所示：'
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Go back to the `template.js` file from the `ssr` folder. Add the `head` parameter
    to the exported function''s signature. Then, add the following two new lines of
    code to the HTML''s `head` tag:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到`ssr`文件夹中的`template.js`文件。将`head`参数添加到导出函数的签名中。然后，在HTML的`head`标签中添加以下两行新代码：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `head` variable extracted from React `Helmet` holds a property for each
    `meta` tag. These tags provide a `toString` function that returns a valid HTML
    tag, which you can directly enter into the document''s `head` object. The first
    problem should be fixed: all `head` tags are now inside the server''s HTML response.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从React `Helmet`提取的`head`变量为每个`meta`标签都持有属性。这些标签提供了一个`toString`函数，它返回一个有效的HTML标签，你可以直接将其输入到文档的`head`对象中。第一个问题应该得到修复：现在所有的`head`标签都包含在服务器的HTML响应中。
- en: Let's focus on the second problem. The server response returns an empty React
    `root` tag when visiting a `PrivateRoute` component. As we explained previously,
    the reason for this is that the naturally initiated redirect does not get through
    to us, as we are using `StaticRouter`. We are redirected away from the `PrivateRoute`
    component because the authentication is not implemented for the server-side-rendered
    code. The first thing to fix is to handle the redirect, and we should also at
    least respond with the login form, instead of an empty React `root` tag. Later,
    we need to fix the authentication problem.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于第二个问题。当访问`PrivateRoute`组件时，服务器响应返回一个空的React `root`标签。正如我们之前解释的那样，这是因为自然发起的重定向没有到达我们这里，因为我们使用了`StaticRouter`。由于服务器端渲染的代码没有实现身份验证，所以我们被重定向离开了`PrivateRoute`组件。首先需要修复的是处理重定向，我们至少应该响应登录表单，而不是一个空的React
    `root`标签。稍后，我们需要修复身份验证问题。
- en: You would not notice this problem without viewing the source code of the server's
    response. The frontend downloads the `bundle.js` file and triggers the rendering
    on its own, as it knows about the authentication status of the user. The user
    would not notice that. Still, it is more efficient if the server sends the correct
    HTML directly. The HTML will be wrong if the user is logged in, but in the case
    of an unauthenticated user, the login form is pre-rendered by the server as it
    initiates the redirects.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不查看服务器响应的源代码，你不会注意到这个问题。前端下载`bundle.js`文件并自行触发渲染，因为它知道用户的身份验证状态。用户不会注意到这一点。然而，如果服务器直接发送正确的HTML，这将更加高效。如果用户已登录，HTML将是错误的，但在未认证用户的情况下，登录表单是由服务器预先渲染的，因为它启动了重定向。
- en: 'To fix this issue, we can access the `context` object that has been filled
    by React Router after it has used the `renderToString` function. The final Express.js
    route should look like the following code example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以在React Router使用`renderToString`函数后访问已经被填充的`context`对象。最终的Express.js路由应该看起来像以下代码示例：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The condition for rendering the correct route on the server is that we inspect
    the `context.url` property. If it is filled, we can initiate a redirect with Express.js.
    This will navigate the browser to the correct path. If the property is not filled,
    we can return the HTML generated by React.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上渲染正确路由的条件是检查`context.url`属性。如果它被填充，我们可以使用Express.js启动重定向。这将导航浏览器到正确的路径。如果属性没有被填充，我们可以返回React生成的HTML。
- en: This route renders the React code correctly up to the point at which authentication
    is required. The SSR route correctly renders all public routes, but none of the
    secure routes. That means that we only respond with the login form at the moment,
    as it is the only route that doesn't require authentication.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此路由正确渲染了React代码，直到需要身份验证的点。SSR路由正确渲染了所有公共路由，但没有渲染任何安全路由。这意味着我们现在只响应登录表单，因为它是唯一不需要身份验证的路由。
- en: The next step is to implement authentication in connection with SSR to fix this
    huge issue.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在与SSR结合的情况下实现身份验证，以解决这个问题。
- en: Authentication with SSR
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SSR进行身份验证
- en: You should have noticed that we have removed most of the authentication logic
    from the server-side React code. The reason for this is that `localStorage` cannot
    be transmitted to the server on the initial loading of a page, which is the only
    case where SSR can be used at all. This leads to the problem that we cannot render
    the correct route because we cannot verify whether a user is logged in. The authentication
    has to be transitioned to cookies, which are sent with every request.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经注意到，我们已经从服务器端的React代码中移除了大部分身份验证逻辑。这样做的原因是`localStorage`不能在页面初始加载时传输到服务器，这是SSR可以使用的唯一情况。这导致的问题是我们不能渲染正确的路由，因为我们不能验证用户是否已登录。身份验证必须转移到与每个请求一起发送的cookies上。
- en: It is important to understand that cookies also introduce some security issues.
    We will continue to use the regular HTTP authorization header for the GraphQL
    API that we have written. If we use cookies for the GraphQL API, we will expose
    our application to potential **cross-site request forgery** (**CSRF**) attacks.
    The frontend code continues to send all GraphQL requests with the HTTP authorization
    header.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，cookies也会引入一些安全问题。我们将继续使用我们编写的GraphQL API的常规HTTP授权头。如果我们为GraphQL API使用cookies，我们将使我们的应用程序容易受到潜在的**跨站请求伪造**（**CSRF**）攻击。前端代码继续使用HTTP授权头发送所有GraphQL请求。
- en: We will only use the cookies to verify the authentication status of a user and
    to initiate requests to our GraphQL API for the SSR of the React code. The SSR
    GraphQL requests will include the authorization cookie's value in the HTTP authorization
    header. Our GraphQL API only reads and verifies this header and does not accept
    cookies. As long as you do not mutate data when loading a page and only query
    for the data to render, there will be no security issues.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只使用cookies来验证用户的身份验证状态，并初始化对我们的GraphQL API的SSR请求。SSR GraphQL请求将在HTTP授权头中包含授权cookie的值。我们的GraphQL
    API只读取和验证这个头，不接受cookies。只要你在加载页面时没有修改数据，并且只查询要渲染的数据，就不会存在安全问题。
- en: Tip
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: As the topic of CSRF and XSS is important, I recommend that you read up on it
    in order to fully understand how to protect yourself and your users. You can find
    a great article at [https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CSRF和XSS是一个重要的主题，我建议你阅读相关内容，以便全面了解如何保护自己和用户。你可以在[https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF))找到一篇优秀的文章。
- en: 'So, just follow these instructions to get authentcation on SSR running:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只需按照以下说明来在SSR上实现身份验证：
- en: 'The first thing to do is install a new package with `npm`, as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首件事是使用`npm`安装一个新的包，如下所示：
- en: '[PRE25]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Import the `cookies` and `jwt` packages, and also extract the `JWT_SECRET`
    string from the environment variables at the top of the server `index.js` file:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`cookies`和`jwt`包，并从服务器`index.js`文件顶部的环境变量中提取`JWT_SECRET`字符串：
- en: '[PRE26]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To use the `cookies` package, we are going to set up a new middleware route.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要使用`cookies`包，我们需要设置一个新的中间件路由。
- en: 'Insert the following code before initializing the webpack modules and the services
    routine:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化webpack模块和服务流程之前插入以下代码：
- en: '[PRE27]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This new Express.js middleware initializes the `cookies` package under the `req.cookies`
    property for every request that it processes. The first parameter of the `Cookies`
    constructor is the request, the second is the response object, and the last is
    an `options` parameter. This takes an array of `keys` with which the cookies are
    signed. The keys are required if you want to sign your cookies for security reasons.
    You should take care of this in a production environment. You can also specify
    a `secure` property, which ensures that the cookies are only transmitted on secure
    HTTPS connections.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个新的Express.js中间件为它处理的每个请求在`req.cookies`属性下初始化`cookies`包。`Cookies`构造函数的第一个参数是请求，第二个是响应对象，最后一个是一个`options`参数。这个参数接受一个`keys`数组，用于对cookies进行签名。如果你出于安全原因想要对cookies进行签名，则这些键是必需的。在生产环境中，你应该注意这一点。你也可以指定一个`secure`属性，这确保了cookies只会在安全的HTTPS连接上传输。
- en: 'We can now extract the `authorization` cookie and verify the authentication
    of the user. To do this, replace the beginning of the SSR route with the following
    code in the server''s `index.js` file:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以提取`authorization`cookie并验证用户的身份验证。为此，将服务器`index.js`文件中SSR路由的开始部分替换为以下代码：
- en: '[PRE28]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, I have added the `async` declaration to the callback function because
    we use the `await` statement inside it. The second step is to extract the `authorization`
    cookie from the request object with `req.cookies.get`. Importantly, we specify
    the `signed` field in the `options` parameter, because only then will it successfully
    return the signed cookies.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我已将`async`声明添加到回调函数中，因为我们在这个函数内部使用了`await`语句。第二步是从请求对象中提取`authorization`cookie，使用`req.cookies.get`。重要的是，我们在`options`参数中指定了`signed`字段，因为只有这样它才能成功返回签名的cookies。
- en: The extracted value represents the JWT that we generate when a user logs in.
    We can verify this with the typical approach that we implemented in [*Chapter
    6*](B17337_06_Final_ASB_ePub.xhtml#_idTextAnchor141), *Authentication with Apollo
    and React*. That is, we use the `await` statement when verifying the JWT. If an
    error is thrown, the user is not logged in. The state is saved in the `loggedIn`
    variable.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提取的值代表我们在用户登录时生成的JWT。我们可以通过我们在[*第6章*](B17337_06_Final_ASB_ePub.xhtml#_idTextAnchor141)中实现的典型方法来验证它，即*使用Apollo和React进行身份验证*。也就是说，我们在验证JWT时使用`await`语句。如果抛出错误，则用户未登录。状态保存在`loggedIn`变量中。
- en: 'Pass the `loggedIn` variable to the `Graphbook` component, as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`loggedIn`变量传递给`Graphbook`组件，如下所示：
- en: '[PRE29]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, we can access the `loggedIn` property inside `index.js` from the `ssr`
    folder.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以从`ssr`文件夹中的`index.js`文件访问`loggedIn`属性。
- en: 'Extract the `loggedIn` state from the properties, and pass it to the `App`
    component in the `ssr` folder''s `index.js` file, as follows:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从属性中提取`loggedIn`状态，并将其传递给`ssr`文件夹的`index.js`文件中的`App`组件，如下所示：
- en: '[PRE30]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Inside the `App` component, we do not need to set the `loggedIn` state directly
    to `false`, but we can take the property's value because it is determined before
    the `App` component is rendered. This flow is different from the client procedure,
    where the `loggedIn` state is determined inside the `App` component.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`App`组件内部，我们不需要直接将`loggedIn`状态设置为`false`，但我们可以获取属性值，因为它在`App`组件渲染之前就已经确定了。这种流程与客户端流程不同，在客户端流程中，`loggedIn`状态是在`App`组件内部确定的。
- en: 'Change the `App` component in the `app.js` file in order to match the following
    code:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`app.js`文件中的`App`组件，以匹配以下代码：
- en: '[PRE31]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, the result is that we pass down the `loggedIn` value from our Express.js
    route, over the `Graphbook` and `App` components, to our `Router` component. This
    already accepts the `loggedIn` property in order to render the correct path for
    the user. At the moment, we still do not set the cookie on the backend when a
    user successfully logs in.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，结果是我们将`loggedIn`值从我们的Express.js路由传递到`Graphbook`和`App`组件，再到我们的`Router`组件。这已经接受`loggedIn`属性以渲染用户的正确路径。目前，我们还没有在用户成功登录时在后端设置cookie。
- en: 'Open the `resolvers.js` file of our GraphQL server to fix that. We will change
    a few lines for the `login` and `signup` functions. Both resolver functions need
    the same changes, as both set the authentication token after login or signup.
    So, insert the following code directly above the return statement:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们的GraphQL服务器的`resolvers.js`文件以修复此问题。我们将为`login`和`signup`函数更改几行。由于两个解析函数在登录或注册后都需要设置认证令牌，因此它们需要相同的更改。所以，直接在返回语句上方插入以下代码：
- en: '[PRE32]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding function sets the cookies for the user''s browser. The context
    object is only the Express.js `request` object where we have initialized the cookies
    package. The properties of the `cookies.set` function are pretty self-explanatory,
    but let''s describe them as follows:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述函数为用户的浏览器设置cookie。上下文对象仅是Express.js的`request`对象，其中我们初始化了cookies包。`cookies.set`函数的属性相当直观，但让我们如下描述它们：
- en: a. The `signed` field specifies whether the keys entered during the initialization
    of the `cookies` object should be used to sign the cookie's value.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. `signed`字段指定在初始化`cookies`对象时输入的密钥是否应该用于签名cookie的值。
- en: 'b. The `expires` property takes a `date` object. It represents the time until
    which the cookie is valid. You can set the property to whatever date you want,
    but I would recommend a short period, such as one day. Insert the following code
    above the `context.cookies.set` statement in order to initialize the `expirationDate`
    variable correctly:'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. `expires`属性接受一个`date`对象。它表示cookie有效的截止时间。您可以设置属性为任何您想要的日期，但我建议设置一个较短的时间，例如一天。在`context.cookies.set`语句上方插入以下代码，以正确初始化`expirationDate`变量：
- en: '[PRE33]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: c. The `httpOnly` field secures the cookie so that it is not accessible by client-side
    JavaScript.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. `httpOnly`字段确保cookie不会被客户端JavaScript访问。
- en: d. The `secure` property has the same meaning as it did when initializing the
    `Cookie` package. It restricts cookies to SSL connections only. This is a must
    when going to production, but it cannot be used when developing, as most developers
    develop locally, without an SSL certificate.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. `secure`属性与初始化`Cookie`包时的含义相同。它将cookie限制为仅SSL连接。在上线时这是必须的，但在开发时不能使用，因为大多数开发者都是在本地开发，没有SSL证书。
- en: e. The `sameSite` field takes either `strict` or `lax` as a value. I recommend
    setting it to `strict`, as you want your GraphQL API or server to receive the
    cookie with every request, but you also want to exclude all cross-site requests,
    as this could be dangerous.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: e. `sameSite`字段可以取`strict`或`lax`作为值。我建议将其设置为`strict`，因为您希望您的GraphQL API或服务器在每次请求时都接收cookie，但您也希望排除所有跨站请求，因为这可能是危险的。
- en: Now, we should clean up our code. Since we are using cookies, we can remove
    the `localStorage` authentication flow in the frontend code. Open the `App.js`
    file in the `client` folder. Remove the `componentWillMount` method, as we are
    reading from `localStorage` there.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该清理我们的代码。由于我们正在使用cookies，我们可以从前端代码中移除`localStorage`认证流程。在`client`文件夹中打开`App.js`文件。移除`componentWillMount`方法，因为我们从`localStorage`中读取数据。
- en: The cookies are automatically sent with any request, and they do not need a
    separate binding as `localStorage` does. That also means that we need a special
    `logout` mutation that removes the cookie from the browser. JavaScript is not
    able to access or remove the cookie because we specified it as `httpOnly`. Only
    the server can delete it from the client.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: cookies会自动与任何请求一起发送，并且不需要像`localStorage`那样的单独绑定。这也意味着我们需要一个特殊的`logout`突变来从浏览器中删除cookie。JavaScript无法访问或删除cookie，因为我们将其指定为`httpOnly`。只有服务器才能从客户端删除它。
- en: 'Create a new `logout.js` file inside the `mutations` folder in order to create
    a `logout` mutation Hook. The content should look like the following:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mutations`文件夹内创建一个新的`logout.js`文件，以便创建一个`logout`突变钩子。内容应如下所示：
- en: '[PRE34]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding Hook only sends a simple `logout` mutation, without any parameters
    or further logic.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前的功能钩子仅发送一个简单的 `logout` 变异，没有任何参数或进一步逻辑。
- en: 'We should use the function inside the `logout.js` file of the `bar` folder
    in order to send the GraphQL request. Import the component at the top of the file,
    as follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该使用 `bar` 文件夹中 `logout.js` 文件内的函数来发送 GraphQL 请求。在文件顶部导入组件，如下所示：
- en: '[PRE35]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Replace the `logout` method with the following code, in order to send the mutation
    upon clicking the `logoutMutation` function. This sends the GraphQL request to
    our server.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `logout` 方法替换为以下代码，以便在点击 `logoutMutation` 函数时发送变异。这会将 GraphQL 请求发送到我们的服务器。
- en: 'To implement the mutation on the backend, add one line to the GraphQL `RootMutation`
    type, inside `schema.js`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在 `schema.js` 中的 GraphQL `RootMutation` 类型上实现变异，请向后台添加一行代码：
- en: '[PRE36]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It's required that the user that's trying to log out is authorized, so we use
    the `@auth` directive.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要确保尝试注销的用户已被授权，因此我们使用 `@auth` 指令。
- en: 'The corresponding resolver function is as follows. Add it to the `resolvers.js`
    file in the `RootMutation` property:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相应的解析函数如下。将其添加到 `resolvers.js` 文件中的 `RootMutation` 属性：
- en: '[PRE37]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The resolver function is minimal. It removes the cookie by setting the expiration
    date to the current time. This removes the cookie on the client when the browser
    receives the response because it is expired at that point. This behavior is an
    advantage in comparison to `localStorage`.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解析函数是最小的。它通过将过期日期设置为当前时间来删除cookie。当浏览器收到响应时，由于此时已过期，它会在客户端删除cookie。与 `localStorage`
    相比，这种行为是一个优点。
- en: We have completed everything to make the authorization work with SSR. It is
    a very complex task, since authorization, SSR, and CSR have effects on the whole
    application. Every framework out there has its own approach to implementing this
    feature, so please take a look at them too.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了所有工作，使授权与 SSR 一起工作。这是一个非常复杂的任务，因为授权、SSR 和 CSR 对整个应用程序都有影响。每个框架都有自己的方法来实现这个功能，所以请也查看它们。
- en: If you look at the source code returned from our server after the rendering,
    you should see that the login form is returned correctly, as it was before. Furthermore,
    the server now recognizes whether the user is logged in. However, the server does
    not yet return the rendered news feed, the application bar, or the chats. Only
    a loading message is included in the returned HTML. The client-side code also
    does not recognize that the user is logged in. We will take a look at these problems
    in the next section.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看渲染后从我们的服务器返回的源代码，您应该看到登录表单被正确返回，就像之前一样。此外，服务器现在能够识别用户是否已登录。然而，服务器尚未返回渲染的新闻源、应用栏或聊天。返回的
    HTML 中只包含一个加载消息。客户端代码也没有识别出用户已登录。我们将在下一节中查看这些问题。
- en: Running Apollo queries with SSR
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SSR 运行 Apollo 查询
- en: By nature, GraphQL queries via `HttpLink` are asynchronous. We have implemented
    a `loading` component to show the user a loading message while the data is being
    fetched.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本质，GraphQL 查询通过 `HttpLink` 是异步的。我们已经实现了一个 `loading` 组件，在数据正在获取时向用户显示加载消息。
- en: This is the same thing that is happening while rendering our React code on the
    server. All of the routing is evaluated, including whether we are logged in. If
    the correct route is found, all GraphQL requests are sent. The problem is that
    the first rendering of React returns the loading state, which is sent to the client
    by our server. The server does not wait until the GraphQL queries are finished
    and it has received all of the responses to render our React code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在服务器上渲染 React 代码时发生的情况相同。所有路由都被评估，包括我们是否已登录。如果找到正确的路由，所有 GraphQL 请求都会发送。问题是第一次渲染
    React 返回加载状态，由我们的服务器发送到客户端。服务器不会等待 GraphQL 查询完成并收到所有响应，然后渲染我们的 React 代码。
- en: 'We will fix this problem now. The following is a list of things that we have
    to do:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将解决这个问题。以下是我们必须做的事情列表：
- en: We need to implement authentication for the SSR Apollo Client instance. We already
    did this for the routing, but now, we need to pass the cookie to the server-side
    GraphQL request too.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要实现 SSR Apollo 客户端实例的认证。我们已经在路由中做到了这一点，但现在，我们需要将cookie传递到服务器端的 GraphQL 请求中。
- en: We need to use a React Apollo-specific method to render the React code asynchronously
    in order to wait for all responses of the GraphQL requests.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要使用 React Apollo 特定的方法来异步渲染 React 代码，以便等待所有 GraphQL 请求的响应。
- en: Importantly, we need to return the Apollo cache state to the client. Otherwise,
    the client will re-fetch everything, as its state is empty upon the first load
    of the page.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要的是，我们需要将Apollo缓存状态返回给客户端。否则，客户端将重新获取所有内容，因为它的状态在页面首次加载时是空的。
- en: 'Let''s get started, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧，如下所示：
- en: 'The first step is to pass the `loggedIn` variable from the Express.js SSR route
    to the `ApolloClient` function as a second parameter. Change the `ApolloClient`
    call inside the server''s `index.js` file to the following line of code:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是将Express.js SSR路由中的`loggedIn`变量传递给`ApolloClient`函数作为第二个参数。将服务器`index.js`文件中的`ApolloClient`调用修改为以下代码：
- en: '[PRE38]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Change the signature of the exported function from the `apollo.js` file to also
    include this second parameter.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将从`apollo.js`文件导出的函数的签名修改为也包括这个第二个参数。
- en: 'Replace the `AuthLink` function inside the Apollo Client''s setup for SSR with
    the following code:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换Apollo Client设置中的`AuthLink`函数：
- en: '[PRE39]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This `AuthLink` adds the cookies to the GraphQL requests by using the `request`
    object given by Express.js. The `request` object already holds the initialized
    cookies package, which we use to extract the authorization cookie. This only needs
    to be done if the user has been verified as logged in previously.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个`AuthLink`通过使用Express.js提供的`request`对象将cookie添加到GraphQL请求中。`request`对象已经包含了初始化的cookie包，我们使用它来提取授权cookie。这只有在用户之前已经验证为登录状态时才需要执行。
- en: 'Import a new function from the Apollo package inside the server''s `index.js`
    file. Replace the import of the `ReactDOM` package with the following line of
    code:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器的`index.js`文件中导入Apollo包中的一个新函数。用以下代码替换对`ReactDOM`包的导入：
- en: '[PRE40]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Originally, we used the `ReactDOM` server methods to render the React code
    to HTML. These functions are synchronous; that is why the GraphQL request did
    not finish. To wait for all GraphQL requests, replace all of the lines – beginning
    from the `rendertoString` function until the end of the SSR route inside the server''s
    `index.js` file. The result should look as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最初，我们使用`ReactDOM`服务器方法将React代码渲染为HTML。这些函数是同步的；这就是为什么GraphQL请求没有完成。为了等待所有GraphQL请求，替换服务器`index.js`文件中从`rendertoString`函数开始直到SSR路由结束的所有行。结果应该如下所示：
- en: '[PRE41]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `renderToStringWithData` function renders the React code, including the
    data received by the Apollo requests. Since the method is asynchronous, we wrap
    the rest of our code inside a callback function.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`renderToStringWithData`函数渲染React代码，包括通过Apollo请求接收到的数据。由于该方法异步，我们将其余代码包裹在一个回调函数中。'
- en: Now, if you take a look at the HTML returned by your server, you should see
    the correct markup, including chats, images, and everything else. The problem
    is that the client does not know that all of the HTML is already there and can
    be reused. The client would re-render everything.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，如果你查看服务器返回的HTML，你应该看到正确的标记，包括聊天、图片以及其他所有内容。问题是客户端不知道所有的HTML已经存在并且可以被重用。客户端将重新渲染一切。
- en: 'To let the client reuse the HTML that our server sends, we have to include
    Apollo Client''s state with our response. Inside the preceding callback, access
    Apollo Client''s state by inserting the following code:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让客户端能够重用我们服务器发送的HTML，我们必须将Apollo Client的状态包含在我们的响应中。在先前的回调函数内部，通过插入以下代码来访问Apollo
    Client的状态：
- en: '[PRE42]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `client.extract` method returns a big object, holding all cache information
    that the client has stored after using the `renderToStringWithData` function.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`client.extract`方法返回一个包含客户端使用`renderToStringWithData`函数后存储的所有缓存信息的大对象。'
- en: 'The state must be passed to the `template` function as a third parameter. So,
    change the `res.send` call to the following:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态必须作为第三个参数传递给`template`函数。因此，将`res.send`调用修改为以下代码：
- en: '[PRE43]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Inside the `template.js` file, extend the function declaration and append the
    `state` variable as a third parameter, after the `head` variable.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`template.js`文件中，扩展函数声明并在`head`变量之后追加`state`变量作为第三个参数。
- en: 'Insert the `state` variable, with the following line of code, inside the HTML
    body and above the `bundle.js` file. If you add it below the `bundle.js` file,
    it won''t work correctly:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML body中`bundle.js`文件上方插入`state`变量，使用以下代码。如果你将它添加到`bundle.js`文件下方，它将无法正确工作：
- en: '[PRE44]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We use the `renderToStaticMarkup` function to insert another `script` tag. It
    sets a large, stringified JSON object as Apollo Client's starting cache value.
    The JSON object holds all of the results of the GraphQL requests returned while
    rendering our server-side React application. We directly store the JSON object
    as a string in a new field inside the `window` object. The `window` object is
    helpful since you can directly access the field globally.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用`renderToStaticMarkup`函数插入另一个`script`标签。它将一个大型、字符串化的JSON对象设置为Apollo Client的起始缓存值。该JSON对象包含在渲染我们的服务器端React应用程序时返回的所有GraphQL请求的结果。我们直接将JSON对象作为字符串存储在`window`对象的新字段中。`window`对象很有用，因为您可以直接全局访问该字段。
- en: 'Apollo has to know about the state variable. It can be used by Apollo Client
    to initialize its cache with the specified data, instead of having to send all
    of the GraphQL requests again. Open the `index.js` file from the client''s `apollo`
    folder. The last property of the initialization process is the cache. We need
    to set our `__APOLLO_STATE__` instance as the starting value of the cache. Replace
    the `cache` property with the following code:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Apollo必须了解状态变量。它可以被Apollo Client用来用指定数据初始化其缓存，而不是必须再次发送所有GraphQL请求。打开客户端`apollo`文件夹中的`index.js`文件。初始化过程的最后一个属性是缓存。我们需要将我们的`__APOLLO_STATE__`实例设置为缓存的起始值。将`cache`属性替换为以下代码：
- en: '[PRE45]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We create the `InMemoryCache` instance and run its `restore` method, where we
    insert the value from the window object. Apollo Client should recreate its cache
    from this variable.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们创建了`InMemoryCache`实例并运行其`restore`方法，其中我们插入来自窗口对象的价值。Apollo Client应该从该变量重新创建其缓存。
- en: We have now set up the cache for Apollo. It will no longer run unnecessary requests
    for which the results already exist. Now, we can finally reuse the HTML, with
    one last change. We have to change `ReactDOM.render` to `ReactDOM.hydrate` in
    the client's `index.js` file. The difference between these functions is that React
    reuses the HTML if it was correctly rendered by our server. In this case, React
    only attaches some necessary event listeners. If you use the `ReactDOM.render`
    method, it dramatically slows down the initial rendering process, as it compares
    the initial DOM with the current DOM and may change it accordingly.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经为Apollo设置了缓存。它将不再运行已经存在结果的不必要请求。现在，我们最终可以重用HTML，只需进行最后一次更改。我们必须在客户端的`index.js`文件中将`ReactDOM.render`更改为`ReactDOM.hydrate`。这两个函数之间的区别在于，如果我们的服务器正确渲染了HTML，React会重用该HTML。在这种情况下，React仅附加一些必要的事件监听器。如果您使用`ReactDOM.render`方法，它将显著减慢初始渲染过程，因为它会将初始DOM与当前DOM进行比较，并根据需要进行更改。
- en: The last problem that we have is that the client-side code does not show the
    logged-in state of our application after refreshing a page. The server returns
    the correct markup with all the data, but the frontend redirects us to the login
    form. The reason for this is that we statically set the `loggedIn` state variable
    to `false` in the `App.js` file of the client-side code.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到最后一个问题是客户端代码在刷新页面后不显示应用程序的登录状态。服务器返回了包含所有数据的正确标记，但前端将我们重定向到登录表单。这是因为我们在客户端代码的`App.js`文件中静态地将`loggedIn`状态变量设置为`false`。
- en: 'The best way to check whether the user is authenticated is to verify whether
    the `__APOLLO_STATE__` field on the window object is filled and has a `currentUser`
    object attached. If that is the case, we can assume that the user was able to
    fetch their own data record, so they must be logged in. To change our `App.js`
    file accordingly, add the following condition to the `loggedIn` state variable:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 检查用户是否认证的最佳方式是验证窗口对象上的`__APOLLO_STATE__`字段是否被填充并且附加了一个`currentUser`对象。如果是这样，我们可以假设用户能够检索到自己的数据记录，所以他们必须已经登录。为了相应地更改我们的`App.js`文件，向`loggedIn`状态变量添加以下条件：
- en: '[PRE46]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As you can see in the preceding code, we verify whether the Apollo starting
    cache variable includes a `ROOT_QUERY` property with the `currentUser` subfield
    . The `ROOT_QUERY` property is filled if any query can be fetched successfully.
    The `currentUser` field is only filled if the authenticated user was successfully
    requested.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码中所见，我们验证Apollo启动缓存变量是否包含一个带有`currentUser`子字段的`ROOT_QUERY`属性。如果任何查询可以成功检索，则`ROOT_QUERY`属性会被填充。只有当认证用户成功请求时，`currentUser`字段才会被填充。
- en: If you execute `npm run server`, you will see that everything now works perfectly.
    Take a look at the markup that's returned; you will see either the login form
    or, when logged in, all of the content of the page that you are visiting. You
    can log in on the client, the news feed is fetched dynamically, you can refresh
    the page, and all of the posts are directly there, without the need for a single
    GraphQL request, as the server returned the data side by side with the HTML. This
    works not only for the `/app` path but for any path that you implement.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行`npm run server`，你会看到现在一切运行得非常完美。看看返回的标记；你会看到登录表单，或者当你登录时，你访问的页面的全部内容。你可以在客户端登录，新闻源会动态获取，你可以刷新页面，所有的帖子都会直接显示，无需进行单个GraphQL请求，因为服务器已经将数据与HTML一起返回。这不仅适用于`/app`路径，也适用于你实现的任何路径。
- en: We are now finished with the SSR setup.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了SSR的设置。
- en: So far, we have only looked at the developmental part of SSR. When we get to
    the point where we want to make a production build and publish our application,
    there are a few other things that we will have to consider, which we will look
    at in [*Chapter 12*](B17337_12_Final_ASB_ePub.xhtml#_idTextAnchor204), *Continuous
    Deployment with CircleCI and AWS*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看了SSR的开发部分。当我们到达想要制作生产构建并发布我们的应用的时候，我们还需要考虑一些其他的事情，这些内容我们将在[*第12章*](B17337_12_Final_ASB_ePub.xhtml#_idTextAnchor204)，*使用CircleCI和AWS进行持续部署*中探讨。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we changed a lot of the code that we have programmed so far.
    You learned the advantages and disadvantages of offering SSR. The main principles
    behind React Router, Apollo, and authentication with cookies while using SSR should
    be clear by now. It takes a lot of work to get SSR running, and it needs to be
    managed with every change made to your application. Nevertheless, it has excellent
    performance and user experience benefits for your users.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们修改了我们迄今为止编写的大量代码。你学习了提供SSR的优势和劣势。React Router、Apollo以及使用SSR进行cookie认证的主要原则现在应该已经很清晰了。要让SSR运行起来需要做很多工作，并且需要管理你应用中每一次的更改。尽管如此，它为你的用户提供了卓越的性能和用户体验优势。
- en: In the next chapter, we will look at how to offer real-time updates through
    **Apollo Subscriptions**, instead of using the old and inefficient polling approach.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何通过**Apollo Subscriptions**提供实时更新，而不是使用旧的和低效的轮询方法。
