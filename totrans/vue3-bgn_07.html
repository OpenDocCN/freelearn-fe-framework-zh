<html><head></head><body>
		<div id="_idContainer076">
			<h1 id="_idParaDest-81" class="chapter-number"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.2.1">Handling API Data and Managing Async Components with Vue.js</span></h1>
			<p><span class="koboSpan" id="kobo.3.1">In </span><a href="B21130_06.xhtml#_idTextAnchor074"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.5.1">, we focused on how components can communicate with each other with the use of properties, which are used for parent-to-child communications and events to handle messages sent from a child to </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">a parent.</span></span></p>
			<p><span class="koboSpan" id="kobo.7.1">In this chapter, we will stay on the topic of communication by showing how to communicate with an external source, such as an API. </span><span class="koboSpan" id="kobo.7.2">External communication is a very common method when developing a dynamic website that cannot make use of static data, and learning how to manage asynchronous operations will not only result in a clean user experience but also help keep the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">application performant.</span></span></p>
			<p><span class="koboSpan" id="kobo.9.1">Loading data from an external source such as an API makes data handling more complicated. </span><span class="koboSpan" id="kobo.9.2">In fact, when the data is hardcoded, we do not have to worry about anything, as the information is immediately available, while when working with data that comes from an external source, we need to not only think about the empty state that the app will be while the data is loaded but also consider the possibility of the data failing </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">to load.</span></span></p>
			<p><span class="koboSpan" id="kobo.11.1">We will start the chapter by removing the hardcoded posts and loading them dynamically; we will then do the same with the comments by making the data on-demand. </span><span class="koboSpan" id="kobo.11.2">We will then enhance our application to automatically load more posts, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.12.1">watch</span></strong><span class="koboSpan" id="kobo.13.1">. </span><span class="koboSpan" id="kobo.13.2">Finally, we will learn how to define and use asynchronous components </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.15.1">&lt;Suspense&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.17.1">The chapter will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">following topics:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.19.1">Loading data from an API using the Vue.js </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">life cycle</span></span></li>
				<li><span class="koboSpan" id="kobo.21.1">Watching for changes in components using </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.22.1">watch </span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">functions</span></span></li>
				<li><span class="koboSpan" id="kobo.24.1">Handling asynchronous components </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">with Suspense</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.26.1">By the end of the chapter, you will have learned how to load data and components dynamically. </span><span class="koboSpan" id="kobo.26.2">You will know how to create components that load data on demand and what benefits this brings to our application. </span><span class="koboSpan" id="kobo.26.3">You will also be able to handle side effects using </span><strong class="source-inline"><span class="koboSpan" id="kobo.27.1">watch</span></strong><span class="koboSpan" id="kobo.28.1"> and, finally, define and take care of asynchronous components to ensure your application is </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">rendered correctly.</span></span></p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.30.1">Technical requirements</span></h1>
			<p><span class="koboSpan" id="kobo.31.1">In this chapter, the branch is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.32.1">CH07</span></strong><span class="koboSpan" id="kobo.33.1">. </span><span class="koboSpan" id="kobo.33.2">To pull this branch, run the following command or use your GUI of choice to support you in </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">this operation:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.35.1">
Git switch CH07.</span></pre>
			<p><span class="koboSpan" id="kobo.36.1">As part of this chapter, we are also going to use an external resource called Dummyapi.io. </span><span class="koboSpan" id="kobo.36.2">This website will provide a dummy API that we will use to load our post dynamically. </span><span class="koboSpan" id="kobo.36.3">To be able to use the API, you need to register and generate an </span><strong class="old"><span class="koboSpan" id="kobo.37.1">APP ID</span></strong><span class="koboSpan" id="kobo.38.1">. </span><span class="koboSpan" id="kobo.38.2">Creating an </span><strong class="old"><span class="koboSpan" id="kobo.39.1">APP ID</span></strong><span class="koboSpan" id="kobo.40.1"> is completely free and can be obtained by creating an account on the following </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">link (</span></span><a href="https://dummyapi.io/sign-in"><span class="No-Break"><span class="koboSpan" id="kobo.42.1">https://dummyapi.io/sign-in</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.43.1">).</span></span></p>
			<p><span class="koboSpan" id="kobo.44.1">This new branch, </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">CH07</span></strong><span class="koboSpan" id="kobo.46.1">, includes just a couple of style changes and the replacement of the native button with the custom button component that we created in the last </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">chapter, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">TheButton.vue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.50.1">The code files for the chapter can be found at </span><a href="https://github.com/PacktPublishing/Vue.js-3-for-Beginners"><span class="koboSpan" id="kobo.51.1">https://github.com/PacktPublishing/Vue.js-3-for-Beginners</span></a><span class="koboSpan" id="kobo.52.1">. </span></p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.53.1">Loading data from an API using the Vue.js life cycle</span></h1>
			<p><span class="koboSpan" id="kobo.54.1">It is common for most of the</span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.55.1"> applications that are built for the web to expose a level of dynamic content. </span><span class="koboSpan" id="kobo.55.2">Providing the ability to load information on the fly has been one of the most important factors that led to the growth of JavaScript</span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.56.1"> frameworks, such </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">as Vue.js.</span></span></p>
			<p><span class="koboSpan" id="kobo.58.1">Until now, the Companion App has been built using static data that is loaded directly within the components. </span><span class="koboSpan" id="kobo.58.2">Hardcoded values are not very common in real applications, and the posts and comments used within the application were just a stopgap to help us focus on the basic features of Vue.js, but it is now time to learn how to load </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">data dynamically.</span></span></p>
			<p><span class="koboSpan" id="kobo.60.1">Being able to successfully handle asynchronous data load is very important. </span><span class="koboSpan" id="kobo.60.2">No matter how big or small your next application will be, it is very likely that you will be required to handle </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">external data.</span></span></p>
			<p><span class="koboSpan" id="kobo.62.1">In this section, we are going to update two parts of our application. </span><span class="koboSpan" id="kobo.62.2">First, we are going to update </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">SocialPosts.vue</span></strong><span class="koboSpan" id="kobo.64.1"> to load the post from an external source, and then we are going to change </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">SocialPostComments.vue</span></strong><span class="koboSpan" id="kobo.66.1"> to also load comments dynamically but with a little twist, as we</span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.67.1"> will implement something called “loading data</span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.68.1"> on demand.” </span><span class="koboSpan" id="kobo.68.2">We will then briefly discuss the implications that dynamic loading can have on performance and the user experience of </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">our application.</span></span></p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.70.1">Loading social posts from an API</span></h2>
			<p><span class="koboSpan" id="kobo.71.1">Until now, the posts that our application</span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.72.1"> displayed were always the same due to the hardcoded array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">posts </span></strong><span class="koboSpan" id="kobo.74.1">defined in </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">SocialPosts.vue</span></strong><span class="koboSpan" id="kobo.76.1">. </span><span class="koboSpan" id="kobo.76.2">In this section, we are</span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.77.1"> going to use a public API offered by </span><strong class="old"><span class="koboSpan" id="kobo.78.1">DummyAPI </span></strong><span class="koboSpan" id="kobo.79.1">(</span><a href="https://dummyapi.io/"><span class="koboSpan" id="kobo.80.1">https://dummyapi.io/</span></a><span class="koboSpan" id="kobo.81.1">) to make our </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">post dynamic.</span></span></p>
			<p><span class="koboSpan" id="kobo.83.1">Services such as </span><strong class="old"><span class="koboSpan" id="kobo.84.1">DummyAPI</span></strong><span class="koboSpan" id="kobo.85.1"> are very useful to develop application scaffolding and to help you practice your skills. </span><span class="koboSpan" id="kobo.85.2">There are plenty</span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.86.1"> of free services like this one available on the internet, and they can easily be found using a </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">search engine.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.88.1">Research is part of development</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.89.1">Spend a couple of minutes navigating through the </span><strong class="old"><span class="koboSpan" id="kobo.90.1">DummyAPI </span></strong><span class="koboSpan" id="kobo.91.1">website and try to understand how we will use the API and what endpoints we will use. </span><span class="koboSpan" id="kobo.91.2">Learning external resources is a very important part of </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">web development.</span></span></p>
			<p><span class="koboSpan" id="kobo.93.1">Loading external data will be achieved using Vue.js methods, the native Fetch API, and Vue.js life cycles. </span><span class="koboSpan" id="kobo.93.2">First, we are going to remove the old, hardcoded data from </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">SocialPosts.vue</span></strong><span class="koboSpan" id="kobo.95.1">. </span><span class="koboSpan" id="kobo.95.2">This file can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">molecules</span></strong><span class="koboSpan" id="kobo.97.1"> folder, as it is a component that renders a big section of our Companion </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">App homepage:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.99.1">
const posts = reactive(</span><strong class="old"><span class="koboSpan" id="kobo.100.1">[]</span></strong><span class="koboSpan" id="kobo.101.1">);</span></pre>
			<p><span class="koboSpan" id="kobo.102.1">Then, in the same file, we are going to create a method that calls the external API to fetch our </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">new posts:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.104.1">
const fetchPosts = () =&gt; {
  const baseUrl = "https://dummyapi.io/data/v1";
  fetch(`${baseUrl}/post?limit=5`, {
    "headers": {
      "app-id": "1234567890"
    }
  })
    .then( response =&gt; response.json())
    .then( result =&gt; {
      posts.push(...result.data);
    })
}</span></pre>
			<p><span class="koboSpan" id="kobo.105.1">The preceding code uses the native JavaScript </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">fetch</span></strong><span class="koboSpan" id="kobo.107.1"> method (</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"><span class="koboSpan" id="kobo.108.1">https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API</span></a><span class="koboSpan" id="kobo.109.1">) to send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">GET </span></strong><span class="koboSpan" id="kobo.111.1">request to the </span><a href="http://dummyapi.io"><span class="koboSpan" id="kobo.112.1">dummyapi.io</span></a><span class="koboSpan" id="kobo.113.1"> API. </span><span class="koboSpan" id="kobo.113.2">Due to the API requirements, we need to pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">app-id</span></strong><span class="koboSpan" id="kobo.115.1"> with the request. </span><span class="koboSpan" id="kobo.115.2">This can be obtained for</span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.116.1"> free, as mentioned in the </span><em class="italic"><span class="koboSpan" id="kobo.117.1">Technical </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.118.1">requirements</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.119.1"> section.</span></span></p>
			<p><span class="koboSpan" id="kobo.120.1">We then fetch the result in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">json</span></strong><span class="koboSpan" id="kobo.122.1"> format using </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">response.json()</span></strong><span class="koboSpan" id="kobo.124.1"> and, finally, append the returned data to </span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.125.1">the post’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">Reactive </span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">property.</span></span></p>
			<p><span class="koboSpan" id="kobo.128.1">After the method has been defined, it is time to “call” it. </span><span class="koboSpan" id="kobo.128.2">When triggering an </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">async</span></strong><span class="koboSpan" id="kobo.130.1"> request like in this case, we take advantage of the Vue.js life cycle to ensure that our request is triggered at the </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">correct time.</span></span></p>
			<p><span class="koboSpan" id="kobo.132.1">In </span><a href="B21130_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.133.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.134.1">, we introduced the different life cycles and mentioned that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">created</span></strong><span class="koboSpan" id="kobo.136.1"> life cycle is the correct one for asynchronous data. </span><span class="koboSpan" id="kobo.136.2">Our description of it was </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">as follows:</span></span></p>
			<p class="author-quote"><span class="koboSpan" id="kobo.138.1">“[The </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">created</span></strong><span class="koboSpan" id="kobo.140.1"> life cycle] is the perfect stage to trigger asynchronous calls to gather some data. </span><span class="koboSpan" id="kobo.140.2">Triggering slow requests now will help us save some time, as this request will continue behind the scenes while our component is being rendered.”</span></p>
			<p><span class="koboSpan" id="kobo.141.1">Let’s go and call our newly created method, </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">fetchPosts</span></strong><span class="koboSpan" id="kobo.143.1">, during the created life cycle. </span><span class="koboSpan" id="kobo.143.2">In contrast to other life cycles </span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.144.1">such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">mounted</span></strong><span class="koboSpan" id="kobo.146.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">created</span></strong><span class="koboSpan" id="kobo.148.1"> does not need to be explicitly defined. </span><span class="koboSpan" id="kobo.148.2">The explanation from the official documentation is </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">as follows:</span></span></p>
			<p class="author-quote"><span class="koboSpan" id="kobo.150.1">“Because </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">setup</span></strong><span class="koboSpan" id="kobo.152.1"> is run around the </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">beforeCreate</span></strong><span class="koboSpan" id="kobo.154.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">created</span></strong><span class="koboSpan" id="kobo.156.1"> lifecycle hooks, you do not need to explicitly define them. </span><span class="koboSpan" id="kobo.156.2">In other words, any code that would be written inside those hooks should be written directly in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">setup</span></strong><span class="koboSpan" id="kobo.158.1"> function.”</span></p>
			<p><span class="koboSpan" id="kobo.159.1">This simplifies our requirement, meaning that all we need to do is call the method after it is defined within the body of </span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.160.1">our component’s </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">JavaScript logic:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.162.1">
const posts = reactive([]);
const fetchPosts = () =&gt; {
   ...
</span><span class="koboSpan" id="kobo.162.2">}
</span><strong class="old"><span class="koboSpan" id="kobo.163.1">fetchPosts();</span></strong></pre>
			<p><span class="koboSpan" id="kobo.164.1">At this stage, our posts should be dynamically loaded from the API, but the work is not done yet; in fact, the application displays the </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">posts incorrectly:</span></span></p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<span class="koboSpan" id="kobo.166.1"><img src="image/B21130_07_01.jpg" alt="Figure 7.1: The Companion App displaying a broken UI"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.167.1">Figure 7.1: The Companion App displaying a broken UI</span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.168.1">What caused the preceding error?</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.169.1">Before reading the answer, why don’t you try to investigate what could have caused the issue with the rendering displayed in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.170.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.171.1">.1</span></em><span class="koboSpan" id="kobo.172.1">? </span><span class="koboSpan" id="kobo.172.2">How would you go about </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">fixing it?</span></span></p>
			<p><span class="koboSpan" id="kobo.174.1">The data fetched by the API is</span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.175.1"> loaded and applied to our “posts” successfully, but the structure of the data does not match the one that we previously had set. </span><span class="koboSpan" id="kobo.175.2">This </span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.176.1">problem is related to the advanced properties settings that we just learned about in the </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">previous chapter.</span></span></p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.178.1">Fixing the SocialPost.vue properties’ misalignment</span></h2>
			<p><span class="koboSpan" id="kobo.179.1">Misaligned props are something that is very common in real applications, but they can be avoided. </span><span class="koboSpan" id="kobo.179.2">In fact, the reason why</span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.180.1"> the app is rendering a broken UI is that we have not specified which properties are expected to be “required” in </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">SocialPost.vue</span></strong><span class="koboSpan" id="kobo.182.1">, and as a result, Vue.js tries to render the app with the data it has, resulting in the missing data being set </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">null</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.186.1">Let’s compare the previous hardcoded structure of the posts array with the new structure received by the API to see how the two structures compare and what changes are required to ensure the Companion App can correctly render the </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">post information:</span></span></p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<span class="koboSpan" id="kobo.188.1"><img src="image/B21130_07_02_BW.jpg" alt="Figure 7.2: The transition between the previous structure of posts and the new one provided by the API"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.189.1">Figure 7.2: The transition between the previous structure of posts and the new one provided by the API</span></p>
			<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.190.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.191.1">.2</span></em><span class="koboSpan" id="kobo.192.1"> displays the</span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.193.1"> changes we are going to make in our application to align with the new data. </span><span class="koboSpan" id="kobo.193.2">Some of the fields need to change to match the new object properties, and comments and retweets have been removed altogether. </span><span class="koboSpan" id="kobo.193.3">Calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">&lt;SocialPost&gt;</span></strong><span class="koboSpan" id="kobo.195.1"> component will now be changed to </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">the following:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.197.1">
&lt;SocialPost
  v-for="(post, index) in posts"
  :username="post</span><strong class="old"><span class="koboSpan" id="kobo.198.1">.owner.firstName</span></strong><span class="koboSpan" id="kobo.199.1">"
  </span><strong class="old"><span class="koboSpan" id="kobo.200.1">:id</span></strong><span class="koboSpan" id="kobo.201.1">="post</span><strong class="old"><span class="koboSpan" id="kobo.202.1">.id</span></strong><span class="koboSpan" id="kobo.203.1">"
  :avatarSrc="post</span><strong class="old"><span class="koboSpan" id="kobo.204.1">.image</span></strong><span class="koboSpan" id="kobo.205.1">"
  :post="post</span><strong class="old"><span class="koboSpan" id="kobo.206.1">.text</span></strong><span class="koboSpan" id="kobo.207.1">"
  :likes="post.likes"
  :key="post</span><strong class="old"><span class="koboSpan" id="kobo.208.1">.id</span></strong><span class="koboSpan" id="kobo.209.1">"
  @delete="onDelete(index)"
&gt;&lt;/SocialPost&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.210.1">The preceding highlighted code shows the difference between the old and new component instances. </span><span class="koboSpan" id="kobo.210.2">Note that we had to replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">userId</span></strong><span class="koboSpan" id="kobo.212.1"> with just </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">id</span></strong><span class="koboSpan" id="kobo.214.1">, which will be required later. </span><span class="koboSpan" id="kobo.214.2">It is now time to</span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.215.1"> modify the child component to make sure it can function with the new data. </span><span class="koboSpan" id="kobo.215.2">This will involve a couple </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">of steps:</span></span></p>
			<ol>
				<li><span class="koboSpan" id="kobo.217.1">Remove </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">UserId</span></strong><span class="koboSpan" id="kobo.219.1"> from the UI, as it is </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">too long:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.221.1">
&lt;div class="name"&gt;{{ username }}&lt;/div&gt;</span></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.222.1">&lt;div class="userId"&gt;{{ userId }}&lt;/div&gt;</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.223.1">
&lt;IconDelete @click="onDeleteClick" /&gt;</span></pre></li>
				<li><span class="koboSpan" id="kobo.224.1">Remove </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">comments</span></strong><span class="koboSpan" id="kobo.226.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">retweets</span></strong><span class="koboSpan" id="kobo.228.1"> from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">props</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.230.1"> declaration:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.231.1">
const props = defineProps({</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.232.1">
  username: String,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.233.1">
  userId: Number,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.234.1">
  avatarSrc: String,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.235.1">
  post: String,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.236.1">
  likes: Number,</span></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.237.1">  comments: Array,</span></strong></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.238.1">  retweets: Number</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.239.1">
});</span></pre></li>
				<li><span class="koboSpan" id="kobo.240.1">Refactor </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">interactions</span></strong><span class="koboSpan" id="kobo.242.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">commentsNumber</span></strong><span class="koboSpan" id="kobo.244.1"> from the UI and replace them with </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">just </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">likes</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.248.1">
&lt;div class="interactions"&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.249.1">
  &lt;IconHeart /&gt;</span></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.250.1">  {{ interactions }}</span></strong></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.251.1">  &lt;IconCommunity /&gt;</span></strong></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.252.1">  {{ commentsNumber }}</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.253.1">
  </span><strong class="old"><span class="koboSpan" id="kobo.254.1">{{ likes }}</span></strong></pre></li>
				<li><span class="koboSpan" id="kobo.255.1">Remove the logic associated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">interactions</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.257.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">commentsNumber</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">:</span></span><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.260.1">const commentsNumber = computed( () =&gt; {</span></strong></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.261.1">  return props.comments.length;</span></strong></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.262.1">});</span></strong></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.263.1">const interactions = computed( ()=&gt; {</span></strong></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.264.1">  const comments = props.comments.length;</span></strong></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.265.1">  console.log(comments, props.likes, props.retweets);</span></strong></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.266.1">  return comments + props.likes + props.retweets;</span></strong></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.267.1">});</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.268.1">Remove the condition</span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.269.1"> attached to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">Show </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">comment</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.272.1"> button:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.273.1">
&lt;TheButton</span></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.274.1">  v-show="hasComments"</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.275.1">
  @click="onShowCommentClick"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.276.1">
  value="Show comment"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.277.1">
  width="auto"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.278.1">
  theme="dark"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.279.1">
/&gt;</span></pre></li>
			</ol>
			<p><span class="koboSpan" id="kobo.280.1">The preceding changes may seem quite complicated when reading them out, but they follow a logical pattern. </span><span class="koboSpan" id="kobo.280.2">They are all connected to each other, a modification in one component may result in a change in another and so on. </span><span class="koboSpan" id="kobo.280.3">For example, removing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">retweet</span></strong><span class="koboSpan" id="kobo.282.1"> props in the parent would then result in the props being removed from the child component within </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">defineProps</span></strong><span class="koboSpan" id="kobo.284.1">, and consequently, the removal of any code logic attached to those props, and finally, any use of the props in the </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">component template.</span></span></p>
			<p><span class="koboSpan" id="kobo.286.1">As you get more familiar with the framework, the preceding changes will feel trivial, but I have added them here and covered them step by step on purpose to give you some idea of how to logically think </span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.287.1">about a component and its </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">data flow.</span></span></p>
			<p><span class="koboSpan" id="kobo.289.1">At this stage, the application should render correctly, and the home page should display posts coming from the dummy API we </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">have implemented:</span></span></p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<span class="koboSpan" id="kobo.291.1"><img src="image/B21130_07_03.jpg" alt="Figure 7.3: The Companion App displaying posts from the external API"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.292.1">Figure 7.3: The Companion App displaying posts from the external API</span></p>
			<p><span class="koboSpan" id="kobo.293.1">The Companion App displays the post correctly again, but something is still missing. </span><span class="koboSpan" id="kobo.293.2">The logic that was used to display the comment does not work </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">correctly anymore.</span></span></p>
			<p><span class="koboSpan" id="kobo.295.1">Before we move forward, you should improve the component that we just made to make it more reliable, by improving </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">its properties.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.297.1">Your turn – improve the properties set in SocialPost.vue</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.298.1">Spend a few minutes to enhance the</span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.299.1"> props set in </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">SocialPost.vue</span></strong><span class="koboSpan" id="kobo.301.1">. </span><span class="koboSpan" id="kobo.301.2">Look at each props and decide if they should be required, by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">required</span></strong><span class="koboSpan" id="kobo.303.1"> attribute on props or if they could be set to optional by defining a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">default </span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">value.</span></span></p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.306.1">Load comments on demand</span></h2>
			<p><span class="koboSpan" id="kobo.307.1">When the </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">posts</span></strong><span class="koboSpan" id="kobo.309.1"> data was hardcoded, the comments associated with the individual post were available on the first render, and we were able to pass them immediately between the parent and child components. </span><span class="koboSpan" id="kobo.309.2">But now that the information is loaded dynamically, we can change</span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.310.1"> our logic to just load the comments </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">on demand.</span></span></p>
			<p><span class="koboSpan" id="kobo.312.1">Imagine an application where all the data is loaded on the main page and has to be passed around between tens of components. </span><span class="koboSpan" id="kobo.312.2">No matter how hard you would work, the code would be quite hard to maintain. </span><span class="koboSpan" id="kobo.312.3">Passing properties through many layers of components is known in the industry as “</span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">props drilling.”</span></span></p>
			<p><span class="koboSpan" id="kobo.314.1">Props drilling can be avoided</span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.315.1"> using </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">two techniques:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.317.1">Loading data </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">on demand</span></span></li>
				<li><span class="koboSpan" id="kobo.319.1">Using </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">state management</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.321.1">In this chapter, we are going to cover the first technique, loading data on demand, while state management will be covered later in </span><a href="B21130_11.xhtml#_idTextAnchor153"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.322.1">Chapter 11</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.323.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.324.1">Making a change like the one we just performed prevents some data from being loaded immediately, with it just being fetched on demand. </span><span class="koboSpan" id="kobo.324.2">This is a very good practice to improve both performance and </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">code structure.</span></span></p>
			<p><span class="koboSpan" id="kobo.326.1">When analyzing how comments behave in our application, we can see that it would be quite wasteful to load all comments associated with the posts immediately, when we know that the application will just display them on user interaction (a </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">button click).</span></span></p>
			<p><span class="koboSpan" id="kobo.328.1">We are going to work on two files. </span><span class="koboSpan" id="kobo.328.2">First, we are going to replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">comments </span></strong><span class="koboSpan" id="kobo.330.1">property from </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">SocialPost.vue</span></strong><span class="koboSpan" id="kobo.332.1"> with the post ID. </span><span class="koboSpan" id="kobo.332.2">Then, we will create the functionality required to load the comments on demand </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">SocialPostComments.vue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.336.1">At this point, you should have enough knowledge to remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">comments</span></strong><span class="koboSpan" id="kobo.338.1"> property from the component and replace it with another property, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">post-id</span></strong><span class="koboSpan" id="kobo.340.1">. </span><span class="koboSpan" id="kobo.340.2">This will be used later to request the correct comments from the dummy API, and the code changes should be </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">the following:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.342.1">
&lt;SocialPostComments
  v-if="showComments"
</span><strong class="old"><span class="koboSpan" id="kobo.343.1">  </span></strong><strong class="old"><span class="koboSpan" id="kobo.344.1">:comments="comments"</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.345.1">  :post-id="id"</span></strong><span class="koboSpan" id="kobo.346.1">
  @delete="onDeleted"
/&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.347.1">Because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">comments</span></strong><span class="koboSpan" id="kobo.349.1"> property was already removed from </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">defineProps</span></strong><span class="koboSpan" id="kobo.351.1"> in the previous section of this chapter, all that </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.352.1">was left to do was to ensure that we removed the prop from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">&lt;SocialPostComments&gt;</span></strong><span class="koboSpan" id="kobo.354.1"> component declaration and replaced it with one </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">post-id</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.358.1">The next step requires us to rewrite the logic that handles the load of the comments. </span><span class="koboSpan" id="kobo.358.2">We will start by modifying the properties, by removing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">comments</span></strong><span class="koboSpan" id="kobo.360.1"> one and replacing it with the newly </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">passed </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">post-id</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.364.1">
&lt;script setup &gt;
  import IconDeleteVue from '../icons/IconDelete.vue';
  const props = defineProps({
    </span><strong class="old"><span class="koboSpan" id="kobo.365.1">comments: Array,</span></strong><span class="koboSpan" id="kobo.366.1">
    </span><strong class="old"><span class="koboSpan" id="kobo.367.1">postId: String</span></strong><span class="koboSpan" id="kobo.368.1">
  })
&lt;/script&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.369.1">The ID of the post is required for us to be able to fetch the correct comments from the API. </span><span class="koboSpan" id="kobo.369.2">It is very common when passing IDs around to prefix them with the actual context. </span><span class="koboSpan" id="kobo.369.3">So, in our case, instead of naming our prop ID, we named it  </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">postId.</span></strong><span class="koboSpan" id="kobo.371.1"> Small improvements such as this can really help keep your code clean </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">and readable.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.373.1">Defining multiword props using kebab case</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.374.1">Did you notice that the property we just defined is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">postId</span></strong><span class="koboSpan" id="kobo.376.1"> in the component declaration but is passed in the component using kebab case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">post-id</span></strong><span class="koboSpan" id="kobo.378.1">? </span><span class="koboSpan" id="kobo.378.2">HTML is not case-sensitive, so using </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">postId</span></strong><span class="koboSpan" id="kobo.380.1"> would just </span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.381.1">mean the same as </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">postid</span></strong><span class="koboSpan" id="kobo.383.1">. </span><span class="koboSpan" id="kobo.383.2">Therefore, to ensure that we better define the multiword props, we use kebab case – that </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">is, “word-word.”</span></span></p>
			<p><span class="koboSpan" id="kobo.385.1">It is now time to make the necessary changes to ensure that  </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">SocialPostComments.vue</span></strong><span class="koboSpan" id="kobo.387.1"> works correctly with the new posts structure and create the logic required to load the comments </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">on demand.</span></span></p>
			<p><span class="koboSpan" id="kobo.389.1">We are going to use the following path from the API, </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">/post/{postId}/comment</span></strong><span class="koboSpan" id="kobo.391.1">. </span><span class="koboSpan" id="kobo.391.2">This is going to return us the </span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.392.1">comment from a given </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">postId</span></strong><span class="koboSpan" id="kobo.394.1">, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">postId</span></strong><span class="koboSpan" id="kobo.396.1"> is the actual ID of the </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">post selected.</span></span></p>
			<p><span class="koboSpan" id="kobo.398.1">Let’s break down all the </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">changes required:</span></span></p>
			<ol>
				<li><span class="koboSpan" id="kobo.400.1">First, we import </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">reactive</span></strong><span class="koboSpan" id="kobo.402.1">from </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">vue </span></strong><span class="koboSpan" id="kobo.404.1">and use it to define a new array </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">comments</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">:</span></span><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.408.1">import { reactive } from 'vue';</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.409.1">
const props = defineProps({</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.410.1">
  postId: String</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.411.1">
});</span></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.412.1">const comments = reactive([]);</span></strong></pre></li>
				<li><span class="koboSpan" id="kobo.413.1">Second, we create a new method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">fetchComments</span></strong><span class="koboSpan" id="kobo.415.1"> that accepts a parameter </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">postId</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">:</span></span><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.419.1">const fetchComments = (postId) =&gt; {  }</span></strong></pre></li>
				<li><span class="koboSpan" id="kobo.420.1">Next, we create a fetch request in the body of the newly created method and use </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">postId</span></strong><span class="koboSpan" id="kobo.422.1"> to create the correct request URL. </span><span class="koboSpan" id="kobo.422.2">Just like before, we make sure to pass the </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">correct </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">app-id</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">:</span></span><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.426.1">const fetchComments = (postId) =&gt; {</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.427.1">
  </span><strong class="old"><span class="koboSpan" id="kobo.428.1">const baseUrl = "https://dummyapi.io/data/v1";</span></strong></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.429.1">  fetch(`${baseUrl}/post/${postId}/comment?limit=5`,</span></strong></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.430.1">  {</span></strong></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.431.1">    "headers": {</span></strong></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.432.1">      "app-id": "1234567890"</span></strong></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.433.1">    }</span></strong></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.434.1">  });</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.435.1">
}</span></pre></li>
				<li><span class="koboSpan" id="kobo.436.1">Then, we fetch the response JSON and assign it to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">comments</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.438.1"> reactive:</span></span><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.439.1">fetch(...)</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.440.1">
  </span><strong class="old"><span class="koboSpan" id="kobo.441.1">.then( response =&gt; response.json())</span></strong></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.442.1">  .then( result =&gt; {</span></strong></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.443.1">    Object.assign(comments, result.data);</span></strong></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.444.1">})</span></strong></pre></li>
				<li><span class="koboSpan" id="kobo.445.1">Finally, we call this function when the component loads. </span><span class="koboSpan" id="kobo.445.2">As mentioned before, calling a function within the script </span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.446.1">setup body is equivalent to calling it on the created life cycle. </span><span class="koboSpan" id="kobo.446.2">The function will receive the </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">postId</span></strong><span class="koboSpan" id="kobo.448.1"> property as </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">its argument:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.450.1">
const fetchComments = (postId) =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.451.1">
  ...</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.452.1">
};</span></pre><pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.453.1">fetchComments(props.postId);</span></strong></pre></li>
			</ol>
			<p><span class="koboSpan" id="kobo.454.1">At this stage, our Companion App will render the </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">comments</span></strong><span class="koboSpan" id="kobo.456.1"> body that is currently received from the </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">API request:</span></span></p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<span class="koboSpan" id="kobo.458.1"><img src="image/B21130_07_04.jpg" alt="Figure 7.4: The comments body displayed in the Companion App"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.459.1">Figure 7.4: The comments body displayed in the Companion App</span></p>
			<p><span class="koboSpan" id="kobo.460.1">From the screenshot displayed in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.461.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.462.1">.4</span></em><span class="koboSpan" id="kobo.463.1">, we can deduce that there are two main changes that we need to implement in </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">the component:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.465.1">Improve the UI when </span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.466.1">no comments </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">are available</span></span></li>
				<li><span class="koboSpan" id="kobo.468.1">Format the body of the comments to just show the author’s name and the message, instead of the raw object received by </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">the API</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.470.1">To improve the user experience and show a different message if there is a post with no comments, we can use the built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">v-if</span></strong><span class="koboSpan" id="kobo.472.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">v-else</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.474.1"> directives:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.475.1">
&lt;template v-if="comments.length === 0"&gt;&lt;/template&gt;
&lt;template v-else&gt;&lt;/template&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.476.1">Just like a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">if</span></strong><span class="koboSpan" id="kobo.478.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">else</span></strong><span class="koboSpan" id="kobo.480.1"> statement, when a Vue.js component receives elements that include a </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">v-if</span></strong><span class="koboSpan" id="kobo.482.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">v-else</span></strong><span class="koboSpan" id="kobo.484.1"> directives, it will just render one of the two, depending on the condition received. </span><span class="koboSpan" id="kobo.484.2">In our case, the first block will be rendered if the comments array is empty and has a length</span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.485.1"> of zero, while the second block will render if comments </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">are available.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.487.1">Use &lt;template&gt; to avoid unused HTML elements</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.488.1">You may have noticed that we used an element called </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">&lt;template&gt;</span></strong><span class="koboSpan" id="kobo.490.1"> when introducing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">v-if</span></strong><span class="koboSpan" id="kobo.492.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">v-else</span></strong><span class="koboSpan" id="kobo.494.1"> code block. </span><span class="koboSpan" id="kobo.494.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">&lt;template&gt;</span></strong><span class="koboSpan" id="kobo.496.1"> element is a special Vue.js element that allows you to add logic without the </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.497.1">need to add an HTML element. </span><span class="koboSpan" id="kobo.497.2">In fact, if the template element was not available, we would have had to add </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">&lt;span&gt;</span></strong><span class="koboSpan" id="kobo.499.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">&lt;div&gt;</span></strong><span class="koboSpan" id="kobo.501.1"> just to allow us to add our logic. </span><span class="koboSpan" id="kobo.501.2">Every time you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">&lt;template&gt;</span></strong><span class="koboSpan" id="kobo.503.1"> element, it will disappear and will not render anything within the DOM. </span><span class="koboSpan" id="kobo.503.2">It is very useful in logic that uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">v-if</span></strong><span class="koboSpan" id="kobo.505.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">v-else</span></strong><span class="koboSpan" id="kobo.507.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">v-if-else</span></strong><span class="koboSpan" id="kobo.509.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">v-for</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.513.1">Let’s fill in the code blocks that we just created with the correct HTML. </span><span class="koboSpan" id="kobo.513.2">The first block will just show a static message for the empty state, while for the second, we need to analyze the object received by the API and understand what we want </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">to display.</span></span></p>
			<p><span class="koboSpan" id="kobo.515.1">It is now time to focus on the structure of the comments. </span><span class="koboSpan" id="kobo.515.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">comment</span></strong><span class="koboSpan" id="kobo.517.1"> object seems to include multiple properties, but the only ones we should use are the name of the user and the message, therefore </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">owner.firstName</span></strong><span class="koboSpan" id="kobo.519.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">message</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">, respectively:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.522.1">
&lt;template v-if="comments.</span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">length</span></strong><span class="koboSpan" id="kobo.524.1"> === 0"&gt;
  </span><strong class="old"><span class="koboSpan" id="kobo.525.1">There are no comments for this post!</span></strong><span class="koboSpan" id="kobo.526.1">
&lt;/template&gt;
&lt;template v-else&gt;
  </span><strong class="old"><span class="koboSpan" id="kobo.527.1">&lt;p&gt;Comments:&lt;/p&gt;</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.528.1">  &lt;div v-for="{owner, message} in comments" class="comment"&gt;</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.529.1">    &lt;p&gt;{{ owner.firstName }}: &lt;strong&gt;{{ message }}&lt;/strong&gt;&lt;/p&gt;</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.530.1">  &lt;/div&gt;</span></strong><span class="koboSpan" id="kobo.531.1">
&lt;/template&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.532.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">v-if</span></strong><span class="koboSpan" id="kobo.534.1"> statement includes a simple static message, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">v-else</span></strong><span class="koboSpan" id="kobo.536.1"> contains a loop created using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">v-for</span></strong><span class="koboSpan" id="kobo.538.1"> directives, </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">&lt;div v-for="{owner, message} in comments" class="comment"&gt;</span></strong><span class="koboSpan" id="kobo.540.1">, that includes two mustache templates to format our string, </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">&lt;p&gt;{{ owner.firstName }}: &lt;strong&gt;{{ </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">message }}&lt;/strong&gt;&lt;/p&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.544.1">After the latest modification, our</span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.545.1"> Companion App should display</span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.546.1"> a nicely formatted layout for </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">our comments.</span></span></p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<span class="koboSpan" id="kobo.548.1"><img src="image/B21130_07_05.jpg" alt="Figure 7.5: The Companion App’s formatted comments"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.549.1">Figure 7.5: The Companion App’s formatted comments</span></p>
			<p><span class="koboSpan" id="kobo.550.1">In this section, we learned how to load information asynchronously using an external API; we then walked through the changes necessary to ensure our application can work with the new dynamic data. </span><span class="koboSpan" id="kobo.550.2">The section also included a few tips to help you improve your Vue.js skills, such as the use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">&lt;template&gt;</span></strong><span class="koboSpan" id="kobo.552.1"> to keep the HTML clean, the need to declare multi-word properties with kebab case, and the defining good properties to ensure that our components will not render incorrectly if any of the values </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">are missing.</span></span></p>
			<p><span class="koboSpan" id="kobo.554.1">In the next section, we are going to learn how to trigger side effects, such as API requests, when watching for components’ </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">data changes.</span></span></p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.556.1">Watching for changes in components using watch</span></h1>
			<p><span class="koboSpan" id="kobo.557.1">In the previous section, we learned how to load our data dynamically by triggering an API request during the component</span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.558.1"> rendering cycle. </span><span class="koboSpan" id="kobo.558.2">In this section, we will see another aspect of asynchronous data loading by describing how to handle API requests, triggered as a side effect when watching for </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">data changes.</span></span></p>
			<p><span class="koboSpan" id="kobo.560.1">As we learned in </span><a href="B21130_05.xhtml#_idTextAnchor060"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.561.1">Chapter 5</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.562.1">,</span></em><span class="koboSpan" id="kobo.563.1"> computed properties are a great asset to watch other properties and internal data to create new variables, but they are not handy when we need to trigger a side effect, such as a DOM change or an </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">API call.</span></span></p>
			<p><span class="koboSpan" id="kobo.565.1">This is where a Vue.js feature called </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">watch</span></strong><span class="koboSpan" id="kobo.567.1"> comes to the rescue. </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">watch</span></strong><span class="koboSpan" id="kobo.569.1">, just like </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">computed</span></strong><span class="koboSpan" id="kobo.571.1">, allows you to listen to any changes that occur to properties, reactive data, or another computed property, but it also provides you the ability to trigger a callback when </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">data changes.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.573.1">watch is just for edge cases, not everyday use</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.574.1">If you find yourself using </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">watch</span></strong><span class="koboSpan" id="kobo.576.1"> often during your development, it means that </span><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.577.1">you are using </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">methods</span></strong><span class="koboSpan" id="kobo.579.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">computed</span></strong><span class="koboSpan" id="kobo.581.1"> incorrectly. </span><span class="koboSpan" id="kobo.581.2">It is very common for inexperienced Vue.js developers to overuse </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">watch</span></strong><span class="koboSpan" id="kobo.583.1">. </span><span class="koboSpan" id="kobo.583.2">I have personally used it just a handful of times in years </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">of development.</span></span></p>
			<p><span class="koboSpan" id="kobo.585.1">We are going to change our application to automatically load more posts if there are fewer than four posts shown on screen. </span><span class="koboSpan" id="kobo.585.2">As mentioned previously, we are going to watch for a component variable (in our case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">posts</span></strong><span class="koboSpan" id="kobo.587.1"> array), and we are then going to trigger a side effect (in our case, another API call) when a certain condition </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">is met.</span></span></p>
			<p><span class="koboSpan" id="kobo.589.1">Let’s develop this together. </span><span class="koboSpan" id="kobo.589.2">First, we need to update our </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">fetch</span></strong><span class="koboSpan" id="kobo.591.1"> method to accept a page parameter to ensure that we fetch new posts and not always the </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">same ones:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.593.1">
const fetchPosts = (</span><strong class="old"><span class="koboSpan" id="kobo.594.1">page</span></strong><span class="koboSpan" id="kobo.595.1">) =&gt; {
  const baseUrl = "https://dummyapi.io/data/v1";
  fetch(`${baseUrl}/post?limit=5</span><strong class="old"><span class="koboSpan" id="kobo.596.1">&amp;page=${page}</span></strong><span class="koboSpan" id="kobo.597.1">`, {
    "headers": {
      "app-id": "1234567890"
    }
  })
    .then( response =&gt; response.json())
    .then( result =&gt; {
      posts.push(...result.data);
    })
}</span></pre>
			<p><span class="koboSpan" id="kobo.598.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">fetchPosts</span></strong><span class="koboSpan" id="kobo.600.1"> method now accepts a parameter of </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">page</span></strong><span class="koboSpan" id="kobo.602.1"> and appends it to the request query </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">parameter, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">`${baseUrl}/post?limit=5&amp;page=${page}`</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.606.1">We are then going to create a new ref called </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">page</span></strong><span class="koboSpan" id="kobo.608.1"> that will hold the current page value. </span><span class="koboSpan" id="kobo.608.2">To accomplish this, we are going to import </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">ref</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.610.1">from Vue.js:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.611.1">
import { reactive, </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">ref}</span></strong><span class="koboSpan" id="kobo.613.1"> from 'vue';</span></pre>
			<p><span class="koboSpan" id="kobo.614.1">Next, we define and initialize the variable. </span><span class="koboSpan" id="kobo.614.2">Because the first page of the posts is going to be 0, we are going to use this </span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.615.1">number as the </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">initialization value:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.617.1">
const page = ref(0);</span></pre>
			<p><span class="koboSpan" id="kobo.618.1">Lastly, we are going to pass this </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">ref</span></strong><span class="koboSpan" id="kobo.620.1"> when </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">calling </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">fetchPosts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.624.1">
fetchPosts(</span><strong class="old"><span class="koboSpan" id="kobo.625.1">page.value)</span></strong><span class="koboSpan" id="kobo.626.1">;</span></pre>
			<p><span class="koboSpan" id="kobo.627.1">Remember that because we used </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">ref</span></strong><span class="koboSpan" id="kobo.629.1"> to define our page variable, we need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">.value</span></strong><span class="koboSpan" id="kobo.631.1"> notation to access </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">its value.</span></span></p>
			<p><span class="koboSpan" id="kobo.633.1">Now, it is time to create our </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">watch</span></strong><span class="koboSpan" id="kobo.635.1">. </span><span class="koboSpan" id="kobo.635.2">Just like </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">computed</span></strong><span class="koboSpan" id="kobo.637.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">watch</span></strong><span class="koboSpan" id="kobo.639.1"> will depend on one or more other reactive values, like </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">Ref </span></strong><span class="koboSpan" id="kobo.641.1">and </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">Reactive</span></strong><span class="koboSpan" id="kobo.643.1">, and will include a callback value. </span><span class="koboSpan" id="kobo.643.2">The syntax is </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">watch( dependentData, callback(newValue, oldValue))</span></strong><span class="koboSpan" id="kobo.645.1">. </span><span class="koboSpan" id="kobo.645.2">So, in our case, the code would look </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">like this:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.647.1">
&lt;script setup&gt;
import { reactive, ref, </span><strong class="old"><span class="koboSpan" id="kobo.648.1">watch </span></strong><span class="koboSpan" id="kobo.649.1">} from 'vue';
import SocialPost from '../molecules/SocialPost.vue'
</span><strong class="old"><span class="koboSpan" id="kobo.650.1">watch(</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.651.1">  posts,</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.652.1">  (newValue, old) =&gt; {</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.653.1">    if( newValue.length &lt; 4 ) {</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.654.1">      page.value++;</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.655.1">      fetchPosts(page.value);</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.656.1">    }</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.657.1">  }</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.658.1">)</span></strong></pre>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">watch</span></strong><span class="koboSpan" id="kobo.660.1"> is meant to observe variable changes and trigger a callback. </span><span class="koboSpan" id="kobo.660.2">In our example, the application observes the variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">posts</span></strong><span class="koboSpan" id="kobo.662.1"> and triggers a callback that will change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">page</span></strong><span class="koboSpan" id="kobo.664.1"> variable and fetch new posts, using our API. </span><span class="koboSpan" id="kobo.664.2">The callback triggered by </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">watch</span></strong><span class="koboSpan" id="kobo.666.1"> offers two values; the first is the new value that the observed variable has received, and the second is the </span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">old value.</span></span></p>
			<p><span class="koboSpan" id="kobo.668.1">Most of the time, you will probably just use the first value (therefore, the new value of the observed data), but having </span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.669.1">access to both values is very useful when the effect triggered is dependent on the “change” of the variable. </span><span class="koboSpan" id="kobo.669.2">For example, this may be needed if you have an animation that shows different effects, depending on whether the value increases or decreases. </span><span class="koboSpan" id="kobo.669.3">This would only be possible if you have both the old and the new values </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">to compare.</span></span></p>
			<p><span class="koboSpan" id="kobo.671.1">Our Companion App should now be ready to be tested. </span><span class="koboSpan" id="kobo.671.2">To test our new functionality, delete a couple of posts by clicking the delete icon next to them, and then see the new posts </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">load dynamically.</span></span></p>
			<p><span class="koboSpan" id="kobo.673.1">There are a few more options available with </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">watch</span></strong><span class="koboSpan" id="kobo.675.1">, such as the ability to trigger it after the effect has taken place in the DOM, or the possibility to trigger it immediately when the component renders. </span><span class="koboSpan" id="kobo.675.2">However, these are out of the scope of this book, as they are for more advanced use and would just be confusing at </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">this stage.</span></span></p>
			<p><span class="koboSpan" id="kobo.677.1">Remember that using </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">watch</span></strong><span class="koboSpan" id="kobo.679.1"> has a cost. </span><span class="koboSpan" id="kobo.679.2">In fact, there is a cost to be paid for an application observing a value, but there is an even greater performance cost in triggering a callback on every change of a value. </span><span class="koboSpan" id="kobo.679.3">For this reason, it is recommended to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">watch</span></strong><span class="koboSpan" id="kobo.681.1"> only when needed and to ensure that the body of the callback is not </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">too resource-intensive.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.683.1">Use computed to minimize watch callbacks</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.684.1">If you are observing a variable that changes too often and want to try and improve on performance, you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">computed</span></strong><span class="koboSpan" id="kobo.686.1"> to create a new variable. </span><span class="koboSpan" id="kobo.686.2">This new computer property can then be watched instead. </span><span class="koboSpan" id="kobo.686.3">Because computed properties are cached, this approach is </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">more performant.</span></span></p>
			<p><span class="koboSpan" id="kobo.688.1">That completes our introduction to </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">watch</span></strong><span class="koboSpan" id="kobo.690.1">. </span><span class="koboSpan" id="kobo.690.2">This is a useful feature that, when used correctly, can help you create clean and </span><span class="No-Break"><span class="koboSpan" id="kobo.691.1">readable components.</span></span></p>
			<p><span class="koboSpan" id="kobo.692.1">In this section, we</span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.693.1"> learned what </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">watch</span></strong><span class="koboSpan" id="kobo.695.1"> is and how using it improves our component, giving us a chance to trigger side effects from our application, such as an API request or DOM modification. </span><span class="koboSpan" id="kobo.695.2">We then made changes in the Companion App to better understand this topic. </span><span class="koboSpan" id="kobo.695.3">Finally, we explained the drawbacks of using </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">watch</span></strong><span class="koboSpan" id="kobo.697.1"> and discussed when and how to </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">use it.</span></span></p>
			<p><span class="koboSpan" id="kobo.699.1">In the next section, we are going to introduce a built-in component called </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">&lt;Suspense&gt;</span></strong><span class="koboSpan" id="kobo.701.1">. </span><span class="koboSpan" id="kobo.701.2">This feature simplifies how we handle the loading state of </span><span class="No-Break"><span class="koboSpan" id="kobo.702.1">asynchronous components.</span></span></p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.703.1">Handling asynchronous components with &lt;Suspense&gt;</span></h1>
			<p><span class="koboSpan" id="kobo.704.1">Handling dynamic data loading is never easy. </span><span class="koboSpan" id="kobo.704.2">In fact, when data is static and hardcoded, displaying the information takes no effort, as the data is available on first render, but when the data needs to come</span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.705.1"> from an outside source, such as a database or a third-party API, then the complexity increases. </span><span class="koboSpan" id="kobo.705.2">When loading information asynchronously, the data is not available on the first load, forcing </span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.706.1">us to handle a “loading state” until the data is available, or having to display an error state if the loading event has failed </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">to complete.</span></span></p>
			<p><span class="koboSpan" id="kobo.708.1">To prevent having to handle state changes in multiple components and code duplication, Vue.js introduced a globally available built-in component </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">&lt;Suspense&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.712.1">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">&lt;Suspense&gt;</span></strong><span class="koboSpan" id="kobo.714.1">, we can orchestrate all loading states at once with very clean syntax. </span><span class="koboSpan" id="kobo.714.2">In the following section, we are going to first understand what makes a component asynchronous and then understand how this can be used to simplify </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">our code.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.716.1">An experimental feature</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.717.1">At the time of writing, </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">&lt;Suspense&gt;</span></strong><span class="koboSpan" id="kobo.719.1"> is still an experimental feature, and there is no set date on when and if it will </span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.720.1">become a core part of the Vue.js</span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.721.1"> framework. </span><span class="koboSpan" id="kobo.721.2">The team is fixing a few bugs with it and more importantly, developing server-side support before it is turned into a </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">full feature.</span></span></p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.723.1">Understanding asynchronous components</span></h2>
			<p><span class="koboSpan" id="kobo.724.1">In the preceding introduction, we discussed an async component by using the example of a component that needs to load data</span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.725.1"> dynamically, but that is not the actual definition of an </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">async component.</span></span></p>
			<p><span class="koboSpan" id="kobo.727.1">An async component is “</span><em class="italic"><span class="koboSpan" id="kobo.728.1">a component that requires an asynchronous function to be performed and completed before the rendering can </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.729.1">be initialized</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">.”</span></span></p>
			<p><span class="koboSpan" id="kobo.731.1">The important takeaway from the preceding definition is the words </span><strong class="old"><span class="koboSpan" id="kobo.732.1">asynchronous</span></strong><span class="koboSpan" id="kobo.733.1"> and </span><strong class="old"><span class="koboSpan" id="kobo.734.1">completed</span></strong><span class="koboSpan" id="kobo.735.1">. </span><span class="koboSpan" id="kobo.735.2">The presence of both an </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">async</span></strong><span class="koboSpan" id="kobo.737.1"> operation and the need for it to be completed are requirements for a component to be defined as an </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">asynchronous component.</span></span></p>
			<p><span class="koboSpan" id="kobo.739.1">In fact, if we look at our current application, we can see that we already have dynamic data that is loaded in </span><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">SocialPosts.vue</span></strong><span class="koboSpan" id="kobo.741.1">, but this does not make it an async component, as the component is rendered immediately and does not wait for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">fetch</span></strong><span class="koboSpan" id="kobo.743.1"> operation to </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">be completed.</span></span></p>
			<p><span class="koboSpan" id="kobo.745.1">An asynchronous component is characterized by the</span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.746.1"> presence of a top-level </span><strong class="old"><span class="koboSpan" id="kobo.747.1">await</span></strong><span class="koboSpan" id="kobo.748.1"> function in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">&lt;script setup&gt;</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.750.1">code block.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.751.1">An asynchronous component affects the page rendering</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.752.1">An asynchronous component will stop the rendering itself and all of its children until the data is fully loaded. </span><span class="koboSpan" id="kobo.752.2">This should just be used if the component has no reason to render without the data </span><span class="No-Break"><span class="koboSpan" id="kobo.753.1">being available.</span></span></p>
			<p><span class="koboSpan" id="kobo.754.1">Let’s look at our Companion App and try to find a good candidate to turn into an async component. </span><span class="koboSpan" id="kobo.754.2">Currently, only two components have asynchronous operations between them, </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">SocialPosts.vue</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.756.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">SocialPostComments.vue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.759.1">If we look at the logic within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">SocialPostComments.vue</span></strong><span class="koboSpan" id="kobo.761.1">, we can see that the component does not currently function properly. </span><span class="koboSpan" id="kobo.761.2">The current component logic displays a message when the comments array is empty, </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">"&lt;p&gt;There are no comments for this post!&lt;/p&gt;"</span></strong><span class="koboSpan" id="kobo.763.1">, but this message is also displayed when the component first renders. </span><span class="koboSpan" id="kobo.763.2">This is because </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.764.1">the component renders immediately, even if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">fetch </span></strong><span class="koboSpan" id="kobo.766.1">request is </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">still active.</span></span></p>
			<p><span class="koboSpan" id="kobo.768.1">This is a very good candidate to be turned into an async component. </span><span class="koboSpan" id="kobo.768.2">In fact, this component has both an “async operation” and the “need for it to be completed,” as mentioned in the definition of an </span><span class="No-Break"><span class="koboSpan" id="kobo.769.1">async component.</span></span></p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.770.1">Turning a component into an asynchronous component</span></h2>
			<p><span class="koboSpan" id="kobo.771.1">Vue.js provides a very simple way to define a component as an asynchronous component. </span><span class="koboSpan" id="kobo.771.2">In fact, all we need to do is</span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.772.1"> ensure that the component includes one or more </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">await</span></strong><span class="koboSpan" id="kobo.774.1"> functions within </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">its body.</span></span></p>
			<p><span class="koboSpan" id="kobo.776.1">When the Vue.js framework sees an await function, it automatically defines the component </span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">as async.</span></span></p>
			<p><span class="koboSpan" id="kobo.778.1">Let’s modify </span><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">SocialPostComments.vue</span></strong><span class="koboSpan" id="kobo.780.1"> to await the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">fetch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.782.1"> method:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.783.1">
&lt;script setup &gt;
import { reactive } from 'vue';
const props = defineProps({
  postId: String
});
const comments = reactive([]);
const fetchComments = (postId) =&gt; {
  const baseUrl = "https://dummyapi.io/data/v1";
  </span><strong class="old"><span class="koboSpan" id="kobo.784.1">return </span></strong><span class="koboSpan" id="kobo.785.1">fetch(`${baseUrl}/post/${postId}/comment?limit=5`,
  {
    "headers": {
      "app-id": "1234567890"
    }
  })
    .then( response =&gt; response.json())
    .then( result =&gt; {
      Object.assign(comments, result.data);
    })
};
</span><strong class="old"><span class="koboSpan" id="kobo.786.1">await </span></strong><span class="koboSpan" id="kobo.787.1">fetchComments(props.postId);
&lt;/script&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.788.1">Our component logic required just two small changes to turn the component into a dynamic one. </span><span class="koboSpan" id="kobo.788.2">First, we made sure that our </span><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">fetchComments</span></strong><span class="koboSpan" id="kobo.790.1"> method returned a promise by adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">return</span></strong><span class="koboSpan" id="kobo.792.1"> before the </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">fetch</span></strong><span class="koboSpan" id="kobo.794.1"> method. </span><span class="koboSpan" id="kobo.794.2">Then, we added </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">await</span></strong><span class="koboSpan" id="kobo.796.1"> when calling the method. </span><span class="koboSpan" id="kobo.796.2">These two </span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.797.1">changes were all that was needed to ensure the component would turn into an </span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">async component.</span></span></p>
			<p><span class="koboSpan" id="kobo.799.1">All that is left to do now is learn how to use asynchronous components. </span><span class="koboSpan" id="kobo.799.2">In fact, at this stage, the Companion App is unable to load comments, and clicking on the “Load comment” button would log the </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">following error:</span></span></p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<span class="koboSpan" id="kobo.801.1"><img src="image/B21130_07_06.jpg" alt="Figure 7.6: An error message triggered by Vue.js when trying to incorrectly load an async component"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.802.1">Figure 7.6: An error message triggered by Vue.js when trying to incorrectly load an async component</span></p>
			<p><span class="koboSpan" id="kobo.803.1">The error message mentions the need for the async component to be nested in </span><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">&lt;Suspense&gt;</span></strong><span class="koboSpan" id="kobo.805.1"> in order to be rendered. </span><span class="koboSpan" id="kobo.805.2">Let’s learn what this </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">&lt;Supense&gt;</span></strong><span class="koboSpan" id="kobo.807.1"> is and how it can be used to load </span><span class="No-Break"><span class="koboSpan" id="kobo.808.1">async components.</span></span></p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.809.1">Rendering async components</span></h2>
			<p><span class="koboSpan" id="kobo.810.1">In the previous section, we made the </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">SocialPostComments.vue</span></strong><span class="koboSpan" id="kobo.812.1"> file asynchronous, and it is now time to learn how to handle this component to ensure that it is </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">loaded correctly.</span></span></p>
			<p><span class="koboSpan" id="kobo.814.1">As we previously mentioned, when a component is</span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.815.1"> turned into an asynchronous one, it then requires us to handle its loading state. </span><span class="koboSpan" id="kobo.815.2">Loading this component normally, as we are currently doing in the application, would not work, as the component is not immediately available, so we need to find a way to handle its </span><span class="No-Break"><span class="koboSpan" id="kobo.816.1">load gracefully.</span></span></p>
			<p><span class="koboSpan" id="kobo.817.1">As always, the Vue.js core team has worked hard to provide us with all the tools we need to quickly accomplish </span><span class="No-Break"><span class="koboSpan" id="kobo.818.1">complex operations.</span></span></p>
			<p><span class="koboSpan" id="kobo.819.1">The component is defined on the official Vue.js documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">as follows:</span></span></p>
			<p class="author-quote"><span class="koboSpan" id="kobo.821.1">“</span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">&lt;Suspense&gt;</span></strong><span class="koboSpan" id="kobo.823.1"> is a built-in component for orchestrating async dependencies in a component tree. </span><span class="koboSpan" id="kobo.823.2">It can render a loading state while waiting for multiple nested async dependencies down the component tree to be resolved.”</span></p>
			<p><span class="koboSpan" id="kobo.824.1">Wrapping one or multiple components within </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">&lt;Suspense&gt;</span></strong><span class="koboSpan" id="kobo.826.1"> prevents them from rendering until all the async operations are completed. </span><span class="koboSpan" id="kobo.826.2">Furthermore, </span><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">&lt;Suspense&gt;</span></strong><span class="koboSpan" id="kobo.828.1"> also allows you to display a “loading” component while the async operations </span><span class="No-Break"><span class="koboSpan" id="kobo.829.1">are completed.</span></span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">&lt;Suspense&gt;</span></strong><span class="koboSpan" id="kobo.831.1"> is already preloaded in the application, and it does not need to be imported. </span><span class="koboSpan" id="kobo.831.2">Let’s open </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">SocialPost.vue</span></strong><span class="koboSpan" id="kobo.833.1"> and change our code to correctly load our </span><span class="No-Break"><span class="koboSpan" id="kobo.834.1">async component:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.835.1">
...
</span><span class="koboSpan" id="kobo.835.2">&lt;div class="post" v-text="post"&gt;&lt;/div&gt;
</span><strong class="old"><span class="koboSpan" id="kobo.836.1">&lt;Suspense v-if="showComments" &gt;</span></strong><span class="koboSpan" id="kobo.837.1">
  &lt;SocialPostComments
    </span><strong class="old"><span class="koboSpan" id="kobo.838.1">v-if="showComments"</span></strong><span class="koboSpan" id="kobo.839.1">
    :post-id="id"
    @delete="onDeleted"
  /&gt;
</span><strong class="old"><span class="koboSpan" id="kobo.840.1">&lt;/Suspense&gt;</span></strong><span class="koboSpan" id="kobo.841.1">
&lt;div class="interactions"&gt;
...</span></pre>
			<p><span class="koboSpan" id="kobo.842.1">The use of this built-in component is very simple. </span><span class="koboSpan" id="kobo.842.2">In fact, all we need to do is wrap </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">SocialPostComments</span></strong><span class="koboSpan" id="kobo.844.1"> within</span><strong class="source-inline"><span class="koboSpan" id="kobo.845.1"> &lt;Suspense&gt;</span></strong><span class="koboSpan" id="kobo.846.1">, as highlighted in the previous code block, and move the </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">v-if</span></strong><span class="koboSpan" id="kobo.848.1"> directive, </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">v-if="showComments"</span></strong><span class="koboSpan" id="kobo.850.1">, from </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">SocialPostComments</span></strong><span class="koboSpan" id="kobo.852.1"> to the built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">Suspense</span></strong><span class="koboSpan" id="kobo.854.1"> component. </span><span class="koboSpan" id="kobo.854.2">After these changes,  </span><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">SocialPostComments</span></strong><span class="koboSpan" id="kobo.856.1"> will simply render after the async operation within the </span><span class="No-Break"><span class="koboSpan" id="kobo.857.1">component resolves.</span></span></p>
			<p><span class="koboSpan" id="kobo.858.1">There are cases in which you may be required to display a loading indicator while the async operation completes. </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">&lt;Suspense&gt;</span></strong><span class="koboSpan" id="kobo.860.1"> provides a </span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.861.1">named slot called </span><strong class="old"><span class="koboSpan" id="kobo.862.1">fallback</span></strong><span class="koboSpan" id="kobo.863.1"> that can handle this. </span><span class="koboSpan" id="kobo.863.2">Let’s learn how to use this feature by adding a fallback message while the post </span><span class="No-Break"><span class="koboSpan" id="kobo.864.1">comments load.</span></span></p>
			<p><span class="koboSpan" id="kobo.865.1">To implement a fallback message, our </span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.866.1">code would require the </span><span class="No-Break"><span class="koboSpan" id="kobo.867.1">following modifications:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.868.1">
&lt;Suspense v-if="showComments" &gt;
  &lt;SocialPostComments
    :post-id="id"
    @delete="onDeleted"
  /&gt;
  </span><strong class="old"><span class="koboSpan" id="kobo.869.1">&lt;template #fallback&gt;</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.870.1">    fetching comments...</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.871.1">  &lt;/template&gt;</span></strong><span class="koboSpan" id="kobo.872.1">
&lt;/Suspense&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.873.1">To add a message while the comments are fetched, we use the </span><strong class="old"><span class="koboSpan" id="kobo.874.1">fallback </span></strong><span class="koboSpan" id="kobo.875.1">slot alongside our </span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">SocialPostComments</span></strong><span class="koboSpan" id="kobo.877.1">. </span><span class="koboSpan" id="kobo.877.2">This slot is going to be defined using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">&lt;template #fallback&gt;</span></strong><span class="koboSpan" id="kobo.879.1"> syntax. </span><span class="koboSpan" id="kobo.879.2">The content of this slot will just be displayed while the async operation within </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">SocialPostComments</span></strong><span class="koboSpan" id="kobo.881.1"> is run, and it </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.882.1">will disappear as soon as the component </span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">is rendered.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.884.1">Custom error handling</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.885.1">At this stage, error handling is not handled by </span><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">&lt;Suspense&gt;</span></strong><span class="koboSpan" id="kobo.887.1">, and this needs to be handled manually using </span><strong class="source-inline"><span class="koboSpan" id="kobo.888.1">onErrorCapture()</span></strong><span class="koboSpan" id="kobo.889.1"> hooks. </span><span class="koboSpan" id="kobo.889.2">Explaining this is beyond the scope of </span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">this book.</span></span></p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.891.1">Summary</span></h1>
			<p><span class="koboSpan" id="kobo.892.1">We have now completed everything we had to learn about async data and component loading. </span><span class="koboSpan" id="kobo.892.2">We started the chapter by removing the hardcoded </span><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">posts</span></strong><span class="koboSpan" id="kobo.894.1"> and replacing them with dummy data that is loaded dynamically. </span><span class="koboSpan" id="kobo.894.2">We then fixed the property mismatch caused by the data change, learning how to prevent this in the future by improving the use of property typing </span><span class="No-Break"><span class="koboSpan" id="kobo.895.1">and validations.</span></span></p>
			<p><span class="koboSpan" id="kobo.896.1">Then, we learned how to change our data flow to load comments on demand and defined when this should be used, as well as the performance and user experience benefits that this brings. </span><span class="koboSpan" id="kobo.896.2">We then introduced another feature related to async operations, </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">watch</span></strong><span class="koboSpan" id="kobo.898.1">. </span><span class="koboSpan" id="kobo.898.2">We used this feature to trigger a side effect and automatically load more posts when the number of posts reaches a </span><span class="No-Break"><span class="koboSpan" id="kobo.899.1">certain number.</span></span></p>
			<p><span class="koboSpan" id="kobo.900.1">Lastly, we learned how to create and handle asynchronous components. </span><span class="koboSpan" id="kobo.900.2">We described what makes an async component and changed our Companion App to ensure our comments were fetched before loading the component. </span><span class="koboSpan" id="kobo.900.3">We concluded the chapter by introducing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">&lt;Suspense&gt;</span></strong><span class="koboSpan" id="kobo.902.1"> built-in component, using it to correctly load our asynchronous component, and we also examined a fallback feature that shows text while the </span><span class="No-Break"><span class="koboSpan" id="kobo.903.1">component loads.</span></span></p>
			<p><span class="koboSpan" id="kobo.904.1">At this stage, you should be able to fully handle asynchronous data loading, side effects, and components that require JavaScript promises to be fulfilled before </span><span class="No-Break"><span class="koboSpan" id="kobo.905.1">being displayed.</span></span></p>
			<p><span class="koboSpan" id="kobo.906.1">In the next chapter, we are going to move our focus away from Vue.js and focus on testing our application. </span><span class="koboSpan" id="kobo.906.2">We will learn the basics of end-to-end testing with </span><strong class="old"><span class="koboSpan" id="kobo.907.1">Cypress </span></strong><span class="koboSpan" id="kobo.908.1">and unit testing </span><span class="No-Break"><span class="koboSpan" id="kobo.909.1">with </span></span><span class="No-Break"><strong class="old"><span class="koboSpan" id="kobo.910.1">Vitest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.911.1">.</span></span></p>
		</div>
	

		<div id="_idContainer077" class="Content">
			<h1 id="_idParaDest-94" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.1.1">Part 3: Expanding Your Knowledge with Vue.js and Its Core Libraries</span></h1>
			<p><span class="koboSpan" id="kobo.2.1">At this stage in our journey, it is time to introduce the external libraries that are part of the Vue.js ecosystem that are required to build </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">production-ready applications.</span></span></p>
			<p><span class="koboSpan" id="kobo.4.1">This part contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
			<ul>
				<li><a href="B21130_08.xhtml#_idTextAnchor103"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 8</span></em></a><em class="italic"><span class="koboSpan" id="kobo.7.1">, Testing Your App with Vitest and Cypress</span></em></li>
				<li><a href="B21130_09.xhtml#_idTextAnchor120"><em class="italic"><span class="koboSpan" id="kobo.8.1">Chapter 9</span></em></a><em class="italic"><span class="koboSpan" id="kobo.9.1">, Introduction to Advanced Vue.js Techniques – Slots, Lifecycle, and </span></em><em class="italic"><span class="koboSpan" id="kobo.10.1">Template Refs</span></em></li>
				<li><a href="B21130_10.xhtml#_idTextAnchor135"><em class="italic"><span class="koboSpan" id="kobo.11.1">Chapter 10</span></em></a><em class="italic"><span class="koboSpan" id="kobo.12.1">, Handling Routing with </span></em><em class="italic"><span class="koboSpan" id="kobo.13.1">Vue Router</span></em></li>
				<li><a href="B21130_11.xhtml#_idTextAnchor153"><em class="italic"><span class="koboSpan" id="kobo.14.1">Chapter 11</span></em></a><em class="italic"><span class="koboSpan" id="kobo.15.1">, Managing Your Application’s State with Pinia</span></em></li>
				<li><a href="B21130_12.xhtml#_idTextAnchor163"><em class="italic"><span class="koboSpan" id="kobo.16.1">Chapter 12</span></em></a><em class="italic"><span class="koboSpan" id="kobo.17.1">, Achieving Client-Side Validation with VeeValidate</span></em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer078">
			</div>
		</div>
		<div>
			<div id="_idContainer079">
			</div>
		</div>
		<div>
			<div id="_idContainer080">
			</div>
		</div>
		<div>
			<div id="_idContainer081">
			</div>
		</div>
		<div>
			<div id="_idContainer082">
			</div>
		</div>
		<div>
			<div id="_idContainer083" class="Basic-Graphics-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer084" class="Basic-Graphics-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer085">
			</div>
		</div>
		<div>
			<div id="_idContainer086">
			</div>
		</div>
		<div>
			<div id="_idContainer087" class="Basic-Graphics-Frame">
			</div>
		</div>
	</body></html>