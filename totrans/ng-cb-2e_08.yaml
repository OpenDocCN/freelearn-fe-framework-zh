- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Mastering Angular Forms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精通Angular表单
- en: Getting user input is an integral part of almost any modern app that we use.
    Whether it is authenticating users, asking for feedback, or filling out business-critical
    forms, knowing how to implement and present forms to end users is always an interesting
    challenge. In this chapter, you’ll learn about **Angular forms** and how you can
    create great user experiences using them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 获取用户输入是几乎所有现代应用不可或缺的一部分。无论是用户认证、请求反馈还是填写关键业务表单，了解如何实现和向最终用户展示表单总是一个有趣的挑战。在本章中，你将了解**Angular表单**以及如何使用它们创建出色的用户体验。
- en: 'Here are the recipes that we’re going to cover in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将要涵盖的食谱如下：
- en: Creating your first template-driven form with validation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建带有验证的第一个模板驱动表单
- en: Creating your first reactive form with form validation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建带有表单验证的第一个响应式表单
- en: Testing forms in Angular
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular中测试表单
- en: Server-side validation using asynchronous validator functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步验证函数进行服务器端验证
- en: Implementing complex forms with reactive `FormArray`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用响应式`FormArray`实现复杂表单
- en: Writing your own custom form control using `ControlValueAccessor`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ControlValueAccessor`编写自己的自定义表单控件
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For the recipes in this chapter, ensure your setup is complete as per the ''Technical
    Requirements'' in the ''Angular-Cookbook-2E'' GitHub repository. For setup details,
    visit: [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md).
    The starter code for this chapter is located at [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter08](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter08).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的食谱，请确保你的设置按照'Angular-Cookbook-2E' GitHub仓库中的'技术要求'完成。有关设置详情，请访问：[https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md)。本章的起始代码位于[https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter08](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter08)。
- en: Creating your first template-driven form with validation
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建带有验证的第一个模板驱动表单
- en: Let’s start getting familiar with Angular forms in this recipe. In this one,
    you’ll learn about the basic concepts of template-driven forms and will create
    a basic Angular form, using the template-driven forms API.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从本食谱开始熟悉Angular表单。在这个食谱中，你将了解模板驱动表单的基本概念，并创建一个基本的Angular表单，使用模板驱动表单API。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter08/ng-tdf`
    inside the cloned repository:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆的仓库中的`start/apps/chapter08/ng-tdf`：
- en: Open the code repository in your code editor.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用，你应该看到以下内容：
- en: '![](img/B18469_08_01.png)'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_08_01.png)'
- en: 'Figure 8.1: ng-tdf app running on http://localhost:4200'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.1：运行在http://localhost:4200的ng-tdf应用
- en: How to do it…
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We have an Angular app that already has a bunch of components and some UI setup.
    We need to implement the functionality to add a new version to the logs. We’ll
    use a template-driven form to allow the user to pick an app and submit a release
    version. Let’s get started:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个已经包含了许多组件和一些UI设置的Angular应用。我们需要实现添加新版本到日志的功能。我们将使用模板驱动表单来允许用户选择一个应用并提交一个发布版本。让我们开始吧：
- en: 'First, we’ll add the `FormsModule` in the `src/app/components/version-control/version-control.component.ts`
    file in the project, as follows:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将在项目的`src/app/components/version-control/version-control.component.ts`文件中添加`FormsModule`，如下所示：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we’ll use a template-variable with `NgForm` and `NgModel` on the form
    input inside the component’s HTML file to use template-driven forms. Update the
    `version-control.component.html` file as follows:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在组件的HTML文件中的表单输入上使用`NgForm`和`NgModel`模板变量来使用模板驱动表单。按照以下方式更新`version-control.component.html`文件：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s create a method that will be triggered when the form is submitted. Update
    the `version-control.component.ts` file as follows:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个当表单提交时会被触发的机制。按照以下方式更新`version-control.component.ts`文件：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we have the form submit handler, let’s add the event listener to the
    template. Update the `version-control.component.html` file, as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经有了表单提交处理程序，让我们给模板添加事件监听器。更新`version-control.component.html`文件，如下所示：
- en: '[PRE4]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After adding this, you should be able to add new versions. However, you can
    use any value for the input or even provide nothing, and it will add as a new
    version. See the following screenshot for an example:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加这个之后，你应该能够添加新的版本。然而，你可以为输入使用任何值，甚至不提供任何内容，它也会作为一个新版本添加。请参见以下截图以获取示例：
- en: '![](img/B18469_08_02.png)'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_08_02.png)'
- en: 'Figure 8.2: ng-tdf app without form validation'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.2：没有表单验证的ng-tdf应用
- en: 'We’ll add some form validation going forward. First of all, we’ll make sure
    we only change the value of the `versionName` property when the form has a valid
    input. Update the `formSubmit` method in the `version-control.component.ts` file,
    as follows:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将向前添加一些表单验证。首先，我们要确保只有当表单有有效输入时，我们才更改`versionName`属性的值。更新`version-control.component.ts`文件中的`formSubmit`方法，如下所示：
- en: '[PRE5]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will now add some validations in the template file. We’ll make the required
    input and ensure that the version provided follows semantic versioning. Update
    the `version-control.component.html` file, as follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将在模板文件中添加一些验证。我们将强制输入，并确保提供的版本遵循语义版本控制。更新`version-control.component.html`文件，如下所示：
- en: '[PRE6]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you try submitting the form now with an invalid value, you’ll see that the
    version provided doesn’t get added to the logs, but if you provide a valid version
    like `2.1.0`, it will be added to the logs. However, this isn’t great in terms
    of UX, since it doesn’t tell us what’s wrong.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在尝试提交一个无效值的表单，你会看到提供的版本不会添加到日志中，但如果提供一个有效的版本，如`2.1.0`，它将被添加到日志中。然而，从用户体验的角度来看，这并不好，因为它没有告诉我们哪里出了问题。
- en: 'Let’s show some error messages based on the form validation we have. Update
    the `version-control.component.html`, as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们根据我们已有的表单验证显示一些错误消息。更新`version-control.component.html`文件，如下所示：
- en: '[PRE7]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you now submit the form without any input, you should see the following
    error:'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在提交一个没有任何输入的表单，你应该会看到以下错误：
- en: '![](img/B18469_08_03.png)'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_08_03.png)'
- en: 'Figure 8.3: ng-tdf app with form validation'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.3：具有表单验证的ng-tdf应用
- en: And if you try giving it the wrong value, you’ll see a different error.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你尝试给它错误的值，你会看到不同的错误。
- en: 'Great! Within a few minutes, we were able to create our first template-driven
    form in Angular with form validation. If you refresh the app now and add some
    versions, you should see the following:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 太好了！在几分钟内，我们就能够使用表单验证在Angular中创建我们的第一个模板驱动表单。如果你现在刷新应用并添加一些版本，你应该会看到以下内容：
- en: '![](img/B18469_08_04.png)'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_08_04.png)'
- en: 'Figure 8.4: ng-tdf app final output'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.4：ng-tdf应用最终输出
- en: Now that you know how the template-driven forms are created, let’s see the next
    section to understand how it works.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了模板驱动表单是如何创建的，让我们看看下一节来了解它是如何工作的。
- en: How it works…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The key to using template-driven forms in Angular resides in `FormsModule`,
    the `ngForm` directive, and the `ngModel` binding. This would almost always include
    template variables along with the `name` attributes for inputs in the template.
    We began by adding the `FormsModule` in the `VersionControlComponent` class, which
    is necessary to use the `ngForm` directive and the `[(ngModel)]` two-way data
    binding. Then, we added the `[(ngModel)]` to the version input. We also added
    the `ngForm` attributeon the `form` element, similarly creating a `#versionForm`
    variable so that we can use it to see if the entire form is valid. Then, we added
    the `ngSubmit` handler to the `form` element so that we could trigger a method
    when the form is submitted. We also added the respective method named `formSubmit`
    in the `VersionControlComponent` class as well. Notice that we pass the `versionForm`
    variable to the `formSubmit` method, which makes it easier to test the functionality
    for us. Upon submitting the form, we use the form in the `formSubmit` method to
    get the value of the input and to create a new `version-log` item. Notice that
    we access the control/input by using `form.controls['version']`. The key version
    directly corresponds to the value of the `name` attribute on the input element
    in the template. `ngForm` automatically creates a `FormControl` instance for us,
    using the value of the `name` attribute of the input, and thus we can access it
    that way. Also, notice that if you provide an invalid version for the new release
    log, the app will show the respective errors based on either the empty input,
    or an invalid version format. This is because we have the `required`attribute
    set on the `<input />` element as well as the `pattern` attribute.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中使用模板驱动表单的关键在于`FormsModule`、`ngForm`指令和`ngModel`绑定。这几乎总是包括模板变量以及模板中输入的`name`属性。我们首先在`VersionControlComponent`类中添加了`FormsModule`，这是使用`ngForm`指令和`[(ngModel)]`双向数据绑定所必需的。然后，我们将`[(ngModel)]`添加到版本输入中。我们还添加了`ngForm`属性到`form`元素上，同样创建了一个`#versionForm`变量，这样我们就可以用它来检查整个表单是否有效。然后，我们在`form`元素上添加了`ngSubmit`处理器，以便在表单提交时触发一个方法。我们还在`VersionControlComponent`类中添加了相应的`formSubmit`方法。请注意，我们将`versionForm`变量传递给`formSubmit`方法，这使得我们更容易测试其功能。提交表单时，我们在`formSubmit`方法中使用表单来获取输入值并创建一个新的`version-log`条目。请注意，我们通过使用`form.controls['version']`来访问控件/输入。关键版本直接对应于模板中输入元素的`name`属性值。`ngForm`会自动为我们创建一个`FormControl`实例，使用输入的`name`属性值，因此我们可以这样访问它。此外，请注意，如果您为新版本日志提供了无效的版本，应用程序将根据空输入或无效的版本格式显示相应的错误。这是因为我们在`<input
    />`元素上设置了`required`属性以及`pattern`属性。
- en: See also
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Building a template-driven form in Angular*: [https://angular.io/guide/forms#building-a-template-driven-form](https://angular.io/guide/forms#building-a-template-driven-form)'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 Angular 中构建模板驱动表单*: [https://angular.io/guide/forms#building-a-template-driven-form](https://angular.io/guide/forms#building-a-template-driven-form)'
- en: '*Show and hide* *validation error messages* (Angular docs): [https://angular.io/guide/forms#show-and-hide-validation-error-messages](https://angular.io/guide/forms#show-and-hide-validation-error-messages
    )'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示和隐藏* *验证错误消息*（Angular 文档）: [https://angular.io/guide/forms#show-and-hide-validation-error-messages](https://angular.io/guide/forms#show-and-hide-validation-error-messages)'
- en: Creating your first reactive form with validation
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建带有验证的第一个响应式表单
- en: You’ve learned about template-driven forms in the previous recipe and are now
    confident in building Angular apps with them. Now, guess what? reactive forms
    are even better. Many known engineers and businesses in the Angular community
    recommend using only reactive forms for Angular apps. The reason is that when
    it comes to complex forms, Reactive forms make it easy to manage, i.e., you can
    decouple your form’s logic from the template and add validators dynamically, etc.
    In this recipe, you’ll build your first Reactive form and will learn its basic
    usage.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的菜谱中，您已经了解了模板驱动表单，并且现在对使用它们构建 Angular 应用程序充满信心。现在，猜猜看？响应式表单甚至更好。Angular 社区中的许多知名工程师和企业推荐仅使用响应式表单来构建
    Angular 应用程序。原因是，当涉及到复杂表单时，响应式表单使得管理变得容易，即您可以将表单的逻辑与模板解耦，并动态添加验证器等。在本菜谱中，您将构建您的第一个响应式表单，并学习其基本用法。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter08/ng-reactive-forms`
    inside the cloned repository:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用程序位于克隆的仓库中的`start/apps/chapter08/ng-reactive-forms`目录下：
- en: Open the code repository in your code editor.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令来运行项目：
- en: '[PRE8]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用，你应该会看到以下内容：
- en: '![](img/B18469_08_05.png)'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_08_05.png)'
- en: 'Figure 8.5: ng-reactive-forms app running on http://localhost:4200'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.5：运行在http://localhost:4200上的ng-reactive-forms应用
- en: Now that we have the app running locally, let’s see the steps involved in this
    recipe in the next section.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用，让我们在下一节中查看这个食谱所涉及的步骤。
- en: How to do it…
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'So far, we have an app that has a `VcLogsComponent`, which shows a bunch of
    version logs that we create. We also have a `VersionControlComponent`, which has
    a form with which the release logs will be created. We now have to make our current
    form a Reactive form, using the reactive forms API. Let’s get started:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个包含`VcLogsComponent`的应用，它显示了我们创建的一组版本日志。我们还有一个`VersionControlComponent`，它有一个表单，通过这个表单将创建发布日志。我们现在必须将我们的当前表单改为响应式表单，使用响应式表单API。让我们开始吧：
- en: 'First of all, we need to import `ReactiveFormsModule` into the imports of our
    `AppModule`. Let’s do it by modifying the `app/components/version-control/version-control.component.ts`
    file, as follows:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要将`ReactiveFormsModule`导入到我们的`AppModule`的导入中。让我们通过修改`app/components/version-control/version-control.component.ts`文件来实现，如下所示：
- en: '[PRE9]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We’ll create the Reactive form shortly. First, import the required dependencies
    in the `version-control.component.ts` file, as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将很快创建响应式表单。首先，在`version-control.component.ts`文件中导入所需的依赖项，如下所示：
- en: '[PRE10]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we’ll create a `FormGroup` in our `VersionControlComponent` class with
    a control named `version`. A `FormGroup` allows us to group multiple controls
    together in a form. Modify the `version-control.component.ts` file, as follows:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在`VersionControlComponent`类中创建一个名为`version`的控件`FormGroup`。`FormGroup`允许我们在表单中将多个控件组合在一起。按照以下方式修改`version-control.component.ts`文件：
- en: '[PRE11]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that we have the Reactive form in place, let’s bind the `versionForm` in
    the template to the `<form>` element. Update the `version-control.component.html`
    file, as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经设置了响应式表单，让我们在模板中将`versionForm`绑定到`<form>`元素。按照以下方式更新`version-control.component.html`文件：
- en: '[PRE12]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Great! Now that we have the form group bound, we can also bind the `version`
    form control. Modify the `version-control.component.html` file further, as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太好了！现在我们已经绑定了表单组，我们还可以绑定`version`表单控件。进一步修改`version-control.component.html`文件，如下所示：
- en: '[PRE13]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s decide what will happen when we submit this form. We’ll call a method
    named `formSubmit` in the template and pass `versionForm` to it when the form
    is submitted. Modify the `version-control.component.html` file, as follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们决定当提交这个表单时会发生什么。在模板中，我们将调用名为`formSubmit`的方法，并在表单提交时将`versionForm`传递给它。按照以下方式修改`version-control.component.html`文件：
- en: '[PRE14]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `formSubmit` method doesn’t yet exist. Let’s create it now in the `VersionControlComponent`
    class. Modify the `version-control.component.ts` file, as follows:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`formSubmit`方法还不存在。现在让我们在`VersionControlComponent`类中创建它。按照以下方式修改`version-control.component.ts`文件：'
- en: '[PRE15]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you try submitting the form now with an invalid value, you’ll see that the
    version provided doesn’t get added to the logs, but if you provide a valid version
    like `2.1.0`, it will be added to the logs. However, this isn’t great in terms
    of UX, since it doesn’t tell us what’s wrong.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在尝试提交一个无效的值，你会看到提供的版本不会添加到日志中，但如果你提供一个有效的版本，如`2.1.0`，它将被添加到日志中。然而，从用户体验的角度来看，这并不好，因为它没有告诉我们哪里出了问题。
- en: 'Let’s show some error messages based on the form validation we have. Update
    the `version-control.component.html`, as follows:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们根据我们已有的表单验证显示一些错误消息。按照以下方式更新`version-control.component.html`文件：
- en: '[PRE16]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you now type something in the form and clear the input, you should see an
    error, as follows:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在在表单中输入一些内容然后清除输入，你应该会看到一个错误，如下所示：
- en: '![](img/B18469_08_06.png)'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_08_06.png)'
- en: 'Figure 8.6: ng-reactive-forms app with form validation'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.6：具有表单验证的ng-reactive-forms应用
- en: And if you try giving it the wrong value, you’ll see a different error.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你尝试给它错误的值，你会看到一个不同的错误。
- en: Great! Within a few minutes, we were able to create our Reactive form in Angular
    with form validation. See the next section to understand how it works.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！在几分钟内，我们就能在Angular中创建带有表单验证的响应式表单。参见下一节了解它是如何工作的。
- en: How it works…
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: To work with reactive forms in Angular, we need to import the `ReactiveFormsModule`
    in the components in the case of standalone components, and in the `NgModule`
    if you’re using modules. In the recipe, we do exactly that, i.e., import the `ReactiveFormsModule`
    in the `VersionControlComponent` class’s `imports` array. After that, we create
    a `FormGroup`, which is a Reactive form, and it takes an object as an argument
    for the constructor function. The object passed to the constructor can have further
    `FormControl`, nested form groups, and `FormArray`, etc. because they all inherit
    the `AbstractControl` class, as shown in *Figure 8.6*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Angular中使用响应式表单，对于独立组件，我们需要在组件中导入`ReactiveFormsModule`，如果你使用模块，则在`NgModule`中导入。在配方中，我们正是这样做的，即在`VersionControlComponent`类的`imports`数组中导入`ReactiveFormsModule`。之后，我们创建一个`FormGroup`，这是一个响应式表单，它将一个对象作为构造函数的参数。传递给构造函数的对象可以具有进一步的`FormControl`，嵌套表单组，以及`FormArray`等，因为它们都继承自`AbstractControl`类，如图*8.6*所示。
- en: '![](img/B18469_08_07.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18469_08_07.png)'
- en: 'Figure 8.7: Base class AbstractControl being inherited'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：基类AbstractControl正在被继承
- en: 'In our recipe, we provide a key named `version` against a `FormControl`. The
    `FormControl` constructor method takes two arguments in our recipe; the first
    one is the default value, and the second is an array of `Validators`. Notice that
    we’re using the following validators:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配方中，我们为`version`提供了一个键名`version`。在我们的配方中，`FormControl`构造函数方法接受两个参数；第一个是默认值，第二个是`Validators`数组。请注意，我们正在使用以下验证器：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Also, notice that the pattern we’re using to validate semantic versioning is
    `([0-9]+)\.([0-9]+)\.([0-9]+)`. We then use the `FormGroup` (i.e., the `versionForm`
    variable) in the template on the `<form>` element, using the `[formGroup]` binding.
    We then bind the `version` `FormControl` in the template using the `formControlName`
    attribute. We handle the form submission using the `(ngSubmit)` listener on the
    `<form>` element. In the `VersionControlComponent` class, we have the `formSubmit`
    method to handle the form submission. This is also what we bind the event listener
    to in the template. When this method is called, we check if the form is valid.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们用于验证语义版本的模式是`([0-9]+)\.([0-9]+)\.([0-9]+)`。然后我们在模板中的`<form>`元素上使用`FormGroup`（即`versionForm`变量），使用`[formGroup]`绑定。然后我们使用`formControlName`属性在模板中绑定`version`
    `FormControl`。我们使用`<form>`元素上的`(ngSubmit)`监听器处理表单提交。在`VersionControlComponent`类中，我们有`formSubmit`方法来处理表单提交。这也是我们在模板中绑定事件监听器的地方。当此方法被调用时，我们检查表单是否有效。
- en: The validation on each `FormGroup`, `FormArray`, or `FormControl` happens on
    the `change`, `blur`, or `submit` event. And since they are inherited from the
    `AbstractControl` class, they can be configured via the `updateOn` property on
    the `AbstractControl`. In our case, the validation happens on `change` by default.
    If the form is not valid, we simply do not do anything. Otherwise, we set the
    value of the `versionName` property, which adds a new log to the logs list.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`FormGroup`、`FormArray`或`FormControl`的验证发生在`change`、`blur`或`submit`事件上。由于它们继承自`AbstractControl`类，它们可以通过`AbstractControl`上的`updateOn`属性进行配置。在我们的情况下，验证默认发生在`change`上。如果表单无效，我们简单地不做任何事情。否则，我们设置`versionName`属性的值，这将在日志列表中添加一条新记录。
- en: Finally, we show the errors based on the form validation in the template, using
    the `errors`property on the `version` form control. When the form is empty after
    making any initial change to it, the `errors` object on the form control gets
    the `required` property set to `true`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们展示了基于模板表单验证的错误，使用`version`表单控件上的`errors`属性。当对表单进行任何初始更改后，表单控件上的`errors`对象将`required`属性设置为`true`。
- en: When the user adds a value to the input, the `required` property is removed,
    and the validation of `pattern` gets triggered, and if the pattern `([0-9]+)\.([0-9]+)\.([0-9]+)`
    doesn’t match the value of the input, we get the `pattern` property added to the
    form control’s `errors` object. Notice that in *step 8*, we use these properties
    from the `errors` object to show the relevant error.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户向输入框添加值时，`required`属性被移除，并触发`pattern`验证，如果模式`([0-9]+)\.([0-9]+)\.([0-9]+)`与输入值不匹配，我们将在表单控件的`errors`对象中添加`pattern`属性。注意，在*步骤8*中，我们使用`errors`对象中的这些属性来显示相关错误。
- en: See also
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Angular’s guide to reactive forms: [https://angular.io/guide/reactive-forms](https://angular.io/guide/reactive-forms)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular的响应式表单指南：[https://angular.io/guide/reactive-forms](https://angular.io/guide/reactive-forms)
- en: Testing forms in Angular
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Angular中测试表单
- en: To make sure we build robust and bug-free forms for end users, it is a really
    good idea to have tests relating to your forms. It makes code more resilient and
    less prone to errors. In this recipe, you’ll learn how to test your template-driven
    forms using unit tests.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们为最终用户构建健壮且无错误的表单，拥有与您的表单相关的测试是一个非常好的主意。这使得代码更具弹性，更不容易出错。在这个菜谱中，您将学习如何使用单元测试测试您的模板驱动表单。
- en: Getting ready
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter08/ng-testing-forms`
    inside the cloned repository:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用程序位于克隆的仓库中的`start/apps/chapter08/ng-testing-forms`目录内：
- en: Open the code repository in your code editor.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project along with the backend server:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目及其后端服务器：
- en: '[PRE18]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用程序，您应该看到以下内容：
- en: '![](img/B18469_08_08.png)'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_08_08.png)'
- en: 'Figure 8.8: ng-testing-forms app running on http://localhost:4200'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.8：ng-testing-forms 应用程序在 http://localhost:4200 上运行
- en: Now that we have the app running locally, let’s see the steps involved in this
    recipe in the next section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地上运行了应用程序，让我们在下一节中查看这个菜谱涉及的步骤。
- en: How to do it…
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We have an app that contains three different components. The first one has
    a template-driven form, the second one has a reactive form with validations, and
    the third has a reactive form with both synchronous and asynchronous validations.
    The implementation of all three of them is identical, except the third component’s
    validation kicks in as soon as the form is dirty instead of waiting to be submitted.
    The form also has validations applied to the inputs. Let us start looking into
    how we can test this form:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个包含三个不同组件的应用程序。第一个有一个模板驱动表单，第二个有一个带有验证的响应式表单，第三个有一个带有同步和异步验证的响应式表单。这三个组件的实现都是相同的，除了第三个组件的验证会在表单变脏时立即启动，而不是等待提交。表单也对输入应用了验证。让我们开始探讨如何测试这个表单：
- en: 'First, run the following command to run the unit tests:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，运行以下命令来运行单元测试：
- en: '[PRE19]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once the command is run, you should see all the tests passing on the console
    as follows:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命令运行后，您应该在控制台上看到所有测试通过，如下所示：
- en: '![](img/B18469_08_09.png)'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_08_09.png)'
- en: 'Figure 8.9: Unit tests running with ng-testing-forms'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.9：使用 ng-testing-forms 运行的单元测试
- en: 'Let us write the tests for the template-driven form. This is easy. We will
    update the `version-control-tdf.component.spec.ts` file, as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写模板驱动表单的测试。这很简单。我们将更新`version-control-tdf.component.spec.ts`文件，如下所示：
- en: '[PRE20]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you look at the tests now, you should see all the tests passing as follows:'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您现在查看测试，您应该看到所有测试都通过，如下所示：
- en: '![](img/B18469_08_10.png)'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_08_10.png)'
- en: 'Figure 8.10: First test for template-driven forms passing'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.10：模板驱动表单的第一个测试通过
- en: 'Let’s add another test to the file. This will test if we are able to see the
    error message of the required input. Let’s update the `version-control-tdf.component.spec.ts`
    file, as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在文件中添加另一个测试。这个测试将检查我们是否能够看到必填输入的错误消息。让我们更新`version-control-tdf.component.spec.ts`文件，如下所示：
- en: '[PRE21]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s add one more test. This will test if we are able to see the message for
    the pattern of the version being valid. Add the following test to the same file:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再添加一个测试。这个测试将检查我们是否能够看到版本模式有效时的消息。将以下测试添加到同一文件中：
- en: '[PRE22]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Great! You should see all the tests still passing. The fun fact is that the
    tests are identical for the Reactive form (with synchronous validators only) example
    as well.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 太好了！你应该看到所有测试仍然通过。有趣的事实是，对于只包含同步验证器的响应式表单（Reactive form）示例，测试也是相同的。
- en: Copy all the three tests we added from *step 2* to *step 4* to the file `version-control-rf.component.spec.ts`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们从*步骤 2*到*步骤 4*添加的所有三个测试复制到文件`version-control-rf.component.spec.ts`中。
- en: Now comes the tricky part, i.e., working with `async` validators. We cannot
    just copy and paste the tests for this one and expect the tests to pass when we
    have an incorrect version provided in the form. We need some additional work to
    do in this case. First, copy the same tests from the `version-control-tdf.component.spec.ts`
    file into the `version-control-rf-async.component.spec.ts` file.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是棘手的部分，即处理`async`验证器。我们不能简单地复制粘贴这个测试，并期望在表单中提供错误版本时测试通过。在这种情况下，我们需要做一些额外的工作。首先，将`version-control-tdf.component.spec.ts`文件中的相同测试复制到`version-control-rf-async.component.spec.ts`文件中。
- en: 'You will notice that we have two tests failing now, as follows:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会注意到现在有两个测试失败了，如下所示：
- en: '![](img/B18469_08_11.png)'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_08_11.png)'
- en: 'Figure 8.11: Tests failing for a form with asynchronous validators, using a
    service'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.11：具有异步验证器的表单测试失败，使用服务
- en: 'We are going to mock the `FormValidationService` for our tests. Update the
    `version-control-rf-async.component.spec.ts`, as follows:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将模拟 `FormValidationService` 进行我们的测试。按照以下方式更新 `version-control-rf-async.component.spec.ts`
    文件：
- en: '[PRE23]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let us provide our mock service to the `TestBed` for the tests in the same
    file, as follows:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将我们的模拟服务提供给同一文件中的 `TestBed` 进行测试，如下所示：
- en: '[PRE24]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With the above change, the tests `'should submit the form with valid version'`
    and `'should show required error'` should pass. Yay! However, the last test failed.
    We will fix that.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过上述更改，测试 `'应该提交带有有效版本的表单'` 和 `'应该显示必需错误'` 应该通过。太好了！然而，最后一个测试失败了。我们将修复它。
- en: 'Let’s update the final failing test. We are going to update our `FormValidationServiceMock`
    object to return a `pattern` error if there is an invalid input. Update the file
    as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更新最终的失败测试。我们将更新我们的 `FormValidationServiceMock` 对象，使其在输入无效时返回一个 `pattern`
    错误。按照以下方式更新文件：
- en: '[PRE25]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And voila! All of the tests should be passing now, as follows:'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 哇！现在所有的测试都应该通过了，如下所示：
- en: '![](img/B18469_08_12.png)'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_08_12.png)'
- en: 'Figure 8.12: All tests passing for the recipe'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.12：配方中所有测试通过
- en: Awesome! You now know a bunch of techniques to test your Angular forms. However,
    some of these techniques might still require some explanation. See the next section
    to understand how it all works.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你现在已经了解了一堆测试你的 Angular 表单的技术。然而，其中一些技术可能还需要一些解释。参见下一节了解这一切是如何工作的。
- en: How it works…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Testing Angular forms can be a bit of a challenge, as it depends on how complex
    the form is, what use cases you want to test, and how complex those use cases
    are. This is also true for cases where you have several dependencies to work with.
    In our recipe, we started with the template-driven forms, and it was easy for
    us to test them, since the component has a `ViewChild()` of the type `NgForm`.
    This makes it easier to write our first test that sets the value of the `version`
    form control. Then, we click the **Submit** button and expect the component’s
    `versionName` property value to be the one we entered in the form. Easy peasy!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 Angular 表单可能有点挑战性，因为它取决于表单的复杂程度，你想要测试哪些用例，以及这些用例的复杂程度。对于需要处理多个依赖项的情况也是如此。在我们的配方中，我们从模板驱动的表单开始，对我们来说测试它们很容易，因为组件有一个
    `ViewChild()` 类型为 `NgForm`。这使得我们编写第一个测试来设置 `version` 表单控件的值变得容易。然后，我们点击 **提交**
    按钮，并期望组件的 `versionName` 属性值是我们表单中输入的那个。简单得很！
- en: For the second test, we first set the value of the form to `2.2.4`, and then
    we empty the form by setting the value to an empty string. Then, we submit the
    form and expect the value of the component’s `versionName` property to remain
    unchanged and still be `0.0.0`. However, what we also check is that, inside the
    form, we can see the error that says, `'Version number is required'`. Notice that
    we use the `fixture.debugElement.nativeElement.querySelector` method to get the
    desired error element, and then we check its `textContent` value.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二次测试，我们首先将表单的值设置为 `2.2.4`，然后通过将值设置为空字符串来清空表单。然后，我们提交表单并期望组件的 `versionName`
    属性保持不变，仍然是 `0.0.0`。然而，我们还检查的是，在表单内部，我们可以看到显示 `'版本号是必需的'` 错误。请注意，我们使用 `fixture.debugElement.nativeElement.querySelector`
    方法获取所需的错误元素，然后检查其 `textContent` 值。
- en: For the test to check the pattern, we do the same as for the second test, but
    instead of emptying the input, we provide `'``invalid input'` as the new value
    to the form control. The template-driven form picks it and shows the error `'Version
    number does not match the pattern (x.x.x)'`, which is what we expect in the test
    as well.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查模式，我们与第二次测试相同，但不是清空输入，而是将 `'``invalid input'` 作为新值提供给表单控件。由模板驱动的表单选择它并显示错误
    `'版本号不匹配模式（x.x.x）'`，这是我们测试中期望的。
- en: The same three tests work exactly the same as the `Reactive Forms` example we
    have. The difference this time is that the `versionForm` property in the component
    is not `NgForm` but, rather, a `FormGroup`. It is amazing that Angular has the
    same API (i.e., the same methods) in both `NgForm`and `FormGroup`to set and retrieve
    the values. This is because it creates a top-level `FormGroup` behind the scenes,
    thus making our tests the same.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前在 `Reactive Forms` 示例中所使用的三个测试完全相同。这次的不同之处在于，组件中的 `versionForm` 属性不是 `NgForm`，而是
    `FormGroup`。令人惊讶的是，Angular 在 `NgForm` 和 `FormGroup` 中都提供了相同的 API（即相同的方法）来设置和检索值。这是因为它在幕后创建了一个顶层的
    `FormGroup`，从而使我们的测试保持一致。
- en: For the tests with `async` validators, we did something special. Apart from
    copying and pasting the tests from the other examples, we had to mock the `FormValidationService`.
    This is because this example had an asynchronous validator function, which comes
    from the `FormValidationService`class, and it is a general best practice to mock
    all the dependencies of a unit so that we can purely test it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用 `async` 验证器的测试，我们做了些特别的事情。除了从其他示例中复制粘贴测试之外，我们还需要模拟 `FormValidationService`。这是因为这个示例有一个来自
    `FormValidationService` 类的异步验证函数，并且模拟单元的所有依赖项是一个通用的最佳实践，这样我们就可以纯粹地测试它。
- en: We start by creating a stub named `FormValidationServiceMock` (we’ll learn more
    about stubs in *Chapter 10* ,*Writing Unit Tests in Angular with Jest*). Then,
    we provide this stub in the `TestBed` against the `FormValidationService` class.
    Finally, we make sure that our `versionValidator` method in the stub returns the
    correct error when the input is not valid. And that’s it. Without many changes
    in the tests themselves, we are able to test all three kinds of forms with minor
    adjustments. I hope you learned quite a few techniques in this recipe.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为 `FormValidationServiceMock` 的存根（我们将在 *第 10 章* 中学习更多关于存根的知识，*使用 Jest
    在 Angular 中编写单元测试*）。然后，我们将这个存根提供给 `TestBed`，针对 `FormValidationService` 类。最后，我们确保存根中的
    `versionValidator` 方法在输入无效时返回正确的错误。就这样。在测试本身没有太多变化的情况下，我们能够通过微小的调整测试所有三种类型的表单。我希望你在本菜谱中学到了很多技术。
- en: See also
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Testing* *template-driven forms*: [https://angular.io/guide/forms-overview#testing-template-driven-forms](https://angular.io/guide/forms-overview#testing-template-driven-forms)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试* *模板驱动表单*：[https://angular.io/guide/forms-overview#testing-template-driven-forms](https://angular.io/guide/forms-overview#testing-template-driven-forms)'
- en: Server-side validation using asynchronous validator functions
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异步验证函数进行服务器端验证
- en: Form validations are straightforward in Angular, with the reason being the super-awesome
    validators that Angular provides out of the box. These validators are synchronous,
    meaning that as soon as you change the input, the validators kick in and provide
    you with information about the validity of the values right away. However, sometimes,
    you might rely on some validations from a backend API or have some asynchronous
    logic that you need to execute to validate the form value. These situations would
    require something called asynchronous validators. In this recipe, you’re going
    to create your first asynchronous validator.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，表单验证非常直接，原因在于 Angular 提供的超级棒的验证器。这些验证器是同步的，这意味着只要你改变输入，验证器就会立即启动并提供有关值有效性的信息。然而，有时你可能依赖于来自后端
    API 的某些验证，或者需要执行一些异步逻辑来验证表单值。这些情况将需要称为异步验证器的东西。在这个菜谱中，你将创建你的第一个异步验证器。
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter08/ng-rf-async-validator`
    inside the cloned repository:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆的仓库中的 `start/apps/chapter08/ng-rf-async-validator`：
- en: Open the code repository in your code editor.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project along with the backend server:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目及其后端服务器：
- en: '[PRE26]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会在新浏览器标签页中打开应用，你应该会看到以下内容：
- en: '![](img/B18469_08_13.png)'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_08_13.png)'
- en: 'Figure 8.13: Asynchronous validators app running on http://localhost:4200'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.13：异步验证器应用在 http://localhost:4200 上运行
- en: Now that we have the app running, let’s see the steps involved in this recipe
    in the next section.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经运行了应用，让我们在下一节中查看本菜谱所涉及的步骤。
- en: How to do it…
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We already have the backend with an endpoint that can accept a version as a
    query parameter, returning a `boolean` for if the provided version is a valid
    version according to the pattern (`x.x.x`) and is a newer version than the previously
    provided one. We’ll create an `async` validator to make sure that the new releases
    have a valid version. Let’s begin:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个后端，它有一个可以接受版本作为查询参数的端点，返回一个`boolean`，表示提供的版本是否根据模式（`x.x.x`）是有效的版本，并且比之前提供的版本新。我们将创建一个`async`验证器来确保新版本有一个有效的版本。让我们开始：
- en: 'First, we will modify the `VersionService` class in the `version.service.ts`
    file, as follows, to add a method to validate the form input via the `http://localhost:3333/api/version/validate`
    endpoint:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将修改`version.service.ts`文件中的`VersionService`类，如下所示，以添加一个通过`http://localhost:3333/api/version/validate`端点验证表单输入的方法：
- en: '[PRE27]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will now create an **Async Validator Function** (`AsyncValidatorFn`) inside
    the `VersionService` class. This is something we will bind later to the form in
    the app. Let us update the `version.service.ts` file, as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在`VersionService`类中创建一个**异步验证函数**（`AsyncValidatorFn`）。这是我们稍后将在应用程序中的表单上绑定的事情。让我们更新`version.service.ts`文件，如下所示：
- en: '[PRE28]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We will use the `versionValidator` method we just created inside the `VersionControlComponent`
    class with the `versionForm`. To do that, let’s modify the `version-control.component.ts`
    file, as follows:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用我们刚刚在`VersionControlComponent`类中创建的`versionValidator`方法，与`versionForm`一起使用。为此，让我们修改`version-control.component.ts`文件，如下所示：
- en: '[PRE29]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you now try submitting a version equal to or lower than the last submitted
    one, you will receive an error, as follows:'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在尝试提交一个等于或低于上次提交版本的版本，你将收到一个错误，如下所示：
- en: '![](img/B18469_08_14.png)'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_08_14.png)'
- en: 'Figure 8.14: Error being shown when a lower or equal version number is provided'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.14：提供较低或相等的版本号时显示的错误
- en: Cool! So, you now know how to create an asynchronous validator function in Angular
    for form validation within reactive forms. Since you’ve finished the recipe, refer
    to the next section to see how this works.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！所以，你现在知道如何在Angular中创建异步验证函数来进行响应式表单验证。既然你已经完成了这个菜谱，请参考下一节，看看它是如何工作的。
- en: How it works...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Angular provides an effortless way to create `async` validator functions, and
    they’re handy too. We use an `async` validator function when there needs to be
    a validation that can be time-consuming and we don’t want to block the main thread,
    or when we rely on a backend service for validation. For example, in this recipe,
    we started by creating the validator method named `versionValidator` inside a
    new service, called `VersionService`. Notice that we are using a couple of RxJS
    operators in the method, including `timer`, `switchMap`, and `map`. We use the
    `timer` operator to debounce and wait for the user to stop typing for **500**
    milliseconds. We then use the `switchMap` operator combined with the `validateVersion`
    method to make an HTTP call to the backend, validating the version. The benefit
    of `switchMap` here is that it cancels out existing HTTP calls, if any. Then,
    we use the `map` operator to remove the error from the HTTP call. If there’s no
    error, we return an empty object from the map function’s callback. If we have
    an error, we set the `[error]` as `true` in the `errors` object, as shown in *step
    4*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了一个轻松创建`async`验证函数的方法，而且它们也很方便。当我们需要执行可能耗时的验证且不想阻塞主线程，或者我们依赖于后端服务进行验证时，我们会使用`async`验证函数。例如，在这个菜谱中，我们首先在一个名为`VersionService`的新服务中创建了一个名为`versionValidator`的验证器方法。请注意，我们在该方法中使用了一些RxJS运算符，包括`timer`、`switchMap`和`map`。我们使用`timer`运算符来去抖动并等待用户停止输入**500**毫秒。然后，我们使用`switchMap`运算符与`validateVersion`方法结合，向后端发起HTTP调用，验证版本。`switchMap`在这里的好处是它会取消现有的HTTP调用（如果有的话）。然后，我们使用`map`运算符从HTTP调用中移除错误。如果没有错误，我们从`map`函数的回调中返回一个空对象。如果有错误，我们在`errors`对象中将`[error]`设置为`true`，如*步骤4*所示。
- en: After creating the validator function, we attached it to the form control for
    the version name by using the `FormControl.setAsyncValidators` method in the `VersionControlComponent`
    class. We then used the validation errors, named `pattern` and `oldVersion`, in
    the template to show the relevant error message on the UI.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 创建验证函数后，我们通过在`VersionControlComponent`类中使用`FormControl.setAsyncValidators`方法将其附加到版本名称的表单控件上。然后，我们在模板中使用名为`pattern`和`oldVersion`的验证错误来显示相关的错误消息。
- en: See also
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '`AsyncValidator` Angular docs: [https://angular.io/api/forms/AsyncValidator#provide-a-custom-async-validator-directive](https://angular.io/api/forms/AsyncValidator#provide-a-custom-async-validator-directive)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsyncValidator` Angular 文档：[https://angular.io/api/forms/AsyncValidator#provide-a-custom-async-validator-directive](https://angular.io/api/forms/AsyncValidator#provide-a-custom-async-validator-directive)'
- en: Implementing complex forms with reactive FormArray
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用响应式 FormArray 实现复杂表单
- en: This is definitely one of the most requested recipes from the readers of the
    first edition of *Angular Cookbook*. In this recipe, we’ll work with reactive
    Forms and specifically, the `FormArray` class from reactive forms. We’re going
    to implement a complex form, which has a list of projects that can be submitted
    with reactive forms. The user will be able to add as many projects as they want
    and will be able to remove the ones they don’t want.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这无疑是第一版 *Angular Cookbook* 读者最常请求的食谱之一。在这个食谱中，我们将与响应式表单一起工作，特别是响应式表单中的 `FormArray`
    类。我们将实现一个复杂的表单，该表单可以提交一系列项目。用户将能够添加他们想要的任意数量的项目，并且可以删除他们不需要的项目。
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter08/ng-form-arrays`
    inside the cloned repository:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆的仓库中的 `start/apps/chapter08/ng-form-arrays` 目录内：
- en: Open the code repository in your code editor.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE30]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用，你应该会看到以下内容：
- en: '![](img/B18469_08_15.png)'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_08_15.png)'
- en: 'Figure 8.15: reactive FormArray app running on http://localhost:4200'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.15：运行在 http://localhost:4200 的响应式 FormArray 应用
- en: Now that we have the app running locally, let’s see the steps involved in this
    recipe in the next section.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用，让我们在下一节中查看这个食谱所涉及的步骤。
- en: How to do it…
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We have an app that already implements a Reactive form. However, we can only
    add one project so far. We will use reactive `FormArray` to let the user submit
    multiple projects, and we will use the Reactive `FormBuilder`, which is a nice
    little API from the `@angular/forms` package that makes it easy to create and
    maintain reactive forms in Angular. Let us begin:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个已经实现了响应式表单的应用。然而，到目前为止我们只能添加一个项目。我们将使用响应式 `FormArray` 允许用户提交多个项目，并且我们将使用响应式
    `FormBuilder`，这是 `@angular/forms` 包中的一个很好的小 API，它使得在 Angular 中创建和维护响应式表单变得容易。让我们开始吧：
- en: 'First of all, let’s use the Reactive `FormBuilder` to add a `FormArray` to
    the existing Reactive form in the `portfolio-form.component.ts` file, as follows:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们使用响应式 `FormBuilder` 在 `portfolio-form.component.ts` 文件中向现有的响应式表单添加一个 `FormArray`，如下所示：
- en: '[PRE31]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that we have the `projects` `FormArray`, let’s use that in the template
    so that we can show the form inputs for the projects, according to the form array.
    Let’s modify the `portfolio-form.component.html` file, as follows:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了 `projects` `FormArray`，让我们在模板中使用它，以便我们可以根据表单数组显示项目的表单输入。让我们修改 `portfolio-form.component.html`
    文件，如下所示：
- en: '[PRE32]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You’ll notice that the object on the right in the app has a `projects` array
    now. However, we can see no inputs for the projects at the moment. That’s because
    the form array is empty, as shown in the following figure:'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会注意到应用右侧的对象现在有一个 `projects` 数组。然而，我们目前看不到任何关于项目的输入。这是因为表单数组是空的，如下面的图所示：
- en: '![](img/B18469_08_16.png)'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_08_16.png)'
- en: 'Figure 8.16: reactive FormArray app running on http://localhost:4200'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.16：运行在 http://localhost:4200 的响应式 FormArray 应用
- en: 'We’ll add one form group to the form array by default when the app starts.
    To do this, modify the `portfolio-form.component.ts` file, as follows:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用启动时，我们将默认向表单数组中添加一个表单组。为此，修改 `portfolio-form.component.ts` 文件，如下所示：
- en: '[PRE33]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you look at the app now, you should see one set of inputs for the projects,
    as shown in the following figure:'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在查看应用，你应该会看到一组项目的输入，如下面的图所示：
- en: '![](img/B18469_08_17.png)'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_08_17.png)'
- en: 'Figure 8.17: One set of inputs for projects by default'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.17：默认情况下的一组项目输入
- en: 'Let’s add a button for the user to be able to add more projects. We’ll modify
    the `portfolio-form.component.html` file, as follows:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个按钮，让用户能够添加更多项目。我们将修改 `portfolio-form.component.html` 文件，如下所示：
- en: '[PRE34]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With the code above, you should see new project inputs appearing with the click
    of the `+` button.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过上面的代码，你应该会在点击 `+` 按钮时看到新的项目输入出现。
- en: 'Let’s add our final feature for this recipe, which is showing buttons to remove
    the project’s input row. We’ll first add a method in the `portfolio-form.component.ts`
    file that receives the index of the row to be removed as an argument:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为这个菜谱添加最后一个特性，即显示用于移除项目输入行的按钮。我们首先在 `portfolio-form.component.ts` 文件中添加一个方法，该方法接收要移除的行的索引作为参数：
- en: '[PRE35]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we’ll update the template to add the `Remove` button. Update the `portfolio-form.component.html`
    file, as follows:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将更新模板以添加 `Remove` 按钮。更新 `portfolio-form.component.html` 文件，如下所示：
- en: '[PRE36]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you now look at the app, you should be able to add or remove projects to
    the form as you like, as shown in the following figure:'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在查看应用程序，你应该能够根据需要添加或移除项目到表单中，如下面的图所示：
- en: '![](img/B18469_08_18.png)'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_08_18.png)'
- en: 'Figure 8.18: Final result with form arrays'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.18：带有表单数组的最终结果
- en: Great! You now know how to work with reactive `FormArray`. Refer to the next
    section to understand how it all works.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你现在已经知道如何使用响应式 `FormArray`。参考下一节了解它是如何工作的。
- en: How it works…
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Angular’s `FormArray` is an amazing tool built into the reactive Forms in Angular.
    It aggregates all values of each child `FormControl` or `FormGroup` into an array.
    The beauty of the `FormArray` is that if any one of the child `FormControls` is
    invalid, the whole array becomes invalid. In this recipe, we start by using the
    `FormBuilder` from the `ReactiveFormsModule` in the `PortfolioFormComponent` class.
    We initialize it with an empty `FormArray` and then push one `FormGroup` to it
    when the component mounts (using the `ngOnInit`method). This is so we can see
    one set of form inputs for the projects. Note that we use the `addNewProject`
    method for this. Also note that we use a `getter` function, named `projectsFormArr`,
    so that we can easily access the `FormArray` to be able to loop over it, add Form
    Groups to it, and remove the desired `FormGroups` from it when needed. We then
    loop over the `projectsFormArr.controls` array so that we can display the inputs
    via the HTML template, using the `*ngFor` directive.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 的 `FormArray` 是 Angular 响应式表单中内置的一个神奇工具。它将每个子 `FormControl` 或 `FormGroup`
    的所有值聚合到一个数组中。`FormArray` 的美妙之处在于，如果任何一个子 `FormControls` 无效，整个数组都会变为无效。在这个菜谱中，我们首先在
    `PortfolioFormComponent` 类中使用 `ReactiveFormsModule` 中的 `FormBuilder`。我们用空 `FormArray`
    初始化它，然后在组件挂载时（使用 `ngOnInit` 方法）向其中推送一个 `FormGroup`。这样我们就可以看到一组项目表单输入。请注意，我们使用
    `addNewProject` 方法来做这件事。还请注意，我们使用了一个名为 `projectsFormArr` 的 `getter` 函数，这样我们就可以轻松访问
    `FormArray`，以便在需要时遍历它、向其中添加表单组以及从其中移除所需的 `FormGroups`。然后我们遍历 `projectsFormArr.controls`
    数组，以便通过 HTML 模板使用 `*ngFor` 指令显示输入。
- en: Then, we modify the template to add the + button so that we can add more projects
    to the form array. Note the statement in the `*ngFor` has `let isLast = last`.
    The `*ngFor` directive provides us with the first and last variables automatically,
    so we can use them in our template. This statement creates a variable named `isLast`
    for us, and it assigns the value of the `last` variable provided by the `*ngFor`
    directive (which is a Boolean) to it. This is so we can show the + button only
    on the last row instead of on every row.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们修改模板以添加 + 按钮，这样我们就可以向表单数组中添加更多项目。注意 `*ngFor` 中的语句有 `let isLast = last`。`*ngFor`
    指令自动提供第一个和最后一个变量，因此我们可以在模板中使用它们。这个语句为我们创建了一个名为 `isLast` 的变量，并将 `*ngFor` 指令提供的
    `last` 变量的值（一个布尔值）赋给它。这样我们就可以只在最后一行显示 + 按钮，而不是在每一行都显示。
- en: Finally, we add the `remove` button to each row except for the last one so we
    can remove the respective `FormGroup` from the `FormArray`. Note that here we
    also add `let i = index` to the template in the `*ngFor` directive. This is because
    our `removeProject` method in the TypeScript file expects the index of the `FormGroup`
    in the `FormArray` to be passed in it when it is called. Hence, we’re able to
    get the index for each `FormGroup` from the `*ngFor` directive and can pass the
    index to the `removeProject` method. We use `[hidden]="isLast"` on each `remove`
    button so that it is hidden onthe last row only. This is because we show the +
    button on the last row and we need to have at least one empty row for the projects.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将 `remove` 按钮添加到除了最后一行之外的所有行，这样我们就可以从 `FormArray` 中移除相应的 `FormGroup`。请注意，在这里我们还在模板中的
    `*ngFor` 指令中添加了 `let i = index`。这是因为我们的 TypeScript 文件中的 `removeProject` 方法在调用时期望传入
    `FormArray` 中 `FormGroup` 的索引。因此，我们能够从 `*ngFor` 指令中获取每个 `FormGroup` 的索引，并将其传递给
    `removeProject` 方法。我们在每个 `remove` 按钮上使用 `[hidden]="isLast"` 以使其仅在最后一行隐藏。这是因为我们在最后一行显示了
    + 按钮，并且我们需要至少有一行空行用于项目。
- en: See also
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Angular `FormArray`: [https://angular.io/api/forms/FormArray](https://angular.io/api/forms/FormArray)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular `FormArray`：[https://angular.io/api/forms/FormArray](https://angular.io/api/forms/FormArray)
- en: Writing your own custom form control using ControlValueAccessor
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ControlValueAccessor编写自定义表单控件
- en: Angular forms are great. While they support the default HTML tags like `input`,
    `textarea`, etc., sometimes, you might want to define your own components that
    take a value from the user. What if your components could work seamlessly with
    Angular forms, i.e., using f`ormControlName`, `ngModel`, and so on? That would
    be cool, right?
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Angular表单很棒。虽然它们支持默认的HTML标签如`input`、`textarea`等，但有时你可能想定义自己的组件，这些组件可以从用户那里获取值。如果你的组件能够无缝地与Angular表单一起工作，即使用`formControlName`、`ngModel`等，那会怎么样？那会很酷，对吧？
- en: In this recipe, you’ll learn how to create a component with your own custom
    form control using the `ControlValueAccessor` API, allowing you to use your component
    with both template-driven forms and reactive forms.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何使用`ControlValueAccessor` API创建一个具有自定义表单控件的组件，允许你使用你的组件与模板驱动表单和响应式表单一起使用。
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'The app that we are going to work with resides in `start/apps/chapter08/ng-form-cva`
    inside the cloned repository:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆的仓库`start/apps/chapter08/ng-form-cva`中：
- en: Open the code repository in your code editor.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE37]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用，你应该看到以下内容：
- en: '![](img/B18469_08_19.png)'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_08_19.png)'
- en: 'Figure 8.19: Custom form control app running on http://localhost:4200'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.19：运行在http://localhost:4200上的自定义表单控件应用
- en: Now that we have the app running locally, let’s see the steps involved in this
    recipe in the next section.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用，让我们在下一节中查看这个菜谱涉及的步骤。
- en: How to do it…
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We have a simple Angular app. It has two inputs and a **Submit** button. The
    inputs are for a review, and they ask the user to provide a value for the rating
    of this imaginary item and any comments the user wants to provide. We’ll convert
    the rating input into a custom `FormControl` using the `ControlValueAccessor`
    API. Let’s get started:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个简单的Angular应用。它有两个输入和一个**提交**按钮。输入用于评论，并要求用户为这个假想项目的评分提供一个值，以及用户想要提供的任何评论。我们将使用`ControlValueAccessor`
    API将评分输入转换为自定义`FormControl`。让我们开始吧：
- en: 'Let’s create a component for our custom `FormControl` Open the terminal in
    the project root and run the following command and select the `@nx/angular:component
    schematics` and “As provided” when asked:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为我们的自定义`FormControl`创建一个组件。在项目根目录中打开终端，并运行以下命令，当被询问时选择`@nx/angular:component
    schematics`和“按提供”：
- en: '[PRE38]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We’ll now create the `star` UI for the `rating` component. Modify the `rating.component.html`
    file, as follows:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将为`rating`组件创建`star` UI。按照以下方式修改`rating.component.html`文件：
- en: '[PRE39]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add the styles for the `rating` component to the `rating.component.scss` file
    as follows:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`rating`组件的样式添加到`rating.component.scss`文件中，如下所示：
- en: '[PRE40]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We also need to modify the `RatingComponent` class to introduce the necessary
    methods and properties. Let’s modify the `rating.component.ts` file, as follows:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要修改`RatingComponent`类，以引入必要的方法和属性。按照以下方式修改`rating.component.ts`文件：
- en: '[PRE41]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let’s import the `RatingComponent` class in the `HomeComponent` class because
    `RatingComponent` is a `standalone` component. Update the `home.component.ts`
    file, as follows:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`RatingComponent`是一个`standalone`组件，我们需要在`HomeComponent`类中导入`RatingComponent`类。更新`home.component.ts`文件，如下所示：
- en: '[PRE42]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we need to use this `rating` component instead of the input that we already
    have in the `home.component.html` file. Modify the file as follows:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要使用这个`rating`组件来替换`home.component.html`文件中已有的输入。按照以下方式修改文件：
- en: '[PRE43]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If you refresh the app now and hover over the stars, you can see the color
    change. The selected rating is also highlighted as follows:'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在刷新应用并悬停在星星上，你可以看到颜色变化。选定的评分也会按照以下方式突出显示：
- en: '![](img/B18469_08_20.png)'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_08_20.png)'
- en: 'Figure 8.20: Rating component with hovered stars'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.20：带有悬停星星的评分组件
- en: 'Let’s now implement the `ControlValueAccessor` interface for our `rating` component.
    It requires a couple of methods to be implemented. Modify the `rating.component.ts`
    file, as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来实现`ControlValueAccessor`接口，用于我们的`rating`组件。它需要实现几个方法。按照以下方式修改`rating.component.ts`文件：
- en: '[PRE44]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We’ll now add the required methods to disable the input when required and to
    set the value of the form control – in other words, the `setDisabledState` and
    `writeValue` methods. We’ll also add the `disabled` property to our `RatingComponent`
    class, as follows:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将添加必要的函数来在需要时禁用输入，并设置表单控件的值——换句话说，就是`setDisabledState`和`writeValue`方法。我们还将向`RatingComponent`类添加`disabled`属性，如下所示：
- en: '[PRE45]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We need to use the `disabled` property to prevent any UI changes when it is
    `true`. The value of the `value` variable should not be updated either. Modify
    the `rating.component.ts` file to do so, as follows:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要使用`disabled`属性来防止当它为`true`时进行任何UI更改。`value`变量的值也不应该被更新。修改`rating.component.ts`文件以实现这一点，如下所示：
- en: '[PRE46]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: With the above change, you’ll notice that hovering over the stars doesn’t do
    anything now because of the `disabled` property being set to `true`.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过上述更改，你会注意到由于`disabled`属性被设置为`true`，现在悬停在星星上不会做任何事情。
- en: 'Let’s make sure that we send the value of the `value` variable to `ControlValueAccessor`
    because that’s what we want to access later. Also, let’s set the `disabled` property
    back to `false`. Update the `selectRating` method in the `RatingComponent` class,
    as follows:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保我们将`value`变量的值发送到`ControlValueAccessor`，因为这是我们稍后想要访问的内容。同时，让我们将`disabled`属性重置为`false`。按照以下方式更新`RatingComponent`类中的`selectRating`方法：
- en: '[PRE47]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We need to tell Angular that our `RatingComponent` class has a `value` accessor;
    otherwise, using the `formControlName` attribute on the `<app-rating>` element
    will throw errors. Let’s add an `NG_VALUE_ACCESSOR` provider to the `RatingComponent`
    class’s decorator, as follows:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要告诉Angular我们的`RatingComponent`类有一个`value`访问器；否则，在`<app-rating>`元素上使用`formControlName`属性将引发错误。让我们在`RatingComponent`类的装饰器中添加一个`NG_VALUE_ACCESSOR`提供者，如下所示：
- en: '[PRE48]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you refresh the app now, select a rating, and hit the **Submit** button,
    you should see the values being logged, as follows:'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在刷新应用程序，选择一个评分，并点击**提交**按钮，你应该会看到如下所示的值被记录：
- en: '![](img/B18469_08_21.png)'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_08_21.png)'
- en: 'Figure 8.21: Form value logged using the custom form control'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.21：使用自定义表单控件记录的表单值
- en: Voilà! You just learned how to create a custom form control using `ControlValueAccessor`.
    Refer to the next section to understand how it works.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！你刚刚学会了如何使用`ControlValueAccessor`创建自定义表单控件。参考下一节以了解它是如何工作的。
- en: How it works…
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'We started the recipe by creating a component we can use to provide a rating
    for the review we submit. We started by adding the template and the styles for
    the `rating` component. Note that we are using an `[ngClass]` directive on each
    of the `star` elements to add the `rating__star--active` class conditionally.
    Let’s discuss each condition now:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从创建一个可以用来为我们提交的评论提供评分的组件开始。我们首先添加了`rating`组件的模板和样式。请注意，我们正在使用`[ngClass]`指令在每个`star`元素上条件性地添加`rating__star--active`类。现在让我们讨论每个条件：
- en: '`(isMouseOver && hoveredRating >= star)`: This condition relies on the `isMouseOver`
    and `hoveredRating` variables. The `isMouseOver` variable becomes `true` as soon
    as we mouse over any star and is turned back to `false` when we move away from
    the star. This means that it is only `true` when we’re hovering over a star. `hoveredRating`
    tells us which star we’re hovering over at any moment and is assigned the star’s
    value – in other words, a value from `1` to `5`. So, this condition is only `true`
    when we’re doing a mouseover, and the hovered star’s rating is greater than the
    value of the current star. So, if we’re hovering over the fourth star, all the
    stars from value `1` to `4` will be highlighted, as they’ll have the `rating__star--active`
    class conditionally assigned to them.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(isMouseOver && hoveredRating >= star)`: 这个条件依赖于`isMouseOver`和`hoveredRating`变量。`isMouseOver`变量在我们鼠标悬停在任意星星上时变为`true`，当我们从星星移开时变为`false`。这意味着它只有在悬停在星星上时才是`true`。`hoveredRating`告诉我们我们在任何时刻悬停在哪个星星上，并分配给星星的值——换句话说，一个从`1`到`5`的值。因此，这个条件只有在鼠标悬停时才为`true`，并且悬停的星星的评分大于当前星星的值。所以，如果我们悬停在第四颗星星上，所有从值`1`到`4`的星星都会被突出显示，因为它们将条件性地分配`rating__star--active`类。'
- en: '`(!isMouseOver && value >= star)`: This condition relies on the `isMouseOver`
    variable that we discussed previously and the `value` variable. The `value` variable
    holds the value of the selected rating, which is updated when we click on a star.
    So, this condition is applied when we’re not doing a mouseover, and we have the
    value of the `value` variable greater than the current star. This is especially
    beneficial when you have a greater value assigned to the `value` variable and
    try to hover over a star with a lesser value, in which case, all the stars with
    values greater than the hovered star will not be highlighted.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(!isMouseOver && value >= star)`: 这个条件依赖于我们之前讨论的`isMouseOver`变量和`value`变量。`value`变量包含所选评分的值，当我们在星星上点击时更新。因此，当我们在不进行鼠标悬停的情况下，并且`value`变量的值大于当前星星时，这个条件被应用。当你将更大的值分配给`value`变量并尝试悬停在具有较小值的星星上时，这尤其有益，在这种情况下，所有值大于悬停星星的星星都不会被突出显示。'
- en: 'Then, we used three events on each star, `mouseenter`, `mouseleave`, and `click`,
    and then used our `onRatingMouseEnter`, `onRatingMouseLeave`, and `selectRating`
    methods, respectively, for these events. All of this was designed to ensure that
    the entire UI is fluent and provides a good user experience. We then implemented
    the `ControlValueAccessor` interface for our `rating` component. When we do that,
    we need to define the `onChange` and `onTouched` methods as empty methods, which
    we did as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为每个星星使用了三个事件，`mouseenter`、`mouseleave`和`click`，然后分别使用我们的`onRatingMouseEnter`、`onRatingMouseLeave`和`selectRating`方法处理这些事件。所有这些设计都是为了确保整个UI流畅并提供良好的用户体验。然后我们为我们的`rating`组件实现了`ControlValueAccessor`接口。当我们这样做时，我们需要定义`onChange`和`onTouched`方法为空方法，我们按照以下方式实现：
- en: '[PRE49]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, we used the `registerOnChange` and `registerOnTouched` methods from `ControlValueAccessor`
    to assign our methods, as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`ControlValueAccessor`中的`registerOnChange`和`registerOnTouched`方法来分配我们的方法，如下所示：
- en: '[PRE50]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We registered these methods because whenever we make a change in our component
    and want to let `ControlValueAccessor` know that the value has changed, we need
    to call the `onChange` method ourselves. We do that in the `selectRating` method
    as follows, which makes sure that when we select a rating, we set the form control’s
    value to the value of the selected rating:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注册了这些方法，因为每当我们在组件中做出更改并希望让`ControlValueAccessor`知道值已更改时，我们需要自己调用`onChange`方法。我们在`selectRating`方法中这样做，如下所示，确保当我们选择一个评分时，我们将表单控件的值设置为所选评分的值：
- en: '[PRE51]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The other way around is when we need to know when the form control’s value
    is changed from outside the component. In this case, we need to assign the updated
    value to the `value` variable. We do that in the `writeValue` method from the
    `ControlValueAccessor` interface, as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种情况是我们需要知道表单控件的值是否从组件外部更改。在这种情况下，我们需要将更新后的值分配给`value`变量。我们在`ControlValueAccessor`接口的`writeValue`方法中这样做，如下所示：
- en: '[PRE52]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: What if we don’t want the user to provide a value for the rating? In other words,
    we want the rating form control to be disabled. For this, we use the `setDisabledState`
    method from the `ControlValueAccessor` interface, so whenever the form control’s
    `disabled` state is changed, we set the `disabled` property to reflect the changes.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想让用户为评分提供值呢？换句话说，我们希望评分表单控件被禁用。为此，我们使用`ControlValueAccessor`接口中的`setDisabledState`方法，这样每当表单控件的`disabled`状态发生变化时，我们就设置`disabled`属性以反映这些更改。
- en: 'Finally, we wanted Angular to know that this `RatingComponent` class has a
    value accessor. This is so that we can use the reactive forms API – specifically,
    the `formControlName` attribute with the `<app-rating>` selector – and use it
    as a form control. To do that, we provide our `RatingComponent` class as a provider
    to its `@Component` definition decorator, using the `NG_VALUE_ACCESSOR` injection
    token, as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望Angular知道这个`RatingComponent`类有一个值访问器。这样我们就可以使用响应式表单API——具体来说，使用`<app-rating>`选择器的`formControlName`属性——并将其用作表单控件。为此，我们将我们的`RatingComponent`类作为提供者提供给其`@Component`定义装饰器，使用`NG_VALUE_ACCESSOR`注入令牌，如下所示：
- en: '[PRE53]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Note that we’re using the `useExisting` property with the `forwardRef` method
    providing our `RatingComponent` class in it. We need to provide `multi: true`
    because Angular itself registers some value accessors using the `NG_VALUE_ACCESSOR`
    injection token, and there may also be third-party form controls.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，我们正在使用`useExisting`属性，并通过`forwardRef`方法提供我们的`RatingComponent`类。我们需要提供`multi:
    true`，因为Angular本身使用`NG_VALUE_ACCESSOR`注入令牌注册了一些值访问器，并且可能还有第三方表单控件。'
- en: 'Once we’ve set everything up, we use `formControlName` on our `rating` component
    in the `home.component.html` file, as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 一切设置完成后，我们在 `home.component.html` 文件中的 `rating` 组件上使用 `formControlName`，如下所示：
- en: '[PRE54]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: See also
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Custom form control in Angular by `thoughtram`: [https://blog.thoughtram.io/angular/2016/07/27/custom-form-controls-in-angular-2.html](https://blog.thoughtram.io/angular/2016/07/27/custom-form-controls-in-angular-2.html)'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 中的自定义表单控件，由 `thoughtram` 提供：[https://blog.thoughtram.io/angular/2016/07/27/custom-form-controls-in-angular-2.html](https://blog.thoughtram.io/angular/2016/07/27/custom-form-controls-in-angular-2.html)
- en: '`ControlValueAccessor` docs: [https://angular.io/api/forms/ControlValueAccessor](https://angular.io/api/forms/ControlValueAccessor)'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ControlValueAccessor` 文档：[https://angular.io/api/forms/ControlValueAccessor](https://angular.io/api/forms/ControlValueAccessor)'
- en: Learn more on Discord
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的 Discord 社区——在那里您可以分享反馈、向作者提问，并了解新书发布——请扫描下面的二维码：
- en: '[https://packt.link/AngularCookbook2e](Chapter_8.xhtml)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/AngularCookbook2e](Chapter_8.xhtml)'
- en: '![](img/QR_Code1388317275422265.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1388317275422265.png)'
