- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Diving into the Reactive Paradigm
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解响应式范式
- en: Reactive patterns are reusable solutions to a commonly occurring problem using
    reactive programming. Behind all these patterns is a new way of thinking, a new
    architecture, new coding styles, and new tools. That’s what this entire book is
    based on – useful reactive patterns in Angular applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式模式是使用响应式编程对常见问题进行可重用解决方案。在这些模式背后是一种新的思维方式，新的架构，新的编码风格和新的工具。这正是整本书的基础——在Angular应用程序中有用的响应式模式。
- en: Now, I know you are impatient to write your first reactive pattern in Angular,
    but before doing so, and in order to help you take full advantage of all the RxJS
    patterns and leverage the reactive paradigm, we will start by explaining in detail
    all the fundamentals and preparing the groundwork for the following chapters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我知道您迫不及待地想写出您在Angular中的第一个响应式模式，但在这样做之前，为了帮助您充分利用所有RxJS模式和利用响应式范式，我们将首先详细解释所有基础知识，并为后续章节打下基础。
- en: Let’s start with a basic understanding of the reactive paradigm, its advantages,
    and the problems it solves. Best of all, let’s put a reactive mindset on and start
    thinking reactively. We will begin by highlighting the pillars and the advantages
    of the reactive paradigm. Then, we will explain the marble diagram and why it
    is useful. Finally, we will highlight the use of RxJS in Angular.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从对响应式范式的初步理解开始，了解其优势以及它解决的问题。最好的是，让我们培养一种响应式思维，开始以响应式的方式思考。我们将首先强调响应式范式的支柱和优势。然后，我们将解释水珠图及其用途。最后，我们将突出RxJS在Angular中的应用。
- en: Giving an insight into the fundamentals of the reactive paradigm is incredibly
    important. This will ensure you get the basics right, help you understand the
    usefulness of the reactive approach, and consequently help you determine which
    situation is best to use it in.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对响应式范式的基本原理进行深入了解至关重要。这将确保您掌握基础知识，帮助您理解响应式方法的有用性，并因此帮助您确定在哪种情况下最好使用它。
- en: 'In this chapter, we’re going to cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Exploring the pillars of reactive programming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索响应式编程的支柱
- en: Learning the marble diagram (our secret weapon)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习水珠图（我们的秘密武器）
- en: Highlighting the use of RxJS in Angular
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 突出RxJS在Angular中的应用
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter does not require any environment setup or installation steps.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不需要任何环境设置或安装步骤。
- en: All the code snippets in this chapter are just examples to illustrate the concept,
    so you will not need the code repository to follow along. However, if you’re interested,
    the code for the book can be found at [https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码片段只是为了说明概念，所以您不需要代码仓库来跟随。然而，如果您感兴趣，本书的代码可以在[https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition)找到。
- en: This book assumes that you have a basic understanding of Angular and RxJS.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设您对Angular和RxJS有基本的了解。
- en: Note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: This book uses the new Angular documentation site, [angular.dev](http://angular.dev).
    The previous documentation site, [angular.io](http://angular.io), will soon be
    deprecated. Stay connected with the latest updates and resources by accessing
    the documentation through this link.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用新的Angular文档网站[angular.dev](http://angular.dev)。之前的文档网站[angular.io](http://angular.io)将很快被弃用。通过此链接访问文档，以保持与最新更新和资源的联系。
- en: Exploring the pillars of reactive programming
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索响应式编程的支柱
- en: '**Reactive programming** is among the major programming paradigms used by developers
    worldwide. Every programming paradigm solves some problems and has its own advantages.
    By definition, reactive programming is programming with asynchronous data streams
    and is based on observer patterns. So, let’s talk about these pillars of reactive
    programming!'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应式编程**是全球开发者使用的重大编程范式之一。每种编程范式都解决了一些问题，并有其自身的优势。根据定义，响应式编程是使用异步数据流的编程，基于观察者模式。那么，让我们来谈谈响应式编程的这些支柱吧！'
- en: Data streams
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据流
- en: '**Data streams** are the spine of reactive programming. Everything that may
    change or happen over time (you don’t know when exactly) is represented as asynchronous
    streams such as events, notifications, and messages. Reactive programming is about
    reacting to changes as soon as they are emitted!'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据流**是反应式编程的脊柱。所有可能在时间上发生变化或发生的事情（你不知道确切的时间）都表示为异步流，如事件、通知和消息。反应式编程是关于在变化发生时立即做出反应！'
- en: 'An excellent example of data streams is UI events. Let’s suppose that we have
    an HTML button and we want to execute an action whenever a user clicks on it.
    Here, we can think of the click event as a stream:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流的一个很好的例子是UI事件。假设我们有一个HTML按钮，我们希望在用户点击它时执行一个动作。在这里，我们可以将点击事件视为一个流：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As implemented in the preceding code snippet, in order to react to the click
    event, we register an `EventListener` event. Then, every time a click occurs,
    the `processClick` method is called to execute a side effect. In our case, we
    are just logging `Hi` in the console.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如前代码片段所示，为了对点击事件做出反应，我们注册了一个`EventListener`事件。然后，每次点击发生时，都会调用`processClick`方法来执行副作用。在我们的例子中，我们只是在控制台记录`Hi`。
- en: As you might have gathered, to be able to react when something happens and execute
    a side effect, you should listen to the streams to become notified. To get closer
    to reactive terminology, instead of *listen*, we can say *observe*. This leads
    us to the *observer* design pattern, which is at the heart of reactive programming.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所可能收集到的，为了能够对发生的事情做出反应并执行副作用，你应该监听流以获得通知。为了更接近反应式术语，我们可以说*观察*而不是*监听*。这使我们来到了*观察者*设计模式，它是反应式编程的核心。
- en: Observer patterns
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察者模式
- en: 'The **observer pattern** is based on two main roles – a publisher and a subscriber:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**观察者模式**基于两个主要角色——发布者和订阅者：'
- en: A **publisher** maintains a list of subscribers and notifies them or propagates
    a change every time there is an update
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布者**维护一个订阅者列表，并在每次更新时通知他们或传播一个变化'
- en: On the other hand, a **subscriber** performs an update or executes a side effect
    every time they receive a notification from the publisher
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，**订阅者**每次从发布者收到通知时都会执行更新或执行副作用
- en: 'The observer pattern is illustrated here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式在此处展示：
- en: '![Figure 1.1 – The observer pattern](img/B21180_01_1.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 观察者模式](img/B21180_01_1.jpg)'
- en: Figure 1.1 – The observer pattern
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 观察者模式
- en: To get notified about the updates, you need to subscribe to the publisher. A
    real-world analogy would be a newsletter; you don’t get any emails from a specific
    newsletter if you don’t subscribe to it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更新通知，你需要订阅发布者。一个现实世界的类比就是时事通讯；如果你不订阅它，你不会从特定的时事通讯中收到任何电子邮件。
- en: 'This leads us to the building blocks of RxJS, which include the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们来到了RxJS的构建块，包括以下内容：
- en: '**Observables**: These are a representation of the asynchronous data streams
    that notify the observers of any change'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可观察对象**：这些是异步数据流的表示，通知观察者任何变化'
- en: '**Observers**: These are consumers of the data streams emitted by Observables'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察者**：这些是消费由可观察对象发出的数据流的消费者'
- en: RxJS combines the observer pattern with the iterator pattern and functional
    programming to process and handle asynchronous events. This was a reminder of
    reactive programming fundamentals, and it is crucial to know when to put a reactive
    implementation in place and when to avoid it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS将观察者模式与迭代器模式和函数式编程相结合，以处理和异步事件。这是对反应式编程基础的一个提醒，知道何时实现反应式实现以及何时避免它至关重要。
- en: 'In general, whenever you have to handle asynchronous tasks in your Angular
    application, always think of RxJS. The main advantages of RxJS over other asynchronous
    APIs are as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你在Angular应用程序中处理异步任务时，总是要想到RxJS。RxJS相对于其他异步API的主要优势如下：
- en: RxJS makes dealing with event-based programs, asynchronous data calls, and callbacks
    an easy task.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJS使得处理基于事件的程序、异步数据调用和回调变得容易。
- en: Observables guarantee consistency. They emit multiple values over time so that
    you can consume continuous data streams.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察对象保证了一致性。它们在一段时间内发出多个值，以便你可以消费连续的数据流。
- en: Observables are lazy; they are not executed until you subscribe to them. This
    helps with writing declarative code that is clean, efficient, and easy to understand
    and maintain.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察对象是懒加载的；它们在你订阅它们之前不会执行。这有助于编写清晰、高效、易于理解和维护的声明式代码。
- en: Observables can be canceled, completed, and retrieved at any moment. This makes
    a lot of sense in many real-world scenarios.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Observables 可以在任何时候取消、完成和检索。这在许多实际场景中非常有意义。
- en: RxJS provides many operators with a functional style to manipulate collections
    and optimize side effects.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJS 提供了许多具有函数式风格的操作符来操作集合和优化副作用。
- en: Observables push errors to the subscribers and provide a clean way to handle
    errors.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Observables 将错误推送到订阅者，并提供了一种处理错误的干净方式。
- en: RxJS allows you to write clean and efficient code to handle asynchronous data
    in your application.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJS 允许你编写干净且高效的代码来处理应用中的异步数据。
- en: Now that we have given some insight into the reactive programming pillars and
    detailed the major advantages of RxJS, let’s explore the marble diagram, which
    is very handy for understanding and visualizing the Observable execution.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对反应式编程的支柱进行了介绍，并详细阐述了 RxJS 的主要优势，让我们来探索弹珠图，这对于理解和可视化 Observable 执行非常有用。
- en: Learning about the marble diagram (our secret weapon)
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解弹珠图（我们的秘密武器）
- en: RxJS ships with more than one hundred **operators** – these are among the building
    blocks of RxJS, useful for manipulating streams. All the reactive patterns that
    will be detailed later in this book are based on operators, and when it comes
    to explaining operators, it is better to refer to a visual representation – that’s
    where marble diagrams come in!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS 随带超过一百个 **操作符** – 这些是 RxJS 的构建块之一，用于操作流。本书后面将详细介绍的所有的反应式模式都是基于操作符的，当涉及到解释操作符时，最好参考视觉表示
    – 这就是弹珠图的作用所在！
- en: '**Marble diagrams** are visual representations of the operator’s execution,
    which will be used in all chapters to understand the behavior of RxJS operators.
    At first, it might seem daunting, but it is delightfully simple. You only have
    to understand the anatomy of the diagram and then you’ll be good at reading and
    translating it.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**弹珠图**是操作符执行的视觉表示，本书的所有章节都将使用它来理解 RxJS 操作符的行为。一开始可能会觉得有些令人畏惧，但实际上它非常简单。你只需理解图标的解剖结构，然后你就能很好地阅读和翻译它。'
- en: 'Marble diagrams represent the execution of an operator, so every diagram will
    include the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 弹珠图表示操作符的执行，因此每个图都将包括以下内容：
- en: '**Input Observable(s)**: Represents one or many Observables given as input
    to the operator'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入 Observable(s)**：表示作为操作符输入的一个或多个 Observable'
- en: '**Operator**: Represents the operator to be executed with its parameters'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作符**：表示要执行的操作符及其参数'
- en: '**Output Observable**: Represents the Observable produced after the operator’s
    execution'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出 Observable**：表示操作符执行后产生的 Observable'
- en: 'We can see the execution illustrated here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在此看到执行过程的示例：
- en: '![Figure 1.2 – The operator execution](img/B21180_01_2.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 操作符执行](img/B21180_01_2.jpg)'
- en: Figure 1.2 – The operator execution
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 操作符执行
- en: 'Now, let’s zoom in on the representation of the input/output Observables:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们放大输入/输出 Observable 的表示：
- en: '![Figure 1.3 – The marble diagram elements](img/B21180_01_3.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 弹珠图元素](img/B21180_01_3.jpg)'
- en: Figure 1.3 – The marble diagram elements
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 弹珠图元素
- en: 'The elements of these diagrams include the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图标的元素包括以下内容：
- en: '**The timeline**: Observables are asynchronous streams that produce data over
    time. Therefore, the representation of time is crucial in the marble diagram,
    and it is represented as an arrow flowing from left to right.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间线**：Observables 是异步流，在一段时间内产生数据。因此，在弹珠图中，时间的表示至关重要，它被表示为从左到右流动的箭头。'
- en: '**The marble values**: These are the values emitted by the Observables over
    time. They are represented by colored circles.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹珠值**：这些是 Observable 在一段时间内发出的值。它们由彩色圆圈表示。'
- en: '**The completion status**: The vertical line (|) represents the successful
    completion of the Observables.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完成状态**：垂直线（|）表示 Observable 成功完成。'
- en: '**The error status**: The **X** represents an error emitted by the Observable.
    Neither the values nor the vertical line representing completion will be emitted
    thereafter.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误状态**：**X** 代表由 Observable 发出的错误。之后既不会发出值，也不会发出表示完成的垂直线。'
- en: 'That’s all the elements you need to know about. Now, let’s put all the pieces
    together in a real marble diagram:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要了解的所有元素。现在，让我们将这些部分组合到一个真实的弹珠图中：
- en: '![Figure 1.4 – An example of a marble diagram for a custom operator](img/B21180_01_4.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – 自定义操作符的弹珠图示例](img/B21180_01_4.jpg)'
- en: Figure 1.4 – An example of a marble diagram for a custom operator
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 自定义操作符的弹珠图示例
- en: As you may have guessed, we have a custom operator called `divideByTwo` that
    will emit half of every received number. When the input Observable emits the values
    `4` and `8`, the output Observable produces `2` and `4` respectively.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，我们有一个自定义操作符叫做 `divideByTwo`，它会发出接收到的每个数字的一半。当输入的可观察对象发出值 `4` 和 `8` 时，输出的可观察对象分别产生
    `2` 和 `4`。
- en: However, when the `R` value, which is non-numeric, is emitted, then an error
    is thrown, indicating abnormal termination. This case is not handled in the operator
    code. The input Observable continues the emission and then completes successfully.
    However, the value will never be processed because, after the error, the stream
    is closed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当发出非数字的 `R` 值时，则会抛出错误，表示异常终止。这种情况在操作符代码中没有处理。输入的可观察对象继续发射，然后成功完成。然而，该值永远不会被处理，因为在错误之后，流被关闭了。
- en: At this point, we’ve gone through all the elements composing the marble diagram.
    You will be able to understand the operators used in the chapters to come. Now,
    let’s shed some light on the use of RxJS in Angular.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经走过了构成水滴图的全部元素。你将能够理解接下来章节中使用的操作符。现在，让我们来了解一下 RxJS 在 Angular 中的使用。
- en: Highlighting the use of RxJS in Angular
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 突出 RxJS 在 Angular 中的使用
- en: 'RxJS is practically a first-class citizen in Angular. It is part of the Angular
    ecosystem and is used in many features to handle asynchronous tasks. The following
    are some examples of these features:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，RxJS 几乎是一个一等公民。它是 Angular 生态系统的一部分，并被用于许多功能来处理异步任务。以下是一些这些功能的例子：
- en: The HttpClient module
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HttpClient 模块
- en: The Router module
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由模块
- en: Reactive forms
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式表单
- en: The Event emitter
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件发射器
- en: We will discuss each of the following concepts in the subsequent subsections.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的小节中讨论以下每个概念。
- en: Note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We recommend taking a quick look at [https://angular.dev/overview](https://angular.dev/overview),
    where you can find further details about the aforementioned features.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议快速浏览一下 [https://angular.dev/overview](https://angular.dev/overview)，在那里你可以找到关于上述功能的更多详细信息。
- en: The HttpClient module
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HttpClient 模块
- en: You might be familiar with the HttpClient API provided by Angular that is used
    to communicate with a server over the HTTP protocol. The `HttpClient` service
    is based on Observables that manage all transactions, which means that the result
    of calling API methods such as `GET`, `PATCH`, `POST`, and `PUT` will be an Observable.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉 Angular 提供的 HttpClient API，该 API 用于通过 HTTP 协议与服务器通信。`HttpClient` 服务基于可观察对象来管理所有事务，这意味着调用
    API 方法（如 `GET`、`PATCH`、`POST` 和 `PUT`）的结果将是一个可观察对象。
- en: 'In the following code snippet, we have an example of an Angular service that
    injects the `HttpClient` service and fetches data from the server using the `HttpClient.get()`
    method:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们有一个 Angular 服务的例子，它注入了 `HttpClient` 服务，并使用 `HttpClient.get()` 方法从服务器获取数据：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `getRecipes()` method – or, to be more accurate, the call to ``this.http.get<Recipe>(`api/recipes/`)``
    – returns an Observable that you should subscribe to in order to send the `GET`
    request to the server. Please note that this is an example of an HTTP transaction,
    and it is the same for all the other HTTP methods available in the API (`POST`,
    `PUT`, `PATCH`, etc.).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`getRecipes()` 方法 – 或者更准确地说，对 ``this.http.get<Recipe>(`api/recipes/`)`` 的调用
    – 返回一个可观察对象，你应该订阅它以向服务器发送 `GET` 请求。请注意，这是一个 HTTP 事务的例子，并且对于 API 中可用的所有其他 HTTP
    方法（`POST`、`PUT`、`PATCH` 等）都是相同的。'
- en: Note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The code contains references to `recipe.model` and `getRecipes()` – in [*Chapter
    2*](B21180_02.xhtml#_idTextAnchor031)*, Walking through Our Application*, you
    will be introduced to the Recipe app that we will be working on throughout the
    rest of the book.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中包含对 `recipe.model` 和 `getRecipes()` 的引用 – 在 [*第 2 章*](B21180_02.xhtml#_idTextAnchor031)*，漫步我们的应用程序*
    中，你将介绍我们将在本书的其余部分工作的 Recipe 应用程序。
- en: 'For those familiar with Promise-based HTTP APIs, you may be wondering about
    the advantages of using Observables in this context. For those who are not acquainted
    with Promises, **Promises** are JavaScript objects that represent the eventual
    completion (or failure) of an asynchronous operation and its resulting value.
    They provide a cleaner and more structured way to work with asynchronous code
    compared to traditional callback-based approaches. However, there are a lot of
    advantages of using Observables over Promises, and the most important ones are
    listed as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉基于Promise的HTTP API的人来说，你可能想知道在这个上下文中使用可观测量的优势。对于那些不熟悉Promise的人来说，**Promise**是表示异步操作最终完成（或失败）及其结果的JavaScript对象。它们提供了一种比传统基于回调的方法更干净、更有结构化的方式来处理异步代码。然而，使用可观测量而不是Promise有很多优势，其中最重要的如下：
- en: Observables are cancellable, so you can cancel the HTTP request whenever you
    want by calling the unsubscribe method
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观测量是可以取消的，因此你可以通过调用取消订阅方法在任何时候取消HTTP请求
- en: You can also retry HTTP requests when an error occurs or an exception is thrown
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当发生错误或抛出异常时，你也可以重试HTTP请求
- en: The server’s response cannot be mutated by Observables, although this can be
    the case for chaining `then()` on Promises.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 可观测量不能修改服务器的响应，尽管在Promise上链式调用`then()`可能会出现这种情况。
- en: The Router module
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由模块
- en: The Router module available in the `@angular/router` package uses Observables
    in router events and activated routes. We will look at both here.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在`@angular/router`包中可用的路由模块在路由事件和激活路由中使用可观测量。我们在这里将查看这两个方面。
- en: Router events
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由事件
- en: Router events allow you to intercept the navigation life cycle. They are defined
    in the Router as Observables.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 路由事件允许你拦截导航生命周期。它们在路由器中定义为可观测量。
- en: Note
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We recommend taking a quick look at [https://angular.dev/api/router/Event](https://angular.dev/api/router/Event),
    where you can find further details about router events.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议快速查看[https://angular.dev/api/router/Event](https://angular.dev/api/router/Event)，在那里你可以找到有关路由事件的更多详细信息。
- en: The majority of Angular applications have a routing mechanism. Router events
    change frequently over time, and it makes sense to listen to changes to execute
    side effects. That’s why Observables are a flexible way in which to handle those
    streams.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Angular应用程序都有一个路由机制。路由事件随时间频繁变化，因此监听这些变化以执行副作用是有意义的。这就是为什么可观测量是处理这些流的一种灵活方式。
- en: To intercept all the events the router goes through, first, you should inject
    the `Router` service, which provides URL manipulation capabilities. Then, subscribe
    to the events Observable available in the `Router` object and filter the events
    of type `RouterEvent` using the RxJS filter operator.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要拦截路由器经过的所有事件，首先，你应该注入`Router`服务，它提供URL操作能力。然后，订阅`Router`对象中可用的事件可观测量，并使用RxJS过滤操作符过滤出`RouterEvent`类型的事件。
- en: 'The following is an example of an Angular service that injects the Router in
    the constructor, subscribes to the router events, and traces the event ID and
    path in the console:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个Angular服务的示例，它在构造函数中注入路由器，订阅路由事件，并在控制台中跟踪事件ID和路径：
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a very basic example, and you could introduce pretty much any specific
    behavior to it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常基础的示例，你几乎可以引入任何特定的行为。
- en: The activated route
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 激活路由
- en: '`ActivatedRoute` is a router service that you can inject into your components
    to retrieve information about a route’s path and parameters. Many properties are
    based on Observables. Here, you will find the implementation of the `ActivatedRoute`
    class:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActivatedRoute`是一个可以将路由器注入到你的组件中以检索有关路由路径和参数信息的路由服务。许多属性基于可观测量。在这里，你可以找到`ActivatedRoute`类的实现：'
- en: '[PRE3]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you may have figured out, `url`, `params`, `queryParams`, `fragment`, `data`,
    `paramMap`, and `queryParamMap` are represented as Observables. All these parameters
    might change over time, so it makes sense to listen to these changes to register
    side effects or update the values.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，`url`、`params`、`queryParams`、`fragment`、`data`、`paramMap`和`queryParamMap`都表示为可观测量。所有这些参数可能会随时间变化，因此监听这些变化以注册副作用或更新值是有意义的。
- en: 'Here’s an example of an Angular component that injects the `ActivatedRoute`
    class in the constructor and then in `ngOnInit()` method, subscribes to the following
    properties:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个Angular组件的示例，它在构造函数中注入`ActivatedRoute`类，然后在`ngOnInit()`方法中订阅以下属性：
- en: The `url` property of `ActivatedRoute`, in order to log the current URL in the
    console
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActivatedRoute`的`url`属性，以便在控制台记录当前URL'
- en: 'The `queryParams` property of `ActivatedRoute`, in order to retrieve the `criteria`
    parameter and store it in a local property named `criteria`:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActivatedRoute` 的 `queryParams` 属性，用于检索 `criteria` 参数并将其存储在名为 `criteria` 的本地属性中：'
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This example showcases the usage of the `url` and `queryParams` properties.
    For a comprehensive overview of all `ActivatedRoute` properties and their functionalities,
    I encourage you to visit the Angular documentation page at [https://angular.dev/api/router/ActivatedRoute#properties](https://angular.dev/api/router/ActivatedRoute#properties).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 本例展示了 `url` 和 `queryParams` 属性的使用。为了全面了解所有 `ActivatedRoute` 属性及其功能，我鼓励您访问 Angular
    文档页面 [https://angular.dev/api/router/ActivatedRoute#properties](https://angular.dev/api/router/ActivatedRoute#properties)。
- en: Reactive forms
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反应式表单
- en: 'Reactive forms available under the `@angular/forms` package are based on Observables
    to track form control changes. Here’s the overview of the `FormControl` class
    in Angular:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `@angular/forms` 包下可用的反应式表单基于 Observables 来跟踪表单控件的变化。以下是 Angular 中 `FormControl`
    类的概述：
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The properties `valueChanges` and `statusChanges` of `FormControl` are represented
    as Observables that trigger change events. Subscribing to a `FormControl` value
    change is a way of triggering application logic within the `component` class.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormControl` 的 `valueChanges` 和 `statusChanges` 属性表示为触发更改事件的 Observables。订阅
    `FormControl` 的值变化是触发 `component` 类中应用逻辑的一种方式。'
- en: 'Here’s an example that subscribes to the `valueChanges` Observable of a `FormControl`
    property called `rating` and simply traces the value through `console.log(value)`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，它订阅了名为 `rating` 的 `FormControl` 属性的 `valueChanges` Observable，并简单地通过
    `console.log(value)` 跟踪值：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This way, you will get the changed value as an output.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您将获得作为输出的更改值。
- en: The Event emitter
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件发射器
- en: 'The event emitter, which is part of the `@angular/core` package, is used to
    emit data from a child component to a parent component through the `@Output()`
    decorator. The `EventEmitter` class extends the RxJS subject and registers handlers
    for events emitted by this instance:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 事件发射器，它是 `@angular/core` 包的一部分，用于通过 `@Output()` 装饰器从子组件向父组件发射数据。`EventEmitter`
    类扩展了 RxJS subject 并为该实例发射的事件注册了处理程序：
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is what happens under the hood when you create an event emitter and emit
    a value.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建事件发射器并发射一个值时，幕后发生的事情就是这样。
- en: 'The following code block is an example of emitting the updated value of a recipe
    rating:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块是一个示例，展示了如何发射食谱评分的更新值：
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So, the `EventEmitter` smooths communication between components by allowing
    one component to emit custom events and another component to listen for and respond
    to those events. This mechanism plays a crucial role in enabling parent-child
    communication, sibling communication, and even communication between unrelated
    components in Angular applications.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`EventEmitter` 通过允许一个组件发射自定义事件，另一个组件监听并响应这些事件，从而平滑了组件之间的通信。这种机制在实现父子组件通信、兄弟组件通信，甚至在
    Angular 应用程序中实现无关组件之间的通信中起着至关重要的作用。
- en: Note
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the previous code snippets, the subscription to the Observables was done
    explicitly for demonstration purposes. In a real-world example, we should include
    the unsubscription logic if we want to subscribe explicitly. We will shed light
    on this in [*Chapter 3*](B21180_03.xhtml#_idTextAnchor047), *Fetching Data* *as
    Streams*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码片段中，为了演示目的，显式地订阅了 Observables。在现实世界的例子中，如果我们想显式地订阅，我们应该包括取消订阅的逻辑。我们将在
    [*第 3 章*](B21180_03.xhtml#_idTextAnchor047)，*作为流获取数据* 中详细说明。
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we walked you through the fundamentals of reactive programming
    and in which use cases it shines. Then, we explained the marble diagram that will
    be our reference for explaining RxJS operators in all the following chapters.
    Finally, we highlighted the use of reactive programming in Angular by illustrating
    concrete examples, implementations, and advantages.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您介绍了反应式编程的基础以及它在哪些用例中表现出色。然后，我们解释了将作为我们解释所有后续章节中 RxJS 操作符参考的宝石图。最后，我们通过具体示例、实现和优势，突出了在
    Angular 中使用反应式编程。
- en: Now that we have got the basics right, it is time to start preparing and explaining,
    in the next chapter, the application that we are going to build throughout this
    book, where we are going to implement all of the reactive patterns we will learn
    progressively.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了基础知识，是时候开始准备和解释了，在下一章中，我们将构建整个本书中的应用程序，我们将逐步实现我们将学习的所有反应式模式。
