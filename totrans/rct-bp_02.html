<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Creating a Web Shop"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Creating a Web Shop</h1></div></div></div><p>Selling merchandise online has been a staple of the Web since it was commercialized in the 1990s. In this chapter, we will explore how we can leverage the power of ReactJS to create our very own web shop.</p><p>We'll start by creating a number of different components, such as a home page, a products page, a <a class="indexterm" id="id67"/>checkout and receipt page, and we'll fetch products from data stores via a concept called <span class="strong"><strong>Flux</strong></span>.</p><p>When we're finished, you'll have a complete blueprint that you can expand upon and apply your own styling to.</p><p>Let's get started!</p><div class="section" title="An overview of the components"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>An overview of the components</h1></div></div></div><p>When creating any kind of website, it's often beneficial to create a mock-up of how you want the page<a class="indexterm" id="id68"/> to look before proceeding to write any code. This makes it easier to visualize how you want your site to look and what components you need to create. You can use any kind of mockup tool to create this, even a sheet of paper will do.</p><p>Looking at our website mock-up, we can see that we need to create the following components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A layout component</li><li class="listitem" style="list-style-type: disc">A home page component for the front page</li><li class="listitem" style="list-style-type: disc">A menu component with a brand name and the most important links</li><li class="listitem" style="list-style-type: disc">A company information component</li><li class="listitem" style="list-style-type: disc">A product list component</li><li class="listitem" style="list-style-type: disc">An item component</li><li class="listitem" style="list-style-type: disc">A checkout component</li><li class="listitem" style="list-style-type: disc">A receipt component</li></ul></div><p>These are just the view components. In addition to these, we'll need to create data stores and actions and<a class="indexterm" id="id69"/> subcomponents for the main ones. For instance, for the product component on the front page, you will need a picture element, description, price, and a buy button, and any time you need a list or table, you need to make another subcomponent, and so on.</p><p>We'll create these as we go along. Let's take a look at the following image:</p><div class="mediaobject"><img alt="An overview of the components" src="graphics/B04943_02_01.jpg"/></div><p>The preceding mock-up shows the product list page as seen on a desktop and as viewed on a smart phone. It's worthwhile to sketch up mock-ups for all the platforms you intend to support. It's also a good idea to make sketches of all the different pages and states they can have.</p></div></div>
<div class="section" title="Setting up a shop"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Setting up a shop</h1></div></div></div><p>We'll be using the code from <a class="link" href="ch01.html" title="Chapter 1. Diving Headfirst into ReactJS">Chapter 1</a>, <span class="emphasis"><em>Diving Headfirst into ReactJS</em></span>, as the basis for this web shop. Make a duplicate of the code from the first chapter and make sure that it's running before you continue making changes.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>Copy the code to<a class="indexterm" id="id70"/> another directory and run it by executing <code class="literal">node server.js</code>. It should start up a server and automatically open a browser window for you.</p></div></div><div class="section" title="Creating the layout"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Creating the layout</h2></div></div></div><p>First of all, we <a class="indexterm" id="id71"/>need a basic layout for our webshop. There are many options available for you. For instance, you can choose any one of the many open source CSS frameworks, such as<a class="indexterm" id="id72"/> <span class="strong"><strong>Bootstrap</strong></span> or <span class="strong"><strong>Foundation</strong></span>, or <a class="indexterm" id="id73"/>you can strike your own path and build up a basic grid and bring in elements as you see fit.</p><p>For simplicity's sake, we'll be going with Bootstrap for this webshop. It's a hugely popular framework that is easy to work with and has excellent support for React.</p><p>As noted, we'll be using the scaffolding from <a class="link" href="ch01.html" title="Chapter 1. Diving Headfirst into ReactJS">Chapter 1</a>, <span class="emphasis"><em>Diving Headfirst into ReactJS</em></span>. In addition, we're going to need a few more packages, most notably: <code class="literal">react-bootstrap</code>, <code class="literal">react-router</code>, <code class="literal">lodash</code>, <code class="literal">Reflux</code>, <code class="literal">superagent</code> and <code class="literal">react-router-bootstrap</code>. For simplicities sake, replace the dependencies section in your <code class="literal">package.json</code> with these values and run <code class="literal">npm install</code> in your command line:</p><div class="informalexample"><pre class="programlisting">"devDependencies": {
  "babel-preset-es2015": "6.9.0",
  "babel-preset-react": "6.11.1",
  "babelify": "7.3.0",
  "browser-sync": "2.13.0",
  "browserify": "13.0.1",
  "browserify-middleware": "7.0.0",
  "history": "3.0.0",
  "jsxstyle": "0.0.18",
  "lodash": "4.13.1",
  "react": "15.1.0",
  "react-bootstrap": "0.29.5",
  "react-dom": "15.1.0",
  "react-router": "2.5.2",
  "react-router-bootstrap": "0.23.0",
  "reactify": "1.1.1",
  "reflux": "0.4.1",
  "serve-favicon": "2.3.0",
  "superagent": "2.1.0",
  "uglifyjs": "2.4.10",
  "watchify": "3.7.0"
}</pre></div><p>The <code class="literal">--save-dev</code> option saves the dependencies in your <code class="literal">package.json</code> file under the <code class="literal">devDependencies</code> key as shown in the preceding code. On a production build, these dependencies will not be installed, and this makes the deployment go faster. We'll take a look at how to create a production build in <a class="link" href="ch08.html" title="Chapter 8. Deploying Your App to the Cloud">Chapter 8</a>, <span class="emphasis"><em>Deploying Your App to the Cloud</em></span>. If you rather want to put these packages in your regular dependencies section, use <code class="literal">--save</code> instead of <code class="literal">--save-dev</code> and in your <code class="literal">package.json</code> the preceding packages will reside<a class="indexterm" id="id74"/> in your <code class="literal">dependencies</code> section rather than in your <code class="literal">devDependencies</code>.</p><p>We also need the Bootstrap, and<a class="indexterm" id="id75"/> we'll use a <span class="strong"><strong>Content Delivery Network</strong></span> (<span class="strong"><strong>CDN</strong></span>) to fetch it. Add the following code snippet to the <code class="literal">&lt;head&gt;</code> section of your <code class="literal">index.html</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-glyphicons.css" /&gt;

&lt;link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" /&gt;</pre></div><p>Whether you want to support the older version of Internet Explorer is your choice, but if you do, you're going to need to add this part to the <code class="literal">&lt;head&gt;</code> section of your <code class="literal">index.html</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;!--[if lt IE 9]&gt;
  &lt;script&gt;
    (function() {
      var ef = function(){};
      window.console = window.console || {log:ef,warn:ef,error:ef,dir:ef};
    }());
  &lt;/script&gt;
  &lt;script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"&gt;&lt;/script&gt;
  &lt;script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv-printshiv.min.js"&gt;&lt;/script&gt;
  &lt;script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"&gt;&lt;/script&gt;
  &lt;script src="//cdnjs.cloudflare.com/ajax/libs/es5-shim/3.4.0/es5-shim.js"&gt;&lt;/script&gt;
  &lt;script src="//cdnjs.cloudflare.com/ajax/libs/es5-shim/3.4.0/es5-sham.js"&gt;&lt;/script&gt;
&lt;![endif]--&gt;</pre></div><p>This adds a <span class="strong"><strong>polyfill</strong></span> to your code base. A polyfill adds support for HTML5 features that older browsers don't support.</p><p>We also want to<a class="indexterm" id="id76"/> use the modern features of Internet Explorer, so let's add the following <code class="literal">meta</code> tag:</p><div class="informalexample"><pre class="programlisting">&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;</pre></div><p>This setting tells the browser to render according to the most recent version of the standard. This tag was introduced in <span class="emphasis"><em>IE8</em></span>, so this tag won't matter if your users are using <span class="emphasis"><em>IE7</em></span> or lower. Additional settings are <code class="literal">IE=5</code> to <code class="literal">IE=11</code> and <code class="literal">IE=EmulateIE7</code> to <code class="literal">IE=EmulateIE11</code>. Using the emulate instructions informs Internet Explorer how to render in the standards<a class="indexterm" id="id77"/> and quirks mode. For instance, <code class="literal">EmulateIE9</code> renders the page as <span class="emphasis"><em>IE9</em></span> in the standards mode and as <span class="emphasis"><em>IE5</em></span> in the quirks mode.</p><p>Which settings you choose is dependent on your target platform, and unless you have a very specific IE version in mind, going with <code class="literal">IE=edge</code> is probably the safest option.</p><p>In order for the smart phones to show the page in proper scale, we need to add this <code class="literal">meta</code> tag as well:</p><div class="informalexample"><pre class="programlisting">&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;</pre></div><p>This notifies the smart phone browser that you want to display the page in full width with a scale of 1. You can play with the scale and width, but in most cases, this setting is what you want.</p></div><div class="section" title="Adding your own CSS code"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Adding your own CSS code</h2></div></div></div><p>We already have a CSS file in the public folder. We're going to use a very basic CSS layout and rely<a class="indexterm" id="id78"/> on Bootstrap for the most part. Edit <code class="literal">public/app.css</code> and replace it with the following code:</p><div class="informalexample"><pre class="programlisting">body {
  background:#eee;
  padding:62px 0 0 0;
}
.row {
  padding:0 0 20px 0;
}
.summary {
  border-bottom: 3px double black;
}</pre></div><p>The padding is there simply to make sure that the content falls inside the menu (that we'll be creating in the upcoming section called <span class="emphasis"><em>The menu and footer</em></span>).</p></div><div class="section" title="Adding a route handler"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Adding a route handler</h2></div></div></div><p>Let's open the <code class="literal">app.jsx</code> file, remove everything from the initial scaffold, and replace it with the following<a class="indexterm" id="id79"/> code:</p><div class="informalexample"><pre class="programlisting">"use strict";

import React from "react";
import Router from "react-router";
import Routes from "./routes.jsx";
import { render } from "react-dom";

render (
  Routes,
  document.getElementById('container')
);</pre></div><p>In our imports section, we're now adding <code class="literal">react-router</code> and a new file called <code class="literal">routes.jsx</code>. You'll note that we're fetching <code class="literal">Route</code> from react-router by encapsulating it in braces. This is called <a class="indexterm" id="id80"/>
<span class="strong"><strong>destructuring</strong></span> and is identical to fetching it with <code class="literal">var Route = require("react-router").Route</code>, which is quite easy to type.</p><p>The next thing we do is<a class="indexterm" id="id81"/> let the <span class="strong"><strong>router</strong></span> control our app by applying <code class="literal">Router.run</code>, provide it with the contents of our new <code class="literal">routes</code> file, then mount it on the <code class="literal">&lt;div&gt;</code> tag with the <code class="literal">id</code> container as we did before.</p><p>Of course, to run this, you need to create a file called <code class="literal">router.jsx</code>. It should look like this:</p><div class="informalexample"><pre class="programlisting">"use strict";

import React from "react";
import Layout from './layout.jsx';
import { Router, Route, browserHistory } from 'react-router'

const Routes = (
  &lt;Router history={browserHistory}&gt;
  &lt;Route handler={Layout} path="/"&gt;
  &lt;/Route&gt;
  &lt;/Router&gt;
);

module.exports = Routes;</pre></div><p>It's pretty straightforward as you can see, since we're not creating any routes just yet. Again, we're importing <code class="literal">react</code>, <code class="literal">react-router</code>, and <code class="literal">route</code>, and also a new file called <code class="literal">layout.jsx</code>, which will be our primary route handler.</p><p>At the end, we're exporting the contents of the Routes as Routes. This is a necessary step because this is what allows you to import it later in your other scripts. You could simplify this by putting <code class="literal">module.exports =</code> instead of <code class="literal">const Routes =</code> in the module declaration and then skip the last line. It's your choice, but I think it's a good practice to structure your<a class="indexterm" id="id82"/> code by putting the imports first, the code in the middle, and then what the module exports last.</p><p>This is what should go into the <code class="literal">layout.jsx</code> file:</p><div class="informalexample"><pre class="programlisting">"use strict";

import React from "react";

const Layout = React.createClass ({
  render() {
    return (
      &lt;div&gt;
        { React.cloneElement(
          this.props.children,
          this.state
        ) }
      &lt;/div&gt;
    );
  }
});</pre></div><p>This page is completely empty. The only thing we've added for now is the route handler. This is where the contents of your route changes will go. Everything you put around it will not be changed when you switch to a new route, so this is where you place static elements, such as headers, footers, and asides.</p><p>When you have put all of this together, you've got all the pieces you need to start building your webshop. You have now implemented the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The scaffold from <a class="link" href="ch01.html" title="Chapter 1. Diving Headfirst into ReactJS">Chapter 1</a>, <span class="emphasis"><em>Diving Headfirst into ReactJS</em></span></li><li class="listitem" style="list-style-type: disc">Bootstrap for ReactJS</li><li class="listitem" style="list-style-type: disc">A way to handle route changes</li><li class="listitem" style="list-style-type: disc">A polyfill for older browsers</li></ul></div><p>Don't be discouraged when your web browser shows a blank web page when you run this code. This is the expected output at this point.</p></div><div class="section" title="The menu and footer"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>The menu and footer</h2></div></div></div><p>It's time to start<a class="indexterm" id="id83"/> working on the visible menu components. Let's begin with the menu and the footer. Looking <a class="indexterm" id="id84"/>at our mock-up, we see that we want to build a full-width section with the brand name of the shop and the menu links, and at the bottom, we want a single centered line of text with a copyright notice.</p><p>We'll do this by<a class="indexterm" id="id85"/> adding the following import to our <code class="literal">import</code> section in the <code class="literal">layout.jsx</code> file:</p><div class="informalexample"><pre class="programlisting">import Menu from "./components/menu.jsx";
import Footer from "./components/footer";</pre></div><p>Replace the <code class="literal">render</code> function with this code snippet:</p><div class="informalexample"><pre class="programlisting">render() {
  return (
    &lt;div&gt;
      &lt;Menu /&gt;

        { React.cloneElement (
          this.props.children,
          this.state
        ) }

      &lt;Footer /&gt;

    &lt;/div&gt;
  );
}</pre></div><p>Next, create a<a class="indexterm" id="id86"/> directory called <code class="literal">components</code> and place a file called <code class="literal">menu.jsx</code> in there. Add the following code inside the <code class="literal">menu.jsx</code> file:</p><div class="informalexample"><pre class="programlisting">"use strict";
import React from "react";
import { Nav, NavItem, Navbar, Button };
import { Link } from 'react-router';
import { LinkContainer } from "react-router-bootstrap";</pre></div><p>These imports pull in <code class="literal">Nav</code>, <code class="literal">NavItem</code>, <code class="literal">Navbar</code>, <code class="literal">Button</code>, and <code class="literal">LinkContainer</code> via destructuring, as mentioned in <a class="link" href="ch01.html" title="Chapter 1. Diving Headfirst into ReactJS">Chapter 1</a>, <span class="emphasis"><em>Diving Headfirst into ReactJS</em></span>:</p><div class="informalexample"><pre class="programlisting">const Menu = React.createClass ({
  render() {
    return (
      &lt;Navbar inverse fixedTop&gt;
        &lt;Navbar.Header&gt;
          &lt;Navbar.Brand&gt;
            &lt;Link to="/"&gt;My webshop&lt;/Link&gt;
          &lt;/Navbar.Brand&gt;
          &lt;Navbar.Toggle /&gt;
        &lt;/Navbar.Header&gt;</pre></div><p>We create a <code class="literal">Navbar</code> instance with a linked brandname. If you want an image instead of a text brand, you<a class="indexterm" id="id87"/> can insert a JSX node instead of a text string, like this:</p><div class="informalexample"><pre class="programlisting">brand={&lt;span class="logo"&gt;&lt;img src="http://placehold.it/100/30/" height="30" width="100" alt="My webshop" /&gt;&lt;/span&gt;}.</pre></div><p>The <code class="literal">fixedTop</code> option creates a fixed <code class="literal">Navbar</code> instance that sticks to the top of your screen. Replace it with <code class="literal">staticTop</code> if you want a floating Navbar instance instead. You can also add <code class="literal">inverse</code> if you want a black Navbar instance instead of a grey one:</p><div class="informalexample"><pre class="programlisting">        &lt;Navbar.Collapse&gt;
          &lt;Nav&gt;
            &lt;LinkContainer  eventKey={1} to="/company"&gt;
              &lt;Button bsStyle="link"&gt;
                About
              &lt;/Button&gt;
            &lt;/LinkContainer&gt;

            &lt;LinkContainer  eventKey={2} to="/products"&gt;
              &lt;Button bsStyle="link"&gt;
                Products
              &lt;/Button&gt;
            &lt;/LinkContainer&gt;
          &lt;/Nav&gt;

          &lt;Nav pullRight&gt;
            &lt;LinkContainer to="/checkout"&gt;
              &lt;Button bsStyle="link"&gt;
                Your cart: {this.props.cart.length} items
              &lt;/Button&gt;
            &lt;/LinkContainer&gt;
          &lt;/Nav&gt;
        &lt;/Navbar.Collapse&gt;
      &lt;/Navbar&gt;</pre></div><p>We add three navigation items<a class="indexterm" id="id88"/> in our navigation bar, like in our mock-up. We also<a class="indexterm" id="id89"/> provide a <span class="strong"><strong>right</strong></span> keyword so that the items in your Navbar instance are aligned to the right. These links redirect to those pages that we haven't made yet, so we will have to make these next:</p><div class="informalexample"><pre class="programlisting">    );
  }
});
module.exports = Menu;</pre></div><p>That's it for the menu. We also need to add the footer, so go ahead and add a file called <code class="literal">footer.jsx</code> in the <a class="indexterm" id="id90"/>
<code class="literal">components</code> folder<a class="indexterm" id="id91"/> and add the following code:</p><div class="informalexample"><pre class="programlisting">"use strict";
import React from "react";

const Footer = React.createClass({
  render() {
    return (
      &lt;footer className="footer text-center"&gt;
        &lt;div className="container"&gt;
          &lt;p className="text-muted"&gt;Copyright 2015 Your Webshop.
            All rights reserved.
          &lt;/p&gt;
        &lt;/div&gt;
      &lt;/footer&gt;
    );
  }

});
module.exports = Footer;</pre></div></div><div class="section" title="Creating the pages"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Creating the pages</h2></div></div></div><p>Let's create a <a class="indexterm" id="id92"/>subfolder called <code class="literal">pages</code> and add the following files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">pages/products.jsx</code>:<div class="informalexample"><pre class="programlisting">"use strict";
import React from "react";

const Products = React.createClass ({
  render() {
    return (
      &lt;div /&gt;
    );
  }
});
module.exports = Products;</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">pages/company.jsx</code>:<div class="informalexample"><pre class="programlisting">"use strict";
import React from "react";
import { Grid, Row, Col, Panel } from "react-bootstrap";

const Company = React.createClass ({
  render() {
    return (
      &lt;Grid&gt;
        &lt;Row&gt;
          &lt;Col xs={12}&gt;
            &lt;Panel&gt;
              &lt;h1&gt;The company&lt;/h1&gt;

              &lt;p&gt;Contact information&lt;/p&gt;
              &lt;p&gt;Phone number&lt;/p&gt;
              &lt;p&gt;History of our company&lt;/p&gt;

            &lt;/Panel&gt;
          &lt;/Col&gt;
        &lt;/Row&gt;
      &lt;/Grid&gt;
    );
  }

});
module.exports = Company;</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">pages/checkout.jsx</code>:<div class="informalexample"><pre class="programlisting">"use strict";
import React from "react";

const Products = React.createClass ({
  render() {
    return (
      &lt;div /&gt;
    );
  }
});
module.exports = Checkout;</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">pages/receipt.jsx</code>:<div class="informalexample"><pre class="programlisting">"use strict";
import React from "react";

const Receipt = React.createClass ({
  render() {
    return (
      &lt;div /&gt;
    );
  }
});
module.exports = Receipt;</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">pages/item.jsx</code>:<div class="informalexample"><pre class="programlisting">"use strict";
import React from "react";

const Item = React.createClass ({
  render() {
    return (
      &lt;div /&gt;
    );
  }
});
module.exports = Item;</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">pages/home.jsx</code>:<div class="informalexample"><pre class="programlisting">"use strict";
import React from "react";
import { Grid, Row, Col, Jumbotron } from "react-bootstrap";
import { LinkContainer } from "react-router-botstrap";
import { Link } from 'react-router';

const Home = React.createClass ({
  render() {
    return (
      &lt;Grid&gt;
        &lt;Row&gt;
          &lt;Col xs={12}&gt;
            &lt;Jumbotron&gt;
              &lt;h1&gt;My webshop!&lt;/h1&gt;

              &lt;p&gt;
                Welcome to my webshop.
                This is a simple information
                unit where you can showcase
                your best products or
                tell a little about your webshop.
              &lt;/p&gt;

              &lt;p&gt;
                &lt;LinkContainer to="/products"&gt;
                  &lt;Button bsStyle="primary"
                    to="/products"&gt;View products&lt;/Button&gt;
                &lt;/LinkContainer&gt;
              &lt;/p&gt;
            &lt;/Jumbotron&gt;
          &lt;/Col&gt;
        &lt;/Row&gt;
      &lt;/Grid&gt;
    );
  }

});
module.exports = Home;</pre></div></li></ul></div><p>Now, let's add the<a class="indexterm" id="id93"/> links we just created in our routes. Open the <code class="literal">routes.jsx</code> file and add the following content to the imports section:</p><div class="informalexample"><pre class="programlisting">import Products from "./pages/products.jsx";
import Home from "./pages/home.jsx";
import Company from "./pages/company.jsx";
import Item from "./pages/item.jsx";
import Checkout from "./pages/checkout.jsx";
import Receipt from "./pages/receipt.jsx";</pre></div><p>Replace the <code class="literal">&lt;Route handler={Layout} path="/"&gt;&lt;/Route&gt;</code> code block with this:</p><div class="informalexample"><pre class="programlisting">&lt;Route handler={Layout}&gt;
  &lt;Route name="home"
    path="/"
    handler={Home} /&gt;
  &lt;Route name="company"
    path="company"
    handler={Company} /&gt;
  &lt;Route name="products"
    path="products"
    handler={Products} /&gt;
  &lt;Route name="item"
    path="item/:id"
    handler={Item} /&gt;
  &lt;Route name="checkout"
    path="checkout"
    handler={Checkout} /&gt;
  &lt;Route name="receipt"
    path="receipt"
    handler={Receipt} /&gt;
&lt;/Route&gt;</pre></div><p>We've added the <code class="literal">receipt</code> page to our file structure and the routes, but it will not be visible in the menu bar because you should only be redirected to the <code class="literal">receipt</code> page after you've checked out an order.</p><p>If you run the app now, you'll see a menu bar on top of the screen, which you can click on. You'll note that <a class="indexterm" id="id94"/>when you click on any of the menu options, the app will route to the chosen page. You'll also note that the chosen route will be highlighted in the menu bar, which makes it easy to know where you are, without looking at the route in the address bar.</p><p>When you open the app in the responsive mode in your web browser or open the app on a smartphone, you'll note that the menu collapses and that a <span class="strong"><strong>Hamburger</strong></span> button appears instead of the menu links. When you click on this button, the menu expands and presents the links in a drop-down menu.</p></div><div class="section" title="Creating a database of products"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Creating a database of products</h2></div></div></div><p>Your shops need products, so we're going to provide a small set of items for our web shop.</p><p>This kind of data is<a class="indexterm" id="id95"/> usually stored in some kind of database. The database can be self provided either locally or remotely or you can use any of the many cloud-based database services. Traditionally, you would use a database <a class="indexterm" id="id96"/>based on <span class="strong"><strong>SQL</strong></span> (<span class="strong"><strong>Structured Query Language</strong></span>), but nowadays, it's common to go for the <span class="strong"><strong>NoSQL</strong></span> document-based approach. This is what we'll do for <a class="indexterm" id="id97"/>our webshop, and we'll simply use a flat file for the data.</p><p>Create a file and call it <code class="literal">products.json</code>, save it in the <code class="literal">public</code> folder, and add the following content:</p><div class="informalexample"><pre class="programlisting">{
  "products": {
    "main_offering": [
      {
        "World's best novel": {
          "SKU": "NOV",
          "price": "$21.90",
          "savings": "24% off",
          "description": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
          "image": "http://placehold.it/{size}&amp;text=The Novel"
        }
      }
    ],
    "sale_offerings": [
      {
        "Fantasy book": {
          "SKU": "FAN",
          "price": "$6.99",
          "savings": "80% off",
          "description": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
          "image": "http://placehold.it/{size}&amp;text=Fantasy"
        }
      },
      {
        "Mystery book": {
          "SKU": "MYS",
          "price": "$8.99",
          "savings": "34% off",
          "description": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
          "image": "http://placehold.it/{size}&amp;text=Mystery"
        }
      },
      {
        "Adventure book": {
          "SKU": "ADV",
          "price": "$7.99",
          "savings": "62% off",
          "description": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
          "image": "http://placehold.it/{size}&amp;text=Adventure"
        }
      },
      {
        "Science fiction book": {
          "SKU": "SCI",
          "price": "$5.99",
          "savings": "32% off",
          "description": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
          "image": "http://placehold.it/{size}&amp;text=Sci-Fi"
        }
      },
      {
        "Childrens book": {
          "SKU": "CHI",
          "price": "$7.99",
          "savings": "12% off",
          "description": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
          "image": "http://placehold.it/{size}&amp;text=Childrens"
        }
      },
      {
        "Economics book": {
          "SKU": "ECO",
          "price": "$25.99",
          "savings": "7% off",
          "description": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
          "image": "http://placehold.it/{size}&amp;text=Economics"
        }
      }
    ]
  }
}</pre></div><p>This file is equivalent to what you would find if you inserted a few products in a NoSQL database, such as<a class="indexterm" id="id98"/> <span class="strong"><strong>MongoDB</strong></span>. The syntax is <span class="strong"><strong>JSON</strong></span> (<span class="strong"><strong>JavaScript Object Notation</strong></span>), an open format that<a class="indexterm" id="id99"/> transports data as attribute-value pairs. It's simple and language-independent, and just by looking at the preceding structure, you can easily understand its data structure and<a class="indexterm" id="id100"/> contents.</p><p>The fields should be self-explanatory, but let's walk through them. There are two groups of products, one for the main range and one for the sales range. The main range has only one item and the sales range has six. The products in each list have a title, an <span class="strong"><strong>SKU</strong></span> (<span class="strong"><strong>store keeping unit</strong></span>, for<a class="indexterm" id="id101"/> example, a product code), a price, a conveniently formatted savings text, a description, and an image URL. We've elected to insert a placeholder code for the pixel size of the image because we want to be able to dynamically alter the sizes when we present the pictures to the user.</p><p>We want to access this file by going to <code class="literal">http://localhost:3000/products.json</code>, so we need to make an addition to <code class="literal">server.js</code>. Edit this file, and before the line with <code class="literal">app.listen</code>, add the following code and restart the server:</p><div class="informalexample"><pre class="programlisting">// json
app.get('*.json', function (req, res) {
  res.sendFile(__dirname+"/public/"+req.path);
});</pre></div><p>When you access <code class="literal">http://localhost:3000/products.json</code>, you should be served our products.</p></div><div class="section" title="Creating a data store to fetch the products"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec32"/>Creating a data store to fetch the products</h2></div></div></div><p>The application <a class="indexterm" id="id102"/>architecture suggested for use with<a class="indexterm" id="id103"/> ReactJS is called <span class="strong"><strong>Flux</strong></span>. It's not a framework though, but can be seen as more of a pattern to transmit data.</p><p>Flux consists of three major parts: the dispatchers, stores, and actions. The central idea behind Flux is a concept known as <span class="emphasis"><em>unidirectional data flow</em></span>. The idea is that your app should have a store to hold your data and that your components should listen to it for updates. You interact with it using dispatchers, which you can think of as messengers that pass instructions to your actions. In your actions, you can fetch new data and pass it over to the store, which in turn emits data to your components.</p><p>This pattern avoids the common problem of having multiple places where you need to update the state of your application, which often leads to bugs that are hard to track down.</p><p>This may be a bit much to digest, so let's take a quick look at the individual components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Dispatcher</strong></span>: This is the<a class="indexterm" id="id104"/> central hub. It receives actions and sends payloads to all of its registered callbacks.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Actions</strong></span>: These<a class="indexterm" id="id105"/> refer to helper methods that facilitate the passing of data to the dispatcher.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Stores</strong></span>: These are<a class="indexterm" id="id106"/> logic containers that have callbacks registered on the dispatcher, which emits state changes to all registered callbacks.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Views</strong></span>: This<a class="indexterm" id="id107"/> refers to those React components that get a state from the stores and pass data to any of the descendants in their component tree.</li></ul></div><p>There are a multitude<a class="indexterm" id="id108"/> of different Flux implementations. For this chapter, I've chosen Reflux as the Flux implementation, but we'll look at a different implementation called <span class="strong"><strong>Redux</strong></span> in <a class="link" href="ch06.html" title="Chapter 6. Advanced React">Chapter 6</a>, <span class="emphasis"><em>Advanced React</em></span>, and an alternate solution in <a class="link" href="ch07.html" title="Chapter 7. Reactagram">Chapter 7</a>, <span class="emphasis"><em>Reactagram</em></span>. </p><p>Reflux ditches the concept of a single central dispatcher, choosing to merge the concept of dispatcher and action. This lets us get away with less code and results in a code base that is easier to understand.</p><p>Let's create a<a class="indexterm" id="id109"/> <span class="strong"><strong>Reflux</strong></span> implementation.</p><p>We already installed <span class="emphasis"><em>Reflux</em></span> and the HTTP request library called <a class="indexterm" id="id110"/>
<span class="strong"><strong>Superagent</strong></span> that we'll use to fetch our product's data when we bootstrapped our application at the beginning of the chapter, so we're ready to start with <span class="emphasis"><em>Reflux</em></span> right away.</p><p>Let's create our first store. Make two folders: <code class="literal">stores</code> and <code class="literal">actions</code>. Create two files, <code class="literal">stores/products.js</code> and <code class="literal">actions/products.js</code>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>
<code class="literal">Stores</code> and <code class="literal">Actions</code> are regular JavaScript files, and unlike the ReactJS components, they don't use <code class="literal">.jsx</code> file ending.</p></div></div><p>In <code class="literal">actions/products.js</code>, add the following code:</p><div class="informalexample"><pre class="programlisting">"use strict";

import Reflux from 'reflux';

const Actions = {
  FetchProducts: Reflux.createAction("FetchProducts")
};

module.exports = Actions;</pre></div><p>In this file, we define a single<a class="indexterm" id="id111"/> key called <span class="strong"><strong>FetchProducts</strong></span>. We then assign a Reflux action with the same <a class="indexterm" id="id112"/>name. It's possible to define a different name, but this will only lead to confusion later, so in order to keep the code base sane, it's advisable to duplicate the key name.</p><p>In <code class="literal">stores/products.js</code>, add the following code:</p><div class="informalexample"><pre class="programlisting">"use strict";
import Reflux from 'reflux';
import Request from 'superagent';
import Actions from './actions/products';</pre></div><p>Here, we import the action that we just created along with <code class="literal">superagent</code> and <code class="literal">reflux</code>:</p><div class="informalexample"><pre class="programlisting">const ProductStore = Reflux.createStore ({

  init() {
    this.listenTo(Actions.FetchProducts, this.onFetchProducts);</pre></div><p>The <code class="literal">init()</code> method will be executed once and is run immediately on import. This means that it starts executing everything that you've put in <code class="literal">init()</code> as soon as the page is processed:</p><div class="informalexample"><pre class="programlisting">  },
  onFetchProducts() {
    Request
      .get('/products.json')
      .end((err, res)=&gt; {
        this.trigger(JSON.parse(res.text));
      });
  }</pre></div><p>Here, we simply access <code class="literal">product.json</code>, and when it's loaded, we emit the result to all those components that listen to updates from this store. Emits with Reflux is done using the <code class="literal">this.trigger()</code> built-in method and it emits the object that you pass within the parentheses:</p><div class="informalexample"><pre class="programlisting">});

module.exports = ProductStore;</pre></div><p>Now that<a class="indexterm" id="id113"/> this is taken care of, the next step is to listen to updates from this store in our code. Open <code class="literal">layout.jsx</code> and add the following imports:</p><div class="informalexample"><pre class="programlisting">import Actions from "./actions/products"
import ProductStore from "./stores/products"</pre></div><p>Then, add the following code just above the <code class="literal">render()</code> method:</p><div class="informalexample"><pre class="programlisting">mixins:[
  Reflux.listenTo(ProductStore, 'onFetchProducts')
],
componentDidMount() {
  Actions.FetchProducts();
},
onFetchProducts(data){
  this.setState({products: data.products});
},</pre></div><p>This is exciting because we're finally starting to populate our app with content. Whenever the store emits data now, this component will pick it up and propagate it to its children components via the state object.</p></div><div class="section" title="Building the product's listing and the item page"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec33"/>Building the product's listing and the item page</h2></div></div></div><p>The view we're <a class="indexterm" id="id114"/>going to build now will present users with a selection of your book titles. It will start with the main offering as a full-size column and then <a class="indexterm" id="id115"/>provide other offerings in three smaller columns.</p><p>Let's open <code class="literal">pages/products.jsx</code> and write code that will display the product's data. Replace everything in the file with the following code:</p><div class="informalexample"><pre class="programlisting">"use strict";
import React from "react";
import { Grid, Row, Col, Button } from "react-bootstrap";
import { Link } from "react-router";

const Products = React.createClass ({
  propTypes: {
    products: React.PropTypes.object
  },
  getDefaultProps() {
    return {
      products: {
        main_offering: [],
        sale_offerings: []
      }
    }
  },
  render() {
    return (
      &lt;Grid&gt;
        &lt;Offerings productData={this.props.products.main_offering}
        type={"main"} maxProducts={1}/&gt;
        &lt;Offerings productData={this.props.products.sale_offerings}
        type={"ribbon"} maxProducts={3}/&gt;
      &lt;/Grid&gt;
    );
  }
});</pre></div><p>We expect to<a class="indexterm" id="id116"/> receive a <code class="literal">data</code> property called products with two lists: a main offering and a sales offering. You'll probably remember these from <code class="literal">products.json</code>, where we defined them. In our render code, we create a Bootstrap grid and create two<a class="indexterm" id="id117"/> nodes with a new component<a class="indexterm" id="id118"/> called <span class="strong"><strong>offerings</strong></span>. We're providing three properties to this component: a list of products, a type, and maximum amount of products that we want to display. In this context, <code class="literal">type</code> is a string and can be either <code class="literal">main</code> or <code class="literal">ribbon</code>:</p><div class="informalexample"><pre class="programlisting">const Offerings = React.createClass ({
  propTypes: {
    type: React.PropTypes.oneOf(['main', 'ribbon']),
    maxProducts: React.PropTypes.number,
    productData: React.propTypes.array
  },
  getDefaultProps() {
    return {
      type: "main",
      maxProducts: 3
    }
  },
  render() {
    let productData = this.props.productData.filter((data, idx)=&gt; {
      return idx &lt; this.props.maxProducts;
    });
    let data = productData.map((data, idx)=&gt; {
      if(this.props.type === "main") {
        return &lt;MainOffering
          {...this.props} key={idx}
          productData={data}/&gt;
      }
      else if(this.props.type === "main") {
        return &lt;RibbonOffering
          {...this.props} key={idx}
          productData={data}/&gt;
      }
    });
    return &lt;Row&gt;{data}&lt;/Row&gt;;
  }
});</pre></div><p>In the <code class="literal">map</code> function, we have assigned a new <a class="indexterm" id="id119"/>property called <span class="strong"><strong>key</strong></span>. This is to help ReactJS uniquely identify the <a class="indexterm" id="id120"/>components. Any component with a key will be reordered and reused in the rendering process.</p><p>When you're dealing with props, it's usually a good idea to define a set of default properties for the<a class="indexterm" id="id121"/> data you want to work with. It's also a way of documenting by writing easily understandable code. In this example, it's very easy to infer just by looking at the property type and the default property that <code class="literal">maxProducts</code> defines the maximum number of products to be displayed. However, <code class="literal">type</code> is still hard to understand. As you know, it's a string and can be <code class="literal">main</code>. Knowing that it also can be assigned as a <span class="emphasis"><em>ribbon</em></span> is something that you need to read the rest of the source code to understand. In these cases, it may be helpful to provide the optional values in a docblock code. For instance, documenting this property can be done by adding a docblock like this: <code class="literal">@param {string} type "main"|"ribbon"</code>.</p><p>Reducing the product data is done by applying a <code class="literal">filter</code> function to the list of products and returning the first matches by the <code class="literal">index</code> value. We then run a <code class="literal">map</code> function on the remaining data and return either a <code class="literal">MainOffering</code> component if <code class="literal">type</code> is <code class="literal">main</code> or a <code class="literal">RibbonOffering</code> component if <code class="literal">type</code> is <code class="literal">ribbon</code>:</p><div class="informalexample"><pre class="programlisting">const MainOffering = React.createClass ({
  propTypes: {
    productData: React.PropTypes.object
  },
  render() {
    const title = Object.keys(this.props.productData);
    if(this.props.productData[title]){
      (&lt;Col xs={12}&gt;
        &lt;Col md={3} sm={4} xs={12}&gt;
          &lt;p&gt;
            &lt;img src={this.props.productData[title].
            image.replace("{size}","200x150")}/&gt;
          &lt;/p&gt;
        &lt;/Col&gt;
        &lt;Col md={9} sm={8} xs={12}&gt;
          &lt;Link to={"/item/"+this.props.productData[title].SKU}&gt;
            &lt;h4&gt;{title}&lt;/h4&gt;
          &lt;/Link&gt;

          &lt;p&gt;
            {this.props.productData[title].description}
          &lt;/p&gt;

          &lt;p&gt;
            {this.props.productData[title].price}
            {" "}
            ({this.props.productData[title].savings})
          &lt;/p&gt;

          &lt;p&gt;
            &lt;Button bsSize="large"&gt;Add to cart&lt;/Button&gt;
          &lt;/p&gt;
        &lt;/Col&gt;
      &lt;/Col&gt;
    )} else {
      return null;
    }
  }
});</pre></div><p>The <code class="literal">MainOffering</code> component creates a full-sized column with a large product image to the left and it also creates a price, description, and a buy button to the right. The product image gets the 200 x 150 by way of replacing the <code class="literal">{size}</code> template with a <code class="literal">string</code> value. <code class="literal">Placehold.it</code> is a <a class="indexterm" id="id122"/>convient service that you can use to display a dummy<a class="indexterm" id="id123"/> image until you've got a real image to show. There are a number of such services online, ranging from the plain ones, such as <code class="literal">placehold.it</code>, to services showing dogs and cats to nature, technology, and architecture:</p><div class="informalexample"><pre class="programlisting">const RibbonOffering = React.createClass ({
  propTypes: {
    productData: React.PropTypes.object
  },
  render() {
    const title = Object.keys(this.props.productData);
    if(this.props.productData) {
      return (&lt;Col md={4} sm={4} xs={12}&gt;
        &lt;Col xs={12}&gt;
          &lt;p&gt;
            &lt;img src={this.props.productData[title].image.
            replace("{size}","200x80")}/&gt;
          &lt;/p&gt;
        &lt;/Col&gt;
        &lt;Col xs={12}&gt;
          &lt;Link to={"/item/"+this.props.productData[title].SKU}&gt;
            &lt;h4&gt;{title}&lt;/h4&gt;
          &lt;/Link&gt;

          &lt;p&gt;
            {this.props.productData[title].description}
          &lt;/p&gt;

          &lt;p&gt;
            {this.props.productData[title].price} 
            {" "}
            ({this.props.productData[title].savings})
          &lt;/p&gt;

          &lt;p&gt;
            &lt;Button bsSize="large"&gt;Add to cart&lt;/Button&gt;
          &lt;/p&gt;
        &lt;/Col&gt;
      &lt;/Col&gt;)
    }
    else {
      return null;
    }
  }
});</pre></div><p>It's worth mentioning here that in the <code class="literal">render()</code> method, we either return a ReactJS node or <code class="literal">null</code> if <code class="literal">this.props.productData</code> has a title. The reason that we do this is because when we mount the<a class="indexterm" id="id124"/> component, <code class="literal">productData</code> will be unpopulated. If we<a class="indexterm" id="id125"/> try to use the property at this point, ReactJS will return an error. It will be populated as soon as the data has been fetched in the <span class="emphasis"><em>store</em></span>, and that may take a few milliseconds or it may take a bit long depending on a number of things, but primarily, it depends on latency, which means it's very unlikely that the data is available when you mount the component. In any case, you shouldn't rely on that, so it's better to return nothing until the data is available:</p><div class="informalexample"><pre class="programlisting">module.exports = Products;</pre></div><p>We've defined a number of components in this file, but note that we only export the main one, called products. The other components will not be available via destructuring because they have not been exported.</p><p>We've linked <a class="indexterm" id="id126"/>our items to the <code class="literal">item</code> page, so we need to flesh it out and retrieve the item data when the customer visits this page.</p><p>Open <code class="literal">pages/item.jsx</code> and replace the content with this code:</p><div class="informalexample"><pre class="programlisting">"use strict";
import React from "react";
import Reflux from "reflux";
import { Router, State } from "react-router";
import { Grid, Row, Col, Button } from "react-bootstrap";
import CartActions from "../actions/cart";

const Item = React.createClass ({
  mixins: [
    Router.State
  ],
  render() {
    if (!this.props.products) return null;

    // Find the requested product in our product list
    let products = this.props.products.main_offering.concat(this.props.products.sale_offerings);
    let data = products.filter((item)=&gt; {
      return item[Object.keys(item)].SKU ===
        this.props.routeParams.id;
    });</pre></div><p>Here, we take advantage of the fact that all of our products exist as a property to this page and that they simply return a filtered object list from the complete product list. The filter is based on <code class="literal">this.getParams().id</code>. This is a built-in <span class="emphasis"><em>mixin</em></span> provided by <code class="literal">react-router</code>, which fetches the <code class="literal">id</code> key defined in <code class="literal">routes.jsx</code>.</p><p>A <span class="strong"><strong>mixin</strong></span> is a piece of <a class="indexterm" id="id127"/>code that contains methods that<a class="indexterm" id="id128"/> can be included in other pieces of code without the use of inheritance. This is advantageous because it allows easy code injection and reuse. This has drawbacks as well because uncritical use of mixins can lead to confusion regarding the origin of the code you're using:</p><div class="informalexample"><pre class="programlisting">    if(!data.length){
      return (&lt;Grid&gt;
      &lt;Row&gt;
        &lt;Col xs={12}&gt;
          &lt;h1&gt;Product missing&lt;/h1&gt;
          &lt;p&gt;
            I'm sorry, but the product could not be found.
          &lt;/p&gt;
        &lt;/Col&gt;
      &lt;/Row&gt;
    &lt;/Grid&gt;)} else {
      return (&lt;Grid&gt;
        &lt;Row&gt;
          &lt;Col xs={12}&gt;
            &lt;ProductInfo productData={data[0]}/&gt;
          &lt;/Col&gt;
        &lt;/Row&gt;
      &lt;/Grid&gt;
    )};
  }
});</pre></div><p>This return <a class="indexterm" id="id129"/>declaration checks the new object list for its length and either<a class="indexterm" id="id130"/> provides the item information or an information block informing the customer that the product couldn't be found:</p><div class="informalexample"><pre class="programlisting">const ProductInfo = React.createClass ({
  propTypes: {
    productData: React.PropTypes.object
  },
  render() {
    const title = Object.keys(this.props.productData);
    if(this.props.productData[title]){
      (&lt;Col xs={12}&gt;
        &lt;Col md={3} sm={4} xs={12}&gt;
          &lt;p&gt;
            &lt;img src={this.props.productData[title].
            image.replace("{size}","200x150")}/&gt;
          &lt;/p&gt;
        &lt;/Col&gt;
        &lt;Col md={9} sm={8} xs={12}&gt;
          &lt;h4&gt;{title}&lt;/h4&gt;
          &lt;p&gt;
            {this.props.productData[title].description}
          &lt;/p&gt;

          &lt;p&gt;
            {this.props.productData[title].price}
            {" "}
            ({this.props.productData[title].savings})
          &lt;/p&gt;

          &lt;p&gt;
            &lt;Button bsSize="large"
              onClick={CartActions.AddToCart.
              bind(null, this.props.productData)}&gt;
              Add to cart
            &lt;/Button&gt;
          &lt;/p&gt;
        &lt;/Col&gt;
      &lt;/Col&gt;
    )}
    else {
      return null;
    }
  }
});
module.exports = Item;</pre></div><p>The<a class="indexterm" id="id131"/> last piece<a class="indexterm" id="id132"/> of code prints out the product information.</p><p>This is how the final result should appear:</p><div class="mediaobject"><img alt="Building the product's listing and the item page" src="graphics/B04943_02_02.jpg"/></div><p>The final piece <a class="indexterm" id="id133"/>of the puzzle adds the action that puts the item<a class="indexterm" id="id134"/> in your cart. For that, we need to make another action file and a cart store.</p></div><div class="section" title="Creating a cart store"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec34"/>Creating a cart store</h2></div></div></div><p>We'll need to<a class="indexterm" id="id135"/> add two more files to our project, <code class="literal">actions/cart.js</code> and <code class="literal">store/carts.js</code>. Create these files and add this code to the <code class="literal">actions</code> file:</p><div class="informalexample"><pre class="programlisting">"use strict";

import Reflux from "reflux";

const Cart = {
  AddToCart: Reflux.createAction("AddToCart"),
  RemoveFromCart: Reflux.createAction("RemoveFromCart"),
  ClearCart: Reflux.createAction("ClearCart")
};

module.exports = Cart;</pre></div><p>We define three actions, one for adding items, one for removing them, and the third for clearing the cart.</p><p>Open <code class="literal">store/carts.js</code> and add the following piece of code:</p><div class="informalexample"><pre class="programlisting">"use strict";
import Reflux from "reflux";
import CartActions from "../actions/cart";
let _cart = {cart: []};</pre></div><p>This is our <code class="literal">store</code> object. Initializing it outside <code class="literal">CartStore</code> itself makes it private and hidden, making it impossible to import <code class="literal">CartStore</code> and modify the <code class="literal">store</code> object directly. It's customary, but <a class="indexterm" id="id136"/>not necessary, to prefix such objects with an underscore. It's simply a way of indicating that we're working with a <code class="literal">private</code> object:</p><div class="informalexample"><pre class="programlisting">const CartStore = Reflux.createStore ({

  init() {
    this.listenTo(CartActions.AddToCart, this.onAddToCart);
    this.listenTo(CartActions.RemoveFromCart, this.onRemoveFromCart);
    this.listenTo(CartActions.ClearCart, this.onClearCart);
  },</pre></div><p>These are the actions we'll listen and respond to. Whenever any of the preceding actions are called in our code, the function that we connect to the action will be executed:</p><div class="informalexample"><pre class="programlisting">  onAddToCart(item){
    _cart.cart.push(item);
    this.emit();
  },</pre></div><p>When we call <code class="literal">CartActions.AddToCart</code> with an item in our code, this code will add the item to our <code class="literal">cart</code> object. We then call <code class="literal">this.emit()</code>, which is our store emitter. We could just as easily call <code class="literal">this.trigger</code> directly (which is the native <code class="literal">Reflux</code> function for emitting data), but having a single function responsible for emitting data is beneficial if you need to perform any functions or execute any code before emitting the data:</p><div class="informalexample"><pre class="programlisting">  onRemoveFromCart(item) {
    _cart.cart = _cart.cart.filter((cartItem)=&gt; {
      return item !== cartItem
    });
    this.emit();
  },</pre></div><p>This function removes an item from our <code class="literal">cart</code> object using the built-in <code class="literal">filter</code> function in JavaScript. The <code class="literal">filter</code> function returns a new array when called, excluding the item we want removed. We then simply emit the altered <code class="literal">cart</code> object:</p><div class="informalexample"><pre class="programlisting">  onClearCart() {
    _cart.cart = [];
    this.emit();
  },</pre></div><p>This resets the cart and emits the empty <code class="literal">cart</code> object:</p><div class="informalexample"><pre class="programlisting">  emit() {
    this.trigger(_cart);
  }</pre></div><p>In this function, we emit the <code class="literal">cart</code> object. Any component that listens to this store will receive the object and render the new data:</p><div class="informalexample"><pre class="programlisting">});

module.exports = CartStore;</pre></div><p>We also want to<a class="indexterm" id="id137"/> provide the user with some indication of the state of his/her cart, so open up <code class="literal">menu.jsx</code> and replace <code class="literal">NavItemLink</code> for the <code class="literal">Checkout</code> section with the following piece of code:</p><div class="informalexample"><pre class="programlisting">&lt;NavItemLink
  to="/checkout"&gt;
  Your cart: {this.props.cart.length} items
&lt;/NavItemLink&gt;</pre></div><p>Before <code class="literal">render()</code>, add a <code class="literal">defaultProps</code> section with this code:</p><div class="informalexample"><pre class="programlisting">  getDefaultProps() {
    return {
      cart: []
    }
  },</pre></div><p>All state changes go through <code class="literal">layout.jsx</code>, so open this file and add the following import:</p><div class="informalexample"><pre class="programlisting">import CartStore from "./stores/cart"</pre></div><p>In the <code class="literal">mixins</code> section, add a listener for the <code class="literal">cart</code> store and the function that is to be run when the cart emits data. The code should now look like this:</p><div class="informalexample"><pre class="programlisting">  mixins: [
    Reflux.listenTo(ProductStore, 'onFetchProducts'),
    Reflux.listenTo(CartStore, 'onCartUpdated')
  ],
  onCartUpdated(data){
    this.setState({cart: data.cart});
  },</pre></div><p>The <code class="literal">Menu</code> component needs to receive the new state, so provide it with this code:</p><div class="informalexample"><pre class="programlisting">&lt;Menu {...this.state} /&gt;</pre></div><p>Finally, we need to add the action to the <span class="strong"><strong>Add to cart</strong></span> buttons. Edit <code class="literal">pages/products.jsx</code> and replace the button code in <code class="literal">MainOffering</code> and <code class="literal">RibbonOffering</code> with this code:</p><div class="informalexample"><pre class="programlisting">&lt;Button bsSize="large"
  onClick={CartActions.AddToCart.bind(null,
  this.props.productData)}&gt;
  Add to cart
&lt;/Button&gt;</pre></div><p>Add the following<a class="indexterm" id="id138"/> line of code to the imports section as well:</p><div class="informalexample"><pre class="programlisting">import CartActions from "../actions/cart";</pre></div><p>You're set. When you click on the <span class="strong"><strong>Add to cart</strong></span> button in the products page now, the cart will be updated and the menu count will also be updated immediately.</p><div class="mediaobject"><img alt="Creating a cart store" src="graphics/B04943_02_03.jpg"/></div></div><div class="section" title="Checking out"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec35"/>Checking out</h2></div></div></div><p>What good is a <a class="indexterm" id="id139"/>webshop if your customers cannot check out? After all, that's what they're here for. Let's set up a check out screen and let the customer enter a delivery address.</p><p>We need to create some new files: <code class="literal">stores/customer.js</code>, <code class="literal">actions/customer.js</code>, and <code class="literal">components/customerdata.jsx</code>.</p><p>Open <code class="literal">actions/customer.js</code> and add this code:</p><div class="informalexample"><pre class="programlisting">"use strict";

import Reflux from "reflux";

const Actions = {
  SaveAddress: Reflux.createAction("SaveAddress")
};

module.exports = Actions;</pre></div><p>This single action will be responsible for address management.</p><p>Next, open <code class="literal">stores/customer.js</code> and add this code:</p><div class="informalexample"><pre class="programlisting">"use strict";
import Reflux from "reflux";
import CustomerActions from "../actions/customer";
let _customer = {customer: [], validAddress: false};</pre></div><p>As in <code class="literal">cart.js</code>, here we define a <code class="literal">private</code> object to store the state of our store. As you can read from the object definition, we'll store a customer list and a Boolean address validator. We will also import the customer action file that we just created:</p><div class="informalexample"><pre class="programlisting">const CustomerStore = Reflux.createStore({

  init() {
    this.listenTo(CustomerActions.SaveAddress, this.onSaveAddress);
  },

  onSaveAddress(address) {
    _customer = address;
    this.emit();
  },

  emit() {
    this.trigger(_customer);
  }
});

module.exports = CustomerStore;</pre></div><p>You'll recognize the structure of this code from the <code class="literal">cart.js</code> file. We listen to the <code class="literal">SaveAddress</code> action and execute the connected function whenever the action is called. Finally, the<a class="indexterm" id="id140"/> emitter is called every time the state object is changed.</p><p>Before we edit the last new file, let's open <code class="literal">checkout.jsx</code> and set up the code we need there. Replace the current content with this code:</p><div class="informalexample"><pre class="programlisting">"use strict";
import React from "react";
import { Grid, Button, Table, Well } from "react-bootstrap";
import CartActions from "../actions/cart";
import CustomerData from "../components/customerdata";</pre></div><p>We import two new functions from <code class="literal">React-Bootstrap</code> and two of the new files that we just created:</p><div class="informalexample"><pre class="programlisting">const Checkout = React.createClass ({
  propTypes: {
    cart: React.PropTypes.array,
    customer: React.PropTypes.object
  },
  getDefaultProps() {
    return {
      cart: [],
      customer: {
        address: {},
        validAddress: false
      }
    }
  },</pre></div><p>In this section, we initialize the component with two properties: a <code class="literal">cart</code> array and a <code class="literal">customer</code> object:</p><div class="informalexample"><pre class="programlisting">  render() {
    let CheckoutEnabled = (this.props.customer.validAddress &amp;&amp; this.props.cart.length &gt; 0);
    return (
      &lt;Grid&gt;
        &lt;Well bsSize="small"&gt;
          &lt;p&gt;Please confirm your order and checkout your cart&lt;/p&gt;
        &lt;/Well&gt;

        &lt;Cart {...this.props} /&gt;

        &lt;CustomerData {...this.props} /&gt;

        &lt;Button disabled={!CheckoutEnabled}
          bsStyle={CheckoutEnabled ? 
          "success" : "default"}&gt;
          Proceed to checkout
        &lt;/Button&gt;

      &lt;/Grid&gt;
    );
  }
});</pre></div><p>We define a Boolean variable that controls whether the checkout button is visible or not. Our requirements are simply that we want at least one item in our cart and that the customer has entered a valid name address.</p><p>We then display <a class="indexterm" id="id141"/>a simple message to our customer inside a Bootstrap well. Next, we display the cart contents (which we'll define in the following code snippet), and then, we present a series of input fields where the customer can add an address. Finally, we display a button that takes the user to the payment window:</p><div class="informalexample"><pre class="programlisting">const Cart = React.createClass ({
  propTypes: {
    cart: React.PropTypes.array
  },
  render() {
    let total = 0;
    this.props.cart.forEach((data)=&gt; {
      total += parseFloat(data[Object.keys(data)].
        price.replace("$", ""));
    });

    let tableData = this.props.cart.map((data, idx)=&gt; {
      return &lt;CartElement productData={data} key={idx}/&gt;
    });

    if (!tableData.length) {
      tableData = (&lt;tr&gt;
        &lt;td colSpan="3"&gt;Your cart is empty&lt;/td&gt;
      &lt;/tr&gt;);
    }
    return &lt;Table striped condensed&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th width="40%"&gt;Name&lt;/th&gt;
          &lt;th width="30%"&gt;Price&lt;/th&gt;
          &lt;th width="30%"&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        {tableData}
        &lt;tr className="summary" border&gt;
        &lt;td&gt;&lt;strong&gt;Order total:&lt;/strong&gt;&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;${total}&lt;/strong&gt;&lt;/td&gt;
        &lt;td&gt;
          {tableData.length ?
            &lt;Button bsSize="xsmall" bsStyle="danger"
              onClick={CartActions.ClearCart}&gt;
              Clear Cart
            &lt;/Button&gt; : null}
        &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/Table&gt;;
  }
});</pre></div><p>Cart is another React component that takes care of displaying a table with the contents of the customer's cart, including a total amount for the order. We initialize a variable for the total amount and <a class="indexterm" id="id142"/>set it to zero. We then use the built-in <code class="literal">forEach</code> function in JavaScript to loop and walkthrough the <code class="literal">cart</code> contents and create an order total. Since the prices come with a dollar symbol from the JSON file, we need to strip out this before adding the sums (or else JavaScript would simply concatenate the strings). We also use <code class="literal">parseFloat</code> to convert the string into a float.</p><p>In reality, this is not an ideal solution because you don't want to use <code class="literal">float</code> values when working with prices.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>Try adding 0.1 and 0.2 with JavaScript to understand why (hint: it won't equal 0.3).</p></div></div><p>The best solution is to use integers and divide by 100 whenever you want to display fractional values. For that reason, <code class="literal">products.json</code> could be updated to include a price field like this: <code class="literal">"display_price": "$21.90","price": "2190"</code>. Then, we'd work with <code class="literal">price</code> in our code, but use <code class="literal">display_price</code> in our views.</p><p>Next, we walk through our cart content again, but this time using JavaScript's built-in <code class="literal">map</code> function. We return a new array populated with <code class="literal">CartElement</code> nodes. We then render a table and insert the new array that we just created:</p><div class="informalexample"><pre class="programlisting">const CartElement = React.createClass ({
  render() {
    const title = Object.keys(this.props.productData);
    if(title) {
      (&lt;tr&gt;
        &lt;td&gt;{title}&lt;/td&gt;
        &lt;td&gt;{this.props.productData[title].price}&lt;/td&gt;
        &lt;td&gt;
          &lt;Button bsSize="xsmall" bsStyle="danger"
            onClick={CartActions.RemoveFromCart.bind
            (null, this.props.productData)}&gt;
            Remove
          &lt;/Button&gt;
        &lt;/td&gt;
      &lt;/tr&gt;
      )
    }
    else {
      return null
    }
  }
}
);

module.exports = Checkout;</pre></div><p>The <code class="literal">CartElement</code> component should look familiar to you with one exception, the <code class="literal">onClick</code> method has a bind. We do this because we want to pass along the product data when the customer <a class="indexterm" id="id143"/>clicks on the <span class="strong"><strong>Remove</strong></span> button. The first element in the bind is the event and the second is the data. We don't need to pass along the event, so we simply set that to <code class="literal">null</code>.</p><p>Let's take a look at the following screenshot:</p><div class="mediaobject"><img alt="Checking out" src="graphics/B04943_02_04.jpg"/></div><p>We also need<a class="indexterm" id="id144"/> to add the code for <code class="literal">customerdata.jsx</code> so let's open this file and add the following code:</p><div class="informalexample"><pre class="programlisting">"use strict";
import React from "react";
import { FormGroup, FormControl, InputGroup, Button }
  from "react-bootstrap";
  import CustomerActions from "../actions/customer";
  import clone from 'lodash/clone';


const CustomerData = React.createClass ({
  getDefaultProps() {
    return {
      customer: {
        address: {},
        validAddress: false
      }
    }
  },
  getInitialState() {
    return {
      customer:{
        name: this.props.customer.address.name ? 
          this.props.customer.address.name : "",
        address: this.props.customer.address.address ? 
          this.props.customer.address.address : "",
        zipCode: this.props.customer.address.zipCode ? 
          this.props.customer.address.zipCode : "",
        city: this.props.customer.address.city ? 
          this.props.customer.address.city : ""
      },
      validAddress: this.props.customer.validAddress ?
        this.props.customer.validAddress : false
    };
  },</pre></div><p>This might look a bit complicated, but the idea here is that we'll set the customer name and address validation to the same as <code class="literal">this.props</code> if it exists, but if not, we use the default values <a class="indexterm" id="id145"/>of empty strings and set Boolean to <code class="literal">false</code> for address validation.</p><p>The reason we do this is that we want to display whatever data the customer has entered if he/she chooses to add data to the checkout screen, but then decides to visit another part of the store before proceeding to the checkout screen:</p><div class="informalexample"><pre class="programlisting">  validationStateName() {
    if (this.state.customer.name.length &gt; 5)
      return "success";
    else if (this.state.customer.name.length &gt; 2)
      return "warning";
    else 
      return "error";
  },

  handleChangeName(event) {
    let customer = clone(this.state.customer);
    customer.name = event.target.form[0].value;
    this.setState({
      customer,
      validAddress: this.checkAllValidations()
    });
    CustomerActions.SaveAddress(this.state);
  },</pre></div><p>This is the first of four similar sections that deal with input validation. The validation is only based on string length, but it can be replaced with any desired validation logic.</p><p>In <code class="literal">handleChangeName</code>, we clone the state in a local variable (making sure we don't accidentally mutate the state manually), and then, we set the new value for the name from the input field. The input value is fetched via <code class="literal">refs</code>, which is a ReactJS concept. A reference can <a class="indexterm" id="id146"/>be set to any element and accessed via <code class="literal">this.refs</code>.</p><p>Next, on every change, we check all the validations that we've set up. If all are valid, we set the address validator to Boolean as <code class="literal">true</code>. Finally, we save the state and then run the action that will store the new address in the customer store. This change will be emitted to <code class="literal">layout.jsx</code>, which will then pass the data back to this component, and others which listens to the customer store.</p><div class="informalexample"><pre class="programlisting">  validationStateAddress() {
    if (this.state.customer.address.length &gt; 5)
      return "success";
    else if (this.state.customer.address.length &gt; 2)
      return "warning";
    else 
      return "error";
  },

  handleChangeAddress(event) {
    let customer = clone(this.state.customer);
    customer.address =
      event.target.form[1].value;
    this.setState({
      customer,
      validAddress: this.checkAllValidations()
    });
    CustomerActions.SaveAddress(this.state);
  },

  validationStateZipCode() {
    if (this.state.customer.zipCode.length &gt; 5)
      return "success";
    else if (this.state.customer.zipCode.length &gt; 2)
      return "warning";
    else 
      return "error";
  },

  handleChangeZipCode(event) {
    let customer = clone(this.state.customer);
    customer.zipCode =
      event.target.form[2].value;
    this.setState({
      customer,
      validAddress: this.checkAllValidations()
    });
    CustomerActions.SaveAddress(this.state);
  },

  validationStateCity() {
    if (this.state.customer.city.length &gt; 5)
      return "success";
    else if (this.state.customer.city.length &gt; 2)
      return "warning";
    else 
      return "error";
  },

  handleChangeCity(event) {
    let customer = clone(this.state.customer);
    customer.city =
      event.target.form[3].value;
    this.setState({
      customer,
      validAddress: this.checkAllValidations()
    });
    CustomerActions.SaveAddress(this.state);
  },

  checkAllValidations() {
    return ("success" == this.validationStateName() &amp;&amp;
    "success" == this.validationStateAddress() &amp;&amp;
    "success" == this.validationStateZipCode() &amp;&amp;
    "success" == this.validationStateCity());
  },</pre></div><p>This function returns<a class="indexterm" id="id147"/> Boolean as <code class="literal">true</code> or <code class="literal">false</code> depending on all validation checks:</p><div class="informalexample"><pre class="programlisting">  render() {
    return (
      &lt;div&gt;
        &lt;form&gt;
          &lt;FormGroup&gt;
            &lt;FormControl
              type="text"
              value={ this.state.customer.address.name }
              placeholder="Enter your name"
              label="Name"
              bsStyle={ this.validationStateName() }
              hasFeedback
              onChange={ this.handleChangeName }
            /&gt;
          &lt;/FormGroup&gt;</pre></div><p>Here, we use the Bootstrap <code class="literal">FormGroup</code> and <code class="literal">FormControl</code> functions and set the styling based on the validation check. We set the <code class="literal">ref</code> parameter here that we use to access the value when we<a class="indexterm" id="id148"/> save the name in our customer store. Every time the input field is changed, it's sent to the <code class="literal">onChange</code> handler, <code class="literal">handleChangeName</code>. The rest of the input fields are identical, except that they call upon different change handlers and validators:</p><div class="informalexample"><pre class="programlisting">        &lt;FormGroup&gt;
            &lt;FormControl
              type="text"
              value={ this.state.customer.address }
              placeholder="Enter your street address"
              label="Street "
              bsStyle={ this.validationStateAddress() }
              hasFeedback
              onChange={ this.handleChangeAddress } /&gt;
          &lt;/FormGroup&gt;

          &lt;FormGroup&gt;
            &lt;FormControl
              type="text"
              value={ this.state.customer.zipCode }
              placeholder="Enter your zip code"
              label="Zip Code"
              bsStyle={ this.validationStateZipCode() }
              hasFeedback
            onChange={ this.handleChangeZipCode } /&gt;

          &lt;/FormGroup&gt;
          &lt;FormGroup&gt;

            &lt;FormControl
              type="text"
              value={ this.state.customer.city }
              placeholder="Enter your city"
              label="City"
              bsStyle={this.validationStateCity()}
              hasFeedback
            onChange={this.handleChangeCity}/&gt;

          &lt;/FormGroup&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    );
  }

});
module.exports = CustomerData;</pre></div><p>In order to <a class="indexterm" id="id149"/>propagate the changes in the new customer store from the layout to the children components, we need to make a change in <code class="literal">layout.jsx</code>. Open the file and add this import:</p><div class="informalexample"><pre class="programlisting">import CustomerStore from "./stores/customer" </pre></div><p>Then, in the mixins, add this line of code:</p><div class="informalexample"><pre class="programlisting">Reflux.listenTo(CustomerStore, 'onCustomerUpdated')</pre></div></div><div class="section" title="Providing a receipt"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec36"/>Providing a receipt</h2></div></div></div><p>The next logical step is to take care of payment and provide a receipt for the customer. For payments, you<a class="indexterm" id="id150"/> need an account with a payment provider, such as <span class="strong"><strong>PayPal</strong></span>, <span class="strong"><strong>Klarna</strong></span>, <span class="strong"><strong>BitPay</strong></span>, and so on. Integration is usually very straightforward, and it goes like this:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">You connect to <a class="indexterm" id="id151"/>a data API provided by the payment provider.</li><li class="listitem">Transmit your <a class="indexterm" id="id152"/>API key and the order data.</li><li class="listitem">After the payment <a class="indexterm" id="id153"/>process is finished, the payment provider will redirect to your receipt page and let you know whether the payment was successful or not.</li></ol></div><p>The connection to the payment API should be hooked up to the <span class="strong"><strong>Proceed to checkout</strong></span> button. As the integration with a payment provider differs with every provider, we'll simply provide a receipt page without verifying the payment.</p><p>Open <code class="literal">checkout.jsx</code> and add the following import:</p><div class="informalexample"><pre class="programlisting">import { LinkContainer } from "react-router-bootstrap";</pre></div><p>Then, replace the checkout button with this code:</p><div class="informalexample"><pre class="programlisting">&lt;LinkContainer to="/receipt"&gt;
  &lt;Button
    disabled={!CheckoutEnabled}
    bsStyle= {
      CheckoutEnabled ? "success" : "default"
    }&gt;
    Proceed to checkout
  &lt;/Button&gt;
&lt;/LinkContainer&gt;</pre></div><p>Open <code class="literal">receipt.jsx</code> and replace the content with this code:</p><div class="informalexample"><pre class="programlisting">"use strict";
import React from "react";
import { Grid, Row, Col, Panel, Table } from "react-bootstrap";
import Router from "react-router";
import CartActions from "../actions/cart"
const Receipt = React.createClass ({
  mixins: [
    Router.Navigation
  ],
  componentDidMount() {
    if(!this.props.cart.length) {
      this.props.history.pushState('/');
    }
  },</pre></div><p>Here, we tap into the <code class="literal">history</code> method and notify it to send the customer to the home page if there's no cart data. This is a simple validation to check whether the customer has entered the receipt page outside the predefined path.</p><p>This solution is<a class="indexterm" id="id154"/> not very robust. When you set it up with a payment provider, you will send an identifier to the provider. You need to store this identifier and use this instead to decide whether to show the receipt page and what to show:</p><div class="informalexample"><pre class="programlisting">  propTypes: {
    cart: React.PropTypes.array,
    customer: React.PropTypes.object
  },
  getDefaultProps() {
    return {
      cart: [],
      customer: {
        address: {},
        validAddress: false
      }
    }
  },
  componentWillUnmount() {
    CartActions.ClearCart();
  },
  render() {
    let total = 0;
    this.props.cart.forEach((data)=&gt; {
      total += parseFloat(data[Object.keys(data)].
        price.replace("$", ""));
    });
    let orderData = this.props.cart.map((data, idx)=&gt; {
      return &lt;OrderElement productData={data} key={idx}/&gt;
    });

    return (
      &lt;Grid&gt;
        &lt;Row&gt;
          &lt;Col xs={12}&gt;
            &lt;h3 className="text-center"&gt;
               Invoice for your purchase&lt;/h3&gt;
          &lt;/Col&gt;
        &lt;/Row&gt;
        &lt;Row&gt;
          &lt;Col xs={12} md={12} pullLeft&gt;
            &lt;Panel header={"Billing details"}&gt;
              {this.props.customer.address.name}&lt;br/&gt;
              {this.props.customer.address.address}&lt;br/&gt;
              {this.props.customer.address.zipCode}&lt;br/&gt;
              {this.props.customer.address.city}
            &lt;/Panel&gt;
          &lt;/Col&gt;
          &lt;Col xs={12} md={12}&gt;
            &lt;Panel header={"Order summary"}&gt;
              &lt;Table&gt;
                &lt;thead&gt;
                  &lt;th&gt;Item Name&lt;/th&gt;
                  &lt;th&gt;Item Price&lt;/th&gt;
                &lt;/thead&gt;
                {orderData}
                &lt;tr&gt;
                  &lt;td&gt;&lt;strong&gt;Total&lt;/strong&gt;&lt;/td&gt;
                  &lt;td&gt;${total}&lt;/td&gt;
                &lt;/tr&gt;
              &lt;/Table&gt;
            &lt;/Panel&gt;
          &lt;/Col&gt;
        &lt;/Row&gt;
      &lt;/Grid &gt;
    );
  }
});</pre></div><p>We're reusing code from the checkout page here to show the cart content and the order total. We're also creating a new <code class="literal">OrderElement</code> component in order to display the list of items in the<a class="indexterm" id="id155"/> customer's cart:</p><div class="informalexample"><pre class="programlisting">const OrderElement = React.createClass ({
  render() {
    const title = Object.keys(this.props.productData);
    if(title) {
      (&lt;tr&gt;
        &lt;td&gt;{title}&lt;/td&gt;
        &lt;td&gt;{this.props.productData[title].price}&lt;/td&gt;
      &lt;/tr&gt;
      )
    }
    else {
      return null;
      }
    }
  }
);

module.exports = Receipt;</pre></div><div class="mediaobject"><img alt="Providing a receipt" src="graphics/B04943_02_05.jpg"/></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Summary</h1></div></div></div><p>We've finished our first blueprint, the webshop. You now have a fully functioning shop built with ReactJS. Let's take a look at what we've built in this chapter.</p><p>First, we started detailing the components that we needed to create and made a basic mock-up of how we wanted the site to look. We wanted the design to be responsive and the content visible on a range of devices, from the smallest smart phones to tablets and desktop computers screens.</p><p>We then worked on the layout and chose to use Bootstrap to help us with the responsive functionality. We took the scaffolding from <a class="link" href="ch01.html" title="Chapter 1. Diving Headfirst into ReactJS">Chapter 1</a>, <span class="emphasis"><em>Diving Headfirst into ReactJS</em></span>, and extended it by adding a small number of node modules from the <code class="literal">npm</code> registry, chiefly, <code class="literal">react-router</code>, <code class="literal">react-bootstrap</code>, and the promise-based request library, <code class="literal">superagent</code>.</p><p>We built the web shop based on the concept of unidirectional data flow, following the established Flux pattern where actions go back to the store and the store emits data to the components. Furthermore, we set it up so that all data is routed through the central app and propagated as properties to the child components. This is a powerful pattern because it leaves you with no uncertainty as to where your data originates from, and every part of your app has access to the same data with the same state.</p><p>While making the webshop, we resolved a number of technical hurdles, such as routing, form validation, and array filtering.</p><p>The final app is a basic working webshop that is ready to be developed and styled further.</p><p>In the next chapter, we'll look at how to develop responsive apps with ReactJS! </p></div></body></html>