- en: Chapter 1. Diving Headfirst into ReactJS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章. 深入了解ReactJS
- en: Welcome dear reader! In this book, you'll find a set of blueprints that you
    can use to develop modern web apps with ReactJS.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎亲爱的读者！在本书中，您将找到一套蓝图，您可以使用这些蓝图使用ReactJS开发现代网络应用程序。
- en: This chapter will introduce you to ReactJS and cover how to work with a component-based
    architecture. You will learn all the important concepts in ReactJS, such as creating
    and mounting components, working with props and states, understanding the life
    cycle methods, and setting up a development workflow for efficient development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍ReactJS，并涵盖如何使用基于组件的架构进行工作。您将学习ReactJS中的所有重要概念，例如创建和挂载组件、处理props和states、理解生命周期方法，以及设置高效开发的工作流程。
- en: 'In this chapter we will:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Introduce ReactJS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍ReactJS
- en: Explore the props and states
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索props和states
- en: Learn all about the important life cycle methods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解所有重要的生命周期方法
- en: Walk through synthetic events and the virtual DOM
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解合成事件和虚拟DOM
- en: Learn the modern JavaScript developer's workflow
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习现代JavaScript开发者的工作流程
- en: Composition
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合
- en: Create a basic scaffolding for all our apps
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们所有的应用创建基本的脚手架
- en: Even if you have previous experience with ReactJS, it's worth reading through
    this chapter, especially the scaffolding part, as we'll be using this scaffold
    for the majority of the blueprints in this book.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你之前有ReactJS的使用经验，也值得阅读这一章，特别是脚手架部分，因为我们将使用这个脚手架来构建本书中大部分的蓝图。
- en: Let's begin!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Introducing ReactJS
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍ReactJS
- en: To efficiently develop with ReactJS, it is vital to understand what it is and
    is not. ReactJS is not a framework. ReactJS describes itself as the **V** in the
    **MVC** (**Model-View-Controller**) design pattern. It's a view library that you
    can combine with frameworks such as **AngularJS**, **Ember**, and **Meteor** or
    even in conjunction with other popular JavaScript libraries, such as **Knockout**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要高效地使用ReactJS进行开发，了解它是什么以及它不是什么是至关重要的。ReactJS不是一个框架。ReactJS将自己描述为**MVC**（**模型-视图-控制器**）设计模式中的**V**。它是一个视图库，您可以将其与**AngularJS**、**Ember**和**Meteor**等框架结合使用，甚至可以与其他流行的JavaScript库，如**Knockout**结合使用。
- en: Many people use **React** on its own and combine it with a data flow pattern
    called **Flux**. The idea behind Flux is to establish unidirectional data flow,
    meaning that data should originate at a single point in your app and flow downwards.
    We'll look more closely into this pattern in [Chapter 2](ch02.html "Chapter 2. Creating
    a Web Shop"), *Creating a Web Shop*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人单独使用**React**，并将其与称为**Flux**的数据流模式结合使用。Flux背后的想法是建立单向数据流，这意味着数据应该从您的应用程序中的单个点起源并向下流动。我们将在[第二章](ch02.html
    "第二章. 创建网络商店")*创建网络商店*中更详细地探讨这个模式。
- en: Modern JavaScript development
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现代JavaScript开发
- en: In 2015, JavaScript got its first major upgrade in many years. The syntax is
    JavaScript 2015\. You may know it as EcmaScript 6\. The EcmaScript committee decided
    on a name change in mid-2015, and from now on, JavaScript is going to be updated
    yearly. Modern browsers are slowly implementing support for the new features.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年，JavaScript在许多年后迎来了第一次重大升级。语法是JavaScript 2015。你可能知道它叫作EcmaScript 6。EcmaScript委员会在2015年中决定更改名称，从现在开始，JavaScript将每年更新一次。现代浏览器正在逐步实现对新特性的支持。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A note on the code you'll be seeing in this book. We will be using JavaScript
    2015 throughout the book. Evergreen browsers such as Firefox, Chrome, and Microsoft
    Edge will implement the new functionality on their own timeline, which means that
    some browsers may support new features before others, while some features may
    not be implemented at all.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本书中您将看到的代码的说明。本书将使用JavaScript 2015。常青浏览器，如Firefox、Chrome和Microsoft Edge，将根据自己的时间表实现新功能，这意味着某些浏览器可能在新功能被其他浏览器支持之前就支持了这些功能，而某些功能可能根本不会被实现。
- en: You will most likely find yourself in a situation where you'd like to take advantage
    of new language features without wanting to wait for it to be implemented. Backwards
    compatibility is also an issue because you don't want to leave your users behind.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你很可能会遇到想要利用新语言特性而又不想等待它被实现的情况。向后兼容性也是一个问题，因为你不希望让你的用户落后。
- en: The solution to both of these concerns is to use a transpiler to generate a
    baseline EcmaScript-5-compatible code, such as **Traceur** or **Babel**. Since
    Babel was partly built with ReactJS in mind, I suggest that you go with this one,
    and throughout the book, we'll be depending on Babel for our transpiling needs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这两个问题的方法是使用转译器生成基线EcmaScript-5兼容代码，例如**Traceur**或**Babel**。由于Babel部分是为了ReactJS而构建的，我建议你选择这个，本书中，我们将依赖Babel来满足我们的转译需求。
- en: We'll be exploring the modern developer's workflow in this book by developing
    and iterating a scaffolding or a basic setup that we can use when starting new
    projects. When setting up and using this scaffolding, we'll rely heavily on the
    terminal, `Node.js` and `npm`. Don't worry if this is unfamiliar ground for you.
    We'll go slow.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将通过开发迭代脚手架或基本设置来探索现代开发者的工作流程。在设置和使用这个脚手架时，我们将大量依赖终端、`Node.js`和`npm`。如果你对此不熟悉，不要担心。我们会慢慢来。
- en: Component specification
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件规范
- en: ReactJS components have a built-in set of methods and properties that you'll
    come to rely on. Some of them are for debugging, such as `displayName` and `propTypes`;
    some for setting initial data, such as `getInitialState` and `getDefaultProps`;
    and finally, there are a number of methods dealing with the component life cycle,
    such as `componentDidMount`, `componentShouldUpdate`, and more.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS组件有一套内置的方法和属性，你将依赖它们。其中一些用于调试，如`displayName`和`propTypes`；一些用于设置初始数据，如`getInitialState`和`getDefaultProps`；最后，还有一些处理组件生命周期的方法，如`componentDidMount`、`componentShouldUpdate`等。
- en: Props and states
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Props和states
- en: Data within a component can come from the outside (*props*) or be instantiated
    from the inside (*states*).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 组件内的数据可以来自外部（*props*）或从内部实例化（*states*）。
- en: For testability and immutability concerns, it's desirable to rely on data that
    is passed to components as much as possible rather than working with an internal
    state. However, there are lots of reasons why you'd want to use an internal state,
    so let's take a detailed look at props and states and when you want to use which.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于测试性和不可变性的考虑，我们尽可能希望依赖于传递给组件的数据，而不是处理内部状态。然而，有许多原因会让你想要使用内部状态，所以让我们详细了解一下props和states，以及何时使用哪一个。
- en: Props
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Props
- en: 'Let''s look at a simple component:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的组件：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When you execute this component, you will see the words **My first component**
    in your browser window.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行此组件时，你将在浏览器窗口中看到**我的第一个组件**这几个字。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the app renders to `div` with the `id` app.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，应用程序渲染到具有`id` app的`div`元素。
- en: 'The corresponding HTML file needs to look something like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的HTML文件需要看起来像这样：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This component defines a constant called `app`, which creates a React component
    with the built-in `createClass` method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件定义了一个名为`app`的常量，它使用内置的`createClass`方法创建了一个React组件。
- en: The `rende`r method is the only required method in a ReactJS component. You
    can eschew all other methods, but this one. In `render`, you can either write
    a combination of HTML and JavaScript called **JSX** or compose your HTML code
    using ReactJS elements.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`render`方法是ReactJS组件中唯一必需的方法。你可以避免使用所有其他方法，但这个方法不能省略。在`render`方法中，你可以编写HTML和JavaScript的组合，称为**JSX**，或者使用ReactJS元素组合HTML代码。'
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: JavaScript doesn't understand JSX, so when you write JSX code, you need to convert
    it to JavaScript before executing it in the JavaScript environment. The easiest
    way to convert JSX is using the Babel transpiler because it will do this automatically.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript无法理解JSX，所以当你编写JSX代码时，你需要将其转换为JavaScript，然后在JavaScript环境中执行。将JSX转换为JavaScript最简单的方法是使用Babel转译器，因为它会自动完成这项工作。
- en: 'Whichever way you decide to do it, the following JSX code will be transformed:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你决定如何做，以下JSX代码将被转换：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It will be transformed to this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 它将被转换成这样：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `createElement()` method accepts three parameters: the `html` tag, a `null`
    field, and the HTML code. The second field is actually an object with properties
    (or `null`). We''ll get back to this a little bit later.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`createElement()`方法接受三个参数：`html`标签、一个`null`字段和HTML代码。第二个字段实际上是一个具有属性（或`null`）的对象。我们稍后会回到这一点。'
- en: 'Let''s introduce the concept of properties and make this component a bit more
    interesting:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们引入属性的概念，使这个组件更有趣：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'All component properties are available for use by accessing `this.props`. Here,
    we set an initial message, **Hello World!**, and now, this is what you see when
    you execute the component:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![Props](img/B04943_01_01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: Props cannot be modified and should be treated as immutable.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that props are sent together with the call to the component.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: You can send as many properties as you want, and they are always available under
    `this.props`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have multiple properties that you want to send, just add them sequentially
    to the component call:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can set a component''s initial props by calling `getDefaultProps`. This
    can be helpful when you anticipate that a prop will be used, but it''s not available
    until a later point in the component''s life cycle:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you call the component by adding a greeting, the component will simply show
    an empty page. If you don't have an initial prop, React will throw an error and
    complain that you're referencing a property that doesn't exist.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: States
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'States are similar to props, but are meant for variables that are only available
    within the component. You can set a state in the same way as props:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Also, you can call the variable with `this.state`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Similar to props, if you try to use a nonexisting state variable, ReactJS will
    throw an error.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'A state is primarily used when you make changes that only make sense within
    the component. Let''s look at an example to understand this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we set a `random_number` variable to `0`. We access the built-in `componentDidMount`
    method and start an interval that sets a new random number for this variable every
    second. In the render, we simply output the variable. Every time the state changes,
    ReactJS responds by re-rendering the output. Whenever you run `setState`, ReactJS
    triggers a re-render of the component. It's worth taking care to limit the number
    of times you apply `setState`, as you may run into performance issues if you're
    liberal with the use of them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: render
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the only required method in a component. It should return a single
    child element, such as a JSX structure, but if you don''t want to render anything,
    it can also return `null` or `false` to indicate that you don''t want anything
    rendered:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: statics
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This object can be used to define static methods that can be called on the
    component:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that static methods don't have access to the props or state of your components.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: propTypes
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This object allows you to validate props being passed to your components. This
    is an optional tool to help you when developing your apps and will show up in
    your console log if the props you pass to a component do not match your specifications:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The final example creates a custom validator, which you can use to validate
    even more complex data values.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: displayName
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This value is set automatically if you don''t set it explicitly, and it is
    used for debugging purposes:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Life cycle methods
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Life cycle methods are a set of functions that you can override in your component.
    Initially, all but `shouldComponentUpdate` (which defaults to `true`) is empty.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期方法是你在组件中可以重写的一组函数。最初，除了`shouldComponentUpdate`（默认为`true`）之外，其他都是空的。
- en: componentDidMount
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`componentDidMount`'
- en: This is one of the most common methods you'll employ in your apps. Here's where
    you place any functions you want to run directly after the component has been
    rendered for the first time.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你在应用中会使用到最常见的方法之一。这是你放置任何希望在组件第一次渲染后立即运行的函数的地方。
- en: You have access to the current contents of states and props in this method,
    but take care to never run `setState` in here, as that will trigger an endless
    update loop.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以访问此方法中的当前状态和props的内容，但请注意不要在这里运行`setState`，因为这将触发无限更新循环。
- en: 'It''s worth noting that if you''re making a server-side app, this component
    will not be called. In this case, you''ll have to rely on `componentWillMount`
    instead:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，如果你正在开发一个服务器端应用程序，这个组件将不会被调用。在这种情况下，你将不得不依赖`componentWillMount`：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: componentWillMount
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`componentWillMount`'
- en: This method will be executed before the component is rendered for the first
    time. You have access to the current component's state and props here, and unlike
    `componentDidMount`, it's safe to run `setState` here (ReactJS will understand
    that state changes in this method should be set immediately and not trigger a
    re-render).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将在组件第一次渲染之前执行。你在这里可以访问当前组件的状态和props，并且与`componentDidMount`不同，在这里运行`setState`是安全的（ReactJS会理解在这个方法中状态的变化应该立即设置，而不是触发重新渲染）。
- en: 'This method is executed on both server-side and client-side apps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在服务器端和客户端应用程序中都会执行：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: shouldComponentUpdate
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`shouldComponentUpdate`'
- en: This method is invoked whenever the component receives new props or a change
    in state occurs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件接收到新的props或状态发生变化时，此方法会被调用。
- en: By default, `shouldComponentUpdate` returns a `true` value. If you override
    it and return `false`, the component will never be updated despite receiving updated
    props or a new state. This can be useful if you create a component that should
    only be updated if certain conditions are met or if it should never be updated
    at all. You can benefit from speed increases if you set this to `false` when you
    have a component that should never be updated. However, you should take great
    care when using this method because careless use can lead to bugs that can be
    very hard to track down.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`shouldComponentUpdate`返回一个`true`值。如果你重写它并返回`false`，尽管接收到更新的props或新的状态，组件也永远不会更新。如果你创建了一个应该只在满足某些条件或根本不应该更新的组件，这可能会很有用。如果你将此设置为`false`，你可以从速度提升中受益。然而，在使用此方法时应该非常小心，因为粗心使用可能导致难以追踪的bug。
- en: componentWillReceiveProps
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`componentWillReceiveProps`'
- en: This method lets you compare the incoming props and can be used as an opportunity
    to react to a prop transition before the render method is called. Invoke this
    method with `componentWillReceiveProps(object nextProps)` in order to access the
    incoming props with `nextProps`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法让你比较传入的props，并且可以在调用渲染方法之前作为响应props转换的机会。使用`componentWillReceiveProps(object
    nextProps)`来调用此方法，以便访问传入的props。
- en: It's worth noting that if you call `setState` here, an additional re-render
    will not be triggered. It's not called for the initial render.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，如果你在这里调用`setState`，不会触发额外的重新渲染。它不会在初始渲染时被调用。
- en: There's no analogous method to react to a pure state change, but you can use
    `componentWillUpdate` if you need a way to react to state changes before they
    are rendered.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 没有类似的方法来响应纯状态变化，但如果你需要在渲染之前响应状态变化，可以使用`componentWillUpdate`。
- en: 'This method is not executed on the initial render:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在初始渲染时不执行：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: componentWillUpdate
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`componentWillUpdate`'
- en: This method is executed before the rendering, when the component receives new
    props or states but not on the initial render.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在渲染之前执行，当组件接收到新的props或states，但不在初始渲染时执行。
- en: Invoke this method with `componentWillUpdate(object nextProps, object nextState)`
    in order to access the incoming props and states with `nextProps` and `nextState`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`componentWillUpdate(object nextProps, object nextState)`来调用此方法，以便使用`nextProps`和`nextState`访问传入的props和states。
- en: 'Since you can evaluate a new state in this method, calling `setState` here
    will trigger an endless loop. This means that you cannot use `setState` in this
    method. If you want to run `setState` based on a prop change, use `componentWillReceiveProps`
    instead:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: componentDidUpdate
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This method is executed whenever the component receives new props or states
    and the render method has been executed:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: componentWillUnmount
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final life cycle method is `componentWillUnmount`. This is invoked just
    before the component is unmounted from the DOM. If you need to clean up memory
    or invalidate timers, this is the place to do it:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Synthetic events and the Virtual DOM
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's explore the differences between the regular DOM and the virtual DOM and
    what you need to consider when writing your code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: The DOM
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Document Object Model** (**DOM**) is a programming API for HTML documents.
    Whenever you ask a browser to render HTML, it parses what you have written and
    turns it into a DOM and then displays it in the browser. It is very forgiving,
    so you can write invalid HTML and still get the result you want without even knowing
    you made a mistake.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, say, you write the following line of code and parse it with a
    web browser:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After this, the DOM will show the following structure:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![The DOM](img/B04943_01_02.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: The closing `</p>` tag is automatically inserted for you, and a DOM element
    for the `<p>` tag has been created with all its associated properties.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: ReactJS is not as forgiving. If you write the same HTML in your `render` method,
    it will fail to render and throw an `«Unterminated JSX contents»` error. This
    is because JSX requires a strict match between opening and closing tags. This
    is actually a good thing because it helps you with writing syntactically correct
    HTML.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The virtual DOM
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The virtual DOM is basically a simpler implementation of the real DOM.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: ReactJS doesn't work directly with the DOM. It uses a concept of virtual DOM,
    whereby it maintains a smaller and more simplified internal set of elements, and
    only pushes changes to the visible DOM when there has been a change of state in
    the set of elements. This enables you to switch out parts of your visible elements
    without the other elements being affected, and in short, this makes the process
    of DOM updates very efficient. The best part of this is that you get it all for
    free. You don't have to worry about it because ReactJS handles everything in the
    background.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: It does, however, mean that you cannot look for changes in the DOM and make
    changes directly, like you would normally do with libraries, such as **jQuery**,
    or native JavaScript functions, such as `getElementById()`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Instead, you need to attach a reference named `refs` to the elements you want
    to target. You can do this by adding `ref="myReference"` to your element. The
    reference is now available through a call to `React.findDOMNode(this.refs.myReference)`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Synthetic event handlers
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever you call an event handler within ReactJS, they are passed an instance
    of **SyntheticEvent** instead of the native event handler. This has the same interface
    as the native event handler's, except it's cross-browser compatible so you can
    use it without worrying whether you need to make exceptions in your code for different
    browser implementations.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你调用ReactJS中的事件处理器时，它们都会传递一个**SyntheticEvent**实例而不是原生事件处理器。它与原生事件处理器的接口相同，但它具有跨浏览器兼容性，因此你可以使用它而不用担心是否需要在代码中为不同的浏览器实现做出例外。
- en: The events are triggered in a bubbling phase. This means that the event is first
    captured down to the deepest target and then propagated to outer elements.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 事件在冒泡阶段被触发。这意味着事件首先被捕获到最深的目标，然后传播到外部元素。
- en: Sometimes, you may find yourself wanting to capture the event immediately. In
    such cases, adding `Capture` behind the event can achieve this. For instance,
    to capture `onClick` immediately, use `onClickCapture` and so on.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能希望立即捕获事件。在这种情况下，在事件后添加`Capture`可以实现这一点。例如，要立即捕获`onClick`，使用`onClickCapture`等等。
- en: You can stop propagation by calling `event.stopPropagation()` or `event.preventDefault()`
    where appropriate.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用`event.stopPropagation()`或`event.preventDefault()`在适当的地方停止事件传播。
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A complete list of the available event handlers is available at [https://facebook.github.io/react/docs/events.html](https://facebook.github.io/react/docs/events.html).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的所有事件处理器的完整列表可在[https://facebook.github.io/react/docs/events.html](https://facebook.github.io/react/docs/events.html)找到。
- en: Putting it all together
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: 'When we put all this together, we can extend the sample app with referenced
    elements and an event handler:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将所有这些整合在一起时，我们可以通过引用元素和事件处理器来扩展示例应用：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let's start at the end. As we did earlier, we initialize our app by rendering
    a single ReactJS component called **app** with a single prop onto the element
    with the `#app` ID.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从结尾开始。就像我们之前做的那样，我们通过渲染一个名为**app**的单个ReactJS组件，并传递一个属性到具有`#app` ID的元素上来初始化我们的应用。
- en: 'Before the app mounts, we set initial values for our two state values: `greeting`
    and `message`. Before the app mounts, we set the state for greeting to be the
    same value as the greeting property passed to the app.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用挂载之前，我们为我们的两个状态值设置初始值：`greeting`和`message`。在应用挂载之前，我们将问候状态的设置为其传递给应用的问候属性相同的值。
- en: We then add the input box and a clear button as well as some text in our `render`
    method and attach an `onChange` handler and an `onClick` handler to these. We
    also add `ref` to the input box.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`render`方法中添加输入框、一个清除按钮以及一些文本，并将`onChange`处理器和`onClick`处理器附加到这些元素上。我们还为输入框添加了`ref`。
- en: After the component has mounted, we locate the message box by its `ref` parameter
    and tell the browser to focus on it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件挂载后，我们通过其`ref`参数找到消息框，并告诉浏览器将其聚焦。
- en: Finally, we can go the event handlers. The `onChange` handler is bound to `handleChange`.
    It will activate on every key press and save a new message state, which is the
    current content of the input box. ReactJS will then re-render the content in the
    `render` method. In the reconciliation process, it will note that the value in
    the input box is different from the last render, and it will make sure that this
    box is rendered with the updated value. At the same time, ReactJS will also populate
    the empty text element after **Your message:** with the state value.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以进入事件处理器。`onChange`处理器绑定到`handleChange`。它将在每次按键时激活，并保存一个新的消息状态，即输入框的当前内容。然后ReactJS将在`render`方法中重新渲染内容。在协调过程中，它将注意到输入框中的值与上一次渲染不同，并确保这个框以更新后的值渲染。同时，ReactJS也会在**您的消息：**后的空文本元素中填充状态值。
- en: The `handleClear` method simply resets the message state and clears the input
    box using `refs`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleClear`方法简单地重置消息状态并使用`refs`清除输入框。'
- en: This example is slightly contrived. It could be shortened quite a bit, and storing
    props as states is generally something you should avoid, unless you have a very
    good reason for doing so. In my experience, working with a local state is the
    single most bug-prone code you will encounter and the hardest code to write tests
    for.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子稍微有些牵强。它可以缩短很多，并且将属性存储为状态通常是你应该避免的事情，除非你有非常充分的理由这样做。根据我的经验，使用本地状态是你会遇到的最容易出错的代码，也是最难编写测试的代码。
- en: Composition
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合
- en: Composition is the act of combining things together to make more complex things
    and then putting these things together to make even more complex things, and so
    on.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 组合是将事物组合在一起以形成更复杂的事物，然后将这些事物组合起来以形成更复杂的事物，如此类推的行为。
- en: Knowing how to put together ReactJS components is vital when creating apps that
    go beyond Hello World. An app composed of many small parts is more manageable
    than a single large monolith app.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建超出Hello World的应用时，知道如何组合ReactJS组件至关重要。由许多小部分组成的程序比单一的大型单体应用更容易管理。
- en: 'Composing apps is very simple with ReactJS. For instance, the Hello World app
    we just created can be imported into a new component with the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ReactJS组合应用非常简单。例如，我们刚刚创建的Hello World应用可以通过以下代码导入到新的组件中：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In your new component, you can use the `HelloWorld` variable like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的新组件中，你可以这样使用`HelloWorld`变量：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Every component you created can be imported and used in this manner, and this
    is one of the many compelling reasons for choosing ReactJS.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建的每个组件都可以以这种方式导入和使用，这也是选择ReactJS的许多吸引人理由之一。
- en: Developing with modern frontend tools
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用现代前端工具进行开发
- en: It's hard to overstate the importance of `Node.js` and `npm` in modern JavaScript
    development. These key pieces of technology are central to the development of
    JavaScript web apps, and we'll be relying on `Node.js` and `npm` for the applications
    that we will be developing in this book.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 很难过分强调`Node.js`和`npm`在现代JavaScript开发中的重要性。这些关键技术是JavaScript网络应用开发的核心，我们将在这本书中开发的程序中依赖`Node.js`和`npm`。
- en: Node.js is available for Windows, Mac, and Linux, and is a breeze to install.
    We'll be using `Node.js` and `npm` for all of the examples in this book. We'll
    also be using EcmaScript 2015 and a transpiler to convert the code to a baseline
    JavaScript code that is compatible with older browsers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`Node.js`适用于Windows、Mac和Linux，安装起来非常简单。我们将在这本书的所有示例中使用`Node.js`和`npm`。我们还将使用EcmaScript
    2015和转译器将代码转换为与旧浏览器兼容的基线JavaScript代码。'
- en: If you haven't been using this workflow before, get ready to be excited because
    not only will it make you more productive, it will also open a world of developer
    goodness.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有使用过这个工作流程，准备好兴奋吧，因为它不仅会使你更有效率，还会为你打开一个开发者美好世界的大门。
- en: Let's begin.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Browserify
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Browserify
- en: The traditional method of developing for the Web had you manually adding scripts
    to your `index.html` file. It usually consisted of a mix of frameworks or libraries
    topped off with your own code, which you then added sequentially so that it was
    loaded and executed in the correct order. There are a few drawbacks to this method
    of development. Version control becomes difficult because you have no good way
    of controlling whether newer versions of your external libraries are compatible
    with the rest of your code. As a consequence, many web apps ship with old JavaScript
    libraries. Organizing your scripts is another problem because you have to add
    and remove old versions manually when upgrading. File size is also problematic
    because many libraries ship with more bells and whistles than you need.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的Web开发方法需要你手动将脚本添加到`index.html`文件中。这通常包括一系列框架或库，再加上你自己的代码，你按顺序添加它们，以确保它们按正确的顺序加载和执行。这种方法有几个缺点。版本控制变得困难，因为你没有很好的方法来控制你的外部库的新版本是否与你的其他代码兼容。因此，许多网络应用都带有旧的JavaScript库。组织你的脚本也是一个问题，因为当你升级时，你必须手动添加和删除旧版本。文件大小也是一个问题，因为许多库包含了你不需要的更多功能。
- en: Wouldn't it be nice if we had tools that could keep your dependencies up to
    date, inform you when there are incompatibility issues, and remove code you don't
    use? The answer to all of this is yes, and fortunately, such utilities exist.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个工具可以保持你的依赖项更新，在你遇到不兼容问题时通知你，并移除你不需要的代码，那岂不是很好？答案是肯定的，幸运的是，这样的工具确实存在。
- en: The only drawback is that you have to change the way you write your code. Instead
    of writing scripts that rely on global environment variables, you write modular
    code that is self-contained, and you always specify your dependencies up front.
    If you think that this doesn't sound like much of a drawback, you're right. In
    fact, it's a huge improvement because this makes it very easy to read and understand
    code and allows easy dependency injection when writing tests.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的缺点是您必须改变编写代码的方式。您不再编写依赖于全局环境变量的脚本，而是编写自包含的模块化代码，并且您始终在开始时指定您的依赖项。如果您认为这并不是一个很大的缺点，您是对的。事实上，这是一个巨大的改进，因为这使代码易于阅读和理解，并在编写测试时允许轻松的依赖注入。
- en: Two of the most popular tools for assembling modular code are **Browserify**
    and **Webpack**.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 组装模块化代码的最流行工具是**Browserify**和**Webpack**。
- en: In the beginning, we'll focus on **Browserify** for the simple reason that it's
    very easy to work with and has excellent plugin support. We'll look at **Webpack**
    in [Chapter 6](ch06.html "Chapter 6. Advanced React"), *Advanced React*. Both
    of these tools will analyze your application, figure out which modules you're
    using, and assemble a JavaScript file that contains everything you need to load
    the code in a browser.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于**Browserify**，简单的理由是它非常容易使用，并且具有出色的插件支持。我们将在[第6章](ch06.html "第6章。高级React")中查看**Webpack**，*高级React*。这两个工具都将分析您的应用程序，找出您正在使用的模块，并组装一个包含您在浏览器中加载代码所需所有内容的JavaScript文件。
- en: In order for this to work, you need a base file, a starting point for your application.
    In our scaffold, we'll call this `app.jsx`. This file will contain references
    to your modules and the components that it uses. When you create new components
    and connect them to `app.jsx` or the children of `app.jsx`, **Browserify** will
    add them to the bundle.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个功能正常工作，你需要一个基础文件，这是你应用程序的起点。在我们的框架中，我们将称之为`app.jsx`。这个文件将包含对您的模块和它所使用的组件的引用。当您创建新的组件并将它们连接到`app.jsx`或`app.jsx`的子组件时，**Browserify**会将它们添加到包中。
- en: A number of tools exist to enhance the bundle generation with Browserify. For
    EcmaScript 2015 and newer JavaScript code, we'll use **Babelify**. It's a handy
    tool that in addition to converting JavaScript to EcmaScript 5 will also to convert
    React-specific code such as JSX. In other words, you don't have to use a separate
    JSX transformer in order to use JSX.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多工具可以增强Browserify的包生成。对于EcmaScript 2015及更高版本的JavaScript代码，我们将使用**Babelify**。这是一个方便的工具，除了将JavaScript转换为EcmaScript
    5之外，它还会将React特定的代码（如JSX）转换为EcmaScript 5。换句话说，您不需要使用单独的JSX转换器来使用JSX。
- en: We'll also be using **Browser-sync**, which is a tool that auto reloads your
    code while you edit. This speeds up the development process immensely, and after
    using it for a while, you'll never want to go back to refreshing your app manually.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用**Browser-sync**，这是一个在您编辑时自动重新加载您代码的工具。这极大地加快了开发过程，并且在使用了一段时间之后，您将永远不会想回到手动刷新应用程序。
- en: Scaffolding our React app
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搭建我们的React应用程序
- en: 'These are the steps we''ll be taking to set up our development workflow:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采取以下步骤来设置我们的开发工作流程：
- en: Create an `npm` project.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`npm`项目。
- en: Install dependencies.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装依赖项。
- en: Create a server file.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个服务器文件。
- en: Create a development directory.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个开发目录。
- en: Create our base `app.jsx` file.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们的基础`app.jsx`文件。
- en: Run the server.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行服务器。
- en: 'First of all, make sure that you have `npm` installed. If not, head over to
    [https://nodejs.org/download/](https://nodejs.org/download/) and download the
    installer. The detailed explanation of the preceding steps is as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请确保您已安装`npm`。如果没有，请访问[https://nodejs.org/download/](https://nodejs.org/download/)并下载安装程序。以下步骤的详细说明如下：
- en: Create a directory where you want the app to be sorted and open a terminal window
    and `cd` in this folder.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个您希望应用程序排序的目录，并打开一个终端窗口，然后使用`cd`进入该文件夹。
- en: Initialize your app by typing `npm init` followed by the *Enter* key. Give the
    project a name and answer the few questions that follow or just leave them empty.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过输入`npm init`然后按*Enter*键来初始化您的应用程序。给项目起一个名字，然后回答后续的几个问题，或者直接留空。
- en: 'We''re going to grab a few packages from `npm` to get started. Issuing the
    following command will get the packages and add the dependencies to your newly
    created `package.json` file:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`npm`获取一些包以开始。运行以下命令将获取这些包并将依赖项添加到您新创建的`package.json`文件中：
- en: '[PRE24]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Babel requires a configuration file called `.babelrc`. Add it to the following
    code:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Babel需要一个名为`.babelrc`的配置文件。将其添加到以下代码中：
- en: '[PRE25]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a new text file with your favorite text editor, add the following code,
    and save it as `server.js`:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This segment sets up our app using **express** as our web server. It also initalizes
    `browserify`, `babelify`, and `browser-sync`. Finally, we set up our app to run
    on port `8080`. The line `process.env.PORT || 8080` simply means that you can
    override the port by prefixing the server script with `PORT 8085` to run on port
    `8085` or any other port you''d like to use:'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This sets up Browserify to transform all code with that of the file extension
    `.jsx` with Babelify. The stage `0` configuration means that we want to use experimental
    code that has yet to be approved by the EcmaScript committee:'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We want to reference our JavaScript bundle with `<script src="img/bundle.js"></script>`
    in our `index.html` file. When the web server notices a call for this file, we
    tell the server to send the browserified `app.jsx` file in our `source` folder
    instead:'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With this configuration, we tell the web server to serve any of the listed
    files from `public.folder`:'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This line instructs the web server to serve `index.html` if the user accesses
    the root path:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Finally, this runs the web server with `browser-sync`, proxying your app at
    the port you choose. This means that if you specify port `8080` as your port,
    your front-facing port will be a proxy port (usually `3000`), which will access
    `8080` on your behalf.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We tell `browser-sync` to monitor all JSX files in our `source/` folder and
    our CSS files in our `public/` folder. Whenever these change, `browser-sync` will
    update and refresh the page. We also tell it to ignore all the files in the `node_modules/`
    folder. This is generally wise to do because the folder will often contain thousands
    of files, and you don't want to waste time waiting for these files to be scanned.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, create two a directories called `public` and `source`. Add the following
    three files: `index.html` and `app.css` to your public folder and `app.jsx` to
    your `source` folder.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write this in the `index.html` file:'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Write this in the `app.css` file:'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Write this in the `app.jsx` file:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Your file structure should now look like this:'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Scaffolding our React app](img/B04943_01_03.jpg)'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Running the app
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go the root of the app, type `node server`, and then press *Enter*. This will
    start a node server and in a few seconds, `browser-sync` will open a web browser
    with the location `http://localhost:3000`. If you have any other web servers or
    processes running on port `3000`, `browser-sync` will choose a different port.
    Take a look at the console output to make sure which port it has chosen.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: You will see the contents of your render method from `app.jsx` on the screen.
    In the background, Browserify has employed Babelify to convert your JSX and ES2015
    code as well as your imported dependencies to a single `bundle.js` file that is
    served on `http://localhost:3000`. The app and CSS code will be refreshed every
    time you make a change in the code while this server is running, so I urge you
    to experiment with the code, implement a few life cycle methods, try working with
    states and props, and generally get a feel of working with ReactJS.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在屏幕上看到`app.jsx`中渲染方法的全部内容。在后台，Browserify已经使用Babelify将你的JSX和ES2015代码以及导入的依赖项转换为单个`bundle.js`文件，该文件在`http://localhost:3000`上提供。当这个服务器运行时，每次你在这个服务器运行时对代码进行更改，应用程序和CSS代码都会被刷新，所以我强烈建议你尝试与代码进行实验，实现一些生命周期方法，尝试使用状态和属性进行工作，并总体上感受一下使用ReactJS的工作方式。
- en: If this is your first time working with this kind of setup, I'd imagine you
    feel quite a rush surging through you right now. This setup is very empowering
    and fun to work with, and best of all, it's almost effortless to scaffold.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你第一次使用这种配置，我想你现在一定感到一股强烈的兴奋感涌上心头。这种配置非常强大，使用起来也很有趣，最好的是，搭建起来几乎不费吹灰之力。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at all the important concepts you will come to work
    with when you develop applications with ReactJS. We looked at the component specification,
    how to compose components, and life cycle methods before we went to look at how
    to set up and structure a ReactJS app. Finally, we went through the scaffolding
    that we'll be using for the blueprints in this book.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了当你使用ReactJS开发应用程序时将遇到的所有重要概念。在我们去了解如何设置和构建一个ReactJS应用程序之前，我们研究了组件规范、如何组合组件以及生命周期方法。最后，我们回顾了本书蓝图中所使用的搭建结构。
- en: In the next chapter, we'll go through our first blueprint and create a web shop.
    We'll explore the concept of unidirectional data flow by taking advantage of the
    Flux pattern.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习我们的第一个蓝图并创建一个网店。我们将通过利用Flux模式来探索单向数据流的概念。
