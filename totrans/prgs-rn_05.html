<html><head></head><body>
		<div id="_idContainer029">
			<h1 id="_idParaDest-74" class="chapter-number"><a id="_idTextAnchor110"/>5</h1>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor111"/>Managing States and Connecting Backends</h1>
			<p>In the previous chapter, you learned how to build an app that works fine and looks great. In this chapter, we will focus on data. First, you will learn how to handle more complex data in your app. Then, you’ll learn about different options regarding how to make your app communicate with the rest of the world by connecting it to remote backends. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li><a id="_idTextAnchor112"/>Managing global application states</li>
				<li>Working with global state management solutions</li>
				<li>Connecting to remote backends</li>
			</ul>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor113"/>Technical requirements</h1>
			<p>To be able to run the code in this chapter, you must set up the following: </p>
			<ul>
				<li>A working React Native environment (<a href="http://bit.ly/prn-setup-rn">bit.ly/prn-setup-rn</a> – React Native CLI Quickstart). </li>
				<li>While most of this chapter should also work on Windows, I recommend working on a Mac.</li>
				<li>To check out the simple examples, you can use <a href="https://codesandbox.io/">https://codesandbox.io/</a> and import <strong class="source-inline">react-native-web</strong> as a dependency. This provides all React Native components and transforms them into HTML tags.</li>
			</ul>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor114"/>Managing global application states</h1>
			<p>Since React Native is based <a id="_idIndexMarker310"/>on React, managing the application state does not differ much from React applications. There are dozens of well-maintained and working state management libraries available, all of which you can use in React Native. However, having a good plan and knowing how to manage the application state is much more important in an app than in a web application.</p>
			<p>While it might be acceptable to wait a couple of seconds for data to appear or for a new page to load, this is not the case in a mobile app. Users are used to seeing information or changes immediately. So, you have to ensure that this also is the case in your app. </p>
			<p>In this section, we’ll have a look at the most popular state management solutions, but first, you’ll learn about the different state management patterns and which one you should use for your project.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor115"/>Passing properties</h2>
			<p>While it may<a id="_idIndexMarker311"/> work fine to only work with local component states in small applications and example projects, this approach is very limited. There are a lot of use cases where you have to share data between different components. The bigger your application grows, the more components you will have, and the more layers you will have to pass your data through.</p>
			<p>The following diagram shows the main problem:</p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/B16694_05_01.jpg" alt="Figure 5.1 – State management without a global state management solution&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – State management without a global state management solution</p>
			<p>The preceding diagram shows a very simple example that’s very close to our example app, but you can already see the main problem: the app contains two tabs, one to show content and one to provide an individual user area. This second tab contains a login functionality, which is <a id="_idIndexMarker312"/>extracted in a login component.</p>
			<p>The <strong class="bold">Content</strong> tab contains a dashboard component, which is mainly for showing content. But we also want to be able to adapt this content to the user. So, we need the information about the user in the dashboard component.</p>
			<p>Without a global application state management library, we will have to do the following if a user logs in:</p>
			<ol>
				<li value="1">Pass the information from the <strong class="bold">Login</strong> component to the <strong class="bold">User</strong> tab.</li>
				<li>Pass the information from the <strong class="bold">User</strong> tab to <strong class="source-inline">App.js</strong>.</li>
				<li>Set the user information in the state of <strong class="source-inline">App.js</strong>.</li>
				<li>Pass the user information as a prop to the <strong class="bold">Content</strong> tab.</li>
				<li>Pass the user information from the <strong class="bold">Content</strong> tab to the <strong class="bold">Dashboard</strong> component.</li>
			</ol>
			<p>Even in this simple example, we had to include five components to provide the user information to the dashboard component. When we are talking about complex real-world applications, there could be 10 or more layers that you would have to pass your data through. This would be a nightmare to maintain and understand.</p>
			<p>There is another problem with this approach: when we pass the user information as a prop to the <strong class="bold">Content</strong> tab, this will re-render the whole <strong class="bold">Content</strong> tab if the user information in the state of <strong class="source-inline">App.js</strong> changes. This means that we re-render the <strong class="bold">Content</strong> tab and potentially a lot of child components that haven’t changed because of the changed prop.</p>
			<p>This is especially<a id="_idIndexMarker313"/> important because the global state of large apps can become quite complex and huge. If you compare this to a backend application, you can think of the global application state as the database of the system. </p>
			<p>So, global state management libraries should solve two problems. On the one hand, they should give us an option to share information between components and keep our application’s state management maintainable. On the other hand, they should also help reduce unnecessary re-renders and therefore optimize our app’s performance. </p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor116"/>Using global state providers/containers</h2>
			<p>The following<a id="_idIndexMarker314"/> diagram shows how the data flow is expected to work with a global state management solution:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/B16694_05_02.jpg" alt="Figure 5.2 – State management with a global state management solution&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – State management with a global state management solution</p>
			<p>As you can see, the global <a id="_idIndexMarker315"/>app state management solution provides an option to set data to a global place and connect components to consume this data. While this ensures that the connected components get re-rendered automatically when this data changes, it also has to guarantee that only these components are re-rendered and not the whole component tree. </p>
			<p>While this is a good pattern, it also comes with some risks. When every component can connect to your global state, you have to be very careful in which ways this state can be edited.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Never allow any component to write directly to your state. No matter what library you use, your global state provider should always have control over how the state can be altered. </p>
			<p>As mentioned in the preceding information box, your global state provider should always be in control of the state. This means that you should never allow any component to set the <a id="_idIndexMarker316"/>state directly. Instead, your app state provider should provide some functions that alter the state. This ensures that you always know in which ways your state can change. A state that can only be altered in these ways is also called a predictable state.</p>
			<h3>Using the predictable state pattern</h3>
			<p>Having a predictable<a id="_idIndexMarker317"/> state is especially important when working on large-scale projects with multiple developers. Imagine a project <a id="_idIndexMarker318"/>where anyone could simply set the state directly from any component. When you run into an error because your state contains an invalid value, which cannot be handled by your application, it is nearly impossible to find out where this value is coming from. Also, you cannot provide any central validation when you allow your state to be edited directly from outside the global state provider. </p>
			<p>When you use the predictable state pattern, you have three advantages. First, you can provide validation and prevent invalid values from getting written to your state. Second, if you run into an error because of invalid state values, you have a central point where you can start debugging. Third, it’s easier to write tests for it. </p>
			<p>The pattern of creating a predictable state is shown in the following diagram:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/B16694_05_03.jpg" alt="Figure 5.3 – Simple predictable state management&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Simple predictable state management</p>
			<p>As you can see, a component triggers any event. In this example, a user clicks a button. This event triggers an action. This can be a custom Hook or a function that is provided by some state management library. This Hook or function can do multiple things, from validating the event to fetching data from a local storage solution or an external backend. In the end, the state will be set. </p>
			<p>To give you a better idea, let’s have a look at a concrete example. The component is a reload button. Upon clicking it, the action fetches the most recent data from the backend. It handles the request and if the request is successful and provides valid data, the action sets this data in the state. Otherwise, it sets an error message and provides code to the state. </p>
			<p>As you can see, this <a id="_idIndexMarker319"/>pattern can also provide a good layer of abstraction between business logic and UI. If you would like to<a id="_idIndexMarker320"/> have an even better abstraction, you could use the next pattern we’ll talk about.</p>
			<h3>Using the state/action/reducer pattern</h3>
			<p>This simple predictable state <a id="_idIndexMarker321"/>management pattern <a id="_idIndexMarker322"/>can be extended. The following diagram shows an extended version, which adds reducers and selectors: </p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/B16694_05_04.jpg" alt="Figure 5.4 – The state/action/reducer pattern&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – The state/action/reducer pattern</p>
			<p>The preceding diagram shows the so-called <strong class="bold">state/action/reducer</strong> pattern. In this pattern, the action is not a function or Hook but a JavaScript object that gets dispatched. In most cases, this action is handled by a reducer. The reducer takes the action, which can have some data as a payload, and processes it. It can validate data, merge the data with the current state, and set the state.</p>
			<p>Normally, in this pattern, the reducer does not reach out to any other data sources. It only knows the action and the state. If you want to fetch data in this pattern, you can use middleware. This middleware intercepts the dispatched actions, processes its tasks, and dispatches other actions, which are then handled by reducers. </p>
			<p>Again, let’s have a look at a concrete example. A user clicks on the <strong class="bold">Reload</strong> button. This click dispatches a <strong class="source-inline">FETCH_DATA</strong> action. This <strong class="source-inline">FETCH_DATA</strong> action is handled by the middleware. The middleware fetches the data and validates the request. If everything worked fine, it dispatches a <strong class="source-inline">SET_DATA</strong> action with the new data as a payload.</p>
			<p>The reducer handles this <strong class="source-inline">SET_DATA</strong> action, maybe does some data validation, merges the data with the current state, and sets the new state. If the data fetching in the middleware fails, the middleware dispatches a <strong class="source-inline">DATA_FETCH_ERROR</strong> action with an error code and error message as a payload. This action is also handled by a reducer, which sets the error code and message for the state.</p>
			<p>Another difference <a id="_idIndexMarker323"/>between <em class="italic">Figure 5.3</em> and <em class="italic">Figure 5.4</em> is the existence of selectors. This is something that exists in different state management solutions because it makes it possible to subscribe to only a part of the state instead of the whole state. This is very useful because it makes it possible to create complex state objects while not always re-rendering your whole application. </p>
			<p>This is clearer when <a id="_idIndexMarker324"/>we look at an example. Let’s say that you have an application whose global state consists of a user, an array of articles, and an array of favorite article IDs. Your application shows the articles in one tab and every article has a button to add it to a favorite list. On a second tab, you show the user information.</p>
			<p>When you put all this in the same global state, without using selectors, the default behavior of your <strong class="bold">User</strong> tab would be to re-render if you favor an article, even if nothing on the user page has changed. This is because the <strong class="bold">User</strong> tab also consumes the whole state and this state changed. When using a selector on the user, it doesn’t re-render, because the user part of the state that the <strong class="bold">User</strong> tab is connected to didn’t change. </p>
			<p>If you were to use a complex state without selectors, you would have to create different state providers, which are completely independent of each other. </p>
			<p>Now that you’ve learned about the different options, it’s time to have a look at when it is necessary to use a global state or when you can also use a local component state and simply pass the props. </p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor117"/>Comparing local component state and global application state</h1>
			<p>If you want to provide some <a id="_idIndexMarker325"/>data to be shown in your UI, you must store it in your state in most scenarios. But the interesting question is: In which state? Local component state or global application state?</p>
			<p>This is a topic that has no simple answer or rules that fit every situation. However, I want to give you some guidelines so that you can make a good decision for all of your use cases:</p>
			<ul>
				<li><strong class="bold">Keep your global state as lean as possible</strong>: Global variables are something that is very uncommon to use in most programming languages. And this is for a reason. If everything can be set anywhere in your application, it is hard to debug and maintain it. Also, the bigger the global application state grows, the more likely it is that you will run into performance problems. </li>
				<li><strong class="bold">Form data should not be part of the global state</strong>: When you provide input fields such as text fields, toggles, date pickers, or anything else, the state of these components should not be part of the global application state. This information belongs to the view, which provides these fields and should therefore be part of the view’s component state. </li>
				<li><strong class="bold">Try not to pass data down more than three layers</strong>: When passing props to a child component, you should try to avoid passing this data through multiple layers. The best practice would be to never pass the component props to a child component, but only the component’s state. However, this can be quite hard in practice, so I would recommend sticking to never passing data down more than three layers. </li>
				<li><strong class="bold">Try not to pass data up multiple layers</strong>: As you have already learned, it is possible to pass data from a child to a parent component by passing a function from the parent to the child, which sets the state of the parent and then calls this function from the child component. Since this can lead to very confusing component dependencies to each other, you should be even more careful with passing data up than passing it down. I would recommend passing data up only one layer.</li>
				<li><strong class="bold">Use the global application state for data, which is used in multiple areas of your app</strong>: When data has to be available in multiple areas of your app, which are on completely different navigation stacks, you should always use the global app state. </li>
			</ul>
			<p>Deciding which data belongs to which state can be challenging. It is always a case-by-case decision and <a id="_idIndexMarker326"/>sometimes, you will have to revert your decision because of changing requirements or because you realize that it wasn’t the right decision while working with it. That’s fine. However, you can reduce these efforts by thinking about the right state solution for your data at the beginning. </p>
			<p>Now that we’ve covered the theory, it’s time to look at the most popular solutions and how to maintain the global application state. </p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor118"/>Working with global state management solutions</h1>
			<p>Historically, we would have to <a id="_idIndexMarker327"/>start with Redux since it was the first global state management solution to be popular. Back in 2015, when it was introduced, it quickly became the de facto standard for global state management in React applications. It is still used very widely, but especially in the last 3 years, some other third-party solutions have emerged.</p>
			<p>React also introduced a built-in solution for global state management that can be used in class components, as well as function components. It’s called <strong class="bold">React Context</strong>, and since it ships with React, we’ll start by looking at it.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor119"/>Working with React Context</h2>
			<p>The idea of React Context is<a id="_idIndexMarker328"/> very simple: it is like a tunnel into a component that any other component can connect to. A context always consists of a provider and a consumer. The provider can be added to any existing component and expects a value property to be passed. All components that are descendants of the provider component can then implement a consumer and consume this value. </p>
			<h3>Working with plain React Context providers and consumers</h3>
			<p>The following code <a id="_idIndexMarker329"/>shows a plain React Context example:</p>
			<pre class="source-code">
export function App() {
  return (
    &lt;ColorsProvider&gt;
      &lt;ColoredButton /&gt;
    &lt;/ColorsProvider&gt;
  );
}</pre>
			<p>In your <strong class="source-inline">App.js</strong> file, you add a <strong class="source-inline">ColorsProvider</strong>, which wraps a <strong class="source-inline">ColoredButton</strong> component. This means that in <strong class="source-inline">ColoredButton</strong>, we will be able to implement a consumer for the <strong class="source-inline">ColorsProvider</strong> value. But let’s have a look at the implementation of <strong class="source-inline">ColorsProvider</strong> first: </p>
			<pre class="source-code">
import defaultColors from "defaultColors";
export const ColorContext = React.createContext();
export function ColorsProvider(props) {
  const [colors, setColors] = 
      useState(defaultColors.light);
  const toggleColors = () =&gt; {
      setColors((curColors) =&gt;
          curColors === defaultColors.dark ? 
              defaultColors.light : defaultColors.dark
    );
  };
  const value = {
    colors: colors,
    toggleColors: toggleColors
  };
  return &lt;ColorContext.Provider value={value} {...props} /&gt;;
} </pre>
			<p>In this example, <strong class="source-inline">ColorsProvider</strong> is a function component that provides a state with the property colors. This is initialized with a default color scheme, which is imported from <strong class="source-inline">defaultColors</strong>. It also provides a <strong class="source-inline">toggleColors</strong> function, which changes the color schemes.</p>
			<p>The colors state variable<a id="_idIndexMarker330"/> and the <strong class="source-inline">toggleColors</strong> function are then packed into a value object, which is passed to the value property of <strong class="source-inline">ColorContext.Provider</strong>. <strong class="source-inline">ColorContext</strong> is initialized in line 2.</p>
			<p>As you can see, the file has two exports: <strong class="source-inline">ColorContext</strong> itself and the <strong class="source-inline">ColorsProvider</strong> function component. You have already learned how to use the provider, so next, we’ll look at how to consume the context’s value.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">ColorsProvider</strong> function component isn’t necessary for React Context to work. We could have also added the React Context initialization, the colors state, and the <strong class="source-inline">toggleColors</strong> function, as well as <strong class="source-inline">ColorContext.Provider</strong> directly into the <strong class="source-inline">App.js</strong> file. But it is best practice, and I would recommend extracting your contexts into separate files.</p>
			<p>The following code shows <strong class="source-inline">ColoredButton</strong>, which is wrapped by our <strong class="source-inline">ColorsProvider</strong> in our <strong class="source-inline">App.js</strong> file:</p>
			<pre class="source-code">
function ColoredButton(props) {
  return (
    &lt;ColorContext.Consumer&gt;
      {({ colors, toggleColors }) =&gt; {
          return (
              &lt;Pressable
                  onPress={toggleColors}
               style={{
                  backgroundColor: colors ? 
                  colors.background : 
                  defaultColors.background
            }}
          &gt;
            &lt;Text
                style={{
                    color: colors ? colors.foreground : 
                    defaultColors.foreground
              }}
            &gt;
              Toggle Colors
            &lt;/Text&gt;
          &lt;/Pressable&gt;
        );
      }}
    &lt;/ColorContext.Consumer&gt;
  );
}</pre>
			<p>As you can see, we use a <strong class="source-inline">ColorContext.Consumer</strong> component, which provides the values of <strong class="source-inline">ColorsProvider</strong>. These values can then be used. In this case, we use the <strong class="source-inline">colors</strong> object to style the <strong class="source-inline">Pressable</strong> and <strong class="source-inline">Text</strong> components and we pass the <strong class="source-inline">toggleColors</strong> function to the <strong class="source-inline">onPress</strong> property of the <strong class="source-inline">Pressable</strong> component. </p>
			<p>This method of implementing <a id="_idIndexMarker331"/>a consumer works in function components as well as in class components. When working with function components, there is a simpler syntax you can use to fetch the value of the context.</p>
			<h3>Working with Context and React Hooks</h3>
			<p>The following code <a id="_idIndexMarker332"/>example shows a small section of the code example<a id="_idIndexMarker333"/> we looked at previously:</p>
			<pre class="source-code">
function ColoredButton(props) {
const {colors, toggleColors} = React.useContext(ColorContext);
  return (
          &lt;Pressable
              onPress={toggleColors}</pre>
			<p>As you can see, instead of having to implement the context consumer component, you can simply use the <strong class="source-inline">useContext</strong> Hook to fetch the values. This makes the code shorter and much more readable. </p>
			<p>While this example is very simple, it nevertheless follows best practices. As you can see, the <strong class="source-inline">setColors</strong> function, which is the setter for our state, isn’t publicly available. Instead, we provide a <strong class="source-inline">toggleColors</strong> function, which allows us to alter the state in a predefined way. Also, we have the state abstracted very well from the UI. </p>
			<p>Hooks enable you to even go one step further. When the project grows and you want to have an additional layer of abstraction, such as for making external requests, you could create a custom Hook as your middleware. </p>
			<p>This is what we will add next to our example project. We’ll create some functionality so that the user can create a list of favorite movies, which then gets displayed in the <strong class="bold">User</strong> tab. While doing this, we’ll discuss the <a id="_idIndexMarker334"/>benefits and limitations of React Context for global state management.</p>
			<p>The following<a id="_idIndexMarker335"/> figure shows what we’ll create:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B16694_05_05.jpg" alt="Figure 5.5 – Example app – Favorite Movies&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – Example app – Favorite Movies</p>
			<p>This is what the app <a id="_idIndexMarker336"/>should be able to do. On each <a id="_idIndexMarker337"/>movie details page, we’ll add a button to add the movie to <strong class="bold">Favorite Movies</strong>. If a movie is already part of <strong class="bold">Favorite Movies</strong>, the button changes to a <strong class="bold">Remove</strong> button, which removes the movie from the list.</p>
			<p>In the <strong class="bold">Movies</strong> list, we want to add a thumbs-up icon to all movies that are part of the <strong class="bold">Favorite Movies</strong> list. Finally, we<a id="_idIndexMarker338"/> want to display all movies in the <strong class="bold">User</strong> tab. </p>
			<p>First, we have to create<a id="_idIndexMarker339"/> the context and the custom Hook to be able to store the data. The following code shows <strong class="source-inline">UserProvider</strong>:</p>
			<pre class="source-code">
export function UserProvider(props: any) {
  const [name, setName] = useState&lt;string&gt;('John');
  const [favs, setFavs] = useState&lt;{[favId: number]: 
      IMovie}&gt;({});
  const addFav = (fav: IMovie): void =&gt; {
      if (!favs[fav.id]) {
          const _favs = {...favs};
          _favs[fav.id] = fav;
          setFavs(_favs);
      }
  };
  const removeFav = (favId: number): void =&gt; {
      if (favs[favId]) {
          const _favs = {...favs};
          delete _favs[favId];
          setFavs(_favs);
      }
  };
  const value = {
      name, favs, addFav, removeFav,
  };
  return &lt;UserContext.Provider value={value} {...props} /&gt;;
}</pre>
			<p>As you can see, we have two state variables: an object that stores the favorite movies in a map-like structure (<strong class="source-inline">favs</strong>) and the name of the user (<strong class="source-inline">name</strong>). You can ignore <strong class="source-inline">name</strong> for now; we’ll need this later. </p>
			<p>The provider also contains <strong class="source-inline">addFav</strong> and <strong class="source-inline">removeFav</strong> functions, which are the only ways to edit the store from outside the provider. These two functions and the <strong class="source-inline">name</strong> and <strong class="source-inline">favs</strong> state variables are <a id="_idIndexMarker340"/>packed into the <strong class="source-inline">value</strong> variable, which then gets passed to the <strong class="source-inline">value</strong> property of the provider. </p>
			<p>Next, we’ll have a<a id="_idIndexMarker341"/> look at the custom Hook. This Hook serves as the middleware and the data selectors. It is used to fetch data before it’s stored and to transform data to provide it in the way it is needed:</p>
			<pre class="source-code">
export function useUser() {
  const context = React.useContext(UserContext);
  const {name, favs, addFav, removeFav} = context;
  const addFavById = (favId: number): void =&gt; {
      const movie = getMovieById(favId);
      if (!movie) {
          return;
      }
      addFav(movie);
  };
  const getFavsAsArray = (): IMovie[] =&gt; {
      return Object.values(favs);
  };
  const isFav = (favId: number): boolean =&gt; {
    return !!favs[favId];
  };
    return {
        name, favs, getFavsAsArray, removeFav, addFavById, 
        isFav,
    };
}</pre>
			<p>As we did in our previous Hooks example, we’ll use the <strong class="source-inline">useContext</strong> Hook to make the provider’s data accessible in our custom Hook. The custom Hook contains three functions. The <strong class="source-inline">addFavById</strong> function takes a <strong class="source-inline">movieId</strong> and fetches the movie from our <strong class="source-inline">movieService</strong>. This is a typical middleware task. </p>
			<p>The <strong class="source-inline">getFavsAsArray</strong> function provides the favorite movies of a user as an array. The <strong class="source-inline">isFav</strong> function answers the question if a given ID belongs to a movie in the user’s favorite list. These two functions are typical selectors. </p>
			<p>The Hook returns these three functions as well as <strong class="source-inline">name</strong>, <strong class="source-inline">favs</strong>, and <strong class="source-inline">removeFav</strong> from the provider. With <a id="_idIndexMarker342"/>these things, we have all we need to implement our requirements very easily. </p>
			<p>Let’s start with the<a id="_idIndexMarker343"/> movie details page. We’ll have a look at different parts of the added code; if you want to see the whole file, please visit this book’s GitHub repository: </p>
			<pre class="source-code">
const Movie = (props: MovieProps) =&gt; { 
  const {isFav, addFavById, removeFav} = useUser();
  const _isFav = isFav(props.route.params.movie.id);
  ...</pre>
			<p>In this component, we need the <strong class="source-inline">isFav</strong> function to check if a movie is already part of the user’s favorites. Depending on that, we want to be able to add or remove the movie to or from the user’s favorites. Therefore, we import our <strong class="source-inline">useUser</strong> Hook and then use object destructuring to make these functions available. We also store the <strong class="source-inline">isFav</strong> information in a variable for later use.</p>
			<p>Now that we can work with these functions, we have to implement the button itself: </p>
			<pre class="source-code">
&lt;Pressable
  style={styles.pressableContainer}
  onPress={
      _isFav
      ? () =&gt; removeFav(props.route.params.movie.id)
      : () =&gt; addFavById(props.route.params.movie.id)
  }&gt;
  &lt;Text style={styles.pressableText}&gt;
    {_isFav ? '👎 Remove from favs' : '👍 Add to favs'}
  &lt;/Text&gt;
&lt;/Pressable&gt;</pre>
			<p>As you can see, the implementation part of the button is quite easy. We use our <strong class="source-inline">_isFav</strong> variable to check<a id="_idIndexMarker344"/> which text our button should display and to decide which function we should call. The <strong class="source-inline">addFavById</strong> and <strong class="source-inline">removeFav</strong> functions can be called like any other function provided by the component. </p>
			<p>Now that we have<a id="_idIndexMarker345"/> built the functionality to edit the favorites, the next step is to display this information in the movies list. The import of the Hook works as follows in the movie details view:</p>
			<pre class="source-code">
const Genre = (props: GenreProps) =&gt; {
  const [movies, setMovies] = useState&lt;IMovie[]&gt;([]);
  const {isMovieFav} = useUser();
  ...</pre>
			<p>Since we don’t want to write anything to the state, we don’t need to make these functions available. And in contrast to the movie details page, we must check multiple movies for their favorite status, so it makes no sense to create a variable to cache the result of <strong class="source-inline">isMovieFav</strong> here.</p>
			<p>Next, let’s look at the implementation of the movie list’s JSX:</p>
			<pre class="source-code">
  return (
    &lt;ScrollContainer&gt;
      {movies.map(movie =&gt; (
          &lt;Pressable
            {isMovieFav(movie.id) ? (
              &lt;Text style={styles.movieTitleFav}&gt;👍&lt;/Text&gt;
              ) : undefined}
            &lt;Text style={styles.movieTitle}&gt;{movie.title}
                &lt;/Text&gt;
          &lt;/Pressable&gt;
        ))}
    &lt;/ScrollContainer&gt;
  );</pre>
			<p>While iterating over the movies, we’ll check every movie with the <strong class="source-inline">isMovieFav</strong> function. If it returns <strong class="source-inline">true</strong>, we’ll <a id="_idIndexMarker346"/>add a thumbs-up icon. That’s the only change that is needed here.</p>
			<p>The last step is to <a id="_idIndexMarker347"/>show the list of <strong class="bold">Favorite Movies</strong> in the <strong class="bold">User</strong> tab. This is also just a few lines of code: </p>
			<pre class="source-code">
const User = (props: UserProps) =&gt; {
  const {getMovieFavsAsArray} = useUser();
  const _movieFavsArray = getMovieFavsAsArray();
  return (
    &lt;ScrollContainer&gt;
      {_movieFavsArray.map(movie =&gt; {
        return (
          &lt;Pressable&gt;
            &lt;Text style={styles.movieTitle}&gt;{movie.title}
                &lt;/Text&gt;
          &lt;/Pressable&gt;
        );
      })}
    &lt;/ScrollContainer&gt;
  );
}; </pre>
			<p>The preceding code shows the whole component (except imports and styling). We fetch our favorite movies with the Hook’s <strong class="source-inline">getMovieFavsAsArray</strong> function and store them in a variable. Then, we iterate over the array and render the movies. That’s it! Our example is complete. </p>
			<p>As you have seen in this example, the implementation part of the components is very easy and only needs a few lines <a id="_idIndexMarker348"/>of code in most cases. This will stay the same, even in bigger projects, when you <a id="_idIndexMarker349"/>have a good structure in your contexts. I like this approach very much because it doesn’t need any external libraries and has a clear separation between UI components, middleware, and state provider. It also comes with another benefit. </p>
			<p>It can be very useful to persist parts of the store and rehydrate (reload) them when the user reopens the app. This is also very easy when working with React Context. The following code snippet is part of <strong class="source-inline">UserProvider</strong> and shows how to store and reload the user’s favorite list.</p>
			<p>In this case, we are using <strong class="source-inline">AsyncStorage</strong> as a local storage solution:</p>
			<pre class="source-code">
  useEffect(() =&gt; {
    AsyncStorage.getItem('HYDRATE::FAVORITE_MOVIES').then
        (value =&gt; {
            if (value) {
                setFavs(JSON.parse(value));
           }
      });
  }, []);
   useEffect(() =&gt; {
     if (favs !== {}) {
         AsyncStorage.setItem('HYDRATE::FAVORITE_MOVIES', 
             JSON.stringify(favs));
     }
  }, [favs]);</pre>
			<p>Since the provider works like any other component, it can also use the <strong class="source-inline">useEffect</strong> Hook. In this example, we<a id="_idIndexMarker350"/> are using an effect to fetch <strong class="source-inline">favs</strong> from <strong class="source-inline">AsyncStorage</strong> when the provider gets <a id="_idIndexMarker351"/>mounted. We use another effect to store the favorites every time the <strong class="source-inline">favs</strong> variable changes. While there are a lot of benefits, unfortunately, this approach based on React Context comes with a big limitation. </p>
			<h3>Understanding the limitations of React Context</h3>
			<p>At the beginning of this<a id="_idIndexMarker352"/> example, I told you to ignore the <strong class="source-inline">name</strong> variable in the state provider because we would need it later. This later is now. If you have already looked at this book’s GitHub repository, you may have realized that the code for the <strong class="source-inline">Home</strong> view has changed.</p>
			<p>The following code snippet shows the changes:</p>
			<pre class="source-code">
const Home = (props: HomeProps) =&gt; {
  const {name} = useUser();
  ...
  console.log('re-render home');
  return (
    &lt;ScrollContainer&gt;
      &lt;Text style={styles.welcome}&gt;Hello {name}&lt;/Text&gt;
  ...</pre>
			<p>This view now imports the <strong class="source-inline">useUser</strong> Hook and reads the user’s name to provide a warm welcome message to the user. It also contains a <strong class="source-inline">console.log</strong> that logs every re-render of the page. When<a id="_idIndexMarker353"/> you run the code example and add/remove movies to/from the user’s favorites, you’ll realize that the <strong class="source-inline">Home</strong> component re-renders on every change of <strong class="source-inline">favs</strong> in <strong class="source-inline">UserProvider</strong>.</p>
			<p>This happens even if we don’t use <strong class="source-inline">favs</strong> in this component. This is because a state change in <strong class="source-inline">UserProvider</strong> triggers a re-render in every descendant, which also contains every component that imports the custom Hook.</p>
			<p>This limitation does not mean that you can’t use React Context. It is widely used, even in large projects. But you always have to keep this limitation in mind. My recommended solution for this problem is to split your global state into different contexts with different providers.</p>
			<p>In this example, we could have created a <strong class="source-inline">UserContext</strong>, which only contains the name of the user, and a <strong class="source-inline">FavContext</strong>, which only contains the list of favorites. </p>
			<p>You could also use <strong class="source-inline">useMemo</strong>, <strong class="source-inline">React.memo</strong>, or <strong class="source-inline">componentDidUpdate</strong> to optimize the performance of this approach. But if you need to do this, I recommend using another solution that provides these optimizations out of the box. One of them is Zustand, which we’ll have a look at next. </p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor120"/>Working with Zustand</h2>
			<p><strong class="bold">Zustand.js</strong> is a very lean<a id="_idIndexMarker354"/> approach to state management. It is based on Hooks and comes with <a id="_idIndexMarker355"/>performance-optimized selectors built in. It can also be extended in different ways so that you can use it to implement exactly the global state management pattern you like. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you want to use Zustand in class components, you can’t do this directly because class components don’t support Hooks. However, you could use the <strong class="bold">higher-order component</strong> (<strong class="bold">HOC</strong>) pattern to wrap the class <a id="_idIndexMarker356"/>component in a function component. Then, you can use the Hook in the function component and pass the Zustand state to the class component as a prop.</p>
			<p class="callout">You can read more about HOC in the React documentation here: <a href="https://bit.ly/prn-hoc">https://bit.ly/prn-hoc</a>.</p>
			<p>To create a Zustand store, you must use the <strong class="source-inline">create</strong> Hook provided by Zustand. This creates a store, which <a id="_idIndexMarker357"/>holds the state and provides functions to access the state. To get a more concrete idea, let’s have a look at what our example project looks like with the<a id="_idIndexMarker358"/> global state handled by Zustand.</p>
			<p>The code snippets shown here are just excerpts. If you want to check out the running example, please go to this book’s GitHub repository and choose the <strong class="source-inline">chapter-5-zustand</strong> tag:</p>
			<pre class="source-code">
export const useUserStore = create&lt;IUser &amp; UserStoreFunctions&gt;((set, get) =&gt; ({
  name: 'John',
  favs: {},
  addFavById: (favId: number) =&gt; {
    const _favs = {...get().favs};
    if (!_favs[favId]) {
      const movie = getMovieById(favId);
      if (movie) {
        _favs[favId] = movie;
        set({favs: _favs});
      }
    }
  },
  removeFav: (favId: number) =&gt; {
    const _favs = {...get().favs};
    if (_favs[favId]) {
      delete _favs[favId];
      set({favs: _favs});
    }
  },
}));</pre>
			<p>We use the <strong class="source-inline">create</strong> function provided by Zustand to create the store. We pass a function to <strong class="source-inline">create</strong> that can access the <strong class="source-inline">get</strong> and <strong class="source-inline">set</strong> parameters and returns the store. This store itself is an object that can hold data objects (the state) and functions (setters or selectors) as <a id="_idIndexMarker359"/>properties. Inside these functions, we can use <strong class="source-inline">get</strong> to access state objects or <strong class="source-inline">set</strong> to write parts of the store. </p>
			<p>Again, when you work with objects as<a id="_idIndexMarker360"/> part of your state, you have to create a new object and write it to the store to trigger a re-render. If you just alter the existing state object and write it back, the state will not be recognized as changed because the object reference did not change. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">When working with objects in your state, it can be annoying to always have to create copies of these objects before setting them to the state. This problem is solved by an open source library called <strong class="bold">immer.js</strong>. This library<a id="_idIndexMarker361"/> provides a <strong class="source-inline">produce</strong> function, which takes the old state, lets you make changes, and automatically creates a new object out of it. It also integrates into Zustand as middleware.</p>
			<p class="callout">You can find out more about<a id="_idIndexMarker362"/> immer.js here: <a href="https://bit.ly/prn-immer">https://bit.ly/prn-immer</a>.</p>
			<p>In our example, we still have <strong class="source-inline">name</strong> and <strong class="source-inline">favs</strong> as state properties. To modify this state, our Zustand store provides an <strong class="source-inline">addFavById</strong> function and a <strong class="source-inline">removeFav</strong> function. The <strong class="source-inline">addFavById</strong> function not only writes to the store but also fetches the movie for a given ID from our <strong class="source-inline">movieService</strong>. </p>
			<p>Next, we’ll look at<a id="_idIndexMarker363"/> how we connect to the store from within a component. We don’t even have to change much code to switch from React Context to Zustand in <a id="_idIndexMarker364"/>our components.</p>
			<p>Let’s have a look at the movie view: </p>
			<pre class="source-code">
const Movie = (props: MovieProps) =&gt; {
  const [addFavById, favs, removeFav] = useUserStore(state 
      =&gt; [
          state.addFavById,
          state.favs,
          state.removeFav,
         ], shallow);
  const _isFav = favs[props.route.params.movie.id];
  ...</pre>
			<p>Here, we use the <strong class="source-inline">useUserStore</strong> Hook we just created with Zustand’s <strong class="source-inline">create</strong> function to connect to the Zustand state. We connect to multiple parts of the state using array destructuring. Since we have already implemented the usage of the functions in our JSX code in the React Context example, we don’t have to change anything there. It’s the same functions doing the same thing, but coming from another state management solution. </p>
			<p>However, the most important thing occurs when looking at the <strong class="source-inline">Home</strong> view: </p>
			<pre class="source-code">
const Home = (props: HomeProps) =&gt; {
  const name = useUserStore(state =&gt; state.name);
  console.log('rerender home');
  ...</pre>
			<p>Here, we are doing the same <a id="_idIndexMarker365"/>as we did in the React Context example: we are connecting our home view to the global state and fetching the name. When you run this example, you will realize that <strong class="source-inline">console.log</strong> will no longer be triggered when you add or remove favorites.</p>
			<p>This is because Zustand only triggers re-renders if the part of the state the component is connected to changes, not if anything in the state changes. This is very useful because you don’t have to think about performance optimization that much. Zustand provides this out of the box. </p>
			<p>Zustand is becoming<a id="_idIndexMarker366"/> more and more popular because of its simplicity and flexibility. As mentioned previously, you don’t have to choose this simple approach with Zustand. You could even create a Redux-like workflow with it. </p>
			<p>Speaking of Redux, this is the next solution you’ll learn about.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor121"/>Working with Redux</h2>
			<p>Redux is by far the most used <a id="_idIndexMarker367"/>solution when it comes to global state management. The following diagram compares the usage of react-redux and Zustand:</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B16694_05_06.jpg" alt="Figure 5.6 – Daily npm downloads of react-redux and Zustand&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – Daily npm downloads of react-redux and Zustand</p>
			<p>As you can see, the daily downloads of <strong class="source-inline">react-redux</strong> are quite stable at around 5 million. Zustand’s popularity is rapidly growing. It changed from around 100,000 daily downloads in Q3 2021 to around 500,000 daily downloads in Q2 2022. This is a sign that a lot of new projects prefer Zustand over Redux. </p>
			<p>Nevertheless, Redux is a very good solution. It follows a very clear structure and has a huge ecosystem built around it. Redux uses the state/action/reducer pattern and forces the developer to stick to it. It can be enhanced with different middlewares such as <strong class="source-inline">redux-thunk</strong> or <strong class="source-inline">redux-saga</strong> to handle effects. It also provides great developer tools for debugging. </p>
			<p>Since Redux is a very <a id="_idIndexMarker368"/>mature technology, there are a lot of great tutorials and books on the market that handle Redux. Therefore, the basic usage of Redux won’t be covered by this book. If you don’t already know the basics of Redux, I recommend starting <a id="_idIndexMarker369"/>with the official tutorial here: <a href="https://bit.ly/prn-redux">https://bit.ly/prn-redux</a>.</p>
			<p>While Redux is a great state management solution, it comes with two huge downsides. First, it creates some overhead for creating and maintaining all the parts of the process. To provide a simple string value in your global state, you need at least the store, a reducer, and an action. Second, the code of applications with a deep Redux integration can become quite hard to read.</p>
			<p>I would recommend Redux for huge applications that a lot of developers work on. In this case, the clear structure and the separation between the logical layers are worth the overhead. Middleware should be used to handle side effects and <strong class="source-inline">redux-toolkit</strong> can be used to simplify the code. This setup can work very well in this large-scale scenario.</p>
			<p>Now that you’ve learned how to use Redux, Zustand, and React Context to handle the global application state, you have seen that there are multiple different ways to approach global state management. While these solutions are my favorites at the moment, there are a lot more options available. If you want to loo<a id="_idTextAnchor122"/>k<a id="_idTextAnchor123"/> for different options, I also recommend MobX, MobX-state-tree, Recoil, and Rematch.</p>
			<p>Now that you’ve learned how to handle data inside a React Native app, we’ll check out how we can retrieve data from external APIs.  </p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor124"/>Connecting to remote backends</h1>
			<p>React Native allows you to use<a id="_idIndexMarker370"/> different solutions to connect to online resources such as APIs. First, you’ll learn about plain HTTP API connections. Later in this section, we’ll also have a look at more high-level solutions such as GraphQL clients and SDKs such as Firebase or Amplify. But let’s start with some general things. </p>
			<h2 id="_idParaDest-86">Understanding the general principl<a id="_idTextAnchor125"/>e<a id="_idTextAnchor126"/>s of connections in React Native</h2>
			<p>No matter what <a id="_idIndexMarker371"/>connection solution you use in your React Native app, it is always a good<a id="_idIndexMarker372"/> idea to use <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) as the format for your data transfer. Since React Native apps are written in JavaScript and JavaScript plays very well with JSON, this is the only logical choice. </p>
			<p>Next, regardless of which connection solution you use, always wrap your API calls in a service. Even if you are sure about the connection solution you chose, you may want or have to replace it in a few years.</p>
			<p>This is much simpler when you have all the code wrapped in a service than searching for it everywhere in your whole application. The last thing I want to mention here is that you have to think about how to secure your API. </p>
			<h3>Understanding security risks</h3>
			<p>You always have to keep in mind<a id="_idIndexMarker373"/> that a React Native app runs completely client-side. This means that everything you ship in your app can be considered publicly available. This also includes API keys, credentials, or any other authentication information. While there can never be 100% impenetrable software, you should at least provide some level of security:</p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B16694_05_07.jpg" alt="Figure 5.7 – Security efforts and likelihood of a breach (inspired by https://reactnative.dev/docs/security)&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – Security efforts and likelihood of a breach (inspired by https://reactnative.dev/docs/security)</p>
			<p>As you can see, even some efforts in securing your app reduce the likelihood of a breach significantly. The <a id="_idIndexMarker374"/>minimum you should do is as follows: </p>
			<ul>
				<li>Don’t store your private API keys or credentials in your code.</li>
				<li>Don’t use tools such as <strong class="source-inline">react-native-dotenv</strong> or <strong class="source-inline">react-native-config</strong> to store sensitive data. This data is also shipped to the client in plain text. </li>
				<li>Use user-based keys or credentials wherever possible. </li>
				<li>Remove all console output in production builds to not expose keys.</li>
				<li>Store sensitive information in secure local storage solutions (see the <em class="italic">Storage</em> section of <a href="B16694_04.xhtml#_idTextAnchor079"><em class="italic">Chapter 4</em></a>, <em class="italic"> Styling, Storage, and Navigation in React Native</em>).</li>
			</ul>
			<p>When you need to work with third-party APIs, which only provide you with one key, you should create your own server layer that you can call from within your app. Then, you can store your API key on the server, add it to the request, call the third-party API from your server, and provide the response to your app.</p>
			<p>In that way, you don’t make your API key public. Again, always keep in mind that everything you ship<a id="_idIndexMarker375"/> with your app can be exposed. </p>
			<p>With that warning given, let’s start with our first simple call, where we will use the JavaScript Fetch API.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor127"/>Working with the built-in Fetch API</h2>
			<p>React Native ships with a <a id="_idIndexMarker376"/>built-in Fetch API, which is sufficient for most use cases. It is easy to use, easy to read, and can be used in apps of all sizes. We’ll use our example app again to see how it works. We’ll replace the <strong class="source-inline">genres.json</strong> and <strong class="source-inline">movies.json</strong> static files with real API calls to The Movie DB (<a href="https://www.themoviedb.org">https://www.themoviedb.org</a>). Please note that this API is free for non-commercial use only and you have to stick to the terms of use when using it. </p>
			<p>You can find the full example code on GitHub (the <strong class="source-inline">chapter-5-fetch</strong> tag). To run it, you have to register at <a href="https://www.themoviedb.org/">https://www.themoviedb.org/</a> and obtain an API key. You can read more about this here: <a href="https://bit.ly/prn-tmd-api">https://bit.ly/prn-tmd-api</a>.</p>
			<p>Now, let’s have a look at the code. First, we must create a constants file for all API information:</p>
			<pre class="source-code">
export const APIConstants: {
  API_URL: string;
  API_KEY: string;
     } = {
         API_URL: 'https://api.themoviedb.org/3/',
         API_KEY: '&lt;put your api key here - never do that  
             in production&gt;',
};</pre>
			<p>In our example, we put the base URL and the API key here. This is where you can paste the API key you retrieved from The Movie DB. </p>
			<p class="callout-heading">Security note</p>
			<p class="callout">Never put your API key in your app like this in production. </p>
			<p>Since we have already <a id="_idIndexMarker377"/>extracted our data connection in <strong class="source-inline">movieService</strong>, this is the file where we will make most of the changes. Instead of reading and filtering local files, we’ll connect to the real API. To make the connection easier, we’ll write two helper functions first:</p>
			<pre class="source-code">
const createFullAPIPath: (path: string) =&gt; string = path =&gt; {
  return (
    APIConstants.API_URL + path +
        (path.includes('?') ? '&amp;' : '?') +
        'api_key=' + APIConstants.API_KEY
   );
};
async function makeAPICall&lt;T&gt;(path: string): Promise&lt;T&gt; {
  console.log(createFullAPIPath(path));
  const response = await fetch(createFullAPIPath(path));
  return response.json() as Promise&lt;T&gt;;
}</pre>
			<p>The <strong class="source-inline">createFullAPIPath</strong> function takes the path of the request and adds the base URL and the API key for authentication to the call. The <strong class="source-inline">makeAPICall</strong> function does the fetch action and returns typed data from the response JSON. </p>
			<p>These helper functions are used to create different functions that are exported so that they’re available in the application. Let’s look at one of them – the <strong class="source-inline">getGenres</strong> function:</p>
			<pre class="source-code">
const getGenres = async (): Promise&lt;Array&lt;IGenre&gt;&gt; =&gt; {
  let data: Array&lt;IGenre&gt; = [];
  try {
    const apiResponse = await makeAPICall&lt;{genres: Array
        &lt;IGenre&gt;}&gt;('genre/movie/list',
        );
    data = apiResponse.genres;
  } catch (e) {
        console.log(e);
    }
  return data;
};</pre>
			<p>As you can see, we use the <strong class="source-inline">makeAPICall</strong> helper function to fetch the data. We add the data type we expect the data to be. As the path, we only have to pass the relative path of the API. Then, we process the response and return the data. In production, we wouldn’t log the error to the console but to an external error reporting system. You’ll learn more about this in <a href="B16694_13.xhtml#_idTextAnchor462"><em class="italic">Chapter 13</em></a><em class="italic">, Tips and Outlook</em>.</p>
			<p>There is one simple<a id="_idIndexMarker378"/> thing left that we have to change in our application to make it work again. You may have noticed that the functions in our service changed to <strong class="source-inline">async</strong> functions, which return promises instead of direct data. While we were able to process the local data synchronously, API calls are always executed asynchronously.</p>
			<p>And that’s a good thing. You don’t want your application to freeze until the response to your API request is there. But since the service function returns promises now, we have to modify the places where these functions are called.</p>
			<p>So, let’s have a look at the home view again – more precisely, the <strong class="source-inline">useEffect</strong> Hook part: </p>
			<pre class="source-code">
  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      setGenres(await getGenres());
    };
    fetchData();
  }, []); </pre>
			<p>Since we are not able to create async functions directly in the <strong class="source-inline">useEffect</strong> Hook, we create an async <strong class="source-inline">fetchData</strong> function that we then call in <strong class="source-inline">useEffect</strong>. In this function, we await the promise that is returned by <strong class="source-inline">getGenres</strong> and set the data in the state. </p>
			<p>Similar changes have to be made in the <strong class="source-inline">genre</strong> view, the <strong class="source-inline">movie</strong> view, and the <strong class="source-inline">addFavById</strong> function of our Zustand store. </p>
			<p>While Fetch is quite powerful <a id="_idIndexMarker379"/>and you can use it even in large-scale and enterprise projects, some other solutions can be useful too. </p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor128"/>Working with other data fetching solutions</h2>
			<p>In this subsection, you’ll learn about <a id="_idIndexMarker380"/>other popular solutions for data fetching. All of them have their benefits and tradeoffs and in the end, you have to decide what’s the best fit for your project. The following solutions work fine, are well maintained, and are widely used: </p>
			<ul>
				<li><strong class="bold">Axios</strong>: Axios is a third-party HTTP client for fetching data. It works quite similarly to the Fetch API but brings a lot <a id="_idIndexMarker381"/>of additional features. Once created, you can configure your Axios instance with headers, interceptors, and more. It also provides excellent error handling and allows you to cancel requests. </li>
				<li><strong class="bold">Apollo/URQL GraphQL client</strong>: GraphQL is <a id="_idIndexMarker382"/>a query language for APIs that has become very popular over the last few years. The advantage it has over REST APIs is that you can control what you want to fetch on the client. You can also fetch multiple resources in one call. This results in fetching exactly the data you need in the most efficient way possible. You can read more <a id="_idIndexMarker383"/>about GraphQL here: <a href="https://bit.ly/prn-advantage-graph">https://bit.ly/prn-advantage-graph</a>.</li>
			</ul>
			<p>There are multiple client implementations for GraphQL. The most popular ones are Apollo and URQL. Both clients <a id="_idIndexMarker384"/>not only provide data fetching but also handle caching, refreshing, and data actualization in the UI. While this can be very useful, you always should ensure that you also provide a great user experience for users while they are offline.</p>
			<ul>
				<li><strong class="bold">React Native Firebase</strong>: Firebase is a very popular app development backend platform. It provides different services with very well-maintained SDKs. React Native Firebase is a wrapper around the native Android and iOS SDK. It provides data fetching, but only for connections to<a id="_idIndexMarker385"/> the Firebase services. If you want to learn more about Firebase, you can visit the React Native Firebase <a id="_idIndexMarker386"/>documentation: <a href="https://bit.ly/prn-firebase">https://bit.ly/prn-firebase</a>.</li>
				<li><strong class="bold">AWS Amplify</strong>: Amplify is a collection of AWS services that can be accessed via the Amplify SDKs. Like<a id="_idIndexMarker387"/> Firebase, it provides data fetching capabilities, but only to the AWS services that have <a id="_idIndexMarker388"/>been configured in Amplify. If you<a id="_idIndexMarker389"/> want to learn more about Amplify, you can visit the Amplify JavaScript documentation: <a href="https://bit.ly/prn-amplify">https://bit.ly/prn-amplify</a>.</li>
			</ul>
			<p>Besides these solutions, a lot of service providers provide their own SDKs that can be used to access their services. It is totally fine to use these SDKs. But again, always remember to not store any API keys or authentication information in your app.</p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor129"/>Summary</h1>
			<p>To wrap this chapter up, let’s have a short recap. In this chapter, you learned how to handle local and global states. You learned about the most popular concepts of global state handling and how to decide which data should be stored in your global state or the local state of a component or view. You also understood how to use React Context, Zustand, and Redux for global state handling. </p>
			<p>After mastering state management in React Native, you learned how to connect your app to a remote backend. You understood how to use the built-in Fetch API, how to extract API calls in a service, how to create and use helper functions, and how to work with async calls. Finally, you learned about the different solutions for data fetching, such as Axios, GraphQL clients, and other SDKs. </p>
			<p>Now that you have completed the first five chapters of this book, you can create a working app with a strong technical foundation. In the next chapter, you will learn how to make your app look good with beautiful animations.</p>
		</div>
	</body></html>