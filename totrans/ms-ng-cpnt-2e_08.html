<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Time Will Tell</h1>
                </header>
            
            <article>
                
<p>Our task-management system is shaping up. However, we have not been concerned about one crucial aspect of managing our projects so far. Time plays a major role in all projects, and it's probably the aspect that is often the most complicated to manage.</p>
<p>In this chapter, we will add a few features to our task management system that will help our users to manage time more efficiently. Reusing some components that we created earlier, we will be able to provide a consistent user experience to manage time.</p>
<p>On a higher level, we will develop the following features to enable time management in our application:</p>
<ul>
<li><strong>Task details</strong>: So far, we did not include a details page of tasks because all the necessary information about tasks could be displayed on the task list of our project page. As our time management will increase the complexity of our tasks quite a bit, we will create a new detail view of project tasks that will also be accessible through routing.</li>
<li><strong>Efforts management</strong>: We will include some new data on our tasks to manage efforts on tasks. Efforts are always represented by an estimated duration of time and an effective duration of spent time. We will make both properties of efforts optional so that they can exist independently. We will create new components to enable users to provide time duration input easily.</li>
</ul>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Creating a project task detail component to edit task details and enable a new route</li>
<li>Modifying our tag management system to include task tags</li>
<li>Creating new pipes to deal with formatting time durations</li>
<li>Creating task information components to display task overview information on the existing task components</li>
<li>Creating a time duration component that enables users to easily input time durations using a no-UI user interaction approach</li>
<li>Implementing time effort tracking on tasks</li>
<li>Creating an SVG component to display progress on tasks</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Task details</h1>
                </header>
            
            <article>
                
<p>So far, our task list was sufficient enough to display all details of tasks directly in the listing. However, as we will add more details to tasks in this chapter, it's time to provide a detailed view where users can edit the task.</p>
<p>We already laid the groundwork for project navigation using the router in <a href="237031a7-f616-4811-8486-08b5113d316f.xhtml">Chapter 5</a>, <em>Component-Based Routing</em>. Adding a new routable component that we'll use in the context of our projects will be a breeze.</p>
<p>Before we start creating a new task details component, let's introduce a new state within our task model. Users should have the additional option to provide a task description in addition to the task title. This description will be editable on the task details view.</p>
<p>Let's open our model file, located in <kbd>src/app/model.ts</kbd>, and add an optional description field to our task interface:</p>
<pre>…<br/><br/>export interface Task {<br/>  readonly id?: number;<br/>  readonly projectId?: number;<br/>  readonly title: string;<br/><strong>  readonly description?: string;</strong><br/>  readonly done: boolean;<br/>  readonly order: number;<br/>}<br/><br/>…</pre>
<p>Okay, so now we can store a description with each of our tasks. When new tasks are created on the task list, however, we will still only store the title of the task. A user needs to access the new detail view in order to update the description of a task.</p>
<p>Alright, let's create a new component for our task detail view using the Angular CLI:</p>
<pre><strong>ng generate component --spec false -cd onpush tasks/task-details</strong></pre>
<p>Let's open the generated component class file in <kbd>src/app/tasks/task-details/task-details.component.ts</kbd> and add the following code:</p>
<pre>import {<br/>  ChangeDetectionStrategy, Component, EventEmitter, Input, Output,<br/>  ViewEncapsulation<br/>} from '@angular/core';<br/>import {Tag, Task} from '../../model';<br/><br/>@Component({<br/>  selector: 'mac-task-details',<br/>  templateUrl: './task-details.component.html',<br/>  styleUrls: ['./task-details.component.css'],<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class TaskDetailsComponent {<br/>  @Input() task: Task;<br/>  @Input() tags: Tag[];<br/>  @Output() outUpdateTask = new EventEmitter&lt;Task&gt;();<br/><br/>  updateTitle(title: string) {<br/>    this.outUpdateTask.emit({<br/>      ...this.task,<br/>      title<br/>    });<br/>  }<br/><br/>  updateDescription(description: string) {<br/>    this.outUpdateTask.emit({<br/>      ...this.task,<br/>      description<br/>    });<br/>  }<br/>}</pre>
<p>Within the task details, we're enabling the user to edit both the title and description of tasks. We're working on a simple UI component to represent the task details view. Therefore, we're expecting the task object to be set as a component input. The <kbd>outUpdateTask</kbd> output is used to communicate task updates to our parent component. We've also added two methods to be used within our view in order to update the task title and description.</p>
<p>We'd also like to support tag selection when a user edits the description of a task. For this purpose, we're adding a <kbd>tags</kbd> input, which can be provided by the parent component.</p>
<p>Alright, let's now take a look at the template of our component, and see how we'll deal with the task data to provide an interface to edit the details. Open the template file located in  <kbd>src/app/tasks/task-details/task-details.component.html</kbd> and add the following content:</p>
<pre>&lt;h3 class="title"&gt;Task Details of task #{{task.id}}&lt;/h3&gt;<br/>&lt;div class="content"&gt;<br/>  &lt;div class="label"&gt;Title&lt;/div&gt;<br/>  &lt;mac-editor [content]="task.title"<br/>              [showControls]="true"<br/>              (outSaveEdit)="updateTitle($event)"&gt;&lt;/mac-editor&gt;<br/>  &lt;div class="label"&gt;Description&lt;/div&gt;<br/>  &lt;mac-editor [content]="task.description"<br/>              [showControls]="true"<br/>              [tags]="tags"<br/>              (outSaveEdit)="updateDescription($event)"&gt;&lt;/mac-editor&gt;<br/>&lt;/div&gt;</pre>
<p>By reusing the editor component that we created in <a href="1682edec-f2b3-4b02-afd8-ed7ef586b712.xhtml"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>Thinking in Projects</em>, we can rely on simple UI composition to make the title and description of our tasks editable.</p>
<p>As we stored the task data into the <kbd>task</kbd> member variable on our component, we can reference the <kbd>title</kbd> and <kbd>description</kbd> fields to create a binding to the <kbd>content</kbd> input property of our editor components.</p>
<p>While the title should only consist of plaintext, we can support the tagging functionality that we created in <a href="70aeeb16-2a1e-4d20-b523-00df06a8398a.xhtml"><span class="ChapterrefPACKT">Chapter 7</span></a>, <em>Components for User Experience</em>, on the description field of the task. For this, we simply pass the list of available tags into the editor component.</p>
<p>We are using the editor components'  <kbd>outSaveEdit</kbd> output property to call our update functions for updating the title or description, respectively.</p>
<p>So far, so good. We created a task details component that makes it easy to edit the title and description of tasks using our editor UI component. Now, we need to create a container component for our task details view and enable it as a child route within our application.</p>
<p>Let's use the Angular CLI to create a task details container component:</p>
<pre><strong>ng generate component --spec false -cd onpush container/task-details-container</strong></pre>
<p>As always, the view of our container components is dead simple. We're simply rendering a UI component and passing down the required data. Let's do that by editing the template of our task details container component, which is located in <kbd>src/app/container/task-details-container/task-details-container.component.html</kbd><span>:</span></p>
<pre>&lt;mac-task-details [task]="task | async"<br/>                  [tags]="tags | async"<br/>                  (outUpdateTask)="updateTask($event)"&gt;<br/>&lt;/mac-task-details&gt;</pre>
<p>The task details UI component required a task object to be passed as input as well as the list of tags supported by our application. We'll obtain this data using the observables provided from the respective services. When a task is updated we'll receive the <kbd>outUpdateTask</kbd> output event and call a method <kbd>updateTask</kbd> on our container component. Let's open the component class located in <span><kbd>src/app/container/task-details-container/task-details-container.component.ts</kbd> </span>and add the following code:</p>
<pre>import {ChangeDetectionStrategy, Component, ViewEncapsulation} from '@angular/core';<br/>import {ActivatedRoute} from '@angular/router';<br/>import {TaskService} from '../../tasks/task.service';<br/>import {Observable, combineLatest} from 'rxjs';<br/>import {Tag, Task} from '../../model';<br/>import {map} from 'rxjs/operators';<br/>import {TagsService} from '../../tags/tags.service';<br/><br/>@Component({<br/>  selector: 'mac-task-details-container',<br/>  templateUrl: './task-details-container.component.html',<br/>  styleUrls: ['./task-details-container.component.css'],<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class TaskDetailsContainerComponent {<br/>  task: Observable&lt;Task&gt;;<br/>  tags: Observable&lt;Tag[]&gt;;<br/><br/>  constructor(private taskService: TaskService,<br/>              private route: ActivatedRoute,<br/>              private tagsService: TagsService) {<br/>    this.task = combineLatest(<br/>      this.taskService.getTasks(),<br/>      route.params<br/>    ).pipe(<br/>      map(([tasks, routeParams]) =&gt;<br/>        tasks.find((task) =&gt; task.id === +routeParams.taskId)<br/>      )<br/>    );<br/>    this.tags = this.tagsService.tags;<br/>  }<br/><br/>  updateTask(task: Task) {<br/>    this.taskService.updateTask(task);<br/>  }<br/>}</pre>
<p>There's nothing new here. We're using a route parameter called <kbd>taskId</kbd> to obtain a specific task from the task list coming from our task service.</p>
<p>The only thing left to enable our new task details view is to create a child route within our route configuration. Let's open our route configuration, located in <kbd>src/app/routes.ts</kbd>, to make the necessary modifications:</p>
<pre>…<br/><strong>import {TaskDetailsContainerComponent} from './container/task-details-container/task-details-container.component';</strong><br/><br/>export const routes: Route[] = [{<br/>  path: 'projects/:projectId',<br/>  component: ProjectContainerComponent,<br/>  canActivate: [ProjectContainerGuard],<br/>  children: [{<br/>    path: 'tasks',<br/>    component: TaskListContainerComponent<br/>  }<strong>, {</strong><br/><strong>    path: 'tasks/:taskId',</strong><br/><strong>    component: TaskDetailsContainerComponent</strong><br/><strong>  }</strong>, {<br/>    path: 'comments',<br/>    component: ProjectCommentsContainerComponent<br/>  }, {<br/>    path: 'activities',<br/>    component: ProjectActivitiesContainerComponent<br/>  }, {<br/>    path: '**',<br/>    redirectTo: 'tasks'<br/>  }]<br/>}, {<br/>  path: '',<br/>  pathMatch: 'full',<br/>  redirectTo: '/projects/1'<br/>}];</pre>
<p>We added a new child route on our project view, which is now accessible with the URL <kbd>/projects/:projectId/tasks/:taskId</kbd>. By including the parameter <kbd>:taskId</kbd> in the route configuration, we can pass the concerned task ID into the <span>task details container</span> component.</p>
<p>Fantastic! We've created a new task details view and enabled it within our router. You can preview your changes within the browser and access the details view of a task by entering the following URL into your browser: <kbd>http://localhost:4200/projects/1/tasks/1</kbd>. You should now see the details view of the first task within our first project. Try editing the title and description before we move on with the integration of our task details view.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Navigating to task details</h1>
                </header>
            
            <article>
                
<p>In order to make our task details route navigable, we need to modify our task component within the task list. We would like to add a small button to our task component that will navigate to the details view. Let's start with the template changes; open our task component template, located in <kbd>src/app/tasks/task/task.component.html</kbd>, and apply the following changes:</p>
<pre>&lt;mac-checkbox [checked]="task.done"<br/>              (outCheck)="updateTask($event)"&gt;&lt;/mac-checkbox&gt;<br/>&lt;div class="content"&gt;<br/>  &lt;div class="title"&gt;<br/>    &lt;mac-editor [content]="task.title"<br/>                [showControls]="true"<br/>                (outSaveEdit)="updateTitle($event)"&gt;&lt;/mac-editor&gt;<br/>  &lt;/div&gt;<br/>  <strong>&lt;button class="button button-small" (click)="showDetails()"&gt;Details&lt;/button&gt;</strong><br/>  &lt;button class="delete" (click)="deleteTask()"&gt;&lt;/button&gt;<br/>&lt;/div&gt;</pre>
<p>Let's move right into our component class and implement the new <kbd>showDetails</kbd> method. Open the file <kbd><span>src/app/tasks/task/task.component.html</span></kbd> and apply the following changes:</p>
<pre>…<br/><br/>@Component({<br/>  selector: 'mac-task',<br/>  templateUrl: './task.component.html',<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class TaskComponent {<br/>  …<br/>  <strong>@Output() outShowDetails = new EventEmitter&lt;Task&gt;();</strong><br/><br/>  …<br/><br/><strong>  showDetails() {</strong><br/><strong>    this.outShowDetails.emit(this.task);</strong><br/><strong>  }</strong><br/>}</pre>
<p>Alright, now we need to make sure that we're carrying the event to show task details all the way up to the task list container component. Our next step is the task list UI component, where we need to delegate the <kbd>outShowDetails</kbd> output of our task component.</p>
<p>Let's start with the template changes in <span><kbd>src/app/tasks/task-list/task-list.component.html</kbd> and apply the following change:</span></p>
<pre>…<br/>&lt;div class="tasks"&gt;<br/>  &lt;mac-task *ngFor="let task of tasks"<br/>            [task]="task"<br/>            (outUpdateTask)="updateTask($event)"<br/>            (outDeleteTask)="deleteTask($event)"<br/><strong>            (outShowDetails)="showDetails($event)"</strong><br/>            macDraggable<br/>            draggableType="task"<br/>            [draggableData]="task"<br/>            macDraggableDropZone<br/>            dropAcceptType="task"<br/>            (outDropDraggable)="dropTask(task, $event)"&gt;&lt;/mac-task&gt;<br/>&lt;/div&gt;</pre>
<p>That was easy! Now, let's add the changes to the task list component class located in <kbd><span>src/app/tasks/task-list/task-list.component.ts</span></kbd>:</p>
<pre>…<br/><br/>@Component({<br/>  selector: 'mac-task-list',<br/>  templateUrl: './task-list.component.html',<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class TaskListComponent {<br/>  …<br/>  <strong>@Output() outShowDetails = new EventEmitter&lt;Task&gt;();</strong><br/><br/>  …<br/><br/>  <strong>showDetails(task: Task) {</strong><br/><strong>    this.outShowDetails.emit(task);</strong><br/><strong>  }</strong><br/>}</pre>
<p>Great, the next stop in our component tree is the task list container, which is where we'll implement the logic to navigate to the details view. Let's open the template of the task list container, located in <kbd>src/app/container/task-list-container/task-list-container.component.html</kbd>, and create the necessary binding:</p>
<pre>&lt;mac-task-list<br/>  [tasks]="filteredTasks | async"<br/>  [taskFilterTypes]="taskFilterTypes"<br/>  [activeTaskFilterType]="activeTaskFilterType | async"<br/>  (outUpdateTask)="updateTask($event)"<br/>  (outDeleteTask)="deleteTask($event)"<br/>  <strong>(outShowDetails)="showDetails($event)"</strong><br/>  (outActivateFilterType)="activateFilterType($event)"<br/>  (outAddTask)="addTask($event)"&gt;<br/>&lt;/mac-task-list&gt;</pre>
<p>Finally, we need to implement the <kbd>showDetails</kbd> method within the container component class located in <kbd><span>src/app/container/task-list-container/task-list-container.component.ts</span></kbd>:</p>
<pre>…<br/><br/>@Component({<br/>  selector: 'mac-task-list-container',<br/>  templateUrl: './task-list-container.component.html',<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class TaskListContainerComponent {<br/>  …<br/><br/>  <strong>showDetails(task: Task) {</strong><br/><strong>    this.selectedProject</strong><br/><strong>      .pipe(take(1))</strong><br/><strong>      .subscribe(selectedProject =&gt; {</strong><br/><strong>        this.router.navigate(['/projects', selectedProject.id, 'tasks', task.id]);</strong><br/><strong>      });</strong><br/><strong>  }</strong><br/>}</pre>
<p>Hurray! We have finally made our task details view navigable using a new navigation button on our task component!</p>
<p>Now, you might ask yourself, why have we implemented such a crazy output delegation path, just to trigger a navigation? Wouldn't it be much easier to just use a <kbd>routerLink</kbd> directive within the task UI component and be done?</p>
<p>Of course, that would be much easier. However, there's a slight problem with using router links within simple UI components. By doing so, we rely on a specific route configuration being present in our system. Using router links directly within UI components restricts them to a very specific context. We'd like to avoid this, so we can reuse our components in many different contexts. The only meaningful way to solve this issue is to use output delegation and control your navigation within container components programmatically:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5de1ef3b-662b-4706-b963-ca0504b9dc22.png" style=""/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Newly created task detail view with editable title and description</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enabling tags for tasks</h1>
                </header>
            
            <article>
                
<p>So far, the tag-management system that we created in <a href="70aeeb16-2a1e-4d20-b523-00df06a8398a.xhtml"><span class="ChapterrefPACKT">Chapter 7</span></a>, <em>Components for User Experience</em>, only supports project tags. As we have now created a detail view for tasks, it would be nice to also support task tags directly in our tagging system. Our tagging system is quite flexible, and we can implement new tags with very little effort.</p>
<p>Let's modify our tags service, located in <kbd>src/app/tags/tags.service.ts</kbd>, in order to enable tags for our tasks:</p>
<pre>import {Injectable} from '@angular/core';<br/>import {ProjectService} from '../project/project.service';<br/>import {Project, Tag<strong>, Task</strong>} from '../model';<br/>import {Observable, of<strong>, combineLatest</strong>} from 'rxjs/Observable';<br/>import {map} from 'rxjs/operators';<br/>import {limitWithEllipsis, replaceAll} from '../utilities/string-utilities';<br/><strong>import {TaskService} from '../tasks/task.service';</strong><br/><br/>@Injectable()<br/>export class TagsService {<br/>  tags: Observable&lt;Tag[]&gt;;<br/><br/>  constructor(private projectService: ProjectService<strong>,</strong><br/><strong>              private taskService: TaskService</strong>) {<br/>    <strong>this.tags = combineLatest(</strong><br/><strong>      this.projectService.getProjects().pipe(</strong><br/><strong>        map((projects: Project[]) =&gt; projects.map(project =&gt; ({</strong><br/><strong>          type: 'project',</strong><br/><strong>          hashTag: `#project-${project.id}`,</strong><br/><strong>          title: limitWithEllipsis(project.title, 20),</strong><br/><strong>          link: `/projects/${project.id}/tasks`</strong><br/><strong>        })))</strong><br/><strong>      ),</strong><br/><strong>      this.taskService.getTasks().pipe(</strong><br/><strong>        map((tasks: Task[]) =&gt; tasks.map(task =&gt; ({</strong><br/><strong>          type: 'task',</strong><br/><strong>          hashTag: `#task-${task.id}`,</strong><br/><strong>          title: `${limitWithEllipsis(task.title, 20)} (${task.done ? 'done' : 'open'})`,</strong><br/><strong>          link: `/projects/${task.projectId}/tasks/${task.id}`</strong><br/><strong>        })))</strong><br/><strong>      )</strong><br/><strong>    ).pipe(</strong><br/><strong>      map(([projectTags, taskTags]) =&gt; [...projectTags, ...taskTags])</strong><br/><strong>    );</strong><br/>  }<br/><br/>  …<br/>}</pre>
<p>In addition to the project service, we're also injecting the task service within the constructor of our tags service. Very similar to what we already do for projects, we need to create a tag object for every single task within our application. We're using the observable provided by the task service and use the <kbd>map</kbd> operator to convert all tasks to tags.</p>
<p>Finally, we're using the <kbd>combineLatest</kbd> observable helper to merge both project tags and task tags into a single observable stream. Within a final map operator, we're concatenating those two tag lists into a single array.</p>
<p>This wasn't too complicated, right? This relatively simple change results in a huge improvement for our users. They can now reference individual tasks everywhere in our system where we have enabled tags. By clicking a task tag, we are navigating to our newly created task details view:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/eecd6862-a29c-4085-a312-6bba0a1ea149.png" style=""/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The editor component of the project comments tab displaying the newly added task tags</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing efforts</h1>
                </header>
            
            <article>
                
<p>In this section, we will create some components that help us keep track of work efforts. Primarily, we will use this to manage efforts on tasks, but this could be applied to any part of our application where we need to keep track of time.</p>
<p>Efforts in our context always consist of two things:</p>
<ul>
<li><strong>Estimated duration</strong>: This is the duration that is initially estimated for the task</li>
<li><strong>Effective duration</strong>: This is the duration of time that is spent on a given task</li>
</ul>
<p>For time durations, we assume some time units and rules that will simplify the processing of time and align to some working standards. The goal here is not to provide razor sharp time management but something that is accurate enough to bring value. For this purpose, we define the following working time units:</p>
<ul>
<li><strong>Minute</strong>: One minute is a regular 60 seconds</li>
<li><strong>Hour</strong>: One hour always represents 60 minutes</li>
<li><strong>Day</strong>: One day represents a regular workday of eight hours</li>
<li><strong>Week</strong>: One week is equivalent to five working days (5 * 8 hours)</li>
</ul>
<p>When working with durations and efforts we would like to have some type safety, and for this reason, we're introducing a few new interfaces to our model. Let's open our model, located in <kbd>src/app/model.ts</kbd>, and add the following two interfaces:</p>
<pre>…<br/><br/><strong>export interface TimeUnit {</strong><br/><strong>  short: string;</strong><br/><strong>  milliseconds: number;</strong><br/><strong>}</strong><br/><br/><strong>export interface TimeEfforts {</strong><br/><strong>  estimated: number;</strong><br/><strong>  effective: number;</strong><br/><strong>}<br/></strong></pre>
<p style="font-size: 16px">The <kbd>short</kbd> property on the <kbd>TimeUnit</kbd> interface will be used to recognize time entry by the user. We will use the letters m, h, d, and w for the different time units and store how many milliseconds each time frame contains.</p>
<p>Since we'd like to keep track of the time and efforts spent on tasks, let's also modify our task model. Find the <kbd>Task</kbd> interface within our model file and add the following property:</p>
<pre>export interface Task {<br/>  readonly id?: number;<br/>  readonly projectId?: number;<br/>  readonly title: string;<br/>  readonly description?: string;<br/>  readonly done: boolean;<br/>  readonly order: number;<br/><strong>  readonly efforts?: TimeEfforts;</strong><br/>}<br/><br/>…</pre>
<p>We have added a new optional <kbd>efforts</kbd> property to our task interface, which is storing the efforts spent working on our tasks.</p>
<p style="font-size: 16px">Alright, we have prepared our model for the upcoming time tracking features. In the next section, we're going to implement our first UI component to enter time durations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">No-UI time duration input</h1>
                </header>
            
            <article>
                
<p>We could now start to write a complex user interface component, where users can enter individual time units in different input elements. However, I believe it's much more convenient to treat time duration input with a no-UI approach.</p>
<p>Put very simply, no-UI means that we use regular text input to provide user interactions. Well, that's nothing new right? Text input is where it all started. However, there's a significant trend in providing no-UI interactions lately. By combining intelligence in how we process the text input of users, no-UI interactions can actually be surprisingly efficient, and outperform complex user interfaces by far.</p>
<p>Instead of building a complex user interface to enter time duration, we can simply agree on a textual short form to write durations. We can let the user write something, such as <kbd>1.5d</kbd> or <kbd>5h 30m</kbd>, in order to provide input. Sticking to the convention that we established at the beginning of this section, <em>Managing Efforts</em>, we can build a simple parser that can handle this sort of input.</p>
<p>This approach has several advantages. Besides that, this is one of the most efficient ways to enter time durations, and it's also easy for us to implement. We can simply reuse our editor component to gather text input from the user. Then, we use a conversion process to parse the entered time duration.</p>
<p>Let's spin up a new utility module that helps us deal with these conversions. Let's start by creating a new empty file on the path <kbd>src/app/utilities/time-utilities.ts</kbd>.</p>
<p>First, we need to have a constant that defines all the units we need for the conversion process. Add this first code excerpt to our newly created file:</p>
<pre>import {TimeUnit} from '../model';<br/><br/>export const UNITS: TimeUnit[] = [{<br/>  short: 'w',<br/>  milliseconds: 5 * 8 * 60 * 60 * 1000<br/>}, {<br/>  short: 'd',<br/>  milliseconds: 8 * 60 * 60 * 1000<br/>}, {<br/>  short: 'h',<br/>  milliseconds: 60 * 60 * 1000<br/>}, {<br/>  short: 'm',<br/>  milliseconds: 60 * 1000<br/>}];</pre>
<p>We make use of the <kbd>TimeUnit</kbd> <span>interface which we've created in our model.</span></p>
<p>These are all the units that we need to deal with for now. You can see the milliseconds being calculated at run-time. We can also write the milliseconds as number literals, but calculating them in place provides us with some transparency on how we get to these values and we can spear on some comments.</p>
<p>Let's look at our parsing function, which we can use to parse text input into time durations. Append the following code to our file:</p>
<pre>export function parseDuration(formattedDuration: string): number {<br/>  const pattern = /[\d\.]+\s*[wdhm]/g;<br/>  let timeSpan = 0;<br/>  let result;<br/>  while (result = pattern.exec(formattedDuration)) {<br/>    const chunk = result[0].replace(/\s/g, '');<br/>    const amount = Number(chunk.slice(0, -1));<br/>    const unitShortName = chunk.slice(-1);<br/>    timeSpan += amount * UNITS.find((unit) =&gt; unit.short === unitShortName).milliseconds;<br/>  }<br/>  return timeSpan || null;<br/>}</pre>
<p>Let's analyze the preceding code briefly to explain what we do here:</p>
<ol>
<li>First, we define a regular expression that helps us dissect the text representation of a duration. This pattern will extract chunks from the text input that are important to calculate the duration behind the text representation. These chunks always consist of a number, followed by either <kbd>w</kbd>, <kbd>d</kbd>, <kbd>h</kbd>, or <kbd>m</kbd>. Therefore, the text <kbd>10w 3d 2h 30m</kbd> will be split into the chunks <kbd>10w</kbd>, <kbd>3d</kbd>, <kbd>2h</kbd>, and <kbd>30m</kbd>.</li>
<li>We initialize a <kbd>timeSpan</kbd> variable with <kbd>0</kbd>, so we can add all the milliseconds from discovered chunks together and later return this sum.</li>
</ol>
<ol start="3">
<li>For each of the previously-extracted chunks, we now extract the number component into a variable called <kbd>amount</kbd>, and the unit (<kbd>w</kbd>, <kbd>d</kbd>, <kbd>h</kbd>, or <kbd>m</kbd>) into a variable called <kbd>unitShortName</kbd>.</li>
<li>Now, we can look up the data in the <kbd>UNITS</kbd> constant for the unit of the chunk that we will process, multiply the amount of milliseconds of the unit by the amount we extract from the chunk, and then add that result to our <kbd>timeSpan</kbd> variable.</li>
</ol>
<p>Well, this is quite a neat function we have built here. It accepts a formatted time duration string and converts it into milliseconds. This is already half of what we need to deal with the textual representation of time durations. The second piece is the opposite of what just built. We need a function to convert a duration in milliseconds into a formatted duration string. Let's append another piece of code to our file:</p>
<pre>export function formatDuration(timeSpan: number): string {<br/>  return UNITS.reduce((str, unit) =&gt; {<br/>    const amount = timeSpan / unit.milliseconds;<br/>    if (amount &gt;= 1) {<br/>      const fullUnits = Math.floor(amount);<br/>      const formatted = `${str} ${fullUnits}${unit.short}`;<br/>      timeSpan -= fullUnits * unit.milliseconds;<br/>      return formatted;<br/>    } else {<br/>      return str;<br/>    }<br/>  }, '').trim();<br/>} </pre>
<p>Let's also explain briefly what the <kbd>formatDuration</kbd> function does:</p>
<ul>
<li>We use the <kbd>Array.prototype.reduce</kbd> function to format a string that contains all time units and their amount. We iterate over all available time units in the <kbd>UNITS</kbd> constant, starting with the largest unit for weeks.</li>
<li>We then divide the <kbd>timeSpan</kbd> variable, which is in milliseconds, by the milliseconds of the unit, which gives us the amount of the given unit.</li>
<li>If the amount is greater than or equal to 1, we can add the unit with the given amount and unit short name to our formatted string.</li>
<li>As we could be left with some fractions after the comma in the amount, which we will need to encode in smaller units, we subtract the floored version of our amount from the <kbd>timeSpan</kbd> before we return to the <kbd>reduce</kbd> function again.</li>
<li>This process is repeated for every unit, where each unit will only provide a formatted output if the amount is greater than or equal to 1.</li>
</ul>
<p>This is all we need to convert back and forth between formatted time duration and time duration represented in milliseconds.</p>
<p>We'll do one more thing before we create the actual component to enter time durations. We will create a simple pipe that basically just wraps our <kbd>formatTime</kbd> function. For this, we will create a new pipe using the Angular CLI:</p>
<pre><strong>ng generate pipe --spec false pipes/format-duration</strong></pre>
<p>Let's open the generated file <kbd>src/app/pipes/format-duration.pipe.ts</kbd> and add the following content:</p>
<pre>import {Pipe, PipeTransform} from '@angular/core';<br/>import {formatDuration} from '../utilities/time-utilities';<br/><br/>@Pipe({<br/>  name: 'formatDuration'<br/>})<br/>export class FormatDurationPipe implements PipeTransform {<br/>  transform(value) {<br/>    if (value == null || typeof value !== 'number') {<br/>      return value;<br/>    }<br/><br/>    return formatDuration(value);<br/>  }<br/>}</pre>
<p>Using the <kbd>formatTime</kbd> function of our new time utility module, we now have the ability to format durations in milliseconds directly in our component templates.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Components to manage efforts</h1>
                </header>
            
            <article>
                
<p>Okay, this is enough time-math for the moment. Let's now use the elements that we've created to shape some components that will help us gather user input.</p>
<p>In this section, we will create two components to manage efforts:</p>
<ul>
<li><strong>Duration component</strong>: The duration component is a simple UI component, enabling user input of time durations using the formatted time strings we dealt with in the previous topics. It uses an editor component to enable user input and makes use of the time formatting pipe as well as the <kbd>parseDuration</kbd> utility function.</li>
<li><strong>Efforts component</strong>:<strong> </strong>The efforts component is just a composition of two duration components that represent the estimated effort and the effective effort spent on a given task. Following a strict rule of composition, this component is important for us so that we don't repeat ourselves and instead compose a larger component.</li>
</ul>
<p>Let's start with the duration component and use the Angular CLI to scaffold our initial component structure:</p>
<pre><strong>ng generate component --spec false -cd onpush ui/duration</strong></pre>
<p>Alright, let's now open the component class located in <kbd>src/app/ui/duration/duration.component.ts</kbd> and apply the following changes:</p>
<pre>import {ChangeDetectionStrategy, Component, EventEmitter, Input, Output, ViewEncapsulation} from '@angular/core';<br/>import {parseDuration} from '../../utilities/time-utilities';<br/><br/>@Component({<br/>  selector: 'mac-duration',<br/>  templateUrl: './duration.component.html',<br/>  styleUrls: ['./duration.component.css'],<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class DurationComponent {<br/>  @Input() duration: number;<br/>  @Output() outDurationChange = new EventEmitter&lt;number&gt;();<br/><br/>  editSaved(formattedDuration: string) {<br/>    this.outDurationChange.emit(parseDuration(formattedDuration));<br/>  }<br/>}<br/> </pre>
<p>There's nothing fancy about this component really, because we created the bulk of the logic already and we simply compose a higher component.</p>
<p>For the <kbd>duration</kbd> input, we expect a time duration in milliseconds, while the <kbd>outDurationChange</kbd> output property will emit the updated duration in milliseconds when the user provides some input.</p>
<p>The <kbd>editSaved</kbd> method serves in the binding to the underlying editor component. Whenever the user saves his edits on the editor component, we'll take this input, convert the formatted time duration into milliseconds using the <kbd>parseDuration</kbd> function, and re-emit the converted value using the <kbd>outDurationChange</kbd> output property.</p>
<p>Let's look at the template of our component in <kbd><span>src/app/ui/duration/duration.component.ts</span></kbd>:</p>
<pre>&lt;mac-editor [content]="duration | formatDuration"<br/>            [showControls]="true"<br/>            (outSaveEdit)="editSaved($event)"&gt;&lt;/mac-editor&gt;</pre>
<p>Surprised with how simple our template is? Well, this is exactly what we should achieve with higher order components, once we establish a good foundation of base components. Well-organized composition radically simplifies our code. The only thing that we deal with here is our good old editor component.</p>
<p>We bind the <kbd>duration</kbd> input property of our duration component to the <kbd>content</kbd> input property of the editor component. As we'd like to pass the formatted time duration and not the duration in milliseconds, we use the <kbd>formatDuration</kbd> pipe to convert within the binding expression.</p>
<p>If the editor component notifies us about a saved edit, we call the <kbd>editSaved</kbd> method on our duration component, which will parse the entered duration and re-emit the resulting value a    s milliseconds.</p>
<p>As we initially defined all efforts to consist of an estimated and an effective duration, we would now like to create another component that combines these two durations within a single component.</p>
<p>Let's create a new efforts component by using the Angular CLI tool:</p>
<pre><strong>ng generate component --spec false -cd onpush efforts/efforts</strong></pre>
<p>Open up the template file of the generated component, located in <kbd>src/app/efforts/efforts/efforts.component.html</kbd>, and add the following content:</p>
<pre>&lt;div class="label"&gt;Estimated:&lt;/div&gt;<br/>&lt;mac-duration [duration]="efforts?.estimated"<br/>              (outDurationChange)="estimatedChange($event)"&gt;&lt;/mac-duration&gt;<br/>&lt;div class="label"&gt;Effective:&lt;/div&gt;<br/>&lt;mac-duration [duration]="efforts?.effective"<br/>              (outDurationChange)="effectiveChange($event)"&gt;&lt;/mac-duration&gt;<br/>&lt;button class="button small" (click)="addEffectiveHours(1)"&gt;+1h&lt;/button&gt;<br/>&lt;button class="button small" (click)="addEffectiveHours(4)"&gt;+4h&lt;/button&gt;<br/>&lt;button class="button small" (click)="addEffectiveHours(8)"&gt;+1d&lt;/button&gt;</pre>
<p>First, we add two duration components, where the first one is used to gather input for the estimated time and the later one for effective time.</p>
<p>In addition to this, we provide three small buttons to increase the effective duration by a simple click. In this way, the user can quickly add one or four hours (half a working day) or a complete working day (which we defined as eight hours).</p>
<p>Let's open the file <kbd><span>src/app/efforts/efforts/efforts.component.ts</span></kbd> and implement the component class:</p>
<pre>import {Component, ViewEncapsulation, Input, Output, EventEmitter, ChangeDetectionStrategy} from '@angular/core';<br/>import {UNITS} from '../../utilities/time-utilities';<br/>import {TimeEffort} from '../../model';<br/><br/>@Component({<br/>  selector: 'mac-efforts',<br/>  templateUrl: './efforts.component.html',<br/>  styleUrls: ['./efforts.component.css'],<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class EffortsComponent {<br/>  @Input() efforts: TimeEffort;<br/>  @Output() outEffortsChange = new EventEmitter&lt;TimeEffort&gt;();<br/><br/>  estimatedChange(estimated: number) {<br/>    this.outEffortsChange.emit({<br/>      ...this.efforts,<br/>      estimated<br/>    });<br/>  }<br/><br/>  effectiveChange(effective: number) {<br/>    this.outEffortsChange.emit({<br/>      ...this.efforts,<br/>      effective<br/>    });<br/>  }<br/><br/>  addEffectiveHours(hours: number) {<br/>    const hourMilliseconds = UNITS.find((unit) =&gt; unit.short === 'h').milliseconds;<br/>    let effective = this.efforts &amp;&amp; this.efforts.effective ? this.efforts.effective : 0;<br/>    effective += hours * hourMilliseconds;<br/><br/>    this.outEffortsChange.emit({<br/>      ...this.efforts,<br/>      effective<br/>    });<br/>  }<br/>}</pre>
<p>The component provides an input named <kbd>efforts</kbd> to provide a <kbd>TimeEfforts</kbd> object. If you take a look at the component template again, the <kbd>estimated</kbd> and <kbd>effective</kbd> properties of the efforts object are directly bound to the input properties of the duration components.</p>
<p>The <kbd>estimatedChange</kbd> and <kbd>effectiveChange</kbd> methods are used to create bindings to the <kbd>outDurationChange</kbd> output properties of the respective duration components. All we do here is emit an aggregated data object that contains the effective and estimated time in milliseconds using the <kbd>outEffortsChange</kbd> output property.</p>
<p>The <kbd>addEffectiveHours</kbd> method is used for our quick buttons within the template of our efforts component. We calculate the effective property by multiplying the number of milliseconds for a working hour with the number of hours passed to the function. We use our <kbd>UNITS</kbd> constant from the time utility module in order to get the number of milliseconds for an hour. After we've calculated the new effective duration, we're using the <kbd>outEffortsChange</kbd> output to propagate the update.</p>
<p>That's all we need in order to provide a user input to manage efforts on our tasks. To complete this topic, we will add our newly-created efforts component to the task details component in order to manage efforts on tasks.</p>
<p>Let's first look at the code changes in the task details component template located in <kbd>src/app/tasks/task-details/task-details.component.html</kbd>:</p>
<pre>&lt;h3 class="title"&gt;Task Details of task #{{task.id}}&lt;/h3&gt;<br/>&lt;div class="content"&gt;<br/>  &lt;div class="label"&gt;Title&lt;/div&gt;<br/>  &lt;mac-editor [content]="task.title"<br/>              [showControls]="true"<br/>              (outSaveEdit)="updateTitle($event)"&gt;&lt;/mac-editor&gt;<br/>  &lt;div class="label"&gt;Description&lt;/div&gt;<br/>  &lt;mac-editor [content]="task.description"<br/>              [showControls]="true"<br/>              [tags]="tags"<br/>              (outSaveEdit)="updateDescription($event)"&gt;&lt;/mac-editor&gt;<br/>  <strong>&lt;div class="label"&gt;Efforts&lt;/div&gt;</strong><br/><strong>  &lt;mac-efforts [efforts]="task.efforts"</strong><br/><strong>               (outEffortsChange)="updateEfforts($event)"&gt;</strong><br/><strong>  &lt;/mac-efforts&gt;</strong><br/>&lt;/div&gt;</pre>
<p>We're simply including our new efforts component in the task details template. Since we have the efforts object already present on our task objects, we can create the necessary binding without additional changes in the component class. However, for updating the efforts when a user changes the estimated or effective durations, we will need to implement a new method <kbd>updateEfforts</kbd>.</p>
<p>Let's open our component class, located in <kbd><span>src/app/tasks/task-details/task-details.component.html</span></kbd>, and implement the new method:</p>
<pre>import {<br/>  ChangeDetectionStrategy, Component, EventEmitter, Input, Output,<br/>  ViewEncapsulation<br/>} from '@angular/core';<br/>import {Tag, Task<strong>, TimeEfforts</strong>} from '../../model';<br/><br/>@Component({<br/>  selector: 'mac-task-details',<br/>  templateUrl: './task-details.component.html',<br/>  styleUrls: ['./task-details.component.css'],<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class TaskDetailsComponent {<br/>  …<br/><br/>  <strong>updateEfforts(efforts: TimeEfforts) {</strong><br/><strong>    this.outUpdateTask.emit({</strong><br/><strong>      ...this.task,</strong><br/><strong>      efforts</strong><br/><strong>    });</strong><br/><strong>  }</strong><br/>}</pre>
<p>We added a new <kbd>updateEfforts</kbd> method that deals with the output provided by the efforts component. Because the efforts property is part of the task object, we can simply reuse the <kbd>outUpdateTask</kbd> output to delegate the update. Our container component is already prepared to deal with task updates.</p>
<p>Awesome stuff! We have successfully implemented a no-UI component and used the concept of composition to it's best. You should now be able to preview the changes in your browser and manage efforts on the task details view:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/47a486de-e505-4bcf-a5a8-1565bd0b6aad.png" style=""/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Our new Efforts component that consists of two duration input components</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The visual efforts timeline</h1>
                </header>
            
            <article>
                
<p>Although the components that we have created so far to manage efforts provide a good way to edit and display effort and time durations, we can still improve this with some visual indication.</p>
<p>In this section, we will create a visual efforts timeline using SVG. This timeline should display the following information:</p>
<ul>
<li>The total estimated duration as a grey background bar</li>
<li>The total effective duration as a green bar that overlays on the total estimated duration bar</li>
<li>A yellow bar that shows any overtime (if the effective duration is greater than the estimated duration)</li>
</ul>
<p>The following two figures illustrate the different visual states of our efforts timeline component:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ca97d17f-6145-460b-b300-3596098de1fd.png" style=""/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The visual state if the estimated duration is greater than the effective duration</div>
<p class="mce-root">If a task's effective time will be more than the originally estimated time, we can show that overtime in a different colour:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/0f7283c6-c29b-4f24-9832-0e91848239b2.png" style=""/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">The visual state if the effective duration exceeds the estimated duration (the overtime is displayed as a yellow bar)</div>
<p>Let's start fleshing out our visual timeline component by using Angular CLI to create our component stubs:</p>
<pre><strong>ng generate component --spec false -cd onpush efforts/efforts-timeline</strong></pre>
<p>Alright, let's first look at the component class located in <kbd>src/app/efforts/efforts-timeline/efforts-timeline.component.ts</kbd> and implement the necessary logic to render our SVG timeline:</p>
<pre>import {Component, Input, ViewEncapsulation, ChangeDetectionStrategy, OnChanges, SimpleChanges} from '@angular/core';<br/>import {TimeEfforts} from '../../model';<br/><br/>@Component({<br/>  selector: 'mac-efforts-timeline',<br/>  templateUrl: './efforts-timeline.component.html',<br/>  styleUrls: ['./efforts-timeline.component.css'],<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class EffortsTimelineComponent implements OnChanges {<br/>  @Input() efforts: TimeEfforts;<br/><br/>  done: number;<br/>  overtime: number;<br/><br/>  ngOnChanges(changes: SimpleChanges) {<br/>    this.done = 0;<br/>    this.overtime = 0;<br/><br/>    if (<br/>      !this.efforts.estimated &amp;&amp; this.efforts.effective ||<br/>      (this.efforts.estimated &amp;&amp; this.efforts.estimated === this.efforts.effective)<br/>    ) {<br/>      this.done = 100;<br/>    } else if (this.efforts.estimated &lt; this.efforts.effective) {<br/>      this.done = this.efforts.estimated / this.efforts.effective * 100;<br/>      this.overtime = 100 - this.done;<br/>    } else {<br/>      this.done = this.efforts.effective / this.efforts.estimated * 100;<br/>    }<br/>  }<br/>}</pre>
<p>Our component has only one input. The <kbd>efforts</kbd> input is a <kbd>TimeEfforts</kbd> object which we're supposed to render on a graphical timeline. All the other properties that we need to render our timeline are derived from this efforts object.</p>
<p>In the <kbd>OnChanges</kbd> lifecycle hook, we set two component member fields, which are based on the estimated and effective time:</p>
<ul>
<li><strong>done</strong>: This contains the width of the green bar in percent, which displays the effective duration without overtime that exceeds the estimated duration</li>
<li><strong>overtime</strong>: This contains the width of the yellow bar in percent that displays any overtime, which is any time duration that exceeds the estimated duration</li>
</ul>
<p>Let's look at the template of the efforts timeline component and see how we can now use the <kbd>done</kbd> and <kbd>overtime</kbd> member fields to draw our timeline.</p>
<p>Open the template file located in <kbd><span>src/app/efforts/efforts-timeline/efforts-timeline.component.ts</span></kbd> and apply the following changes:</p>
<pre>&lt;svg width="100%" height="10"&gt;<br/>  &lt;rect height="10"<br/>        x="0" y="0" width="100%"<br/>        class="remaining"&gt;&lt;/rect&gt;<br/>  &lt;rect *ngIf="done" x="0" y="0" [attr.width]="done + '%'" height="10"<br/>        class="done"&gt;&lt;/rect&gt;<br/>  &lt;rect *ngIf="overtime" [attr.x]="done + '%'" y="0"<br/>        [attr.width]="overtime + '%'" height="10"<br/>        class="overtime"&gt;&lt;/rect&gt;<br/>&lt;/svg&gt;</pre>
<p>Our template is SVG-based, and it contains three <span>rectangles for each of the bars that we want to display.</span>  The background bar of our efforts timeline will always be displayed.</p>
<p>Above the remaining bar, we conditionally display the done and the overtime bar using the calculated widths from our component class.</p>
<p>That's all we need for representing our efforts timeline. We can now go ahead and include the efforts timeline component in our efforts component. This way, our users will have visual feedback when they edit the estimated or effective duration, and it provides them with a sense of overview.</p>
<p>Let's open the template of the efforts component, located in <kbd><span>src/app/efforts/efforts/efforts.component.html</span></kbd>, and apply the following changes:</p>
<pre>&lt;div class="label"&gt;Estimated:&lt;/div&gt;<br/>&lt;mac-duration [duration]="efforts?.estimated"<br/>              (outDurationChange)="estimatedChange($event)"&gt;&lt;/mac-duration&gt;<br/>&lt;div class="label"&gt;Effective:&lt;/div&gt;<br/>&lt;mac-duration [duration]="efforts?.effective"<br/>              (outDurationChange)="effectiveChange($event)"&gt;&lt;/mac-duration&gt;<br/>&lt;button class="button small" (click)="addEffectiveHours(1)"&gt;+1h&lt;/button&gt;<br/>&lt;button class="button small" (click)="addEffectiveHours(4)"&gt;+4h&lt;/button&gt;<br/>&lt;button class="button small" (click)="addEffectiveHours(8)"&gt;+1d&lt;/button&gt;<br/><strong>&lt;mac-efforts-timeline *ngIf="efforts"</strong><br/><strong>                      [efforts]="efforts"&gt;</strong><br/><strong>&lt;/mac-efforts-timeline&gt;</strong></pre>
<p>As we have the efforts object readily available in our component, we can simply create a binding to the efforts timeline component <kbd>efforts</kbd> input property.</p>
<p>Congratulations! You've just put the cherry on the cake with this last change. Our users can now not only enter estimations and effective working hours using our efforts component, they also have a visual feedback of time available, spent, and overtime. Spin up the application in your browser and mess around with the new efforts component a bit. I'm sure you'll enjoy the text-based no-UI input elements we've just created. Let's take a look at a screenshot of our efforts timeline in action:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/89446e4a-15ca-42e2-97a5-e838cf2c95ed.png" style=""/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The Efforts component displaying our newly-created efforts timeline component (the overtime of six hours is visualized with the yellow bar)</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recapitulating on efforts management</h1>
                </header>
            
            <article>
                
<p>In this section, we have created components that allow users to manage efforts easily and add a simple but powerful time tracking to our tasks. We've done the following to achieve this:</p>
<ul>
<li>We implemented some utility functions to deal with the time math in order to convert time durations in milliseconds into formatted time durations and vice versa</li>
<li>We created a pipe to format time durations in milliseconds using our utility functions</li>
<li>We created a duration UI component, which wraps an editor component and uses our time utilities to provide a no-UI kind of input element to enter durations</li>
<li>We created an efforts component that acts as a composition of two duration components for estimated and effective time, and provides additional buttons to add effective spent time quickly</li>
<li>We integrated the efforts component into the task details component in order to manage efforts on tasks</li>
<li>We created a visual efforts timeline component using SVG, which displays the overall progress on a task</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we implemented some components that help our users keep track of time. They can now log efforts on tasks and manage milestones on projects. We created a new task detail view that can be accessed using a navigation link on our task list.</p>
<p><span>Isn't it nice how easy it suddenly seems to implement new functionality when using components with proper encapsulation? The great thing about component-oriented development is that your development time for new functionality is decreased with the number of reusable components that you already created.</span></p>
<p>Once more, we experienced the power of composition using components, and reusing existing components, we were able to easily implement higher components that provide more complex functionality.</p>
<p>In the next chapter, we will look at how to use the charting library Chartist and create some wrapper components that allow us to build reusable charts. Additionally, we will build a dashboard for our task management system, where we will see our chart components in action.</p>


            </article>

            
        </section>
    </body></html>