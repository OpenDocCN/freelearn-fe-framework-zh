- en: Using the Vuex Plugin System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, I wrote about the possibility of persisting the *EveryNote*
    application state, using the Vuex plugin system. We also learned about a built-in
    logger plugin to log every mutation. But, what exactly is a Vuex plugin? And how
    can we write a custom plugin?
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following pages, you will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about the Vuex plugin system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add two useful plugins to the *EveryNote* application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a Google Analytics plugin to track user interaction with your app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop an undo/redo plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have Node.js installed on a system. Finally, to use
    the Git repository of this book, the user needs to install Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-6](https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-6)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-6-promises](https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-6-promises)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://goo.gl/aZjE63](https://goo.gl/aZjE63)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Vuex plugin system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Vuex plugin is a function that receives the application store as the only
    argument and can subscribe to mutations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add a plugin to the store as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Like components, plugins cannot directly alter the state; they have to commit
    a mutation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine that we want to show the last time a mutation has been
    committed. We could write a plugin as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Since we can subscribe to every mutation receiving the new state, we could persist
    the application state with `localStorage`. In fact, there is a plugin called `vuex-persistedstate`
    that does exactly that. You can read more about this plugin in the following pages.
  prefs: []
  type: TYPE_NORMAL
- en: Empowering EveryNote with two plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you Google *Vuex plugins,* you may find various plugins for different purposes.
    I selected two that you will probably want to use in your next Vuex project. These
    plugins are:'
  prefs: []
  type: TYPE_NORMAL
- en: vuex-persistedstate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: vuex-router-sync
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to use the first one to save the EveryNote state with `localStorage,`
    so that we don't lose all the notes every time the browser page is reloaded.
  prefs: []
  type: TYPE_NORMAL
- en: It is strongly recommended that you use the second one, vuex-router-sync, if
    you are creating a single-page web application. In this case, you are already
    using vue-router and vuex-router-sync will synchronize the current route, as part
    of Vuex store's state.
  prefs: []
  type: TYPE_NORMAL
- en: Saving the app state with vuex-persistedstate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *EveryNote* application currently shows two fake notes and loses newly created
    notes every time you reload the page. By addingthe`vuex-persistedstate` plugin,
    notes will be saved with `localStorage`.
  prefs: []
  type: TYPE_NORMAL
- en: To add the `vuex-persistedstate` type, enter the following*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we need to add it to the plugins list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to remove the two fake notes from the mock API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: From now on, if you add a note and then reload the page, that note will still
    be there.
  prefs: []
  type: TYPE_NORMAL
- en: '`vuex-persistedstate` is highly configurable and can persist the application
    state to every synchronous storage. For example, you can configure it to use `sessionStorage,`
    instead of `localStorage,`if you want the state to be reset when the application
    page is closed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information at: [https://github.com/robinvdvleuten/vuex-persistedstate](https://github.com/robinvdvleuten/vuex-persistedstate).'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing router data with vuex-router-sync
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are using vue-router in your application, you may also want to use vuex-router-sync
    because, as it says on the plugin website, *it* *syncs vue-router's current $route
    as part of vuex store's state.*
  prefs: []
  type: TYPE_NORMAL
- en: 'To install this plugin, type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To add it to the *EveryNote* app, you need to add vue-router to the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'and modify `src/store/index.js` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'But how does it work? Each time the route changes, this plugin updates the
    `store.state.route` property. This property consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To update the store property, it commits a `route.ROUTE_CHANGED` mutation, where
    `route` is the default name of the module of the vuex-router-syncplugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can change the module name it uses as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In order to programmatically change a route, use vue-router; do not modify `store.state.route`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information at: [https://github.com/vuejs/vuex-router-sync](https://github.com/vuejs/vuex-router-sync).'
  prefs: []
  type: TYPE_NORMAL
- en: In the following pages, we are going to develop a Google Analytics plugin that
    uses vuex-router-sync to send page-views to Google servers.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a Google Analytics plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following pages, I will assume that you are familiar with Google Analytics
    and that you have correctly configured Google Analytics tracking in your application.
    If not, you can Google it, understand how it works, and come back here. A basic
    understanding is more than enough to proceed with the following pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to add this Google Analytics tracking code snippet to the
    `index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: After that, a global `gtag(...)` function will be available to send events to
    Google Analytics servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, an application tracks page views and some events. To send an event
    to Google Analytics servers, it is enough to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the preceding code, we can write a plugin that sends an Analytics event
    for each mutation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In order to send page views, we can exploit the vuex-router-sync`route.ROUTE_CHANGED`
    mutation committed every time the location changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can update the Analytics plugin accordingly, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Where the `analytics` object is something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You probably do not want to send all mutations as analytics events; in that
    case, you can create a map of mutation types that you want to send, or a list
    of mutation types you don't want to be sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the EveryNote code with the Google Analytics plugin by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Developing an undo/redo plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Google Analytics plugin we just coded is a good and simple example of how
    the Vuex plugin system can be exploited to add features to your application, without
    touching the application core code. But what about a more complex plugin? Is the
    Vuex plugin also suited for more complex operations? Well, of course, it is! In
    the following pages, we will develop an undo/redo plugin, which is still a simple,
    but not trivial example.
  prefs: []
  type: TYPE_NORMAL
- en: We can exploit the fact that, in using the Vuex system, we have a single centralized
    state and this state can only be modified by mutations. The idea is to take a
    snapshot of the state each time it gets modified. Then, to go back in the mutation
    history, it is enough to set the current state to a snapshot, representing an
    older state before the mutation occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a plugin that registers a module called `undoRedo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we define two state properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**currentPosition**: This represents the index of the current snapshot. When
    an undo mutation is committed, we decrease the index; when a redo mutation or
    another one is committed, the index is increased.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**snapshots**: This is an array containing state snapshots.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, we need two corresponding mutations to update these properties,
    as well as an `UNDO` and a `REDO` mutation to actually let plugin clients undo
    or redo modifications.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we provide two getters, `canUndo()` and `canRedo(),` to expose the
    undoable/redoable state of the plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now subscribe to mutations to take a snapshot each time the application
    state gets changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Of course, there are mutations that must be excluded, such as mutations of `snapshots`
    or `currentPosition` properties, and mutations that a user of this plugin may
    want to exclude, such as `route/ROUTE_CHANGED` if vuex-router-sync is used in
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now implement the undo/redo mutations as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the preceding code is just about restoring the right snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'When taking a snapshot, not every state property should be considered and each
    snapshot must be a copy of the state. The following code shows these concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can provide a factory method to create and configure the undo/redo
    plugin. The following is the entire plugin code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can download the EveryNote code with the undo/redo plugin, by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Undo/redo, implemented this way, works well with an application that does not
    synchronize its state with a server. Normally, it is not enough to restore the
    previous state, but you need also to perform an action to update the server data.
    For example, if you undo a delete note, you need to send the undeleted note data
    to the remote server. This means that a real undo/redo feature is application-dependent,
    and that the plugin we wrote needs to be extended to also handle synchronization
    with a remote server.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with asynchronicity using promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a real undo/redo plugin you will probably send data to a server, which is
    an asynchronous operation. We understood that asynchronicity must be dealt with
    inside Vuex actions. When you dispatch an action, `store.dispatch('anAction')`,
    the `dispatch` method returns a `Promise`. In the following pages I will explain
    how you can handle asynchronous operations using `Promise`, a relatively new JavaScript
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with asynchronous operations in JavaScript can be tricky. I have seen
    incredibly messy pieces of code just because the programmer didn't know how to
    deal with asynchronous code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The worst way of waiting for a piece of data that will be available later is
    polling. *Never do something like this*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example can be refactored using a callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Callbacks are good for simple operations, but become quickly unmanageable when
    you need to combine more than one callback. Have you ever heard of the phrase
    c*allback hell*?
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, JavaScript now provides `Promise`, a simple way to deal with asynchronous
    operations. Using a `Promise`, the preceding code can be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If you are not familiar with promises, google and study them. The following
    sections will explain how promises can be chained or be executed in parallel,
    which, in my opinion, is still not well understood by programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `store.dispatch('action')` function returns a promise. This allows the programmer
    to wait for an action to be completed before executing another one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example where an action is dispatched after another one is completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `then(callback)` method of a `Promise` returns another `Promise`, which
    will be resolved with the value returned by the callback. If the value returned
    by the callback is itself a `Promise`, it will wait for this second `Promise`
    to be completed. OK, I know—the first time you hear it, this concept sounds a
    bit twisted. I will explain promise concatenation in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: First, the synchronous code gets executed, printing `start` and `end`, and then
    the promise chain gets executed. In the middle step of the chain, a promise that
    is resolved after 1000 ms is returned from the callback. This makes the last `then(...)`
    of the chain wait for the `asyncEcho(...)` promise to be resolved before it can
    execute the last callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Until the chain promises get resolved, the code execution moves from one `then()`
    to the other. But what happens when a promise gets rejected? Let''s see another
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Did you get the right output? Or did you expect to see *Fail 3* after the *Fail
    2* line? That is a common mistake. Only if an error occurs inside a callback or
    a rejected promise is returned is the fail callback of the next step of the chain
    executed. In all other cases, it is the next success callback that gets executed,
    even if the fail callback of the previous step was executing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure explains this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c34ffc1-5a35-4086-84bd-adc5f6e264f1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Chaining promises'
  prefs: []
  type: TYPE_NORMAL
- en: Parallel execution of promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know how to chain promises, we also know how to chain Vuex actions
    since the `store.dispatch(...)` method returns a promise. But what if we want
    to execute two or more actions in parallel and wait for all of the actions to
    be completed? The `Promise` object provides a `Promise.all([p1, p2, ..., pn])`method
    that returns a promise that is either resolved after all the provided promises
    are resolved or that is rejected as soon as one of the provided promises is rejected.
    Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Common mistakes when using promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, let's look at the two common mistakes made when using `Promise`.
  prefs: []
  type: TYPE_NORMAL
- en: The following code shows what happens when a **`Promise`** constructor callback
    is misunderstood**:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The callback function provided to `new Promise(callback)` is executed synchronously.
    If you want to schedule something immediately after the current JavaScript execution
    is completed, use `Promise.resolve().then(callback)` or `setTimeout(callback,
    0)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows what happens when a programmer forgets to return a
    rejected promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'No matter what `Math.random()` returns, the output is always Resolved Fail
    or Resolved Success because the `fail` callback of `buggyToss()` does not throw
    any error or return a rejected promise. The following is the correct version of
    `buggyToss()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we looked at how the Vuex plugin system works, we extended
    the *EveryNote* application with two useful plugins, and we developed two plugins
    from scratch: a Google Analytics plugin and an undo/redo plugin. Furthermore,
    generally, we saw how the Vuex plugin system can be exploited to add general features
    to our application without touching the application''s core code.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally we understood how to deal with asynchronous operations using JavaScript
    `Promise` feature.
  prefs: []
  type: TYPE_NORMAL
