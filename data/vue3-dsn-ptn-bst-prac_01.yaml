- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: The Vue 3 Framework
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue 3 框架
- en: The world wide web of today has changed by many magnitudes since the early days
    when the internet was just a collection of linked pages for academic and scientific
    purposes. As the technology evolved and machines became more powerful, more and
    more features were added to the earlier protocols, and new techniques and technologies
    competed until finally, standards were adopted. Extra functionality came in the
    form of plugins for the browser and embedded content. Java applets, Flash, Macromedia,
    Quicktime, and other plugins were common. It was with the arrival of HTML5 that
    most, if not all, of these were gradually replaced by standards.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与互联网早期只是学术和科学目的的链接页面集合相比，今天的全球互联网已经发生了巨大的变化。随着技术的进步和机器变得更加强大，早期协议中添加了越来越多的功能，新技术和技术竞争，直到最终采用标准。额外的功能以浏览器插件和嵌入式内容的形式出现。Java
    小程序、Flash、Macromedia、Quicktime 以及其他插件都很常见。随着 HTML5 的到来，其中大多数，如果不是全部，都逐渐被标准所取代。
- en: Today, a clear distinction exists between structure, style, and behavior. **Hyper
    Text Markup Language** (**HTML**) defines the structural elements that make up
    a web page. **Cascading Style Sheets** (**CSS**) provides rules that modify the
    appearance of HTML elements, including even animations and transformations. And
    finally, JavaScript is the programming language that provides behavior and can
    access and modify both HTML and CSS. So many different capabilities also introduced
    a high level of *complexity* and incompatibility between browsers. This is where
    libraries and frameworks were born, at first to solve incompatibility issues and
    standardize appearance, but soon evolved to include other programming paradigms
    beyond the simple manipulation of HTML and CSS.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，结构、样式和行为之间存在明确的区分。**超文本标记语言**（**HTML**）定义了构成网页的结构元素。**层叠样式表**（**CSS**）提供规则来修改
    HTML 元素的显示外观，包括动画和转换。最后，JavaScript 是一种编程语言，它提供行为并可以访问和修改 HTML 和 CSS。因此，引入了众多不同的功能，也带来了浏览器之间的高度复杂性和不兼容性。这就是库和框架诞生的原因，最初是为了解决不兼容性问题并标准化外观，但很快演变为包括其他编程范式，而不仅仅是简单的
    HTML 和 CSS 操作。
- en: Some of the most popular libraries and frameworks today use the **reactive paradigm**.
    They cleverly make changes in JavaScript to reflect automatically in the HTML/CSS.
    Vue 3 is the latest version of the progressive framework, which heavily uses the
    concept of reactivity. It also implements other paradigms and patterns of software
    design that allow you to build anything from simple interactions in a static web
    page to complex applications that can even be installed locally and compete with
    native desktop applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当今最流行的库和框架中，一些使用 **响应式范式**。它们巧妙地在 JavaScript 中进行更改，以自动反映在 HTML/CSS 中。Vue 3 是进阶框架的最新版本，它大量使用了响应性的概念。它还实现了其他软件设计范式和模式，允许你从静态网页中的简单交互构建到可以本地安装并可与原生桌面应用程序竞争的复杂应用程序。
- en: 'In this book, we will explore the Vue 3 framework, and study different design
    patterns to help us build first-class applications: from simple web pages to powerful
    **progressive web applications** **(PWAs**). Along the way, we will look at best
    practices and well-proven patterns in software engineering.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将探索 Vue 3 框架，并研究不同的设计模式，以帮助我们构建一流的应用程序：从简单的网页到强大的 **渐进式网络应用程序**（**PWAs**）。在这个过程中，我们将探讨软件工程中的最佳实践和经过验证的模式。
- en: 'This chapter covers the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: The progressive framework
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进阶框架
- en: Single-file components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单文件组件
- en: Different syntax options to write components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的语法选项来编写组件
- en: By the end of this chapter, you will have a basic understanding of where Vue
    3 fits into the JavaScript landscape, and what features it provides. For Vue 2
    users, there is an appendix to this book, with changes needed to be aware of when
    migrating an application. As the book progresses, we will build knowledge on top
    of these concepts.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将基本了解 Vue 3 在 JavaScript 生态系统中的位置以及它提供的功能。对于 Vue 2 用户，本书附录中包含迁移应用程序时需要了解的更改。随着本书的进展，我们将在此基础上构建知识。
- en: The progressive framework
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进阶框架
- en: Before we describe what Vue is, we need to make the distinction between the
    terms *library* and *framework*. These are often used interchangeably, but there
    is a difference, and a good developer should be aware of this when choosing one
    or the other to build a web application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们描述Vue是什么之前，我们需要区分术语**库**和**框架**。这些术语经常被互换使用，但它们之间有一个区别，一个好的开发者应该在选择其中一个来构建Web应用程序时意识到这一点。
- en: 'Let’s have a look at the definitions of these terms:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些术语的定义：
- en: A **library** is a collection of reusable code, in the form of functions, classes,
    and so on, that have been developed by someone else and can be easily imported
    into your program. It does not prescribe how and where to use it, but normally,
    they provide documentation on how to use them. It is up to the programmer to decide
    when and how to implement them. This concept exists in most development languages,
    to the point that some of them are completely based on the notion of importing
    libraries to provide functionality.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图书馆**是一个由他人开发的可重用代码集合，以函数、类等形式存在，可以轻松导入到你的程序中。它并不规定如何以及在哪里使用它，但通常，它们会提供如何使用它们的文档。程序员需要决定何时以及如何实现它们。这个概念存在于大多数开发语言中，以至于其中一些完全基于导入库来提供功能的概念。'
- en: A **framework** also has bundles of classes and functions for your use but prescribes
    specifications that define how the program runs and should be built, with what
    architecture, and the conditions where or how your code can be used. The key attribute
    to consider here is that a framework is inverting the control in the application,
    so it defines the flow of the program and data. By doing so, it emphasizes structures
    or standards that the programmer should abide by.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**框架**也提供了一系列供你使用的类和函数，但规定了定义程序运行和构建方式、架构以及你的代码可以在何种条件下或如何使用的规范。这里要考虑的关键属性是，框架在应用程序中反转了控制权，因此它定义了程序的流程和数据。通过这样做，它强调了程序员应该遵守的结构或标准。'
- en: 'Having separated the concepts, now it raises the question of when to use a
    library and when to use a framework. Before answering that, let’s be clear that
    there is a huge gray area between these two when building real-life applications.
    In theory, you could build the same application using either one. As always in
    software engineering, it is a matter of deciding upon the trade-offs for each
    approach. So, take what comes next with a pinch of salt; it''s not a law written
    in stone:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在区分了这些概念之后，现在提出了一个问题：何时使用库，何时使用框架。在回答这个问题之前，让我们明确，在构建实际应用程序时，这两者之间有一个巨大的灰色区域。从理论上讲，你可以使用任何一个来构建相同的应用程序。像软件工程中的所有事情一样，这是一个决定每种方法权衡的问题。所以，带着一点盐来接受接下来的内容；这不是刻在石头上的法律：
- en: You may want to use a *library* when building small to medium-sized applications,
    or when in need to add additional functionality to your application (in general,
    you can use additional libraries inside frameworks). There are also exceptions
    to the “size” guideline. For example, **React** is a library, but there are huge
    applications built on top of it, such as Facebook. A trade-off to consider is
    that using only libraries without a framework will need establishing common approaches
    and more coordination within a team, so management and direction efforts can grow
    significantly. On the other hand, a library used inside plain JavaScript programming
    can offer some important performance improvements and give you considerable flexibility.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当构建小型到中型应用程序或需要向应用程序添加额外功能时（通常，你可以在框架内部使用额外的库），你可能想使用**库**。也有一些“大小”指南的例外。例如，**React**是一个库，但基于它构建了巨大的应用程序，如Facebook。需要考虑的一个权衡是，仅使用库而不使用框架将需要建立团队内的共同方法和更多协调，因此管理和方向的努力可以显著增加。另一方面，在纯JavaScript编程中使用库可以提供一些重要的性能改进，并给你带来相当大的灵活性。
- en: 'You may want to use a *framework* when you build medium to large-sized applications,
    when you need a structure to help you coordinate the development, or when you
    want to have a quick start skipping the “basics” of developing common functionality
    from scratch. There are frameworks that are built on top of other frameworks,
    for example, **Nuxt** is built on top of **Vue**. The trade-off to consider is
    that you are prescribed an architecture model to build the application, which
    often follows a particular approach and way of thinking. You and your team will
    have to learn about the framework and its limits and live within those boundaries.
    There is always the chance that your application may outgrow the framework in
    the future. At the same time, some of the benefits are as follows: easier coordination
    of work, considerable gains from a head-start, common problems solved true and
    tested, focus on situations (think shopping applications versus social media,
    for example), and much more. Depending on the framework, however, you could be
    facing some small performance loss by the extra processing it takes or difficulties
    scaling up. It is up to you to weigh up the trade-offs for each case.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你构建中到大型应用程序时，你可能需要使用一个*框架*，当你需要一个结构来帮助你协调开发，或者当你想要快速入门而跳过从头开始开发常见功能的基础。有些框架是建立在其他框架之上的，例如，**Nuxt**是建立在**Vue**之上的。需要考虑的权衡是，你被指定了一个架构模型来构建应用程序，这通常遵循特定的方法和思维方式。你和你的团队将不得不学习框架及其限制，并在这个范围内工作。总有可能你的应用程序在未来会超出框架的范围。同时，一些好处如下：更容易协调工作，从先发优势中获得相当大的收益，真正解决并经过测试的常见问题，专注于特定情况（例如，考虑购物应用与社交媒体之间的差异），等等。然而，根据框架的不同，你可能会因为额外的处理而面临一些小的性能损失或扩展困难。权衡每种情况的利弊取决于你。
- en: So, what is Vue then? By definition, *Vue is a progressive framework* for building
    user interfaces. Being progressive means that it has the architectural benefits
    of a framework, but also the speed and modular advantages of a library, as features
    and functionality can be incrementally implemented. In practice, this means that
    it prescribes certain models to build your application, but at the same time,
    allows you to start small and grow as much as you need. You can even use multiple
    Vue applications on a single page or take over the entire application. You can
    even import and use other libraries and frameworks if needed. Quite fancy!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Vue究竟是什么呢？根据定义，*Vue是一个渐进式框架*，用于构建用户界面。渐进式意味着它具有框架的架构优势，同时也具有库的速度和模块化优势，因为特性和功能可以增量实现。在实践中，这意味着它规定了构建应用程序的某些模型，但同时也允许你从小规模开始，并根据需要扩展。你甚至可以在单个页面上使用多个Vue应用程序，或者接管整个应用程序。如果需要，你甚至可以导入和使用其他库和框架。相当复杂！
- en: Another fundamental concept in Vue is that of **reactivity**. It refers to the
    capacity of automatically displaying in the HTML the value or changes made to
    a variable in JavaScript, but also within your code. This is a big part of the
    magic offered by Vue.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Vue的另一个基本概念是**响应性**。它指的是自动在HTML中显示JavaScript中变量值或变化的能力，但也包括在你的代码中。这是Vue提供的魔法的一部分。
- en: 'In traditional programming, once a variable is assigned a value, it holds true
    until programmatically changed. However, in reactive programming, if a variable’s
    value depends on other variables, then when one of those dependencies changes,
    it will take the new resulting value. Take, for example, the following simple
    formula:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统编程中，一旦变量被分配了一个值，它就会保持这个值直到程序性地改变。然而，在响应式编程中，如果一个变量的值依赖于其他变量，那么当这些依赖项中的任何一个发生变化时，它将采用新的结果值。以下是一个简单的公式为例：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In reactive programming, every time `B` or `C` changes value, so will `A`. As
    you will see later in this book, this is a very powerful model to build user interfaces.
    In this example, and to be according to the terminology, `A` is the dependent,
    and `B` and `C` are the dependencies.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式编程中，每当`B`或`C`的值发生变化时，`A`也会发生变化。正如你将在本书后面看到的，这是一个构建用户界面的非常强大的模型。在这个例子中，并且为了符合术语，`A`是依赖项，而`B`和`C`是依赖项。
- en: In the coming chapters, we will explore this *progressive* attribute as we build
    the example applications. But before that, we need to see what Vue 3 offers in
    its most basic form.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将随着构建示例应用程序来探索这个*渐进式*属性。但在那之前，我们需要看看Vue 3在其最基本形式下提供了什么。
- en: Using Vue in your web application
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的Web应用程序中使用Vue
- en: 'There are several options to use Vue in your web application, and it largely
    depends on what your objective is:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Web应用中使用Vue有几种选择，这很大程度上取决于你的目标：
- en: To include a small self-contained application or piece of code on a page, you
    can directly import Vue and code inside a script tag
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在页面上包含一个小型自包含的应用或代码片段，你可以直接在脚本标签中导入Vue和代码
- en: To build a larger application, you will need a build tool that takes your code
    and *bundles* it for distribution
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要构建一个更大的应用，你需要一个构建工具，它将你的代码打包以进行分发
- en: Notice that I use the word *bundle* and not *compile*, as JavaScript applications
    are interpreted and executed at runtime on the browser. This will become apparent
    later on when we introduce the concept of **single-file components**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我使用的是“打包”这个词，而不是“编译”，因为JavaScript应用是在浏览器上运行时解释和执行的。这一点将在我们介绍**单文件组件**的概念时变得明显。
- en: 'Let’s briefly see an example of the first case in a very simple HTML page:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地看看一个非常简单的HTML页面中的第一个案例示例：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `head` section, we define a `script` tag and import Vue from a free
    `Vue`, which exposes all the methods and functions of the framework. Inside our
    `body` tag, we declare a `div` element with `id="app"`. This defines where our
    small application will be mounted and what part of the page our Vue framework
    will control. Notice the content of `div: {{message}}`. The double curly brackets
    define a point where the content will be replaced at runtime by the value of the
    `message` variable that we define in JavaScript. This is called **interpolation**
    and is the primary way in which a value (string, number, etc.) can be displayed
    on the web page.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '在`head`部分，我们定义一个`script`标签并从免费的`Vue`导入Vue，它暴露了框架的所有方法和函数。在我们的`body`标签内部，我们声明一个具有`id="app"`的`div`元素。这定义了我们的小型应用将被挂载的位置以及我们的Vue框架将控制的页面部分。请注意`div:
    {{message}}`的内容。双大括号定义了一个在运行时将被`message`变量的值替换的内容点，该变量我们在JavaScript中定义。这被称为**插值**，是值（字符串、数字等）在网页上显示的主要方式。'
- en: By the end of `body`, we create a script element with our application. We start
    by extracting the `createApp` function from Vue and use it to create an application
    by passing an object. This object has specific fields that define a `data()` method
    that, in turn, returns an object. The field names in this object will be treated
    as reactive variables that we can use in our JavaScript as well as in the HTML.
    Finally, the `createApp()` constructor returns the Vue 3 application instance,
    so we chain the invocation and call the `mount()` method to, well, mount our humble
    application to the element with the `app` ID. Notice that we are using CSS selectors
    as the argument (the pound sign indicates the `id` property, hence `id="app"`
    is selected by `#app`).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到了`body`的结尾，我们创建了一个包含我们应用的脚本元素。我们首先从Vue中提取`createApp`函数，并通过传递一个对象来使用它创建一个应用。这个对象有特定的字段，定义了一个`data()`方法，该方法反过来返回一个对象。这个对象中的字段名将被视为响应式变量，我们可以在JavaScript以及HTML中使用它们。最后，`createApp()`构造函数返回Vue
    3应用实例，因此我们链式调用并调用`mount()`方法，将我们谦逊的应用挂载到具有`app` ID的元素上。请注意，我们使用CSS选择器作为参数（井号表示`id`属性，因此`id="app"`通过`#app`被选中）。
- en: As this method of using Vue is not that common (or popular), we will focus on
    greater things and will use a **bundler** to organize our workflow and have a
    significantly better developer experience...but first, we need to know a bit more
    about Vue and what makes it so great.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种使用Vue的方法并不常见（或流行），我们将关注更重要的事情，并使用**打包器**来组织我们的工作流程，并拥有显著更好的开发者体验……但首先，我们需要了解更多关于Vue以及是什么让它如此出色的信息。
- en: The bundler way, a better way...
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打包器的方式，更好的方式...
- en: As you can imagine, importing Vue directly into a web page would only work for
    very small applications. Instead, Vue is structured in the concept of *components*,
    which are reusable isolated sets of JavaScript code, HTML, and CSS that behave
    as a unit. You can think of them as building blocks to compose a web page. Obviously,
    a browser knows nothing about this so we will use a *bundler* to transform our
    application into something the browser can interpret, with the added benefit of
    running a number of optimizations in the process. Here is where the “framework”
    part comes into action, as it prescribes how these components should be written
    and what methods need to contain.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，直接将Vue导入到网页中只会适用于非常小的应用程序。相反，Vue以*组件*的概念构建，这些是可重用的、隔离的JavaScript代码、HTML和CSS集合，它们作为一个单元运行。你可以把它们看作是构建网页的构建块。显然，浏览器对此一无所知，因此我们将使用*打包器*将我们的应用程序转换成浏览器可以解释的格式，同时在这个过程中还可以运行一系列优化。这就是“框架”部分开始发挥作用的地方，因为它规定了这些组件应该如何编写以及需要包含哪些方法。
- en: 'When using a bundler, it will wrap up all of our code into one or more JavaScript
    files that the browser will load at runtime. The execution workflow in a browser
    for a Vue application could be simplified as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用打包器时，它将把我们的所有代码打包成一个或多个浏览器在运行时加载的JavaScript文件。Vue应用程序在浏览器中的执行工作流程可以简化如下：
- en: '![Figure 1.1: A very simplified view of our application execution order when
    using a bundler](img/Figure_1.01_B18602.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1：使用打包器时我们应用程序执行顺序的非常简化的视图](img/Figure_1.01_B18602.jpg)'
- en: 'Figure 1.1: A very simplified view of our application execution order when
    using a bundler'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：使用打包器时我们应用程序执行顺序的非常简化的视图
- en: 'The browser will load the `index.html` page as usual and then load and execute
    the `bundle.js` file, just like any other JavaScript. The bundler will have packaged
    all our files and execute them in a prescribed order:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器将像往常一样加载`index.html`页面，然后加载并执行`bundle.js`文件，就像任何其他JavaScript文件一样。打包器将打包所有我们的文件，并按规定的顺序执行它们：
- en: The `main.js` file will import and launch the Vue 3 application.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main.js`文件将导入并启动Vue 3应用程序。'
- en: Then, it will start the page composition from the *main* component, here encapsulated
    in the `App.vue` file. This component will spawn other components, thus forming
    a tree of components that make up the page.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它将从*主*组件开始页面组合，这里封装在`App.vue`文件中。这个组件将生成其他组件，从而形成一个构成页面的组件树。
- en: Don’t worry if this sounds a bit strange right now. We will see these concepts
    in action as we advance building our example applications throughout the book.
    In [*Chapter 3*](B18602_03.xhtml#_idTextAnchor079), *Setting Up a Working Project*,
    we will start a simple application using this same diagram.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在听起来有点奇怪，请不要担心。随着我们在书中构建示例应用程序的进展，我们将看到这些概念的实际应用。在[*第3章*](B18602_03.xhtml#_idTextAnchor079)
    *设置工作项目*中，我们将使用这个相同的图表开始一个简单的应用程序。
- en: So far, you have had a view of what libraries and frameworks are, and just a
    quick peek into what Vue has to offer. What is important to remember is that in
    the modern JavaScript world, it is common to use bundlers to help us organize
    our applications and optimize the code for the browser. We will work with the
    official Vue 3 bundler, **Vite**, later on. But first, we need a few more basic
    concepts.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经对库和框架有了了解，并且对Vue能提供的内容有了一个快速的浏览。重要的是要记住，在现代JavaScript世界中，使用打包器来帮助我们组织应用程序并对浏览器代码进行优化是很常见的。稍后我们将使用官方的Vue
    3打包器**Vite**。但首先，我们需要一些更多的基础概念。
- en: Understanding single-file components
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解单文件组件
- en: As you may have guessed, the `App.vue` file mentioned before is a `App.vue`)
    down to the last customized button, if you will. We will discuss components in
    depth in [*Chapter 4*](B18602_04.xhtml#_idTextAnchor102), *User Interface Composition
    with Components*, but for now, keep in mind that this is the way to go, as prescribed
    by the framework. If you have experience in an object-oriented language, this
    may look familiar (and you wouldn’t be wrong).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，之前提到的`App.vue`文件是一个从`App.vue`到最后的自定义按钮的组件，如果你愿意的话。我们将在[*第4章*](B18602_04.xhtml#_idTextAnchor102)中深入讨论组件，即*组件的用户界面组合*，但就目前而言，请记住这是框架规定的做法。如果你有面向对象语言的经验，这可能会看起来很熟悉（而且你不会错）。
- en: 'An SFC is a plain text file with the `.vue` extension that contains the following
    sections:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: SFC是一个带有`.vue`扩展名的纯文本文件，包含以下部分：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It may look strange at first, to have all this content in one place, but this
    is actually what makes it great. Here is a description of each section:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最初看起来可能有些奇怪，所有这些内容都集中在一个地方，但实际上这正是它的优点所在。以下是每个部分的描述：
- en: A `setup`. This will define the application interface that we are going to use
    to write our code in Vue. We could also declare the `lang="ts"` attribute to use
    TypeScript instead of plain JavaScript.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`setup`。这将定义我们将用于在Vue中编写代码的应用程序接口。我们还可以声明`lang="ts"`属性来使用TypeScript而不是纯JavaScript。
- en: A **template** tag surrounds the HTML for our component. Here, we can use HTML
    elements, other components, directives, and so on. A great advantage of Vue is
    that we can use plain HTML to write our HTML. This may sound obvious, but other
    libraries handle this completely differently and have their own syntax for it.
    However, Vue 3 also allows the use of other syntaxes through the use of bundler
    plugins. We are not left out of options here.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**template**标签包围着我们的组件的HTML。在这里，我们可以使用HTML元素、其他组件、指令等等。Vue的一个巨大优势是我们可以使用纯HTML来编写我们的HTML。这听起来可能很显然，但其他库处理这个问题完全不同，并且有自己的语法。然而，Vue
    3也允许通过使用打包器插件来使用其他语法。我们在这里也有选择。
- en: A `scoped` attribute, which will encapsulate the rules and limit them to our
    component, thus preventing them from “bleeding out” to the rest of the application.
    In the same way as with previous sections, we can also use different syntax to
    write the styles, as long as it is supported by the bundler.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`scoped`属性，它将封装规则并限制它们只应用于我们的组件，从而防止它们“溢出”到应用程序的其他部分。与前面的部分一样，我们也可以使用不同的语法来编写样式，只要它被打包器支持。
- en: Best practice
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Always scope your styles, unless you are defining styles on a parent component
    or CSS variables that you want explicitly to be passed on to the entire application.
    For application-wide styles, use a separate CSS file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 总是作用域你的样式，除非你在父组件上定义样式或你希望明确传递到整个应用程序的CSS变量。对于应用程序范围的样式，请使用单独的CSS文件。
- en: The important concept to remember is that an SFC contains these three elements
    that define a single component. The bundler application will do its magic and
    separate each part and place it where it belongs, so the browser can interpret
    them properly. We will use the fast and new **Vite** for this in [*Chapter 3*](B18602_03.xhtml#_idTextAnchor079),
    *Setting Up a Working Project*, and in [*Chapter 4*](B18602_04.xhtml#_idTextAnchor102),
    *User Interface Composition with Components*, we will delve in-depth into components
    and how to handle the flow of control and information between them. But first,
    let’s take a look at how we write our components.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的重要概念是，一个SFC包含这三个定义单个组件的元素。打包器应用程序将施展其魔法，将每个部分分离并放置在适当的位置，以便浏览器可以正确地解释它们。我们将在[*第3章*](B18602_03.xhtml#_idTextAnchor079)“设置工作项目”和[*第4章*](B18602_04.xhtml#_idTextAnchor102)“组件的用户界面组合”中使用快速且新的**Vite**，深入探讨组件以及如何在它们之间处理控制流和信息流。但首先，让我们看看我们如何编写我们的组件。
- en: Different strokes – options, composition, and script setup API
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的笔触——选项、组合和脚本设置API
- en: The classical way to describe a component in Vue 2 has been branded as the *Options
    API*. To maintain backward compatibility, the same syntax is also supported in
    Vue 3\. However, there is also a new syntax named the *Composition API*, which
    is what we will use in this book.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue 2中描述组件的经典方式已被标记为*Options API*。为了保持向后兼容性，Vue 3也支持相同的语法。然而，还有一个名为*Composition
    API*的新语法，这是我们将在本书中使用的。
- en: 'The *Options API* is inherited from Vue 2 and prescribes that a component is
    defined by an object with defined fields, none of which is actually mandatory.
    Moreover, some of them have defined parameters and expected outputs. For example,
    these are the most common fields to use (also, a non-exclusive list):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*Options API*是从Vue 2继承的，规定一个组件由一个具有定义字段的对象定义，其中没有任何字段是强制性的。此外，其中一些具有定义的参数和预期输出。例如，这些是最常用的字段（也是一个非排他性列表）：'
- en: '`data` should be a function that returns an object whose fields would become
    reactive variables.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`应该是一个返回对象的函数，其字段将成为响应式变量。'
- en: '`methods` is an object that contains our functions. These functions have access
    to the reactive variables from data by using the `this.variableName` format.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`methods`是一个包含我们的函数的对象。这些函数可以通过使用`this.variableName`格式访问`data`中的响应式变量。'
- en: '`components` is an object where each field provides a name for the template,
    and the value points to the constructor of another component (child to the current
    one).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`components` 是一个对象，其中每个字段提供了一个模板的名称，值指向另一个组件（当前组件的子组件）的构造函数。'
- en: '`computed` is an object whose attributes define “computed” properties. Each
    member is then a function or an object that can be used as reactive variables
    in our template and code. Functions will be read-only, and objects could include
    logic to read and write values to them. This concept will be clarified as we see
    code examples in [*Chapter 3*](B18602_03.xhtml#_idTextAnchor079), *Setting Up
    a* *Working Project*.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`computed` 是一个对象，其属性定义了“计算”属性。每个成员随后是一个函数或对象，可以用作模板和代码中的响应式变量。函数将是只读的，对象可以包含读取和写入它们值的逻辑。这个概念将在我们查看[*第
    3 章*](B18602_03.xhtml#_idTextAnchor079)的*设置工作项目*中的代码示例时得到阐明。'
- en: '`props` and `emits` declare parameters to receive data from the parent component
    and declare events that get dispatched to the parent component. This provides
    a formal way to communicate and pass data between related components, but is not
    the only one, as we will see in [*Chapter 7*](B18602_07.xhtml#_idTextAnchor173),
    *Data* *Flow Management*.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`props` 和 `emits` 声明参数以从父组件接收数据，并声明发送到父组件的事件。这为在相关组件之间进行通信和传递数据提供了一种正式的方式，但并非唯一，正如我们将在[*第
    7 章*](B18602_07.xhtml#_idTextAnchor173)的*数据流管理*中看到的。'
- en: Life cycle hooks methods are a series of functions that are triggered during
    the life cycle of the component.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命周期钩子方法是一系列在组件生命周期中触发的函数。
- en: Mixins are objects that describe a common functionality that could be shared
    across multiple components. This is not the only way to reuse code in Vue 3\.
    The use of mixins in the Options API caused some complications that gave birth
    to the Composition API. We will not deal with mixins in detail, but will see other
    approaches to share functionality between components (such as “composables”).
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合是一种对象，它描述了可以在多个组件之间共享的通用功能。这并不是在 Vue 3 中重用代码的唯一方式。在 Options API 中使用混合引起了一些复杂性，从而产生了
    Composition API。我们不会详细讨论混合，但会看到其他在组件之间共享功能的方法（例如“composables”）。
- en: This syntax is well-defined but has some limitations. For small components,
    it is too much scaffolding code, and for large components, the code organization
    suffers greatly and is very verbose. Plus, in order to reference the reactive
    variables declared in the `data` section or other methods, the internal code has
    to use the `this` keyword (e.g., `this.data_variable_name` or `this.myMethod()`).
    The `this` keyword refers to the created instance of the component. The problem
    is when the reserved word `this` changes meaning depending on the scope and context
    of use. There are other drawbacks that have appeared over time that led to the
    creation of the Composition API. However, this syntax is relevant and fully supported
    by Vue 3\. One advantage of this is that you can easily migrate code from Vue
    2 (within certain considerations, as shown later in the *Appendix – Migrating
    from* *Vue 2*).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法定义良好，但有一些限制。对于小型组件，它提供了过多的脚手架代码，而对于大型组件，代码组织受到严重影响，且非常冗长。此外，为了引用在 `data`
    部分或其他方法中声明的响应式变量，内部代码必须使用 `this` 关键字（例如，`this.data_variable_name` 或 `this.myMethod()`）。`this`
    关键字指的是组件创建的实例。问题是当保留字 `this` 的含义根据使用范围和上下文而变化时。随着时间的推移，出现了其他缺点，导致了组合式 API 的创建。然而，这种语法在
    Vue 3 中是相关且完全支持的。这个优点之一是你可以轻松地将代码从 Vue 2 迁移过来（在附录中稍后展示的某些考虑范围内，如*附录 - 从 Vue 2
    迁移*）。
- en: The Composition API exposes a method called `Setup()` that is executed before
    the component is mounted. In this method, we import functions and components,
    declare variables, and so on, that define our component instead of declaring them
    as “options.” This means that you can write your code in more of a JavaScript
    way This gives you the freedom to import, reuse, and organize your code better.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 组合式 API 提供了一个名为 `Setup()` 的方法，它在组件挂载之前执行。在这个方法中，我们导入函数和组件，声明变量等，这些定义了我们的组件，而不是将它们声明为“选项”。这意味着你可以用更
    JavaScript 的方式编写代码，这给了你更好的导入、重用和组织代码的自由。
- en: 'Let’s see a comparison between the two approaches with a reactive variable,`_hello="Hello
    World"`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个反应变量`_hello="Hello World"`来比较这两种方法：
- en: '**Options API**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**选项式 API**'
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Composition API**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**组合式 API**'
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the Options API, we just use the `data` field to return an object whose fields
    will turn into reactive variables. Vue will take care of interpreting the object.
    However, notice how, in the Composition API, we need to first import from Vue
    the `ref` constructor, which will create a reactive constant or variable for us.
    The end result is the same, but here, we have more fine control over what is done
    and where. When using the new Vite bundler, this fine control of what gets imported
    into our components may result in faster code building and development times.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在选项API中，我们只是使用`data`字段来返回一个对象，其字段将变成响应式变量。Vue将负责解释这个对象。然而，请注意，在组合式API中，我们首先需要从Vue导入`ref`构造函数，这将为我们创建一个响应式常量或变量。最终结果是一样的，但在这里，我们对自己的操作和位置有更多的精细控制。当使用新的Vite打包器时，这种对组件中导入内容的精细控制可能会导致代码构建和开发时间的加快。
- en: 'At first sight, it seems that the Composition API is more verbose than the
    Options API, and so it is for such a trivial example. However, as our component
    begins to grow, this becomes the opposite. Still, verbose... So, there is an alternative
    syntax for the Composition API called *script setup*, and is the one we will use
    in this book. Let’s compare now how this component looks with this new syntax:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，似乎组合式API比选项API更冗长，对于这样一个简单的例子确实如此。然而，随着我们的组件开始增长，这种状况就相反了。尽管如此，仍然很冗长...所以，组合式API有一个名为*脚本设置*的替代语法，这是我们将在本书中使用的语法。现在让我们比较一下使用这种新语法时组件的外观：
- en: '**Composition API –** **script setup**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**组合式API –** **脚本设置**'
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Two lines of code! That is hard to beat. Because we added the `setup` attribute
    in the `script` tag, the bundler knows everything we do here is in the realm of
    the Composition API, and all the functions, variables, and constants are automatically
    exposed to the template. There''s no need to define exports. If we need something,
    we import it directly and use it. Also, we now have a few extra advantages, such
    as the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅两行代码！这很难超越。因为我们添加了`setup`属性到`script`标签中，打包器就知道我们在这里所做的所有事情都属于组合式API的范畴，所有的函数、变量和常量都会自动暴露给模板。不需要定义导出。如果我们需要什么，我们可以直接导入并使用它。此外，我们现在还有一些额外的优势，如下所示：
- en: We can have reactive and non-reactive variables displayed in our template
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在模板中显示响应式和非响应式变量
- en: We know that all the code is executed before the component is mounted
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们知道所有代码都是在组件挂载之前执行的
- en: The syntax is closer to vanilla JavaScript (a big plus!!!), so we can organize
    our code to our convenience and pleasure
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法更接近vanilla JavaScript（一个很大的优点！！！），因此我们可以根据我们的方便和愉悦来组织代码
- en: Smaller bundle size (did I mention this before? Yes, it is important!)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更小的包大小（我之前提到过吗？是的，这很重要！）
- en: 'But wait, you may notice that I’m defining a reactive variable as a *constant*!
    Yes, I am! And no, it is not an error. In JavaScript, a constant points to a particular
    immutable value, which, in this case, is an object, but this applies only to the
    object, not to its members. The `ref()` constructor returns an object, so the
    constant applies to the object reference and we *can* change the value of its
    members. If you have worked with pointers in Java, C, or a similar language, you
    may recognize this concept as the use of `value` attribute from the object. Here
    is an example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等，你可能注意到我把一个响应式变量定义为一个*常量*！是的，我是这样做的！而且，不，这并不是一个错误。在JavaScript中，常量指向一个特定的不可变值，在这个例子中，是一个对象，但这个规则只适用于对象，不适用于它的成员。`ref()`构造函数返回一个对象，因此常量适用于对象引用，我们可以改变其成员的值。如果你在Java、C或类似的语言中处理过指针，你可能认识这个概念，即使用对象的`value`属性。以下是一个例子：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'But, at the same time, nothing has changed in the way to access this variable
    in the template:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，与此同时，访问这个变量在模板中的方式并没有改变：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So, in brief, every time a variable is declared as reactive using the `ref()`
    constructor, you need to reference its value with the `constant_name.value` format,
    and just as `constant_name` in the template (HTML). When the constant name is
    used in the template, Vue already knows how to access the value and you don’t
    need to reference it explicitly as in JavaScript.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，每次使用`ref()`构造函数将变量声明为响应式时，你需要使用`constant_name.value`格式来引用其值，就像模板（HTML）中的`constant_name`一样。当在模板中使用常量名称时，Vue已经知道如何访问该值，你不需要像在JavaScript中那样显式地引用它。
- en: Tip
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 小提示
- en: Adopt a code convention so you’ll know when an identifier refers to a variable,
    constant, function, class, and so on.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 采用代码约定，这样你就可以知道标识符是指变量、常量、函数、类等等
- en: Exploring built-in directives in Vue 3
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Vue 3的内置指令
- en: 'Vue also provides special HTML attributes called `v-`. As for the purpose of
    this book, let’s explain the most commonly used Vue directives:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 还提供了称为 `v-` 的特殊 HTML 属性。对于本书的目的，让我们解释最常用的 Vue 指令：
- en: 'v-bind: (shorthand ":")'
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'v-bind: (缩写 ":")'
- en: 'The `v-bind:` directive binds the value of an HTML attribute to the value of
    a JavaScript variable. If the variable is reactive, each time it updates its value,
    it will be reflected in the html. If the variable is not reactive, it will be
    used only once during the initial rendering of the HTML. Most often, we use only
    the `:` shorthand prefix (semi-colon). For example, the `my_profile_picture` reactive
    variable contains a web address to a picture:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-bind:` 指令将 HTML 属性的值绑定到 JavaScript 变量的值。如果变量是响应式的，每次它更新其值时，它都会反映在 HTML 中。如果变量不是响应式的，它将仅在
    HTML 的初始渲染期间使用一次。我们通常只使用 `:` 缩写前缀（分号）。例如，`my_profile_picture` 响应式变量包含一个指向图片的网址：'
- en: '`<``img :src="img/my_profile_picture">`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`<``img :src="img/my_profile_picture">`'
- en: The `src` attribute will receive the value of the `my_profile_picture` variable.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`src` 属性将接收 `my_profile_picture` 变量的值。'
- en: v-show
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: v-show
- en: 'This directive will show or hide the element, without removing it from the
    document. It is equivalent to modifying the CSS `display` attribute. It expects
    a variable that gives a Boolean value (or something that can be interpreted as
    true or non-empty). For example, the `loading` variable has a Boolean value:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令将显示或隐藏元素，而不会将其从文档中移除。它相当于修改 CSS 的 `display` 属性。它期望一个提供布尔值的变量（或可以解释为真或非空的东西）。例如，`loading`
    变量有一个布尔值：
- en: '`<``div v-show="loading">…</div>`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`<``div v-show="loading">…</div>`'
- en: The `div` will appear when the `loading` variable is true.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `loading` 变量为真时，`div` 将会显示。
- en: It is important to keep in mind that `v-show` will use the style of the object
    to display it or not, but the element will still be part of the **Document Object**
    **Model** (**DOM**).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，`v-show` 将使用对象的样式来显示或隐藏它，但元素仍然是 **文档对象模型**（**DOM**）的一部分。
- en: v-if, v-else, and v-else-if
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: v-if, v-else, 和 v-else-if
- en: These directives behave as you would expect with conditional sentences in JavaScript,
    showing and hiding the element based on the value resolved by the expression passed.
    They are similar to `v-show` in the sense that they will show or hide the element,
    but with the difference that they remove completely the element from the DOM.
    Because of this, it can be expensive computationally if used improperly at a large
    scale with elements that switch their state often, as the framework has to perform
    more operations to manipulate the DOM, as opposed to `v-show`, when only the display
    style needs to change.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令的行为与 JavaScript 中的条件语句预期一致，根据传递的表达式解析的值显示或隐藏元素。在它们将元素显示或隐藏的意义上，与 `v-show`
    类似，但不同之处在于它们会完全从 DOM 中移除元素。因此，如果在大规模上不正确地使用经常切换状态的元素，这可能会在计算上非常昂贵，因为框架必须执行更多操作来操作
    DOM，而与 `v-show` 不同，当只需要更改显示样式时。
- en: Note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Use `v-if` to show or display elements that will not toggle once shown or hidden
    (and preferred when the initial state is hidden). Use `v-show` if an element will
    switch states often. This will improve the performance when displaying large lists
    of elements.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `v-if` 来显示或显示那些一旦显示或隐藏后不会切换的元素（并且在初始状态为隐藏时首选）。如果元素将经常切换状态，请使用 `v-show`。这将提高显示大量元素时的性能。
- en: v-for and :key
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: v-for 和 :key
- en: 'These two attributes, when combined, behave like a `for` loop in JavaScript.
    They will create as many copies of the element as prescribed in the iterator,
    each one with the corresponding interpolated value. It is extremely useful to
    display collections of data items. The `:key` attribute is used internally to
    keep track of changes more efficiently, and must reference a unique attribute
    of the item being looped on – for example, the `id` field of an object, or the
    index in an array when the indexes won‘t change. Here is an example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个属性结合使用时，在 JavaScript 中表现得像 `for` 循环。它们将根据迭代器中指定的数量创建元素副本，每个副本都有相应的插值值。这对于显示数据项集合非常有用。`:key`
    属性在内部用于更有效地跟踪变化，并且必须引用正在迭代的项的唯一属性——例如，对象的 `id` 字段，或者当索引不会改变时数组中的索引。以下是一个示例：
- en: '`<span v-for="i in 5" :key="i"> {{``i}} </span>`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`<span v-for="i in 5" :key="i"> {{``i}} </span>`'
- en: 'This will display five `span` elements on the web page with the interpolation
    of `i` showing the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在网页上显示五个 `span` 元素，`i` 的插值显示以下内容：
- en: '`1 2 3 4 5`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`1 2 3 4 5`'
- en: v-model
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: v-model
- en: 'This directive is pure magic. When attached to an input element (input, textarea,
    select, etc.), it will assign the value returned by the HTML element to the referenced
    variable, thus keeping the DOM and JavaScript state in synchronization – something
    that is called **two-way binding**. Here is an example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令简直就是魔法。当它附加到输入元素（input、textarea、select等）上时，它将把HTML元素返回的值赋给引用的变量，从而保持DOM和JavaScript状态的一致性——这被称为**双向绑定**。以下是一个示例：
- en: '`<input` `type="text" v-model="name">`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`<input type="text" v-model="name">`'
- en: When the user enters text in HTML, the `"name"` variable in JavaScript will
    immediately have that value assigned. In these examples, we are using primitive
    data types such as numbers and strings, but we can also use more complex values
    such as objects or arrays. More of this will come in [*Chapter 4*](B18602_04.xhtml#_idTextAnchor102),
    *User Interface Composition with Components*, when we see components in depth.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在HTML中输入文本时，JavaScript中的`"name"`变量将立即被赋予该值。在这些示例中，我们使用的是原始数据类型，如数字和字符串，但我们也可以使用更复杂的数据类型，如对象或数组。更多内容将在[*第4章*](B18602_04.xhtml#_idTextAnchor102)中介绍，即使用组件进行用户界面组合，届时我们将深入探讨组件。
- en: 'v-on: (and the shorthand @)'
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: v-on:（以及缩写@）
- en: 'This directive behaves a bit differently than the ones seen before. It expects
    not a variable, but a function or an expression, and it ties an HTML event to
    a JavaScript function to execute it. The event needs to be declared immediately
    after the colon. For example, to react to a `click` event on a button, we would
    write the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令的行为与之前看到的不同。它期望的不是变量，而是一个函数或表达式，并将一个HTML事件绑定到一个JavaScript函数上以执行它。事件需要在冒号后立即声明。例如，为了响应按钮上的`click`事件，我们会写出以下内容：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When the button triggers the `click` event, the JavaScript `"printPage()"`
    function will be executed. Also, the shorthand for this directive is more commonly
    used, and we will use that from now on in this book: just replace the `v-on:`
    with `@`. Then, the previous example becomes the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮触发`click`事件时，JavaScript中的`"printPage()"`函数将被执行。此外，这个指令的缩写更常用，从现在起，我们将在这本书中使用它：只需将`v-on:`替换为`@`。然后，之前的示例变为以下内容：
- en: '`<``button @click="printPage()">Print</button>`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`<button @click="printPage()">打印</button>`'
- en: 'You can find the complete list of built-in directives in the official documentation
    here: [https://vuejs.org/api/built-in-directives.html](https://vuejs.org/api/built-in-directives.html)
    . We will see others as we move forward.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档中找到内置指令的完整列表：[https://vuejs.org/api/built-in-directives.html](https://vuejs.org/api/built-in-directives.html)。随着我们的前进，我们将看到其他指令。
- en: So far, we have seen that Vue 3 applications are built with components that
    we can use in our HTML and that we create using SFCs. The framework also provides
    us with directives to manipulate HTML elements, but that is not all. In the next
    section, we’ll see that the framework also provides some handy prebuilt components
    for us to use.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到Vue 3应用程序是通过组件构建的，这些组件我们可以用在我们的HTML中，并且我们使用SFCs创建它们。该框架还为我们提供了用于操作HTML元素的指令，但这并不是全部。在下一节中，我们将看到该框架还提供了一些方便的预构建组件供我们使用。
- en: Built-in components
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置组件
- en: 'The framework also provides us with several built-in components that we can
    use without explicitly importing them into each SFC. I have provided here a small
    description of each one, so you can refer to the official documentation for the
    syntax and examples (see [https://vuejs.org/api/built-in-components.html](https://vuejs.org/api/built-in-components.html)):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架还为我们提供了几个内置组件，我们可以在不将它们显式导入每个SFC的情况下使用。我在这里为每个组件提供了一个简短的描述，因此您可以参考官方文档以获取语法和示例（见[https://vuejs.org/api/built-in-components.html](https://vuejs.org/api/built-in-components.html)）：
- en: '`Transition` and `TransitionGroup` are two components that can work together
    to provide animations and transition to elements and components. They need you
    to create the CSS animations and transition classes to implement the animation
    when inserting or removing elements into the page. They are mainly (or often)
    used when you are displaying a list of elements with `v-for`/`:key` or `v-if`/`v-show`
    directives.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Transition`和`TransitionGroup`是两个可以协同工作以提供元素和组件动画和过渡的组件。它们需要您创建CSS动画和过渡类，以便在将元素插入或从页面中删除时实现动画。它们主要（或经常）用于您使用`v-for`/`:key`或`v-if`/`v-show`指令显示元素列表时。'
- en: '`KeepAlive` is another wrapper component (meaning that it surrounds other components)
    used to preserve the state (internal variables, elements, etc.) when the component
    wrapped inside is no longer on display. Usually, component instances are cleared
    out and “garbage collected” when they are unmounted. `KeepAlive` keeps them cached
    so their state is restored when they come back on display.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KeepAlive` 是另一个包装组件（意味着它包围其他组件），用于在包裹的组件不再显示时保留状态（内部变量、元素等）。通常，组件实例在卸载时会被清除并“垃圾回收”。`KeepAlive`
    将它们缓存起来，以便它们在重新显示时恢复状态。'
- en: '`Teleport` is a brand-new component in Vue 3, that allows you to transport
    the HTML of the component into another location anywhere on the page, even outside
    the component tree of your application. This helps in some cases where you need
    to display information outside your component but it has to be processed by your
    component’s internal logic.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Teleport` 是 Vue 3 中的一个全新的组件，允许你将组件的 HTML 传输到页面上的任何位置，甚至可以传输到应用组件树之外。这在某些情况下很有帮助，当你需要在外部显示信息但必须由组件的内部逻辑处理时。'
- en: '`Suspense` is a new component in Vue 3, but is still in an experimental phase,
    so its future is uncertain at the time of this writing. The basic idea is to display
    “fallback” content until all the asynchronous child components/elements are ready
    to be rendered. It is provided as a convenience since there are patterns that
    you could use to solve this problem. We will see some later on.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Suspense` 是 Vue 3 中的一个新组件，但仍然处于实验阶段，因此在撰写本文时其未来尚不确定。其基本思想是在所有异步子组件/元素准备好渲染之前显示“后备”内容。它作为一个便利性提供，因为存在可以用来解决这个问题的一些模式。我们稍后会看到一些。'
- en: '`Component-is` is a special element that will load a component at runtime,
    as prescribed by the content of a variable – for example, if we need to display
    a component based on the value of a variable, and the use of other directives
    may be cumbersome. It can also be used to render HTML elements. Let’s see an example:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Component-is` 是一个特殊元素，它将在运行时根据变量的内容加载组件——例如，如果我们需要根据变量的值显示一个组件，而使用其他指令可能很繁琐。它也可以用来渲染
    HTML 元素。让我们看一个例子：'
- en: '[PRE9]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this simple example, when the user clicks the `Edit` button, the action
    value will change to `EditItem`, and the component will be swapped in place. You
    can find the documentation here: [https://vuejs.org/api/built-in-special-elements.html.](https://vuejs.org/api/built-in-special-elements.html)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，当用户点击“编辑”按钮时，动作值将更改为“EditItem”，并且组件将在原地交换。你可以在这里找到文档：[https://vuejs.org/api/built-in-special-elements.html.](https://vuejs.org/api/built-in-special-elements.html)
- en: With the idea of frameworks and components, we are now better prepared to move
    forward.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 基于框架和组件的理念，我们现在更好地准备向前迈进。
- en: Book code conventions
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 书籍代码约定
- en: In this book, we will use a set of code conventions and guidelines that are
    good practices for Vue 3\. They will help you not only understand the examples
    of this book but also the code in the wild that you may come across, as more and
    more developers use it. Let’s start from the beginning.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用一组适用于 Vue 3 的代码约定和指南，这些都是良好的实践。它们将帮助你不仅理解本书的示例，还能理解你可能会遇到的野外科普代码，因为越来越多的开发者正在使用它。让我们从开始讲起。
- en: Variables and props
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量和属性
- en: These are always in lowercase and spaces are replaced with an underscore, for
    example, `total_count` and `person_id`..
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些名称总是小写，并且空格被下划线替换，例如 `total_count` 和 `person_id`..
- en: Constants
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量
- en: References to injected objects start with a `$` (dollar) sign, for example,
    `$router`, `$modals`, and `$notifications`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对注入对象的引用以 `$`（美元符号）开头，例如 `$router`、`$modals` 和 `$notifications`。
- en: References to reactive data start with `_` and are typed in snake case, for
    example, `_total` and `_first_input`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对响应式数据的引用以 `_` 开头，并使用蛇形命名法，例如 `_total` 和 `_first_input`。
- en: References to constant values are all in capital letters, for example, `OPTION`
    and `LANGUAGE_CODE.`
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对常量值的引用全部使用大写字母，例如 `OPTION` 和 `LANGUAGE_CODE.`
- en: Constructor functions for injected dependencies will start with `use`, for example,
    `const $store=useStore().`
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注入依赖的构造函数将以 `use` 开头，例如 `const $store=useStore().`
- en: Classes and component names
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和组件名称
- en: These are written in PascalCase (each word starts with an upper case letter),
    for example, `Person`, `Task`, and `QueueBuilder`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些名称使用 PascalCase（每个单词以大写字母开头），例如 `Person`、`Task` 和 `QueueBuilder`。
- en: Functions, methods, events, and filenames
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数、方法、事件和文件名
- en: These are written in camel case, for example, `doSubscribe()` and `processQueue()`
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这些是用驼峰命名法编写的，例如，`doSubscribe()`和`processQueue()`
- en: Instances
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例
- en: Instances will have the abstract name, followed by the word `Service` in the
    case of plain JavaScript objects that provide functions, `Model` for state models,
    and so forth. We will use services to encapsulate functionality.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 实例将具有抽象名称，对于提供函数的纯JavaScript对象，后面跟着单词`Service`，对于状态模型，则是`Model`，等等。我们将使用服务来封装功能。
- en: 'Here''s an example: `const` `projectService=new ProjectService().`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：`const` `projectService=new ProjectService().`
- en: Tip
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: With your team, always use a code convention that all agree upon. This will
    make the code more readable and maintainable. It can be also recommended to use
    a linter (a processor to capture conventions in your code).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 与你的团队一起，始终使用大家都同意的代码约定。这将使代码更易于阅读和维护。还建议使用一个linter（一个用于捕获你代码中约定的处理器）。
- en: As mentioned, these code conventions are gaining popularity, so you may see
    them in multiple projects. However, these are not mandatory standards and most
    definitely are not prescribed by the framework. You can write all in capital letters
    if that is your style, but what really matters is that you and your team define
    and abide by your own conventions in a consistent manner. What matters in the
    end, is that we all have a common language when writing code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的，这些代码约定越来越受欢迎，所以你可能会在多个项目中看到它们。然而，这些并不是强制性的标准，绝对不是由框架规定的。如果你喜欢全部大写，那也可以，但真正重要的是你和你的团队能够以一致的方式定义并遵守自己的约定。最终，重要的是我们都有一种共同的代码编写语言。
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has gone from the basics of libraries and frameworks to Vue 3 directives,
    components, and even code conventions. These concepts are still a bit abstract,
    so we will bring them down to implementation as we move through the rest of the
    book and work with real code. However, we are on safe footing now to learn about
    design principles and patterns in the next chapter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已经从库和框架的基础知识过渡到Vue 3指令、组件，甚至代码约定。这些概念仍然有些抽象，所以随着我们继续阅读本书的其余部分并编写实际代码，我们将把它们具体化。然而，我们现在已经安全地站在了学习下一章设计原则和模式的基础上。
- en: Review questions
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习问题
- en: 'To help you consolidate the contents of this chapter, you can use these review
    questions:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你巩固本章内容，你可以使用以下复习问题：
- en: What is the difference between a library and a framework?
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库和框架之间的区别是什么？
- en: Why is Vue a “progressive” framework?
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么Vue是一个“渐进式”框架？
- en: What are single-file components?
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单文件组件是什么？
- en: What are some of the most common directives used in Vue development?
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Vue开发中最常用的指令有哪些？
- en: Why are code conventions important?
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码约定为什么很重要？
- en: If you can answer these questions quickly in your mind, you’re good to go! If
    not, you may want to review the chapter briefly to make sure you have the basis
    to move on.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能在脑海中迅速回答这些问题，那么你已经准备好了！如果不能，你可能需要简要回顾本章，以确保你具备继续前进的基础。
