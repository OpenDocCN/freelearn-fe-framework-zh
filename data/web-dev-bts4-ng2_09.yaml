- en: Chapter 9. Communication and Data Persistence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。通信和数据持久性
- en: This chapter is about working with HTTP requests and storing data on the server.
    We will learn how to use the built-in HTTP library to work with endpoints. Also,
    we will learn how to use **Observables** to work with data. At the end of the
    chapter, we will learn how to work with Firebase as the persistence layer of the
    app. As usual, we will continue to build the project we started to develop in
    previous chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讲解如何处理HTTP请求并将数据存储在服务器上。我们将学习如何使用内置的HTTP库来处理端点。此外，我们还将学习如何使用**可观察对象**来处理数据。在本章结束时，我们将学习如何将Firebase作为应用程序的持久层。和往常一样，我们将继续构建之前章节中开始开发的项目。
- en: 'At the end of the chapter, you will have a solid understanding of the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将对以下内容有扎实的了解：
- en: HttpModule
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HttpModule
- en: Creating connections
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建连接
- en: Observables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察对象
- en: Installing Firebase tools
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Firebase工具
- en: Connecting to Firebase
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到Firebase
- en: 'Let''s begin:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: Open the Terminal, create the folder `ecommerce` , and move into the folder.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，创建文件夹`ecommerce`，并进入该文件夹。
- en: Copy the contents of the project from the folder `chapter_9/1.ecommerce-seed`
    into the new project.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目文件夹`chapter_9/1.ecommerce-seed`中的内容复制到新项目中。
- en: 'Run the following script to install the npm modules:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下脚本以安装npm模块：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Start the TypeScript watcher and lite server with the following command:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令启动TypeScript监视器和轻量级服务器：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This script opens the web browser and navigates to the welcome page of the project.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本打开Web浏览器并导航到项目的欢迎页面。
- en: Client to server communication
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端到服务器的通信
- en: 'The web browsers and servers function as a **client-server system** . In general,
    the web server keeps the data and shares it with any number of web browsers on
    request. The web browsers and servers must have a common language, and they must
    follow rules so that both know what to expect. The language and rules of communication
    are defined in communications protocols. The **Transmission Control Protocol**
    ( **TCP** ) is a standard that defines how to establish and maintain a network
    conversation via which application programs can exchange data. TCP works with
    the **Internet Protocol** ( **IP** ), which defines how computers send packets
    of data to each other. Together, TCP and IP are the basic rules defining the Internet.
    The web browsers and servers communicate via **TCP/IP** stack. To send data over
    a TCP/IP network requires four steps or layers:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Web浏览器和服务器作为**客户端-服务器系统**运行。一般来说，Web服务器保存数据，并在请求时与任意数量的Web浏览器共享数据。Web浏览器和服务器必须有共同的语言，并且必须遵循规则，以便双方知道可以期待什么。通信的语言和规则在通信协议中定义。**传输控制协议**（**TCP**）是一种标准，定义了如何建立和维护网络会话，通过该会话应用程序可以交换数据。TCP与**互联网协议**（**IP**）一起工作，后者定义了计算机如何相互发送数据包。TCP和IP共同定义了互联网的基本规则。Web浏览器和服务器通过**TCP/IP**堆栈进行通信。要在TCP/IP网络上发送数据，需要四个步骤或层：
- en: The **Application layer** encodes the data being sent. It does not care about
    how the data gets between two points, and it knows very little about the status
    of the network. Applications pass data to the next layer in the TCP/IP stack and
    then continue to perform other functions until a reply is received.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用层**对发送的数据进行编码。它不关心数据如何在两点之间传输，对网络状态知之甚少。应用程序将数据传递给TCP/IP堆栈中的下一层，然后继续执行其他功能，直到收到回复。'
- en: The **Transport layer** splits the data into manageable chunks, and adds port
    number information. The Transport Layer uses port numbers for addressing, which
    range from 1 to 65,535\. Port numbers from 0 to 1,023 are called **well-known
    ports** . The numbers below 256 are reserved for public services that run on the
    Application layer.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输层**将数据分割成可管理的块，并添加端口号信息。传输层使用端口号进行寻址，端口号范围从1到65,535。从0到1,023的端口号被称为**众所周知的端口**。256以下的数字保留用于在应用层上运行的公共服务。'
- en: The **Internet layer** adds IP addresses stating where the data is from and
    where it is going. It's the *glue* that holds networking together. It permits
    the sending, receiving, and routing of data.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互联网层**添加IP地址，说明数据的来源和去向。它是将网络连接在一起的“胶水”。它允许数据的发送、接收和路由。'
- en: The **Link layer** adds **Media Access Control** ( **MAC** ) address information
    to specify which hardware device the message came from, and which hardware device
    the message is going to. The MAC address is fixed at the time the interface was
    manufactured and cannot be changed.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接层**添加**媒体访问控制**（**MAC**）地址信息，以指定消息来自哪个硬件设备，消息将要传送到哪个硬件设备。MAC地址在接口制造时固定，并且无法更改。'
- en: All client-server protocols operate in the Application layer. Application-layer
    protocol states the basic communication patterns. For the data exchange format
    to be formalized, the server implements an **Application Program Interface** (
    **API** ), such as a web service. The API is an abstraction layer for resources
    like databases and custom software. The **Hypertext Transfer Protocol** ( **HTTP**
    ) is the Application-layer protocol that implements the **World Wide Web** ( **WWW**
    ). While the web itself has many different facets, the primary purpose of HTTP
    is to transfer hypertext documents and other files from web servers to web clients.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所有客户端-服务器协议都在应用层操作。应用层协议规定了基本的通信模式。为了使数据交换格式得到正式化，服务器实现了一个**应用程序接口**（**API**），比如一个网络服务。API是资源（比如数据库和自定义软件）的抽象层。**超文本传输协议**（**HTTP**）是实现**万维网**（**WWW**）的应用层协议。虽然网络本身有许多不同的方面，但HTTP的主要目的是将超文本文档和其他文件从网络服务器传输到网络客户端。
- en: Web API
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web API
- en: The interaction between web clients and servers' assets happens via the defined
    interface called the  **Web API** . It is a server architectural approach providing
    programmable interfaces to a set of services serving different types of consumers.
    The Web API is typically defined as a set of HTTP request and response messages.
    In general, the structure of the reply message is represented in an **Extensible
    Markup Language** ( **XML** ) or **JavaScript Object Notation** ( **JSON** ) format.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Web客户端和服务器资产之间的交互是通过定义的接口**Web API**进行的。它是一种服务器架构方法，为不同类型的消费者提供可编程接口。Web API通常被定义为一组HTTP请求和响应消息。一般来说，回复消息的结构以**可扩展标记语言**（**XML**）或**JavaScript对象表示**（**JSON**）格式表示。
- en: In the epoch of Web 1.0, the Web API was synonymous for **Simple Object Access **
    **Protocol** ( **SOAP** ) based web services and **Service-Oriented Architecture**
    ( **SOA** ). In Web 2.0, this term is moving towards  **Representational State
    Transfer** ( **REST** ) style web resources and **Resource-Oriented Architecture**
    ( **ROA** ).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web 1.0时代，Web API是**简单对象访问协议**（**SOAP**）为基础的网络服务和**面向服务的架构**（**SOA**）的同义词。在Web
    2.0中，这个术语正在向**表述状态转移**（**REST**）风格的网络资源和**面向资源的架构**（**ROA**）转变。
- en: REST
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST
- en: '**REST** is an architectural style of the World Wide Web and is used for design
    networked applications. There is not a standard or W3C recommendation for REST.
    The term REST was introduced and defined in 2000 by *Roy Fielding* in his doctoral
    dissertation. Later, he used REST to design HTTP 1.1 and **Uniform Resource Identifiers**
    ( **URIs** ).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: REST是万维网的一种架构风格，用于设计网络应用程序。REST没有标准或W3C推荐。REST这个术语是由Roy Fielding在他的博士论文中于2000年引入和定义的。后来，他使用REST设计了HTTP
    1.1和统一资源标识符（URIs）。
- en: 'REST as a programming approach is:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种编程方法，REST是：
- en: '*Platform-independent* so that the server can be installed on Linux, Windows,
    and so on'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与平台无关，因此服务器可以安装在Linux、Windows等上。
- en: '*Language-independent* , so we can use C#, Java, JavaScript, and so on'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与语言无关，因此我们可以使用C＃、Java、JavaScript等。
- en: Standards-based and can run on top of HTTP standards
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于标准，并且可以在HTTP标准之上运行。
- en: 'REST uses simple HTTP protocol to make calls between clients and servers rather
    than using a complicated mechanism such as a **Remote Procedure Call** ( **RPC**
    ), **Common Object Request Broker Architecture** ( **CORBA** ), or **SOAP** .
    Any application calls RESTful makes conforms to the constraints of REST:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: REST使用简单的HTTP协议在客户端和服务器之间进行调用，而不是使用复杂的机制，如远程过程调用（RPC）、公共对象请求代理体系结构（CORBA）或SOAP。任何调用RESTful的应用程序都符合REST的约束：
- en: The **client-server constraint** means that the client and server are separated
    so that they may be replaced and developed independently
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端-服务器约束意味着客户端和服务器是分离的，因此它们可以独立替换和开发。
- en: The client and server communication is based on **stateless constraint** , so
    there is no client context stored on the server between requests and each request
    contains all the information necessary to service the request
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端和服务器的通信基于无状态约束，因此在请求之间服务器上没有存储客户端上下文，每个请求都包含了服务请求所需的所有信息。
- en: The **cacheable constraint** defines whether the server responses must implicitly
    or explicitly mark themselves as cacheable, or not
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可缓存约束定义了服务器响应是否必须隐式或显式地标记自己为可缓存或不可缓存。
- en: To comply with **layer systems constraints** , the client and server use the
    layered architecture to improve the overall system capability and scalability
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵守层系统约束，客户端和服务器使用分层架构来提高整个系统的能力和可扩展性
- en: The server can follow the **code on demand optional constraints** to customize
    the functionality of the client by the transfer of executable code such as JavaScript
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器可以遵循代码应请求可选约束，通过传输可执行代码（如JavaScript）来自定义客户端的功能。
- en: RESTful applications use HTTP requests for all four **CRUD** ( **Create, Read,
    Update,** and **Delete** ) operations. REST doesn't include security, encryption,
    session management, and so on but we can build them on the top of HTTP.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful应用程序使用HTTP请求进行所有四个CRUD（创建、读取、更新和删除）操作。REST不包括安全性、加密、会话管理等，但我们可以在HTTP的基础上构建它们。
- en: Let's have a look at a typical endpoint we used to read the product: `http://localhost:9000/product/123`
    .
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个典型的端点，我们用来读取产品：`http://localhost:9000/product/123`。
- en: 'There is just a URL sent to the server using a simple HTTP GET request. The
    `product` here is the resource in the URL. There is a standard convention in REST
    design to use nouns to identify resources. REST can handle more complex requests,
    like: `http://localhost:3000/products?category=1` .'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 只需使用简单的HTTP GET请求将URL发送到服务器。这里的“产品”是URL中的资源。在REST设计中有一个标准约定，即使用名词来标识资源。REST可以处理更复杂的请求，比如：`http://localhost:3000/products?category=1`。
- en: If necessary, we can utilize the HTTP `POST` method to send long parameters
    or binaries inside the POST body.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们可以利用HTTP的POST方法在POST主体内发送长参数或二进制数据。
- en: REST response formats
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST响应格式
- en: 'For most of the time, the server responds with XML, **Comma-Separated Values**
    ( **CSV** ), or JSON formats in REST. The choice depends on the format''s advantages:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，服务器以XML、**逗号分隔值**（**CSV**）或JSON格式响应REST。选择取决于格式的优势：
- en: XML is easily expandable and type safe
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML易于扩展和类型安全
- en: CSV is very compact
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSV非常紧凑
- en: JSON is easy to parse
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON易于解析
- en: REST and AJAX
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST和AJAX
- en: We use the  **Asynchronous JavaScript and XML** ( **AJAX** ) client-side technique
    to create asynchronous web applications. AJAX uses `XMLHttpRequest` objects to
    send requests to the server to dynamically change the web page. The AJAX and REST
    requests are similar.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用**异步JavaScript和XML**（**AJAX**）客户端技术来创建异步Web应用程序。AJAX使用`XMLHttpRequest`对象向服务器发送请求以动态更改网页。AJAX和REST请求类似。
- en: REST API design guidelines
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST API设计指南
- en: 'What is the next step we need to take to create the proper REST API? That question
    has no simple answer, and since there''s no one widely adopted standard that works
    in all cases I recommend we get the answer from well-known sources such as Microsoft
    REST API Guidelines, available at: [https://github.com/Microsoft/api-guidelines](https://github.com/Microsoft/api-guidelines)
    .'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要采取下一步来创建适当的REST API吗？这个问题没有简单的答案，因为没有一个被广泛采用的标准适用于所有情况，我建议我们从微软REST API指南等知名来源获取答案，可在以下网址找到：[https://github.com/Microsoft/api-guidelines](https://github.com/Microsoft/api-guidelines)。
- en: 读累了记得休息一会哦~
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**公众号：古德猫宁李**'
- en: 电子书搜索下载
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书单分享
- en: 书友学习交流
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
- en: 电子书搜索下载
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
- en: The HttpModule
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HttpModule
- en: So far, we have developed only the frontend of our application and it is therefore
    pretty useless. We need somewhere to store our products and categories so that
    we can fetch them later on. To do this, we're going to connect to a server, which
    is going to house a RESTful API that serves up JSON.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只开发了应用程序的前端，因此它几乎没有用。我们需要一个地方来存储我们的产品和类别，以便以后可以获取它们。为此，我们将连接到一个服务器，该服务器将承载提供JSON的RESTful
    API。
- en: Out of the box, Angular 2 includes `HttpModule` to organize some low-level methods
    of fetching and posting our data.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2默认包含`HttpModule`来组织一些低级方法来获取和发布我们的数据。
- en: 'To use the new `HttpModule` in our project, we have to import it as a separate
    add-on module called `@angular/http` , shipped in a separate script file as part
    of the Angular npm package. We import the `@angular/http` in the `systemjs.config.js`
    file configured `SystemJS` to load that library when we need it:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的项目中使用新的`HttpModule`，我们必须将其导入为一个名为`@angular/http`的单独的附加模块，作为Angular npm包的一部分，以单独的脚本文件的形式提供。我们在`systemjs.config.js`文件中导入`@angular/http`，配置`SystemJS`在需要时加载该库：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our application will access `HttpModule` services from anywhere in the application,
    so we should register them by adding the `HttModule` to the list of `imports`
    of the `AppModule` . After the bootstrap, all the `HttpModule` services become
    available to the root level of `AppComponent` :'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将从应用程序的任何地方访问`HttpModule`服务，因此我们应该通过将`HttModule`添加到`AppModule`的`imports`列表中来注册它们。引导之后，所有`HttpModule`服务都将对`AppComponent`的根级别可用：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The in-memory Web API
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存中的Web API
- en: 'Because we don''t have a real web server that can handle our requests, we will
    use a mock service to mimic the behavior of the real one. That approach has the
    following advantages:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们没有一个真正能处理我们请求的网络服务器，我们将使用模拟服务来模仿真实服务器的行为。这种方法具有以下优点：
- en: It rapidly stubs out API designs and new endpoints. **Service mocking** gives
    you the ability to use **Test Driven Development** ( **TDD** ).
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它快速地创建API设计和新的端点。**服务模拟**使您能够使用**测试驱动开发**（**TDD**）。
- en: It shares APIs between team members. We won't have downtime whilst the frontend
    team waits for the other team to finish. This approach makes the financial argument
    for mocking unusually high.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在团队成员之间共享API。我们不会因为前端团队等待其他团队完成而停机。这种方法使得模拟的财务论点异常高。
- en: It takes control of simulated responses and performance conditions. We can use
    mocks to create a proof of concept, as a wireframe, or as a demo, so they can
    be very cost efficient to use.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它控制模拟响应和性能条件。我们可以使用模拟来创建概念验证，作为线框图或演示，因此它们非常具有成本效益。
- en: 'It has disadvantages that we should know about:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一些我们应该知道的缺点：
- en: We have to do double the work and sometimes this can mean quite a lot
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须做双倍的工作，有时这意味着相当多的工作
- en: It has deployment constraints if you need to deploy it somewhere
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要在某个地方部署它，它有部署约束
- en: The mocking code is subject to bugs
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟代码容易出现错误
- en: The mock is only a representation of what it is mocking, and it can misrepresent
    the real service
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟只是对所模拟的东西的一种表示，它可能会误导真实的服务
- en: 'The in-memory Web API is an optional service in the `angular-in-memory-web-api`
    library. It''s not part of Angular 2, so we need to install it as a separate npm
    package and register for module loading by `SystemJS` inside the `systemjs.config.js`
    file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 内存Web API是`angular-in-memory-web-api`库中的一个可选服务。它不是Angular 2的一部分，因此我们需要将其安装为单独的npm包，并在`systemjs.config.js`文件中通过`SystemJS`进行模块加载注册：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we need to create an `InMemoryDataService` class which implements `InMemoryDbService`
    , to create an in-memory database:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个实现`InMemoryDbService`的`InMemoryDataService`类，以创建一个内存数据库：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `createDb` method should create a *database* object hash whose keys are
    collection names and whose values are arrays of the group objects. It is safe
    to call it again because it returns new arrays with new objects. That allows `InMemoryBackendService`
    to morph the arrays and objects without touching the source data. I moved the
    datasets from `ProductService` and `CategoryService` in this file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`createDb`方法应该创建一个*数据库*对象哈希，其键是集合名称，其值是组对象的数组。可以安全地再次调用它，因为它返回具有新对象的新数组。这允许`InMemoryBackendService`在不触及源数据的情况下改变数组和对象。我将这个文件中的数据集从`ProductService`和`CategoryService`中移动过来。'
- en: 'Analogous with the `HttModule` , we are importing the `InMemoryWebApiModule`
    and `InMemoryDataService` into the list of `imports` of the `AppModule` . They
    replace the default `Http` client backend within in-memory Web API alternative
    services:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与`HttModule`类似，我们正在将`InMemoryWebApiModule`和`InMemoryDataService`导入到`AppModule`的`imports`列表中。它们替换了内存Web
    API替代服务中的默认`Http`客户端后端：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The method `forRoot` prepares the in-memory Web API in the root application
    module to create an in-memory database in the moment of bootstrapping. It has
    a second parameter of `InMemoryBackendConfigArgs` type and keeps `InMemoryBackend`
    configuration options such as delay (in milliseconds) to simulate latency, host
    for this service, and so on.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`forRoot`方法在根应用程序模块中准备内存Web API，以在引导时创建内存数据库。它有一个`InMemoryBackendConfigArgs`类型的第二个参数，并保留`InMemoryBackend`配置选项，例如延迟（以毫秒为单位）以模拟延迟，为此服务的主机等。'
- en: Now everything is ready to change both `ProductService` and `CategoryService`
    to start them using an `HTTP` service.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切准备就绪，可以更改`ProductService`和`CategoryService`，以开始使用`HTTP`服务。
- en: The HTTP client
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP客户端
- en: 'The Angular **HTTP client** communicates with a server via AJAX requests using
    an HTTP protocol. Components of our project will never talk directly to HTTP client
    services. We delegate data access to service classes. Let''s update the imports
    in `ProductService` as shown in the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Angular **HTTP客户端**通过HTTP协议的AJAX请求与服务器通信。我们项目的组件将永远不会直接与HTTP客户端服务通信。我们将数据访问委托给服务类。让我们按照以下所示更新`ProductService`中的导入：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, fetch the products with the `Http` service:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`Http`服务获取产品：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you see, we are using a standard HTTP GET request to fetch the set of products.
    The `InMemoryWebApiModule` quite cleverly understands the query parameters in
    the requested URL. Here, the `ProductGridComponent` utilizes the `ProductService`
    to display our grid of products on the web page:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用标准的HTTP GET请求来获取产品集。`InMemoryWebApiModule`非常聪明地理解了请求URL中的查询参数。在这里，`ProductGridComponent`利用`ProductService`在网页上显示我们的产品网格：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `products` property here is just an array of products. We use a simple
    `NgFor` directive to iterate through them:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`products`属性只是一个产品数组。我们使用简单的`NgFor`指令来遍历它们：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The source code changes in `CategoryService` a bit differently because of the
    nature of the categories data. The set of categories is static, so we don''t need
    to fetch them every time and can keep them in the cache inside `CategoryService`
    :'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类别数据的性质不同，`CategoryService`中的源代码更改有些不同。类别集是静态的，所以我们不需要每次都获取它们，可以将它们保存在`CategoryService`内的缓存中：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the `getCategory` method, we can easily find the category by ID because we
    simply fetch it from the cache.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getCategory`方法中，我们可以很容易地通过ID找到类别，因为我们只是从缓存中获取它。
- en: The HTTP Promises
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP承诺
- en: 'Carefully look at how we return the data from an HTTP GET request. We use the
    `toPromise` method just after the `get` method of the `Http` class:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看我们如何从HTTP GET请求中返回数据。我们在`Http`类的`get`方法之后立即使用`toPromise`方法：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So, why do we need this method and what exactly does it do?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们需要这个方法，它到底是做什么的呢？
- en: 'Almost all the `Http` service methods return a RxJS `Observable` . Observables
    are a powerful way to manage asynchronous data flows. To convert a RxJS `Observable`
    into a `Promise` , we use the `toPromise` operator. It just fetches a single chunk
    of data and returns it immediately. Before using the `toPromise` operator, we
    need to import it from RxJS implicitly because the library is quite extensive
    and we should include only those features that we need:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的`Http`服务方法都返回RxJS`Observable`。可观察对象是管理异步数据流的强大方式。要将RxJS`Observable`转换为`Promise`，我们使用`toPromise`操作符。它只是立即获取单个数据块并立即返回。在使用`toPromise`操作符之前，我们需要隐式从RxJS导入它，因为该库非常庞大，我们应该只包含我们需要的功能：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let's talk about `Observable`  and why `Http` uses them everywhere.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈`Observable`以及为什么`Http`在各处使用它们。
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can find the source code for this at `chapter_9/2.ecommerce-promise` .
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`chapter_9/2.ecommerce-promise`找到此源代码。
- en: RxJS library
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxJS库
- en: The **RxJS** is a project actively developing by Microsoft in collaboration
    with many open source developers. There is a set of libraries organized as an
    API for asynchronous and event-based programming. We use Observables to represent
    the asynchronous data streams. There are many operators to query and Schedulers
    to parameterize the concurrency in them. In short--the RxJS is a combination of
    Observer and Iterator patterns and functional programming.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**RxJS**是微软与许多开源开发人员合作积极开发的项目。它是一组组织为异步和基于事件的编程API的库。我们使用可观察对象来表示异步数据流。有许多操作符来查询和调度器来参数化它们的并发性。简而言之
    - RxJS是观察者和迭代器模式以及函数式编程的结合。'
- en: 'Before use we can import all core modules:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用之前，我们可以导入所有核心模块：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Better import only necessary functionality if you care about the size of your
    application:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你关心应用程序的大小，最好只导入必要的功能：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The RxJs is huge, and I suggest to refer to the official website to learn more:
    [http://reactivex.io](http://reactivex.io)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: RxJs非常庞大，我建议参考官方网站了解更多：[http://reactivex.io](http://reactivex.io)
- en: Observables versus promises
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观察对象与承诺
- en: 'In our days the **Observables** are a proposed feature for JavaScript version
    ES2016 (ES7), so we use the RxJS as the polyfill library to bring them into the
    project until the next new version of JavaScript is released. Angular 2 has basic
    support for Observables and we use RxJS to extend this functionality. Promises
    and Observables bring the abstractions that help us deal with the asynchronous
    nature of our applications with several key differences:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的日子里，**可观察对象**是JavaScript版本ES2016（ES7）的一个提议功能，因此我们使用RxJS作为填充库将它们引入项目，直到下一个新版本的JavaScript发布。Angular
    2对可观察对象有基本支持，我们使用RxJS来扩展这个功能。Promise和可观察对象提供了帮助我们处理应用程序异步特性的抽象，有一些关键的区别：
- en: Observables emit multiple values over time, in contrast to Promises which can
    return only one value or error
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察对象随时间发出多个值，与只能返回一个值或错误的Promise相反
- en: Observables are treated like arrays and allow us to use operators, collection-like
    methods to manipulate values
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察对象被视为数组，并允许我们使用操作符、类似集合的方法来操作值
- en: Observables can be cancelled
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察对象可以被取消
- en: Observables can be retried with one of the retry operators
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察对象可以使用重试操作符之一进行重试
- en: 'So we use `toPromise` specially to convert the stream of data from a request
    into a single value. Do we really need that? I''ve made some changes in the project
    to show you how easy it is to use Observables in Angular 2 applications. Just
    have a look at the modified version of `ProductService` :'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们特别使用`toPromise`将请求的数据流转换为单个值。我们真的需要吗？我对项目进行了一些更改，以向您展示在Angular 2应用程序中如何轻松使用可观察对象。只需查看`ProductService`的修改版本：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We use several transformation operators from the RxJS package in the preceding
    code, so don''t forget to import them from the package. There are many operators
    in RxJS helping us to organize different sorts of transformations:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上面的代码中使用了RxJS包中的几个转换操作符，所以不要忘记从包中导入它们。RxJS中有许多操作符，可以帮助我们组织不同类型的转换：
- en: The `map` operator transforms the items by applying a function to each of them.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`操作符通过对每个项目应用函数来转换项目。'
- en: The `flatMap` , `concatMap` , and `flatMapIterable` operators transform the
    items into Observables or Iterables and flatten them into one.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flatMap`，`concatMap`和`flatMapIterable`操作符将项目转换为可观察对象或可迭代对象，并将它们展平为一个。'
- en: The `switchMap` operator transforms the items into Observables. The items emitted
    from the most-recently transformed Observable will be mirrored.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switchMap`操作符将项目转换为可观察对象。最近转换的可观察对象发出的项目将被镜像。'
- en: The `scan` operator sequentially applies a function to each emitted item to
    emit only successive values.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scan`操作符依次对每个发出的项目应用函数，以仅发出连续的值。'
- en: The `groupBy` operator helps divide and organize Observables by key to emit
    the groups of items from the original one.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupBy`操作符帮助按键划分和组织可观察对象，以从原始对象中发出项目组。'
- en: The `buffer` operator combines emitted items into bundles. It emits bundles
    instead of emitting one item at a time.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buffer`操作符将发出的项目组合成包。它发出包而不是一次发出一个项目。'
- en: The **cast** casts all items from the source Observable into a particular type
    before reemitting them.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cast**将源可观察对象中的所有项目转换为特定类型，然后重新发出它们。'
- en: 'RxJS is really big and I recommend starting to learn more about it from the
    official website: [https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS)
    .'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS非常庞大，我建议从官方网站开始学习更多关于它的知识：[https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS)。
- en: 'When successful a request returns an instance of the `Response` class. The
    response data is in JSON string format, so we must parse that string into JavaScript
    objects which we do by calling the `json` method of the `Response` class. As usual,
    we should deal with errors because we have to be prepared for something to go
    wrong, as it surely will. We catch errors by calling the `handleError` method
    of our class. Bear in mind, we must transform the error into a user-friendly message,
    and return it in a new, failed observable via `Observable.throw` :'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的请求返回`Response`类的实例。响应数据以JSON字符串格式返回，因此我们必须通过调用`Response`类的`json`方法将该字符串解析为JavaScript对象。通常情况下，我们应该处理错误，因为我们必须为可能出错的情况做好准备。我们通过调用我们的类的`handleError`方法来捕获错误。请记住，我们必须将错误转换为用户友好的消息，并通过`Observable.throw`返回一个新的失败的observable：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There are two different techniques to display Observable data on the web page.
    The first approach is organizing a subscription of Observable data as implemented
    in:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页上显示Observable数据有两种不同的技术。第一种方法是组织Observable数据的订阅，如下所示：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We subscribed to all changes that happen in `ProductService` and immediately
    assign them to the `product` property, so Angular delivers them into the template.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们订阅了在`ProductService`中发生的所有变化，并立即将它们分配给`product`属性，因此Angular将它们传递到模板中。
- en: 'Another approach is to forward the Observable result to the template as implemented
    in:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是将Observable结果转发到模板中，如下所示：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We then forward the Observable result to the template via the `product`  property
    where the `async` pipe in the `NgFor` handles the subscription:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过`product`属性将Observable结果转发到模板，其中`NgFor`中的`async`管道处理订阅：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Sometimes, we may need to start one request, then cancel it and make a different
    request before the server has responded to the first one. It is complicated to
    implement such a sequence with Promises, so let's have a look how Observables
    can help us.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能需要开始一个请求，然后取消它，并在服务器对第一个请求做出响应之前进行不同的请求。使用Promises来实现这样的顺序是复杂的，所以让我们看看Observables如何帮助我们。
- en: Observables in search-by-title
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索标题中的Observables
- en: 'We have a feature to search products by title. The user types the title and
    then presses the **Go** button to request data from the server. We can improve
    the user experience here, so that when the user types a title into the search
    box, we will make repeated HTTP requests for products filtered by title. Look
    at the updated markup of `ProductSearchComponent` :'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个按标题搜索产品的功能。用户输入标题，然后按下**Go**按钮从服务器请求数据。我们可以在这里改善用户体验，当用户在搜索框中输入标题时，我们将重复进行产品的HTTP请求，以标题进行过滤。看一下`ProductSearchComponent`的更新标记：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We removed the **Go** button. An input element gathers the search title from
    the user and calls the `searchProduct` method after each `keyup` event. The `searchProduct`
    method updates the query parameters of the URL:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们移除了**Go**按钮。输入元素从用户那里收集搜索标题，并在每次`keyup`事件后调用`searchProduct`方法。`searchProduct`方法更新URL的查询参数：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `ProductGridComponent` listens to the stream of query parameters change
    in the `route` and manipulates the stream before it reaches the `productService`
    :'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductGridComponent`监听`route`中查询参数变化的流，并在到达`productService`之前操作流：'
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, we wait for the user to stop typing for at least 300
    milliseconds with the `debounceTime` operator. Only changed search values make
    it through to the service via the `distinctUntilChanged` operator. Later, we fetch
    category and search query parameters and request products from `productService`
    .
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`debounceTime`操作符等待用户停止输入至少300毫秒。只有改变的搜索数值通过`distinctUntilChanged`操作符传递到服务端。之后，我们获取类别和搜索查询参数，并从`productService`请求产品。
- en: We can quickly start the server and open our web application in the browser
    to check that all works as expected. From that point, we can demonstrate our project
    to colleagues or stakeholders as a proof of concept that we will use in future
    development.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速启动服务器并在浏览器中打开我们的Web应用程序，以检查所有内容是否按预期工作。从那时起，我们可以向同事或利益相关者展示我们的项目，作为我们将来开发中使用的概念验证。
- en: Next, we need a real database and hosting server to finish development and test
    everything in the real environment. Let's use Firebase to store and sync our data
    in real time and deliver web content faster.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个真正的数据库和托管服务器来完成开发，并在真实环境中测试所有内容。让我们使用Firebase实时存储和同步我们的数据，并更快地提供Web内容。
- en: Tip
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can find the source code for this at `chapter_9/3.ecommerce-promise` .
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`chapter_9/3.ecommerce-promise`找到此源代码。
- en: Introduction to Firebase
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Firebase简介
- en: '**Firebase** is a *Realtime NoSQL JSON Database* . Any piece of data is accessible
    by URL. Firebase contains SDK for different platforms, such as JavaScript for
    the Web, IOS, Android, and so on. It includes authentication baked inside core
    libraries, so we can quickly authenticate users directly from clients via OAuth
    provided by GitHub, Google, Twitter, and Facebook. It also supports anonymous
    and password authentication. Firebase provides a hosting service for static assets
    through the Firebase Console or CLI. Firebase uses web sockets to update data
    on all connected clients in real time.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase是一个实时的NoSQL JSON数据库。任何数据都可以通过URL访问。Firebase包含不同平台的SDK，比如Web的JavaScript，IOS，Android等。它包括身份验证内置在核心库中，因此我们可以通过GitHub、Google、Twitter和Facebook提供的OAuth直接从客户端快速验证用户。它还支持匿名和密码验证。Firebase通过Firebase控制台或CLI提供静态资产的托管服务。Firebase使用Web套接字实时更新所有连接的客户端上的数据。
- en: If you've never used Firebase before you need to register an account first.
    Open your web browser and navigate to[https://firebase.google.com/](https://firebase.google.com/)
    . Click on **SIGN IN** and use your Google account to set up your Firebase account.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前从未使用过Firebase，您需要先注册一个帐户。打开您的Web浏览器，转到[https://firebase.google.com/](https://firebase.google.com/)。点击“登录”并使用您的Google帐户设置您的Firebase帐户。
- en: Creating a Firebase project
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Firebase项目
- en: 'We are planning to use the Firebase SDK library to access and store data. However,
    before that, we need to add Firebase to our web application. We''ll need a Firebase
    project, the Firebase SDK, and a short snippet of initialization code that has
    a few details about our project. Click **Go to console** or open the **Firebase
    Console** from the following address: [https://firebase.google.com/console](https://firebase.google.com/console)
    .'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划使用Firebase SDK库来访问和存储数据。但在此之前，我们需要将Firebase添加到我们的Web应用程序中。我们需要一个Firebase项目、Firebase
    SDK和一个关于我们项目的一些细节的初始化代码片段。点击“转到控制台”或从以下地址打开“Firebase控制台”：[https://firebase.google.com/console](https://firebase.google.com/console)。
- en: 'Click on the **Create New Project** button and add a project name and your
    country of origin:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“创建新项目”按钮，添加项目名称和您的原籍国：
- en: '![Creating a Firebase project](Image00135.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![创建Firebase项目](Image00135.jpg)'
- en: In less than a minute, we will have access to the Firebase relative database,
    authentication, storage, and so on.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 不到一分钟，我们将可以访问Firebase相关的数据库、身份验证、存储等。
- en: Installing Firebase CLI tools
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Firebase CLI工具
- en: 'We will use the Firebase CLI tools to manage, view, and deploy our project
    to Firebase from a Terminal. Let''s open the Terminal, navigate to our project,
    and run the following command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Firebase CLI工具从终端管理、查看和部署我们的项目到Firebase。让我们打开终端，转到我们的项目，并运行以下命令：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After installation, we will have a globally available Firebase command. Now,
    we can sign into Firebase from the Terminal. Remember you must already have set
    up a Google account to proceed:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，我们将拥有一个全局可用的Firebase命令。现在，我们可以从终端登录到Firebase。请记住，您必须已经设置了Google账户才能继续：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This command establishes connection to your remote Firebase account and grants
    access to our projects:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令建立了与远程Firebase账户的连接，并授予了我们对项目的访问权限：
- en: '![Installing Firebase CLI tools](Image00136.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![安装Firebase CLI工具](Image00136.jpg)'
- en: 'If you interested in knowing what commands the Firebase CLI supports, please
    go to the official website: [https://firebase.google.com/docs/cli/](https://firebase.google.com/docs/cli/)
    .'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道Firebase CLI支持哪些命令，请访问官方网站：[https://firebase.google.com/docs/cli/](https://firebase.google.com/docs/cli/)。
- en: Initializing a project directory
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化项目目录
- en: 'We will use the Firebase CLI to perform many trivial tasks, such as running
    the local server or for deployment. Before using it, we need to initialize a project
    directory for the folder which will contain the `firebase.json` file. Usually
    we use the root folder of the Angular project as the Firebase project directory.
    Open the Terminal, navigate to the root folder of our project and execute the
    following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Firebase CLI执行许多琐碎的任务，比如运行本地服务器或部署。在使用之前，我们需要为包含`firebase.json`文件的文件夹初始化项目目录。通常我们使用Angular项目的根文件夹作为Firebase项目目录。打开终端，导航到我们项目的根文件夹，并执行以下命令：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This command will guide you through setting up the project directory. If necessary,
    you can run this command again safely.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将引导您设置项目目录。如果需要，您可以安全地再次运行此命令。
- en: '![Initializing a project directory](Image00137.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![初始化项目目录](Image00137.jpg)'
- en: 'Please answer `Yes` to the question: `Configure as a single-page app (rewrite
    all URLs to /index.html)?` The Firebase CLI creates the `rewrites` settings inside
    the `firebase.json` file. We use a rewrite because we want to show the same content
    for multiple URLs. This is applicable for our application because we configured
    the Angular Component Router using the default HTML 5 `pushState` strategy. It
    produces URLs that are easier for users to understand and it preserves the option
    to do server-side rendering later.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请回答“是”以回答问题：“配置为单页应用程序（将所有URL重写为/index.html）？” Firebase CLI会在`firebase.json`文件中创建`rewrites`设置。我们使用重写是因为我们希望为多个URL显示相同的内容。这适用于我们的应用程序，因为我们使用默认的HTML
    5 `pushState`策略配置了Angular组件路由。它生成了用户更容易理解的URL，并保留了以后进行服务器端渲染的选项。
- en: Importing data into Firebase
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据导入Firebase
- en: 'Before use, we need to import our data into the Firebase database. Open the
    Firebase console, find your project and click to move it in:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用之前，我们需要将我们的数据导入Firebase数据库。打开Firebase控制台，找到您的项目，然后点击移动它：
- en: '![Importing data into Firebase](Image00138.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![将数据导入Firebase](Image00138.jpg)'
- en: 'Find the **Database** menu item on the sidebar and click it. That brings the
    Firebase Realtime Database instance onto the stage. Click the context menu button
    on the right side and, from the drop-down menu, choose **Import JSON** . I prepared
    the `firebase.import.json` file for import, so just select it from the root folder
    of our project and click on **Import** :'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在侧边栏上找到**数据库**菜单项并点击。这将把Firebase实时数据库实例带到舞台上。点击右侧的上下文菜单按钮，从下拉菜单中选择**导入JSON**。我已经准备好了`firebase.import.json`文件供导入，所以只需从项目的根文件夹中选择它，然后点击**导入**：
- en: '![Importing data into Firebase](Image00139.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![将数据导入Firebase](Image00139.jpg)'
- en: The Firebase Realtime Database stores the data as JSON objects. It looks like
    a cloud-hosted JSON tree. In contradistinction to an SQL database, there are no
    tables or records. Each data incorporated to the JSON tree becomes a node in the
    existing JSON structure with an associated key. We can provide our own keys, such
    as `category` or `product` IDs, or Firebase can provide them for us in a moment
    when we save data with a POST request.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase实时数据库将数据存储为JSON对象。它看起来像是一个托管在云端的JSON树。与SQL数据库相反，这里没有表或记录。每个添加到JSON树中的数据都成为现有JSON结构中的一个节点，并带有关联的键。我们可以提供自己的键，例如`category`或`product`
    ID，或者Firebase可以在我们使用POST请求保存数据时为我们提供它们。
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The keys must be UTF-8 encoded and cannot be longer than 768 bytes. They can''t
    contain ., $, #, [,], /, or ASCII control characters such as 0-31 or 127.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须采用UTF-8编码，长度不能超过768字节。它们不能包含.，$，#，[，]，/或ASCII控制字符，如0-31或127。
- en: 'The data structure of the Dream Bean website is quite simple and contains only
    two entities with a product to category relationship. The Firebase Realtime Database
    supports nesting data up to 32 levels deep, and the first temptation is to add
    `category` into `product` , but be careful doing that because, when you retrieve
    data later, Firebase will return the product and all of its child nodes as well.
    Plus, we will have trouble when we try to grant someone read or write access to
    nodes. The best solution here is denormalize our data to keep the structure as
    flat as possible. We can follow these recommendations:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Dream Bean网站的数据结构非常简单，只包含两个实体，具有产品到类别的关系。Firebase实时数据库支持嵌套数据，最多可以深达32级，最初的诱惑是将`category`添加到`product`中，但要小心，因为当您稍后检索数据时，Firebase将返回产品及其所有子节点。此外，当我们尝试授予某人对节点的读取或写入访问权限时，会遇到麻烦。这里的最佳解决方案是对数据进行去规范化，以尽可能保持结构的扁平化。我们可以遵循以下建议：
- en: Split data into separate paths
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据拆分为单独的路径
- en: Add an index or key to your data
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向数据添加索引或键
- en: Use an index or key to fetch relational data
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用索引或键来获取关联数据
- en: 'At the beginning stage, we deliberately added `categoryId` into the product
    entity to quickly and efficiently fetch data by index:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始阶段，我们故意将`categoryId`添加到产品实体中，以便通过索引快速高效地获取数据：
- en: '![Importing data into Firebase](Image00140.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![将数据导入Firebase](Image00140.jpg)'
- en: The Firebase database rules
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Firebase数据库规则
- en: 'Firebase always creates default rules for each new database:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase始终为每个新数据库创建默认规则：
- en: '![The Firebase database rules](Image00141.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![Firebase数据库规则](Image00141.jpg)'
- en: 'The rules of the Firebase Realtime Database are quite flexible and expression
    based. We can use JavaScript-like language to define:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase实时数据库的规则非常灵活且基于表达式。我们可以使用类似JavaScript的语言来定义：
- en: The structure of data
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据结构
- en: The data indexes
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据索引
- en: Secure data with the Firebase Authentication service
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Firebase身份验证服务保护数据
- en: 'By default, the database rules require Firebase authentication and grant full
    read and write permissions only to authenticated users, so it isn''t accessible
    to everyone. We will change the rules to organize read access to everyone but
    keep write access to authenticated users. Rules can be configured in two different
    ways. The easiest way to create an immediate effect is to use the Firebase console,
    so let''s open it, select the **Database** menu from the side bar and choose the
    **Rules**  tab. You should see the text area with the current rules. You can manually
    change them or copy the following rules and paste them into the text area:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，数据库规则要求Firebase身份验证并仅授予完全读写权限给经过身份验证的用户，因此它对每个人都不可访问。我们将更改规则以使每个人都可以读取，但保持写入权限给经过身份验证的用户。规则可以以两种不同的方式进行配置。创建立即生效的最简单方法是使用Firebase控制台，因此让我们打开它，从侧边栏中选择**数据库**菜单，然后选择**规则**选项卡。您应该看到带有当前规则的文本区域。您可以手动更改它们，或者复制以下规则并粘贴到文本区域中：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Click **Publish** to apply the new rules on the database. Another way to manage
    database rules is to create a special JSON file, so the Firebase CLI will use
    this file when we deploy our project into Firebase. Open the Terminal, navigate
    into our project and run the following command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 单击**发布**以将新规则应用于数据库。管理数据库规则的另一种方法是创建一个特殊的JSON文件，这样当我们将项目部署到Firebase时，Firebase
    CLI将使用这个文件。打开终端，进入我们的项目并运行以下命令：
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, choose the **Database: Deploy Firebase Realtime Database Rules** option.
    Leave the default answer to all the questions:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，选择**数据库：部署Firebase实时数据库规则**选项。对所有问题保持默认答案：
- en: '![The Firebase database rules](Image00142.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![Firebase数据库规则](Image00142.jpg)'
- en: 'Open the `database.rules.json` and update it:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`database.rules.json`并更新它：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, once the data's been imported into the database, its time to connect our
    project to it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦数据被导入到数据库，就该将我们的项目连接到它了。
- en: Connecting to Firebase
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到Firebase
- en: To organize communication, we need the **AngularFire2** library to integrate
    Firebase Realtime observers and authentication with Angular2.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了组织通信，我们需要**AngularFire2**库来将Firebase实时观察者和身份验证与Angular2集成。
- en: Installing AngularFire2 and Firebase
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装AngularFire2和Firebase
- en: 'First of all, install the AngularFire2 and Firebase SDK libraries as npm modules:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将AngularFire2和Firebase SDK库安装为npm模块：
- en: '[PRE30]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The next step is to install Typescript 2 locally because AngularFire2 depends
    on it:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在本地安装Typescript 2，因为AngularFire2依赖于它：
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, update the `systemjs.config.js` file with those two libraries because
    they need to be mapped with `SystemJS` for module loading:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用这两个库更新`systemjs.config.js`文件，因为它们需要与`SystemJS`进行映射以进行模块加载：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The AngularFire2 and Firebase setup
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AngularFire2和Firebase设置
- en: 'We need to set up the AngularFire2 module and Firebase configuration before
    use. Open the `app.module.ts` file and import the `AngularFireModule` . Now open
    the web browser, navigate to the Firebase console, and select your project (if
    it was not already open). Next, click on the  **Add Firebase to your app** link:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用之前，我们需要设置AngularFire2模块和Firebase配置。打开`app.module.ts`文件并导入`AngularFireModule`。现在打开Web浏览器，导航到Firebase控制台，并选择您的项目（如果尚未打开）。接下来，单击**将Firebase添加到您的应用程序**链接：
- en: '![The AngularFire2 and Firebase setup](Image00143.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![AngularFire2和Firebase设置](Image00143.jpg)'
- en: 'Firebase creates the initialization code snippet, which we will use in our
    application:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase创建了初始化代码片段，我们将在我们的应用程序中使用：
- en: '![The AngularFire2 and Firebase setup](Image00144.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![AngularFire2和Firebase设置](Image00144.jpg)'
- en: 'Select the initialization configuration and copy to the clipboard. Switch back
    to our project and paste it so our code will look like the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 选择初始化配置并复制到剪贴板。切换回我们的项目并粘贴，这样我们的代码将如下所示：
- en: '[PRE33]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We are ready to use Firebase in our project.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备在我们的项目中使用Firebase。
- en: Getting categories from Firebase
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Firebase获取类别
- en: 'AngularFire2 syncs data as lists with the help of `FirebaseListObservable`
    , so open the `category.service.ts` file and import it:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 'AngularFire2通过`FirebaseListObservable`将数据同步为列表，因此打开`category.service.ts`文件并导入它： '
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We inject the `AngularFire` service into the constructor. It creates the `FirebaseListObservable`
    through the `AngularFire.database` service, as we call it in the `getCategories`
    method with the relative URL.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`AngularFire`服务注入到构造函数中。通过`AngularFire.database`服务创建`FirebaseListObservable`，我们在`getCategories`方法中使用相对URL进行调用。
- en: Getting products from Firebase
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Firebase获取产品
- en: 'It''s a different story for fetching data for the products. It is not enough
    to have only one URL, we need to use query parameters. The list method of the
    `AngularFire.database` service has a second parameter object that we can use to
    specify the query parameters:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于获取产品数据来说情况就不同了。仅有一个URL是不够的，我们需要使用查询参数。`AngularFire.database`服务的列表方法有一个第二个参数对象，我们可以用它来指定查询参数：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We use Firebase Realtime Database queries to retrieve data based on various
    factors selectively. To construct a query for `products` , we start by specifying
    how we want the data to be ordered using one of the ordering functions:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Firebase实时数据库查询有选择地检索基于各种因素的数据。要为`products`构建查询，我们首先指定如何使用其中一个排序函数对数据进行排序：
- en: The `orderByChild` retrieves ordered nodes by a child key
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orderByChild`按子键检索排序的节点'
- en: The `orderByKey` retrieves ordered nodes by their keys
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orderByKey`按其键检索排序的节点'
- en: The `orderByValue` retrieves ordered nodes by the value of their children
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orderByValue`按其子节点的值检索排序的节点'
- en: The `orderByPriority` retrieves ordered nodes by priority value
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orderByPriority`按优先级值检索排序的节点'
- en: 'The result of the `orderByChild` function for a specified child key will be
    ordered as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 指定子键的`orderByChild`函数的结果将按以下顺序排序：
- en: Children with a null value
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有空值的子节点
- en: Children with a false Boolean value
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有false布尔值的子节点
- en: Children with a true Boolean value
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有true布尔值的子节点
- en: Children with a numeric value sorted in ascending order
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有按升序排序的数值的子节点
- en: Children with a string sorted lexicographically in ascending order
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有按字典顺序升序排序的字符串的子节点
- en: Children with objects sorted lexicographically by key name in ascending order
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有按键名按升序排序的对象的子节点
- en: Note
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Firebase database keys can only be strings.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase数据库键只能是字符串。
- en: 'The result of the `orderByKey` function will be returned in ascending order
    by key name as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`orderByKey`函数的结果将按键名升序返回：'
- en: Children with a key that can be parsed as a 32-bit integer come first and are
    sorted in ascending order
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以解析为32位整数的键的子节点首先出现，并按升序排序
- en: Children with a string value key come next and are sorted in ascending order
    lexicographically
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有字符串值键的子节点紧随其后，并按字典顺序升序排序
- en: The result of the `orderByValue` function will be ordered by its value.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`orderByValue`函数的结果将按其值排序。'
- en: Note
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Firebase database priority values can only be numbers and strings.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase数据库优先级值只能是数字和字符串。
- en: 'The result of the `orderByPriority` function will be the ordering of children,
    and is determined by their priority and key as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`orderByPriority`函数的结果将是子节点的排序，由其优先级和键决定如下：'
- en: Children with no priorities are sorted by key
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有优先级的子节点按键排序
- en: Children with a number are sorted numerically
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有数字的子节点按数字顺序排序
- en: Children with a string are sorted lexicographically
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有字符串的子节点按字典顺序排序
- en: Children who have the same priority are sorted by key
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有相同优先级的子节点按键排序
- en: 'After we''ve decided how the retrieved data should be ordered, we can use the
    limit or range methods to conduct complex queries:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定检索到的数据应该如何排序之后，我们可以使用限制或范围方法进行复杂的查询：
- en: The `limitToFirst` creates a query limited to the first set number of children
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limitToFirst` 创建一个查询，限制为第一组子元素'
- en: The `limitToLast` creates a query limited to the last set number of children
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limitToLast` 创建一个查询，限制为最后一组子元素'
- en: The `startAt` creates a query with a particular starting point
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startAt` 创建一个具有特定起始点的查询'
- en: The `endAt` creates a query with a specific ending point
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endAt` 创建一个具有特定结束点的查询'
- en: The `equalTo` creates a query with a particular matching value
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equalTo` 创建一个具有特定匹配值的查询'
- en: We use the `limitToFirst` and `limitToLast` queries to set a maximum number
    of children the Firebase will return. Using `startAt` and `endAt` queries helps
    us to choose the arbitrary starting and ending points in the JSON tree. The `equalTo`
    query filters data based on **exact matching** .
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `limitToFirst` 和 `limitToLast` 查询来设置 Firebase 将返回的最大子元素数量。使用 `startAt`
    和 `endAt` 查询帮助我们在 JSON 树中选择任意的起始点和结束点。`equalTo` 查询根据**精确匹配**过滤数据。
- en: 'When we select the category we create a query based on a combination, `orderByChild`
    and `equalTo` , because we know the exact value of `categoryId` to filter:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们选择类别时，我们基于组合创建一个查询，`orderByChild` 和 `equalTo`，因为我们知道 `categoryId` 的确切值来进行过滤：
- en: '[PRE36]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When the user searches by inputting the title, we use a combination of `orderByChild`
    , `startAt` , and `endAt` :'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户通过输入标题进行搜索时，我们使用 `orderByChild`、`startAt` 和 `endAt` 的组合：
- en: '[PRE37]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `\uf8ff` character used in the preceding query helps us create a trick.
    It's a very high value in the Unicode range, and because it's after most regular
    characters in Unicode, the query matches all values that start with the user's
    input value.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的查询中使用的 `\uf8ff` 字符帮助我们创建一个技巧。它是 Unicode 范围内的一个非常高的值，因为它在大多数常规字符之后，所以查询匹配以用户输入值开头的所有值。
- en: Deploying the application to Firebase
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将应用程序部署到 Firebase
- en: 'Our application has only static content, and that means that we can deploy
    it to Firebase Hosting. We can do this with a single command:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用只有静态内容，这意味着我们可以将其部署到 Firebase Hosting。我们可以用一条命令来做到这一点：
- en: '[PRE38]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The Firebase CLI deploys our web application to the domain: `https://<your-firebase-app>.firebaseapp.com`
    .'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase CLI 将我们的 Web 应用部署到域名：`https://<your-firebase-app>.firebaseapp.com`。
- en: 'We can manage and rollback deployments from the Firebase console:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从 Firebase 控制台管理和回滚部署：
- en: '![Deploying the application to Firebase](Image00145.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![将应用程序部署到 Firebase](Image00145.jpg)'
- en: Tip
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can find the source code for this chapter at `chapter_9/4.ecommerce-firebase`
    .
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `chapter_9/4.ecommerce-firebase` 找到本章的源代码。
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discovered what data persistence is, and how important it
    is in client to server communications. We started with a brief tour of the Web
    APIs before diving deeper into REST to provide a reminder of the main principles
    of both.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们发现了数据持久性是什么，以及在客户端到服务器通信中它有多重要。我们从对 Web API 的简要介绍开始，然后深入研究 REST，以提醒主要原则。
- en: We looked at Angular 2's departure from the `HttpModule` and we discussed how
    to use it to organize client to server communications. As a bonus, we learnt that
    we can use the in-memory web API to create proofs of concept, wireframes, or demos.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看了 Angular 2 从 `HttpModule` 的离开，并讨论了如何使用它来组织客户端到服务器的通信。作为奖励，我们了解到我们可以使用内存
    Web API 来创建概念验证、线框或演示。
- en: Observables are a proposed feature for JavaScript version ES2016 (ES7), and
    we talked about the RxJS polyfill library used in Angular 2 with Observables to
    help us deal with the asynchronous nature of our applications.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象是 JavaScript 版本 ES2016（ES7）的一个提议特性，我们讨论了在 Angular 2 中使用 RxJS polyfill 库与可观察对象来帮助我们处理应用程序的异步特性。
- en: Firebase is a real-time no-SQL JSON database which keeps any piece of data accessible
    by URL. Firebase contains SDK for different platforms, such JavaScript for the
    Web, IOS, and Android. We demonstrated how to use it as a persistence layer of
    our application.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase是一个实时的无SQL JSON数据库，可以通过URL访问任何数据。Firebase包含不同平台的SDK，比如Web的JavaScript，IOS和Android。我们演示了如何将其用作应用程序的持久层。
- en: In [Chapter 10](text00099.html#page "Chapter 10. Advanced Angular Techniques")
    , *Advanced Angular Techniques* , we will secure our data with the help of the
    Firebase platform. We will learn how to install `ng2-bootstrap` and how this will
    enable us to create directives in an easier way. Finally, we will end by building
    the project we started to develop in previous chapters.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](text00099.html#page "Chapter 10. Advanced Angular Techniques")中，*高级Angular技术*，我们将借助Firebase平台保护我们的数据。我们将学习如何安装`ng2-bootstrap`，以及这将如何使我们更容易地创建指令。最后，我们将结束在之前章节中开始开发的项目。
- en: 读累了记得休息一会哦~
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**公众号：古德猫宁李**'
- en: 电子书搜索下载
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书单分享
- en: 书友学习交流
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
- en: 电子书搜索下载
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
