<html><head></head><body>
  <div id="_idContainer040" class="Basic-Text-Frame">
    <h1 class="chapterNumber">2</h1>
    <h1 id="_idParaDest-31" class="chapterTitle">Rendering with JSX</h1>
    <p class="normal">This chapter will introduce you to <strong class="keyWord">JSX</strong>, which<a id="_idIndexMarker058"/> is the XML/HTML markup syntax that’s embedded in your JavaScript code and used to declare your React components. At the lowest level, you’ll use HTML markup to describe the pieces of your UI. Building React applications involves organizing these pieces of HTML markup into components. In React, creating a component allows you to define custom elements that extend beyond basic HTML markup. These custom elements, or components, are defined using JSX, which then translates them into standard HTML elements for the browser. This ability to create and reuse custom components is a core feature of React, enabling more dynamic and complex UIs. This is where React gets interesting – having your own JSX tags that can use JavaScript expressions to bring your components to life. JSX is the language used to describe UIs built using React.</p>
    <p class="normal">In this chapter, we’ll cover the following:</p>
    <ul>
      <li class="bulletList">Your first JSX content</li>
      <li class="bulletList">Rendering HTML</li>
      <li class="bulletList">Creating your own JSX elements</li>
      <li class="bulletList">Using JavaScript expressions</li>
      <li class="bulletList">Building fragments of JSX</li>
    </ul>
    <h1 id="_idParaDest-32" class="heading-1">Technical requirements</h1>
    <p class="normal">The code for this chapter can be found in the following directory of the accompanying GitHub repository: <a href="https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter02"><span class="url">https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter02</span></a>.</p>
    <h1 id="_idParaDest-33" class="heading-1">Your first JSX content</h1>
    <p class="normal">In this<a id="_idIndexMarker059"/> section, we’ll implement the obligatory <code class="inlineCode">Hello World</code> JSX application. This initial dive is just the beginning – it’s a simple yet effective way to get acquainted with the syntax and its capabilities. As we progress, we’ll delve into more complex and nuanced examples, demonstrating the power and flexibility of JSX in building React applications. We’ll also discuss what makes this syntax work well for declarative UI structures.</p>
    <h2 id="_idParaDest-34" class="heading-2">Hello JSX</h2>
    <p class="normal">Without <a id="_idIndexMarker060"/>further ado, here’s your first JSX application:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;
<span class="hljs-keyword">const</span> root = <span class="hljs-title">ReactDOM</span>.<span class="hljs-title">createRoot</span>(<span class="hljs-variable">document</span>.<span class="hljs-title">getElementById</span>(<span class="hljs-string">"root"</span>));
root.<span class="hljs-title">render</span>(
  <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
    Hello, <span class="hljs-tag">&lt;</span><span class="hljs-name">strong</span><span class="hljs-tag">&gt;</span>JSX<span class="hljs-tag">&lt;/</span><span class="hljs-name">strong</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
);
</code></pre>
    <p class="normal">Let’s walk through what’s happening here.</p>
    <p class="normal">The <code class="inlineCode">render()</code> function takes JSX as an argument and renders it to the DOM node passed to <code class="inlineCode">ReactDOM.createRoot()</code>.</p>
    <p class="normal">The actual JSX content in this example renders a paragraph with some bold text inside. There’s nothing fancy going on here, so we could have just inserted this markup into the DOM directly as a plain string. However, the aim of this example is to show the basic steps involved in getting JSX rendered onto the page.</p>
    <p class="normal">Under the hood, JSX is not directly understood by web browsers and needs to be transformed into standard JavaScript code that browsers can execute. This transformation is typically done <a id="_idIndexMarker061"/>using a tool<a id="_idIndexMarker062"/> like <strong class="keyWord">Vite</strong> or <strong class="keyWord">Babel</strong>. When Vite processes JSX code, it compiles the JSX down to <code class="inlineCode">React.createElement()</code> calls. These calls create JavaScript objects that represent the virtual DOM elements. For example, the JSX expression in the example above is compiled into this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;
<span class="hljs-keyword">const</span> root = <span class="hljs-title">ReactDOM</span>.<span class="hljs-title">createRoot</span>(<span class="hljs-variable">document</span>.<span class="hljs-title">getElementById</span>(<span class="hljs-string">"root"</span>));
root.<span class="hljs-title">render</span>(
  <span class="hljs-title">React</span>.<span class="hljs-title">createElement</span>(
    <span class="hljs-string">"p"</span>,
    <span class="hljs-literal">null</span>,
    <span class="hljs-string">"</span><span class="hljs-string">Hello, "</span>,
    <span class="hljs-title">React</span>.<span class="hljs-title">createElement</span>(<span class="hljs-string">"strong"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"JSX"</span>)
  )
);
</code></pre>
    <p class="normal">The first <a id="_idIndexMarker063"/>argument to <code class="inlineCode">React.createElement</code> is the type of the element (such as a string like <code class="inlineCode">div</code> or <code class="inlineCode">p</code> for DOM elements, or a React component for composite components). The second argument is an object containing the props for this element, and any subsequent arguments are the children of this element. This transformation is done by Vite under the hood, and you never write such code.</p>
    <p class="normal">These objects created by <code class="inlineCode">React.createElement()</code>, known as <strong class="keyWord">React elements</strong>, describe the structure and properties of a <a id="_idIndexMarker064"/>UI component in an object format that React can work with. React then uses these objects to construct the actual DOM and keep it up to date. This process involves a reconciliation algorithm that efficiently updates the DOM to match the React elements. When the state of a component changes, React calculates the minimal set of changes required to update the DOM, rather than re-rendering the entire component. This makes updates much more efficient and is one of the key advantages of using React.</p>
    <p class="normal">Before we move forward with more in-depth code examples, let’s take a moment to reflect on our <code class="inlineCode">Hello World</code> example. The JSX content was short and simple. It was also declarative because it described <em class="italic">what</em> to render, not <em class="italic">how</em> to render it. Specifically, by looking at the JSX, you can see that this component will render a paragraph and some bold text within it. If this were done imperatively, there would probably be some more steps involved, and they would probably need to be performed in a specific order.</p>
    <p class="normal">The example we just implemented should give you a feel for what declarative React is all about. As we move forward in this chapter and throughout the book, the JSX markup will grow more elaborate. However, it’s always going to describe what is in the UI.</p>
    <p class="normal">The <code class="inlineCode">render()</code> function tells React to take your JSX markup and update the UI in the most efficient way possible. This is how React enables you to declare the structure of your UI without having to think about carrying out ordered steps to update elements on the screen, an approach that often leads to bugs. Out of the box, React supports the standard HTML tags that you would find on any HTML page, such as <code class="inlineCode">div</code>, <code class="inlineCode">p</code>, <code class="inlineCode">h1</code>, <code class="inlineCode">ul</code>, <code class="inlineCode">li</code>, and others.</p>
    <p class="normal">Now that we have discovered what JSX is, how it works, and what declarative idea it follows, let’s explore how we can render plain HTML markup and what conventions we should follow.</p>
    <h1 id="_idParaDest-35" class="heading-1">Rendering HTML</h1>
    <p class="normal">At the end <a id="_idIndexMarker065"/>of the day, the job of a React component is to render HTML in the DOM browser. This is why JSX has support for HTML tags out of the box. In this section, we’ll look at some code that renders a few of the available HTML tags. Then, we’ll cover some of the conventions that are typically followed in React projects when HTML tags are used.</p>
    <h2 id="_idParaDest-36" class="heading-2">Built-in HTML tags</h2>
    <p class="normal">When we<a id="_idIndexMarker066"/> render JSX, element tags reference React components. Since it would be tedious to have to create components for HTML elements, React comes with HTML components. We can render any HTML tag in our JSX, and the output will be just as we’d expect.</p>
    <p class="normal">Now, let’s try rendering some of these tags:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;
<span class="hljs-keyword">const</span> root = <span class="hljs-title">ReactDOM</span>.<span class="hljs-title">createRoot</span>(<span class="hljs-variable">document</span>.<span class="hljs-title">getElementById</span>(<span class="hljs-string">"root"</span>));
root.<span class="hljs-title">render</span>(
  <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> /&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">code</span><span class="hljs-tag"> /&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span><span class="hljs-tag"> /&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">label</span><span class="hljs-tag"> /&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag"> /&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">pre</span><span class="hljs-tag"> /&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">select</span><span class="hljs-tag"> /&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">table</span><span class="hljs-tag"> /&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">ul</span><span class="hljs-tag"> /&gt;	</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
);
</code></pre>
    <p class="normal">Don’t worry about the formatting of the rendered output for this example. We’re making sure that we can render arbitrary HTML tags, and they render as expected, without <a id="_idIndexMarker067"/>any special definitions and imports.</p>
    <div class="note">
      <p class="normal">You may have noticed the surrounding <code class="inlineCode">&lt;div&gt;</code> tag, grouping together all of the other tags as its children. This is because React needs a root element to render. Later in the chapter, you’ll learn how to render adjacent elements without wrapping them in a parent element.</p>
    </div>
    <p class="normal">HTML elements rendered using JSX closely follow regular HTML element syntax, with a few subtle differences regarding case-sensitivity and attributes.</p>
    <h2 id="_idParaDest-37" class="heading-2">HTML tag conventions</h2>
    <p class="normal">When<a id="_idIndexMarker068"/> you render HTML tags in JSX markup, the expectation is that you’ll use lowercase for the tag name. In fact, capitalizing the name of an HTML tag will fail. Tag names are case-sensitive and non-HTML elements are capitalized. This way, it’s easy to scan the markup and spot the built-in HTML elements versus everything else.</p>
    <p class="normal">You can also pass HTML elements any of their standard properties. When you pass them something unexpected, a warning about the unknown property is logged. Here’s an example that illustrates these ideas:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;
<span class="hljs-keyword">const</span> root = <span class="hljs-title">ReactDOM</span>.<span class="hljs-title">createRoot</span>(<span class="hljs-variable">document</span>.<span class="hljs-title">getElementById</span>(<span class="hljs-string">"</span><span class="hljs-string">root"</span>));
root.<span class="hljs-title">render</span>(
  <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">title</span><span class="hljs-tag">=</span><span class="hljs-string">"My Button"</span><span class="hljs-tag"> </span><span class="hljs-attr">foo</span><span class="hljs-tag">=</span><span class="hljs-string">"bar"</span><span class="hljs-tag">&gt;</span>
    My Button
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
);
root.<span class="hljs-title">render</span>(<span class="hljs-tag">&lt;</span><span class="hljs-name">Button</span><span class="hljs-tag"> /&gt;</span>);
</code></pre>
    <p class="normal">When you run this example, it will fail to compile because React doesn’t know about the <code class="inlineCode">&lt;Button&gt;</code> element; it only knows about <code class="inlineCode">&lt;button&gt;</code>.</p>
    <p class="normal">You can use any valid HTML tags as JSX tags, as long as you remember that they’re case-sensitive and that you need to pass the correct attribute names. In addition to simple HTML tags that only have attribute values, you can use more semantic HTML tags to describe the structure of your page content.</p>
    <h2 id="_idParaDest-38" class="heading-2">Describing UI structures</h2>
    <p class="normal">JSX is<a id="_idIndexMarker069"/> capable of describing screen elements in a way that ties them together to form a complete UI structure. Let’s look at some JSX markup that declares a more elaborate structure than a single paragraph:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;
<span class="hljs-keyword">const</span> root = <span class="hljs-title">ReactDOM</span>.<span class="hljs-title">createRoot</span>(<span class="hljs-variable">document</span>.<span class="hljs-title">getElementById</span>(<span class="hljs-string">"root"</span>));
root.<span class="hljs-title">render</span>(
  <span class="hljs-tag">&lt;</span><span class="hljs-name">section</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">header</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>A Header<span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">header</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">nav</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">a</span><span class="hljs-tag"> </span><span class="hljs-attr">href</span><span class="hljs-tag">=</span><span class="hljs-string">"item"</span><span class="hljs-tag">&gt;</span>Nav Item<span class="hljs-tag">&lt;/</span><span class="hljs-name">a</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">nav</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">main</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>The main content...<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">main</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">footer</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">small</span><span class="hljs-tag">&gt;</span><span class="hljs-symbol">&amp;copy;</span> 2024<span class="hljs-tag">&lt;/</span><span class="hljs-name">small</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">footer</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">section</span><span class="hljs-tag">&gt;</span>
);
</code></pre>
    <p class="normal">This JSX markup describes a fairly sophisticated UI structure. Yet, it’s easier to read than imperative code because it’s HTML, and HTML is good for concisely expressing a hierarchical structure. This is how we want to think of our UI when it needs to change – not as an individual element or property but the UI as a whole.</p>
    <p class="normal">Here is what the rendered content looks like:</p>
    <figure class="mediaobject"><img src="../Images/B19636_02_01.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 2.1: Describing HTML tag structures using JSX syntax</p>
    <p class="normal">There are<a id="_idIndexMarker070"/> a lot of semantic elements in this markup describing the structure of the UI. For example, the <code class="inlineCode">&lt;header&gt;</code> element describes the top part of the page where the title is, and the <code class="inlineCode">&lt;main&gt;</code> element describes where the main page content goes. This type of complex structure makes it clearer for developers to reason about. But before we start implementing dynamic JSX markup, let’s create some of our own JSX components.</p>
    <h1 id="_idParaDest-39" class="heading-1">Creating your own JSX elements</h1>
    <p class="normal">Components <a id="_idIndexMarker071"/>are the fundamental building blocks of React. In fact, they can be thought of as the vocabulary of JSX markup, allowing you to create complex interfaces through reusable, encapsulated elements. In this section, we’ll delve into how to create your own components and encapsulate HTML markup within them.</p>
    <h2 id="_idParaDest-40" class="heading-2">Encapsulating HTML</h2>
    <p class="normal">We <a id="_idIndexMarker072"/>create new JSX elements so that we can encapsulate larger structures. This means that instead of having to type out complex markup, you can use your custom tag. The React component returns the JSX that goes where the tag is used. Let’s look at the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span>() {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">section</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>My Component<span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Content in my component...<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">section</span><span class="hljs-tag">&gt;</span>
  );
}
<span class="hljs-keyword">const</span> root = <span class="hljs-title">ReactDOM</span>.<span class="hljs-title">createRoot</span>(<span class="hljs-variable">document</span>.<span class="hljs-title">getElementById</span>(<span class="hljs-string">"root"</span>));
root.<span class="hljs-title">render</span>(<span class="hljs-tag">&lt;</span><span class="hljs-name">MyComponent</span><span class="hljs-tag"> /&gt;</span>);
</code></pre>
    <p class="normal">Here’s what<a id="_idIndexMarker073"/> the rendered output looks like:</p>
    <figure class="mediaobject"><img src="../Images/B19636_02_02.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 2.2: A component rendering encapsulated HTML markup</p>
    <p class="normal">This is the first React component that we’ve implemented, so let’s take a moment to dissect what’s going on here. We created a function called <code class="inlineCode">MyComponent</code>, in the return statement of which we put our HTML tags. This is how we create a React component that is used as a new JSX element. As you can see in the call to <code class="inlineCode">render()</code>, you’re rendering a <code class="inlineCode">&lt;MyComponent&gt;</code> element.</p>
    <p class="normal">The HTML that this component encapsulates is returned from the function we created. In this case, when the JSX is rendered by <code class="inlineCode">react-dom</code>, it’s replaced by a <code class="inlineCode">&lt;section&gt;</code> element and everything within it.</p>
    <div class="note">
      <p class="normal">When React renders JSX, any custom elements that you use must have their corresponding React component within the same scope. In the preceding example, the <code class="inlineCode">MyComponent</code> function was declared in the same scope as the call to <code class="inlineCode">render()</code>, so everything worked as expected. Usually, you’ll import components, adding them to the appropriate scope. You’ll see more of this as you progress through the book.</p>
    </div>
    <p class="normal">HTML elements<a id="_idIndexMarker074"/> such as <code class="inlineCode">&lt;div&gt;</code> often take nested child elements. Let’s see whether we can do the same with JSX elements, which we create by implementing components.</p>
    <h2 id="_idParaDest-41" class="heading-2">Nested elements</h2>
    <p class="normal">Using JSX markup is<a id="_idIndexMarker075"/> useful for describing UI structures that have parent-child relationships. Child elements are created by nesting them within another component: the parent.</p>
    <p class="normal">For example, a <code class="inlineCode">&lt;li&gt;</code> tag is only valid as the child of a <code class="inlineCode">&lt;ul&gt;</code> tag or a <code class="inlineCode">&lt;ol&gt;</code> tag – you’re probably going to make similar nested structures with your own React components. For this, you need to use the <code class="inlineCode">children</code> property. Let’s see how this works. Here’s the JSX markup:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title">MySection</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"./MySection"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title">MyButton</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"./MyButton"</span>;
<span class="hljs-keyword">const</span> root = <span class="hljs-title">ReactDOM</span>.<span class="hljs-title">createRoot</span>(<span class="hljs-variable">document</span>.<span class="hljs-title">getElementById</span>(<span class="hljs-string">"root"</span>));
root.<span class="hljs-title">render</span>(
  <span class="hljs-tag">&lt;</span><span class="hljs-name">MySection</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">MyButton</span><span class="hljs-tag">&gt;</span>My Button Text<span class="hljs-tag">&lt;/</span><span class="hljs-name">MyButton</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">MySection</span><span class="hljs-tag">&gt;</span>
);
</code></pre>
    <p class="normal">You’re importing two of your own React components: <code class="inlineCode">MySection</code> and <code class="inlineCode">MyButton</code>.</p>
    <p class="normal">Now, if you look at the JSX markup, you’ll notice that <code class="inlineCode">&lt;MyButton&gt;</code> is a child of <code class="inlineCode">&lt;MySection&gt;</code>. You’ll also notice that the <code class="inlineCode">MyButton</code> component accepts text as its child, instead of more JSX elements.</p>
    <p class="normal">Let’s see how these components work, starting with <code class="inlineCode">MySection</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">MySection</span>(<span class="hljs-params">props</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">section</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">h2</span><span class="hljs-tag">&gt;</span>My Section<span class="hljs-tag">&lt;/</span><span class="hljs-name">h2</span><span class="hljs-tag">&gt;</span>
      {props.children}
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">section</span><span class="hljs-tag">&gt;</span>
  );
}
</code></pre>
    <p class="normal">This <a id="_idIndexMarker076"/>component renders a standard <code class="inlineCode">&lt;section&gt;</code> HTML element, a heading, and then <code class="inlineCode">{props.children}</code>. It’s this last piece that allows components to access nested elements or text and render them.</p>
    <div class="note">
      <p class="normal">The two braces used in the preceding example are used for JavaScript expressions. I’ll touch on more details of the JavaScript expression syntax found in JSX markup in the following section.</p>
    </div>
    <p class="normal">Now, let’s look at the <code class="inlineCode">MyButton</code> component:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">MyButton</span>(<span class="hljs-params">props</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>{props.children}<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>;
}
</code></pre>
    <p class="normal">This component uses the exact same pattern as <code class="inlineCode">MySection</code>; it takes the <code class="inlineCode">{props.children}</code> value and surrounds it with markup. React handles the details for you. In this example, the button text is a child of <code class="inlineCode">MyButton</code>, which is, in turn, a child of <code class="inlineCode">MySection</code>. However, the button text is transparently passed through <code class="inlineCode">MySection</code>. In other words, we didn’t have to write any code in <code class="inlineCode">MySection</code> to make sure that <code class="inlineCode">MyButton</code> got its text. <em class="italic">Pretty cool, right?</em> Here’s what the rendered output looks like:</p>
    <figure class="mediaobject"><img src="../Images/B19636_02_03.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 2.3: A button element rendered using child JSX values</p>
    <p class="normal">You now know how to build your own React components that introduce new JSX tags in your markup. The components that we’ve looked at so far in this chapter have been static. That is, once we rendered them, they were never updated. JavaScript expressions are the dynamic pieces of JSX that give different output based on conditions.</p>
    <h1 id="_idParaDest-42" class="heading-1">Using JavaScript expressions</h1>
    <p class="normal">As you <a id="_idIndexMarker077"/>saw in the preceding section, JSX has a special syntax that allows you to embed JavaScript expressions. Any time React renders JSX content, expressions in the markup are evaluated. This feature is at the heart of JSX’s dynamism; it enables the content and attributes of your components to change in response to different data or state conditions. Each time React renders or re-renders JSX content, these embedded expressions are evaluated, allowing the displayed UI to reflect current data and state. You’ll also learn how to map collections of data to JSX elements.</p>
    <h2 id="_idParaDest-43" class="heading-2">Dynamic property values and text</h2>
    <p class="normal">Some HTML property<a id="_idIndexMarker078"/> or text values are static, meaning that they don’t change as JSX markup is re-rendered. Other values, the values of properties or text, are based on data that is found elsewhere in the application. Remember, React is just the view layer. Let’s look at an example so that you can get a feel for what the JavaScript expression syntax looks like in JSX markup:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"</span><span class="hljs-string">react-dom"</span>;
<span class="hljs-keyword">const</span> enabled = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">const</span> text = <span class="hljs-string">"A Button"</span>;
<span class="hljs-keyword">const</span> placeholder = <span class="hljs-string">"input value..."</span>;
<span class="hljs-keyword">const</span> size = <span class="hljs-number">50</span>;
<span class="hljs-keyword">const</span> root = <span class="hljs-title">ReactDOM</span>.<span class="hljs-title">createRoot</span>(<span class="hljs-variable">document</span>.<span class="hljs-title">getElementById</span>(<span class="hljs-string">"root"</span>));
root.<span class="hljs-title">render</span>(
  <span class="hljs-tag">&lt;</span><span class="hljs-name">section</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">disabled</span><span class="hljs-tag">=</span><span class="hljs-string">{!enabled}</span><span class="hljs-tag">&gt;</span>{text}<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span><span class="hljs-tag"> </span><span class="hljs-attr">placeholder</span><span class="hljs-tag">=</span><span class="hljs-string">{placeholder}</span><span class="hljs-tag"> </span><span class="hljs-attr">size</span><span class="hljs-tag">=</span><span class="hljs-string">{size}</span><span class="hljs-tag"> /&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">section</span><span class="hljs-tag">&gt;</span>
);
</code></pre>
    <p class="normal">Anything that is a valid JavaScript expression, including nested JSX, can go in between the curly braces: <code class="inlineCode">{}</code>. For properties and text, this is often a variable name or object property. Notice, in this example, that the <code class="inlineCode">!enabled</code> expression computes a Boolean value. Here’s what the rendered output looks like:</p>
    <figure class="mediaobject"><img src="../Images/B19636_02_04.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 2.4: Dynamically changing the property value of a button</p>
    <div class="note">
      <p class="normal">If you’re following along with the downloadable companion code, which I strongly recommend doing, try playing around with these values and seeing how the rendered HTML changes: <a href="https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter02"><span class="url">https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter02</span></a></p>
    </div>
    <p class="normal">Primitive JavaScript <a id="_idIndexMarker079"/>values are straightforward to use in JSX syntax. Obviously, we can use more complex values such as objects and arrays in the JSX, as well as functions to handle events. Let’s explore this.</p>
    <h2 id="_idParaDest-44" class="heading-2">Handling events</h2>
    <p class="normal">In React, you<a id="_idIndexMarker080"/> can easily pass functions to components’ properties to handle user interactions such as button clicks, form submissions, and mouse movements. This allows you to create interactive and responsive UIs. React provides a convenient way to attach event handlers directly to components using a syntax, similar to how you would use the <code class="inlineCode">addEventListener</code> and <code class="inlineCode">removeEventListener</code> methods in traditional JavaScript.</p>
    <p class="normal">To illustrate this, let’s consider an example where we want to handle a button-click event in a React component:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title">handleClick</span> = () =&gt; {
  <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-string">"Button clicked!"</span>);
};
<span class="hljs-keyword">const</span> root = <span class="hljs-title">ReactDOM</span>.<span class="hljs-title">createRoot</span>(<span class="hljs-variable">document</span>.<span class="hljs-title">getElementById</span>(<span class="hljs-string">"root"</span>));
root.<span class="hljs-title">render</span>(
  <span class="hljs-tag">&lt;</span><span class="hljs-name">section</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{handleClick}</span><span class="hljs-tag">&gt;</span>Click me<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">section</span><span class="hljs-tag">&gt;</span>
);
</code></pre>
    <p class="normal">In this <a id="_idIndexMarker081"/>example, we define a function called <code class="inlineCode">handleClick</code> that will be called when the button is clicked. We then attach this function as an event handler to the <code class="inlineCode">onClick</code> property of the <code class="inlineCode">&lt;button&gt;</code> component. Whenever the button is clicked, React will invoke the <code class="inlineCode">handleClick</code> function.</p>
    <p class="normal">Compared to using <code class="inlineCode">addEventListener</code> and <code class="inlineCode">removeEventListener</code> in traditional JavaScript, React abstracts away some of the complexities. With React’s event handling, you don’t have to worry about manually attaching and detaching event listeners to/from DOM elements. React manages<a id="_idIndexMarker082"/> the <strong class="keyWord">event delegation</strong> and provides a more <strong class="keyWord">declarative</strong> approach to handling events within components.</p>
    <div class="note">
      <p class="normal">React implements event delegation by default to optimize performance. Instead of attaching event handlers to each individual element, React attaches a single event handler to the root of the application (or a parent component). When an event is triggered on a child element, it bubbles up the component tree until it reaches the parent with the event handler. React’s synthetic event system then determines which component should handle the event based on the target property of the event object. This allows React to efficiently manage events without needing to attach handlers to every single element.</p>
    </div>
    <p class="normal">By using this approach, you can easily pass events to child components, handle them in parent components, or even propagate events through multiple levels of nested components. This helps in building a modular and reusable component architecture. We’ll get to see this in action in the next chapter.</p>
    <div class="note">
      <p class="normal">In addition to the <code class="inlineCode">onClick</code> event, React supports a wide range of other events, such as <code class="inlineCode">onChange</code>, <code class="inlineCode">onSubmit</code>, <code class="inlineCode">onMouseOver</code>, and all standard events. You can attach event handlers to various elements like buttons, input fields, checkboxes, and so on.</p>
    </div>
    <p class="normal">Note that React promotes a unidirectional data flow, which means that data flows from parent components to child components. To pass data or information from child components back to the parent component, you can define callbacks as props and invoke them <a id="_idIndexMarker083"/>with the necessary data. In the upcoming chapters of this book, we will delve deeper into event handling in React and how to create custom callbacks.</p>
    <h2 id="_idParaDest-45" class="heading-2">Mapping collections to elements</h2>
    <p class="normal">Sometimes, you <a id="_idIndexMarker084"/>need to write JavaScript expressions that change the structure of your markup. In the preceding section, you learned how to use JavaScript expression syntax to dynamically change the property values of JSX elements. What about when you need to add or remove elements based on JavaScript collections?</p>
    <div class="note">
      <p class="normal">Throughout the book, when I refer to a JavaScript collection, I’m referring to both plain objects and arrays, or, more generally, anything that’s <em class="italic">iterable</em>.</p>
    </div>
    <p class="normal">The best way to dynamically control JSX elements is to map them from a collection. Let’s look at an example of how this is done:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;
<span class="hljs-keyword">const</span> array = [<span class="hljs-string">"First"</span>, <span class="hljs-string">"Second"</span>, <span class="hljs-string">"Third"</span>];
<span class="hljs-keyword">const</span> object = {
  <span class="hljs-attr">first</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">second</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">third</span>: <span class="hljs-number">3</span>,
};
<span class="hljs-keyword">const</span> root = <span class="hljs-title">ReactDOM</span>.<span class="hljs-title">createRoot</span>(<span class="hljs-variable">document</span>.<span class="hljs-title">getElementById</span>(<span class="hljs-string">"root"</span>));
root.<span class="hljs-title">render</span>(
  <span class="hljs-tag">&lt;</span><span class="hljs-name">section</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>Array<span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
      {array.map((i) =&gt; (
        <span class="hljs-tag">&lt;</span><span class="hljs-name">li</span><span class="hljs-tag"> </span><span class="hljs-attr">key</span><span class="hljs-tag">=</span><span class="hljs-string">{i}</span><span class="hljs-tag">&gt;</span>{i}<span class="hljs-tag">&lt;/</span><span class="hljs-name">li</span><span class="hljs-tag">&gt;</span>
      ))}
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>Object<span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
      {Object.keys(object).map((i) =&gt; (
        <span class="hljs-tag">&lt;</span><span class="hljs-name">li</span><span class="hljs-tag"> </span><span class="hljs-attr">key</span><span class="hljs-tag">=</span><span class="hljs-string">{i}</span><span class="hljs-tag">&gt;</span>
          <span class="hljs-tag">&lt;</span><span class="hljs-name">strong</span><span class="hljs-tag">&gt;</span>{i}: <span class="hljs-tag">&lt;/</span><span class="hljs-name">strong</span><span class="hljs-tag">&gt;</span>
          {object[i]}
        <span class="hljs-tag">&lt;/</span><span class="hljs-name">li</span><span class="hljs-tag">&gt;</span>
      ))}
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">section</span><span class="hljs-tag">&gt;</span>
);
</code></pre>
    <p class="normal">The <a id="_idIndexMarker085"/>first collection is an array called <code class="inlineCode">array</code>, populated with string values. Moving down to the JSX markup, you can see the call to <code class="inlineCode">array.map()</code>, which returns a new array. The mapping function actually returns a JSX element (<code class="inlineCode">&lt;li&gt;</code>), meaning that each item in the array is now represented in the markup.</p>
    <div class="note">
      <p class="normal">The result of evaluating this expression is an array. Don’t worry – JSX knows how to render arrays of elements. For enhanced performance, it is crucial to assign a unique <code class="inlineCode">key</code> prop to each component within the array, enabling React to efficiently manage updates during subsequent re-renders.</p>
    </div>
    <p class="normal">The object collection uses the same technique, except that you have to call <code class="inlineCode">Object.keys()</code> and then map this array. What’s nice about mapping collections to JSX elements on the page is that you can control the structure of React components based on the collected data. </p>
    <p class="normal">This means that you don’t have to rely on imperative logic to control the UI.</p>
    <p class="normal">Here’s what the rendered output looks like:</p>
    <figure class="mediaobject"><img src="../Images/B19636_02_05.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 2.5: The result of mapping JavaScript collections to HTML elements</p>
    <p class="normal">JavaScript<a id="_idIndexMarker086"/> expressions bring JSX content to life. React evaluates expressions and updates the HTML content based on what has already been rendered and what has changed. Understanding how to utilize these expressions is important because it’s one of the most common day-to-day activities of any React developer.</p>
    <p class="normal">Now, it’s time to learn how to group together JSX markup without relying on HTML tags to do so.</p>
    <h1 id="_idParaDest-46" class="heading-1">Building fragments of JSX</h1>
    <p class="normal">Fragments <a id="_idIndexMarker087"/>are a way to group together chunks of markup without having to add unnecessary structure to your page. For example, a common <a id="_idIndexMarker088"/>approach is to have a React component return content wrapped in a <code class="inlineCode">&lt;div&gt;</code> element. This element serves no real purpose and adds clutter to the DOM.</p>
    <p class="normal">Let’s look at an example. Here are two versions of a component. One uses a wrapper element, and the other uses the new fragment feature:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title">ReactDOM</span> <span class="hljs-keyword">from</span> "react-dom";
<span class="hljs-keyword">import</span> <span class="hljs-title">WithoutFragments</span> <span class="hljs-keyword">from</span> "./<span class="hljs-title">WithoutFragments</span>";
<span class="hljs-keyword">import</span> <span class="hljs-title">WithFragments</span> <span class="hljs-keyword">from</span> "./<span class="hljs-title">WithFragments</span>";
<span class="hljs-keyword">const</span> root = <span class="hljs-title">ReactDOM</span>.<span class="hljs-title">createRoot</span>(<span class="hljs-variable">document</span>.<span class="hljs-title">getElementById</span>("root"));
root.<span class="hljs-title">render</span>(
  <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">WithoutFragments</span><span class="hljs-tag"> /&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">WithFragments</span><span class="hljs-tag"> /&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
);
</code></pre>
    <p class="normal">The two<a id="_idIndexMarker089"/> elements rendered are <code class="inlineCode">&lt;WithoutFragments&gt;</code> and <code class="inlineCode">&lt;WithFragments&gt;</code>. Here’s what they<a id="_idIndexMarker090"/> look like when rendered:</p>
    <figure class="mediaobject"><img src="../Images/B19636_02_06.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 2.6: Fragments help render fewer HTML tags without any visual difference</p>
    <p class="normal">Let’s compare the two approaches now.</p>
    <h2 id="_idParaDest-47" class="heading-2">Using wrapper elements</h2>
    <p class="normal">The first approach<a id="_idIndexMarker091"/> is to wrap sibling elements in <code class="inlineCode">&lt;div&gt;</code>. Here’s what the source looks like:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">WithoutFragments</span>() {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>Without Fragments<span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
        Adds an extra <span class="hljs-tag">&lt;</span><span class="hljs-name">code</span><span class="hljs-tag">&gt;</span>div<span class="hljs-tag">&lt;/</span><span class="hljs-name">code</span><span class="hljs-tag">&gt;</span> element.
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  );
}
</code></pre>
    <p class="normal">The essence of this component is the <code class="inlineCode">&lt;h1&gt;</code> and <code class="inlineCode">&lt;p&gt;</code> tags. Yet, in order to return them from <code class="inlineCode">render()</code>, you have to wrap them with <code class="inlineCode">&lt;div&gt;</code>. Indeed, inspecting the DOM using your browser dev tools reveals that <code class="inlineCode">&lt;div&gt;</code> does nothing but add another level of structure:</p>
    <figure class="mediaobject"><img src="../Images/B19636_02_07.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 2.7: Another level of structure in the DOM</p>
    <p class="normal">Now, imagine <a id="_idIndexMarker092"/>an app with lots of these components—that’s a lot of pointless elements! Let’s see how to use fragments to avoid unnecessary tags.</p>
    <h2 id="_idParaDest-48" class="heading-2">Using fragments</h2>
    <p class="normal">Let’s take a<a id="_idIndexMarker093"/> look at the <code class="inlineCode">WithFragments</code> component, where we have avoided using unnecessary tags:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">WithFragments</span>() {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>With Fragments<span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Doesn't have any unused DOM elements.<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span>
  );
}
</code></pre>
    <p class="normal">Instead of wrapping the component content in <code class="inlineCode">&lt;div&gt;</code>, the <code class="inlineCode">&lt;&gt;</code> element is used. This is a special type of element that indicates that only its children need to be rendered. The <code class="inlineCode">&lt;&gt;</code> is a shorthand for <code class="inlineCode">React.Fragment component</code>. If you need to pass a key property to the fragment, you can’t use <code class="inlineCode">&lt;&gt;</code> syntax.</p>
    <p class="normal">You can see the<a id="_idIndexMarker094"/> difference compared to the <code class="inlineCode">WithoutFragments</code> component if you inspect the DOM:</p>
    <figure class="mediaobject"><img src="../Images/B19636_02_08.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 2.8: Less HTML in the fragment</p>
    <p class="normal">With the advent of fragments in JSX markup, we have less HTML rendered on the page because we don’t have to use tags such as <code class="inlineCode">&lt;div&gt;</code> for the sole purpose of grouping elements together. Instead, when a component renders a fragment, React knows to render the fragment’s child element wherever the component is used.</p>
    <p class="normal">So fragments enable React components to render only the essential elements; no more will elements that serve no purpose appear on the rendered page.</p>
    <h1 id="_idParaDest-49" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, you learned about the basics of JSX, including its declarative structure, which leads to more maintainable code. Then, you wrote some code to render some basic HTML and learned about describing complex structures using JSX; every React application has at least some structure.</p>
    <p class="normal">Then, you spent some time learning about extending the vocabulary of JSX markup by implementing your own React components, which is how you design your UI as a series of smaller pieces and glue them together to form the whole. Then, you learned how to bring dynamic content into JSX element properties and how to map JavaScript collections to JSX elements, eliminating the need for imperative logic to control the UI display. Finally, you learned how to render fragments of JSX content, which prevents unnecessary HTML elements from being used.</p>
    <p class="normal">Now that you have a feel for what it’s like to render UIs by embedding declarative XML in your JavaScript modules, it’s time to move on to the next chapter, where we’ll take a deeper look at components, properties, and state.</p>
  </div>
</body></html>