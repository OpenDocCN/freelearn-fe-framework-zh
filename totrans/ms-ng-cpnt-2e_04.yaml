- en: Thinking in Projects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以项目思维思考
- en: It's time to think bigger. So far, we've created everything within our application
    around the concept of a simple task list. However, we want to build something
    bigger than that. Users should be able to organize their tasks into projects.
    Within this chapter, we're going to introduce a frame around our task list and
    make it feel like a full-blown application. With the introduction of a project
    component, the main navigation, tabbed interfaces, and a user area, we are moving
    a big step closer to our final application look.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候考虑更宏大的目标了。到目前为止，我们围绕简单任务列表的概念创建了应用程序中的所有内容。然而，我们想要构建比这更大的东西。用户应该能够将他们的任务组织到项目中。在本章中，我们将围绕我们的任务列表引入一个框架，使其感觉像一个完整的应用程序。通过引入项目组件、主要导航、标签界面和用户区域，我们正朝着最终应用程序的外观迈出重要一步。
- en: We will create a reusable in-place editor component, which we will put into
    action on many existing areas within our application. With the help of this editor,
    the user experience of our system will increase tremendously, and our users will
    start to feel the underlying reactive architecture.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个可重用的就地编辑器组件，并将其应用于我们应用程序中的许多现有区域。借助这个编辑器，我们系统的用户体验将大大提升，我们的用户将开始感受到底层响应式架构。
- en: During this chapter, we will also create a commenting system that we build in
    a way that allows us to place it anywhere we'd like for our users to put comments.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将创建一个评论系统，我们将以允许我们在任何我们希望用户放置评论的地方放置它的方式构建它。
- en: Application security and proper user management are not within the scope of
    this book. However, we're going to create a dummy user service that will help
    us simulate a logged-in user. This service will be used by the commenting system,
    and we'll refactor our existing component to make use of it too.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序安全和适当用户管理不在此书的范围之内。然而，我们将创建一个模拟已登录用户的虚拟用户服务。这个服务将被评论系统使用，并且我们将重构现有的组件以利用它。
- en: 'We''ll cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction of a new project component and additional container components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入新的项目组件和额外的容器组件
- en: Two new RxJS operators called `switchMap` and `take`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个新的RxJS操作符`switchMap`和`take`
- en: Creating a tabbed interface component for project detail navigation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为项目详情导航创建一个标签界面组件
- en: Using content projection to create a navigation UI component
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内容投影创建导航UI组件
- en: Using `contenteditable` to create an in-place editor
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`contenteditable`创建就地编辑器
- en: Using `@HostBinding` and `@HostListener` to bind component members to host element
    properties and events
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@HostBinding`和`@HostListener`将组件成员绑定到宿主元素属性和事件
- en: Obtaining view elements using the `@ViewChild` decorator
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@ViewChild`装饰器获取视图元素
- en: Performing DOM operations by using the `ElementRef` DOM abstraction
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`ElementRef` DOM抽象执行DOM操作
- en: Creating a commenting system that allows us to gather user comments in different
    areas of our application
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个允许我们在应用程序的不同区域收集用户评论的评论系统
- en: Summarizing a simple pipe to format relative time intervals using the third-party
    library Moment.js
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第三方库Moment.js总结一个简单的管道来格式化相对时间间隔
- en: Creating an editor that enables users to edit text fields in-place
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个允许用户就地编辑文本字段的编辑器
- en: Moving into projects
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入项目
- en: Within this topic, we're going to implement the changes needed to move our simple
    task list into a structure that is organized by projects. For this purpose, we
    need to modify the main layout of our components as well as introduce a new component
    that represents our projects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们将实现将我们的简单任务列表移动到一个按项目组织结构的所需更改。为此，我们需要修改我们组件的主要布局，并引入一个代表我们项目的新的组件。
- en: Project service
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目服务
- en: First, let's update our application model to include project data. For this,
    we're going to create a new model for a project as well as update the model of
    our tasks to add a project ID.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们更新我们的应用程序模型以包括项目数据。为此，我们将创建一个项目的新模型，并更新我们的任务模型以添加一个项目ID。
- en: 'Open up the `src/app/model.ts` file and apply the following changes:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`src/app/model.ts`文件并应用以下更改：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each task is now including a reference to a project. The project entities are
    consisting of an ID, individual title, and description property. Let''s also update
    our in-memory web API database. Open the `src/app/database.ts` file and apply
    the following changes:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每个任务现在都包括一个指向项目的引用。项目实体包括一个ID、单个标题和描述属性。让我们也更新我们的内存中Web API数据库。打开`src/app/database.ts`文件并应用以下更改：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We've added two projects to our database as well as updated all the tasks to
    include a reference to the first of the two projects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的数据库中添加了两个项目，并更新了所有任务以包含对两个项目中的第一个项目的引用。
- en: Now, we are going to need a service to access our projects, and we should also
    update our task service to include a method that allows us to query for tasks
    that belong to a specific project.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个服务来访问我们的项目，我们还应该更新我们的任务服务以包括一个允许我们查询属于特定项目任务的方法。
- en: 'First, let''s apply the changes to the existing task service. Open up the `src/app/tasks/task.service.ts`
    file and implement the following changes. Effective changes are marked in bold,
    and the ellipsis character is indicating more code that is irrelevant for the
    changes to be applied:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将更改应用到现有的任务服务中。打开`src/app/tasks/task.service.ts`文件并实现以下更改。有效的更改以粗体显示，省略号字符表示与更改应用无关的更多代码：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The added `getProjectTasks` method is providing a mapped observable that takes
    our source tasks subject and maps each tasks array to produce a filtered tasks
    array that only includes tasks of a specific project.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的`getProjectTasks`方法提供了一个映射的可观察对象，它接受我们的源任务主题，并将每个任务数组映射以生成一个过滤后的任务数组，该数组仅包含特定项目的任务。
- en: 'Alright, now we need to create a new service that allows us to obtain information
    about the projects from our in-memory web API database. Let''s use the Angular
    CLI to create a new service:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们需要创建一个新的服务，允许我们从我们的内存中Web API数据库获取项目信息。让我们使用Angular CLI创建一个新的服务：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The Angular CLI should have created our service on the path `src/app/project/project.service.ts`.
    Let''s open that file and replace its content with the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI应该在`src/app/project/project.service.ts`路径上创建我们的服务。让我们打开该文件并将其内容替换为以下代码：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s discuss the preceding code changes briefly. Our project service contains
    three members:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要讨论前面的代码更改。我们的项目服务包含三个成员：
- en: '**projects: BehaviourSubject<Project[]>**'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**projects: BehaviorSubject<Project[]>**'
- en: The `projects` member behaviour subject is emitting our whole project list once
    loaded from our database. This subject is the basis for all operations within
    our service.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`projects`成员行为主题在从我们的数据库加载后发射整个项目列表。这个主题是我们服务中所有操作的基础。'
- en: '**selectedProjectId: BehaviourSubject<number>**'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**selectedProjectId: BehaviorSubject<number>**'
- en: Since we will need to know which of the projects is currently selected within
    our application, we need to store this information in our service. We're using
    a behaviour subject for emitting the currently selected project ID. This allows
    us to simply emit a project ID through `selectedProjectId` if we wish to select
    a given project.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们需要知道在我们的应用程序中哪个项目当前被选中，因此我们需要在我们的服务中存储这个信息。我们使用行为主题来发射当前选中的项目ID。这允许我们通过`selectedProjectId`简单地发射一个项目ID，如果我们想选择一个特定的项目。
- en: '**selectedProject: Observable<Project>**'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**selectedProject: Observable<Project>**'
- en: The `selectedProject` observable will always emit the currently selected project.
    We'll make use of `combineLatest` to make sure if either `projects` or `selectedProjectId`
    emits a change. We will re-emit the updated, selected project through the `selectedProject`
    observable stream.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`selectedProject`可观察对象将始终发射当前选中的项目。我们将使用`combineLatest`来确保如果`projects`或`selectedProjectId`发射了变化。我们将通过`selectedProject`可观察对象流重新发射更新的选中项目。'
- en: Within the constructor of our service, we're first calling the `loadProjects`
    method to do the HTTP call to our in-memory web API database to obtain the list
    of projects. Within the `loadProjects` method, we're sticking to the same pattern
    from our task service. We're subscribing to the HTTP service observable and emitting
    the resulting items through our internal `projects` subject.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的服务构造函数中，我们首先调用`loadProjects`方法来进行HTTP调用到我们的内存中Web API数据库以获取项目列表。在`loadProjects`方法中，我们遵循与我们的任务服务相同的模式。我们订阅HTTP服务可观察对象，并通过我们内部的`projects`主题发射结果项。
- en: After executing the `loadProjects` method within our constructor, we will create
    the `selectedProject` observable. We will use `combineLatest`, which we've discussed
    already in the previous chapter, to combine the `projects` and the `selectedProjectId`
    subjects into a single observable stream. Whenever one of those two input observables
    emits an event, `combineLatest` will combine the latest result of both input observables
    into a single item that is emitted through the output observable stream. We're
    using the map operator to extract the selected project from the list of projects
    and returning it as an item into the observable output stream.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中执行 `loadProjects` 方法之后，我们将创建 `selectedProject` 可观察对象。我们将使用已经在上一章中讨论过的
    `combineLatest` 来将 `projects` 和 `selectedProjectId` 主题组合成一个单一的可观察流。每当这两个输入可观察对象中的任何一个发出事件时，`combineLatest`
    将将两个输入可观察对象的最新结果组合成一个单一的项目，并通过输出可观察流发出。我们使用 map 操作符从项目列表中提取选定的项目，并将其作为项目返回到可观察输出流中。
- en: Finally, the `selectProject` method is merely emitting the new project ID through
    the `selectedProjectId` subject. Since we're using this subject within the `selectedProject`
    observable created with `combineLatest`, this change will cause the `selectedProject`
    observable to re-emit the currently selected project.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`selectProject` 方法仅仅是通过 `selectedProjectId` 主题发出新的项目 ID。由于我们在这个使用 `combineLatest`
    创建的 `selectedProject` 可观察对象中使用这个主题，这个变化将导致 `selectedProject` 可观察对象重新发出当前选定的项目。
- en: 'As the last step, we need to add our new service to the app module providers.
    Let''s open the `src/app/app.module.ts` file and apply the following changes:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们需要将我们的新服务添加到应用模块提供者中。让我们打开 `src/app/app.module.ts` 文件并应用以下更改：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, that's it for our project service for the moment. We've created our service
    in a highly reactive way, where we store all state within RxJS behavior subjects
    and react to change, transform streams, and emit where updates need to be communicated.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于我们项目服务的部分就到这里了。我们以高度反应性的方式创建了我们的服务，其中我们存储所有状态在 RxJS 行为主题中，并响应变化、转换流，并在需要通信更新时发出。
- en: Project component
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目组件
- en: We've already implemented all necessary changes to deal with the model, data,
    and state for our projects. Now, it's time to move on to the components that are
    required to display our projects and the tasks that belong to them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了处理我们项目所需的模型、数据和状态的所有必要更改。现在，是时候继续到显示我们的项目和它们所属的任务所需的组件了。
- en: 'Let''s start by creating the project component using the Angular CLI:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用 Angular CLI 创建项目组件开始：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'First, let''s change the component class file located in `src/app/project/project/project.component.ts`
    by replacing its content with the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过替换以下代码来更改位于 `src/app/project/project/project.component.ts` 的组件类文件：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Nothing special here. We''ve created a simple project component that accepts
    a project object as input. Let''s move on the template of our new component and
    change the content of the file in `src/app/project/project.component.ts`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别之处。我们创建了一个简单的项目组件，它接受一个项目对象作为输入。让我们继续我们的新组件模板，并更改位于 `src/app/project/project/project.component.ts`
    的文件内容：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Within our template, we first render the project header, which consists of the
    title and the description of our project. After the project header, we want to
    render all project tasks. We can just include the task list container component
    to do so.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模板中，我们首先渲染项目标题，它由我们项目的标题和描述组成。在项目标题之后，我们想要渲染所有项目任务。我们可以通过包含任务列表容器组件来实现这一点。
- en: Updating the task list container
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新任务列表容器
- en: 'That''s it for our project component. However, our task list container is still
    implemented in such a way that it deals with all available tasks and does not
    know anything about projects. Let''s change that by modifying our component class
    located in `src/app/container/task-list-container.component.ts`. Changes are highlighted
    in bold while irrelevant parts are hidden under an ellipsis character:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的项目组件的部分就到这里了。然而，我们的任务列表容器仍然以处理所有可用任务的方式实现，并不知道任何关于项目的信息。让我们通过修改位于 `src/app/container/task-list-container.component.ts`
    的组件类来改变这一点。更改的部分以粗体显示，而无关部分则被省略号字符隐藏：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First of all, we're introducing a new member called `selectedProject`, which
    is an observable stream that we obtain from our project service. Within the constructor
    of our component, we're injecting the project service and receiving the observable
    by calling the `getSelectedProject` method on our service. If you remember from
    the previous topic, this observable will always emit the currently selected project
    within our application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们引入一个名为 `selectedProject` 的新成员，它是一个我们从项目服务获取的可观察流。在我们的组件构造函数中，我们注入项目服务，并通过在服务上调用
    `getSelectedProject` 方法来接收可观察对象。如果你还记得上一个主题，这个可观察对象将始终在我们的应用程序中发射当前所选项目。
- en: Within the constructor, we also need to change the way we obtain our task list.
    Going forward, the task list that we're going to use within our container is always
    dependent on the selected project. To make this happen, we're going to look at
    a new RxJS operator called `switchMap`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们还需要改变我们获取任务列表的方式。从现在开始，我们将在容器内使用的任务列表始终依赖于所选项目。为了实现这一点，我们将研究一个新的 RxJS
    操作符，称为 `switchMap`。
- en: 'Let me first try to explain how `switchMap` works in one sentence. It takes
    an observable stream and for every item emitted, it connects a different observable
    stream to the output. This might sound confusing, so for you to get a better grasp
    on that new concept, let''s look at a simplified example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我先尝试用一句话解释 `switchMap` 的工作原理。它接受一个可观察流，并为每个发射的项目连接一个不同的可观察流到输出。这可能听起来有些令人困惑，所以为了让你更好地掌握这个新概念，让我们看看一个简化的例子：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding example uses `switchMap` to connect an observable **(o2)** to
    a new output observable, every time the source observable **(o1)** is emitting
    an item. We''re using the `interval` helper to create an observable that is emitting
    an item every second. For the second observable **(o2)**, we''re using the `from`
    helper to generate an observable sequence that is emitting the strings **a** and
    **b** as separate items. After that, we''re using the `switchMap` operator, which
    will create a new output observable that connects our **(o2)** observable to the
    output, whenever there''s a new item emitted by the source observable **(o1)**.
    The preceding example will, therefore, log the strings **a** and **b** to the
    console each second:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子使用 `switchMap` 将一个可观察对象 **(o2)** 连接到一个新的输出可观察对象，每次源可观察对象 **(o1)** 发射一个项目时。我们使用
    `interval` 辅助函数创建一个每秒发射一个项目的可观察对象。对于第二个可观察对象 **(o2)**，我们使用 `from` 辅助函数生成一个发射字符串
    **a** 和 **b** 作为单独项目的可观察对象序列。之后，我们使用 `switchMap` 操作符，它将创建一个新的输出可观察对象，将我们的 **(o2)**
    可观察对象连接到输出，每当源可观察对象 **(o1)** 发射新项目时。因此，之前的例子将每秒将字符串 **a** 和 **b** 记录到控制台：
- en: '![](img/49510bc3-69e8-4dd4-b21b-b92fe9d941cc.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/49510bc3-69e8-4dd4-b21b-b92fe9d941cc.png)'
- en: A stream diagram showing the behaviour of the switchMap operator
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流图显示了 `switchMap` 操作符的行为
- en: 'If you''re used to Promises, then you can also think of the `switchMap` operator
    as building an asynchronous Promise chain by returning new Promises within the
    `then` function:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯了 Promises，那么你也可以将 `switchMap` 操作符视为在 `then` 函数中返回新的 Promises 来构建异步 Promise
    链：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'By chaining Promises, we can perform four different asynchronous operations
    in sequence. The `switchMap` operator behaves almost the same, but instead, we
    could chain four different observables after each other:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过链式调用 Promises，我们可以按顺序执行四个不同的异步操作。`switchMap` 操作符的行为几乎相同，但我们可以链式调用四个不同的可观察对象：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Okay, we have learned about the `switchMap` operator and how we can use it
    to chain multiple asynchronous operations in sequence. Now, let''s go back to
    our task list container component and see how we can apply this concept to obtain
    project tasks. The following core excerpt is only showing the relevant part of
    the changes we have used already in our task list container component:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经了解了 `switchMap` 操作符以及我们如何使用它来按顺序链式调用多个异步操作。现在，让我们回到我们的任务列表容器组件，看看我们如何将这个概念应用到获取项目任务。以下核心摘录仅显示我们在任务列表容器组件中已经使用的相关更改部分：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In our case, we're using the `switchMap` operator to take the `selectedProject`
    observable as input and switch to the observable we're obtaining by the `getProjectTasks`
    call. This technique allows us to chain the two asynchronous operations, obtaining
    the selected project and receiving tasks, together in sequence. Within the callback
    of the `switchMap` operator, we are receiving the selected project object, and
    we use the ID of the project to obtain the observable of project tasks.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们使用`switchMap`操作符将`selectedProject`可观察对象作为输入，并切换到通过`getProjectTasks`调用获得的可观察对象。这项技术允许我们将两个异步操作，获取选择的项目和接收任务，按顺序串联起来。在`switchMap`操作符的回调中，我们接收选择的项目对象，并使用项目的ID来获取项目任务的可观察对象。
- en: Now, every time the `selectedProject` observable is emitting a new value, our
    tasks observable will also emit the latest tasks of the selected project. Nice
    and reactive.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当`selectedProject`可观察对象发出新的值时，我们的任务可观察对象也会发出所选项目的最新任务。非常好，非常响应式。
- en: Alright! There's only one change left to discuss. Let's focus on the changes
    within the `addTask` method. Since our task model is now also including a `projectId`
    property, we need to make sure we're adding the correct project ID every time
    we create a task.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！只剩下一个变更需要讨论。让我们专注于`addTask`方法中的变更。由于我们的任务模型现在也包括一个`projectId`属性，我们需要确保每次创建任务时都添加正确的项目ID。
- en: 'We make use of another unknown RxJS operator, `take`, within the code changes
    for the `addTask` method. Don''t worry. The `take` operator works much more straightforward
    than the `switchMap` operator. Again, let''s start with a simplification:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在`addTask`方法的代码变更中，我们使用了另一个未知的RxJS操作符`take`。不用担心，`take`操作符的工作方式比`switchMap`操作符更直接。再次，让我们从简化开始：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The code in the preceding example will print the number one to the console.
    The numbers two and three will not be emitted by the output stream after the transformation
    using the `take` operator. The `take` operator will create a new observable stream
    that will only emit the number of items specified with the parameter passed to
    it. After the amount of items specified are emitted, the stream will close itself,
    even calling for unsubscription to all parent streams:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 之前示例中的代码将在控制台打印数字一。在经过`take`操作符转换后，数字二和三将不会被输出流发出。`take`操作符将创建一个新的可观察对象流，该流将只发出通过传递给它的参数指定的项目数。在指定的项目数发出后，该流将自行关闭，即使调用取消订阅所有父流：
- en: '![](img/657f7f96-f032-41a3-9b98-d42617176005.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/657f7f96-f032-41a3-9b98-d42617176005.png)'
- en: Input observable with three emissions is transformed to an output observable
    with one emission using the take operator
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`take`操作符将具有三个发射的输入可观察对象转换为只有一个发射的输出可观察对象
- en: The `take` operator is especially impressive on our behaviour subjects, where
    you'd like to do some one-off actions on emitted items. Since behaviour subjects
    are always issuing the most recent item at a new subscription, we can use the
    take operator to immediately extract the latest value of the behaviour subject
    and do something with it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`take`操作符在我们的行为主题上特别引人注目，当你想在发出的项上执行一次性操作时。由于行为主题总是在新的订阅中发出最新的项，我们可以使用`take`操作符立即提取行为主题的最新值并对其进行操作。'
- en: 'Let''s look at the code of our updated `addTask` method again to see how and
    why we''re making use of the `take` operator there:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次查看更新后的`addTask`方法的代码，看看我们是如何以及为什么在那里使用`take`操作符的：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First of all, we need to understand at which point in time the `addTask` method
    is getting called. This call happens whenever the user clicks on the add task
    button within the user interface. All we want to do now really is get the latest
    value of our `selectedProject` observable so that we can use the project ID to
    create our task associated with this project. However, if we'd subscribed to the
    `selectedProject` observable in a usual way, we'd keep those subscriptions within
    the `addTask` method active forever. This behaviour would mean that going forward
    when we call this method, let's say, ten times, on every change of the selected
    project, those ten subscriptions would fire again and create some unwanted duplicate
    tasks.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要了解`addTask`方法在什么时间点被调用。这个调用发生在用户在用户界面中点击添加任务按钮时。我们现在真正想要做的就是获取我们`selectedProject`可观察对象的最新的值，以便我们可以使用项目ID来创建与该项目关联的任务。然而，如果我们以通常的方式订阅了`selectedProject`可观察对象，我们会在`addTask`方法中保持这些订阅永远活跃。这种行为意味着当我们继续调用此方法时，比如说，十次，每次选择项目发生变化时，这十个订阅都会再次触发并创建一些不想要的重复任务。
- en: Using the `take` operator, we can prevent this behaviour. It allows us to create
    an observable stream that will be automatically unsubscribed once the desired
    amount of items have passed through. When we pass the number one as an item count
    parameter to the `take` operator, we can just take one item from the source stream
    and create a subscription that is only valid for this one item.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`take`操作符，我们可以防止这种行为。它允许我们创建一个可观察对象流，一旦达到所需数量的项目通过，它将自动取消订阅。当我们将数字一作为项目计数参数传递给`take`操作符时，我们只需从源流中取一个项目，并创建一个仅对这一个项目有效的订阅。
- en: That's it for the changes within the task list container component. Till now,
    we have created a new project service, updated our existing task service, created
    a project component, and updated our task list container component to deal with
    the currently selected project. The last thing that is left to do is integrate
    our project component into the overall application as a top level component.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是任务列表容器组件中的所有更改。到目前为止，我们已经创建了一个新的项目服务，更新了现有的任务服务，创建了一个项目组件，并更新了我们的任务列表容器组件以处理当前选中的项目。最后要做的就是将我们的项目组件作为顶级组件集成到整体应用程序中。
- en: Integrating the project component
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成项目组件
- en: Within this topic, we're going to integrate the changes we've applied so far
    to our application. Currently, our root component is rendering a task list container
    component directly, which we will need to change to render our projects.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们将整合到目前为止应用到我们的应用程序中的更改。目前，我们的根组件正在直接渲染任务列表容器组件，这我们需要更改以渲染我们的项目。
- en: We could go ahead and render the project UI component directly within our application
    root component, however, we've learned that we should never include a top-level
    component without a container component to separate our state concerns from our
    user interface.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接在我们的应用程序根组件中渲染项目UI组件，然而，我们已经了解到我们永远不应该在没有容器组件来分离我们的状态关注点的情况下包含顶级组件。
- en: 'Let''s fix this and use the Angular CLI to create a project container component:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修复这个问题，并使用Angular CLI创建一个项目容器组件：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After the component stub has been generated, open up the `src/app/container/project-container/project-container.component.ts`
    file and apply the following changes:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件占位符生成后，打开`src/app/container/project-container/project-container.component.ts`文件，并应用以下更改：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Nothing fancy here. We''re using the project service to obtain the observable
    that is emitting the currently selected project. We''re going to use this observable
    to render our project UI component. Let''s open up the view template of our new
    container component located in `src/app/container/project-container/project-container.component.html`
    and replace the stub template with the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多花哨的东西。我们正在使用项目服务来获取当前选中项目的可观察对象。我们将使用这个可观察对象来渲染我们的项目UI组件。让我们打开位于`src/app/container/project-container/project-container.component.html`的新容器组件的视图模板，并用以下代码替换占位符模板：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Also, the view template is ridiculously simple. However, we should not fall
    into the temptation of skipping a data container component just because things
    look too simple to be worth a wrapper. You should always bring up the discipline
    to stick to the rule that every top-level component needs a container component
    to handle the data and state concerns. It will save you a lot of time in the future.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，视图模板极其简单。然而，我们不应因为事物看起来过于简单而不值得包装就跳过数据容器组件。你应该始终坚持规则，即每个顶级组件都需要一个容器组件来处理数据和状态问题。这将在未来为你节省大量时间。
- en: Now, it's time to include the project container component in the view of our
    root component. At the same time, we'll also change the layout of our application
    slightly, and go one step further toward our final application look.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将项目容器组件包含到我们的根组件视图中了。同时，我们也会稍微调整我们的应用程序布局，并进一步接近我们最终的应用程序外观。
- en: 'Let''s open up the view template of our root component located in `src/app/app.component.html`
    and apply the following changes:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开位于`src/app/app.component.html`的根组件视图模板，并应用以下更改：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We're adding two layout elements as well as our newly created project container
    component. That's it for our changes to integrate the project component into our
    application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了两个布局元素以及我们新创建的项目容器组件。这就是我们将项目组件集成到我们的应用程序中的所有更改。
- en: Recap
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Congratulations! You've successfully implemented the first version of the project
    feature into our application. We've created a whole bunch of things in this topic.
    Besides building the model and database, services, and components, we have also
    integrated our feature successfully by creating and including a new project container
    component. Go ahead and preview our changes within your browser. I hope you're
    happy with the results and are looking forward to further enhancements.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经成功地将项目功能的第一个版本实现到了我们的应用程序中。在这个主题中，我们创建了很多东西。除了构建模型和数据库、服务和组件之外，我们还通过创建和包含一个新的项目容器组件成功集成了我们的功能。请继续在你的浏览器中预览我们的更改。我希望你对结果感到满意，并期待进一步的改进。
- en: 'Let''s summarize what we did within this topic:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下在这个主题中我们所做的工作：
- en: Created and updated our model to include projects
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建并更新了我们的模型以包含项目
- en: Implemented a new project service to obtain project data and updated the existing
    task service to deal with project tasks
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现了一个新的项目服务来获取项目数据，并更新了现有的任务服务以处理项目任务
- en: We've created a new project component as well as a project container component
    to separate our UI from state and data concerns
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个新的项目组件以及一个项目容器组件，以将我们的UI与状态和数据关注点分离
- en: We updated the task list container component to use the active project information
    to display only relevant project tasks
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们更新了任务列表容器组件，使其使用活动项目信息来仅显示相关的项目任务
- en: We learned about the `switchMap` and `take` operators from RxJS and how to use
    them within our application
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了RxJS中的`switchMap`和`take`操作符以及如何在我们的应用程序中使用它们
- en: Updated our root component view to include our project container component instead
    of the task list container
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将根组件视图更新为包含我们的项目容器组件，而不是任务列表容器
- en: Creating a tabbed interface component
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个分页界面组件
- en: 'Let''s introduce a new UI component to the project that will provide us with
    a tabbed interface that we can use for navigation purposes inside of the project
    component. We''d like to divide the project view into different areas that can
    be accessed through this tabbed interface:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向项目中引入一个新的UI组件，该组件将为我们提供一个分页界面，我们可以用它来在项目组件内部进行导航。我们希望将项目视图划分为不同的区域，这些区域可以通过这个分页界面访问：
- en: '![](img/5a4cb7ea-70f1-429e-8e59-664c3771e8a4.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a4cb7ea-70f1-429e-8e59-664c3771e8a4.png)'
- en: Screenshot of the tabbed interface we're going to create
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的分页界面截图
- en: 'Before we create a new component to render tabs, we will update our model to
    declare an interface that we''re using to represent an individual tab. Open the
    `src/app/model.ts` file and apply the following changes:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建一个新的组件来渲染标签之前，我们将更新我们的模型以声明一个接口，该接口用于表示单个标签。打开`src/app/model.ts`文件并应用以下更改：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Our tabs will always consist of a title and an ID, which will be useful later
    when we need to distinguish between individual tabs. Next, we''re going to create
    our tabs component. Using the Angular CLI, we can create the stub of our new component:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的标签将始终包含一个标题和一个ID，这在以后我们需要区分单个标签时将非常有用。接下来，我们将创建我们的标签组件。使用Angular CLI，我们可以创建我们新组件的占位符：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s open up the component class located in `src/app/ui/tabs/tabs.component.ts`
    and add the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开位于`src/app/ui/tabs/tabs.component.ts`的组件类，并添加以下代码：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We''re following the concept of simple and "pure" components and only using
    input to determine how we should render our tabs. Also, when a tab gets activated,
    we''ll call the `activateTab` method that will then emit using the `outActivateTab`
    output. By now, you should be quite familiar with what you see in this component
    class and the concepts behind it. The `tabs` input is expected to be a list of
    tab objects, for which we''ve just created an interface within our model. Let''s
    open the component view template located in `src/app/ui/tabs/tabs.component.html`
    and replace its content with the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循简单和“纯”组件的概念，并且只使用输入来确定我们应该如何渲染我们的标签。此外，当一个标签被激活时，我们将调用`activateTab`方法，然后通过`outActivateTab`输出发出。到现在为止，你应该非常熟悉这个组件类及其背后的概念。`tabs`输入预期是一个标签对象的列表，我们已经在模型中创建了一个接口。让我们打开位于`src/app/ui/tabs/tabs.component.html`的组件视图模板，并用以下代码替换其内容：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We're repeating over our list of tabs and rendering a button as the effective
    tab element. On the tab button, we set a class based on the condition if the current
    tab from the repetition is the same tab that got passed into our component as
    an active tab. This will make our active tab look different from the rest. When
    the user clicks one of the tabs, we're calling the `activateTab` method and passing
    the clicked tab object as a parameter. Going back to the component code, you can
    see that we're then emitting this tab through the `outActivateTab` output.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在遍历我们的标签列表，并为每个标签渲染一个按钮作为有效的标签元素。在标签按钮上，我们根据当前重复的标签是否与传递给我们的组件作为活动标签的标签相同来设置一个类。这将使我们的活动标签看起来与其它不同。当用户点击其中一个标签时，我们将调用`activateTab`方法并将点击的标签对象作为参数传递。回到组件代码，你可以看到我们随后通过`outActivateTab`输出发射这个标签。
- en: Alright, that was already everything we need for our tabs component. Let's make
    use of our tabs in the project component and provide a tabbed interface to access
    the project's details.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这就是我们标签组件所需的所有内容。让我们在我们的项目组件中使用标签，并提供一个标签界面来访问项目详情。
- en: 'First, let''s open the project component class in `src/app/project/project/project.component.ts`
    and update our code with the following changes:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们打开位于`src/app/project/project/project.component.ts`的项目组件类，并按照以下更改更新我们的代码：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We're going to use the tabs component in our project component, and therefore
    we need to provide the necessary input and handle the output of the tabs component.
    For this reason, our project component will now also contain the inputs `tabs`
    and `activeTab`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的项目组件中使用标签组件，因此我们需要提供必要的输入并处理标签组件的输出。因此，我们的项目组件现在也将包含输入`tabs`和`activeTab`。
- en: We've learned from the previous chapter, [Chapter 3](0ae44400-ec3a-4fb6-816b-b5e808196718.xhtml),
    *Dealing with Data and State*, that our UI components should always delegate output
    until they reach a container component. Following this concept will ensure we're
    separating our state and data manipulation from our UI components, which will
    significantly enhance the overall maintainability of our code. Since our tabs
    component will notify us of a change in the active tab, we will respond to this
    by delegating and merely re-emitting the `outActivateTab` output.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从上一章[第3章](0ae44400-ec3a-4fb6-816b-b5e808196718.xhtml)，*处理数据和状态*中学到了，我们的UI组件应该始终将输出委托到容器组件。遵循这个概念将确保我们将状态和数据操作与UI组件分离，这将显著提高代码的整体可维护性。由于我们的标签组件会通知我们活动标签的变化，我们将通过委托并仅重新发射`outActivateTab`输出来响应这一变化。
- en: 'Alright, let''s open up the project view template located in `src/app/project/project/project.comonent.html`
    and edit it with the following changes:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们打开位于`src/app/project/project/project.comonent.html`的项目视图模板，并按照以下更改进行编辑：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We're rendering our tabs component, passing down the tabs objects and the currently
    active tab we've received as input to the project component. We'll also listen
    for a tab activation output on the tabs component and call the `activateTab` method
    within the project component.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在渲染我们的标签组件，将标签对象和接收到的当前活动标签作为输入传递给项目组件。我们还将监听标签组件上的标签激活输出，并在项目组件内调用`activateTab`方法。
- en: We're also using the information of the active tab to decide if we should render
    the task list container component or not. Only if the ID of the currently active
    tab equals to "tasks" will we render the task list.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用活动标签的信息来决定是否渲染任务列表容器组件。只有当当前活动标签的ID等于“tasks”时，我们才会渲染任务列表。
- en: 'Okay, now we need to make sure we''re passing the data required for the tabs
    down to the project component. We also need to ensure that when a tab is activated,
    we''re performing the necessary changes to our application state. The project
    container component renders the project component, so let''s open up the component
    class located in `src/app/container/project-container/project-container.component.ts`
    and apply the following changes:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们需要确保我们将所需的数据传递给项目组件。我们还需要确保当一个标签被激活时，我们对应用程序状态进行必要的更改。项目容器组件渲染项目组件，所以让我们打开位于`src/app/container/project-container/project-container.component.ts`的组件类，并应用以下更改：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Since we're now in a container component, it's okay to store state and perform
    actions on that state. We're adding a list of tab objects where we are already
    thinking a bit ahead. The Comments tab will be used to switch to our commenting
    system that we'll be building later in this chapter. The Activities tab will be
    used in a later chapter of this book.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在处于容器组件中，存储状态并在该状态上执行操作是可以的。我们添加了一个标签对象列表，我们已经提前思考了一些。评论标签页将用于切换到我们在本章后面将要构建的评论系统。活动标签页将在本书的后续章节中使用。
- en: We're also storing the currently active tab using the `activeTab` member and
    initializing it with the first tab within our tabs list.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用`activeTab`成员存储当前激活的标签页，并用我们标签列表中的第一个标签初始化它。
- en: The code within the `activateTab` method looks almost too simple to be right.
    All we're doing is accepting a tab object as a parameter and updating our `activeTab`
    member.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`activateTab`方法中的代码看起来几乎太简单，以至于不像是正确的。我们只是在接受一个标签对象作为参数，并更新我们的`activeTab`成员。'
- en: 'Now, all that''s left to do for making use of our tabs component is updating
    the bindings within the project container component. Let''s open the component
    view template located in `src/app/container/project-container/project-container.component.html`
    and apply the following changes:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使用我们的标签组件，我们只剩下更新项目容器组件内的绑定。让我们打开位于`src/app/container/project-container/project-container.component.html`的组件视图模板，并应用以下更改：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: That was easy, right? This last change was already everything required to provide
    a friendly tabbed interface to our project component. We'll make use of the `activeTab`
    property to activate more detail views of our project going forward. At the moment,
    the Tasks tab is the only tab enabling something within our user interface, but
    as continue adding features, we'll use the other two tabs for navigation too.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，对吧？这次最后的更改已经包含了提供友好标签页界面所需的所有内容，针对我们的项目组件。我们将利用`activeTab`属性来激活我们项目更多的详细视图。目前，任务标签页是唯一一个在我们的用户界面中启用功能的标签页，但随着我们继续添加功能，我们也将使用其他两个标签页进行导航。
- en: Building the main navigation
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建主要导航
- en: 'In this chapter, we''ve already added a project feature to our application.
    We''ve also added a tabbed interface to navigate the details of a project. However,
    there''s still no way to navigate between projects. That''s what we''re going
    to change now. In this section, we will create components to build our main navigation.
    We will then integrate it and use it to navigate between all existing projects
    within the application:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经在我们的应用程序中添加了一个项目功能，我们还添加了一个标签页界面来导航项目的详细信息。然而，目前还没有方法在项目之间进行导航。这正是我们现在要改变的地方。在本节中，我们将创建组件来构建我们的主要导航。然后我们将将其集成并使用它来在应用程序中导航到所有现有的项目：
- en: '![](img/6fc4767a-93d9-4bb5-afb2-6b863d790263.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6fc4767a-93d9-4bb5-afb2-6b863d790263.png)'
- en: Screenshot of the main navigation we're going to build in this section of the
    book
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的这一节中构建的主要导航的截图
- en: We are designing our navigation components in such a way that we can quickly
    make use of them in any situation. For achieving this goal, we're going to look
    at a new concept within Angular, which is called content projection. With the
    use of content projection, we can achieve a new level of component composition.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在设计我们的导航组件，以便我们可以在任何情况下快速使用它们。为了实现这个目标，我们将探讨Angular中的一个新概念，称为内容投影。通过使用内容投影，我们可以达到组件组合的新水平。
- en: Composition using content projection
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内容投影进行组合
- en: Content projection allows you to insert a view portion from a parent component
    into its child component. This concept is a potent tool when it comes to composition.
    With so-called content slots, we can mark a position within our child component
    where we'd like to give our parent components the opportunity to pass in a view
    portion.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 内容投影允许你将父组件中的一个视图部分插入到其子组件中。当涉及到组合时，这个概念是一个强大的工具。通过所谓的插槽，我们可以在子组件中标记一个位置，以便给父组件提供传递视图部分的机会。
- en: 'Let''s look at a simple content projection example that helps us understand
    what this is good for:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的内容投影示例，这有助于我们理解它能做什么：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding example is showing a straightforward UI component called the reveal
    content component. It's showing a title that we can click on to show or hide content.
    This behaviour is advantageous in a lot of situations and is similar to the concept
    of an accordion or collapsible component.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例展示了一个简单的UI组件，称为内容揭示组件。它显示了一个我们可以点击以显示或隐藏内容的标题。在许多情况下，这种行为都是有利的，并且类似于手风琴或可折叠组件的概念。
- en: There are two things in this example that are unique and should look unfamiliar
    to you. I've also highlighted those two lines of code for you so that you can
    see them popping out right away.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中有两个独特的地方，你应该感到不熟悉。我还为你突出显示了这两行代码，这样你可以立即看到它们。
- en: Within our reveal content component, we're using the `<ng-content>` element
    to mark the position for content to be projected from a parent component. This
    element is also called a content projection slot, and you can have multiples of
    those slots within your component view.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的内容揭示组件中，我们使用`<ng-content>`元素来标记从父组件投影内容的位置。这个元素也被称为内容投影槽，你可以在组件视图中拥有多个这样的槽。
- en: The second thing, which is something we've never done so far, is within the
    app component of the preceding example. We put some template code between the
    reveal content component open and close tags. Usually, a component will eliminate
    any template code that is put into its host element. However, before it does so,
    it first checks if the child component contains content projection slots. If there
    are content projection slots within the child component, it will project any view
    portion found in the host element into the child component at the designated position.
    This is the position we've marked using the `<ng-content>` element.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第二件事，这是我们迄今为止从未做过的事情，是在前一个示例的应用组件中。我们在内容揭示组件的开启和关闭标签之间放置了一些模板代码。通常，一个组件会消除放入其宿主元素中的任何模板代码。然而，在这样做之前，它首先检查子组件是否包含内容投影槽。如果子组件中有内容投影槽，它将把在宿主元素中找到的任何视图部分投影到子组件指定的位置。这就是我们使用`<ng-content>`元素标记的位置。
- en: Content projection and projection slots are concepts borrowed from the web components
    Shadow DOM specification. Angular does not yet use Shadow DOM by default, and
    therefore the behaviour is emulated. However, the concept is the same. If you're
    familiar with Angular.js, the first version of Angular, content projection is
    very similar to the idea of transclusion from Angular.js.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 内容投影和投影槽是从Web组件Shadow DOM规范中借用的概念。Angular目前默认不使用Shadow DOM，因此这种行为是模拟的。然而，概念是相同的。如果你熟悉Angular.js，Angular的第一个版本，内容投影与Angular.js中的transclusion概念非常相似。
- en: Additionally, we can use a select attribute on the `<ng-content>` element to
    set a CSS-like selector. This selector will be used to selectively choose that
    elements should be projected into the specific content slot. In this way, you
    can have multiple content slots that cover different requirements.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以在`<ng-content>`元素上使用一个选择属性来设置类似于CSS的选择器。这个选择器将被用来选择性地选择那些应该被投影到特定内容槽中的元素。通过这种方式，你可以拥有多个内容槽，它们覆盖不同的需求。
- en: Elements from the component host element can only be projected once, and this
    content projection works by going through all the `<ng-content>` elements in sequential
    order by projecting any matching elements. If you have multiple competing content
    projection slots in your template, the first one will win and receive the elements
    that get projected into your component.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 来自组件宿主元素的元素只能投影一次，并且这种内容投影是通过按顺序通过所有`<ng-content>`元素进行投影来实现的，任何匹配的元素都会被投影。如果你在模板中有多个竞争的内容投影槽，第一个将获胜并接收被投影到你的组件中的元素。
- en: 'Let''s look at another example that illustrates this behavior:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个示例，以说明这种行为：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding example shows how we can use selective content projection using
    the `select` attribute on a `<ng-content>` element. The `h1` title element is
    projected into the first content projection slot since we're using a CSS selector
    that matches all `h1` elements. The second content slot does not contain a `select`
    attribute and therefore accepts all other elements that are projected into the
    component.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例展示了如何使用`<ng-content>`元素上的`select`属性进行选择性的内容投影。由于我们使用了一个匹配所有`h1`元素的CSS选择器，`h1`标题元素被投影到第一个内容投影槽中。第二个内容槽没有包含`select`属性，因此接受所有其他被投影到组件中的元素。
- en: Creating navigation components
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建导航组件
- en: 'We will build our navigation from three separate components. Let''s look at
    their purpose real quick:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从三个单独的组件构建我们的导航。让我们快速看看它们的目的：
- en: '**The navigation item component**: Represents one navigation item within our
    navigation. Its responsibility is to render the title of a navigation item as
    well as its behavior when an item is activated.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航项组件**：代表我们导航中的一个导航项。其职责是渲染导航项的标题以及当项被激活时的行为。'
- en: '**The navigation section component**: This is used to visually separate navigation
    items that belong together. We can use this component to group navigation items
    under a title. This grouping makes it easier for our users to find the navigation
    items they are looking for.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航部分组件**：这个组件用于在视觉上将属于一起的导航项分开。我们可以使用这个组件将导航项分组在标题下。这种分组使得我们的用户更容易找到他们正在寻找的导航项。'
- en: '**The navigation component**: This holds the full navigation together. It''s
    just a container that contains our navigation section components together.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航组件**：这个组件负责将整个导航组合在一起。它只是一个容器，将我们的导航部分组件组合在一起。'
- en: By using selective content projection, we can provide an excellent content-based
    API, which makes it easy to use our navigation components in any situation. The
    benefit of building content-based APIs is that we can compose our components together,
    only by including them in a view template.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '通过使用选择性的内容投影，我们可以提供一个优秀的内容API，这使得在任何情况下使用我们的导航组件变得容易。构建基于内容的API的好处是我们可以通过在视图模板中包含它们来组合我们的组件。 '
- en: 'Let''s start by creating the lowest of the three components, the navigation
    item:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建三个组件中的最低级组件开始，即导航项：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s open up the view templated located in `src/app/ui/navigation-item/navigation-item.component.html`
    and change its content with the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开位于`src/app/ui/navigation-item/navigation-item.component.html`的视图模板，并使用以下代码更改其内容：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Yes, I know, it looks too simple to be true. But that''s all we need within
    the view of our navigation item component. Let''s move on to the component class
    of the navigation item located in `src/app/ui/navigation-item/navigation-item.component.ts`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我知道，这看起来太简单以至于不真实。但这正是我们导航项组件视图中所需要的所有内容。让我们继续到位于`src/app/ui/navigation-item/navigation-item.component.ts`的导航项组件类：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Besides a `title` input, the component also takes an input, `navId`, to be used
    later during activation. This ID will help us in our parent component when detecting
    which of the navigation items was activated.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`title`输入外，该组件还接受一个名为`navId`的输入，该输入将在激活时使用。这个ID将帮助我们父组件检测哪个导航项被激活。
- en: We are using a new decorator within our component that we haven't used before.
    The `@HostListener` decorator is a handy addition to our Angular toolset. With
    the help of host listeners, you can create event bindings on the component host
    element, but handle them within your component. Usually, the host element is not
    in direct control of our component. The host element always resides within the
    parent component where our component is placed. However, sometimes it's required
    to bind to properties or events of that element. Just like in our case, where
    we'd like to bind to the click event on the host element of our component. You
    can use the `@HostListener` decorator on a method to bind that method to a specific
    event on the host element. Pass the event name you'd like to bind to as a parameter
    to the decorator. In our case, we're binding to the click event on the navigation
    item host element. Each time the click event is fired, our `activateNavigationItem`
    method will be executed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在组件中使用了一个之前未使用过的新装饰器。`@HostListener`装饰器是Angular工具集的一个方便的补充。借助主机监听器，你可以在组件的主机元素上创建事件绑定，但处理它们在你的组件内部。通常，主机元素并不直接受我们的组件控制。主机元素始终位于我们的组件放置的父组件中。然而，有时需要绑定到该元素的属性或事件。就像在我们的案例中，我们希望绑定到我们组件的主机元素的点击事件。你可以在一个方法上使用`@HostListener`装饰器来绑定该方法到主机元素上的特定事件。将你想要绑定的事件名称作为参数传递给装饰器。在我们的案例中，我们绑定到导航项主机元素的点击事件。每次点击事件被触发时，我们的`activateNavigationItem`方法将被执行。
- en: Inside the `activateNavigationItem` method, after a navigation item is clicked,
    we're emitting the ID of the specific navigation item through the `outActivateNavigationItem`
    output.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在`activateNavigationItem`方法内部，当点击一个导航项后，我们通过`outActivateNavigationItem`输出发射特定导航项的ID。
- en: 'Alright, that''s it for our navigation items. Let''s move one level higher
    within our navigation component tree and create the navigation section component:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，关于我们的导航项就到这里。让我们在导航组件树中再往上一层，创建导航部分组件：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The navigation section component is responsible for grouping navigation items
    together. Let''s open the view template located in `src/app/ui/navigation-section/navigation-section.component.html`
    first and apply the necessary changes:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 导航部分组件负责将导航项组合在一起。让我们首先打开位于`src/app/ui/navigation-section/navigation-section.component.html`的视图模板并应用必要的更改：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Each navigation section consists of a title as well as a list of navigation
    items. Now, we're making use of content projection, which we looked at in the
    previous section. We're marking a place within our view template where view portions
    from the parent component can be projected into the navigation section component.
    Since we know that we only want the navigation item component to be projected
    into our navigation section, we are using a `select` attribute on the `<ng-content>`
    element. By setting the `select` attribute to a value of `mac-navigation-item`,
    Angular will only project navigation item components into this content slot.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 每个导航部分都包含一个标题以及一系列导航项。现在，我们正在使用内容投影，这是我们在上一节中讨论过的。我们在视图模板中标记了一个位置，以便从父组件中投影视图部分到导航部分组件。由于我们知道我们只想将导航项组件投影到我们的导航部分，所以我们正在使用`<ng-content>`元素上的`select`属性。通过将`select`属性设置为`mac-navigation-item`，Angular将只投影导航项组件到这个内容槽中。
- en: 'Let''s also apply the changes to our navigation section component class located
    in `src/app/ui/navigation-section/navigation-section.component.ts`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也对我们的导航部分组件类`src/app/ui/navigation-section/navigation-section.component.ts`应用更改：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This component class is elementary. The only thing we do here is to provide
    a title input that is rendered within our navigation section view. The rest of
    our component logic is handled using content projection, which is providing us
    with a beautiful content-based API.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件类很简单。我们在这里做的唯一一件事是提供一个标题输入，该输入在导航部分视图中被渲染。我们组件的其余逻辑是通过内容投影处理的，它为我们提供了一个美丽的内容API。
- en: 'Now, we could already go ahead and use those two components in conjunction
    and arrange them in any view template within our application. As an example, we
    could write a navigation for accessing cute dog pictures:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经在应用中使用这两个组件，并将它们排列在我们的应用中的任何视图模板中。例如，我们可以编写一个导航来访问可爱的狗狗图片：
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: That's the big strength of content-based APIs. Using content projection, we
    provide the ability to compose complex component trees and configure behaviour
    using only view templates. This comes with a significant ease of use. Not surprisingly,
    a lot of Angular UI libraries are using content projection to create their APIs,
    simply because it's just so much easier to configure everything you need declaratively
    using Angular templates.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是基于内容API的强大之处。使用内容投影，我们提供了组合复杂组件树和仅使用视图模板配置行为的能力。这带来了显著的使用便利性。不出所料，许多Angular
    UI库都在使用内容投影来创建它们的API，仅仅是因为使用Angular模板声明性地配置所需的一切要容易得多。
- en: 'Okay, now, let''s create the last component of our three—the navigation component.
    The navigation component is putting a frame on our navigation and is grouping
    navigation sections together:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在，让我们创建我们三个组件中的最后一个——导航组件。导航组件为我们的导航添加了一个框架，并将导航部分组合在一起：
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'First, let''s open the view template of the navigation component located in
    `src/app/ui/navgiation/navigation.component.html` and change its content to the
    following code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们打开位于`src/app/ui/navigation/navigation.component.html`的导航组件的视图模板，并将其内容更改为以下代码：
- en: '[PRE38]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We''re using content projection again to project elements into our navigation
    view. This time, we''re selecting only navigation section components. Let''s also
    change our component class in `src/app/ui/navigation/navigation.component.ts`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用内容投影将元素投影到我们的导航视图中。这次，我们只选择导航部分组件。让我们也更改`src/app/ui/navigation/navigation.component.ts`中的组件类：
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Okay, this is as simple as a component class could be. The class is empty, and
    we're not providing any particular component configuration. You might wonder why
    we even need this component. Well, to decide about the right to exist for our
    components, we need to look at all parts that are defining the component. The
    component class might not contain any behavioral content. However, the styles
    and the component view could provide material that makes the component worth existing.
    If you're using content projection, you often end up with very little code within
    your classes, and that's fine. As long as the content projection or even only
    encapsulated styles provide us developers with a more convenient API, we should
    feel right about the architecture.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这就像一个组件类可能的那样简单。这个类是空的，我们没有提供任何特定的组件配置。你可能想知道为什么我们甚至需要这个组件。嗯，为了决定我们组件存在的权利，我们需要查看所有定义组件的部分。组件类可能不包含任何行为内容。然而，样式和组件视图可以提供使组件值得存在的材料。如果你使用内容投影，你通常会在你的类中拥有非常少的代码，这是完全可以接受的。只要内容投影或甚至仅封装的样式为我们开发者提供了更方便的API，我们就应该对我们的架构感到满意。
- en: 'Coming back to the overall navigation component tree, things might start to
    get a bit confusing, which is normal when multiple levels are involved. Just to
    recap quickly:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 回到整体导航组件树，事情可能会开始变得有些混乱，当涉及多个层级时这是正常的。只是为了快速回顾：
- en: The navigation item is rendering a title and dealing with the behaviour when
    an item is getting activated
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航项正在渲染标题并处理当项被激活时的行为
- en: The navigation sections render a section title and project navigation items
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航部分渲染部分标题和项目导航项
- en: The navigation solely projects navigation sections and acts as a container around
    our navigation
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航仅投影导航部分，并作为我们导航的容器
- en: Now, we're ready to use our navigation components and put them into action within
    our application!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好使用我们的导航组件，并在我们的应用程序中将它们付诸实践！
- en: Providing a project navigation
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供项目导航
- en: 'Within this section, we''re going to use the navigation components we''ve just
    created to provide a project navigation. For this, we''re first going to introduce
    the necessary changes in the app component class located in `src/main/app/app.component.ts`.
    This is the first time we are dealing with the app or root component class. Since
    this is our root component, we''re treating it like a container component, and
    it gets the privileges to deal with state and data:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用我们刚刚创建的导航组件来提供项目导航。为此，我们首先将在`src/main/app/app.component.ts`中找到的应用程序组件类中引入必要的更改。这是我们第一次处理应用程序或根组件类。由于这是我们根组件，我们将其视为容器组件，并获得了处理状态和数据的特权：
- en: '[PRE40]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We're storing two observables within our app component. Using the project service,
    we're obtaining an observable that emits the list of available projects. We're
    also storing the observable that emits the currently selected project.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序组件中，我们存储了两个可观察对象。使用项目服务，我们获取了一个发出可用项目列表的可观察对象。我们还存储了一个发出当前选中项目的可观察对象。
- en: The `selectProject` method is accepting a project ID as a parameter and delegates
    the call to our project service. This will then cause all observers who subscribed
    to the selected project observable to receive the newly selected project. If you
    remember, we're already using this observable within our task list container component.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`selectProject`方法接受一个项目ID作为参数，并将调用委托给我们的项目服务。这将导致所有订阅了选中项目可观察对象的观察者接收到新选中的项目。如果你记得，我们已经在我们的任务列表容器组件中使用了这个可观察对象。'
- en: 'Let''s move on to the view template of our app component located in `src/app/app.component.html`
    and apply the following changes:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到我们的应用程序组件的视图模板，位于`src/app/app.component.html`，并应用以下更改：
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We're using our navigation components to create a project navigation in the
    space that is reserved for our main navigation. At the moment, we're rendering
    just one navigation section that belongs to our projects. By using the `NgFor`
    directive, we're repeating a navigation item component for each project within
    the list of available projects. We're binding the project ID to the `navId` input
    as well as the project title to the `title` input of our navigation item. Additionally,
    we're setting an active class on the navigation item component if the specific
    project is currently selected.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用我们的导航组件在为主导航预留的空间中创建项目导航。目前，我们正在渲染属于我们项目的单个导航部分。通过使用`NgFor`指令，我们在可用项目列表中为每个项目重复一个导航项组件。我们将项目ID绑定到`navId`输入，以及将项目标题绑定到导航项的`title`输入。此外，如果特定项目当前被选中，我们还在导航项组件上设置了一个活动类。
- en: If one of the navigation items is activated, we call the `selectProject` method
    of our app component and pass the ID that is emitted by the `outActivgateNavigationItem`
    as `$event`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果导航项之一被激活，我们调用应用程序组件的`selectProject`方法，并将`outActivgateNavigationItem`发出的ID作为`$event`传递。
- en: That's it! You have successfully built a project navigation. It's a good time
    to preview your changes in the browser now. You should already be able to navigate
    between the two projects that were added into our database. Since our task list
    container is already making use of the selected project observable, the logic
    of switching between projects should already be seamless. You can try to navigate
    to the second project, which does not contain any tasks. Try adding tasks and
    switching between the two projects.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你已经成功构建了一个项目导航。现在是时候在浏览器中预览你的更改了。你应该已经能够在我们数据库中添加的两个项目之间进行导航。由于我们的任务列表容器已经利用了所选项目的可观察性，因此项目之间的切换逻辑应该已经非常流畅。你可以尝试导航到第二个项目，该项目中没有任何任务。尝试添加任务并在两个项目之间切换。
- en: Recap
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'Within this section, we''ve created our navigation components and used them
    to create our project navigation. You have learned about the following concepts:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了我们的导航组件，并使用它们来创建我们的项目导航。你已经了解了以下概念：
- en: Using content projection to build a content-based API for your components
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内容投影为你的组件构建基于内容的API
- en: The idea of content projection slots and the use of `<ng-content>`
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容投影槽和`<ng-content>`的使用理念
- en: Using the `select` attribute on content slots to selectively project content
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内容槽的`select`属性来选择性地投影内容
- en: Using the `@HostListener` decorator to bind host element events to component
    methods
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@HostListener`装饰器将宿主元素事件绑定到组件方法
- en: One editor to rule them all
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个编辑器统治一切
- en: 'We will be processing a lot of user input within our application. Therefore,
    it''s crucial to provide a pleasant authoring experience to our users. Users need
    to be able to edit project titles, descriptions, and task titles. Within the commenting
    system, which we are creating later in this chapter, users also need to be able
    to edit their comments. We could use regular text area input and work with dialogue
    boxes to edit those fields, but this seems too old-fashioned for a modern user
    interface. Native input fields are fantastic, but sometimes they don''t provide
    an outstanding user experience. What we''re looking for is a way to edit stuff
    in-place:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的应用程序中处理大量的用户输入。因此，为我们的用户提供愉快的创作体验至关重要。用户需要能够编辑项目标题、描述和任务标题。在我们在本章后面创建的评论系统中，用户还需要能够编辑他们的评论。我们可以使用常规文本区域输入并使用对话框来编辑这些字段，但这对于现代用户界面来说似乎过于过时。原生输入字段很棒，但有时它们并不提供出色的用户体验。我们正在寻找一种在原地编辑内容的方法：
- en: '![](img/5e38df5e-85ee-408c-92a8-55d8cd60fb35.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5e38df5e-85ee-408c-92a8-55d8cd60fb35.png)'
- en: A screenshot of our in-place editor in action, showing the save and cancel buttons
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们原地编辑器正在工作的截图，显示了保存和取消按钮
- en: To build our in-place editor, we're going to use the contenteditable API that
    will enable a user to modify the content within HTML elements directly.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建我们的原地编辑器，我们将使用contenteditable API，这将使用户能够直接在HTML元素中修改内容。
- en: 'The following example illustrates how we can use the `contenteditable` attribute
    to make HTML elements editable:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了我们如何使用`contenteditable`属性来使HTML元素可编辑：
- en: '[PRE42]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Run the preceding example on a blank HTML page and click on the `h1` text. You
    will see that the element has become editable and you can type to modify its content.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个空白HTML页面上运行前面的示例，并点击`h1`文本。你会看到该元素已经变为可编辑状态，你可以输入来修改其内容。
- en: 'Getting notified about changes within editable elements is relatively easy.
    There''s an input event emitted on every DOM element that is editable, and this
    will allow us to react to change easily:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通知可编辑元素中的变化相对简单。每个可编辑的DOM元素都会发出一个输入事件，这将使我们能够轻松地做出反应：
- en: '[PRE43]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: With this example, we have already created a naive implementation of an in-place
    editor where we're able to monitor changes applied by the user. Within this topic,
    we'll use this standard technology to build a reusable component that we can use
    wherever we want to make things editable.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，我们已经创建了一个简单的原地编辑器实现，我们可以监控用户应用的变化。在本主题中，我们将使用这项标准技术来构建一个可重用的组件，我们可以在任何需要使内容可编辑的地方使用它。
- en: Creating an editor component
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个编辑器组件
- en: 'First, let''s create a new stub component for our editor using the Angular
    CLI:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用Angular CLI为我们的编辑器创建一个新的占位符组件：
- en: '[PRE44]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'After the files have been generated, so let''s open up the component class
    located in `src/ui/editor/editor.component.ts` and apply the following code changes:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 文件生成后，让我们打开位于`src/ui/editor/editor.component.ts`的组件类，并应用以下代码更改：
- en: '[PRE45]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Okay, that's quite a lot of new code. Let's dissect the different parts of the
    editor component and go through each part step by step.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这有很多新的代码。让我们逐步分析编辑器组件的不同部分。
- en: 'Within our editor component, we''ll need to interact with the native DOM element,
    which we make editable using the contenteditable API. The easiest and also the
    safest method to do this is to use the `@ViewChild` decorator to retrieve a DOM
    element by using local view references:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的编辑器组件中，我们需要与原生DOM元素交互，我们可以通过contenteditable API使其可编辑。完成这一点的最简单也是最安全的方法是使用`@ViewChild`装饰器通过局部视图引用来检索DOM元素：
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `@ViewChild` decorator can be used to search our component view for a specific
    DOM element or a component instance. When we'd like to search our view for a particular
    component instance, we can just pass the component class as a parameter to the
    decorator. When searching for a DOM element, we need to pass a string that should
    match a local view reference on one of the elements within our component view.
    Angular returns a type called `ElementRef` when we're searching our view for DOM
    elements. This object is just a wrapper around native DOM elements, which you
    can then use to access the DOM element.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ViewChild`装饰器可以用来搜索我们的组件视图中的特定DOM元素或组件实例。当我们想要在视图中搜索特定的组件实例时，我们可以将组件类作为参数传递给装饰器。当搜索DOM元素时，我们需要传递一个字符串，该字符串应与组件视图中的一个元素的局部视图引用匹配。当我们搜索视图中的DOM元素时，Angular返回一个名为`ElementRef`的类型。这个对象只是原生DOM元素的包装，然后你可以使用它来访问DOM元素。'
- en: 'If we want to search the component subtree for one single DOM element or component
    instance, we can use the `@ViewChild` decorator. We can also search for a list
    of DOM elements or component instances using the `@ViewChildren` decorator:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在组件子树中搜索单个DOM元素或组件实例，我们可以使用`@ViewChild`装饰器。我们也可以使用`@ViewChildren`装饰器来搜索DOM元素或组件实例的列表：
- en: '| **Query decorator** | **Description** |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| **查询装饰器** | **描述** |'
- en: '| `@ViewChildren` (selector) | Will query the current component''s view for
    either directives or components and return an object of the type `QueryList`.
    If the view is dynamically updated, the list will be updated as well.When the
    selector parameter is a directive or component type, the query decorator will
    search our component view for matching directives or components and return a list
    of directive or component instances.The selector parameter can also be a string
    that is then used as a local view reference name to find DOM elements containing
    this local view reference. |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `@ViewChildren` (选择器) | 将查询当前组件的视图以获取指令或组件，并返回一个类型为`QueryList`的对象。如果视图是动态更新的，列表也会更新。当选择器参数是指令或组件类型时，查询装饰器将在我们的组件视图中搜索匹配的指令或组件，并返回指令或组件实例的列表。选择器参数也可以是一个字符串，然后用作局部视图引用名称，以查找包含此局部视图引用的DOM元素。|'
- en: '| `@ViewChild` (selector) | Will query for only the first matching component
    or directive instance or a DOM element containing the specific local view reference.
    |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `@ViewChildren` (选择器) | 将仅查询第一个匹配的组件或指令实例或包含特定局部视图引用的DOM元素。|'
- en: If you need to communicate with view child components directly, you can use
    the `@ViewChild` and `@ViewChildren` decorators to get hold of those components.
    Sometimes, this is required, but this technique should be used carefully. Direct
    component communication only makes sense when you have requirements that can not
    be fulfilled by using component input and output.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要直接与视图子组件通信，可以使用 `@ViewChild` 和 `@ViewChildren` 装饰器来获取这些组件。有时，这可能是必需的，但应谨慎使用此技术。仅当您有无法通过使用组件输入和输出满足的要求时，直接组件通信才有意义。
- en: Sometimes, you need to run some initialization code on view children after your
    component is initialized. In such cases, you can use the `AfterViewInit` life
    cycle hook. While the view child properties of your component class will still
    be undefined within the constructor of your component, they will be populated
    and initialized after the `AfterViewInit` life cycle callback.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在组件初始化后，您需要在视图子组件上运行一些初始化代码。在这种情况下，您可以使用 `AfterViewInit` 生命周期钩子。尽管您的组件类的视图子属性在组件的构造函数中仍然是未定义的，但它们将在
    `AfterViewInit` 生命周期回调之后填充和初始化。
- en: 'Let''s move back to our editor component code. The next thing we''re going
    to look at is another property in our editor component called `editMode`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的编辑器组件代码。接下来我们要看的是编辑器组件中另一个名为 `editMode` 的属性：
- en: '[PRE47]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Our editor is functioning in two modes. The `editMode` property is used inside
    of our component to determine if the editor is in edit mode or display mode. The
    default mode of the editor component is the display mode. A user can then switch
    an editor to edit mode, where he/she will be able to edit the content within the
    editor. After he/she's done editing, he/she can save or discharge the changes.
    This action will also switch the component back into display mode (where `editorMode`
    is false again).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的编辑器以两种模式运行。`editMode` 属性用于我们的组件内部，以确定编辑器是在编辑模式还是显示模式。编辑器组件的默认模式是显示模式。用户可以将编辑器切换到编辑模式，在那里他/她将能够编辑编辑器内的内容。编辑完成后，他/她可以保存或取消更改。此操作也将组件切换回显示模式（此时
    `editorMode` 再次为false）。
- en: We are using the `@HostBinding` decorator to set the CSS class `edit-mode` on
    the component host element conditionally. This state class will help us to style
    our component differently, depending on the editor mode.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `@HostBinding` 装饰器有条件地设置组件宿主元素的CSS类 `edit-mode`。这个状态类将帮助我们根据编辑器模式不同地样式化我们的组件。
- en: 'Next, let''s take a look at the input properties of our component:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们组件的输入属性：
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `content` input property can be used to set the content of our editor from
    the parent components. This input is required to set the initial content that
    appears when our editor is in display mode.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`content` 输入属性可以用来从父组件设置我们的编辑器内容。此输入是必需的，用于设置编辑器在显示模式下出现的初始内容。'
- en: 'The second input property, `showControls`, controls whether the editor should
    show the control functions. When this input is annoying to false, the editor does
    not show any controls and therefore acts in read-only mode. Three UI controls
    will be shown in our editor when this property is set to true:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个输入属性，`showControls`，控制编辑器是否应显示控制功能。当此输入设置为false时，编辑器不会显示任何控制功能，因此以只读模式运行。当此属性设置为true时，在我们的编辑器中会显示三个UI控制：
- en: '**Edit button**: If the editor is in display mode, the edit button is the only
    visible control on the editor. When a user clicks this button, the editor component
    will switch into edit mode by setting `editMode` to true.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑按钮**：如果编辑器处于显示模式，则编辑按钮是编辑器上唯一可见的控制按钮。当用户点击此按钮时，编辑器组件将通过将 `editMode` 设置为true切换到编辑模式。'
- en: '**Save button**: This control will only be shown if the component is in edit
    mode. It''s there to save any changes performed by the user and switch the component
    back to display mode.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保存按钮**：如果组件处于编辑模式，则只会显示此控制按钮。它用于保存用户执行的所有更改，并将组件切换回显示模式。'
- en: '**Cancel button**: This control is shown along with the save button when the
    component is in edit mode. If activated, the component will switch back to display
    mode, reverting any changes that were typed into the editor by the user.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**取消按钮**：当组件处于编辑模式时，此控制按钮会与保存按钮一起显示。如果激活，组件将切换回显示模式，撤销用户在编辑器中输入的所有更改。'
- en: 'Besides our input properties, we also need some output properties to notify
    the outer world about the changes within our editor. Let''s quickly discuss the
    two output properties we''re exposing on our component:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `outSaveEdit` output is emitting the updated content once the user applies
    any changes to the editor content and has clicked the save button.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Our editor component works in a simple way. If the component is in edit mode,
    it shows an element that can be edited using the contenteditable API. However,
    once the editor switches back to display mode, we see a different element that
    cannot be edited. CSS controls the visibility within the modifier class, which
    is set by the host element property binding to the `editMode` flag.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular has no control over the content within our editable element. We control
    this content manually by using native DOM operations. Let''s look at how we do
    this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: These two private methods can be used inside of our editor component to obtain
    the content of our editable DOM element or to set its content, respectively.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: We've already discussed the `editableContentElement` property of our editor
    component and how we obtain a reference to the editable element within our component
    view using the `@ViewChild` decorator.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Angular does not directly provide us with a DOM element reference but a wrapper
    object of the type `ElementRef`. It's a wrapper around the native DOM element,
    which holds additional information that is relevant to Angular. Using the `nativeElement`
    property, we can obtain a reference to the underlying native DOM element.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: The `ElementRef` wrapper plays an integral part in Angular's platform-agnostic
    architecture. It allows you to run Angular in different environments (for example,
    on a server, native mobile, web workers, or others). It's part of an abstraction
    layer between the components and their views.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we set editable content within our component view using the
    `setEditableContent` method. First, we want to make sure that when our view is
    ready, we are initializing the editable content with the text present in our `content`
    component input. For this, we can use the `AfterViewInit` life cycle hook. We
    also needed a way to react to changes to the `content` input property, and update
    the editable content element based on that. We can use the life cycle hook `OnChanges`
    for this purpose:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Within the `ngOnChanges` callback, once a change in the content input property
    is detected, we can reflect the changed content onto our editable element. It's
    important to check whether the `editableContentElement` input is already set before
    we call `setEditableContent`. Since the `OnChanges` life cycle hook is called
    before the `AfterViewInit` life cycle, the `editableContentElement` obtained by
    our `@ViewChild` query will not be available yet. Because of that, we also need
    to use the `ngAfterViewInit` callback to set the initial content of our editable
    element once our component view has initialized.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so far, we''ve looked at how we can reflect the content input of our
    component into the editable element within the view of the editor component. Now,
    let''s take a look at the implementation of the three user actions within the
    editor. These are the three actions for the edit, save, and cancel buttons:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: When our editor is in display mode, a user can only activate edit mode. We are
    taking care of that using the `beginEdit` method. If a user clicks the edit button
    on our editor component, the only thing we need to do is switch our editor into
    edit mode. We can do that by merely setting the `editMode` property to `true`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Whatever we''ve discussed thus far concerning the code is good enough for us
    to set up a fully functional component. However, the last part of the code, which
    we haven''t discussed yet, relates to ensuring better accessibility of our editor.
    Since our editor component is a bit larger than the editable element, we also
    want to make sure that a click anywhere inside the editor component will cause
    the editable element to be focused. The following code makes this happen:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Using the `@HostListener` decorator, we are registering an event binding on
    our component host element that calls the `focusEditableContent` method. Inside
    this method, we are using the reference to the editable DOM element and triggering
    a focus.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'That was the last missing piece of code to discuss within our component class.
    Let''s look at the template of our component, which is located within the `src/app/ui/editor/editor.component.html`
    file, to see how the code we''ve just created in our component class is related
    to the component view:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The logic within the editor component template is quite straightforward. If
    you've been following the component code, you'll now be able to identify the different
    elements that compose this component's view.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: The first element within the CSS class, `editable-content`, is our editable
    element that has the `contenteditable` attribute. The user will be able to type
    into this element when the editor is in edit mode. It's important to note that
    we've annotated it with a local view reference, `#editableContentElement`, which
    we're using in our view child queries.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: The second element within the CSS class, `output`, is only to display the editor
    content and is only visible when the editor is in display mode. The visibility
    of both the elements is controlled using CSS, based on the `edit-mode` modifier
    class, which, if you recall from the component class code, is set through host
    property binding based on the `editMode` property.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: The three control buttons are shown conditionally using the `NgIf` directive.
    The `showControls` input property needs to be `true`, and depending on the `editMode`
    flag, the view will either show the edit button or the save and the cancel buttons.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the editor component
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it''s time to incorporate the editor component we''ve just created within
    our current project. We will use the editor component to make three areas in our
    application editable in-place:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: The titles of tasks within our task list
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The title of projects
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The description of projects
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start by integrating our in-place editor component into our task list
    component and making the titles of our tasks editable. Open up the file located
    in `src/app/tasks/task/task.component.html` and apply the following changes:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Instead of just rendering the task title directly, we will now use our editor
    component to render the task title. We're binding the task title onto the `content`
    input property of our editor and calling a new method called `updateTitle` when
    the editor is emitting a `outSaveEdit` output. The `showControls` input property
    needs to be set to `true`, otherwise the editor will always stay in read-only
    mode.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the new `updateTitle` method in the task component class located
    in `src/app/tasks/task/task.component.ts`. The following code excerpt shows the
    added method in bold; unchanged code parts are hidden using the ellipsis character:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `updateTitle` method is very similar to the already present `updateTask`
    method. The difference is that we're emitting an updated task model which contains
    the updated title from out editor component. The `updateTask` method is emitting
    an updated task model where the done flag was updated.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that we can re-use the `outUpdateTask` output makes our change to
    integrate the editor component very simple. To help you recall the data flow that
    is now happening within our component tree, let''s look at all the different pieces
    involved once again:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: A user clicks the edit button within the editor component inside a task component
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After editing and clicking the save button, an `outSaveEdit` output with the
    updated title is emitted from the editor and our `updateTitle` method is called
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `updateTitle` method is emitting a new task object containing the updated
    title using the `outUpdateTask` output
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The task list component is delegating the `outUpdateTask` output to its parent
    using an output with the same name.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The task list container component is catching the updated task and calls the
    `updateTask` method on our task list service
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the service has updated the data in our in-memory web API database, the
    updated task list will be passed down the component tree again until the task
    we've just updated arrives at the specific task component again, where it will
    also update the `content` input of our editor
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once again, our reactive and unidirectional data flow pays off when it comes
    to state architecture. With minimal changes, we've added a new feature to make
    our task titles editable in-place. Also, the way our data flows has not increased
    in complexity by implementing this change.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s apply similar changes to make our project title and description editable.
    Let''s start by implementing changes to the template of our project component
    located in `src/app/project/project/project.component.html`. Again, changes are
    in bold and unchanged parts are hidden using the ellipsis character:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This time, we''re using two editors, one for our project title and one for
    the description. The rest of the changes are very similar to the changes we''ve
    applied to our task component. We''re using two new methods called `updateTitle`
    and `updateDescription`, which we now need to add in the project component class
    located in `src/app/project/project/project.component.ts`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Since we did not have anything to update in our project component as of yet,
    we first need to add a new output called `outUpdateProject` to notify our parent
    component about an updated project. The two methods `updateTitle` and `updateDescription`
    are both emitting an updated version of the project data using the updated information.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to update our project container component to handle the newly
    introduced project updates. Let''s start by changing the view template located
    in `src/app/container/project-container/project-container.component.html`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We''re handing the new `outUpdateProject` output of our project component and
    calling a new method called `updateProject`. Let''s look at the implementation
    of this method in the project container component class located in `src/app/container/project-container/project-container.component.ts`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Within the newly added method, we're calling the `updateProject` method on the
    project service and passing the project object that was initially emitted by the
    project UI component.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s implement the `updateProject` method within our project service
    to update project data using the Angular HTTP service. Let''s open the `src/app/project/project.service.ts`
    file and apply the following changes:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Nothing new here. We're using the Angular HTTP service to execute a post request
    to the in-memory web API. After a successful call, we're calling the `loadProjects`
    method on our service, which will emit an updated project list using the `projects`
    behavior subject. This will cause all of our reactive subscriptions to receive
    the updated list of projects and update accordingly.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You've successfully created and integrated our editor component
    to make project titles, descriptions, and task titles editable. Now is a great
    time to preview your changes in the browser and play around with the editing capabilities
    we've added using the editor component. Using an in-place editor, we've simplified
    the authoring process within our application for our users. Also, by using a reactive
    data architecture, the editing feels very responsive and intuitive.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Recap
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within this building block, we have created an in-place editor component, which
    we can use to make things editable for any content within our application. It
    allows us to provide the user with contextual editing capabilities, which will
    result in a fantastic overall user experience.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also learned about the following topics:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Using the `contenteditable` HTML5 attribute to enable in-place editing
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `@ViewChild` and `@ViewChildren` to query view child elements
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `ElementRef` dependency to perform native DOM operations
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the logic, using the `OnChange` as well as the `AfterViewInit`
    life cycle hooks, to reflect data between Angular and content that is not in immediate
    control of Angular
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with users
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Going forward, we'll start dealing with user-generated content within our application
    and therefore require a minimal setup that allows us to deal with users correctly.
    We're creating a model to represent users as well as a simple user service that
    will tell us about the currently logged in user. Our service will just act as
    a mock user service and concerns like registration, login, and authentication
    are not within the scope of this book.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s stick to the practice we''ve established within this book and start
    by introducing the model for our users. Let''s open the `src/app/model.ts` file
    and add the following interface at the end of the file:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Let''s keep this as minimal as possible. Our users will consist of only an
    ID, name, and a URL to a profile picture. As a next step, let''s add a new users
    resource to our in-memory web API database. Open up the `src/app/database.ts`
    file and apply the following changes. Updated content is marked in bold while
    the ellipsis character indicates unchanged, hidden parts of the code:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We've used our newly created user model to add a new users resource to the in-memory
    database. Currently, we'll only store one user within the users resource.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: You can see from the `pictureUrl` inside of the added user object that we're
    referencing a path called `/assets/user.svg`. You can download this resource from
    this book's online resource repository. Please find the exact download link in
    the Download section of Chapter 13, *Task Management Application Source Code*.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: You can also choose your personal profile picture instead of the generic profile
    picture that is available in the book resources. Either way, after preparing the
    image, you need to store it on the path `src/assets/` and set the filename to
    match what is specified in our user object within the in-memory database.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: User service
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Alright, we''ve prepared our model and database for handling users within our
    application. Now, we can create a new service that we are using in our container
    components to obtain the currently logged in user. Let''s create a user service
    using the Angular CLI:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Let''s open the stub service generated on the `src/app/user/user.service.ts`
    path and replace its content with the following code:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We're keeping things simple here. The only method we're providing from our service
    is the `getCurrentUser` method, which will execute a call to our in-memory web
    API and return the first user in the users resource.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: That's already everything for our user service. Next up, we're going to create
    two simple UI components to display the logged in user within our application.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: User area component
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already created the data structures required to represent users within
    our application. We''ll now make use of this to create a user area that shows
    the user profile of the currently logged in user. The user area will be placed
    above the main navigation within the left-hand side area in our application layout:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e786b6fe-c402-4b8b-8f96-94c0fcdfa639.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
- en: The user area component will be positioned above our main navigation
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we will be creating a reusable component to render user profile
    pictures. Let''s use the Angular CLI to generate the stub of our profile picture
    component:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Alright, let''s open the component class file located in `src/app/user/profile-picture/profile-picture.component.ts`
    and change its content to the following code:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Our profile picture component has one straightforward responsibility: to render
    the profile picture of a user. It accepts an input `user` of our model type `User`.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: The Angular framework is concerned about security, and when we are rendering
    security relevant HTML, we need to tell Angular that this specific operation should
    be considered as trusted. In our case, we will render the image source attribute
    to display user profile pictures dynamically using Angular. Image source attributes
    are considered vulnerable because they execute get requests, can contain user-generated
    content, and therefore could also contain some attack vectors.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: When we're using plain string URLs within HTML resource elements, like image,
    script, or link elements, Angular will raise an error. If we want to render an
    expression to an image source attribute within an Angular template, we need to
    use Angular's DOM sanitizer to create a trusted URL first.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the different use cases for using the Angular `DomSanitizer`
    to mark vulnerable resources as trusted:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '| **Use-case** | **Component class** | **Template usage** |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
- en: '| Render HTML |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
- en: '[PRE68]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '|'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '|'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '| Render Styles |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
- en: '[PRE70]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '|'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '|'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '| Render links |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
- en: '[PRE72]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '|'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '|'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '| Resources |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
- en: '[PRE74]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '|'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '|'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Note that bypassing security is not always a good solution. If you're rendering
    user-generated content that could contain attack vectors, you should consider
    sanitizing this content. The `DomSanitizer` of Angular provides a `sanitize` method
    that allows you to sanitize content for different contexts. It will strip out
    and escape security relevant parts of the content and return a sanitized version
    of it.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Inside of our profile picture component class, we are using the DOM sanitizer
    to create a trusted resource URL that we can then use within our template. We're
    sanitizing the user profile picture URL inside of the `OnChanges` life cycle hook.
    This way, if we're changing the user input, the trusted resource URL will also
    be updated.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open the template of our profile picture component located in `src/app/user/profile-picture/profile-picture.component.html`
    and replace the content with the following code:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This is all we need in our profile picture component template. We can now use
    the trusted picture URL inside the `src` attribute, binding on an image element.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, let''s move on to the main component we''d like to create for our
    user area within the left-hand side area of our application layout. We''re using
    Angular CLI again to create the stub of our user area component:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Let''s jump right into the component class file located in `src/app/user/user-area/user-area.component.ts`
    and replace the content with the following code:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Nothing special here. The user area component accepts a `user` input to render
    the profile information of a specific user. Also, we're adding an `openTasksCount`
    input to the component. This will be used to show a message about how many open
    tasks currently exist overall in the projects within the application.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the user area component template located in `src/app/user/user-area/user-area.component.html`
    and replace the content with the following code:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: First, we're rendering the users' profile picture by using our newly created
    profile picture component. We're just forwarding the user object that we provided
    as an input to our user area component down to the profile picture component.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Inside of the information container DIV element, we're rendering a welcome message
    for our user as well as a message to show the number of open tasks.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: That wasn't too complicated. We've just created two UI components for our user
    feature. The user area UI component is rendering a section within the side area
    of our primary layout to show some profile information about the currently logged
    in user. We've also built a reusable profile picture component, which is rendering
    a user's profile image based on a user object.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the user area component
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it's time to incorporate our user component into our main layout. For this,
    we're going to modify our root application component, which is acting as our outermost
    container component.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open the component class of our app component located in `src/app/app.component.ts`
    and apply the following changes:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: We've introduced two new observables within our app component.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: The `openTasksCount` observable is based on the task list observable we obtain
    by calling `getTasks` on our task list service. The task list observable is emitting
    the most recent list of all tasks within our application. Based on that, we're
    using the RxJS map operator to map the list of tasks as input to the count of
    open tasks as output. This results in an observable stream that always emits the
    most recent number of open tasks within our application.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: The second observable, `user`, is obtained merely by calling the `getCurrentUser`
    method on our recently created user service.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the changes within our app component template. Open the
    `src/app/app.component.html` file and apply the following changes. Effective changes
    are highlighted in bold while some unchanged code parts are hidden using the ellipsis
    character. Make sure that you only update the highlighted parts of your code:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: We're rendering a user area component and passing the required inputs by subscribing
    to our observables directly in the view using the `async` pipe. Now, as soon as
    the logged in user or the amount of open tasks changes, our user area component
    will receive the updated values as input.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Well done! You've successfully created a user area component that you can now
    preview in your browser. Try to mark tasks as done and watch the user that is
    being updated based on the overall amount of open tasks.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Our main layout of the application is now complete, and all further enhancements
    will build on that basic layout.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Building a commenting system
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ve created our main project components, a reusable editor
    component, and within the previous topic, we''ve created and integrated a user
    area component. Within this topic, we''re going to create a commenting system
    that enables users to write comments on projects. The commenting system will use
    our editor component to make existing comments editable. We''re also using our
    user feature and the profile picture component to visualize user comments. Based
    on the authoring user of comments, we will decide if existing comments are editable
    for the logged in user:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e4d56bd-64f9-43b4-9b44-54a57d54411c.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
- en: An illustration of the component subtree of our commenting system
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram illustrates the architecture of the component tree within
    the commenting system that we are about to create.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: The comments component will be responsible for listing all the existing comments,
    as well as creating new comments. A comment component represents each comment
    itself. Comment components use an editor that enables users to edit comments once
    they are created.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: The editor component emits an output called `outSaveEdit` once editable content
    is saved using the control buttons of the editor. In the comment component, we
    will capture the output and propagate a new output upwards to our comments component.
    From there, we will delegate the output further to a new project comments container
    component that we're creating in this topic. The project comments container will
    be responsible for storing and retrieving comments using the project service.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: The comments component will also be responsible for providing the necessary
    UI logic to create new comments. The creation of further comments will also be
    communicated to the project comments container using component output. There,
    we will use the project service to add the newly created comment.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Introducing a model for comments
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we move on to creating more components within our application, let's
    first define the model and data we're using to represent comments.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open up our model file located in `src/app/model.ts` and apply the following
    changes:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: We've added two new interfaces to represent our comments. The `Comment` interface
    consists of a `time` property that holds a number timestamp of the time the comment
    was created. We also store the user who commented and of course the comment itself
    using a property named `content`.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: The `CommentUpdate` interface is used for communicating comment updates across
    components and services.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: We've also updated the model of our projects to include an additional field
    called `comments`. That's where all project comments will be stored.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''re changing the `Project` interface to include a new property called
    `comments`, we also need to make sure our database is updated with this change.
    Let''s open our database located in the `src/app/database.ts` file and apply the
    following changes:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The only difference in this file is that we've added the new `comments` property
    on our project objects. For both projects, we're just adding an empty array with
    no pre-existing comments.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Alright, that's all the changes required in our data and model for now. Let's
    move on to the creation of our commenting system.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Building the comment component
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start making our commenting system by fleshing out the comment component
    first. In addition to the comment itself, we'd like to display the user's profile,
    who commented, and the time of the comment.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: To display the time, we will make use of relative time formatting, as this will
    give our users a better feel of time. Relative time formatting presents timestamps
    in the format "5 minutes ago" or "1 month ago", in contrast to absolute timestamps,
    such
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: as "25.12.2015 18:00". Using a famous third-party library called Moment.js,
    we'll create a view pipe that we can use within component templates to convert
    timestamps and dates into a relative time format.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: View pipes are a great way to enrich the template language of Angular. They
    allow you to create helper functions that you can then use within the view inside
    of your component templates. So far, we've only used one view pipe, the `AsyncPipe`,
    which was used to subscribe to observable streams directly inside of the component
    view. Within this section, we'll create our view pipe, which can be used to format
    dates using the Moment.js library.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to install Moment.js as a production dependency to our
    project. Open up a terminal within the root folder of your project and execute
    the following command:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'After Moment.js is installed, we can go ahead and create our first view pipe.
    We can also use the Angular CLI to generate the stub code of our pipe for us:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Alright, the Angular CLI should have created a new view pipe for us with the
    name `fromNow`. Let''s open the view pipe code located in the `src/app/pipes/from-now.pipe.ts`
    file and change its content to the following code:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: All view pipes need to be decorated using Angular's `@Pipe` decorator. Inside
    of the configuration object, we can pass this to the decorator factory, and specify
    the name of the pipe. This name is how we address the view pipe within our component
    templates.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: 'View pipe classes should always implement an interface called `PipeTransform`.
    This interface will ensure that the mandatory method, `transform`, is implemented
    within our pipe class. The transform method is the central piece of every view
    pipe. This function will be called when a pipe is used within the view template
    of a component. Let''s look at a basic example of how a view pipe is used inside
    of a template:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'In this essential case, we''re using a view pipe with the name `toUpperCase`.
    Angular will take the value on the left-hand side of the expression and pass it
    to the `transform` method of the `toUpperCase` pipe as the first parameter. The
    value that is returned from the `transform` method is then evaluated and rendered
    into the view. We can also compose multiple view pipes by chaining them after
    each other:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: In this example, the name will be passed to the `transform` method of the `reverse`
    pipe. The returned value of the `reverse` pipe's `transform` method will then
    be passed as the first parameter to the `transform` method of the `toUpperCase`
    pipe. Like this, you can chain an indefinite amount of pipes onto each other to
    transform component properties directly in your component view template.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: View pipes are treated as stateless by default. Angular uses this assumption
    to perform some optimizations in the background. If pipes and their `transform`
    methods can be considered stateless and pure, Angular can cache the results of
    pipe transformations and re-use the cached values later on. This behaviour is
    okay in most cases, and we don't want to miss out on that performance optimization.
    However, sometimes it's required to rely on some services or other sources of
    state to determine the result of a pipe transformation. In such a case, the `transform`
    method of a pipe is not pure, and therefore cannot be cached. To tell Angular
    that our pipe is not pure, you can use an additional configuration property on
    pipes called `pure`. If you set this property to false, your pipe transformations
    will not be cached, and Angular will execute your `transform` method every time
    your view is rendered.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use our newly created `fromNow` pipe to format the timestamp of comments
    within our comment component. We''re using the Angular CLI again to create the
    structure for the comment component:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Let''s open the component template file located in `src/app/comments/comment/comment.component.html`
    and replace its content with the following code:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: We're reusing our profile picture component to render the comment author user.
    To display the time of the comment in a relative format, we'll use the `fromNow`
    pipe that we created earlier.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will make use of the in-place editor component to display the content
    of the comment and make it editable at the same time. We will bind the comment
    content property to the `content` input property of the editor. At the same time,
    we will listen for the `outSaveEdit` output of the editor and call the `updateComment`
    method on our comment component class.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: We're also deciding if the currently logged in user passed into our component
    as `user` input is the authoring user of the given comment and then use this information
    to either enable or disable the controls on our editor using the `showControls`
    input property. This way, the current user is only allowed to edit a comment if
    he/she's also the author of that comment.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also create our component class and open the `src/app/comments/comment/comment.component.ts`
    file to replace its content with the following code:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The component code is pretty straightforward. As input, we expect a user object
    that is passed along to the `user` input property. This property represents the
    currently logged in user and is used within our template to determine if a user
    should be able to edit the comment. The `comment` input property is expected to
    be an object of type `Comment`. From there, we gather the comment content, the
    time of creation, and the comment author user.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the view template of our comment component, we can observe that
    the `outSaveEdit` output on the editor component will call the `updateComment`
    method in our comment component. Inside of the `updateComment` method, we're creating
    a copy of our comment object and updating its content with the editor output.
    This copy is then emitted using the `outUpdateComment` output of the comment component.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: That's all we need for our comment component. Next up, we're going to create
    the comments component, which represents a list of comments and embraces the necessary
    UI element to create new comments.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: Building the comments component
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last missing piece of the puzzle for our commenting system is the comments
    component, which will list all the comments and provide the UI to create new comments:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7960e916-5e1f-4b48-b681-8743f531e4d2.png)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
- en: The comments component allows users to add comments to projects
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the Angular CLI to create the structure for our comments component:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'First, let''s edit the template of our comments component located in `src/app/comments/comments/comments.component.html`:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: To allow users to create new comments, we're making use of the contenteditable
    API by adding a DIV element that contains the `contenteditable` attribute. We're
    using a local view reference called `#commentContentEditable` on that element
    so that we can quickly reference it from within our component class.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: To add a new comment, we will use a button with a click event binding that calls
    the `createComment` method on our component class.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Below the section where users can add new comments, we will create another section
    that will list all the existing comments. If no comments exist, we just don't
    render the section.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: We're using a particular view element called `<ng-container>` to group our All
    comments title together with the list of comments. This container element is handy
    in situations where you're using template elements, like with the use of `NgIf`,
    but you don't want to create an artificial HTML element for that purpose. Using
    an `<ng-container>` element in conjunction with `NgIf` allows you to show or hide
    a list of elements conditionally, but without the need to have a common parent
    HTML element.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: With the help of the `NgFor` directive, we are repeating over all existing comments
    and rendering a comment component for each repetition. We are binding the comment
    object to our comment component and also adding an output binding to handle updated
    comments.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the class of our comments component by changing the content of
    the `src/app/comments/comments/comments.component.ts` file:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Our component class has two inputs. The `user` input is expected to be set to
    the currently logged in user. The comments input is a list of comments that is
    used in our component view to iterate over and render comment components.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: We also have two outputs in our component. The fist one, `outUpdateComment`,
    is used to tell our parent that one of the comments has been updated. The output
    value is of type `CommentUpdate`, which holds the index of the comment that got
    updated and the comment object itself. Inside of the `updateComment` method, which
    is called from the binding on comment components in our view, we're constructing
    a comment update object and emitting it through the `outUpdateComment` output.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: The `outCreateComment` output is used to tell our parent that a new comment
    should be created. The `createComment` method is used to create a new comment
    object and emit it through that output. Additionally, we're using a view query
    to get hold of the editable DOM element within our component view and store it
    into the member property `commentContentEditable`. When a new comment is created
    using the `createComment` method, after we've emitted the newly created comment
    object, we're using the reference to the editable item to reset its text content.
    This way, after creating a new comment, the editable content element will be blank
    again.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the commenting system into projects
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've created our comments model and updated our in-memory web API database.
    We've created the comment and comments components along with a new view pipe called
    `fromNow` to format relative times in our comment view template. The only missing
    part is to integrate our comments component in our project. For this, we are making
    use of the second tab on our project component, which we've already prepared for
    for our commenting system. To keep our data flow tight, we're introducing a final
    component to fill the gap between our projects and the comments component.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use Angular CLI to create the project comments container component:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'After the component files have been generated, let''s open the class file located
    in `src/app/container/project-comments-container/project-comments-container.component.ts`
    and replace its content with the following code:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Within our project comments container, we're storing three different observables.
    Let's take a look at each of them and their purposes.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: The `user` observable emits the currently logged in user. Within the constructor
    of our container component, we're calling the `getCurrentUser` method on the user
    service to obtain the observable.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: The `selectedProject` observable is obtained by calling `getSelectedProject`
    on our project service. This observable will always emit the currently selected
    project. If we're choosing a different project in our main navigation, the newly
    selected project is emitted through this observable.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `projectComments` observable is a transformed observable with the
    `selectedProject` observable as a source. We would like to access the project
    comments directly so we can use them as input to our commenting system. By using
    the `map` operator inside a pipe transformation, we can select the `comments`
    field of the selected project and create a new output observable that is always
    emitting the comments list of the selected project.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we're providing two methods, `createComment` and `updateComment`, to
    create or update comments using the project service. We're obtaining the latest
    value of the `selectedProject` observable by utilizing the `take` operator and
    updating an existing or adding a new comment using the project service, respectively.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: That's it for the code of our component class. You should be reasonably familiar
    with the logic inside of our container component. The patterns we're using are
    very similar to those from our existing task list container, or the ones present
    in our app component.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open the view template of our project comments container component located
    in `src/app/container/project-comments-container/project-comments-container.component.html`
    and change its content to the following code:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: There is nothing we wouldn't expect from a regular container component template.
    We're merely rendering a comments UI component and binding all inputs and outputs
    of the component to the logic and data within our container component class. Again,
    we're making our comments UI component highly reusable by separating the state
    and data concerns with the use of a container component.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, we''re almost finished integrating our commenting system. The last
    missing bit is to include our project comments container component within our
    project component. Let''s open the view template of the project component located
    in `src/app/project/project/project.component.html` and apply the necessary changes
    to render our commenting system:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: We're just reusing the same logic we've already used to render our task list
    container. We ensure that our tabbed interface within the project component activates
    the project comments container component by placing an `NgIf` with the respective
    condition.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: There you go! That wasn't too complicated, was it? We've finally created and
    integrated a commenting system on our projects. Due to the way we've built our
    commenting system, we can integrate comments in any other location we want to.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'Preview your changes in the browser and play around with the commenting functionality
    a bit to get familiar with what you''ve just built:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09c1e366-895d-482f-ae50-97f2acc364a6.png)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
- en: Screenshot of the commenting system that is integrated within our project component
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Recap
  id: totrans-479
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within this topic, we have successfully created a fully-fledged commenting system
    that can be placed in various areas of our application to enable commenting. Users
    can interact with in-place editors to edit the content in comments, which gives
    them a great user experience.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: 'While writing the code for our commenting system, we learned about the following
    topics:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: Creating a re-usable commenting system that can be used to add commenting functionality
    in every area of our application
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a simple pipe using the `@Pipe` decorator and the Moment.js library
    to provide relative time formatting
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `<ng-container>` element to group elements for use within a template
    directive
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-using the editor component as an in-place editor within the comment component
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main topic of this chapter was the introduction of projects. We've created
    the necessary model and data layer to deal with projects to group individual tasks.
    We've also created UI components to display project information and a tabbed user
    interface component that we can reuse wherever we need it. We learned about the
    concept of content projection, which allows us to build beautiful content-based
    APIs for our components.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: We've further structured our main layout and introduced some navigation components
    that we're currently using to provide a project navigation.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: We created a simple in-place editor that provides an excellent authoring experience
    within our application. Going forward, we can use the editor component wherever
    we want to make content editable for our users. They will not have to jump into
    disturbing dialogues or separate configuration pages, and will be able to edit
    directly within their current context. This is an excellent tool for enhancing
    the experience of our users.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: Besides our shiny new editor component, we created a whole commenting system
    that can be easily included in areas of our application where we'd like to provide
    commenting capabilities. We have added the commenting system within our project
    and users can now comment on projects by navigating to the Comments tab on the
    project details.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: The project navigation and the tabbed interface we've built are both great.
    However, it would be nice to think that the concern of navigation could be separated
    from our regular application composition. We also want to leverage the browser's
    location URL and the native functionality of the browser history. Within the next
    chapter, we're going to address this and learn everything required to integrate
    the Angular router into our application.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
