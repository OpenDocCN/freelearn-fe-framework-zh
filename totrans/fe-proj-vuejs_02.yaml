- en: 2\. Working with Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 处理数据
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will expand on what you learned in the previous chapter
    by introducing more ways to control data inside Vue components. You will learn
    how to set up advanced watchers to observe data changes inside your components,
    and utilize Vue's powerful reactive data feature, computed data properties, to
    concisely output just the data you need in your template. You will also be able
    to utilize asynchronous methods to fetch data for your Vue components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将通过介绍更多控制 Vue 组件内部数据的方法来扩展上一章所学的内容。你将学习如何设置高级监视器来观察组件内部的数据变化，并利用 Vue 强大的反应性数据特性，计算数据属性，在模板中简洁地输出所需的数据。你还将能够利用异步方法为
    Vue 组件获取数据。
- en: By the end of this chapter, you will be able to watch, manage, and manipulate
    data from various sources in your Vue.js components.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够监视、管理和操作 Vue.js 组件中的各种数据源。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, you were introduced to the concepts of single-file
    components and the Vue API, which provides access to methods, directives, and
    data properties. Building on these foundations, we will be introducing computed
    properties, which, like data properties, are reactive in the UI but can perform
    powerful calculations, and their results are cacheable, increasing the performance
    of your project. When building e-commerce stores, you will usually want to calculate
    pricing and cart items reactively as users interact with your UI, which in the
    past would need to be achieved without a page reload using something like `jQuery`.
    Vue.js makes short work of these common frontend tasks by introducing computed
    properties that react immediately to frontend user input.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你被介绍了单文件组件的概念和 Vue API，它提供了访问方法、指令和数据属性的方式。基于这些基础，我们将介绍计算属性，它们与数据属性一样，在
    UI 中是反应性的，但可以执行强大的计算，并且它们的结果是可缓存的，这提高了你项目的性能。当构建电子商务商店时，你通常希望用户与你的 UI 交互时，反应性地计算定价和购物车项目，这在过去需要在不重新加载页面的情况下使用类似
    `jQuery` 的方法来实现。Vue.js 通过引入计算属性，这些计算属性可以立即对前端用户输入做出反应，轻松处理这些常见的前端任务。
- en: Let's begin by introducing reactive data that can be computed on the fly and
    understanding how to call and manipulate asynchronous data.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从介绍可以即时计算的反应性数据开始，并了解如何调用和操作异步数据。
- en: Computed Properties
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算属性
- en: Computed properties are a unique data type that will reactively update when
    source data used within the property is updated. They may look like a Vue method,
    but they are not. In Vue, we can track changes to a data property by defining
    them as a computed property, add custom logic within this property, and use it
    anywhere within the component to return a value. Computed properties are cached
    by Vue, making them more performant for returning data than a data prop or using
    a Vue method.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性是一种独特的数据类型，当属性中使用的源数据更新时，它们会反应性地更新。它们看起来可能像 Vue 方法，但实际上不是。在 Vue 中，我们可以通过将数据属性定义为计算属性来跟踪数据属性的变化，在这个属性中添加自定义逻辑，并在组件的任何地方使用它来返回一个值。Vue
    会缓存计算属性，这使得它们在返回数据方面比数据属性或使用 Vue 方法更高效。
- en: 'Instances where you may use a computed property include but are not limited
    to:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能使用计算属性的场景包括但不限于：
- en: '`total` data property is less than `1`. The computed property for `total` will
    update every time a new piece of data is added to the `items` array:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`total` 数据属性小于 `1`。每当向 `items` 数组添加新的数据时，`total` 的计算属性将更新：'
- en: '[PRE0]'
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will generate the following output:'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '[PRE1]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`formalName`, that can be used within your component:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`formalName`，可以在你的组件中使用：'
- en: '[PRE2]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will generate the following output:'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '[PRE3]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`post`. You will use the simplified and semantic computed properties to output
    the information into your components template. The computed properties in this
    example make it easier to identify and use the author''s full name, see how many
    posts they have produced, and have the data to display their featured post:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post`。你将使用简化和语义化的计算属性将信息输出到组件模板中。本例中的计算属性使得识别和使用作者的完整姓名、查看他们发布了多少帖子以及显示他们的特色帖子变得更容易：'
- en: '[PRE4]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will generate the following output:'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '![Figure 2.1: The computed name output'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.1：计算名称输出](img/B15218_02_01.jpg)'
- en: '](img/B15218_02_01.jpg)'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_02_01.jpg](img/B15218_02_01.jpg)'
- en: 'Figure 2.1: The computed name output'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：计算名称输出
- en: Computed properties are very valuable to a Vue developer when creating performant components.
    In the next exercise, we will explore how to use this inside of a Vue component.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性对于创建高性能组件的 Vue 开发者来说非常有价值。在下一个练习中，我们将探讨如何在 Vue 组件内部使用它。
- en: 'Exercise 2.01: Implementing Computed Data into a Vue Component'
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.01：将计算数据集成到 Vue 组件中
- en: In this exercise, you will use a computed property to help cut down the amount
    of code you need to write inside your Vue templates by concisely outputting basic
    data. To access the code files for this exercise, refer to [https://packt.live/3n1fQZY](https://packt.live/3n1fQZY).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用计算属性来帮助你减少在 Vue 模板内部需要编写的代码量，通过简洁地输出基本数据。要访问此练习的代码文件，请参阅 [https://packt.live/3n1fQZY](https://packt.live/3n1fQZY)。
- en: 'Open a command-line terminal, navigate into the `Exercise 2.01` folder, and
    run the following commands in order:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行终端，导航到 `Exercise 2.01` 文件夹，并按顺序运行以下命令：
- en: '[PRE5]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Go to `https://localhost:8080`.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前往 `https://localhost:8080`。
- en: 'Create an input field for the first name, use `v-model` to bind the data prop
    `firstName` to this field:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于第一个名称的输入字段，使用 `v-model` 将数据属性 `firstName` 绑定到该字段：
- en: '[PRE6]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a second input field for the last name, and use `v-model` to bind the
    data prop `lastName` to this field:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个输入字段用于姓氏，并使用 `v-model` 将数据属性 `lastName` 绑定到该字段：
- en: '[PRE7]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Include these new `v-model` data props in the Vue instance by returning them
    in the `data()` function:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 `data()` 函数中返回这些新的 `v-model` 数据属性，将它们包含在 Vue 实例中：
- en: '[PRE8]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a computed data variable called `fullName`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `fullName` 的计算数据变量：
- en: '[PRE9]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Underneath your input fields, using `heading` tags, output the computed data:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的输入字段下方，使用 `heading` 标签输出计算数据：
- en: '[PRE10]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will generate the following output:'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '![Figure 2.2: Output of the computed data will show the first and last name'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.2：计算数据的输出将显示姓名和姓氏]'
- en: '](img/B15218_02_02.jpg)'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15218_02_02.jpg]'
- en: 'Figure 2.2: Output of the computed data will show the first and last name'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：计算数据的输出将显示姓名和姓氏
- en: In this exercise, we saw how we can write an expression inside a computed data
    property using data from the `v-model` and combine the first name and last name
    into a single output variable that can be reused.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何在计算数据属性内部编写表达式，使用 `v-model` 的数据，并将第一个名称和姓氏合并成一个可以重用的单个输出变量。
- en: Computed Setters
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算设置器
- en: In the last exercise, you saw how to write maintainable and declarative computed
    properties that are reusable and reactive and can be called anywhere within your
    component. In some real-world cases when a computed property is called, you may
    need to call an external API to correspond with that UI interaction or mutate
    data elsewhere in the project. The thing that performs this function is called
    a setter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，你看到了如何编写可维护和声明式的计算属性，这些属性是可重用和响应式的，并且可以在组件内的任何地方调用。在某些实际情况下，当调用计算属性时，你可能需要调用外部
    API 来与该 UI 交互或更改项目中的其他数据。执行此功能的东西被称为设置器。
- en: 'Computed setters are demonstrated in the following example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 计算设置器在以下示例中演示：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'By default, computed data is a getter only, which means it will only output
    the outcome of your expression. In this example, the computed `myComputedDataProp`
    data prop will output `1` in your Vue component:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，计算数据仅是获取器，这意味着它只会输出你的表达式的结果。在此示例中，计算 `myComputedDataProp` 数据属性将在你的 Vue
    组件中输出 `1`：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Then, using a setter in a computed property allows you to reactively listen
    to data and run a callback (setter) that contains the returned value from the
    getter, which can optionally be used in the setter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用计算属性中的设置器可以让你响应式地监听数据并运行一个回调（设置器），该回调包含从获取器返回的值，这些值可以可选地用于设置器中。
- en: 'In this example, the setter will update the data prop count to its new value
    (reflected in the getter) and then call a method within the component called `callAnotherApi`.
    Here, we pass in the count data prop to mimic sending this information somewhere
    useful:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，设置器将更新数据属性 `count` 到其新值（在获取器中反映）并调用组件内的一个方法 `callAnotherApi`。在这里，我们传递
    `count` 数据属性来模拟将此信息发送到某个有用的地方：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You will find out exactly how to use computed data as both getters and setters
    in the following exercise.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，你将了解到如何将计算数据作为获取器和设置器使用。
- en: 'Exercise 2.02: Using Computed Setters'
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.02：使用计算设置器
- en: In this exercise, you will use a computed prop as a setter and a getter, which
    will both output expressions and set data when triggered by a user's input.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用计算属性作为设置器和获取器，这两个属性在用户输入触发时都会输出表达式并设置数据。
- en: To access the code files for this exercise, refer to [https://packt.live/2GwYapA](https://packt.live/2GwYapA).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://packt.live/2GwYapA](https://packt.live/2GwYapA)。
- en: 'Open a command-line terminal, navigate into the `Exercise 2.02` folder, and
    run the following commands in order:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行终端，导航到`Exercise 2.02`文件夹，并按顺序运行以下命令：
- en: '[PRE14]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Go to `https://localhost:8080`.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 访问`https://localhost:8080`。
- en: 'Create an input field with a `v-model` value bound to a computed data value
    called `incrementOne`, return the value of a Vue data variable called `count`
    in the getter, and set the `count` variable in the setter:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`v-model`值绑定到名为`incrementOne`的计算数据值的输入字段，在getter中返回名为`count`的Vue数据变量的值，并在setter中设置`count`变量：
- en: '[PRE15]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of the preceding code will be as follows:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码的输出将如下所示：
- en: '![Figure 2.3: First steps of a computed setter and getter'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图2.3：计算setter和getter的第一步'
- en: '](img/B15218_02_03.jpg)'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_02_03.jpg)'
- en: 'Figure 2.3: First steps of a computed setter and getter'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.3：计算setter和getter的第一步
- en: 'Next, let''s utilize the setter again. We will divide whatever the new `val`
    argument is by `2`, and save that to a new data variable called `divideByTwo`:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们再次使用setter。我们将把新的`val`参数除以`2`，并将其保存到名为`divideByTwo`的新数据变量中：
- en: '[PRE16]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Update the setter to divide `val` by `2`, and bind this new value to the `divideByTwo`
    variable:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将setter更新为除以`val`，并将这个新值绑定到`divideByTwo`变量：
- en: '[PRE17]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output of the `divideByTwo` value should generate an outcome from the value
    entered in the input field, as follows:'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`divideByTwo`值的输出应生成从输入字段中输入的值的输出，如下所示：'
- en: '![Figure 2.4: The outcome of the divideByTwo value'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图2.4：divideByTwo值的输出'
- en: '](img/B15218_02_04.jpg)'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_02_04.jpg)'
- en: 'Figure 2.4: The outcome of the divideByTwo value'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：divideByTwo值的输出
- en: In this exercise, we saw how we can use computed data to both get and set data
    reactively in our template by binding computed variables to the `v-model`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何通过将计算变量绑定到`v-model`来使用计算数据在我们的模板中反应性地获取和设置数据。
- en: Watchers
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听器
- en: Vue `oldVal` and `newVal`. This can help you when writing expressions to compare
    data before writing or binding new values. Watchers can observe objects as well
    as `string`, `number`, and `array` types. When observing objects, it will only
    trigger the handler if the whole object changes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Vue `oldVal`和`newVal`。这可以帮助你在写入或绑定新值之前比较数据。监听器可以观察对象以及`string`、`number`和`array`类型。当观察对象时，只有当整个对象发生变化时，才会触发处理程序。
- en: 'In *Chapter 1*, *Starting Your First Vue Project*, we introduced life cycle
    hooks that run at specific times during a component''s lifespan. If the `immediate`
    key is set to `true` on a watcher, then when this component initializes it will
    run this watcher on creation. You can watch all keys inside of any given object
    by including the key and value `deep: true` (default is `false`) To clean up your
    watcher code, you can assign a handler argument to a defined Vue method, which
    is best practice for large projects.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '在*第一章*，*开始您的第一个Vue项目*中，我们介绍了在组件生命周期特定时间运行的生存周期钩子。如果将`immediate`键设置为`true`，则当组件初始化时，将运行此监听器。你可以通过包含键和值`deep:
    true`（默认为`false`）来监视任何给定对象中的所有键。为了清理你的监听器代码，你可以将处理程序参数分配给定义的Vue方法，这对于大型项目来说是最佳实践。'
- en: Watchers complement the usage of computed data since they can passively observe
    values and cannot be used like normal Vue data variables, while computed data
    must always return a value and can be looked up. Remember not to use arrow functions
    unless you do not require the Vue context of `this`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 监听器补充了计算数据的用法，因为它们可以被动地观察值，不能像正常Vue数据变量那样使用，而计算数据必须始终返回一个值并且可以被查询。请记住，除非你不需要Vue的`this`上下文，否则不要使用箭头函数。
- en: 'The following watcher example demonstrates the `immediate` and `deep` optional
    keys; if any key inside of the `myDataProperty` object were to change it would
    trigger a console log:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了`immediate`和`deep`可选键；如果`myDataProperty`对象中的任何键发生变化，它将触发控制台日志：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, let's set some new values with the help of watchers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在监听器的帮助下设置一些新值。
- en: 'Exercise 2.03: Using Watchers to Set New Values'
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.03：使用监听器设置新值
- en: In this exercise, you will use watcher arguments to watch data properties for
    changes, then use this watcher to set variables via a method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用监听器参数来监视数据属性的变化，然后使用这个监听器通过一个方法设置变量。
- en: To access the code files for this exercise, refer to [https://packt.live/350ORI4](https://packt.live/350ORI4).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://packt.live/350ORI4](https://packt.live/350ORI4)。
- en: 'Open a command-line terminal, navigate into the `Exercise 2.03` folder, and
    run the following commands in order:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Go to `https://localhost:8080`.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set up the document by adding a discount and an `oldDiscount` data variable
    with some styling:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Observe the `discount` property by adding it to the `watch` object. Trigger
    a method called `updateDiscount`. Inside the method, set the `oldDiscount` data
    prop to be `this.discount + 5`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Include a method that will augment the `discount` variable and trigger the watcher:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now add a line break, and an anchor element with the `@click` directive bound
    to the `updateDiscount` method:'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output of the preceding command will be as follows:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.5: A shop watcher page should look something like this'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_02_05.jpg)'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 2.5: A shop watcher page should look something like this'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we saw how we can use watchers to observe and reactively manipulate
    data when data is changed by other methods in the Vue component.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn about deep watching concepts.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Deep Watching Concepts
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using Vue.js to watch a data property, you can purposefully observe keys
    inside an object for changes, rather than changes to the object itself. This is
    done by setting the optional `deep` property to `true`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This example will watch all available keys inside the organization data object
    for changes, so if the `name` property inside the organization changes, the organization
    watcher will trigger.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: If you do not need to observe every key inside of an object, it can be more
    performant to just watch a specific key inside an object for changes by specifying
    it as a `myObj.value` string. For example, you may allow a user to edit their
    company name and have that data sent to an API only when that key has been modified.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, the watcher is specifically observing the `name` key
    of the `organization` object.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We saw how deep watching works. Now, let's try the next exercise and watch the
    nested properties of a data object.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.04: Watching Nested Properties of a Data Object'
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will use watchers to observe keys within an object, which
    will update when a user triggers a method within the UI.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: To access the code files for this exercise, refer to [https://packt.live/353m59N](https://packt.live/353m59N).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a command-line terminal, navigate to the `Exercise 2.04` folder, and run
    the following commands in order:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Go to `https://localhost:8080`.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start by defining a `product` object that contains a `price` and `label` and
    a `discount` key. Output these values into the template:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Set up a button that will modify the price of the product. Do this by adding
    a button element with a `click` event bound to an `updatePrice` method that decrements
    the value of price:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When you click the button, it should reduce the price as seen in the following screenshot:'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.6: Screen displaying the reduced price of Blue juice'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_02_06.jpg)'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 2.6: Screen displaying the reduced price of Blue juice'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.6：显示蓝汁降价屏幕
- en: 'Time for the nested watcher. We will watch the `product` object''s `price`,
    and increment the `discount` data prop:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候观察嵌套观察者了。我们将观察 `product` 对象的 `price`，并增加 `discount` 数据属性：
- en: '[PRE29]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, as you reduce the `price`, the `discount` value will go up because of
    the watcher:'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，随着你减少 `price`，由于观察者的作用，`discount` 值将会上升：
- en: '![Figure 2.7 Output displaying an increased discount value'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.7 显示增加的折扣值]'
- en: '](img/B15218_02_07.jpg)'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15218_02_07.jpg]'
- en: Figure 2.7 Output displaying an increased discount value
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 显示增加的折扣值
- en: In this exercise, we used watchers to observe a key inside an object and then
    set new data with or without using the optional arguments parsed by the watcher.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用了观察者来观察对象中的键，然后使用或不用观察者解析的可选参数设置新数据。
- en: Methods versus Watchers versus Computed Props
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法与观察者与计算属性的比较
- en: In the Vue.js toolbox, we have access to methods, watchers, and computed properties.
    When should you use one or the other?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vue.js 工具箱中，我们有方法、观察者和计算属性。你何时应该使用其中一个或另一个？
- en: Methods are best used to react to an event occurring in the `date.now()`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 方法最适合在 `date.now()` 事件发生时做出反应。
- en: 'In Vue, you would compose an action denoted by `@click`, and reference a method:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vue 中，你会组合一个由 `@click` 标记的动作，并引用一个方法：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Computed props are best used when reacting to data updates or for composing
    complicated expressions for us in your template. In this instance, if the `animalList`
    data changes, the `animals` computed prop will also update by slicing the second
    item from the array and returning the new value:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性最适合在响应数据更新或为我们在模板中组合复杂表达式时使用。在这种情况下，如果 `animalList` 数据发生变化，`animals` 计算属性也将通过从数组中切片第二个项目并返回新值来更新：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Their reactive nature makes computed properties perfect for composing new data
    variables from existing data, such as when you are referencing specific keys of
    a larger, more complicated object, helping to simplify readability of your template.
    In this example, we output the authors twice in two different ways. However, notice
    in the `authorName` computed prop, you can compose conditional logic cleanly without
    bloating the HTML template:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的响应性使得计算属性非常适合从现有数据中组合新的数据变量，例如当你引用一个更大、更复杂对象的特定键时，有助于简化模板的可读性。在这个例子中，我们以两种不同的方式输出了作者两次。然而，请注意在
    `authorName` 计算属性中，你可以干净地组合条件逻辑，而不会使 HTML 模板膨胀：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Data watchers should be used when you need to listen to a data property change
    or a specific data property inside an object, and then perform an action. Because
    of the unique `newVal` and `oldVal` arguments of a watcher, you can watch a variable
    until a certain value is reached, and only then perform an action:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要监听数据属性的变化或对象中的特定数据属性变化，并执行一个动作时，应该使用数据观察者。由于观察者的独特 `newVal` 和 `oldVal` 参数，你可以观察一个变量直到达到某个值，然后才执行动作：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With this in mind, we will build a simple search functionality using a method,
    computed props, and a watcher to achieve a similar outcome and demonstrate the
    ability of each method.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个想法，我们将使用一个方法、计算属性和观察者来构建一个简单的搜索功能，以实现类似的效果并展示每种方法的能力。
- en: 'Exercise 2.05: Handling Search Functionality Using a Vue Method, a Watcher,
    and Computed Props'
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.05：使用 Vue 方法、观察者和计算属性处理搜索功能
- en: In this exercise, you will create a component that allows users to search data
    arrays using three different methods in Vue. By the end of the exercise, you will
    be able to see firsthand how each different method works.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个组件，允许用户使用 Vue 中的三种不同方法搜索数据数组。到练习结束时，你将能够亲眼看到每种不同方法是如何工作的。
- en: To access the code files for this exercise, refer to [https://packt.live/32iDJVe](https://packt.live/32iDJVe).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅 [https://packt.live/32iDJVe](https://packt.live/32iDJVe)。
- en: 'Open the command-line terminal, navigate to the `Exercise 2.05` folder, and run
    the following commands in order:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行终端，导航到 `Exercise 2.05` 文件夹，并按顺序运行以下命令：
- en: '[PRE34]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Go to `https://localhost:8080`.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前往 `https://localhost:8080`。
- en: 'In the `data` object, add a list of frameworks in an array, assigned to the
    `frameworkList` value. Include an empty string with the key to input and an empty
    array with a key of `methodFilterList`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `data` 对象中，添加一个框架列表数组，分配给 `frameworkList` 值。包括一个空字符串作为输入键和一个空数组作为 `methodFilterList`
    键：
- en: '[PRE35]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the template, include a `div` container, a `title`, and a `column` container.
    Inside this `column` container, create an input that is bound to the `v-model`
    input, and bind the `keyup` event on the input to the `searchMethod` method:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板中，包括一个`div`容器、一个`title`和一个`column`容器。在这个`column`容器内部，创建一个绑定到`v-model`输入的输入框，并将输入框上的`keyup`事件绑定到`searchMethod`方法：
- en: '[PRE36]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output of the preceding code will be as follows:'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面代码的输出将如下所示：
- en: '![Figure 2.8: Console should output the key input'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图2.8：控制台应输出关键输入'
- en: '](img/B15218_02_08.jpg)'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_02_08.jpg)'
- en: 'Figure 2.8: Console should output the key input'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.8：控制台应输出关键输入
- en: 'Inside our `searchMethod` method, write a filter expression that binds the
    `methodFilterList` data prop to a filtered `frameworkList` array based on the
    input value. Trigger `searchMethod` on the `created()` life cycle hook so that
    when the component loads, a list is present:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`searchMethod`方法中，编写一个过滤表达式，将`methodFilterList`数据属性绑定到基于输入值的过滤`frameworkList`数组。在`created()`生命周期钩子上触发`searchMethod`，以便当组件加载时，有一个列表存在：
- en: '[PRE37]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'On running the preceding code, you will be able to filter the list as shown
    in *Figure 2.9*:'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的代码后，你将能够像*图2.9*中所示的那样过滤列表：
- en: '![Figure 2.9: You should now be able to filter the list using a Vue method'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图2.9：你现在应该能够使用Vue方法过滤列表'
- en: '](img/B15218_02_09.jpg)'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_02_09.jpg)'
- en: 'Figure 2.9: You should now be able to filter the list using a Vue method'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.9：你现在应该能够使用Vue方法过滤列表
- en: 'Let''s make a filter using computed props. Include a new data prop called `input2`
    and create a `computed` prop called `computedList` that returns the same filter
    as the `searchMethod` but does not need to bind to another data prop:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用计算属性来创建一个过滤器。包括一个新的数据属性`input2`，并创建一个名为`computedList`的计算属性，它返回与`searchMethod`相同的过滤器，但不需要绑定到另一个数据属性：
- en: '[PRE38]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You should now be able to filter the second column of frameworks with the help
    of computed props, as shown in the following screenshot:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在你可以借助计算属性过滤框架的第二列，如下面的截图所示：
- en: '![Figure 2.10: Filtering the second column of frameworks using computed props'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图2.10：使用计算属性过滤框架的第二列'
- en: '](img/B15218_02_10.jpg)'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_02_10.jpg)'
- en: 'Figure 2.10: Filtering the second column of frameworks using computed props'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.10：使用计算属性过滤框架的第二列
- en: 'Finally, let''s filter the same list using a watcher. Include an `input3` prop
    with an empty string and `watchFilterList` prop with an empty array. Also create
    a third column `div`, which contains an input bound to the `input3` `v-model`,
    and a list outputting the `watchFilterList` array:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们使用一个观察者来过滤相同的列表。包含一个带有空字符串的`input3`属性和一个带有空数组的`watchFilterList`属性。同时创建一个第三列`div`，其中包含一个绑定到`input3`的`v-model`的输入框，以及输出`watchFilterList`数组的列表：
- en: '[PRE39]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create a watcher that watches the `input3` prop for changes and binds the result
    of the `frameworkList` filter to the `watchFilterList` array. Set the immediate
    key of `input3` to `true` so it will run when the component is created:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个观察者，它监视`input3`属性的变化，并将`frameworkList`过滤的结果绑定到`watchFilterList`数组。将`input3`的立即键设置为`true`，以便它在组件创建时运行：
- en: '[PRE40]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'With the help of a watcher, you should now be able to filter the third column,
    as shown in the following screenshot:'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在观察者的帮助下，你现在应该能够过滤第三列，如下面的截图所示：
- en: '![Figure 2.11: Filtering the list using a watcher in the third column'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图2.11：在第三列使用观察者过滤列表'
- en: '](img/B15218_02_11.jpg)'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_02_11.jpg)'
- en: 'Figure 2.11: Filtering the list using a watcher in the third column'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11：在第三列使用观察者过滤列表
- en: In this exercise, we have seen how we can achieve a filtered list using a method,
    computed props, and a watcher. Each has their own pros, cons, and use cases depending
    on what you are trying to achieve in your application.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何使用方法、计算属性和观察者来实现过滤列表。每个都有自己的优点、缺点和使用场景，具体取决于你想要在应用程序中实现什么。
- en: Async Methods and Data Fetching
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步方法和数据获取
- en: Asynchronous functions in JavaScript are defined by the async function syntax
    and return an `AsyncFunction` object. These functions operate asynchronously via
    the event loop, using an implicit promise, which is an object that may return
    a result in the future. Vue.js uses this JavaScript behavior to allow you to declare
    asynchronous blocks of code inside methods by including the `async` keyword in
    front of a method. You can then chain `then()` and `catch()` functions or try
    the `{}` syntax inside these Vue methods and return the results.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的异步函数是通过 `async` 函数语法定义的，并返回一个 `AsyncFunction` 对象。这些函数通过事件循环异步操作，使用隐式的
    promise（一个可能在未来返回结果的对象）。Vue.js 使用这种行为允许你在方法中包含 `async` 关键字来声明异步代码块。然后，你可以链式调用
    `then()` 和 `catch()` 函数，或者在 Vue 方法中使用 `{}` 语法并返回结果。
- en: '`Axios` is a popular JavaScript library that allows you to make external requests
    for data using Node.js. It has wide browser support making it a versatile library
    when doing `HTTP` or API requests. We will be using this library in the next exercise.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`Axios` 是一个流行的 JavaScript 库，允许你使用 Node.js 进行外部数据请求。它具有广泛的浏览器支持，使其在执行 `HTTP`
    或 API 请求时成为一个多才多艺的库。我们将在下一个练习中使用这个库。'
- en: 'Exercise 2.06: Using Asynchronous Methods to Retrieve Data from an API'
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.06：使用异步方法从 API 获取数据
- en: In this exercise, you will asynchronously fetch data from an external API source
    and display it in the frontend using computed props.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将异步从外部 API 源获取数据，并使用计算属性在前端显示它。
- en: To access the code files for this exercise, refer to [https://packt.live/353md9h](https://packt.live/353md9h).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅 [https://packt.live/353md9h](https://packt.live/353md9h)。
- en: 'Open a command-line terminal, navigate to the `Exercise 2.06` folder, and run
    the following commands to install `axios`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行终端，导航到 `Exercise 2.06` 文件夹，并运行以下命令来安装 `axios`：
- en: '[PRE41]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Go to `https://localhost:8080`.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 访问 `https://localhost:8080`。
- en: 'Let''s start by importing `axios` into our component and creating a method
    called `getApi()`. Use `axios` to call a response from [https://api.adviceslip.com/advice](https://api.adviceslip.com/advice)
    and `console.log` the result. Include a button that has a `click` event bound
    to the `getApi()` call:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从将 `axios` 导入我们的组件并创建一个名为 `getApi()` 的方法开始。使用 `axios` 调用 [https://api.adviceslip.com/advice](https://api.adviceslip.com/advice)
    的响应，并使用 `console.log` 输出结果。包括一个按钮，将其 `click` 事件绑定到 `getApi()` 调用：
- en: '[PRE42]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output of the preceding code will be as follows:'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码的输出将如下所示：
- en: '![Figure 2.12: Screen displaying a very large object in the console'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.12：显示控制台中一个非常大的对象的屏幕'
- en: '](img/B15218_02_12.jpg)'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_02_12.jpg)'
- en: 'Figure 2.12: Screen displaying a very large object in the console'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.12：显示控制台中一个非常大的对象的屏幕
- en: 'We are only interested in the data object inside the `response` object. Assign
    this data object to a Vue data prop called `response` that we can reuse:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只对 `response` 对象内部的数据对象感兴趣。将此数据对象分配给一个名为 `response` 的 Vue 数据属性，我们可以重用它：
- en: '[PRE43]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Output the `quote` from inside the `response` prop object using a computed
    prop that will update every time the `response` prop changes. Use a ternary operator
    to perform a conditional statement to check whether the `response` prop contains
    the `slip` object to avoid errors:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用计算属性输出 `response` 属性对象内部的 `quote`，该计算属性将在 `response` 属性更改时更新。使用三元运算符执行条件语句以检查
    `response` 属性是否包含 `slip` 对象，以避免错误：
- en: '[PRE44]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Figure 2.13* displays the output generated by the preceding code:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 2.13* 显示了上述代码生成的输出：'
- en: '![Figure 2.13: Screen displaying the quote output in your template'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.13：显示模板中引用输出的屏幕'
- en: '](img/B15218_02_13.jpg)'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_02_13.jpg)'
- en: 'Figure 2.13: Screen displaying the quote output in your template'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.13：显示模板中引用输出的屏幕
- en: 'As a final touch, include a `loading` data prop so the user can see when the
    UI is loading. Set `loading` to `false` by default. Inside the `getApi` method,
    set `loading` to `true`, and in the `then()` chain, set it back to `false` after
    4 seconds using the `setTimeout` function. You can use a ternary operator to change
    the button text between the loading state and its default state:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后的润色，包括一个 `loading` 数据属性，以便用户可以看到 UI 是否正在加载。默认将 `loading` 设置为 `false`。在 `getApi`
    方法中，将 `loading` 设置为 `true`，然后在 `then()` 链中使用 `setTimeout` 函数在 4 秒后将它设置回 `false`。你可以使用三元运算符在加载状态和默认状态之间切换按钮文本：
- en: '[PRE45]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output of the preceding code will be as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出将如下所示：
- en: '![Figure 2.14: Screen displaying the loading button state output in your template'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.14：显示模板中加载按钮状态输出的屏幕'
- en: '](img/B15218_02_14.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_02_14.jpg)'
- en: 'Figure 2.14: Screen displaying the loading button state output in your template'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14：在模板中显示加载按钮状态输出的屏幕
- en: In this exercise, we saw how we can fetch data from an external source, assign
    it to a computed prop, display it in our template, and apply a loading state to
    our content.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何从外部源获取数据，将其分配给计算属性，在我们的模板中显示它，并给我们的内容应用加载状态。
- en: 'Activity 2.01: Creating a Blog List Using the Contentful API'
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动二.01：使用Contentful API创建博客列表
- en: In this activity, we will build a blog that lists articles from an API source.
    This will test your knowledge of Vue by using all the basic functions of a `async`
    methods to fetch remote data from an API and use computed properties to organize
    deep nested object structures.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将构建一个博客，列出来自API源的文章。这将通过使用所有基本的`async`方法从API获取远程数据以及使用计算属性来组织深层嵌套的对象结构来测试您对Vue的了解。
- en: '`Contentful` is a headless **content management system** (**CMS**) that allows
    you to manage content separately to your code repository. You can consume this
    content using the API inside as many code repositories as you need. For example,
    you may have a blog website that acts as a primary source of information, but
    your clients want a standalone page on a different domain that only pulls in the
    most recent featured articles. Using a headless CMS inherently allows you to develop
    these two separate code bases and use the same updated data source.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`Contentful`是一个无头**内容管理系统**（**CMS**），允许您将内容与代码存储库分开管理。您可以使用API在所需的任何代码存储库中消费此内容。例如，您可能有一个作为信息主要来源的博客网站，但您的客户想要一个独立页面的不同域名，该页面只拉取最新的特色文章。使用无头CMS本质上允许您开发这两个独立的代码库，并使用相同的数据源。'
- en: This activity will be using the headless CMS `Contentful`. The access keys and
    endpoints will be listed in the solution.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动将使用无头CMS `Contentful`。访问密钥和端点将在解决方案中列出。
- en: 'The following steps will help you complete the activity:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成活动：
- en: Use the Vue CLI to create a new project that uses `babel` presets.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Vue CLI创建一个使用`babel`预设的新项目。
- en: Install the `contentful` dependency into your project.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`contentful`依赖项安装到您的项目中。
- en: Use computed properties to output the deeply nested data from the API response.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用计算属性从API响应中输出深层嵌套的数据。
- en: Use `data` props to output the user's `name`, `job title`, and `description`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`data`属性输出用户的`name`、`职位名称`和`描述`。
- en: Use `SCSS` to style the page.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`SCSS`来设置页面样式。
- en: 'The expected outcome is as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 预期结果是以下内容：
- en: '![Figure 2.15: Expected outcome with Contentful blog posts'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.15：使用Contentful博客文章的预期结果'
- en: '](img/B15218_02_15.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15218_02_15.jpg](img/B15218_02_15.jpg)'
- en: 'Figure 2.15: Expected outcome with Contentful blog posts'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15：使用Contentful博客文章的预期结果
- en: Note
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor383).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以通过[此链接](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor383)找到。
- en: After the activity has been completed, you should be able to use `async` methods
    to pull remote data from an API source into your Vue components. You will find
    that computed props are a sophisticated way of breaking down the information into
    smaller chunks of reusable data.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 活动完成后，您应该能够使用`async`方法从API源将远程数据拉入您的Vue组件。您会发现计算属性是一种将信息分解成更小的可重用数据块的高级方式。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you were introduced to Vue.js computed and watch properties,
    which allow you to observe and control reactive data. You also saw how to use
    methods to asynchronously fetch data from an API using the `axios` library and
    how to flatten the data to be more usable within the Vue template using computed
    props. The differences between using methods and computed and watch properties
    were demonstrated by building search functionality using each method.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您被介绍了Vue.js的计算和观察属性，这些属性允许您观察和控制响应式数据。您还看到了如何使用`axios`库异步从API获取数据，以及如何使用计算属性将数据扁平化，以便在Vue模板中使用。通过构建使用每种方法的搜索功能，演示了使用方法和计算以及观察属性之间的区别。
- en: The next chapter will cover the Vue CLI and show you how to manage and debug
    your Vue.js applications that use these computed properties and events.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍Vue CLI，并展示如何管理并调试使用这些计算属性和事件的Vue.js应用程序。
