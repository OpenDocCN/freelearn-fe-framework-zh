- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Introducing React Anti-Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 React 反模式
- en: This book dives deep into the realm of React anti-patterns. An anti-pattern
    is not necessarily a technical error – the code often functions properly at first
    – but although it may initially seem correct, as the code base expands, these
    anti-patterns can become problematic.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书深入探讨了 React 反模式。反模式不一定是技术错误——代码最初通常可以正常工作——但尽管它可能最初看起来是正确的，随着代码库的扩展，这些反模式可能会变得有问题。
- en: As we navigate through the book, we’ll scrutinize code samples that might not
    embody best practices; some could be intricate to decipher, and others, tough
    to modify or extend. While certain pieces of code may suffice for smaller tasks,
    they falter when scaled up. Moreover, we’ll venture into time-tested patterns
    and principles from the expansive software world, seamlessly weaving them into
    our frontend discourse.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们浏览本书的过程中，我们将审查可能不符合最佳实践的代码示例；一些可能难以理解，而另一些则难以修改或扩展。虽然某些代码片段可能适用于较小的任务，但当规模扩大时，它们会失败。此外，我们将探索来自广阔软件世界的经过时间考验的模式和原则，并将它们无缝地编织到我们的前端讨论中。
- en: I aim for practicality. The code illustrations originate either from past projects
    or commonplace domains such as a shopping cart and a user profile component, minimizing
    your need to decipher domain jargon. For a holistic view, the concluding chapters
    showcase detailed, end-to-end examples, furnishing a more organized and immersive
    experience.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我的目标是实用性。代码示例要么来自过去的项目，要么来自常见的领域，如购物车和用户资料组件，以减少你需要解码领域术语的需求。为了获得全面的视角，最后一章展示了详细的全过程示例，提供了一个更有组织和沉浸式的体验。
- en: Specifically, in this introductory chapter, we’ll address the intricacies of
    constructing advanced React applications, highlighting how state management and
    asynchronous operations can obfuscate code clarity. We’ll enumerate prevalent
    anti-patterns and offer a glimpse into the remedial strategies detailed later
    in the book.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在本章介绍中，我们将讨论构建高级 React 应用程序的复杂性，强调状态管理和异步操作如何模糊代码的清晰度。我们将列举常见的反模式，并简要介绍书中稍后详细介绍的补救策略。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the difficulty of building UIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解构建 UI 的难度
- en: Understanding the state management
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解状态管理
- en: Exploring “unhappy paths”
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索“不愉快路径”
- en: Exploring common anti-patterns in React
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 React 中的常见反模式
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: A GitHub repository has been created to host all the code we discuss in the
    book. For this chapter, you can find the code at [https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch1](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch1).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 已创建一个 GitHub 仓库来托管本书中讨论的所有代码。对于本章，你可以在 [https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch1](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch1)
    找到代码。
- en: Understanding the difficulty of building UIs
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解构建 UI 的难度
- en: 'Unless you’re building a straightforward, document-like web page — for example,
    a basic article without advanced UI elements such as search boxes or modals —
    the built-in languages offered by web browsers are generally insufficient. *Figure
    1**.1* shows an example of a website using **HTML** (**HyperText** **Markup Language**):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你正在构建一个简单的、文档式的网页——例如，一个没有高级 UI 元素（如搜索框或模态框）的基本文章——否则，网络浏览器提供的内置语言通常是不够的。*图
    1.1* 展示了一个使用 **HTML**（**超文本标记语言**）的网站示例：
- en: '![Figure 1.1: A simple HTML document website](img/B21103_01_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1：一个简单的 HTML 文档网站](img/B21103_01_01.jpg)'
- en: 'Figure 1.1: A simple HTML document website'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：一个简单的 HTML 文档网站
- en: However nowadays, most applications are more complicated and contain more elements
    than what this language was originally designed for.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如今，大多数应用程序都比这个语言最初设计时更复杂，包含的元素也更多。
- en: The disparity between the language of the web and the UI experiences that people
    encounter daily is substantial. Whether it’s a ticket booking platform, a project
    management tool, or an image gallery, modern web UIs are intricate and native
    web languages don’t readily support them. You can go the extra mile to “simulate”
    UI components such as accordions, toggle switches, or interactive cards, but fundamentally,
    you’re still working with what amounts to a document, not a genuine UI component.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 网页语言与人们日常遇到的UI体验之间的差异是巨大的。无论是票务预订平台、项目管理工具还是图片库，现代的Web UI非常复杂，而原生的Web语言并不容易支持它们。你可以走得更远来“模拟”UI组件，如手风琴、切换开关或交互式卡片，但本质上，你仍在处理相当于文档的东西，而不是真正的UI组件。
- en: In an ideal world, building a UI would resemble working with a visual UI designer.
    Tools such as C++ Builder or Delphi, or more modern alternatives such as Figma,
    let you drag and drop components onto a canvas that then renders seamlessly on
    any screen. This isn’t the case with web development. For instance, to create
    a custom search input, you’ll need to wrap it in additional elements, fine-tune
    colors, adjust padding and fonts, and perhaps add an icon for user guidance. Creating
    an auto-suggestion list that appears right under the search box, matching its
    width exactly, is often far more labor-intensive than one might initially think.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个理想的世界里，构建用户界面将类似于与视觉UI设计师合作。像C++ Builder或Delphi这样的工具，或者更现代的替代品如Figma，允许你将组件拖放到画布上，然后在任何屏幕上无缝渲染。但在网页开发中并非如此。例如，要创建一个自定义的搜索输入框，你需要将其包裹在额外的元素中，微调颜色，调整填充和字体，可能还需要添加一个图标以供用户指导。创建一个正好位于搜索框下方、宽度与其完全匹配的自动建议列表，通常比人们最初想象的要费时得多。
- en: 'As shown in *Figure 1**.2*, a web page can be super complicated and look nothing
    like a document on the surface, although the building blocks of the page are still
    pure HTML:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如**图1.2**所示，一个网页可能非常复杂，表面上看起来根本不像一份文档，尽管页面的构建块仍然是纯HTML：
- en: '![Figure 1.2: Jira issue view](img/B21103_01_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2：Jira问题视图](img/B21103_01_02.jpg)'
- en: 'Figure 1.2: Jira issue view'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：Jira问题视图
- en: This screenshot shows the issue view of Jira, a popular web-based project management
    tool used to track, prioritize, and coordinate tasks and projects. An issue view
    contains many details such as the issue’s title, description, attachments, comments,
    and linked issues. It also contains many elements a user can interact with, such
    as an **Assign to me** button, the ability to change the priority of the issue,
    add a comment, and so on.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这张截图显示了Jira的问题视图，Jira是一款流行的基于网络的项目管理工具，用于跟踪、优先排序和协调任务和项目。问题视图包含许多细节，例如问题的标题、描述、附件、评论和链接的问题。它还包含许多用户可以与之交互的元素，例如**分配给我**按钮、更改问题优先级的能力、添加评论等。
- en: For such a UI, you might expect there to be a navigator component, a drop-down
    list, an accordion, and so on. And seemingly, they are there, as labeled in *Figure
    1**.2*. But they are not actually components. Instead, developers have worked
    hard to *simulate* these with HTML, CSS, and JavaScript.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样的UI，你可能会期望有一个导航组件、一个下拉列表、一个手风琴等。表面上看起来，它们确实存在，如**图1.2**所示。但实际上，它们并不是组件。相反，开发者们努力使用HTML、CSS和JavaScript来**模拟**这些组件。
- en: Now that we’ve glanced over the language mismatch issue in web UI development,
    it might be helpful to delve into what’s under the surface – the different states
    we need to manage in frontend applications. This will provide a taste of the challenges
    that lie ahead and shed light on why introducing patterns is a key step toward
    addressing them.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经浏览了Web UI开发中语言不匹配的问题，那么深入探讨表面之下的问题可能是有帮助的——前端应用程序中我们需要管理的不同状态。这将为我们提供即将到来的挑战的预览，并阐明为什么引入模式是解决这些问题的关键步骤。
- en: Understanding the state management
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解状态管理
- en: Managing the state in modern frontend development is a complex task. Nearly
    every application has to retrieve data from a remote server via a network – we
    can call this data **remote states**. Remote state originates from an external
    source, typically a backend server or API. This is in contrast to local state,
    which is generated and managed entirely within the frontend application itself.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代前端开发中管理状态是一项复杂的任务。几乎每个应用程序都必须通过网络从远程服务器检索数据——我们可以称这些数据为**远程状态**。远程状态源自外部来源，通常是后端服务器或API。这与本地状态形成对比，本地状态是在前端应用程序内部生成和管理的。
- en: 'There are many dark sides of remote states, making the frontend development
    difficult if you don’t pay close attention to them. Here, I’ll just list a few
    obvious considerations:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 远程状态有许多阴暗面，如果你不密切关注它们，将会使前端开发变得困难。在这里，我将仅列出一些明显的考虑因素：
- en: '*Asynchronous nature*: Fetching data from a remote source is usually an asynchronous
    operation. This adds complexity in terms of timing, especially when you have to
    synchronize multiple pieces of remote data.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*异步性*：从远程源获取数据通常是一个异步操作。这增加了在时间上的复杂性，尤其是在你需要同步多个远程数据时。'
- en: '*Error handling*: Connections to remote sources might fail or the server might
    return errors. Properly managing these scenarios for a smooth user experience
    can be challenging.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*错误处理*：连接到远程源可能会失败，或者服务器可能会返回错误。为了提供流畅的用户体验，正确管理这些场景可能具有挑战性。'
- en: '*Loading states*: While waiting for data to arrive from a remote source, the
    application needs to handle “loading” states effectively. This usually involves
    showing loading indicators or fallback UIs (when the requesting component isn’t
    available, we use a default one temporarily).'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加载状态*：在等待从远程源到达数据时，应用程序需要有效地处理“加载”状态。这通常涉及显示加载指示器或回退UI（当请求组件不可用时，我们暂时使用默认的一个）。'
- en: '*Consistency*: Keeping the frontend state in sync with the backend can be difficult,
    especially in real-time applications or those that involve multiple users altering
    the same piece of data.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一致性*：保持前端状态与后端同步可能很困难，尤其是在实时应用或涉及多个用户更改同一数据的应用中。'
- en: '*Caching*: Storing some remote state locally can improve performance but bring
    its own challenges, such as invalidation and staleness. In other words, if the
    remote data is altered by others, we need a mechanism to receive updates or perform
    a refetch to update our local state, which introduces a lot of complexity.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*缓存*：将一些远程状态存储在本地可以提高性能，但也会带来自己的挑战，例如失效和过时。换句话说，如果远程数据被他人更改，我们需要一种机制来接收更新或重新获取数据以更新我们的本地状态，这引入了大量的复杂性。'
- en: '*Updates and optimistic UI*: When a user makes a change, you can update the
    UI optimistically assuming the server call will succeed. But if it doesn’t, you’ll
    need a way to roll back those changes in your frontend state.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更新和乐观UI*：当用户进行更改时，你可以乐观地更新UI，假设服务器调用将成功。但如果它失败了，你需要一种方法来回滚前端状态中的这些更改。'
- en: And those are only some of the challenges of remote states.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是远程状态的一些挑战。
- en: When the data is stored and accessible immediately in the frontend, you basically
    think in a linear way. This means you access and manipulate data in a straightforward
    sequence, one operation following another, leading to a clear and direct flow
    of logic. This way of thinking aligns well with the synchronous nature of the
    code, making the development process intuitive and easier to follow.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据在前端立即存储和可访问时，你基本上会以线性方式思考。这意味着你以直接顺序访问和操作数据，一个操作紧随另一个操作，导致逻辑流程清晰且直接。这种思维方式与代码的同步性质相吻合，使得开发过程直观且易于遵循。
- en: Let’s compare how much more code we’ll need for rendering static data with remote
    data. Think about a famous quotes application that displays a list of quotes on
    the page.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较一下渲染静态数据和远程数据所需的代码量。考虑一个在页面上显示引用列表的著名引用应用。
- en: 'To render the passed-in quotes list, you can map the data into JSX elements,
    like so:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染传入的引用列表，你可以将数据映射到JSX元素中，如下所示：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We’re using `index` as the key here, which is fine for static quotes. However,
    it’s generally best to avoid this practice. Using indices can lead to rendering
    issues in dynamic lists in real-world scenarios.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`index`作为键，这对于静态引用来说是可行的。然而，通常最好避免这种做法。在实际场景中的动态列表中，使用索引可能导致渲染问题。
- en: 'If the quotes are from a remote server, the code will turn into something like
    the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果引用来自远程服务器，代码将变成如下所示：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this React component, we use `useState` to create a quotes state variable,
    initially set as an empty array. The `useEffect` Hook fetches quotes from a remote
    server when the component mounts. It then updates the quotes state with the fetched
    data. Finally, the component renders a list of quotes, iterating through the `quotes`
    array.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个React组件中，我们使用`useState`创建一个引用状态变量，初始设置为空数组。`useEffect` Hook在组件挂载时从远程服务器获取引用。然后，它使用获取的数据更新引用状态。最后，组件渲染一个引用列表，遍历`quotes`数组。
- en: Don’t worry, there’s no need to sweat about the details for now; we’ll delve
    into them in the next chapter on React essentials.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心，现在没有必要担心细节；我们将在下一章关于React必备知识的章节中深入探讨。
- en: The previous code example shows the ideal scenario, but in reality, asynchronous
    calls come with their own challenges. We have to think about what to display while
    data is being fetched and how to handle various error scenarios, such as network
    issues or resource unavailability. These added complexities can make the code
    lengthier and more difficult to grasp.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码示例显示了理想场景，但在现实中，异步调用有其自身的挑战。我们必须考虑在数据获取时显示什么，以及如何处理各种错误场景，例如网络问题或资源不可用。这些额外的复杂性可能会使代码更长且更难以理解。
- en: 'For instance, while fetching data, we temporarily transition into a loading
    state, and should anything go awry, we shift to an error state:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在获取数据时，我们会临时过渡到加载状态，如果出现任何问题，我们会切换到错误状态：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The code uses `useState` to manage three pieces of state: `quotes` for storing
    the quotes, `isLoading` for tracking the loading status, and `error` for any fetch
    errors.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用 `useState` 管理三件状态：`quotes` 用于存储引用，`isLoading` 用于跟踪加载状态，`error` 用于任何获取错误。
- en: The `useEffect` Hook triggers the fetch operation. If the fetch is successful,
    the quotes are displayed and `isLoading` is set to `false`. If an error occurs,
    an error message is displayed and `isLoading` is again set to `false`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect` 钩子触发了获取操作。如果获取成功，则显示引用并设置 `isLoading` 为 `false`。如果发生错误，则显示错误消息并将
    `isLoading` 再次设置为 `false`。'
- en: As you can observe, the portion of the component dedicated to actual rendering
    is quite small (i.e., the JSX code inside `return`). In contrast, managing the
    state consumes nearly two-thirds of the function’s body.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，组件中实际渲染的部分相当小（即 `return` 中的JSX代码）。相比之下，管理状态几乎消耗了函数体的大部分。
- en: 'But that’s just one aspect of the state management. There’s also the matter
    of managing local state, which means the state only needs to be maintained inside
    a component. For example, as demonstrated in *Figure 1**.3*, an accordion component
    needs to track whether it’s expanded or collapsed – when you click the triangle
    on the header, it toggles the list panel:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但这只是状态管理的一个方面。还有管理本地状态的问题，这意味着状态只需要在组件内部维护。例如，如图*图1**.3*所示，手风琴组件需要跟踪它是展开还是折叠的——当你点击标题上的三角形时，它会切换列表面板：
- en: '![Figure 1.3: An expandable section](img/B21103_01_03.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3：可展开的部分](img/B21103_01_03.jpg)'
- en: 'Figure 1.3: An expandable section'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：可展开的部分
- en: Using a third-party state management library such as Redux or MobX can be beneficial
    when your application reaches a level of complexity that makes state tracking
    difficult. However, using a third-party state management library isn’t without
    its caveats (learning curve, best practices in a particular library, migration
    efforts, etc.) and should be considered carefully. That’s why many developers
    are leaning toward using React’s built-in Context API for state management.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用达到一个使状态跟踪变得困难的高度复杂度时，使用像Redux或MobX这样的第三方状态管理库可能会有所帮助。然而，使用第三方状态管理库并非没有其缺点（学习曲线、特定库的最佳实践、迁移努力等），因此应仔细考虑。这就是为什么许多开发者倾向于使用React内置的Context
    API进行状态管理。
- en: Another significant complexity in modern frontend applications that often goes
    unnoticed by many developers, yet is akin to an iceberg that warrants closer attention,
    is “unhappy paths.” Let’s look at these next.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现代前端应用中另一个显著的复杂性，许多开发者往往没有注意到，但它就像一座需要更密切关注的冰山，这就是“不愉快的路径”。让我们接下来看看这些内容。
- en: Exploring “unhappy paths”
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索“不愉快的路径”
- en: When it comes to UI development, our primary focus is often on the “happy path”
    – the optimal user journey where everything goes as planned. However, neglecting
    the “unhappy paths” can make your UI far more complicated than you might initially
    think. Here are some scenarios that could lead to unhappy paths and consequently
    complicate your UI development efforts.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到UI开发时，我们通常主要关注“愉快的路径”——一切按计划进行的最佳用户体验。然而，忽视“不愉快的路径”可能会使你的UI比最初想象的要复杂得多。以下是一些可能导致不愉快路径并进而复杂化你的UI开发工作的场景。
- en: Errors thrown from other components
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来自其他组件抛出的错误
- en: Imagine that you’re using a third-party component or even another team’s component
    within your application. If that component throws an error, it could potentially
    break your UI or lead to unexpected behaviors that you have to account for. This
    can involve adding conditional logic or error boundaries to handle these errors
    gracefully, making your UI more complex than initially anticipated.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在使用第三方组件，甚至在你的应用程序中使用另一个团队的组件。如果该组件抛出错误，它可能会破坏你的UI或导致你必须考虑的意外行为。这可能涉及添加条件逻辑或错误边界来优雅地处理这些错误，从而使你的UI比最初预期的更复杂。
- en: 'For example, in a `MenuItem` component that renders an item’s data, let’s see
    what happens when we try accessing something that doesn’t exist in the passed-in
    prop `item` (in this case, we’re looking for the aptly named `item.something.doesnt.exist`):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个渲染项目数据的`MenuItem`组件中，让我们看看当我们尝试访问传入的属性`item`中不存在的东西时会发生什么（在这种情况下，我们正在寻找名为`item.something.doesnt.exist`的属性）：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `MenuItem` component receives an `item` object and an `onItemClick` function
    as props. It displays the item’s name and description, as well as including an
    `onItemClick` function is called with the item as an argument.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`MenuItem`组件接收一个`item`对象和一个`onItemClick`函数作为属性。它显示项目的名称和描述，以及包含一个`onItemClick`函数被调用，并使用项目作为参数。'
- en: 'This code attempts to access a non-existing property, `item.something.doesnt.exist`,
    which will cause a runtime error. As demonstrated in *Figure 1**.4*, the application
    stopped working after the backend service returned some unexpected data:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码尝试访问一个不存在的属性，`item.something.doesnt.exist`，这将导致运行时错误。正如*图1.4*所示，在后台服务返回一些意外数据后，应用程序停止工作：
- en: '![Figure 1.4: A component-thrown exception during render](img/B21103_01_04.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4：渲染期间组件抛出的异常](img/B21103_01_04.jpg)'
- en: 'Figure 1.4: A component-thrown exception during render'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：渲染期间组件抛出的异常
- en: This can cause the whole application to crash if we don’t isolate the error
    into an **error boundary**, as we can see in *Figure 1**.4* – the menus are not
    displayed, but the category and page titles remain functional; the area affected,
    which I’ve outlined with a red dotted line, is where the menus were supposed to
    appear. Error boundaries in React are a feature that allows you to catch JavaScript
    errors that occur in child components, log those errors, and display a fallback
    UI instead of letting the whole app crash. Error boundaries catch errors during
    rendering, in life cycle methods, and in constructors of the whole tree below
    them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不将错误隔离到一个**错误边界**中，这可能会导致整个应用程序崩溃，正如我们在*图1.4*中看到的那样。4* – 菜单没有显示，但类别和页面标题仍然可用；受影响的区域，我用红色虚线标出，是菜单原本应该出现的地方。React中的错误边界是一个特性，允许你捕获子组件中发生的JavaScript错误，记录这些错误，并显示一个回退UI，而不是让整个应用程序崩溃。错误边界在渲染期间、生命周期方法和它们下面的整个树的构造函数中捕获错误。
- en: In real-world projects, your UI might depend on various microservices or APIs
    for fetching data. If any of these downstream systems are down, your UI has to
    account for it. You’ll need to design fallbacks, loading indicators, or friendly
    error messages that guide the user on what to do next. Handling these scenarios
    effectively often involves both frontend and backend logic, thus adding another
    layer of complexity to your UI development tasks.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的项目中，你的UI可能依赖于各种微服务或API来获取数据。如果这些下游系统中的任何一个出现故障，你的UI必须对此做出反应。你需要设计回退方案、加载指示器或友好的错误消息，以指导用户下一步该做什么。有效地处理这些场景通常需要前端和后端逻辑，从而为你的UI开发任务增加另一层复杂性。
- en: Learning the unexpected user behavior
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习意外的用户行为
- en: No matter how perfectly you design your UI, users will always find ways to use
    your system in manners you didn’t anticipate. Whether they input special characters
    in text fields, try to submit forms too quickly, or use browser extensions that
    interfere with your site, you have to design your UI to handle these edge cases.
    This means implementing additional validation, checks, and safeguards that can
    complicate your UI code base.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你如何完美地设计你的UI，用户总会找到使用你的系统的方式，这是你没有预料到的。无论是他们在文本字段中输入特殊字符，尝试快速提交表单，还是使用干扰你网站的浏览器扩展，你必须设计你的UI来处理这些边缘情况。这意味着实现额外的验证、检查和安全措施，这些可能会使你的UI代码库变得复杂。
- en: 'Let’s examine a basic `Form` component to understand the considerations for
    user input. While this single-field form might require additional logic in the
    `handleChange` method, it’s important to note that most forms typically consist
    of several fields (which means there will be more unexpected user behavior we
    need to consider):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察一个基本的`Form`组件，以了解用户输入的考虑因素。虽然这个单字段表单可能需要在`handleChange`方法中添加额外的逻辑，但重要的是要注意，大多数表单通常由多个字段组成（这意味着我们需要考虑更多的意外用户行为）：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This `Form` component consists of a single text input field that restricts input
    to alphanumeric characters and spaces. It uses a `value` state variable to store
    the input field’s value. The `handleChange` function, triggered on each input
    change, removes any non-alphanumeric characters from the user’s input before updating
    the state with the sanitized value.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Form`组件由一个单行文本输入字段组成，该字段限制输入为字母数字字符和空格。它使用一个`value`状态变量来存储输入字段的值。`handleChange`函数在每次输入更改时触发，在更新状态为清洗后的值之前，从用户的输入中删除任何非字母数字字符。
- en: Understanding and effectively managing these unhappy paths are critical to creating
    a robust, resilient, and user-friendly interface. Not only do they make your application
    more reliable, but they also contribute to a more comprehensive and well-thought-out
    user experience.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 理解并有效地管理这些不愉快的路径对于创建一个强大、有弹性和用户友好的界面至关重要。这不仅使你的应用程序更加可靠，而且也有助于创造一个更全面和深思熟虑的用户体验。
- en: I believe you should now have a clearer insight into the challenges of building
    modern frontend applications in React. Tackling these hurdles isn’t straightforward,
    particularly since React doesn’t offer a definitive guide on which approach to
    adopt, how to structure your code base, manage states, or ensure code readability
    (and by extension, ease of maintenance in the long run), or how established patterns
    can be of aid, among other concerns. This lack of guidance often leads developers
    to create solutions that might work in the short term but could be riddled with
    anti-patterns.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为你现在应该对在React中构建现代前端应用程序的挑战有了更清晰的洞察。解决这些障碍并不简单，尤其是React没有提供明确的指南，说明应该采用哪种方法，如何构建你的代码库，管理状态，或者确保代码的可读性（以及由此带来的长期维护的便捷性），或者如何利用既定模式提供帮助，以及其他担忧。这种缺乏指导往往导致开发者创造出可能在短期内有效，但可能充满反模式的解决方案。
- en: Exploring common anti-patterns in React
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索React中的常见反模式
- en: Within the realm of software development, we often encounter practices and approaches
    that, at first glance, appear to offer a beneficial solution to a particular problem.
    These practices, labeled as **anti-patterns**, may provide immediate relief or
    a seemingly quick fix, but they often hide underlying issues. Over time, reliance
    on these anti-patterns can lead to greater complexities, inefficiencies, or even
    the very issues they were thought to resolve.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发领域，我们经常遇到看似为特定问题提供有益解决方案的实践和方法。这些被标记为**反模式**的实践，可能提供即时的缓解或看似快速的修复，但它们通常隐藏了潜在的问题。随着时间的推移，依赖这些反模式可能导致更大的复杂性、低效，甚至可能是它们试图解决的问题。
- en: Recognizing and understanding these anti-patterns is crucial for developers,
    as it enables them to anticipate potential pitfalls and steer clear of solutions
    that may be counterproductive in the long run. In the upcoming sections, we’ll
    highlight common anti-patterns accompanied by code examples. We’ll address each
    anti-pattern and outline potential solutions. However, we won’t delve deeply here
    since entire chapters are dedicated to discussing these topics in detail.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 认识和理解这些反模式对于开发者至关重要，因为它使他们能够预见潜在的陷阱，并避开那些可能长期产生反效果的解决方案。在接下来的章节中，我们将突出显示常见的反模式，并附上代码示例。我们将解决每个反模式，并概述可能的解决方案。然而，我们不会在这里深入探讨，因为整个章节都致力于详细讨论这些主题。
- en: Props drilling
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**扩孔钻探**'
- en: In complex React applications, managing state and ensuring that every component
    has access to the data it needs can become challenging. This is often observed
    in the form of **props drilling**, where props are passed from a parent component
    through multiple intermediary components before they reach the child component
    that actually needs them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的React应用程序中，管理状态并确保每个组件都能访问它所需的数据可能变得具有挑战性。这通常以**props钻探**的形式出现，其中props从一个父组件通过多个中间组件传递，最终到达真正需要它们的子组件。
- en: 'For instance, consider a `SearchableList`, `List`, and a `ListItem` hierarchy
    – a `SearchableList` component contains a `List` component, and `List` contains
    multiple instances of `ListItem`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个`SearchableList`、`List`和`ListItem`的层次结构——一个`SearchableList`组件包含一个`List`组件，而`List`包含多个`ListItem`实例：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this setup, the `onItemClick` prop is drilled from `SearchableList` through
    `List` and finally to `ListItem`. Though the `List` component doesn’t use this
    prop, it has to pass it down to `ListItem`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设置中，`onItemClick`属性从`SearchableList`通过`List`最终传递到`ListItem`。尽管`List`组件没有使用这个属性，但它必须将其传递给`ListItem`。
- en: This approach can lead to increased complexity and reduced maintainability.
    When multiple props are passed down through various components, understanding
    the flow of data and debugging can become difficult.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可能导致复杂性增加和可维护性降低。当多个属性通过多个组件传递时，理解数据流和调试变得困难。
- en: A potential solution to avoid props drilling in React is by leveraging the Context
    API. It provides a way to share values (data and functions) between components
    without having to explicitly pass props through every level of the component tree.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在React中传递属性钻取的一个潜在解决方案是利用上下文API。它提供了一种在不需要在组件树中的每一层显式传递属性的情况下，在组件之间共享值（数据和函数）的方法。
- en: In-component data transformation
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件内的数据转换
- en: The component-centric approach in React is all about breaking up tasks and concerns
    into manageable chunks, enhancing maintainability. One recurrent misstep, however,
    is when developers introduce complex data transformation logic directly within
    components.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: React中的组件中心方法主要是将任务和关注点分解成可管理的块，从而提高可维护性。然而，一个常见的错误是开发者直接在组件内部引入复杂的数据转换逻辑。
- en: It’s common, especially when dealing with external APIs or backends, to receive
    data in a shape or format that isn’t ideal for the frontend. Instead of adjusting
    this data at a higher level, or in a utility function, the transformation is defined
    inside the component.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是处理外部API或后端时，通常会遇到数据形状或格式不适合前端的情况。而不是在更高层次或实用函数中调整这些数据，转换是在组件内部定义的。
- en: 'Consider the following scenario:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下场景：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `UserProfile` function component retrieves and displays a user’s profile
    based on the provided prop `userId`. Once the remote `data` is fetched, it’s transformed
    within the component itself to create a structured user profile. This transformed
    data consists of the user’s full name (a combination of first and last name),
    age, and a formatted address.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserProfile`函数组件根据提供的`userId`属性检索并显示用户的个人资料。一旦远程`data`被获取，它就在组件内部进行转换，以创建一个结构化的用户资料。这个转换后的数据包括用户的全名（名和姓的组合）、年龄和格式化的地址。'
- en: 'By directly embedding the transformation, we encounter a few issues:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过直接嵌入转换，我们遇到了一些问题：
- en: '*Lack of clarity*: Combining data fetching, transformation, and rendering tasks
    within a single component makes it harder to pinpoint the component’s exact purpose'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*缺乏清晰度*：将数据获取、转换和渲染任务结合在一个组件中，使得难以准确指出组件的确切目的'
- en: '*Reduced reusability*: Should another component require the same or a similar
    transformation, we’d be duplicating logic'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*降低可复用性*：如果另一个组件需要相同或类似的转换，我们将重复逻辑'
- en: '*Testing challenges*: Testing this component now requires considering the transformation
    logic, making tests more convoluted'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试挑战*：现在测试这个组件需要考虑转换逻辑，使得测试更加复杂'
- en: To combat this anti-pattern, it’s advised to separate data transformation from
    the component. This can be achieved using utility functions or custom Hooks, thus
    ensuring a cleaner and more modular design. By externalizing these transformations,
    components remain focused on rendering and business logic stays centralized, making
    for a far more maintainable code base.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这种反模式，建议将数据转换从组件中分离出来。这可以通过使用实用函数或自定义钩子来实现，从而确保更干净和模块化的设计。通过外部化这些转换，组件保持专注于渲染，而业务逻辑保持集中，从而使得代码库更加易于维护。
- en: Complicated logic in views
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图中的复杂逻辑
- en: The beauty of modern frontend frameworks, including React, is the distinct separation
    of concerns. By design, components should be oblivious to the intricacies of business
    logic, focusing instead on presentation. However, a recurrent pitfall that developers
    encounter is the infusion of business logic within view components. This not only
    disrupts the clean separation but also bloats components and makes them harder
    to test and reuse.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现代前端框架，包括React，的美妙之处在于明确的关注点分离。按照设计，组件应该对业务逻辑的复杂性一无所知，而应专注于呈现。然而，开发者经常遇到的一个常见问题是业务逻辑在视图组件中的注入。这不仅破坏了清晰的分离，还使组件膨胀，并使它们更难测试和重用。
- en: 'Consider a simple example. Imagine a component that is meant to display a list
    of items fetched from an API. Each item has a price, but we want to display items
    above a certain threshold price:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个简单的例子。想象一个组件，其目的是显示从API获取的项目列表。每个项目都有一个价格，但我们想显示高于某个阈值价格的项目：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, the `filterExpensiveItems` function, a piece of business logic, resides
    directly within the view component. The component is now tasked with not just
    presenting data but also processing it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`filterExpensiveItems` 函数，一段业务逻辑，直接位于视图组件中。现在，组件不仅要呈现数据，还要处理数据。
- en: 'This approach can become problematic:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可能会出现问题：
- en: '*Reusability*: If another component requires a similar filter, the logic would
    need to be duplicated'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可重用性*：如果另一个组件需要类似的过滤器，逻辑就需要被复制。'
- en: '*Testing*: Unit testing becomes more complex as you’re not just testing the
    rendering, but also the business logic'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试*：随着你不仅要测试渲染，还要测试业务逻辑，单元测试会变得更加复杂。'
- en: '*Maintenance*: As the application grows and more logic is added, this component
    can become unwieldy and harder to maintain'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*维护*：随着应用程序的增长和逻辑的增加，这个组件可能会变得难以控制且难以维护。'
- en: To ensure our components remain reusable and easy to maintain, it’s wise to
    embrace the **separation of concerns** principle. This principle states that each
    module or function in software should have responsibility over a single part of
    the application’s functionality. By separating the business logic from the presentation
    layer and adopting a **layered architecture**, we can ensure each part of our
    code handles its own specific responsibility, leading to a more modular and maintainable
    code base.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的组件保持可重用性和易于维护，明智的做法是接受**关注点分离**原则。这个原则指出，软件中的每个模块或函数都应该负责应用程序功能的一个部分。通过将业务逻辑与表示层分离，并采用**分层架构**，我们可以确保代码的每一部分都处理其特定的责任，从而实现更模块化和易于维护的代码库。
- en: Lack of tests
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺乏测试
- en: Imagine building a shopping cart component for an online store. The cart is
    crucial as it handles item additions, removals, and total price calculations.
    As straightforward as it may seem, it embodies various moving parts and logic
    interconnections. Without tests, you leave the door open for future problems,
    such as incorrect pricing, items not being added or removed correctly, or even
    security vulnerabilities.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下为在线商店构建购物车组件。购物车至关重要，因为它处理项目的添加、删除和总价计算。尽管这看起来可能很简单，但它包含了各种移动部件和逻辑连接。没有测试，你为未来的问题敞开了大门，比如价格计算错误、项目添加或删除不正确，甚至安全漏洞。
- en: 'Consider this simplistic version of a shopping cart:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个购物车的简化版本：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: While this shopping cart’s logic appears straightforward, potential pitfalls
    are lurking. What if an item gets added multiple times erroneously, or prices
    change dynamically, or discounts are applied? Without tests, these scenarios might
    not be evident until a user encounters them, which could be detrimental to the
    business.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个购物车的逻辑看起来很简单，但潜在的问题正在潜伏。如果项目被错误地添加多次，或者价格动态变化，或者应用了折扣，会发生什么？如果没有测试，这些场景可能直到用户遇到它们才变得明显，这可能会对业务造成损害。
- en: Enter `ShoppingCart` component, it means having tests verifying that items are
    correctly added or removed, total calculations are adjusted appropriately, and
    edge cases, such as handling discounts, are managed. Only after these tests are
    in place should the actual component logic be implemented. TDD is more than just
    catching errors early; it champions well-structured, maintainable code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 `ShoppingCart` 组件，意味着要有测试来验证项目是否被正确添加或删除，总价计算是否适当调整，以及处理边缘情况，例如处理折扣等。只有在这些测试到位之后，才应该实现实际的组件逻辑。TDD（测试驱动开发）不仅仅是早期捕捉错误；它推崇结构良好、易于维护的代码。
- en: For the `ShoppingCart` component, adopting TDD would necessitate tests ensuring
    items get added or removed as expected, totals are correctly computed, and edge
    cases are tackled seamlessly. This way, as the application grows, the foundational
    TDD tests ensure each modification or addition maintains the application’s integrity
    and correctness.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `ShoppingCart` 组件，采用 TDD（测试驱动开发）将需要确保项目按预期添加或删除，总计正确计算，并且边缘情况能够无缝处理。这样，随着应用程序的增长，基础
    TDD 测试确保每次修改或添加都保持应用程序的完整性和正确性。
- en: Duplicated code
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重复的代码
- en: It’s a familiar sight in many code bases – chunks of identical or very similar
    code scattered across different parts of the application. Duplicated code not
    only bloats the code base but also introduces potential points of failure. When
    a bug is detected or an enhancement is needed, every instance of the duplicated
    code may need to be altered, leading to an increased likelihood of introducing
    errors.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多代码库中，这是一种常见的景象——在应用程序的不同部分散布着相同或非常相似的代码块。重复的代码不仅膨胀了代码库，还引入了潜在的故障点。当发现错误或需要增强时，可能需要修改重复代码的每个实例，从而增加了引入错误的可能性。
- en: 'Let’s consider two components in which the same filtering logic is repeated:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑两个组件，它们重复了相同的过滤逻辑：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The **DRY** (**don’t repeat yourself**) **principle** comes to the rescue here.
    By centralizing common logic into utility functions or **higher-order components**
    (**HOCs**), the code becomes more maintainable and readable, and less prone to
    errors. For this example, we could abstract the filtering logic and reuse it,
    ensuring a singular source of truth and easier updates.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**DRY**（不要重复自己）原则在这里发挥了作用。通过将常见逻辑集中到实用函数或 **HOCs**（高阶组件）中，代码变得更加易于维护和阅读，并且更不容易出错。对于这个例子，我们可以抽象过滤逻辑并重用它，确保单一的真实来源和更容易的更新。'
- en: Long component with too much responsibility
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 责任过重的长组件
- en: React encourages the creation of modular, reusable components. However, as features
    get added, a component can quickly grow in size and responsibility, turning into
    an unwieldy behemoth. A long component that manages various tasks becomes difficult
    to maintain, understand, and test.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: React 鼓励创建模块化、可重用的组件。然而，随着功能的增加，一个组件可能会迅速增大其规模和责任，变成一个难以驾驭的庞然大物。一个管理各种任务的长组件变得难以维护、理解和测试。
- en: 'Imagine an `OrderContainer` component that has a huge prop list that includes
    a lot of different aspects of the responsibilities:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个 `OrderContainer` 组件，它有一个庞大的属性列表，包括许多不同方面的责任：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Such a component violates the `OrderContainer` component and separate the supporting
    logic into other smaller, focused components or utilize Hooks for logic separation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的组件违反了 `OrderContainer` 组件，并将支持逻辑分离到其他更小、更专注的组件中，或者利用 Hooks 进行逻辑分离。
- en: Note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: These listed anti-patterns have different variations, and we’ll discuss the
    solutions correspondingly in the following chapters. Apart from that, there are
    also some more generic design principles and design patterns we’ll discuss in
    the book, as well as some proven engineering practices, such as refactoring and
    TDD.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这些列出的反模式有不同的变体，我们将在接下来的章节中相应地讨论解决方案。除此之外，书中还将讨论一些更通用的设计原则和设计模式，以及一些经过验证的工程实践，例如重构和
    TDD。
- en: Unveiling our approach to demolishing anti-patterns
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 揭示我们破坏反模式的方法
- en: When it comes to addressing prevalent anti-patterns, an arsenal of design patterns
    comes to the fore. Techniques such as **render props**, HOCs, and **Hooks** are
    instrumental in augmenting component capabilities without deviating from their
    primary roles, while leveraging foundational patterns such as layered architecture
    and separation of concerns ensures a streamlined code base, demarcating logic,
    data, and presentation in a coherent manner. Such practices don’t just elevate
    the sustainability of React apps but also lay the groundwork for effective teamwork
    among developers.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到解决普遍的反模式时，一系列设计模式会浮出水面。**渲染属性**、HOCs（高阶组件）和 **Hooks** 等技术对于增强组件功能而不偏离其核心角色至关重要，同时利用分层架构和关注点分离等基础模式确保代码库的流畅性，以连贯的方式界定逻辑、数据和展示。这些实践不仅提高了
    React 应用的可持续性，还为开发者之间的有效团队合作奠定了基础。
- en: Meanwhile, **interface-oriented programming**, at its core, zeroes in on tailoring
    software centered around the interactions occurring between software modules,
    predominantly via interfaces. Such a modus operandi fosters agility, rendering
    software modules not only more coherent but also amenable to alterations. The
    **headless components** paradigm, on the other hand, embodies components that,
    while devoid of direct rendering duties, are entrusted with the management of
    state or logic. These components pass the baton to their consuming counterparts
    for UI rendering, thus championing adaptability and reusability.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，**面向接口的编程**在本质上专注于定制以软件模块之间的交互为中心的软件，主要通过接口进行。这种做法促进了敏捷性，使软件模块不仅更加连贯，而且易于修改。另一方面，**无头组件**范式体现了这样的组件，尽管它们没有直接的渲染职责，但负责管理状态或逻辑。这些组件将接力棒传递给它们的消费者，以进行UI渲染，从而倡导适应性和可重用性。
- en: By gaining a firm grasp on these design patterns and deploying them judiciously,
    we’re positioned to circumvent prevalent missteps, thereby uplifting the stature
    of our React applications.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通过牢固掌握这些设计模式并明智地部署它们，我们能够避免常见的错误，从而提升我们React应用程序的档次。
- en: Plus, within the coding ecosystem, the twin pillars of TDD and consistent refactoring
    emerge as formidable tools to accentuate code quality. TDD, with its clarion call
    of test-before-code, furnishes an immediate feedback loop for potential discrepancies.
    Hand-in-hand with TDD, the ethos of persistent refactoring ensures that code is
    perpetually optimized and honed. Such methodologies not only set the benchmark
    for code excellence but also instill adaptability to forthcoming changes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在编码生态系统中，TDD（测试驱动开发）和持续重构这两大支柱成为提升代码质量的强大工具。TDD以其“先测试后编码”的明确号召，为潜在的不一致提供了即时反馈循环。与TDD携手并进，持续重构的伦理确保代码始终得到优化和精炼。这些方法不仅为代码卓越设定了基准，还培养了应对未来变化的适应性。
- en: As we navigate the realm of refactoring, it’s pivotal to delve into the essence
    of these techniques, discerning their intricacies and optimal application points.
    Harnessing these refactoring avenues promises to bolster your code’s clarity,
    sustainability, and overarching efficiency. This is something that we’ll be doing
    throughout the book!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们探索重构的领域，深入理解这些技术的本质，辨别它们的复杂性和最佳应用点至关重要。利用这些重构途径有望增强代码的清晰度、可持续性和整体效率。这正是本书将贯穿始终的内容！
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the challenges of UI development from its complexities
    to state management issues. We also discussed the common anti-patterns due to
    the nature of its complexity, and briefly introduced our approach that combines
    best practices and effective testing strategies. This sets the foundation for
    more efficient and robust frontend development.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了UI开发的挑战，从其复杂性到状态管理问题，我们也讨论了由于其复杂性的本质而产生的常见反模式，并简要介绍了我们的方法，该方法结合了最佳实践和有效的测试策略。这为更高效和稳健的前端开发奠定了基础。
- en: In the upcoming chapter, we’ll dive deep into React essentials, giving you the
    tools and knowledge you need to master this powerful library. Stay tuned!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨React基础知识，为您提供掌握这个强大库所需的技术和知识。敬请期待！
