<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer041">
			<h1 id="_idParaDest-114"><em class="italic"><a id="_idTextAnchor116"/>Chapter 11</em>: Migrating Your Angular Application from View Engine to Ivy</h1>
			<p>Several Angular feature releases are published every year. Updating our Angular application requires knowledge of the Angular update process, especially when migrating from Angular View Engine to Angular Ivy as there are many differences, most of which are managed by automated Angular migrations.</p>
			<p>In this chapter, you will learn about the steps required to update an Angular application, following the <em class="italic">Angular Update Guide's</em> instructions, how to manage Angular's third-party dependencies, the most useful parameters for the <strong class="source-inline">ng update</strong> command, how the most important automated Angular Ivy migrations change our applications, and how both automated and manual recommended but optional Angular Ivy migrations are applied.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Learning the Angular update process</li>
				<li>Performing automated Angular Ivy migrations</li>
				<li>Performing manual Angular Ivy migrations</li>
			</ul>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor117"/>Technical requirements</h1>
			<p>The migrations discussed in this chapter apply to applications at or higher than the following:</p>
			<ul>
				<li>Angular Ivy version 12.1</li>
				<li>TypeScript version 4.2</li>
			</ul>
			<p>Make sure you have a recent version of Angular CLI installed globally so that you can run the <strong class="source-inline">ng update</strong> command from a terminal.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor118"/>Learning the Angular update process</h1>
			<p>Angular CLI gives <a id="_idIndexMarker371"/>us a structured approach to update Angular-specific parts of our application. One type of <a id="_idIndexMarker372"/>Angular schematics<a id="_idIndexMarker373"/> is <strong class="bold">migration</strong>, which modifies our application code to comply with breaking changes. Major and minor version releases of Angular often come with migration schematics.</p>
			<p>It is recommended to follow the update process, one major version release at a time. For example, if our application is currently using Angular View Engine version 8.2, we update it to Angular Ivy version 9.1 and verify that all aspects are behaving as expected before we take the next step to update from Angular version 9.1 to version 10.2, and so on until we reach the Angular release version we have planned to update to.</p>
			<p>The fewer update steps we perform at a time, the easier it is to identify what went wrong when something did not go as planned.</p>
			<p>In this section, we will first learn about the Angular Update Guide, an official web app listing step-by-step instructions. After that, we will discuss Angular's third-party dependencies and how their releases affect our Angular application.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor119"/>The Angular Update Guide</h2>
			<p>An important tool for the<a id="_idIndexMarker374"/> Angular update process is the Angular Update Guide. Located at <a href="https://update.angular.io">https://update.angular.io</a>, this web app presents step-by-step instructions for <a id="_idIndexMarker375"/>updating our Angular application.</p>
			<p>To use the<a id="_idIndexMarker376"/> Angular Update Guide, we first choose the following:</p>
			<ul>
				<li>Which Angular version we are currently using</li>
				<li>Which Angular version we want to update to</li>
				<li>The complexity of our application</li>
				<li>Whether our application is a hybrid AngularJS and Angular application using <strong class="source-inline">ngUpgrade</strong></li>
				<li>Whether we are using Angular Material</li>
			</ul>
			<p>Even if we are in a hurry, we should select <strong class="bold">Advanced</strong> as our <strong class="bold">App complexity</strong> and go through all available instructions to make sure we do not miss any recommended migration steps.</p>
			<p>After choosing the <a id="_idIndexMarker377"/>option that matches our application, we are presented with a checklist of instructions, divided into the following sections:</p>
			<ul>
				<li><strong class="bold">Before updating</strong></li>
				<li><strong class="bold">During the update</strong></li>
				<li><strong class="bold">After the update</strong></li>
			</ul>
			<p>It is not always clear what makes a difference regarding whether an instruction is listed in the <strong class="bold">During the update</strong> or <strong class="bold">After the update</strong> sections. For a pleasant update process, we make sure to follow the instructions in the <strong class="bold">Before updating</strong> section before we follow the instructions in the <strong class="bold">During the update</strong> section.</p>
			<p>The instructions in the <strong class="bold">During the update</strong> section must be followed in the order they are listed in because update and migration commands often depend on each other.</p>
			<p>The instructions in the <strong class="bold">After the update</strong> section contain both required migrations and recommended migrations. Both manual and automated migrations are listed but not necessarily all migrations related to a release; that is, some automated migrations are applied when using the <strong class="source-inline">ng update</strong> command but are not listed in the Angular Update Guide. Similarly, some recommended automated and manual migrations are listed in the Angular documentation but not in the Angular Update Guide.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor120"/>Managing Angular dependencies</h2>
			<p>Outside of official Angular<a id="_idIndexMarker378"/> packages, Angular only has a few dependencies. The following package <a id="_idIndexMarker379"/>dependencies <a id="_idIndexMarker380"/>are <a id="_idIndexMarker381"/>listed in Angular's <strong class="source-inline">package.json</strong> files:</p>
			<ul>
				<li><strong class="bold">RxJS</strong></li>
				<li><strong class="bold">tslib</strong></li>
				<li><strong class="bold">Zone.js</strong></li>
			</ul>
			<p>Historically, the versions of these package dependencies are managed by the Angular update<a id="_idIndexMarker382"/> process. However, migrations for breaking changes are not always available. For example, RxJS has no migrations planned for updating from version 6.x to version 7.x.</p>
			<h3>Zone.js</h3>
			<p>At the <a id="_idIndexMarker383"/>time of writing, Zone.js is <a id="_idIndexMarker384"/>still in a prerelease version. Every minor prerelease version contains breaking changes. Typically, migrations are not necessary for our Angular application because we do not use Zone.js directly. Instead, the <strong class="source-inline">NgZone</strong> API wraps Zone.js.</p>
			<p>However, we import Zone.js in several of our application files, and Zone.js version 0.11.1 changes its import paths. Angular version 11 offers an automated migration to update Zone.js.</p>
			<h3>TypeScript</h3>
			<p>TypeScript <a id="_idIndexMarker385"/>does not<a id="_idIndexMarker386"/> follow semantic versioning. Every minor release version contains breaking changes. No automated migrations are available for TypeScript so if our application outputs compilation errors after updating Angular, we must refer to the <em class="italic">Breaking Changes</em> section of TypeScript's official announcement blog post.</p>
			<h3>RxJS</h3>
			<p>The <a id="_idIndexMarker387"/>RxJS versions <a id="_idIndexMarker388"/>officially supported by Angular can be read by inspecting the <strong class="source-inline">dependencies</strong> property of the <strong class="source-inline">@angular/core</strong> <strong class="source-inline">package.json</strong> file. Angular versions 9.0–10.0 officially support RxJS versions 6.5 and 6.6 while Angular versions 10.1–12.1 only have official support for RxJS version 6.6. Angular version 12.2 has opt-in support for RxJS version 7.0 and later minor versions.</p>
			<h3>Node.js</h3>
			<p>Angular CLI <a id="_idIndexMarker389"/>usually has official support for two major <a id="_idIndexMarker390"/>versions of Node.js. Unstable (odd) major version Node.js releases are not officially supported by Angular CLI. Angular CLI versions 9.0–11.2 have official support for Node.js 10.13 and 12.11 or later minor versions. Angular version 12 removes support for Node.js 10 but adds official support for Node.js 14.15 or later minor versions<a id="_idIndexMarker391"/> in addition to Node.js 12.14 or later minor versions.</p>
			<p>In this <a id="_idIndexMarker392"/>section, we learned about the Angular Update Guide and how to manage Angular's dependencies. In the next section, we will learn about the <strong class="source-inline">ng update</strong> command and automated Angular Ivy migrations.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor121"/>Performing automated Angular Ivy migrations</h1>
			<p>Angular CLI supports <a id="_idIndexMarker393"/>automated migrations for both Angular framework packages and third-party Angular libraries. In this section, we will learn how to make the most out of the <strong class="source-inline">ng update</strong> command. Finally, we will discuss important automated Angular Ivy migrations.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor122"/>Making the most of the ng update command</h2>
			<p>The <strong class="source-inline">ng update</strong> command is used to <a id="_idIndexMarker394"/>update Angular-specific package dependencies, both Angular framework packages and third-party Angular libraries. The <strong class="source-inline">ng update</strong> command <a id="_idIndexMarker395"/>looks for automated migrations in the package bundle when updating to the specified package version.</p>
			<p>To update Angular, the following command can be used:</p>
			<p class="source-code">ng update @angular/cli @angular/core</p>
			<p>This will update all the main Angular framework packages to the latest version as well as performing their automated migrations. Angular CLI is responsible for workspace migrations while the Angular Core package is responsible for migrations to Angular's runtime packages.</p>
			<p>In the <em class="italic">Learning the Angular update process</em> section, we recommended only updating one major version at a time. To specify, for example, Angular version 9, use the following command:</p>
			<p class="source-code">ng update @angular/cli^9 @angular/core^9</p>
			<p>This will update the main Angular framework packages to the latest version 9 patch versions.</p>
			<p>It is possible to perform<a id="_idIndexMarker396"/> each migration in a separate commit by specifying the <strong class="source-inline">--create-commits</strong> parameter, as shown in the following command:</p>
			<p class="source-code">ng update @angular/cli^9 @angular/core^9 --create-commits</p>
			<p>This option is recommended as it makes it easier to inspect the changes related to each migration or use Git to cherry-pick the automated migrations we want, or even revert a migration's changes.</p>
			<p>If we choose to revert or omit a migration through Git cherry-picking, we usually want to perform the migration manually. Alternatively, we can rerun a specific migration using the following command format:</p>
			<p class="source-code">ng update &lt;package-name&gt;[@&lt;package-version&gt;] --migrate-only &lt;migration-name&gt;</p>
			<p>We find the name of the migration in the message of the Git commits that are created when specifying the <strong class="source-inline">--create-commits</strong> parameter.</p>
			<p>In some cases, optional migrations are available. For example, Angular version 12 introduces an optional automated migration for making the <strong class="source-inline">production</strong> build configuration the default:</p>
			<p class="source-code">ng update @angular/cli@^12 --migrate-only production-by-default</p>
			<p>As for when to run the main <strong class="source-inline">ng update</strong> command, we follow the Angular Update Guide's instructions as described in the <em class="italic">Learning the Angular update process</em> section.</p>
			<p>For every migration run by the <strong class="source-inline">ng update</strong> command, we see a list of files affected by the migration – if any – before <strong class="source-inline">Migration completed</strong> is displayed.</p>
			<p>Some migrations refer to a web page describing the migration. For example, why the change is needed in addition to code snippets with examples of code before and after running the migration. This is excellent information to review the changes made by the automated migration or to perform the migration steps manually.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor123"/>Reviewing automated Angular Ivy migrations</h2>
			<p>Let's review <a id="_idIndexMarker397"/>some of the most important<a id="_idIndexMarker398"/> automated Angular Ivy migrations to understand their importance.</p>
			<h3>Angular workspace version 9 migration</h3>
			<p>Named <strong class="source-inline">workspace-version-9</strong>, this<a id="_idIndexMarker399"/> migration modifies build configurations <a id="_idIndexMarker400"/>so that the <strong class="source-inline">aot</strong> option is set to <strong class="source-inline">true</strong>, even in the default development build configuration. In fact, if we generate a new Angular Ivy workspace or application using Angular CLI 12, there is no <strong class="source-inline">aot</strong> option specified because its value is <strong class="source-inline">true</strong> by default.</p>
			<p>This migration also changes the <strong class="source-inline">include</strong> property of <strong class="source-inline">tsconfig.app.json</strong> files to match the <strong class="source-inline">"src/**/*.d.ts"</strong> pattern.</p>
			<h3>Lazy loading syntax migration</h3>
			<p>This <a id="_idIndexMarker401"/>migration, named <strong class="source-inline">lazy-loading-syntax</strong>, changes string-based lazy loaded route paths to <a id="_idIndexMarker402"/>use dynamic <strong class="source-inline">import</strong> statements instead. For example, look at the following route configuration:</p>
			<p class="source-code">{</p>
			<p class="source-code">  path: 'dashboard',</p>
			<p class="source-code">  loadChildren: './dashboard.module#DashboardModule',</p>
			<p class="source-code">},</p>
			<p>It is changed to the following by the migration:</p>
			<p class="source-code">{</p>
			<p class="source-code">  path: 'dashboard',</p>
			<p class="source-code">  loadChildren: () =&gt; import('./dashboard.module')</p>
			<p class="source-code">    .then(m =&gt; m.DashboardModule),</p>
			<p class="source-code">},</p>
			<p>The string-based lazy loading route syntax is deprecated and must be avoided.</p>
			<h3>Static flag migration</h3>
			<p>Be <a id="_idIndexMarker403"/>careful with<a id="_idIndexMarker404"/> this migration named <strong class="source-inline">migration-v9-dynamic-queries</strong>. In Angular version 8, the required <strong class="source-inline">static</strong> option is added to <strong class="source-inline">ViewChild</strong> and <strong class="source-inline">ContentChild</strong> queries. In Angular version 9, the <strong class="source-inline">static</strong> option is made optional, defaulting to <strong class="source-inline">false</strong>.</p>
			<p>Consider the following Angular version 9 component:</p>
			<p class="source-code">import { Component, ElementRef, ViewChild } from '@angular/core';</p>
			<p class="source-code">@Component({</p>
			<p class="source-code">  selector: 'app-hello',</p>
			<p class="source-code">  template: '</p>
			<p class="source-code">    &lt;h1 #greeting&gt;</p>
			<p class="source-code">      Hello, World!</p>
			<p class="source-code">    &lt;/h1&gt;</p>
			<p class="source-code">    &lt;div #error *ngIf="hasError"&gt;</p>
			<p class="source-code">      An error occurred</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  ',</p>
			<p class="source-code">})</p>
			<p class="source-code">export class HelloComponent {</p>
			<p class="source-code">  @ViewChild('error')</p>
			<p class="source-code">  errorElement?: ElementRef&lt;HTMLElement&gt;;</p>
			<p class="source-code">  @ViewChild('greeting', { static: true })</p>
			<p class="source-code">  greetingElement?: ElementRef&lt;HTMLElement&gt;;</p>
			<p class="source-code">}</p>
			<p>In Angular View Engine version 7, before the static <strong class="source-inline">option</strong> was available, its view query properties would start out like so:</p>
			<p class="source-code">@ViewChild('error')</p>
			<p class="source-code">errorElement?: ElementRef&lt;HTMLElement&gt;;</p>
			<p class="source-code">@ViewChild('greeting')</p>
			<p class="source-code">greetingElement?: ElementRef&lt;HTMLElement&gt;;</p>
			<p>After <a id="_idIndexMarker405"/>migrating to Angular View Engine <a id="_idIndexMarker406"/>version 8, we have the following view query properties because the <strong class="source-inline">static</strong> option is required:</p>
			<p class="source-code">@ViewChild('error', { static: false })</p>
			<p class="source-code">errorElement?: ElementRef&lt;HTMLElement&gt;;</p>
			<p class="source-code">@ViewChild('greeting', { static: true })</p>
			<p class="source-code">greetingElement?: ElementRef&lt;HTMLElement&gt;;</p>
			<p>As you might be able to see, the Angular version 8 <em class="italic">static query migration</em> is good at guessing the best option for view query and content query properties. Queries for items nested in embedded views such as that created by a structural directive are converted to dynamic queries, that is, <strong class="source-inline">{ static: false }.</strong></p>
			<p>When we migrate to Angular Ivy version 9, the <strong class="source-inline">static</strong> option is optional but defaults to <strong class="source-inline">false</strong>, so we have the following view query properties:</p>
			<p class="source-code">@ViewChild('error')</p>
			<p class="source-code">errorElement?: ElementRef&lt;HTMLElement&gt;;</p>
			<p class="source-code">@ViewChild('greeting', { static: true })</p>
			<p class="source-code">greetingElement?: ElementRef&lt;HTMLElement&gt;;</p>
			<p>Dynamic queries automatically have the <strong class="source-inline">static</strong> option removed by the Angular version 9 <em class="italic">static flag migration</em>.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Query lists are not affected by the historic changes covered by this section because query lists are always dynamic.</p>
			<p>Before <a id="_idIndexMarker407"/>migrating to Angular Ivy version 9, make <a id="_idIndexMarker408"/>sure to review your content and view queries. Refer to the <em class="italic">Static query migration guide</em> and <em class="italic">Dynamic queries flag migration</em> guides, which are still available in the Angular documentation at <a href="https://angular.io/guide/static-query-migration">https://angular.io/guide/static-query-migration</a> and <a href="https://angular.io/guide/migration-dynamic-flag">https://angular.io/guide/migration-dynamic-flag</a>, respectively, as of Angular version 12.2.</p>
			<h3>async to waitForAsync migration</h3>
			<p>This <a id="_idIndexMarker409"/>migration, named <strong class="source-inline">migration-v11-wait-for-async</strong>, renames the <strong class="source-inline">async</strong> testing<a id="_idIndexMarker410"/> callback wrapper to <strong class="source-inline">waitForAsync</strong> to avoid confusion with <strong class="source-inline">async</strong>-<strong class="source-inline">await</strong>. The new name better explains what happens when we wrap a test case callback in this testing function.</p>
			<p><strong class="source-inline">waitForAsync</strong> waits for all microtasks and macrotasks to finish before completing the wrapped test case. This is somewhat like injecting Jasmine and Jest's <strong class="source-inline">done</strong> callback parameter and calling it after the final asynchronous side effect in a test case.</p>
			<h3>Missing @Injectable and incomplete provider definition migration</h3>
			<p>This <a id="_idIndexMarker411"/>automated<a id="_idIndexMarker412"/> Angular version 9 migration named <strong class="source-inline">migration-v9-missing-injectable</strong> makes the following types of code changes:</p>
			<ul>
				<li>An <strong class="source-inline">@Injectable</strong> decorator is added to classes that are registered using class-based module providers.</li>
				<li>Incomplete Angular View Engine module providers are turned into value providers for the <strong class="source-inline">undefined</strong> value.</li>
			</ul>
			<p>A class-based module provider can have one of the following formats:</p>
			<p class="source-code">@NgModule({</p>
			<p class="source-code">  providers: [</p>
			<p class="source-code">    DashboardService,</p>
			<p class="source-code">    {</p>
			<p class="source-code">      provide: weatherServiceToken,</p>
			<p class="source-code">      useClass: HttpWeatherService,</p>
			<p class="source-code">    },</p>
			<p class="source-code">  ],</p>
			<p class="source-code">})</p>
			<p class="source-code">export class DashboardServiceModule { }</p>
			<p>If <strong class="source-inline">DashboardService</strong> or <strong class="source-inline">HttpWeatherService</strong> do not have <strong class="source-inline">Injectable</strong> decorators <a id="_idIndexMarker413"/>applied, this migration adds an <strong class="source-inline">Injectable</strong> decorator to their class definitions.</p>
			<p>A <a id="_idIndexMarker414"/>module provider using the following format is evaluated differently by Angular View Engine and Angular Ivy:</p>
			<p class="source-code">@NgModule({</p>
			<p class="source-code">  providers: [</p>
			<p class="source-code">    { provide: MusicPlayerService },</p>
			<p class="source-code">  ],</p>
			<p class="source-code">})</p>
			<p class="source-code">export class MusicServiceModule { }</p>
			<p>Angular View Engine evaluates the provider as the following value provider:</p>
			<p class="source-code">{ provide: MusicPlayerService, useValue: undefined }</p>
			<p>Angular Ivy evaluates the provider as the following class provider:</p>
			<p class="source-code">{ provide: MusicPlayerService, useClass: MusicPlayerService }</p>
			<p>Note that the preceding class provider is equivalent to the following class provider shorthand:</p>
			<p class="source-code">@NgModule({</p>
			<p class="source-code">  providers: [</p>
			<p class="source-code">    MusicPlayerService,</p>
			<p class="source-code">  ],</p>
			<p class="source-code">})</p>
			<p class="source-code">export class MusicServiceModule { }</p>
			<p>Because <a id="_idIndexMarker415"/>of that difference between provider evaluation, this migration changes incomplete Angular View Engine providers to value providers specifying the <strong class="source-inline">undefined</strong> value.</p>
			<p>Review <a id="_idIndexMarker416"/>all providers with the <strong class="source-inline">useValue: undefined</strong> part after this migration is run. This is most likely not the intent of our application.</p>
			<h3>Optional migration to update Angular CLI workspace configurations to production mode by default</h3>
			<p>Angular CLI version 12 <a id="_idIndexMarker417"/>generates project build configurations with <strong class="source-inline">production</strong> being the default configuration. The result of this is that we do not have to specify the <strong class="source-inline">--configuration=production</strong> parameter to the <strong class="source-inline">ng build</strong> command.</p>
			<p>However, existing<a id="_idIndexMarker418"/> projects are not automatically migrated to use the production configuration by default. Use the optional migration named <strong class="source-inline">production-by-default</strong> to migrate existing projects to this new default setting. This is done primarily using the <strong class="source-inline">defaultConfiguration</strong> setting introduced by Angular version 12.</p>
			<p>These are some of the most noteworthy, automated migrations to be aware of when updating from Angular View Engine to Angular Ivy. In the next section, we will discuss optional manual migrations to make sure our Angular Ivy application is in its best possible shape.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor124"/>Performing manual Angular Ivy migrations</h1>
			<p>In this<a id="_idIndexMarker419"/> section, we will walk through optional migrations that put our application on track for future Angular versions. We will discuss fine-tuning initial navigation, optimizing change detection with <strong class="source-inline">NgZone</strong>, and improving the type safety of our unit tests.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor125"/>Managing initial navigation</h2>
			<p>The <a id="_idIndexMarker420"/>following legacy values for the <strong class="source-inline">initialNavigation</strong> option for <strong class="source-inline">RouterModule.forRoot</strong> are removed by Angular Ivy version 11:</p>
			<ul>
				<li><strong class="source-inline">true</strong></li>
				<li><strong class="source-inline">false</strong></li>
				<li><strong class="source-inline">'legacy_enabled'</strong></li>
				<li><strong class="source-inline">'legacy_disabled'</strong></li>
			</ul>
			<p>Angular Ivy version 11 <a id="_idIndexMarker421"/>also deprecates the <strong class="source-inline">'enabled'</strong> value but introduces the following new values:</p>
			<ul>
				<li><strong class="source-inline">'enabledBlocking'</strong> </li>
				<li><strong class="source-inline">'enabledNonBlocking'</strong> (default)</li>
			</ul>
			<p><strong class="source-inline">'enabledBlocking'</strong> is <a id="_idIndexMarker422"/>equivalent to <strong class="source-inline">'enabled'</strong> and is recommended for server-side rendering using Angular Universal. This value starts the initial navigation process before Angular creates an instance of the root component of our application but blocks bootstrapping of the root component until the initial navigation completes.</p>
			<p>The default <strong class="source-inline">'enabledNonBlocking'</strong> value<a id="_idIndexMarker423"/> starts the initial navigation after Angular has created an instance of the root component of our application but allows the root component to be bootstrapped before the initial navigation completes. This behavior is like the <strong class="source-inline">true</strong> value, which has now been removed.</p>
			<p><strong class="source-inline">'disabled'</strong> is the<a id="_idIndexMarker424"/> third available, non-deprecated value. It disables the initial navigation process and defers to our application code to perform it by using the <strong class="source-inline">Location</strong> and <strong class="source-inline">Router</strong> services. This value should only be used for advanced use cases.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor126"/>Optimizing change detection by configuring NgZone</h2>
			<p>When <a id="_idIndexMarker425"/>we call the <strong class="source-inline">PlatformRef#bootstrapModule</strong> method—usually in our application's main file—we can specify both compiler and bootstrap options. Bootstrap options are not listed in the Angular documentation as of Angular version 12.2. However, inline documentation is available.</p>
			<p>Other than<a id="_idIndexMarker426"/> the traditional <strong class="source-inline">ngZone</strong> option, which allows us to disable <strong class="source-inline">NgZone</strong> entirely, the following two options are added by Angular Ivy:</p>
			<ul>
				<li><strong class="source-inline">ngZoneEventCoalescing</strong></li>
				<li><strong class="source-inline">ngZoneRunCoalescing</strong></li>
			</ul>
			<p>They both<a id="_idIndexMarker427"/> accept a Boolean value that defaults to <strong class="source-inline">false</strong>. Both options optimize change detection for specific use cases by turning multiple change<a id="_idIndexMarker428"/> detection cycle requests in the same VM turn into a single operation, scheduled using an animation frame to synchronize change detection with the current frame rate.</p>
			<p>Event coalescing (<strong class="source-inline">ngZoneEventCoalsecing</strong>) refers to native DOM event bubbling. For example, if multiple click event handlers are triggered by a single user click, change detection is only triggered once.</p>
			<p><strong class="source-inline">ngZoneRunCoalescing</strong> manages the <strong class="source-inline">NgZone#run</strong> method being called multiple times in the same VM turn.</p>
			<p>It is a good default to enable both these options because they increase performance. However, they might change our application's behavior in certain edge cases, causing for example the <em class="italic">NG0100</em> error, <strong class="source-inline">ExpressionChangedAfterItHasBeenCheckedError</strong>, to be thrown in Angular development mode.</p>
			<p>Because of this, take special care when enabling these bootstrap settings for our application.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor127"/>Improving unit test type safety with TestBed.inject</h2>
			<p>Angular Ivy<a id="_idIndexMarker429"/> introduces the static <strong class="source-inline">TestBed.inject</strong> method, which is a strongly typed method that<a id="_idIndexMarker430"/> replaces<a id="_idIndexMarker431"/> the weakly typed static <strong class="source-inline">TestBed.get</strong> method.</p>
			<p>The <strong class="source-inline">TestBed.get</strong> method returns a value of type <strong class="source-inline">any</strong>. In the following example, we see how this forces us to specify a type of annotation to the variable we store the returned dependency in:</p>
			<p class="source-code">it('displays dashboard tiles', () =&gt; {</p>
			<p class="source-code">  const dashboardService: DashboardService =</p>
			<p class="source-code">    TestBed.get(DashboardService);</p>
			<p class="source-code">  // (...)</p>
			<p class="source-code">});</p>
			<p>When migrating to <strong class="source-inline">TestBed.inject</strong>, we can often omit the type annotation, as shown in the following equivalent code snippet:</p>
			<p class="source-code">it('displays dashboard tiles', () =&gt; {</p>
			<p class="source-code">  const dashboardService = </p>
			<p class="source-code">   TestBed.inject(DashboardService);</p>
			<p class="source-code">  // (...)</p>
			<p class="source-code">});</p>
			<p>If the provided type is different from the provider token, we now must cast the returned dependency to <strong class="source-inline">unknown</strong> before casting it to the registered type, as shown in the following example:</p>
			<p class="source-code">it('displays dashboard tiles', () =&gt; {</p>
			<p class="source-code">  TestBed.configureTestingModule({</p>
			<p class="source-code">    providers: [</p>
			<p class="source-code">      {</p>
			<p class="source-code">        provide: DashboardService,</p>
			<p class="source-code">        useClass: DashboardServiceStub</p>
			<p class="source-code">      },</p>
			<p class="source-code">    ],</p>
			<p class="source-code">  });</p>
			<p class="source-code">  const dashboardServiceStub =</p>
			<p class="source-code">    TestBed.inject(DashboardService)</p>
			<p class="source-code">      as unknown as DashboardServiceStub;</p>
			<p class="source-code">  // (...)</p>
			<p class="source-code">});</p>
			<p>It is worth <a id="_idIndexMarker432"/>noting that <strong class="source-inline">TestBed.inject</strong> is also stricter than <strong class="source-inline">TestBed.get</strong> in that it only accepts a provider token arguments of type <strong class="source-inline">Type&lt;T&gt; | AbstractType&lt;T&gt; | InjectionToken&lt;T&gt;</strong>, that is, a concrete class, an abstract class, or a dependency injection token.</p>
			<p>This is<a id="_idIndexMarker433"/> different from <strong class="source-inline">TestBed.get</strong>, which supports a provider token of type <strong class="source-inline">any</strong>, for example a string, a number, or a symbol.</p>
			<p>Avoid provider<a id="_idIndexMarker434"/> tokens that are not supported by <strong class="source-inline">TestBed.inject</strong> as they have been deprecated since Angular version 4, like the weakly typed <strong class="source-inline">Injector#get</strong> signature used for resolving dependencies at runtime.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor128"/>Summary</h1>
			<p>In this chapter, we discussed the Angular update process, including the <em class="italic">Angular Update Guide,</em> the <strong class="source-inline">ng update</strong> command, and managing Angular's third-party dependencies.</p>
			<p>We learned how to review certain important automated Angular Ivy migrations by going through simple code examples.</p>
			<p>Finally, we considered several optional migrations, both automated and manual Angular Ivy migrations. We learned how to fine-tune the Angular router's initial navigation based on our application platform.</p>
			<p>After that, we discussed two undocumented configuration settings for <strong class="source-inline">NgZone</strong> that optimize change detection by coalescing multiple requested change detection cycles into one for certain native events and use cases.</p>
			<p>The final manual migration we discussed improves type safety in our unit tests by using the strongly typed static <strong class="source-inline">TestBed.inject</strong> method instead of the deprecated static <strong class="source-inline">TestBed.get</strong> method.</p>
			<p>In the next chapter, we will explore the impact and limitations of the Angular Ahead-of-Time compiler, which is the default for applications in Angular Ivy.</p>
		</div>
	</div></body></html>