<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Separating Concerns with Typed Services</h1>
                </header>
            
            <article>
                
<p class="mce-root">This chapter builds on the previous chapter, with more techniques showing how communication occurs within your application's building blocks. You will learn the following topics in this chapter:</p>
<ul>
<li>Services and Dependency Injection (DI) concepts</li>
<li>Component communication with services</li>
<li>Writing data logic with services</li>
</ul>
<p>To understand services better, you need to understand <span>at least </span>the basic concepts of Dependency Injection.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dependency injection</h1>
                </header>
            
            <article>
                
<p>Writing Angular in TypeScript demands that your building blocks (components, directives, services, and so on) are written in classes. They are just building blocks, which means that they need to be intertwined with each other before they can become functional, thus making a full-blown application.</p>
<p>This intertwining process can be pretty daunting. For this reason, let's understand the problem first. Take the following TypeScript class, for instance:</p>
<pre>export class Developer {<br/>  private skills: Array&lt;Skill&gt;;<br/>  private bio: Person;<br/>  constructor() {<br/>    this.bio = new Person('Sarah', 'Doe', 24, 'female');<br/>    this.skills = [<br/>      new Skill('css'), <br/>      new Skill('TypeScript'), <br/>      new Skill('Webpack')<br/>    ];<br/>  }<br/>}</pre>
<p>The implementation of the <kbd>Person</kbd> and <kbd>Skill</kbd> classes is as simple as the following:</p>
<pre>// Person Class<br/>export class Person {<br/>  private fName: string;<br/>  private lName: string;<br/>  private age: number;<br/>  private gender: string;<br/>  constructor(<br/>    fName: string, <br/>    lName: string, <br/>    age: number, <br/>    gender: string, <br/>  ) {<br/>    this.fName = fName;<br/>    this.lName = lName;<br/>    this.age = age;<br/>    this.gender = gender;<br/>  }<br/>}<br/><br/>// Skill Class<br/>export class Skill {<br/>  private type: string;<br/>  constructor(<br/>    type: string<br/>  ) {<br/>    this.type = type;<br/>  }<br/>}</pre>
<p>The preceding sample is very functional and valid code until you starting having more developer types that need to be created using this class. There is no way to actually create another type of developer because all the implementation details are tied to a class; hence, the process isn't flexible. We need to make the class a lot more generic before it can be used to create more types of developer.</p>
<p>Let's try improving the<span> </span><kbd>Developer</kbd><span> </span>class, so it receives all the values needed to create a class from the constructor rather than setting it in the class:</p>
<pre>export class Developer {<br/>  private skills: Array&lt;Skills&gt;;<br/>  private bio: Person;<br/>  constructor(<br/>    fName: string, <br/>    lName: string, <br/>    age: number, <br/>    gender: string, <br/>    skills: Array&lt;string&gt;<br/>  ) {<br/>    this.bio = new Person(fName, lName, age, gender);<br/>    this.skills = skills.map(skill =&gt; new Skill(skill));<br/>  }<br/>}</pre>
<p>So much improvement in so few lines! We are now using the constructor to make the code a lot more flexible. With this update, you can use the<span> </span><kbd>Developer</kbd><span> </span>class to create as many types of developer as you need.</p>
<p>Although this solution seems like it will save the day, there is still a tight coupling issue going on in the system. What happens when the constructors in the<span> </span><kbd>Person</kbd><span> </span>and<span> </span><kbd>Skill</kbd><span> </span>classes change? The implication is that you will have to come back and update the call to this constructor in the<span> </span><kbd>Developer</kbd><span> </span>class. Here is an example of such a change in<span> </span><kbd>Skill</kbd>:</p>
<pre>// Skill Class<br/>export class Skill {<br/>  private type: string;<br/>  private yearsOfExperience: number;<br/>  constructor(<br/>    type: string,<br/>    yearsOfExperience: number<br/>  ) {<br/>    this.type = type;<br/>    this.yearsOfExperience = yearsOfExperience<br/>  }<br/>}</pre>
<p>We added another field to the<span> </span><kbd>yearsOfExperience</kbd> <span>class, </span>which is of the number type and represents how long a developer has been practicing a claimed skill. For this to actually work in <kbd>Developer</kbd>, we have to update the <kbd>Developer</kbd> class as well:</p>
<pre>export class Developer {<br/>  public skills: Array&lt;Skill&gt;;<br/>  private bio: Person;<br/>  constructor(<br/>    fName: string, <br/>    lName: string, <br/>    age: number, <br/>    gender: string, <br/>    skils: Array&lt;any&gt;<br/>  ) {<br/>    this.bio = new Person(fName, lName, age, gender);<br/>    this.slills = skills.map(skill =&gt; <br/>       new Skill(skill.type, skill.yearsOfExperience));<br/>  }<br/>}</pre>
<p>Updating this class every time a dependency changes is what we're are striving to avoid. A common practice is to elevate the constructors of the dependencies to the constructor of the class itself:</p>
<pre>export class Developer {<br/>  public skills: &lt;Skill&gt;;<br/>  private person: Person;<br/>  constructor(<br/>    skill: Skill,<br/>    person: Person<br/>  ) {}<br/>}</pre>
<p>This way, the <kbd>Developer</kbd> is less aware of the implementation details of <kbd>Skill</kbd> and <kbd>Person</kbd>. Therefore, if they change internally, <kbd>Developer</kbd> won't care; it just stays as is.</p>
<p>In fact, TypeScript provides a productivity shorthand:</p>
<pre>export class Developer {<br/>  constructor(<br/>    public skills: &lt;Skill&gt;,<br/>    private person: Person<br/>  ) {}<br/>}</pre>
<p>This shorthand will implicitly declare the properties and assign them as dependencies via the constructor as well.</p>
<p>That's not all; elevating these dependencies introduces another challenge. How do we manage all the dependencies in our application without losing track of where things are meant to be? This is where Dependency Injection comes in. It's not an Angular thing, but a popular pattern implemented in Angular.</p>
<p>Let's start seeing DI in action right in an Angular app.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data in components</h1>
                </header>
            
            <article>
                
<p>To better understand the importance of services and DI, let's create a simple app with a component that shows a list of user comments. Once you have an app created, you can run the following command to generate the required component:</p>
<pre><strong>ng g component comment-list</strong></pre>
<p>Update the component's code with the following snippet:</p>
<pre>import { Component, OnInit } from '@angular/core';<br/><br/>@Component({<br/>  selector: 'app-comment-list',<br/>  templateUrl: './comment-list.component.html',<br/>  styleUrls: ['./comment-list.component.css']<br/>})<br/>export class CommentListComponent implements OnInit {<br/><br/>  comments: Array&lt;any&gt;<br/>  constructor() { }<br/><br/>  ngOnInit() {<br/>    this.comments = [<br/>      {<br/>        author: 'solomon',<br/>        content: `TypeScript + Angular is amazing`<br/>      },<br/>      {<br/>        author: 'lorna',<br/>        content: `TypeScript is really awesome`<br/>      },<br/>      {<br/>        author: 'codebeast',<br/>        content: `I'm new to TypeScript`<br/>      },<br/>    ];<br/>  }<br/><br/>}</pre>
<p>The component has a<span> </span><kbd>comments</kbd><span> </span>array, which is populated with<span> </span>hardcoded<span> </span>data once the component is initialized via the<span> </span><kbd>ngOnInit</kbd><span> </span>lifecycle. Now we need to iterate over the list of arrays and print on the DOM:</p>
<pre>&lt;div class="list-group"&gt;<br/>  &lt;a href="#" class="list-group-item" *ngFor="let comment of comments"&gt;<br/>    &lt;h4 class="list-group-item-heading"&gt;{{comment.author}}&lt;/h4&gt;<br/>    &lt;p class="list-group-item-text"&gt;{{comment.content}}&lt;/p&gt;<br/>  &lt;/a&gt;<br/>&lt;/div&gt;</pre>
<p>You need to include the component in your entry (app) component for it to show up:</p>
<pre>&lt;div class="container"&gt;<br/>  &lt;h2 class="text-center"&gt;TS Comments&lt;/h2&gt;<br/>  &lt;div class="col-md-6 col-md-offset-3"&gt;<br/>    &lt;app-comment-list&gt;&lt;/app-comment-list&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</pre>
<p>Your app should look like the following (remember to include Bootstrap as seen in <a href="1388eb32-f9cf-4efd-86fe-dc3f201ed039.xhtml">Chapter 2</a>, <em>Getting Started with TypeScript</em>):</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-317 image-border" height="1166" src="assets/d857dd7f-3771-4c0f-b578-17ce88a96779.png" width="1856"/></div>
<p>This example works, but the devil lies in the detail. When another component needs a list of comments or a portion of the list, we end up recreating the comments. This is the problem with having data in components.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data class services</h1>
                </header>
            
            <article>
                
<p>For the sake of reusability and maintainability, we need to abstract the logic concerns out of the component and let the component just serve as a presentation layer. This is one of those use cases where TypeScript services in Angular come into play.</p>
<p>You <span>first </span>need to create a service with the following command:</p>
<pre><strong>ng g service comment</strong></pre>
<p>This creates your service class, <kbd>./src/app/comment.service.ts</kbd>, with a scaffold content. Update the content with the following:</p>
<pre>import { Injectable } from '@angular/core';<br/><br/>@Injectable()<br/>export class CommentService {<br/>  private comments: Array&lt;any&gt; = [<br/>    {<br/>      author: 'solomon',<br/>      content: `TypeScript + Angular is amazing`<br/>    },<br/>    {<br/>      author: 'lorna',<br/>      content: `TypeScript is really awesome`<br/>    },<br/>    {<br/>      author: 'codebeast',<br/>      content: `I'm new to TypeScript`<br/>    }<br/>  ];<br/>  constructor() {}<br/><br/>  getComments() {<br/>    return this.comments;<br/>  }<br/>}</pre>
<p>The class now does whatever our component was supposed to do with the data, and the data is fetched using the <kbd>getComments</kbd> method, which simply returns an array of comments. The <kbd>CommentService</kbd> class is also decorated; this is not required unless the class has dependencies to be resolved. Nonetheless, good practice demands that we always decorate with <kbd>Injectable</kbd> to know that a class is meant to be a service.</p>
<p>Back with our list component, we just import the class, resolve the dependency from the constructor to create an instance of the service class, and then populate the property with the <kbd>getComments</kbd> return value:</p>
<pre>import { Component, OnInit } from '@angular/core';<br/>import { CommentService } from '../comment.service';<br/><br/>@Component({<br/>  selector: 'app-comment-list',<br/>  templateUrl: './comment-list.component.html',<br/>  styleUrls: ['./comment-list.component.css']<br/>})<br/>export class CommentListComponent implements OnInit {<br/>  private comments: Array&lt;any&gt;;<br/>  constructor(<br/>    private commentService: CommentService<br/>  ) { }<br/><br/>  ngOnInit() {<br/>    this.comments = this.commentService.getComments();<br/>  }<br/><br/>}</pre>
<p>Let's attempt to run the app with these current changes in our browser and see whether things still work as expected:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-318 image-border" height="1178" src="assets/8e3c6caa-3823-455d-9791-2546bf4e64f0.png" width="1849"/></div>
<p>Hell, no! It just blew up. What could have gone wrong? The error message reads <span class="packt_screen">No provider for CommentService!</span></p>
<p>Remember that, when we scaffold components with the <kbd>ng</kbd> CLI command, the CLI not only creates a component but also adds it to our declaration array in the <span>decorator of </span><kbd>ngModule</kbd>:</p>
<pre>// ./src/app/app.module.ts<br/>declarations: [<br/>    AppComponent,<br/>    // New scaffolded component here<br/>    CommentListComponent<br/>  ],</pre>
<p>Modules need to know which components and services belong to them as members. This is why the component is added automatically for you. This is not the same for services because the CLI doesn't automatically update the module (it warns you during the scaffold) when you create service classes via the CLI tool. We need to add the service manually via the <kbd>providers</kbd> array:</p>
<pre>import { CommentService } from './comment.service';<br/>//...<br/><br/>@NgModule({<br/>  //...<br/>  providers: [<br/>    CommentService<br/>  ],<br/>})<br/>export class AppModule { }</pre>
<p>Now, run the app once more to see how our service now powers the app with no more errors in the console:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-319 image-border" height="1176" src="assets/b6d2e1c8-27d6-4690-ad1e-ba2f1c79e877.png" width="1849"/></div>
<p>If there is a need to manipulate the data, it must be done in the service and not in the component. Assuming you want to delete a comment by double-clicking on each item in the list, it's fine to receive the event with the component but the actual deletion should be handled by the service.</p>
<p>Start by adding an event listener to the list items:</p>
<pre>&lt;a href="#" class="list-group-item" (dblclick)="removeComment(comment)" *ngFor="let comment of comments"&gt;<br/>    &lt;h4 class="list-group-item-heading"&gt;{{comment.author}}&lt;/h4&gt;<br/>    &lt;p class="list-group-item-text"&gt;{{comment.content}}&lt;/p&gt;<br/>  &lt;/a&gt;</pre>
<p>The <kbd>dblclick</kbd> event is triggered by double-clicking the items. When this happens, we call the <kbd>removeComment</kbd> method while passing the comment we want to remove from the item.</p>
<p>Here is what <kbd>removeComment</kbd> looks like in the component:</p>
<pre>removeComment(comment) {<br/>    this.comments = this.commentService.removeComment(comment);<br/>}</pre>
<p>As you can see, it doesn't do anything more than calling a method on our service, which is also called <kbd>removeComment</kbd>. This is the method that has the actual responsibility of removing items from the array of comments:</p>
<pre>// Comment service<br/>removeComment(removableComment) {<br/>    // find the index of the comment<br/>    const index = this.comments.findIndex(<br/>      comment =&gt; comment.author === removableComment.author<br/>    );<br/>    // remove the comment from the array<br/>    this.comments.splice(index, 1);<br/>    // return the new array<br/>    return this.comments;<br/>  }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Component interaction with services</h1>
                </header>
            
            <article>
                
<p>This is a very handy use case for services. In <a href="70f76e99-3d5b-43d6-90ad-5ea049aa622c.xhtml">chapter 6</a>, <em>Component Composition with</em> TypeScript, we discussed how components interact with each other and showed different ways of doing it. One of those ways was left out--using a service as an event hub/communication platform for different components.</p>
<p>Let's assume again that, when an item in the list is clicked, we use a sibling component to the comment list component to show a detailed view of the selected comment. First, we need to create this component:</p>
<pre><strong>ng g component comment-detail</strong></pre>
<p>Then, you can update the <kbd>app.component.html</kbd> file to show the added component:</p>
<pre>&lt;div class="container"&gt;<br/>  &lt;h2 class="text-center"&gt;TS Comments&lt;/h2&gt;<br/>  &lt;div class="col-md-4 col-md-offset-2"&gt;<br/>    &lt;app-comment-list&gt;&lt;/app-comment-list&gt;<br/>  &lt;/div&gt;<br/>  &lt;div class="col-md-4"&gt;<br/>    &lt;!-- Comment detail component --&gt;<br/>    &lt;app-comment-detail&gt;&lt;/app-comment-detail&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;<br/><br/></pre>
<p>Now, we need to define what our component does, because it's empty right now. But before that, let's update the comment service to also serve as a hub between the list component and the sibling detail component:</p>
<pre>import { Injectable } from '@angular/core';<br/>import { Subject } from 'rxjs/Subject';<br/><br/>@Injectable()<br/>export class CommentService {<br/>  private commentSelectedSource = new Subject&lt;any&gt;();<br/>  public commentSelected$ = this.commentSelectedSource.asObservable();<br/><br/>  private comments: Array&lt;any&gt; = [<br/>   // ...<br/>  ];<br/><br/>  // ...<br/><br/>  showComment(comment) {<br/>    this.commentSelectedSource.next(comment);<br/>  }<br/>}</pre>
<p>The service now uses an Rx subject to create a stream and a listener, which the selected comment is pushed through and fetched from. The <kbd>commentSelectedSource</kbd> object is responsible for adding a comment to the stream when the comment is clicked. The <kbd>commetSelected$</kbd> object is an observable that we can subscribe to and act on when this comment is clicked.</p>
<p>Now, head right back to your component and add a click event to select the comment item:</p>
<pre>&lt;div class="list-group"&gt;<br/>  &lt;a href="#" class="list-group-item" <br/>    (dblclick)="removeComment(comment)" <br/>    *ngFor="let comment of comments"<br/>    (click)="showComment(comment)"<br/>    &gt;<br/>    &lt;h4 class="list-group-item-heading"&gt;{{comment.author}}&lt;/h4&gt;<br/>    &lt;p class="list-group-item-text"&gt;{{comment.content}}&lt;/p&gt;<br/>  &lt;/a&gt;<br/>&lt;/div&gt;</pre>
<p>The click event triggers a <kbd>showComment</kbd> method on the component, which, in turn, calls <kbd>showComment</kbd> on the service:</p>
<pre>showComment(comment) {<br/>  this.commentService.showComment(comment);<br/>}</pre>
<p>We still have to update the comment detail component, so it subscribes to the observable we created in the class:</p>
<pre>import { Component, OnInit } from '@angular/core';<br/>import { CommentService } from '../comment.service';<br/><br/>@Component({<br/>  selector: 'app-comment-detail',<br/>  templateUrl: './comment-detail.component.html',<br/>  styleUrls: ['./comment-detail.component.css']<br/>})<br/>export class CommentDetailComponent implements OnInit {<br/><br/>  comment: any = {<br/>    author: '',<br/>    content: ''<br/>  };<br/>  constructor(<br/>    private commentService: CommentService<br/>  ) { }<br/><br/>  ngOnInit() {<br/>    this.commentService.commentSelected$.subscribe(comment =&gt; {<br/>      this.comment = comment;<br/>    })<br/>  }<br/><br/>}</pre>
<p>With the <kbd>ngOnInit</kbd> lifecycle hook, we are able to create a subscription to the observable once the component is ready. There is a comment property that will be bound to the view, and this property is updated via the subscription every time a comment item is clicked. Here is the template for the component showing the selected comment:</p>
<pre>&lt;div class="panel panel-default" *ngIf="comment.author"&gt;<br/>  &lt;div class="panel-heading"&gt;{{comment.author}}&lt;/div&gt;<br/>  &lt;div class="panel-body"&gt;<br/>    {{comment.content}}<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</pre>
<p>You can start the app again and try selecting a comment. You should see the following behavior:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-320 image-border" height="1177" src="assets/48b9955d-ace1-4e62-9f8a-3a88ab63ddef.png" width="1976"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Services as utilities</h1>
                </header>
            
            <article>
                
<p>Apart from managing state and component interaction, services are also known for handling utility operations. Let's say that we want to start collecting new comments in our comment app. We don't know much about forms yet, so we can use the browser's prompt. We expect the user to pass both the username and the content via the same textbox in the prompt, as follows:</p>
<pre>&lt;username&gt;: &lt;comment content&gt;</pre>
<p>Therefore, we need a utility method to extract these bits from the textbox into a comment object with the author and content properties. Let's start with collecting the information from the comment list component:</p>
<pre>showPrompt() {<br/>    const commentString = window.prompt('Please enter your username and content: ', 'username: content');<br/>    const parsedComment = this.commentService.parseComment(commentString);<br/>    this.commentService.addComment(parsedComment);<br/>  }</pre>
<p>The <kbd>showPrompt()</kbd> method is used to collect the user input, and the input is passed to the <kbd>parseComment</kbd> method on the service. This method is an example of a utility method, and we will implement it soon. We will also implement the <kbd>addComment</kbd> method, which is called with the parsed comment to update the list of comments. Next, add a button to the view with a click event listener that triggers <kbd>showPrompt</kbd>:</p>
<pre>&lt;button class="btn btn-primary" <br/> (click)="showPrompt()"<br/>&gt;Add Comment&lt;/button&gt;</pre>
<p>Add these two methods to the comment service:</p>
<pre>parseComment(commentString) {<br/>    const commentArr = commentString.split(':');<br/>    const comment = {<br/>      author: commentArr[0].trim(),<br/>      content: commentArr[1].trim()<br/>    }<br/>    return comment;<br/>  }<br/><br/>  addComment(comment) {<br/>    this.comments.unshift(comment);<br/>  }</pre>
<p>The <kbd>parseComment</kbd> method takes a string, splits the string, and gets the author and content of the comment. Then, it returns the comment. The addComment method takes a comment and adds it to the list of existing comments.</p>
<p>Now, you can start adding new comments, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-321 image-border" height="1176" src="assets/31cc7b09-e373-4aa9-9fa7-f4ef30bd706d.png" width="1975"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter exposed a lot of interesting concepts in data abstraction, while utilizing the power of dependency injection. You learned how components interact with each other using a service as a hub, how data and logic are abstracted from a component to services, and how reusable utility code is handled in a service to keep your application clean. In the next chapter, you'll learn a practical approach to forms in Angular and DOM events.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>