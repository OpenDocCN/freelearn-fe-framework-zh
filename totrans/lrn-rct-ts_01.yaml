- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Introducing React
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 React
- en: Facebook has become an incredibly popular app. As its popularity has grown,
    so has the demand for new features. **React** is Facebook’s answer to helping
    more people work on the code base and deliver features more quickly. React has
    worked so well for Facebook that Meta eventually made it open source. Today, React is
    a mature library for building component-based frontends that is extremely popular
    and has a massive community and ecosystem.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook 已经成为一款非常流行的应用。随着其知名度的增长，对新增功能的需求也在增加。**React** 是 Facebook 为帮助更多人参与代码库并更快地交付功能而提供的解决方案。React
    在 Facebook 的工作非常出色，以至于 Meta 最终将其开源。如今，React 是一个成熟的库，用于构建基于组件的前端，它非常受欢迎，拥有庞大的社区和生态系统。
- en: '**TypeScript** is also a popular, mature library maintained by another big
    company, Microsoft. It allows users to add a rich type system to their JavaScript
    code, helping them be more productive, particularly in large code bases.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**TypeScript** 也是一个由另一家大型公司，微软，维护的流行、成熟的库。它允许用户向他们的 JavaScript 代码添加丰富的类型系统，帮助他们提高生产力，尤其是在大型代码库中。'
- en: This book will teach you how to use both of these awesome libraries to build
    robust frontends that are easy to maintain. The first two chapters in the book
    will introduce React and TypeScript separately. You’ll then learn how to use React
    and TypeScript together to compose robust components with strong typing. The book
    covers key topics you’ll need to build a web frontend, such as styling, forms,
    and data fetching.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将教会你如何使用这两个出色的库来构建易于维护的健壮前端。本书的前两章将分别介绍 React 和 TypeScript。然后，你将学习如何将 React
    和 TypeScript 结合起来，使用强类型来构建健壮的组件。本书涵盖了构建网络前端所需的关键主题，例如样式、表单和数据获取。
- en: In this chapter, we will introduce React and understand the benefits it brings.
    We will then build a simple React component, learning about the JSX syntax and
    component props. After that, we will learn how to make a component interactive
    using component state and events. Along the way, we will also learn how to structure
    code in JavaScript modules.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 React 并了解它带来的好处。然后，我们将构建一个简单的 React 组件，学习 JSX 语法和组件属性。之后，我们将学习如何使用组件状态和事件使组件交互。在这个过程中，我们还将学习如何在
    JavaScript 模块中组织代码。
- en: By the end of this first chapter, you’ll be able to create simple React components
    and will be ready to learn how to strongly type them with TypeScript.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够创建简单的 React 组件，并准备好学习如何使用 TypeScript 强类型化它们。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the benefits of React
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 React 的好处
- en: Understanding JSX
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 JSX
- en: Creating a component
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个组件
- en: Understanding imports and exports
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解导入和导出
- en: Using props
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性
- en: Using state
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用状态
- en: Using events
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We use the following tools in this chapter:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用以下工具：
- en: '**Browser**: A modern browser such as Google Chrome.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浏览器**：一个现代浏览器，如 Google Chrome。'
- en: '**Babel REPL**: We’ll use this online tool to briefly explore JSX. It can be
    found at  [https://babeljs.io/repl](https://babeljs.io/repl).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Babel REPL**：我们将使用这个在线工具简要探索 JSX。它可以在 [https://babeljs.io/repl](https://babeljs.io/repl)
    找到。'
- en: '**CodeSandbox**: We’ll use this online tool to build a React component. This
    can be found at [https://codesandbox.io/](https://codesandbox.io/).'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CodeSandbox**：我们将使用这个在线工具来构建一个 React 组件。它可以在 [https://codesandbox.io/](https://codesandbox.io/)
    找到。'
- en: All the code snippets in this chapter can be found online at [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter1/](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter1/).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有的代码片段都可以在 [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter1/](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter1/)
    在线找到。
- en: Understanding the benefits of React
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 React 的好处
- en: Before we start creating our first React component, in this section, we will
    understand what React is and explore some of its benefits.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建第一个 React 组件之前，在本节中，我们将了解 React 是什么以及探索其一些好处。
- en: React is incredibly popular. We have already mentioned that Meta uses React
    for Facebook, but many other famous companies use it, too, such as Netflix, Uber,
    and Airbnb. React’s popularity has resulted in a huge ecosystem surrounding it
    that includes great tools, popular libraries, and many experienced developers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: React 非常受欢迎。我们之前提到 Meta 使用 React 为 Facebook 开发，但许多其他知名公司也在使用它，例如 Netflix、Uber
    和 Airbnb。React 的流行导致了一个围绕它的大生态系统，其中包括优秀的工具、流行的库和许多经验丰富的开发者。
- en: A reason for React’s popularity is that it is simple. This is because it focuses
    on doing one thing very well – providing a powerful mechanism for building UI
    components. Components are pieces of the UI that can be composed together to create
    a frontend. Furthermore, components can be reusable so that they can be used on
    different screens or even in other apps.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: React 流行的一个原因是它很简单。这是因为它专注于做好一件事 – 提供一个强大的机制来构建 UI 组件。组件是 UI 的组成部分，可以组合在一起来创建前端。此外，组件可以重用，因此可以在不同的屏幕上甚至在其他应用程序中使用。
- en: React’s narrow focus means it can be incorporated into an existing app, even
    if it uses a different framework. This is because it doesn’t need to take over
    the whole app to run; it is happy to run as part of an app’s frontend.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: React 的窄焦点意味着它可以集成到现有的应用程序中，即使它使用不同的框架。这是因为它不需要接管整个应用程序来运行；它乐意作为应用程序前端的一部分运行。
- en: React components are displayed performantly using a **virtual DOM** (**Document
    Object Model**). You may be familiar with the real DOM – it provides the structure
    for a web page. However, changes to the real DOM can be costly, leading to performance
    problems in an interactive app. React solves this performance problem by using
    an in-memory representation of the real DOM called a virtual DOM. Before React
    changes the real DOM, it produces a new virtual DOM and compares it against the
    current virtual DOM to calculate the minimum amount of changes required to the
    real DOM. The real DOM is then updated with those minimum changes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: React 组件通过使用 **虚拟 DOM**（**文档对象模型**）来高效地显示。你可能熟悉真实的 DOM – 它提供了网页的结构。然而，对真实 DOM
    的更改可能会带来高昂的成本，导致交互式应用程序的性能问题。React 通过使用真实 DOM 的内存表示形式，即虚拟 DOM，来解决这个性能问题。在 React
    更改真实 DOM 之前，它会生成一个新的虚拟 DOM，并将其与当前的虚拟 DOM 进行比较，以计算对真实 DOM 所需的最小更改量。然后，真实 DOM 使用这些最小更改进行更新。
- en: The fact that Meta uses React for Facebook is a major benefit because it ensures
    that it is of the highest quality – React breaking Facebook is not good for Meta!
    It also means a lot of thought and care goes into ensuring new versions of React
    are cheap to adopt, which helps reduce the maintenance costs of an app.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Meta 使用 React 为 Facebook 开发是一个重大优势，因为它确保了其最高质量 – React 导致 Facebook 出问题对 Meta
    来说可不是什么好事！这也意味着在确保新版本的 React 容易采用，从而有助于降低应用程序的维护成本方面投入了大量的思考和关注。
- en: React’s simplicity means it is easy and quick to learn. There are many great
    learning resources, such as this book. There is also a range of tools that make
    it very easy to scaffold a React app – one such tool is called **Create React
    App**, which we will learn about in [*Chapter 3*](B19051_03.xhtml#_idTextAnchor072),
    *Setting up React* *and TypeScript*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: React 的简单性意味着它容易且快速学习。有许多优秀的资源，例如这本书。还有一系列工具，使构建 React 应用程序变得非常容易 – 其中一个工具叫做
    **Create React App**，我们将在 [*第 3 章*](B19051_03.xhtml#_idTextAnchor072) 中学习，*设置
    React* 和 *TypeScript*。
- en: Now that we are starting to understand React, let’s dig deeper in the next section
    to understand how a React component defines what to display.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始理解 React 了，让我们在下一节深入探讨，了解 React 组件是如何定义显示内容的。
- en: Understanding JSX
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 JSX
- en: '**JSX** is the syntax we use in a React component to define what the component
    should display. JSX stands for **JavaScript XML**, which starts to give us a clue
    as to what it is. We will start to learn about JSX in this section and write some
    JSX in an online playground.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSX** 是我们在 React 组件中用来定义组件应显示内容的语法。JSX 代表 **JavaScript XML**，这开始让我们对它有了些了解。我们将从本节开始学习
    JSX，并在在线沙盒中编写一些 JSX 代码。'
- en: 'The following code snippet is a React component with its JSX highlighted:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是一个带有高亮 JSX 的 React 组件：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can see that JSX looks a bit like HTML. However, it isn’t HTML because an
    HTML `div` element doesn’t contain a `className` attribute, and there is no such
    element name as `Alert`. The JSX is also embedded directly within a JavaScript
    function, which is a little strange because a `script` element is normally used
    to place JavaScript inside HTML.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到 JSX 看起来有点像 HTML。然而，它并不是 HTML，因为 HTML 的 `div` 元素不包含 `className` 属性，也没有名为
    `Alert` 的元素。JSX 还直接嵌入在 JavaScript 函数中，这有点奇怪，因为 `script` 元素通常用于在 HTML 中放置 JavaScript。
- en: JSX is a JavaScript syntax extension. This means that it doesn’t execute directly
    in the browser – it needs to be transpiled to JavaScript first. A popular tool
    that can transpile JSX is called Babel.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 是一种 JavaScript 语法扩展。这意味着它不能直接在浏览器中执行 – 首先需要将其转换为 JavaScript。一个可以将 JSX 转换为
    JavaScript 的流行工具叫做 Babel。
- en: 'Carry out the following steps to write your first piece of JSX in the Babel
    playground:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来在 Babel 操场中编写你的第一个 JSX：
- en: 'Open a browser, go to [https://babeljs.io/repl](https://babeljs.io/repl), and
    enter the following JSX in the left-hand pane:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器，转到 [https://babeljs.io/repl](https://babeljs.io/repl)，并在左侧面板中输入以下 JSX：
- en: '[PRE1]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following appears in the right-hand pane, which is what our JSX has compiled
    down to:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容出现在右侧面板中，这是我们的 JSX 编译后的结果：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can see that it compiles down to a `React.createElement` function call,
    which has three parameters:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它编译成了一个 `React.createElement` 函数调用，该调用有三个参数：
- en: The element type can be an HTML element name (such as `"span"`), a React component
    type, or a React fragment type.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素类型可以是 HTML 元素名称（例如 `span`），React 组件类型或 React 片段类型。
- en: An object containing the properties to be applied to the element. Here, `null`
    is passed because there are no properties.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含要应用于元素的属性的对象。在这里，`null` 被传递，因为没有属性。
- en: The content of the element. Note that the element’s content is often referred
    to as **children** in React.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素的内容。请注意，在 React 中，元素的内容通常被称为 **children**。
- en: Note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The right-hand panel may also contain a `"use strict"` statement at the top
    to specify that the JavaScript will be run in **strict mode**. Strict mode is
    where the JavaScript engine throws an error when it encounters problematic code
    rather than ignoring it. See the following link for more information on the strict
    mode in JavaScript: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧面板的顶部可能还包含一个 `"use strict"` 声明，用于指定 JavaScript 将在 **严格模式** 下运行。严格模式是 JavaScript
    引擎在遇到有问题的代码时抛出错误，而不是忽略它。有关 JavaScript 中严格模式的更多信息，请参阅以下链接：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)。
- en: You may also see `/*#__PURE__*/` comments in the right-hand panel. These comments
    help bundlers such as webpack remove redundant code in the bundling process. We
    will learn about webpack in [*Chapter 3*](B19051_03.xhtml#_idTextAnchor072), *Setting
    up React* *and TypeScript*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可能在右侧面板中看到 `/*#__PURE__*/` 注释。这些注释有助于打包器（如 webpack）在打包过程中删除冗余代码。我们将在 [*第 3
    章*](B19051_03.xhtml#_idTextAnchor072) *设置 React 和 TypeScript* 中学习关于 webpack 的内容。
- en: 'Let’s expand our example by putting a `div` element around the `span` element,
    as shown in the following code snippet:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过将 `div` 元素放在 `span` 元素周围来扩展我们的示例，如下代码片段所示：
- en: '[PRE3]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This now transpiles to two function calls to `React.createElement`, with `span` being
    passed in as a child to `div`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在编译成了两个对 `React.createElement` 的函数调用，其中 `span` 被传递为 `div` 的子元素：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can also see a `className` property, with the `"title"` value passed with
    the `div` element.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到一个 `className` 属性，通过 `div` 元素传递了 `"title"` 值。
- en: Note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We have seen that React uses a `className` attribute rather than `class` for
    CSS class references. This is because `class` is a keyword in JavaScript, and
    using that would cause an error.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，React 使用 `className` 属性而不是 `class` 来引用 CSS 类。这是因为 `class` 是 JavaScript
    中的一个关键字，使用它会导致错误。
- en: 'Let’s do something really interesting now. Let’s embed some JavaScript within
    the JSX. So, make the following highlighted changes:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来做一些真正有趣的事情。让我们在 JSX 中嵌入一些 JavaScript。所以，进行以下高亮更改：
- en: '[PRE7]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We declared a `title` JavaScript variable, assigned it `"Oh no!"`, and embedded
    it within the `span` element.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个 `title` JavaScript 变量，将其赋值为 `"Oh no!"`，并将其嵌入到 `span` 元素中。
- en: Notice that the `title` variable is placed in curly braces inside the element.
    Any piece of JavaScript can be embedded within JSX by surrounding it in curly
    braces.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`title` 变量被放置在元素内部的括号中。任何 JavaScript 代码都可以通过括号包围的方式嵌入到 JSX 中。
- en: 'Our code now transpiles to the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的代码编译成了以下内容：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To further illustrate the use of JavaScript in JSX, let’s use a JavaScript
    ternary expression inside the `span` element. Add the following ternary expression:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了进一步说明 JavaScript 在 JSX 中的使用，让我们在 `span` 元素内部使用一个 JavaScript 三元表达式。添加以下三元表达式：
- en: '[PRE12]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A ternary expression is an inline conditional statement in JavaScript. The
    expression starts with the condition followed by `?`, then what returns when the
    condition is true followed by `:`, and finally, what returns when the condition
    is false. For more information on ternary expressions, see the following link:
    [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 三元表达式是JavaScript中的一个内联条件语句。表达式从条件开始，后跟`?`，然后是条件为真时返回的内容，接着是`:`，最后是条件为假时返回的内容。有关三元表达式的更多信息，请参阅以下链接：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator)。
- en: 'We see that the nested call to `React.createElement` uses the ternary expression
    as the child of `span`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到嵌套调用`React.createElement`使用三元表达式作为`span`的子元素：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This completes our exploration of JSX in the Babel playground.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们在Babel playground中对JSX的探索。
- en: 'In summary, JSX can be thought of as a mix of HTML and JavaScript to specify
    the output of a React component. JSX needs to be transpiled into JavaScript using
    a tool such as Babel. For more information on JSX, see the following link: [https://reactjs.org/docs/introducing-jsx.html](https://reactjs.org/docs/introducing-jsx.html).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，JSX可以被视为HTML和JavaScript的混合，用于指定React组件的输出。JSX需要使用像Babel这样的工具将其转换为JavaScript。有关JSX的更多信息，请参阅以下链接：[https://reactjs.org/docs/introducing-jsx.html](https://reactjs.org/docs/introducing-jsx.html)。
- en: Now that we understand a little more about JSX, we will create our first React
    component in the next section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对JSX有了更深入的了解，我们将在下一节创建我们的第一个React组件。
- en: Creating a component
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建组件
- en: In this section, we will create a React project using an online tool called
    CodeSandbox. We will take time to understand the entry point of a React app and
    how components are structured in a project before creating a basic React component.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用一个名为CodeSandbox的在线工具来创建一个React项目。在创建一个基本的React组件之前，我们将花时间了解React应用的入口点和组件在项目中的结构。
- en: Creating a CodeSandbox project
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建CodeSandbox项目
- en: The great thing about CodeSandbox is that we can create a React project at the
    click of a button in a web browser and then focus on how to create a React component.
    Note that we will learn how to create React projects in a code editor on your
    local computer in [*Chapter 3*](B19051_03.xhtml#_idTextAnchor072), *Setting up
    React and TypeScript*. Our focus is learning about the React fundamentals in this
    chapter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: CodeSandbox的伟大之处在于我们可以在网页浏览器中点击一下按钮就创建一个React项目，然后专注于如何创建React组件。请注意，我们将在[*第3章*](B19051_03.xhtml#_idTextAnchor072)“设置React和TypeScript”中学习如何在本地计算机上的代码编辑器中创建React项目。我们本章的重点是学习React基础知识。
- en: 'For now, let’s carry out the following steps to create a React component in
    CodeSandbox:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行以下步骤在CodeSandbox中创建一个React组件：
- en: Go to [https://codesandbox.io/](https://codesandbox.io/) in a browser and click
    the **Create Sandbox** button found on the right hand side of the page.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中转到[https://codesandbox.io/](https://codesandbox.io/)并点击页面右侧的**Create Sandbox**按钮。
- en: Note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can create a CodeSandbox account if you want, but you can also create a
    React project as an anonymous user.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想，可以创建一个CodeSandbox账户，但你也可以作为一个匿名用户创建一个React项目。
- en: A list of project templates appears. Click the **React** template (don’t choose
    the **React TypeScript** template because we are focusing solely on React in this
    chapter).
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 出现了一个项目模板列表。点击**React**模板（不要选择**React TypeScript**模板，因为我们本章将专注于React）。
- en: 'In a few seconds, a React project will be created:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，将创建一个React项目：
- en: '![Figure 1.1 – React project in CodeSandbox](img/B19051_01_01.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – CodeSandbox中的React项目](img/B19051_01_01.jpg)'
- en: Figure 1.1 – React project in CodeSandbox
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – CodeSandbox中的React项目
- en: 'There are three main panels in the CodeSandbox editor:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: CodeSandbox编辑器中有三个主要面板：
- en: 'The **Files** panel: This is usually on the left-hand side and contains all
    the files in the project.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件**面板：这通常在左侧，包含项目中的所有文件。'
- en: 'The **Code editor** panel: This is usually the middle panel, and it contains
    the code. This is where we will write our React component code. Clicking a file
    in the **Files** panel will open it in the code editor panel.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码编辑器**面板：这通常是中间面板，包含代码。这是我们编写React组件代码的地方。在**文件**面板中点击一个文件，它将在代码编辑器面板中打开。'
- en: 'The **Browser** panel: This displays a preview of the running app and is usually
    on the right-hand side.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浏览器**面板：这显示正在运行的应用的预览，通常在右侧。'
- en: Now that we have created a React project, we will take some time to understand
    the app’s entry point.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个 React 项目，我们将花一些时间来了解应用的入口点。
- en: Understanding the React entry point
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 React 入口点
- en: 'The entry point of this React app is in the `index.js` file. Open this file
    by clicking on it in the **Files** panel and inspect its contents:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 React 应用的入口点在 `index.js` 文件中。通过在 **文件** 面板中单击它来打开此文件并检查其内容：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There is quite a lot going on in this code. Here’s an explanation of each line
    of the code (don’t worry if you don’t fully understand it all at this point in
    the book, you will soon!):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中有很多内容。以下是每行代码的解释（如果你在本书的这一部分还没有完全理解，不要担心，你很快就会明白）：
- en: The first statement imports a `StrictMode` component from React. This means
    that the `StrictMode` component from the `react` library will be used later in
    the code in this file. We will cover import statements in detail in the next section.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一条语句从 React 中导入了一个 `StrictMode` 组件。这意味着在文件中的代码将使用来自 `react` 库的 `StrictMode`
    组件。我们将在下一节详细讲解导入语句。
- en: The second statement imports a `createRoot` function from React.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二条语句从 React 中导入了一个 `createRoot` 函数。
- en: The third import statement imports an `App` component from the `App.js` file
    in our project.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三条导入语句从我们项目的 `App.js` 文件中导入了一个 `App` 组件。
- en: A `rootElement` variable is then assigned to a DOM element with an `id` of `"root"`.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后将一个 `rootElement` 变量赋值给一个具有 `id` 为 `"root"` 的 DOM 元素。
- en: React’s `createRoot` function takes in a DOM element and returns a variable
    that can be used to display a React component tree. The `rootElement` variable
    is then passed into `createRoot`, and the result is assigned to a `root` variable.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 的 `createRoot` 函数接收一个 DOM 元素并返回一个变量，该变量可以用来显示 React 组件树。然后将 `rootElement`
    变量传递给 `createRoot`，并将结果赋值给 `root` 变量。
- en: The `render` function is called on the `root` variable, passing in JSX containing
    the `StrictMode` component with the `App` component nested inside. The `render`
    function displays the React components on the page. This process is often referred
    to as **rendering**.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `root` 变量上调用 `render` 函数，传递包含嵌套 `App` 组件的 `StrictMode` 组件的 JSX。`render` 函数在页面上显示
    React 组件。这个过程通常被称为 **渲染**。
- en: Note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `StrictMode` component will check the content inside it for potential problems
    and report them in the browser’s console. This is often referred to as React’s
    strict mode. The strict mode in React is different from the strict mode in JavaScript,
    but their purpose of eliminating bad code is the same.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`StrictMode` 组件将检查其内部的内容以查找潜在的问题，并在浏览器控制台中报告它们。这通常被称为 React 的严格模式。React 中的严格模式与
    JavaScript 中的严格模式不同，但它们消除坏代码的目的相同。'
- en: In summary, the code in `index.js` renders the `App` component in React’s strict
    mode in a DOM element with an `id` of `"root"`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`index.js` 中的代码在具有 `id` 为 `"root"` 的 DOM 元素中以 React 的严格模式渲染了 `App` 组件。
- en: Next, we will take some time to understand the React component tree and the
    `App` component that is referenced in `index.js`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将花一些时间来了解 React 组件树以及 `index.js` 中引用的 `App` 组件。
- en: Understanding the React component tree
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 React 组件树
- en: A React app is structured in a tree of components and DOM elements. The root
    component is the component at the top of the tree. In our CodeSandbox project,
    the root component is the `StrictMode` component.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 React 应用由组件和 DOM 元素的树状结构组成。树的根组件是树顶部的组件。在我们的 CodeSandbox 项目中，根组件是 `StrictMode`
    组件。
- en: React components can be nested inside another React component. The `App` component
    is nested inside the `StrictMode` component in the CodeSandbox project. This is
    a powerful way of putting components together because any component can be placed
    inside `StrictMode` – it doesn’t necessarily need to be `App`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: React 组件可以嵌套在另一个 React 组件内部。在 CodeSandbox 项目中，`App` 组件嵌套在 `StrictMode` 组件内部。这是一种强大的组件组合方式，因为任何组件都可以放在
    `StrictMode` 内部——它不一定是 `App`。
- en: 'React components can reference one or more other components, and even DOM elements,
    in their JSX. Open the `App.js` file and observe that it references DOM elements
    `div`, `h1`, and `h2`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: React 组件可以在它们的 JSX 中引用一个或多个其他组件，甚至 DOM 元素。打开 `App.js` 文件并观察它引用了 DOM 元素 `div`、`h1`
    和 `h2`：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The component tree in the CodeSandbox project is constructed as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: CodeSandbox 项目的组件树构建如下：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In summary, a React app is structured in a tree of React components and DOM
    elements.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，一个 React 应用由 React 组件和 DOM 元素的树状结构组成。
- en: Next, it is time to create a React component.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，是时候创建一个 React 组件了。
- en: Creating a basic alert component
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个基本的 alert 组件
- en: Now, we are going to create a component that displays an alert, which we will
    simply call `Alert`. It will consist of an icon, a heading, and a message.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个显示警告的组件，我们将其简单地称为`Alert`。它将包括一个图标、一个标题和一条消息。
- en: Important note
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'A React component name must start with a capital letter. If a component name
    starts with a lowercase letter, it is treated as a DOM element and won’t render
    properly. See the following link in the React documentation for more information:
    [https://reactjs.org/docs/jsx-in-depth.html#user-defined-components-must-be-capitalized](https://reactjs.org/docs/jsx-in-depth.html#user-defined-components-must-be-capitalized).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: React组件名称必须以大写字母开头。如果组件名称以小写字母开头，它将被视为DOM元素，并且无法正确渲染。有关更多信息，请参阅React文档中的以下链接：[https://reactjs.org/docs/jsx-in-depth.html#user-defined-components-must-be-capitalized](https://reactjs.org/docs/jsx-in-depth.html#user-defined-components-must-be-capitalized)。
- en: 'Carry out the following steps to create the component in the CodeSandbox project:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以在CodeSandbox项目中创建组件：
- en: In the `src` folder and choose **Create File** in the menu that appears.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹中，并在出现的菜单中选择**创建文件**。
- en: The cursor is placed in a new file, ready for you to enter the component filename.
    Enter `Alert.js` as the filename and press *Enter*.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 光标放置在一个新文件中，准备您输入组件文件名。将文件名输入为`Alert.js`并按*Enter*键。
- en: Note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The filename for component files isn’t important to React or the React transpiler.
    It is common practice to use the same name as the component, either in Pascal
    or snake case. However, the file extension must be `.js` or `.jsx` for React transpilers
    to recognize these as React components.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 组件文件的文件名对React或React转译器来说并不重要。通常的做法是将文件名与组件同名，无论是Pascal大小写还是snake大小写。然而，文件扩展名必须是`.js`或`.jsx`，以便React转译器能够识别这些为React组件。
- en: 'The `Alert.js` file automatically opens in the code editor panel. Enter the
    following code into this file:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Alert.js`文件将在代码编辑器面板中自动打开。将以下代码输入到该文件中：'
- en: '[PRE20]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Remember that the code snippets are available online to copy. The link to the
    preceding snippet can be found at [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter1/Section3-Creating-a-component/Alert.js](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter1/Section3-Creating-a-component/Alert.js).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，代码片段可在网上找到以供复制。上一个代码片段的链接可在[https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter1/Section3-Creating-a-component/Alert.js](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter1/Section3-Creating-a-component/Alert.js)找到。
- en: 'The component renders the following items:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件渲染以下项目：
- en: A warning icon (note that this is a warning emoji).
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个警告图标（请注意，这是一个警告表情符号）。
- en: A title, *Oh no!*.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标题，*哦不！*。
- en: A message, *Something isn’t quite* *right …*.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条消息，*有些地方不太对…*。
- en: Note
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `role` and `aria-label` attributes have been added to the `span` element
    containing the warning icons to help screen readers understand that this is an
    image with a title of warning.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`role`和`aria-label`属性已添加到包含警告图标的`span`元素中，以帮助屏幕阅读器理解这是一个具有警告标题的图像。'
- en: For more information on the `img` role, see [https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/img_role](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/img_role).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`img`角色的更多信息，请参阅[https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/img_role](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/img_role)。
- en: For more information on the `aria-label` attribute, see [https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-label](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-label).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`aria-label`属性的更多信息，请参阅[https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-label](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-label)。
- en: 'Alternatively, a React component can be implemented using arrow function syntax.
    The following code snippet is an arrow syntax version of the `Alert` component:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用箭头函数语法实现React组件。以下代码片段是`Alert`组件的箭头函数语法版本：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'There aren’t any significant differences between arrow functions and normal
    functions in the context of React function components. So, it is down to personal
    preference which one you choose. This book generally uses regular function syntax
    because it has fewer characters to type, however, if you wish, you can find more
    information on JavaScript arrow functions here: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在React函数组件的上下文中，箭头函数和普通函数之间没有显著的区别。所以，选择哪一个取决于个人喜好。本书通常使用常规函数语法，因为它需要输入更少的字符，然而，如果你愿意，你可以在以下链接中找到有关JavaScript箭头函数的更多信息：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)。
- en: 'Congratulations, you have created your first React component. Let’s quickly
    recap the key points in this section:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你已经创建了你的第一个React组件。让我们快速回顾本节的关键点：
- en: The entry point in a React app is usually `index.js`.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React应用中的入口点通常是 `index.js`。
- en: React’s `createRoot` function allows a React component tree to be rendered inside
    a DOM element.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React的 `createRoot` 函数允许React组件树在DOM元素内渲染。
- en: A React component is a JavaScript function whose name starts with a capital
    letter. The function returns what should be displayed using JSX syntax.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个React组件是一个以大写字母开头的JavaScript函数。该函数使用JSX语法返回应显示的内容。
- en: You may have noticed that the alert component doesn’t appear in the `import`
    and `export` statements.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到alert组件没有出现在 `import` 和 `export` 语句中。
- en: Understanding imports and exports
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解导入和导出
- en: '`import` and `export` statements allow JavaScript to be structured into modules.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`import` 和 `export` 语句允许JavaScript被结构化为模块。'
- en: This section will start by covering why JavaScript modules are important and
    then how to define and use them using `import` and `export` statements. We will
    then use that knowledge to add the alert component to the React component tree
    in the CodeSandbox project.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将首先介绍为什么JavaScript模块很重要，然后如何使用 `import` 和 `export` 语句定义和使用它们。然后我们将利用这些知识将alert组件添加到CodeSandbox项目的React组件树中。
- en: Understanding the importance of modules
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解模块的重要性
- en: By default, JavaScript code executes in what is called the **global scope**.
    This means code from one file is automatically available in another file. Unfortunately,
    this means that the functions we implement can overwrite functions in other files
    if the names are the same. You can imagine how this structure quickly becomes
    challenging and risky to maintain.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，JavaScript代码在所谓的**全局作用域**中执行。这意味着一个文件中的代码会自动在另一个文件中可用。不幸的是，这意味着我们实现的函数可能会覆盖其他文件中具有相同名称的函数。你可以想象这种结构很快就会变得具有挑战性和风险，难以维护。
- en: Thankfully, JavaScript has a modules feature. A module’s functions and variables
    are isolated, so functions with the same name in different modules won’t collide.
    This is a much safer way to structure code and is common practice when structuring
    React apps.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，JavaScript有一个模块功能。模块的函数和变量是隔离的，因此不同模块中具有相同名称的函数不会冲突。这是一种更安全的代码结构方式，并且在构建React应用时是一种常见的做法。
- en: Next, we will learn about how to define modules.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何定义模块。
- en: Using export statements
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用导出语句
- en: A module is a file with at least one `export` statement. An `export` statement
    references members that are available to other modules. Think of this as making
    members publically available. A member can be a function, a class, or a variable
    within the file. Members not contained within the `export` statement are private
    and not available outside the module.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是一个至少包含一个 `export` 语句的文件。`export` 语句引用了可供其他模块使用的成员。可以将此视为使成员公开可用。成员可以是文件中的函数、类或变量。未包含在
    `export` 语句中的成员是私有的，且在模块外部不可用。
- en: 'The following code statement is an example of a module with its `export` statement
    highlighted. This is called a **named export statement** because the public members
    are explicitly named:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码语句是一个带有其 `export` 语句高亮的模块示例。这被称为**命名导出语句**，因为公开成员被明确命名：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the example, the `myFunc1` and `myFunc3` functions are public, and `myFunc2`
    is private.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，`myFunc1` 和 `myFunc3` 函数是公开的，而 `myFunc2` 是私有的。
- en: 'Alternatively, the `export` keyword can be added before the `function` keyword
    on the public functions:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以在公共函数之前添加 `export` 关键字：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We will use the `export` keyword approach in this book because it is immediately
    apparent which function is public. With the single `export` statement at the bottom
    of the file, you have to keep going to the bottom of the file to find out whether
    a function is public.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将使用 `export` 关键字方法，因为这样可以立即清楚地知道哪个函数是公开的。在文件底部有一个单独的 `export` 语句，你必须继续滚动到文件底部才能找出一个函数是否是公开的。
- en: 'A `export` statement is defined at the bottom of the module:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`export` 语句定义在模块的底部：'
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `default` keyword signifies that the export is a default `export` statement.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`default` 关键字表示导出是一个默认 `export` 语句。'
- en: 'The second variant is where the `export` and `default` keywords are added in
    front of the member:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种变体是在成员前添加了 `export` 和 `default` 关键字：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This book will generally use named exports rather than default exports.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 本书通常使用命名导出而不是默认导出。
- en: Next, we will learn about `import` statements.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习关于 `import` 语句的内容。
- en: Using import statements
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 import 语句
- en: Using an `import` statement allows public members from a module to be used.
    Like an `export` statement, there are `import` statements. A default `import`
    statement can only be used to reference a default `export` statement.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `import` 语句允许使用模块的公共成员。与 `export` 语句一样，有 `import` 语句。默认 `import` 语句只能用于引用默认
    `export` 语句。
- en: 'Here is an example of a default `import` statement:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个默认 `import` 语句的例子：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The default exported member from the `myModule.js` file is imported and named
    `myFunc1`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `myModule.js` 文件中导入了默认导出成员，并命名为 `myFunc1`。
- en: Note
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The name of an imported default member doesn’t necessarily need to match the
    name of the default exported member, but it is common practice to do so.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 导入的默认成员的名称不一定需要与默认导出成员的名称匹配，但这样做是一种常见的做法。
- en: 'Here is an example of a named `import` statement:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个命名 `import` 语句的例子：
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, the `myFunc1` and `myFunc3` named exported members from the `myModule.js`
    file are imported.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，从 `myModule.js` 文件中导入了名为 `myFunc1` 和 `myFunc3` 的命名导出成员。
- en: Note
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike default imports, the names of imported members must match the exported
    members.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 与默认导入不同，导入成员的名称必须与导出成员的名称匹配。
- en: Now that we understand how to structure JavaScript code into modules, we will
    use this knowledge to add the alert component in the CodeSandbox project to the
    React component tree.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何将 JavaScript 代码结构化为模块，我们将使用这些知识将 alert 组件添加到 CodeSandbox 项目的 React
    组件树中。
- en: Adding Alert to the App component
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Alert 添加到 App 组件中
- en: 'Going back to the `Alert` component in our CodeSandbox project, we will reference
    `Alert` in the `App` component. To do this, carry out the following steps:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的 CodeSandbox 项目中的 `Alert` 组件，我们将在 `App` 组件中引用 `Alert`。为此，执行以下步骤：
- en: 'First, we need to export the `Alert` component. Open `Alert.js` and add the
    `export` keyword before the `Alert` function:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要导出 `Alert` 组件。打开 `Alert.js` 并在 `Alert` 函数之前添加 `export` 关键字：
- en: '[PRE38]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is common practice to have each React component in a separate file and, therefore,
    a separate module. This prevents files from becoming too large and helps the readability
    of the code base.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个 React 组件放在单独的文件中，并因此有一个单独的模块，这是一种常见的做法。这可以防止文件变得过大，并有助于代码库的可读性。
- en: 'Now we can import `Alert` into the `App.js` file. Open `App.js` and add the
    highlighted `import` statement at the top of the file:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以将 `Alert` 导入到 `App.js` 文件中。打开 `App.js` 并在文件顶部添加高亮的 `import` 语句：
- en: '[PRE41]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can now reference `Alert` in the `App` component’s JSX. Add the highlighted
    line inside the `div` element, replacing its existing content:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以在 `App` 组件的 JSX 中引用 `Alert`。在 `div` 元素内部添加高亮行，替换其现有内容：
- en: '[PRE46]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The component will display the following in the **Browser** panel:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件将在 **浏览器** 面板中显示以下内容：
- en: '![Figure 1.2 – The alert component in the Browser panel](img/B19051_01_02.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 浏览器面板中的 alert 组件](img/B19051_01_02.jpg)'
- en: Figure 1.2 – The alert component in the Browser panel
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 浏览器面板中的 alert 组件
- en: Nice! If you have noticed that the alert component isn’t styled nicely, don’t
    worry – we will learn how to style it in [*Chapter 4*](B19051_04.xhtml#_idTextAnchor100),
    *Approaches to Styling* *React Frontends*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！如果你注意到 alert 组件的样式并不美观，不要担心——我们将在 [*第 4 章*](B19051_04.xhtml#_idTextAnchor100)
    *React 前端样式方法* 中学习如何对其进行样式化。
- en: 'Here’s a recap of a couple of key points in this section:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对本节中几个关键点的回顾：
- en: React apps are structured using JavaScript modules to help the code base be
    maintainable.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 应用程序使用 JavaScript 模块结构化，以帮助代码库可维护。
- en: Generally, a React component is structured in its own module and so needs to
    be exported and imported before being referenced in another React component.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，一个 React 组件在其自己的模块中结构化，因此在使用之前需要导出和导入到另一个 React 组件中。
- en: Next, we will learn how to make the alert component a little more flexible.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何使警告组件更加灵活。
- en: Using props
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用属性
- en: Currently, the alert component is pretty inflexible. For example, the alert
    consumer can’t change the heading or the message. At the moment, the heading or
    the message needs to be changed within `Alert` itself. **Props** solve this problem,
    and we will learn about them in this section.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，警告组件相当不灵活。例如，警告消费者不能更改标题或消息。目前，标题或消息需要在 `Alert` 本身内进行更改。**属性** 解决了这个问题，我们将在本节中学习它们。
- en: Note
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Props is short for *properties*. The React community often refers to them as
    props, so we will do so in this book.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Props 是 *属性* 的缩写。React 社区通常将它们称为 props，因此我们将在本书中这样做。
- en: Understanding props
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解属性
- en: '`props` is an optional parameter that is passed into a React component. This
    parameter is an object containing the properties of our choice. The following
    code snippet shows a `props` parameter in a `ContactDetails` component:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`props` 是一个可选参数，它被传递到一个 React 组件中。该参数是一个包含我们选择的属性的对象。以下代码片段显示了 `ContactDetails`
    组件中的 `props` 参数：'
- en: '[PRE53]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `props` parameter contains the `name` and `email` properties in the preceding
    code snippet.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`props` 参数包含 `name` 和 `email` 属性。
- en: Note
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The parameter doesn’t have to be named `props`, but it is common practice.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 参数不必命名为 `props`，但这是常见的做法。
- en: 'Props are passed into a component in JSX as attributes. The prop names must
    match what is defined in the component. Here is an example of passing props into
    the preceding `ContactDetails` component:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 属性作为属性在 JSX 中传递给组件。属性名称必须与组件中定义的名称匹配。以下是一个将属性传递给前面的 `ContactDetails` 组件的示例：
- en: '[PRE54]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: So, props make the component output flexible. Consumers of the component can
    pass appropriate props into the component to get the desired output.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，属性使组件输出更加灵活。组件的消费者可以将适当的属性传递到组件中，以获得所需输出。
- en: Next, we will add some props to the alert component we have been working on.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向我们所工作的警告组件添加一些属性。
- en: Adding props to the alert component
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向警告组件添加属性
- en: 'In the CodeSandbox project, carry out the following steps to add props to the
    alert component to make it more flexible:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CodeSandbox 项目中，按照以下步骤向警告组件添加属性以使其更加灵活：
- en: 'Open `alert.js` and add a `props` parameter to the function:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `alert.js` 并向函数添加一个 `props` 参数：
- en: '[PRE55]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We will define the following properties for the alert:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为警告定义以下属性：
- en: '`type`: This will either be `"information"` or `"warning"` and will determine
    the icon in the alert.'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`: 这将是 `"information"` 或 `"warning"`，并确定警告中的图标。'
- en: '`heading`: This will determine the heading of the alert.'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`heading`: 这将确定警告的标题。'
- en: '`children`: This will determine the content of the alert. The `children` prop
    is actually a special prop used for the main content of components.'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`children`: 这将确定警告的内容。`children` 属性实际上是一个用于组件主要内容的特殊属性。'
- en: 'Update the alert component’s JSX to use the props as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 更新警告组件的 JSX 以使用属性如下：
- en: '[PRE58]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Notice that the `App` component isn’t passing any props to `Alert` yet:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `App` 组件还没有向 `Alert` 传递任何属性：
- en: '![Figure 1.3 – The alert component only showing the information icon](img/B19051_01_03.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 只显示信息图标的警告组件](img/B19051_01_03.jpg)'
- en: Figure 1.3 – The alert component only showing the information icon
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 只显示信息图标的警告组件
- en: 'Open `App.js` and update the `Alert` component in the JSX to pass in props
    as follows:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `App.js` 并更新 JSX 中的 `Alert` 组件，如下传递属性：
- en: '[PRE59]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Notice that the `Alert` component is no longer self-closing so that `Everything
    is really good!` can be passed into its content. The content is passed to the
    `children` prop.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `Alert` 组件不再自动关闭，因此可以将 `Everything is really good!` 传递到其内容中。内容是通过 `children`
    属性传递的。
- en: 'The **Browser** panel now displays the configured alert component:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**浏览器** 面板现在显示配置的警告组件：'
- en: '![Figure 1.4 – The configured alert component in the browser panel](img/B19051_01_04.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – 浏览器面板中配置的警告组件](img/B19051_01_04.jpg)'
- en: Figure 1.4 – The configured alert component in the browser panel
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 浏览器面板中配置的警告组件
- en: We can clean up the alert component code a little by destructuring the `props`
    parameter.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过解构 `props` 参数来稍微清理一下警告组件的代码。
- en: Note
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Destructuring is a JavaScript feature that allows properties to be unpacked
    from an object. For more information, see the following link: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment).'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 解构是JavaScript的一个特性，允许从对象中提取属性。更多信息，请参阅以下链接：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)。
- en: 'Open `Alert.js` again, destructure the `function` parameter, and use the unpacked
    props as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 再次打开`Alert.js`，解构`function`参数，并如下使用解包的props：
- en: '[PRE68]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This is a little cleaner because we use the unpacked props directly rather than
    having to reference them through the `props` parameter.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这更简洁，因为我们直接使用解包的props，而不是通过`props`参数引用它们。
- en: 'We want the `type` prop to default to `"information"`. Define this default
    as follows:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望`type`属性默认为`"information"`。如下定义此默认值：
- en: '[PRE69]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'That completes the implementation of the props in the alert component for now.
    Here’s a quick recap on props:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，警报组件的props实现已完成。以下是对props的快速回顾：
- en: Props allow a component to be configured by the consuming JSX and are passed
    as JSX attributes
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Props允许通过消费JSX来配置组件，并作为JSX属性传递。
- en: Props are received in the component definition in an object parameter and can
    then be used in its JSX
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Props作为对象参数在组件定义中接收，然后可以在其JSX中使用。
- en: Next, we will continue to make the alert component more sophisticated by allowing
    it to be closed by the user.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续改进警报组件，允许用户关闭它。
- en: Using state
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用状态
- en: The component **state** is a special variable containing information about the
    component’s current situation. For example, a component may be in a *loading*
    state or an *error* state.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 组件**状态**是一个特殊的变量，包含有关组件当前情况的信息。例如，组件可能处于*加载*状态或*错误*状态。
- en: In this section, we’ll learn about state and use it within our alert component
    in the CodeSandbox project. We will use state to allow the alert to be closed
    by the user.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习状态，并在CodeSandbox项目中使用它来构建我们的警报组件。我们将使用状态来允许用户关闭警报。
- en: Understanding state
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解状态
- en: There isn’t a predefined list of states; we define what’s appropriate for a
    given component. Some components won’t even need any state; for example, the `App`
    and `Alert` components in our CodeSandbox project haven’t required state for the
    requirements so far.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 没有预定义的状态列表；我们为特定组件定义适当的状态。有些组件甚至不需要任何状态；例如，在我们CodeSandbox项目中的`App`和`Alert`组件到目前为止还没有需要状态的要求。
- en: However, state is a key part of making a component interactive. When a user
    interacts with a component, the component’s output may need to change. For example,
    clicking on a component may need to make an element in the component invisible.
    A change to a component state causes the component to refresh, more often referred
    to as **re-rendering**. So, a user could click on a component causing a state
    change, resulting in an element in the component becoming invisible.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，状态是使组件交互的关键部分。当用户与组件交互时，组件的输出可能需要改变。例如，点击一个组件可能需要使组件中的某个元素不可见。组件状态的改变会导致组件刷新，这通常被称为**重新渲染**。因此，用户点击组件可能导致状态改变，从而使组件中的某个元素变得不可见。
- en: State is defined using a `useState` function from React. The `useState` function
    is one of React’s **hooks**. React hooks were introduced to React in version 16.8
    and give function components powerful capabilities such as state. There is a whole
    chapter on React hooks in [*Chapter 4*](B19051_04.xhtml#_idTextAnchor100), *Using*
    *React Hooks*.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 状态是通过React的`useState`函数定义的。`useState`函数是React的**钩子**之一。React钩子是在React的16.8版本中引入的，为函数组件提供了强大的功能，如状态。关于React钩子有一个专门的章节，即*第4章*，*使用React
    Hooks*。
- en: 'The syntax for `useState` is as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState`的语法如下：'
- en: '[PRE76]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Here are the key points:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是关键点：
- en: The initial state value is passed into `useState`. If no value is passed, it
    will initially be `undefined`.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始状态值传递给`useState`。如果没有传递值，它将初始化为`undefined`。
- en: '`useState` returns a tuple containing the current state value and a function
    to update the state value. The tuple is destructured in the preceding code snippet.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useState`返回一个包含当前状态值和更新状态值函数的元组。在先前的代码片段中，该元组被解构。'
- en: The state variable name is `state` in the preceding code snippet, but we can
    choose any meaningful name.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在先前的代码片段中，状态变量名为`state`，但我们可以选择任何有意义的名称。
- en: We can also choose the state setter function name, but it is common practice
    to use the same name as the state variable preceded by `set`.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以选择状态设置函数的名称，但通常的做法是使用与状态变量相同的名称，并在其前面加上`set`。
- en: 'Multiple states can be defined by defining multiple instances of `useState`.
    For example, here are definitions for loading and error states:'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过定义多个`useState`实例来定义多个状态。例如，以下是加载和错误状态的定义：
- en: '[PRE77]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Next, we will implement state in the alert component to determine whether it
    is visible or not.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在警报组件中实现状态以确定其是否可见。
- en: Implementing a visible state in the alert component
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在警报组件中实现可见状态
- en: We will begin by implementing a feature in the alert component that allows the
    user to close it. A key part of that feature is controlling the alert’s visibility,
    which we will do with a `visible` state. This state will either be `true` or `false`
    and it will initially be set to `true`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在警报组件中实现一个功能，允许用户关闭它。该功能的关键部分是控制警报的可见性，我们将使用`visible`状态来实现。此状态将是`true`或`false`，并且最初将其设置为`true`。
- en: 'Follow these steps to implement a `visible` state in `Alert`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在`Alert`中实现`visible`状态：
- en: Open `Alert.js` in the CodeSandbox project.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在CodeSandbox项目中打开`Alert.js`。
- en: 'Add the following `import` statement at the top of the file to import the `useState`
    hook from React:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件顶部添加以下`import`语句以从React导入`useState`钩子：
- en: '[PRE79]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Define the `visible` state as follows in the component definition:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件定义中如下定义`visible`状态：
- en: '[PRE80]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'After the state declaration, add a condition that returns `null` if the `visible`
    state is `false`. This means nothing will be rendered:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在状态声明之后，添加一个条件，如果`visible`状态为`false`，则返回`null`。这意味着将不会渲染任何内容：
- en: '[PRE86]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The component will render in the `visible` state is `true`. Try changing the
    initial state value to `false`, and you will see it disappear in the **Browser**
    panel.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当`visible`状态为`true`时，组件将进行渲染。尝试将初始状态值更改为`false`，你将在**浏览器**面板中看到它消失。
- en: Currently, the alert component is making use of the `visible` state’s value
    by not rendering anything if it is `false`. However, the component isn’t updating
    the `visible` state yet – that is, `setVisible` is unused at the moment. We will
    update the `visible` state after implementing a `close` button, which we will
    do next.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，警报组件正在使用`visible`状态的值，如果它是`false`，则不渲染任何内容。然而，组件尚未更新`visible`状态——也就是说，`setVisible`目前未使用。我们将在实现关闭按钮后更新`visible`状态，我们将在下一部分实现。
- en: Adding a close button to Alert
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向警报中添加关闭按钮
- en: We will add a close button to the alert component to allow the user to close
    it. We will make this configurable so that the alert consumer can choose whether
    the close button is rendered.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在警报组件中添加一个关闭按钮，允许用户关闭它。我们将使其可配置，以便警报消费者可以选择是否渲染关闭按钮。
- en: 'Carry out the following steps:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Start by opening `Alert.js` and add a `closable` prop:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先打开`Alert.js`并添加一个`closable`属性：
- en: '[PRE95]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The consumer of the alert component will use the `closable` prop to specify
    whether the close button appears.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 警报组件的消费者将使用`closable`属性来指定是否显示关闭按钮。
- en: 'Add a close button between the heading and content as follows:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式在标题和内容之间添加一个关闭按钮：
- en: '[PRE103]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Notice that the `span` element that contains the close icon is given an `"img"`
    role and a `"Close"` label to help screen readers. Likewise, the button is also
    given a `"Close"` label to help screen readers.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，包含关闭图标的`span`元素被赋予了`"img"`角色和`"Close"`标签，以帮助屏幕阅读器。同样，按钮也被赋予了`"Close"`标签以帮助屏幕阅读器。
- en: 'The `close` button appears in the alert component as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭按钮在警报组件中的显示方式如下：
- en: '![Figure 1.5 – The close button in the alert component](img/B19051_01_05.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5 – 警报组件中的关闭按钮](img/B19051_01_05.jpg)'
- en: Figure 1.5 – The close button in the alert component
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – 警报组件中的关闭按钮
- en: 'At the moment, the close button will always render rather than just when the
    `closable` prop is `true`. We can use a JavaScript logical `AND` short circuit
    expression (represented by the `&&` characters) to render the `close` button conditionally.
    To do this, make the following highlighted changes:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，关闭按钮总是渲染，而不仅仅是当`closable`属性为`true`时。我们可以使用JavaScript逻辑短路表达式（由`&&`字符表示）有条件地渲染`close`按钮。为此，进行以下突出显示的更改：
- en: '[PRE118]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: If `closable` is a `closable` is **truthy**, the button will be rendered.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`closable`是**真值**，则按钮将被渲染。
- en: Note
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'See the following link for more information about logical `AND` short-circuit
    expressions: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND).'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 有关逻辑`AND`短路表达式的更多信息，请参阅以下链接：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND)。
- en: See the following link for JavaScript’s falsy values, [https://developer.mozilla.org/en-US/docs/Glossary/Falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy),
    and [https://developer.mozilla.org/en-US/docs/Glossary/Truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy)
    for truthy values.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 有关JavaScript的假值，请参阅以下链接：[https://developer.mozilla.org/en-US/docs/Glossary/Falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy)，有关真值，请参阅以下链接：[https://developer.mozilla.org/en-US/docs/Glossary/Truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy)。
- en: 'Open `App.js` and pass the `closable` prop into `Alert`:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`App.js`并将`closable`属性传递给`Alert`：
- en: '[PRE138]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Notice that a value hasn’t been explicitly defined on the `closable` attribute.
    We could have passed the value as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`closable`属性上没有明确定义值。我们可以按照以下方式传递值：
- en: '[PRE147]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: However, there is no need to pass the value on a boolean attribute. If the boolean
    attribute is present on an element, its value is automatically `true`.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有必要在布尔属性上传递值。如果一个元素上存在布尔属性，其值将自动为`true`。
- en: 'When the `closable` attribute is specified, the `close` button appears in the
    alert component as it did before in *Figure 1**.5*. But when the `closable` attribute
    isn’t specified, the close button doesn’t appear:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定了`closable`属性时，关闭按钮在警告组件中显示，就像在*图1**.5*中之前那样。但是当没有指定`closable`属性时，关闭按钮不会显示：
- en: '![Figure 1.6 – The close button not in the alert component when closable is
    not specified](img/B19051_01_06.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6 – 当未指定closable时，关闭按钮不在警告组件中](img/B19051_01_06.jpg)'
- en: Figure 1.6 – The close button not in the alert component when closable is not
    specified
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – 当未指定closable时，关闭按钮不在警告组件中
- en: Excellent!
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀！
- en: 'A quick recap of what we have learned so far about React state:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们迄今为止关于React状态的了解进行快速回顾：
- en: State is defined using React’s `useState` hook
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React的`useState`钩子定义状态
- en: The initial value of the state can be passed into the `useState` hook
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态的初始值可以通过`useState`钩子传递
- en: '`useState` returns a state variable that can be used to render elements conditionally'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useState`返回一个状态变量，可以用来有条件地渲染元素'
- en: '`useState` also returns a function that can be used to update the value of
    the state'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useState`还返回一个函数，可以用来更新状态的值'
- en: You may have noticed that the `close` button doesn’t actually close the alert.
    In the next section, we will rectify this as we learn about events in React.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，关闭按钮实际上并没有关闭警告。在下一节中，我们将通过学习React中的事件来纠正这一点。
- en: Using events
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件
- en: '**Events** are another key part of allowing a component to be interactive.
    In this section, we will understand what React events are and how to use events
    on DOM elements. We will also learn how to create our own React events.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件**是允许组件具有交互性的另一个关键部分。在本节中，我们将了解React事件是什么以及如何在DOM元素上使用事件。我们还将学习如何创建我们自己的React事件。'
- en: We will continue to expand the alert component’s functionality as we learn about
    events. We will start by finishing the close button implementation before creating
    an event for when the alert has been closed.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们学习事件，我们将继续扩展警告组件的功能。我们将先完成关闭按钮的实现，然后再创建一个当警告被关闭时的事件。
- en: Understanding events
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解事件
- en: Browser events happen as the user interacts with DOM elements. For example,
    clicking a button raises a `click` event from that button.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器事件发生在用户与DOM元素交互时。例如，点击按钮会从该按钮引发一个`click`事件。
- en: Logic can be executed when an event is raised. For example, an alert can be
    closed when its close button is clicked. A function called an **event handler**
    (sometimes referred to as an **event listener**) can be registered for an element
    event that contains the logic to execute when that event happens.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件被引发时，可以执行逻辑。例如，当关闭按钮被点击时，警告可以关闭。可以注册一个名为**事件处理器**（有时称为**事件监听器**）的函数，用于包含在元素事件中，当该事件发生时执行逻辑。
- en: Note
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'See the following link for more information on browser events: [https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events).'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 有关浏览器事件的更多信息，请参阅以下链接：[https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events)。
- en: Events in React events are very similar to browser native events. In fact, React
    events are a wrapper on top of the browser’s native events.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: React中的事件与浏览器原生事件非常相似。事实上，React事件是浏览器原生事件的一个包装器。
- en: 'Event handlers in React are generally registered to an element in JSX using
    an attribute. The following code snippet registers a `click` event handler called
    `handleClick` on a `button` element:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: React中的事件处理程序通常使用属性在JSX中注册到元素上。以下代码片段在`button`元素上注册了一个名为`handleClick`的`click`事件处理程序：
- en: '[PRE148]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Next, we will return to our alert component and implement a `click` handler
    on the close button that closes the alert.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回到我们的警告组件，并在关闭按钮上实现一个`click`处理程序来关闭警告。
- en: Implementing a close button click handler in the alert
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在警告中实现关闭按钮点击处理程序
- en: 'At the moment, our alert component contains a close button, but nothing happens
    when it is clicked. The alert also contains a `visible` state that dictates whether
    the alert is shown. So, to finish the close button implementation, we need to
    add an event handler when it is clicked that sets the `visible` state to `false`.
    Carry out the following steps to do this:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的警告组件包含一个关闭按钮，但点击时没有任何反应。警告还包含一个`visible`状态，它决定了警告是否显示。因此，为了完成关闭按钮的实现，我们需要在点击时添加一个事件处理程序来将`visible`状态设置为`false`。执行以下步骤来完成此操作：
- en: 'Open `Alert.js` and register a `click` handler on the close button as follows:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Alert.js`并在关闭按钮上注册一个如下所示的`click`处理程序：
- en: '[PRE149]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: We have registered a `click` handler called `handleCloseClick` on the close
    button.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在关闭按钮上注册了一个名为`handleCloseClick`的`click`处理程序。
- en: 'We then need to implement the `handleCloseClick` function in the component.
    Create an empty function to start with, just above the `return` statement:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要在组件中实现`handleCloseClick`函数。从创建一个位于`return`语句之上的空函数开始：
- en: '[PRE150]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: This may seem a little strange because we have put the `handleCloseClick` function
    inside another function, `Alert`. The handler needs to be inside the `Alert` function;
    otherwise, the alert component won’t have access to it.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有点奇怪，因为我们已经将`handleCloseClick`函数放在了另一个函数`Alert`内部。处理程序需要放在`Alert`函数内部；否则，警告组件将无法访问它。
- en: 'Arrow function syntax can be used for event handlers if preferred. An arrow
    function version of the handler is as follows:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果喜欢，可以使用箭头函数语法来编写事件处理程序。处理程序的箭头函数版本如下：
- en: '[PRE160]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Event handlers can also be added directly to the element in JSX as follows:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理程序也可以直接在JSX元素上添加，如下所示：
- en: '[PRE161]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: In the alert component, we will stick to the named `handleCloseClick` event
    handler function.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在警告组件中，我们将坚持使用命名的`handleCloseClick`事件处理程序函数。
- en: 'Now we can use the `visible` state setter function to make the `visible` state
    `false` in the event handler:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用`visible`状态设置函数在事件处理程序中将`visible`状态设置为`false`：
- en: '[PRE162]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: If you click the close button in the **Browser** panel, the alert disappears.
    Nice!
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击**浏览器**面板中的关闭按钮，警告就会消失。太棒了！
- en: 'The refresh icon can be clicked to make the component reappear in the **Browser**
    panel:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新图标可以被点击，使组件在**浏览器**面板中重新出现：
- en: '![Figure 1.7 – The Browser panel refresh option](img/B19051_01_07.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7 – 浏览器面板刷新选项](img/B19051_01_07.jpg)'
- en: Figure 1.7 – The Browser panel refresh option
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 浏览器面板刷新选项
- en: Next, we will extend the close button to raise an event when the alert closes.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将扩展关闭按钮，以便在警告关闭时触发一个事件。
- en: Implementing an alert close event
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现警告关闭事件
- en: We will now create a custom event in the alert component. The event will be
    raised when the alert is closed so that consumers can execute logic when this
    happens.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在警告组件中创建一个自定义事件。当警告关闭时，将触发此事件，以便消费者可以在发生这种情况时执行逻辑。
- en: A custom event in a component is implemented by implementing a prop. The prop
    is a function that is called to raise the event.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 组件中的自定义事件是通过实现一个属性来实现的。这个属性是一个在触发事件时被调用的函数。
- en: 'To implement an alert close event, follow these steps:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个关闭警告事件，请按照以下步骤操作：
- en: 'Start by opening `Alert.js` and add a prop for the event:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先打开`Alert.js`并为事件添加一个属性：
- en: '[PRE165]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: We have called the prop `onClose`.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将属性命名为`onClose`。
- en: Note
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is common practice to start an event prop name with `on`.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，事件属性的名称以`on`开头。
- en: 'In the `handleCloseClick` event handler, raise the close event after the `visible`
    state is set to `false`:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`handleCloseClick`事件处理程序中，在将`visible`状态设置为`false`之后触发关闭事件：
- en: '[PRE172]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Notice that we only invoke `onClose` if it is defined and passed as a prop by
    the consumer. This means that we aren’t forcing the consumer to handle this event.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只有在`onClose`被定义并且由消费者作为属性传递时才调用它。这意味着我们并没有强迫消费者处理这个事件。
- en: 'We can now handle when an alert is closed in the `App` component. Open `App.js`
    and add the following event handler to `Alert` in the JSX:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以在 `App` 组件中处理 alert 被关闭的情况。打开 `App.js` 并在 JSX 中的 `Alert` 上添加以下事件处理器：
- en: '[PRE178]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: We have used an inline event handler this time.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这次使用了内联事件处理器。
- en: 'In the **Browser** panel, if you click the close button and look at the console,
    you will see that **closed** has been output:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **浏览器** 面板中，如果你点击关闭按钮并查看控制台，你会看到输出了 **closed**：
- en: '![Figure 1.8 – The Browser panel closed console output](img/B19051_01_08.jpg)'
  id: totrans-483
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.8 – 浏览器面板关闭控制台输出](img/B19051_01_08.jpg)'
- en: Figure 1.8 – The Browser panel closed console output
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – 浏览器面板关闭控制台输出
- en: That completes the close event and the implementation of the alert for this
    chapter.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了关闭事件和本章 alert 的实现。
- en: 'Here’s what we have learned about React events:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于 React 事件我们所学到的：
- en: Events, along with state, allow a component to be interactive
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件，连同状态，使组件具有交互性
- en: Event handlers are functions that are registered on elements in JSX
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件处理器是在 JSX 元素上注册的函数
- en: A custom event can be created by implementing a function prop and invoking it
    to raise the event
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实现一个函数属性并调用它来引发事件，可以创建一个自定义事件
- en: 'The component we created in this chapter is a function component. You can also
    create components using classes. For example, a class component version of the
    alert component is at [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter1/Class-component/Alert.js](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter1/Class-component/Alert.js).
    However, function components are dominant in the React community because of the
    following reasons:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们创建的组件是一个函数组件。你还可以使用类来创建组件。例如，alert 组件的类组件版本在 [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter1/Class-component/Alert.js](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter1/Class-component/Alert.js)。然而，由于以下原因，函数组件在
    React 社区中占主导地位：
- en: Generally, they require less code to implement
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，它们需要更少的代码来实现
- en: Logic inside the component can be more easily reused
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件内的逻辑可以更容易地重用
- en: The implementation is very different
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现方式非常不同
- en: For these reasons, we will focus solely on function components in this book.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，我们将专注于本书中的函数组件。
- en: Next, we will summarize what we have learned in this chapter.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将总结本章所学的内容。
- en: Summary
  id: totrans-496
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We now understand that React is a popular library for creating component-based
    frontends. In this chapter, we created an alert component using React.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在明白 React 是一个流行的库，用于创建基于组件的前端。在本章中，我们使用 React 创建了一个 alert 组件。
- en: Component output is declared using a mix of HTML and JavaScript called JSX.
    JSX needs to be transpiled into JavaScript before it can be executed in a browser.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 组件输出使用 HTML 和 JavaScript 的混合体 JSX 声明。JSX 需要被转换为 JavaScript 才能在浏览器中执行。
- en: Props can be passed into a component as JSX attributes. This allows consumers
    of the component to control its output and behavior. A component receives props
    as an object parameter. The JSX attribute names form the object parameter property
    names. We implemented a range of props in this chapter in the alert component.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将属性作为 JSX 属性传递给组件。这允许组件的消费者控制其输出和行为。组件接收属性作为一个对象参数。JSX 属性名称形成对象参数属性名称。我们在本章的
    alert 组件中实现了一系列属性。
- en: Events can be handled to execute logic when the user interacts with the component.
    We created an event handler for the close button click event in the alert component.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 事件可以被处理，以便在用户与组件交互时执行逻辑。我们在 alert 组件中创建了一个关闭按钮点击事件的处理器。
- en: State can be used to re-render a component and update its output. State is defined
    using the `useState` hook. State is often updated in event handlers. We have created
    state for whether the alert is visible.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `useState` 钩子来定义状态，以重新渲染组件并更新其输出。状态通常在事件处理器中更新。我们为 alert 是否可见创建了状态。
- en: Custom events can be implemented as a function prop. This allows consumers of
    the component to execute logic as the user interacts with it. We implemented a
    close event on the alert component.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过实现一个函数属性来创建自定义事件。这允许组件的消费者在用户与其交互时执行逻辑。我们在 alert 组件上实现了一个关闭事件。
- en: In the next chapter, we will introduce ourselves to TypeScript.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将介绍 TypeScript。
- en: Questions
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to reinforce what you have learned in this chapter:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以巩固你在本章中学到的内容：
- en: What is wrong with the following component definition?
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下组件定义有什么问题？
- en: '[PRE186]'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'A component with a prop is defined as follows:'
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 带有属性的组件如下定义：
- en: '[PRE189]'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: The value of the prop isn’t output though. What is the problem?
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管属性值没有输出。问题是什么？
- en: 'Component props are passed into a component as follows:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组件属性如下传递给组件：
- en: '[PRE192]'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'The component is then defined as follows:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将组件定义为以下内容：
- en: '[PRE193]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: The name `Fred` isn’t output though. What is the problem?
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管没有输出名字`Fred`。问题是什么？
- en: 'What is wrong with how the `click` event is handled in the following JSX:'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下JSX中处理`click`事件的方式有什么问题？
- en: '[PRE194]'
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: What is the initial value of the `loading` state defined here?
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里定义的`loading`状态的初始值是什么？
- en: '[PRE197]'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: What is wrong with how the state is set in the following component?
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下组件中设置状态的方式有什么问题？
- en: '[PRE198]'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: The following component implements an optional `Agree` event. What is wrong
    with this implementation?
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下组件实现了一个可选的`Agree`事件。这个实现有什么问题？
- en: '[PRE206]'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: Answers
  id: totrans-546
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are the answers to the questions on what you have learned in this chapter:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是关于你在本章中学到的内容的问答：
- en: 'The problem with the component definition is that its name is lowercase. React
    functions must be named with an uppercase first character:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组件定义的问题在于其名称是小写的。React函数必须以大写字母开头命名：
- en: '[PRE216]'
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'The problem is that the `name` variable inside the `div` element isn’t enclosed
    in curly brackets. So, the word `name` will be output rather than the value of
    the `name` prop. Here’s the corrected version of the component:'
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 问题在于`div`元素内部的`name`变量没有被大括号括起来。所以，将输出单词`name`而不是`name`属性的值。以下是组件的修正版本：
- en: '[PRE219]'
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'The problem is that a `name` prop is passed rather than `firstName`. Here’s
    the corrected JSX:'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 问题在于传递了一个`name`属性而不是`firstName`。以下是修正后的JSX：
- en: '[PRE222]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'The problem is that a `click` prop is passed rather than `onClick`. Here’s
    the corrected JSX:'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 问题在于传递了一个`click`属性而不是`onClick`。以下是修正后的JSX：
- en: '[PRE223]'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE225]'
- en: The initial value of the `loading` state is `true`.
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`loading`状态初始值是`true`。'
- en: 'The state isn’t updated using the state setter function. Here’s the corrected
    version of the state being set:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态没有使用状态设置函数进行更新。以下是设置状态的修正版本：
- en: '[PRE226]'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'The problem is that clicking the button will cause an error if `onAgree` isn’t
    passed because it will be `undefined`. Here’s the corrected version of the component:'
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 问题在于如果`onAgree`没有被传递，点击按钮将导致错误，因为它将是`undefined`。以下是组件的修正版本：
- en: '[PRE234]'
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-575
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-577
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-578
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-579
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-581
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE245]'
