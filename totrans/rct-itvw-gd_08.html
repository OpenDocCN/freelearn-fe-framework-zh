<html><head></head><body>
<div id="_idContainer042">
<h1 class="chapter-number" id="_idParaDest-258"><a id="_idTextAnchor257"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-259"><a id="_idTextAnchor258"/><span class="koboSpan" id="kobo.2.1">Testing and Debugging the React Application</span></h1>
<p><span class="koboSpan" id="kobo.3.1">React has become the most popular frontend library in the field of web development, enabling programmers to build effective, scalable, and maintainable apps. </span><span class="koboSpan" id="kobo.3.2">To ensure the stability and dependability of your application, comprehensive testing and efficient debugging have become increasingly crucial as projects become larger and more complicated. </span><span class="koboSpan" id="kobo.3.3">This chapter provides a thorough examination of the tools and methods required to master testing and debugging React apps, laying the groundwork for you to build on as you hone </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">your abilities.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">We’ll start by talking about React testing helpers, which facilitate testing and boost productivity. </span><span class="koboSpan" id="kobo.5.2">Then, we will review the most well-liked and adaptable testing tools accessible right now for the JavaScript and React ecosystem, including Enzyme, Jest, and </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">React Testing Library</span></strong><span class="koboSpan" id="kobo.7.1">. </span><span class="koboSpan" id="kobo.7.2">By doing this, you will be able to choose the appropriate tools for your unique needs and requirements. </span><span class="koboSpan" id="kobo.7.3">The setup and takedown phases of the testing life cycle will then be covered </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">in detail.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">We have devoted a section to discussing the best practices for addressing data fetching and mocking issues inside our tests because they are essential components for applications. </span><span class="koboSpan" id="kobo.9.2">We will dive into the details of testing user events, controlling timers, and modeling real-world interactions, giving you the necessary tools to confirm the responsiveness and performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">Finally, we’ll present React DevTools, a vital tool for troubleshooting and evaluating your </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">React apps.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">By the end of this chapter, you will be equipped with the knowledge, abilities, and self-assurance necessary to successfully test and debug your React apps. </span><span class="koboSpan" id="kobo.13.2">You will be well equipped to build applications that are both dependable and robust in the face of constantly changing circumstances if you have a firm grasp of the tools and approaches at your disposal. </span><span class="koboSpan" id="kobo.13.3">So, let’s start on the path to becoming experts in testing and debugging React apps so that your projects can withstand the test </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">of time.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">In this chapter, we are going to take a deep dive into the subject of testing and debugging from a software point of view as we learn the fundamentals, ideology, and concepts for testing our React applications. </span><span class="koboSpan" id="kobo.15.2">The following topics will </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">be covered:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.17.1">Introducing React </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">testing helpers</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Testing </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">our software</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Managing data in </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">our applications</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Code execution using events </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">and timers</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Using React DevTools for debugging </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">and analysis</span></span></li>
</ul>
<h1 id="_idParaDest-260"><a id="_idTextAnchor259"/><span class="koboSpan" id="kobo.27.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.28.1">You can find the projects and code of this chapter, </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">here: </span></span><a href="https://github.com/PacktPublishing/React-Interview-Guide/tree/main/Chapter08"><span class="No-Break"><span class="koboSpan" id="kobo.30.1">https://github.com/PacktPublishing/React-Interview-Guide/tree/main/Chapter08</span></span></a></p>
<h1 id="_idParaDest-261"><a id="_idTextAnchor260"/><span class="koboSpan" id="kobo.31.1">Introducing React testing helpers</span></h1>
<p><span class="koboSpan" id="kobo.32.1">In this section, we are going to learn about the fundamentals of RTL. </span><span class="koboSpan" id="kobo.32.2">But first, let’s try </span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.33.1">to understand what testing means when it comes to programming so that we can learn about the core concepts </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">and methodology.</span></span></p>
<h2 id="_idParaDest-262"><a id="_idTextAnchor261"/><span class="koboSpan" id="kobo.35.1">What is testing in software development?</span></h2>
<p><span class="koboSpan" id="kobo.36.1">Reviewing </span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.37.1">a software program or </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.38.1">system to verify it satisfies its functional and non-functional criteria and certifying its overall quality, performance, and dependability is known as testing in software development. </span><span class="koboSpan" id="kobo.38.2">It comprises running the program under controlled settings to find mistakes, flaws, or possible problems before the product is delivered to end customers. </span><span class="koboSpan" id="kobo.38.3">Testing is usually done at many levels, from the individual component level to the completely integrated system, and it is a critical part of the software development </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">life cycle.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">Depending on the project, there could be any number of testing phases. </span><span class="koboSpan" id="kobo.40.2">Let’s see what some </span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.41.1">of these </span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.42.1">testing-level </span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.43.1">phases could </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">look like:</span></span></p>
<table class="T---Table _idGenTablePara-1" id="table001-5">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="T---Table">
<td class="T---Table T---Body T---Header">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.45.1">Testing phase</span></strong></span></p>
</td>
<td class="T---Table T---Body T---Header">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.46.1">Description</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><span class="koboSpan" id="kobo.47.1">Unit tests</span></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p><span class="koboSpan" id="kobo.48.1">Testing isolated code or its parts is known as unit testing. </span><span class="koboSpan" id="kobo.48.2">It guarantees that every unit operates according to its specifications and acts </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">as intended.</span></span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><span class="koboSpan" id="kobo.50.1">Integration tests</span></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p><span class="koboSpan" id="kobo.51.1">Testing the integration and relationships among various software units, modules, or components is known as integration testing. </span><span class="koboSpan" id="kobo.51.2">It guarantees that the components talk effectively with one another and that the combined system functions as </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">a whole.</span></span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><span class="koboSpan" id="kobo.53.1">Regression tests</span></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p><span class="koboSpan" id="kobo.54.1">Regression testing is done to make sure that new code modifications or improvements don’t negatively impact already-existing functionality. </span><span class="koboSpan" id="kobo.54.2">It entails re-running earlier tests following </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">software modifications.</span></span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><span class="koboSpan" id="kobo.56.1">Security tests</span></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p><span class="koboSpan" id="kobo.57.1">The product’s security features and weaknesses are evaluated during security testing. </span><span class="koboSpan" id="kobo.57.2">It pinpoints possible security concerns such as data leaks, unauthorized access, and </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">coding flaws.</span></span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><span class="koboSpan" id="kobo.59.1">Functional tests</span></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p><span class="koboSpan" id="kobo.60.1">Software functioning is compared to the stated requirements through functional testing. </span><span class="koboSpan" id="kobo.60.2">It comprises testing numerous features, use cases, and situations to evaluate the program from the viewpoint of the </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">end user.</span></span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="koboSpan" id="kobo.62.1">Alpha and </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">beta tests</span></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p><span class="koboSpan" id="kobo.64.1">Before distributing the program to a select group of external users, internal testers do alpha testing in a restricted environment. </span><span class="koboSpan" id="kobo.64.2">Beta testing involves making the program available to a wider number of outside users to obtain input from actual users and spot any </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">possible problems.</span></span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><span class="koboSpan" id="kobo.66.1">Performance tests</span></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p><span class="koboSpan" id="kobo.67.1">The software’s adaptability, rapidity, ability to scale, and stability under various load levels are assessed during performance testing. </span><span class="koboSpan" id="kobo.67.2">This involves testing variables such as the speed of response, resource use, and constraints in </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">the system.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.69.1">Table 8.1: Software development testing phases</span></p>
<p><span class="koboSpan" id="kobo.70.1">As you can see, there are many different types of testing that we can perform during a project’s life cycle. </span><span class="koboSpan" id="kobo.70.2">Next, let’s learn how we can do testing in </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">React applications.</span></span></p>
<h2 id="_idParaDest-263"><a id="_idTextAnchor262"/><span class="koboSpan" id="kobo.72.1">How do we do testing in React applications?</span></h2>
<p><span class="koboSpan" id="kobo.73.1">In React, testing is the method of confirming and validating each component and the entire application </span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.74.1">to make sure they work as intended and adhere to the set criteria. </span><span class="koboSpan" id="kobo.74.2">This often involves testing each individual React component, user interactions, and any potential changes to the application state. </span><span class="koboSpan" id="kobo.74.3">There are a few ways that </span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.75.1">we can do testing in React applications and these are typically unit testing, integration testing, and </span><strong class="bold"><span class="koboSpan" id="kobo.76.1">end-to-end</span></strong><span class="koboSpan" id="kobo.77.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.78.1">E2E</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">) testing.</span></span></p>
<h2 id="_idParaDest-264"><a id="_idTextAnchor263"/><span class="koboSpan" id="kobo.80.1">How do you set up a test environment for a React application?</span></h2>
<p><span class="koboSpan" id="kobo.81.1">For your React application to be reliable, maintainable, and of the highest quality possible, you must set up a testing environment. </span><span class="koboSpan" id="kobo.81.2">You can perform tests in a controlled, isolated setting </span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.82.1">that closely mirrors the production environment if your test environment is set up correctly. </span><span class="koboSpan" id="kobo.82.2">This aids in locating and resolving possible problems before they impact end customers. </span><span class="koboSpan" id="kobo.82.3">All test environments </span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.83.1">require us developers to write tests for them, which is known as </span><strong class="bold"><span class="koboSpan" id="kobo.84.1">test-driven </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.85.1">development</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.86.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.87.1">TDD</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">The following figure describes the TDD cycle in a software development workflow. </span><span class="koboSpan" id="kobo.89.2">Coding, testing, and design are closely knitted together in this programming approach. </span><span class="koboSpan" id="kobo.89.3">There are many variations of this; however, the fundamental principle remains </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">the same:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer039">
<span class="koboSpan" id="kobo.91.1"><img alt=" Figure 8.1: The TDD cycle in software development" src="image/Figure_08.01_B18603.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.92.1"> Figure 8.1: The TDD cycle in software development</span></p>
<p><span class="koboSpan" id="kobo.93.1">Now that </span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.94.1">we have learned about the TDD cycle in software development, let’s move on to testing frameworks/libraries to see how we can best use them in </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">our apps.</span></span></p>
<h2 id="_idParaDest-265"><a id="_idTextAnchor264"/><span class="koboSpan" id="kobo.96.1">How do you choose a testing framework or library?</span></h2>
<p><span class="koboSpan" id="kobo.97.1">When building a React application, it’s a good idea to consider a good testing library. </span><span class="koboSpan" id="kobo.97.2">Having a </span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.98.1">good testing structure means that </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.99.1">our software should operate as expected and live up to the user’s expectations. </span><span class="koboSpan" id="kobo.99.2">So, let’s take a look at some of the popular testing libraries available </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">right now:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.101.1">React Testing Library</span></strong><span class="koboSpan" id="kobo.102.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.103.1">RTL</span></strong><span class="koboSpan" id="kobo.104.1">): The lightweight RTL focuses on testing the functionality </span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.105.1">of your components. </span><span class="koboSpan" id="kobo.105.2">Compared to other testing frameworks, it offers a more </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">straightforward API.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.107.1">Jest</span></strong><span class="koboSpan" id="kobo.108.1">: The popular </span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.109.1">testing framework Jest is already set up to operate with React. </span><span class="koboSpan" id="kobo.109.2">It has built-in capabilities for testing React apps, such as mocking and </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">snapshot testing.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.111.1">Enzyme</span></strong><span class="koboSpan" id="kobo.112.1">: Shallow rendering, complete DOM rendering, and snapshot testing are just a few </span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.113.1">of the testing tools offered for React by the potent testing </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">framework Enzyme.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.115.1">Vite</span></strong><span class="koboSpan" id="kobo.116.1">: The frontend </span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.117.1">build tool Vite has a unit testing framework called </span><strong class="bold"><span class="koboSpan" id="kobo.118.1">Vitest</span></strong><span class="koboSpan" id="kobo.119.1">. </span><span class="koboSpan" id="kobo.119.2">It is a good unit </span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.120.1">test framework with numerous contemporary features, including support for TypeScript, JSX, and component testing </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">for React.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.122.1">Cypress</span></strong><span class="koboSpan" id="kobo.123.1">: Cypress is an </span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.124.1">E2E solution for advanced web test automation that is JavaScript-based. </span><span class="koboSpan" id="kobo.124.2">Frontend developers and QA engineers can build automated web tests with the help of this tool, which is designed for developers and runs directly in </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">the browser</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.126.1">When it comes to testing, there are multiple ways that we can get it set up inside our React projects. </span><span class="koboSpan" id="kobo.126.2">Every developer has their personal preference. </span><span class="koboSpan" id="kobo.126.3">Some choose to have a dedicated folder where all of their test files go that is separate from their main components. </span><span class="koboSpan" id="kobo.126.4">Others prefer to have their test files in the same folder as their component and in both cases, the test files follow the same naming conventions as their components – so, for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">index.js</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.128.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">index.test.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">The following figure shows an example of both use cases. </span><span class="koboSpan" id="kobo.131.2">It is a Next.js project that has the default </span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.132.1">setup for a Jest and</span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.133.1"> RTL project. </span><span class="koboSpan" id="kobo.133.2">There is a folder named </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">__tests__</span></strong><span class="koboSpan" id="kobo.135.1"> that contains a test called </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">index.test.tsx</span></strong><span class="koboSpan" id="kobo.137.1">. </span><span class="koboSpan" id="kobo.137.2">There is another </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">index.test.tsx</span></strong><span class="koboSpan" id="kobo.139.1"> file inside of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">pages</span></strong><span class="koboSpan" id="kobo.141.1"> folder next to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">index.tsx</span></strong><span class="koboSpan" id="kobo.143.1"> component. </span><span class="koboSpan" id="kobo.143.2">Both tests can be run using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">npm </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">test</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.146.1"> command:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<span class="koboSpan" id="kobo.147.1"><img alt="Figure 8.2: React project testing file structure" src="image/Figure_08.02_B18603.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.148.1">Figure 8.2: React project testing file structure</span></p>
<p><span class="koboSpan" id="kobo.149.1">Now that we have learned a bit about testing conventions in general, the next topic we’ll cover will be the fundamentals </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">of RTL.</span></span></p>
<h2 id="_idParaDest-266"><a id="_idTextAnchor265"/><span class="koboSpan" id="kobo.151.1">What are the fundamentals of React Testing Library?</span></h2>
<p><span class="koboSpan" id="kobo.152.1">With the help of the well-liked testing tool RTL, developers are urged to test their components </span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.153.1">in an approach that closely matches how consumers will interact with the application. </span><span class="koboSpan" id="kobo.153.2">RTL encourages testing components according to what individuals observe and perform instead of on implementation specifics, ensuring that the program stays accessible, manageable, and user-friendly. </span><span class="koboSpan" id="kobo.153.3">RTL is a family of packages, and it can be used on both React and React Native projects. </span><span class="koboSpan" id="kobo.153.4">So, it’s good to know that we can use the same package to test our web and </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">mobile apps.</span></span></p>
<p><span class="koboSpan" id="kobo.155.1">RTL has many </span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.156.1">different core principles that we should become </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">familiar with:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.158.1">Events</span></strong><span class="koboSpan" id="kobo.159.1">: RTL provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">fireEvent</span></strong><span class="koboSpan" id="kobo.161.1"> method, which lets you start a variety of DOM events, such as click, change, or submit, to imitate user interactions. </span><span class="koboSpan" id="kobo.161.2">This enables you to verify that the anticipated behavior is displayed by testing how your components respond to </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">user interactions.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.163.1">Queries</span></strong><span class="koboSpan" id="kobo.164.1">: We can use query options to help locate certain items inside the displayed component. </span><span class="koboSpan" id="kobo.164.2">The searches are focused on what the user can see or do, such as text, labels, or responsibilities. </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">GetByText</span></strong><span class="koboSpan" id="kobo.166.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">GetByRole</span></strong><span class="koboSpan" id="kobo.168.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">GetByTestId</span></strong><span class="koboSpan" id="kobo.170.1"> are a few </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">often-used queries.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.172.1">Custom render</span></strong><span class="koboSpan" id="kobo.173.1">: There is a default render function that you can use to render your components, but you can also design your own render function to wrap your components in a particular context or with a particular provider. </span><span class="koboSpan" id="kobo.173.2">When your components depend on unique context settings, such as theme or localization, this is </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">very helpful.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.175.1">Screen</span></strong><span class="koboSpan" id="kobo.176.1">: You can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">screen</span></strong><span class="koboSpan" id="kobo.178.1"> to output an object that gives you easy access to the displayed parts and query methods without you having to manually break them down. </span><span class="koboSpan" id="kobo.178.2">You may streamline your exams and make them easier to read by </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">screen</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.182.1">Asynchronous utilities</span></strong><span class="koboSpan" id="kobo.183.1">: It is possible to use utilities such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">waitFor</span></strong><span class="koboSpan" id="kobo.185.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">waitForElementToBeRemoved</span></strong><span class="koboSpan" id="kobo.187.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">find*</span></strong><span class="koboSpan" id="kobo.189.1"> searches when working with components that download data or depend on asynchronous activities. </span><span class="koboSpan" id="kobo.189.2">By guaranteeing that your tests wait for the necessary components or actions before continuing, these methods assist in managing the asynchronous operation of </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">your components.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.191.1">UserEvent</span></strong><span class="koboSpan" id="kobo.192.1">: For a </span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.193.1">more accurate simulation of user interactions, is advisable to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">@testing-library/user-event</span></strong><span class="koboSpan" id="kobo.195.1"> package in addition to </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">fireEvent</span></strong><span class="koboSpan" id="kobo.197.1">. </span><span class="koboSpan" id="kobo.197.2">The advanced event simulation functions in this package more closely resemble user behavior than the fundamental </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">fireEvent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.199.1"> method.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.200.1">So, now that we have grasped the idea of using React testing helpers to set up a robust testing environment, let’s take what we’ve learned and see how we can best set up our test environments when using these tools. </span><span class="koboSpan" id="kobo.200.2">This is also going to be a chance to see some example </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">test cases.</span></span></p>
<h1 id="_idParaDest-267"><a id="_idTextAnchor266"/><span class="koboSpan" id="kobo.202.1">Testing our software</span></h1>
<p><span class="koboSpan" id="kobo.203.1">Now, let’s focus on learning how we can set up and clean up our project and code base to isolate the effects of tests – that is, setup and teardown. </span><span class="koboSpan" id="kobo.203.2">Setup and teardown are the actions that </span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.204.1">are taken before and following each test or collection of tests in the context of programming, particularly in software testing. </span><span class="koboSpan" id="kobo.204.2">Doing this ensures that we have good test coverage and that our tests are reliable. </span><span class="koboSpan" id="kobo.204.3">It’s crucial to adhere to a methodical approach while setting up and deconstructing tests to isolate their impacts. </span><span class="koboSpan" id="kobo.204.4">This guarantees that tests are independent of one another and do not affect one another, producing precise and </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">trustworthy findings.</span></span></p>
<p><span class="koboSpan" id="kobo.206.1">In automated testing, the setup and teardown steps are critical for separating the effects of specific tests. </span><span class="koboSpan" id="kobo.206.2">Before each test, the setup process helps establish a consistent state. </span><span class="koboSpan" id="kobo.206.3">This stage may include tasks such as generating required objects, connecting to a database, or initializing particular settings. </span><span class="koboSpan" id="kobo.206.4">By conducting these procedures before each test, we guarantee that each test begins from the same starting point, regardless of the outcomes during previous tests. </span><span class="koboSpan" id="kobo.206.5">This implies that a test’s behavior is not impacted by the side effects of a preceding test, which is critical for accurate, </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">trustworthy testing.</span></span></p>
<p><span class="koboSpan" id="kobo.208.1">Any modifications that are made during the test can be undone during the teardown phase. </span><span class="koboSpan" id="kobo.208.2">This could require actions such as cutting off database access, removing test data, or erasing objects made during the test. </span><span class="koboSpan" id="kobo.208.3">We don’t have to worry about changes made during one test affecting subsequent tests if we clean up after each test. </span><span class="koboSpan" id="kobo.208.4">Without a breakdown step, a test could ultimately leave behind certain modifications that might affect the behavior of </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">subsequent tests.</span></span></p>
<p><span class="koboSpan" id="kobo.210.1">Each test runs in the same starting environment and has no impact on the environment for any other tests thanks to the setup and teardown stages, which work together to make sure each </span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.211.1">test is isolated and reproducible. </span><span class="koboSpan" id="kobo.211.2">One of the guiding principles of automated testing is to make sure that the tests are trustworthy and that any flaws that are discovered are attributable to the code being tested and not to the test configuration or </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">cross-test interaction.</span></span></p>
<p><span class="koboSpan" id="kobo.213.1">There are some rules that we can follow that will help us generate an effective test plan. </span><span class="koboSpan" id="kobo.213.2">Let’s walk through them and see how following them can give us a </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">good strategy:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.215.1">Set up the test environment</span></strong><span class="koboSpan" id="kobo.216.1">: Ensure that the testing environment is the same for all tests. </span><span class="koboSpan" id="kobo.216.2">This covers any prerequisites that are required for the test to perform as well as the software, devices, and </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">network setups.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.218.1">Version control</span></strong><span class="koboSpan" id="kobo.219.1">: Use version control tools such as Git and GitHub to keep track of changes to your code and tests so that you can see any problems that fresh code or tests </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">could cause.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.221.1">Create good tests</span></strong><span class="koboSpan" id="kobo.222.1">: Choose the exact tests you wish to run, and then list the variables and testing conditions </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">for each.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.224.1">Utilize test isolation</span></strong><span class="koboSpan" id="kobo.225.1">: Create your tests so that they have no dependence on other tests. </span><span class="koboSpan" id="kobo.225.2">This implies that each test must have its own setup and teardown and cannot rely on the results or state of any </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">other test.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.227.1">Use monitoring</span></strong><span class="koboSpan" id="kobo.228.1">: To gather test results and spot any anomalies or trends in the test data, use logging </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">and monitoring.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.230.1">Make continuous improvements</span></strong><span class="koboSpan" id="kobo.231.1">: Always enhance your tests and testing environment based on the findings and suggestions from each cycle </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">of testing.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.233.1">Use methods</span></strong><span class="koboSpan" id="kobo.234.1">: Implement the setup and takedown procedures that are carried out before and following each test. </span><span class="koboSpan" id="kobo.234.2">These techniques may be used to build and remove resources that the tests require, such as temporary files or </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">database connections.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.236.1">Parallel or sequential testing</span></strong><span class="koboSpan" id="kobo.237.1">: Run the tests sequentially to ensure there is no conflict between them or run them in parallel based on the kind of test to expedite </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">the process.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.239.1">Mock external functions</span></strong><span class="koboSpan" id="kobo.240.1">: An approach to testing that isolates the unit of code being evaluated from its dependencies, such as external libraries, services, or functions, is mocking external functions. </span><span class="koboSpan" id="kobo.240.2">Usually, this is done to provide predictable and </span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.241.1">controlled test conditions. </span><span class="koboSpan" id="kobo.241.2">For a variety of testing scenarios, mocking enables you to imitate the behavior of external dependencies before actually </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">calling them.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.243.1">Now that we have learned some of the basics of setting up our projects for testing it’s time to take it a step further and move on to learning all about writing tests for our </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">React.js projects.</span></span></p>
<h2 id="_idParaDest-268"><a id="_idTextAnchor267"/><span class="koboSpan" id="kobo.245.1">How do we write tests for components, props, and events?</span></h2>
<p><span class="koboSpan" id="kobo.246.1">Once you’ve selected a testing framework and libraries, you can start developing tests for your React application. </span><span class="koboSpan" id="kobo.246.2">You will create a variety of tests, with each one having a different purpose and scope. </span><span class="koboSpan" id="kobo.246.3">There are several types of tests we can write, including component tests, unit tests, integration tests, event tests, and E2E tests. </span><span class="koboSpan" id="kobo.246.4">The aim is to get as much test coverage across all of the tests to set a benchmark and give you credibility and confidence that your application has thorough testing </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">in place.</span></span></p>
<h3><span class="koboSpan" id="kobo.248.1">What are component tests?</span></h3>
<p><span class="koboSpan" id="kobo.249.1">A React component test </span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.250.1">is a form of unit test that specializes in individually testing React components. </span><span class="koboSpan" id="kobo.250.2">React components are the building blocks of a React application and define the UI, encapsulate functionality, and manage the application’s state. </span><span class="koboSpan" id="kobo.250.3">Testing React components ensures that they behave properly and meet the desired functionality </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">and criteria.</span></span></p>
<p><span class="koboSpan" id="kobo.252.1">In this code example, we can see what a component test looks like for a component called </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">Counter.tsx</span></strong><span class="koboSpan" id="kobo.254.1">. </span><span class="koboSpan" id="kobo.254.2">We have an accompanying </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">Counter.test.tsx</span></strong><span class="koboSpan" id="kobo.256.1"> file that tests for increments and decrements on </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">the buttons.</span></span></p>
<p><span class="koboSpan" id="kobo.258.1">Here’s the code for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">Counter.tsx</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.260.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.261.1">
import { useState } from 'react';
const Counter = () =&gt; {
  const [count, setCount] = useState(0);
  const increment = () =&gt; setCount(count + 1);
  const decrement = () =&gt; setCount(count - 1);
  return (
    &lt;div&gt;
      &lt;h1&gt;Counter: {count}&lt;/h1&gt;
      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;
      &lt;button onClick={decrement}&gt;Decrement&lt;/button&gt;
    &lt;/div&gt;
  );
};
export default Counter;</span></pre> <p><span class="koboSpan" id="kobo.262.1">This is the </span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.263.1">code for our test </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">file, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">Counter.test.tsx</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.267.1">
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Counter from './Counter';
describe('Counter component', () =&gt; {
  test('renders Counter component', () =&gt; {
    render(&lt;Counter /&gt;);
    expect(screen.getByText(/Counter:/i)).toBeInTheDocument();
  });
  test('increases the count when the Increment button is clicked', () =&gt; {
    render(&lt;Counter /&gt;);
    fireEvent.click(screen.getByText(/Increment/i));
    expect(screen.getByText(/Counter: 1/i)).toBeInTheDocument();
  });
  test('decreases the count when the Decrement button is clicked', () =&gt; {
    render(&lt;Counter /&gt;);
    fireEvent.click(screen.getByText(/Increment/i));
    fireEvent.click(screen.getByText(/Decrement/i));
    expect(screen.getByText(/Counter: 0/i)).toBeInTheDocument();
  });
});</span></pre> <p><span class="koboSpan" id="kobo.268.1">We have </span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.269.1">now learned the basics of component and component </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">test files.</span></span></p>
<h3><span class="koboSpan" id="kobo.271.1">What are unit tests?</span></h3>
<p><span class="koboSpan" id="kobo.272.1">React unit tests are a method of testing that focuses on individual React components. </span><span class="koboSpan" id="kobo.272.2">Their purpose is </span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.273.1">to guarantee that each component behaves appropriately, follows the intended functionality and requirements, and tests the logic and output of the component. </span><span class="koboSpan" id="kobo.273.2">Unit tests are an essential aspect of the testing process since they assist developers in identifying and resolving issues at the most granular level, ensuring that each component of the application </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">performs properly.</span></span></p>
<p><span class="koboSpan" id="kobo.275.1">We saw what a unit test looks like in our component </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">test example.</span></span></p>
<h3><span class="koboSpan" id="kobo.277.1">What is an integration test?</span></h3>
<p><span class="koboSpan" id="kobo.278.1">A React integration test is a type of test that verifies the right interaction and behavior of many React </span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.279.1">components or between a React component and other system components such as APIs or external services. </span><span class="koboSpan" id="kobo.279.2">Integration tests, as opposed to unit tests, analyze how well components interact together inside the program, ensuring that general functionality is proper and data flows easily between different areas of </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.281.1">Integration tests are multiple tests that run inside of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">describe()</span></strong><span class="koboSpan" id="kobo.283.1"> function block scope, as shown in our earlier component </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">test example.</span></span></p>
<h3><span class="koboSpan" id="kobo.285.1">What are event tests?</span></h3>
<p><span class="koboSpan" id="kobo.286.1">React event tests are a form of testing that focuses on confirming the behavior and functioning </span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.287.1">of React component event handlers. </span><span class="koboSpan" id="kobo.287.2">User interactions or system occurrences that trigger specified actions inside a React application are referred to as events. </span><span class="koboSpan" id="kobo.287.3">Button clicks, form submissions, mouse movements, and keyboard inputs are all examples of events. </span><span class="koboSpan" id="kobo.287.4">By testing event handlers, you guarantee that your application responds to user interactions appropriately and that the necessary actions are taken when events </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">are triggered.</span></span></p>
<h3><span class="koboSpan" id="kobo.289.1">What is snapshot regress testing?</span></h3>
<p><span class="koboSpan" id="kobo.290.1">In React, we can use </span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.291.1">snapshot tests as a way to confirm that our UI has not changed and remains the same as it was prior. </span><span class="koboSpan" id="kobo.291.2">This helps us check that there were no unexpected changes that can affect the way that our design is rendered on screen. </span><span class="koboSpan" id="kobo.291.3">With snapshot testing, it is common for a snapshot of our code base to be taken that can then be compared to a reference snapshot file that is combined with a test. </span><span class="koboSpan" id="kobo.291.4">The test fails if the snapshots are not the same, and this is how we can ensure that there have been no changes to the UI. </span><span class="koboSpan" id="kobo.291.5">We can always update the snapshot to the latest version to match any changes we have made to </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">the UI.</span></span></p>
<h3><span class="koboSpan" id="kobo.293.1">What are end-to-end tests?</span></h3>
<p><span class="koboSpan" id="kobo.294.1">E2E tests are a form of testing that tries to validate the functionality of a whole program, from the UI </span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.295.1">through to the backend services and databases. </span><span class="koboSpan" id="kobo.295.2">E2E tests are used to model real-world user situations and guarantee that the overall structure works as planned, giving seamless user experience and </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">accurate functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.297.1">Cypress is a popular E2E testing library that does not come bundled with React projects but can be </span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.298.1">installed as a separate package. </span><span class="koboSpan" id="kobo.298.2">You can learn more from the </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">documentation: </span></span><a href="https://www.cypress.io/"><span class="No-Break"><span class="koboSpan" id="kobo.300.1">https://www.cypress.io/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.301.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.302.1">We can use our earlier Counter project example to see what the code looks like when doing an E2E test with Cypress. </span><span class="koboSpan" id="kobo.302.2">It is quite similar to Jest and RTL and all three packages can work </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">together seamlessly.</span></span></p>
<p><span class="koboSpan" id="kobo.304.1">Let’s take a look at our modified </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">Counter file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.306.1">
import { useState } from 'react';
import './App.css';
function App() {
  const [count, setCount] = useState(0);
  return (
    &lt;div className="App"&gt;
      &lt;h1&gt;Counter App&lt;/h1&gt;
      &lt;h2 data-testid="counter-display"&gt;Count: {count}&lt;/h2&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}
        data-testid="increment-button"&gt;
        Increment
      &lt;/button&gt;
      &lt;button onClick={() =&gt; setCount(count - 1)}
        data-testid="decrement-button"&gt;
        Decrement
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
export default App;</span></pre> <p><span class="koboSpan" id="kobo.307.1">Here’s our </span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.308.1">Counter </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">test file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.310.1">
describe('Counter App', () =&gt; {
  beforeEach(() =&gt; {
    cy.visit('/');
  });
  it('increases the counter', () =&gt; {
    cy.get('[data-testid="increment-button"]').click();
    cy.get('[data-testid="counter-display"]').
</span><span class="koboSpan" id="kobo.310.2">      contains('Count: 1');
  });
  it('decreases the counter', () =&gt; {
    cy.get('[data-testid="decrement-button"]').click();
    cy.get('[data-testid="counter-display"]').
</span><span class="koboSpan" id="kobo.310.3">      contains('Count: -1');
  });
  it('increases and decreases the counter', () =&gt; {
    cy.get('[data-testid="increment-button"]').
</span><span class="koboSpan" id="kobo.310.4">      click().click();
    cy.get('[data-testid="decrement-button"]').click();
    cy.get('[data-testid="counter-display"]').
</span><span class="koboSpan" id="kobo.310.5">      contains('Count: 1');
  });
});</span></pre> <p><span class="koboSpan" id="kobo.311.1">These examples </span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.312.1">have provided us with a comparison between E2E tests and component tests; the similarities are </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">quite clear.</span></span></p>
<h1 id="_idParaDest-269"><a id="_idTextAnchor268"/><span class="koboSpan" id="kobo.314.1">Managing data in our applications</span></h1>
<p><span class="koboSpan" id="kobo.315.1">We are now going to learn how to manage the data in our applications. </span><span class="koboSpan" id="kobo.315.2">This is also known as data </span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.316.1">fetching and mocking, which are two important concepts to grasp. </span><span class="koboSpan" id="kobo.316.2">When doing </span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.317.1">testing in this area, it is necessary to have a working </span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.318.1">knowledge of how data-fetching APIs operate and how to mimic their data. </span><span class="koboSpan" id="kobo.318.2">This knowledge is necessary for several reasons, including development efficiency, independent testing, integration and interaction with external systems, and cost and </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">rate limiting.</span></span></p>
<p><span class="koboSpan" id="kobo.320.1">In the case of developer efficiency, developers can separate portions of the application for testing and development by mocking API replies. </span><span class="koboSpan" id="kobo.320.2">This means that even if the backend portion of a feature is not yet completed, a frontend developer can still work on it by simulating an API response. </span><span class="koboSpan" id="kobo.320.3">As for independent testing, programmers can confirm that their tests are not impacted by the status or behavior of other systems by mimicking the data given by APIs, producing more dependable and consistent outcomes </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">for tests.</span></span></p>
<p><span class="koboSpan" id="kobo.322.1">When we use external systems such as APIs, we can communicate and exchange data between various software systems. </span><span class="koboSpan" id="kobo.322.2">To get data from databases, communicate with other apps, or offer services to users, many current applications are built on top of APIs. </span><span class="koboSpan" id="kobo.322.3">That’s why creating, maintaining, and enhancing these apps requires a functional understanding of how these </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">APIs function.</span></span></p>
<p><span class="koboSpan" id="kobo.324.1">When we think about cost and rate limiting, many APIs contain use restrictions or extra fees. </span><span class="koboSpan" id="kobo.324.2">To prevent reaching these restrictions or spending needless money, we can mock API answers during development </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">and testing.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">To use data in an application or system, data must be fetched from a data source, such as a database, API, or filesystem. </span><span class="koboSpan" id="kobo.326.2">In online applications and other software systems, data fetching is frequently </span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.327.1">used to display, analyze, or change data. </span><span class="koboSpan" id="kobo.327.2">It often entails sending queries to a local storage location or distant server, processing the answer, and then using the data in </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.329.1">While testing, developing, or designing processes, mocking data refers to creating fictitious or mock data to replicate the behavior of actual data. </span><span class="koboSpan" id="kobo.329.2">When building features for a system, testing code, or designing UIs, mock data can be used as a stand-in for real data. </span><span class="koboSpan" id="kobo.329.3">It enables programmers to test their programs and apps without relying on potentially private, erratic, or unreachable external data sources or </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">live data.</span></span></p>
<h2 id="_idParaDest-270"><a id="_idTextAnchor269"/><span class="koboSpan" id="kobo.331.1">How do we mock data for tests?</span></h2>
<p><span class="koboSpan" id="kobo.332.1">Mock data will </span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.333.1">most likely be required while testing your React application to imitate real-world circumstances. </span><span class="koboSpan" id="kobo.333.2">This is especially helpful for testing components that rely on APIs or third-party services. </span><span class="koboSpan" id="kobo.333.3">Numerous libraries are available for </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">mimicking data:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.335.1">Axios Mock Adapter</span></strong><span class="koboSpan" id="kobo.336.1">: The </span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.337.1">Axios Mock Adapter library intercepts Axios requests and returns </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">mocked data</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.339.1">Nock</span></strong><span class="koboSpan" id="kobo.340.1">: Nock is </span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.341.1">an HTTP request interceptor that returns </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">faked data</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.343.1">JSON Server</span></strong><span class="koboSpan" id="kobo.344.1">: JSON Server </span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.345.1">is a package that uses JSON data to imitate a </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">REST API</span></span></li>
</ul>
<h2 id="_idParaDest-271"><a id="_idTextAnchor270"/><span class="koboSpan" id="kobo.347.1">Why should we use mock data in tests?</span></h2>
<p><span class="koboSpan" id="kobo.348.1">There are many reasons why it’s a good idea to use mock as opposed to real data in our tests. </span><span class="koboSpan" id="kobo.348.2">We can </span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.349.1">separate sections of our system using mock data, which makes it simpler to find problems and test particular components without being impacted by other dependencies. </span><span class="koboSpan" id="kobo.349.2">Controlled mock data ensures that tests are reproducible and produce consistent findings, which is another advantage. </span><span class="koboSpan" id="kobo.349.3">Developers can also verify their code and apps without having to wait for access to actual data thanks to the speedy generation of mock data. </span><span class="koboSpan" id="kobo.349.4">Also, during development and testing, sensitive or private data might be exposed, which can be a major worry for organizations. </span><span class="koboSpan" id="kobo.349.5">Using dummy data helps </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">prevent this.</span></span></p>
<p><span class="koboSpan" id="kobo.351.1">In the next section, we will learn about events and timers, which is crucial learning as it relates to asynchronous or time-dependent actions in programming. </span><span class="koboSpan" id="kobo.351.2">Asynchronous programming is a technique that allows your program to begin a potentially long-running operation while being responsive to other events, rather than needing to wait until that work </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">is completed.</span></span></p>
<p><span class="koboSpan" id="kobo.353.1">When that task is completed, the outcome is shown in your program. </span><span class="koboSpan" id="kobo.353.2">An extremely flexible asynchronous and concurrent programming language such as JavaScript is very powerful because, like sync, it is single-threaded, but unlike async, it also does not block code execution, which is great for our </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">React applications.</span></span></p>
<h1 id="_idParaDest-272"><a id="_idTextAnchor271"/><span class="koboSpan" id="kobo.355.1">Code execution using events and timers</span></h1>
<p><span class="koboSpan" id="kobo.356.1">Now, let’s move on to learning about the subject of events and timers. </span><span class="koboSpan" id="kobo.356.2">In software development, events and timers are implemented to keep track of the precise moment in time when </span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.357.1">something outside the program takes place. </span><span class="koboSpan" id="kobo.357.2">Events and </span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.358.1">timers are critical concepts in programming, especially when dealing with asynchronous or time-dependent actions. </span><span class="koboSpan" id="kobo.358.2">They also play a crucial part in testing such systems. </span><span class="koboSpan" id="kobo.358.3">Let’s go through each subject in further depth to drill these </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">concepts in.</span></span></p>
<h2 id="_idParaDest-273"><a id="_idTextAnchor272"/><span class="koboSpan" id="kobo.360.1">What are events?</span></h2>
<p><span class="koboSpan" id="kobo.361.1">Events are </span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.362.1">activities or occurrences that arise during program execution and are frequently prompted by input from users, system changes, or other sources. </span><span class="koboSpan" id="kobo.362.2">In event-driven programming, system components respond to these occurrences by executing specified routines known as event handlers </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">or callbacks.</span></span></p>
<p><span class="koboSpan" id="kobo.364.1">Simulating events is critical in testing to guarantee that the application responds as intended when the events happen. </span><span class="koboSpan" id="kobo.364.2">You might wish to test how your web application reacts to user </span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.365.1">activities such as button clicks, form submissions, or navigation events. </span><span class="koboSpan" id="kobo.365.2">By simulating these events in your tests, you can ensure that your application’s event handlers are functioning properly and handling various circumstances </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">as planned.</span></span></p>
<h2 id="_idParaDest-274"><a id="_idTextAnchor273"/><span class="koboSpan" id="kobo.367.1">What are timers?</span></h2>
<p><span class="koboSpan" id="kobo.368.1">Timers serve a purpose in programming as they plan the execution of certain functions or code snippets </span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.369.1">after a certain amount of time has passed or at regular intervals. </span><span class="koboSpan" id="kobo.369.2">In JavaScript, common timer functions are </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">setTimeout</span></strong><span class="koboSpan" id="kobo.371.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">setInterval</span></strong><span class="koboSpan" id="kobo.373.1">, which allow you to run a function immediately following a delay or periodically at </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">predefined intervals.</span></span></p>
<p><span class="koboSpan" id="kobo.375.1">Timers can complicate testing since they require asynchronous activities, which can result in unexpected behavior or race situations. </span><span class="koboSpan" id="kobo.375.2">A race situation, also known as a race hazard, is a circumstance in which the substantive behavior of software or other systems is reliant on the sequence or timing of other uncontrolled occurrences. </span><span class="koboSpan" id="kobo.375.3">When one or more of the alternative behaviors is undesired, it constitutes </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">a bug.</span></span></p>
<p><span class="koboSpan" id="kobo.377.1">It is critical to handle timers appropriately when testing code that depends on them to produce accurate and trustworthy test results. </span><span class="koboSpan" id="kobo.377.2">Now that we have learned about timers, the next section will take what we’ve learned further as we look into debugging and making the best use of our knowledge of timers, which can be used </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">in conjunction.</span></span></p>
<h1 id="_idParaDest-275"><a id="_idTextAnchor274"/><span class="koboSpan" id="kobo.379.1">Using React DevTools for debugging and analysis</span></h1>
<p><span class="koboSpan" id="kobo.380.1">React DevTools is a browser plugin that offers a variety of tools for testing your React application. </span><span class="koboSpan" id="kobo.380.2">It allows </span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.381.1">you to investigate the component </span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.382.1">hierarchy, view the React component tree, and verify the props and state of your components. </span><span class="koboSpan" id="kobo.382.2">We will dive into the various debugging techniques available to us and how using them will give us more confidence in the code that </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">we write.</span></span></p>
<p><span class="koboSpan" id="kobo.384.1">React DevTools can be seen in the following figure. </span><span class="koboSpan" id="kobo.384.2">It is available in the Chrome </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">web store:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<span class="koboSpan" id="kobo.386.1"><img alt="Figure 8.3: React DevTools" src="image/Figure_08.03_B18603.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.387.1">Figure 8.3: React DevTools</span></p>
<p><span class="koboSpan" id="kobo.388.1">With that, we have </span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.389.1">learned about React DevTools. </span><span class="koboSpan" id="kobo.389.2">Next, we’ll </span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.390.1">learn how to configure CI/CD pipelines for our automated tests, another useful tool in our </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">debugging toolkit.</span></span></p>
<h3><span class="koboSpan" id="kobo.392.1">How do we configure a CI/CD pipeline to automate tests?</span></h3>
<p><span class="koboSpan" id="kobo.393.1">To </span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.394.1">ensure </span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.395.1">that our tests run every time </span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.396.1">we make code changes, we can configure a </span><strong class="bold"><span class="koboSpan" id="kobo.397.1">continuous integration/continuous deployment</span></strong><span class="koboSpan" id="kobo.398.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.399.1">CI/CD</span></strong><span class="koboSpan" id="kobo.400.1">) pipeline that runs tests automatically. </span><span class="koboSpan" id="kobo.400.2">This allows us to catch issues early and ensure that our code meets the expected standard. </span><span class="koboSpan" id="kobo.400.3">Using a CI/CD pipeline to automate tests in a React application has several advantages, including higher code quality, faster feedback, greater collaboration, and more efficient deployment procedures. </span><span class="koboSpan" id="kobo.400.4">These advantages enable teams to create high-quality software more quickly and consistently, making CI/CD pipelines a vital tool for modern </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">software development.</span></span></p>
<p><span class="koboSpan" id="kobo.402.1">It </span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.403.1">is common </span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.404.1">practice to use a code hosting platform such as GitHub, GitLab, or Bitbucket combined with a CI/CD testing platform such as GitHub Actions, Jenkins, Docker, Kubernetes, or CircleCI to name </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">a few.</span></span></p>
<h3><span class="koboSpan" id="kobo.406.1">How do we debug a React application?</span></h3>
<p><span class="koboSpan" id="kobo.407.1">Debugging a </span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.408.1">React application might be difficult, but it is a necessary skill for any React developer. </span><span class="koboSpan" id="kobo.408.2">In this subsection, we’ll go over some fundamental strategies and tricks for properly debugging a </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">React application.</span></span></p>
<h4><span class="koboSpan" id="kobo.410.1">How do we utilize the debugging tools inside our IDE/code editor?</span></h4>
<p><span class="koboSpan" id="kobo.411.1">Popular </span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.412.1">code editors such as Visual Studio Code include debugging capabilities for JavaScript and React apps. </span><span class="koboSpan" id="kobo.412.2">You can debug your React application immediately within the editor by configuring a launch configuration, which allows you to create breakpoints, walk through code, and </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">inspect variables.</span></span></p>
<h4><span class="koboSpan" id="kobo.414.1">How do we set up breakpoints with DevTools?</span></h4>
<p><span class="koboSpan" id="kobo.415.1">Debugging a React application begins with the use of breakpoints, which interrupt the execution </span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.416.1">of your code at a certain moment in time. </span><span class="koboSpan" id="kobo.416.2">You can set breakpoints, analyze variables, and go through your code line by line using the browser’s built-in developer tools. </span><span class="koboSpan" id="kobo.416.3">Use DevTools and browse the </span><strong class="bold"><span class="koboSpan" id="kobo.417.1">Sources</span></strong><span class="koboSpan" id="kobo.418.1"> tab to establish a breakpoint in your program. </span><span class="koboSpan" id="kobo.418.2">Locate the necessary file, scroll to the line where you wish to establish a breakpoint, and then click on the line number to </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">do so.</span></span></p>
<p><span class="koboSpan" id="kobo.420.1">If you reload the page once you’ve set a breakpoint, your code will halt at </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">the breakpoint.</span></span></p>
<h4><span class="koboSpan" id="kobo.422.1">How do we use logging to track application behavior?</span></h4>
<p><span class="koboSpan" id="kobo.423.1">Another key </span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.424.1">tool for troubleshooting a React application is logging. </span><span class="koboSpan" id="kobo.424.2">You can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">console.log()</span></strong><span class="koboSpan" id="kobo.426.1"> commands to output variable values, trace the flow of your code, and </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">troubleshoot problems.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">Just put </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">console.log()</span></strong><span class="koboSpan" id="kobo.430.1"> followed by the value you wish to log into your code to add a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">console.log()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.432.1"> statement.</span></span></p>
<h4><span class="koboSpan" id="kobo.433.1">How do we create error boundaries?</span></h4>
<p><span class="koboSpan" id="kobo.434.1">Error boundaries are React components that can detect JavaScript problems anywhere in your </span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.435.1">component hierarchy, report them, and replace the crashed component with a fallback UI. </span><span class="koboSpan" id="kobo.435.2">You can prevent your application from crashing if an unhandled error in a single component is wrapped in an error </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">border component.</span></span></p>
<h4><span class="koboSpan" id="kobo.437.1">How do we understand JavaScript error codes?</span></h4>
<p><span class="koboSpan" id="kobo.438.1">React apps can experience a variety of issues, ranging from syntax mistakes to runtime faults. </span><span class="koboSpan" id="kobo.438.2">Knowing </span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.439.1">these issues and the error codes associated with them is critical for effective troubleshooting. </span><span class="koboSpan" id="kobo.439.2">For example, a typical problem that’s seen by React developers is </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">TypeError: Cannot read property 'propName' of undefined</span></strong><span class="koboSpan" id="kobo.441.1">. </span><span class="koboSpan" id="kobo.441.2">When you try to access a property of an undefined object, this </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">error occurs.</span></span></p>
<p><span class="koboSpan" id="kobo.443.1">You can pinpoint the problem and repair it faster if you understand the error code and its </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">associated problems.</span></span></p>
<h4><span class="koboSpan" id="kobo.445.1">How do we install a debugger extension?</span></h4>
<p><span class="koboSpan" id="kobo.446.1">Browser debugger </span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.447.1">plugins can also assist you in debugging your React application. </span><span class="koboSpan" id="kobo.447.2">The React DevTools extension, for example, contains various tools that have been developed expressly for debugging React applications, such as the ability to explore the component hierarchy, check properties and states, and highlight the selected component in the browser. </span><span class="koboSpan" id="kobo.447.3">Similarly, we can use the Redux DevTools extension to debug our application’s state changes. </span><span class="koboSpan" id="kobo.447.4">Using Redux is more applicable when we are working with a more complex application that requires a </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">global state.</span></span></p>
<h4><span class="koboSpan" id="kobo.449.1">How do we use the ESLint plugin for React?</span></h4>
<p><span class="koboSpan" id="kobo.450.1">ESLint is a </span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.451.1">popular JavaScript linting tool that can help you find and correct syntax problems, possible bugs, and code quality concerns. </span><span class="koboSpan" id="kobo.451.2">The ESLint plugin for React adds extra linting rules tailored to React applications, assisting you in detecting frequent mistakes and best </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">practice violations.</span></span></p>
<h3><span class="koboSpan" id="kobo.453.1">What are error monitoring tools?</span></h3>
<p><span class="koboSpan" id="kobo.454.1">Tools for tracking, identifying, and reporting mistakes and anomalies that arise in applications </span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.455.1">throughout development, testing, or deployment are known as error monitoring tools. </span><span class="koboSpan" id="kobo.455.2">These tools assist programmers </span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.456.1">in locating problems, determining their root causes, and promptly resolving them. </span><span class="koboSpan" id="kobo.456.2">For developers to achieve better software, error monitoring systems frequently include capabilities such as real-time error tracking, alerts, and thorough </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">error reporting.</span></span></p>
<p><span class="koboSpan" id="kobo.458.1">There are quite a lot of error monitoring tools available, and some stand-out ones include LogRocket, Sentry, </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">and Rollbar.</span></span></p>
<p><span class="koboSpan" id="kobo.460.1">We have reached the end of this section and also this chapter. </span><span class="koboSpan" id="kobo.460.2">Our knowledge of testing and debugging will be crucial at interviews because this is an area that many companies expect developers to be </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">good in.</span></span></p>
<h1 id="_idParaDest-276"><a id="_idTextAnchor275"/><span class="koboSpan" id="kobo.462.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.463.1">This chapter has offered a thorough understanding of the critical parts of testing and debugging React applications. </span><span class="koboSpan" id="kobo.463.2">We began by discussing the significance of testing in software development and the necessity for a strong testing environment geared toward React apps. </span><span class="koboSpan" id="kobo.463.3">Next, we looked at various testing frameworks and libraries, highlighting their unique characteristics as well as the criteria to consider when choosing the best tools. </span><span class="koboSpan" id="kobo.463.4">Learning about the importance of setups and teardowns was </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">also covered.</span></span></p>
<p><span class="koboSpan" id="kobo.465.1">We covered building tests for components, props, and events throughout this chapter, highlighting the need to create extensive test suites to ensure the dependability and maintainability of our React applications. </span><span class="koboSpan" id="kobo.465.2">To take the testing process even further, we talked about mocking data for tests, which allows us to simulate real-world scenarios without relying on external dependencies. </span><span class="koboSpan" id="kobo.465.3">Understanding events and times when doing testing was another hot topic we </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">talked about.</span></span></p>
<p><span class="koboSpan" id="kobo.467.1">We also introduced React DevTools, which assists developers in evaluating and understanding the internal structure and behavior of their apps throughout the testing phase, as well as CI/CD pipelines. </span><span class="koboSpan" id="kobo.467.2">Another important topic we discussed in this chapter was debugging React apps and using error monitoring tools. </span><span class="koboSpan" id="kobo.467.3">Understanding the art of testing and debugging is critical for React developers looking to build high-quality, long-lasting applications because these skills will make us better developers. </span><span class="koboSpan" id="kobo.467.4">Being capable of solving problems is a quality that is highly sought after in the world </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">of programming.</span></span></p>
<p><span class="koboSpan" id="kobo.469.1">In the next chapter, we will get the chance to learn about some of the most modern React.js build tools available. </span><span class="koboSpan" id="kobo.469.2">Next.js, Gatsby and Remix are three popular choices for React.js development so let’s expand our knowledge further and get a grasp on these </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">amazing libraries</span></span></p>
</div>
</body></html>