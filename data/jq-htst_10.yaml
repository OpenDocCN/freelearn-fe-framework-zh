- en: Chapter 10. A Sortable, Paged Table with Knockout.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。带有 Knockout.js 的可排序、分页表格
- en: Knockout.js is a fantastic JavaScript **Model-View-ViewModel** (**MVVM**) framework
    that can help you save time when writing complex, interactive user interfaces.
    It works very well with jQuery and even has built-in basic templating support
    for building repeated elements that show different data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout.js 是一个很棒的 JavaScript **模型-视图-视图模型**（**MVVM**）框架，可以帮助你在编写复杂的交互式用户界面时节省时间。它与
    jQuery 配合得非常好，甚至还具有用于构建显示不同数据的重复元素的内置基本模板支持。
- en: Mission Briefing
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务简报
- en: In this project we'll build a paged table from data using jQuery and Knockout.js.
    Client-side paging itself is a great feature, but we'll also allow the table to
    be sorted by providing clickable table headings, and add some additional features
    such as filtering the data based on a particular property.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，我们将使用 jQuery 和 Knockout.js 从数据构建分页表格。客户端分页本身是一个很好的功能，但我们还将允许通过提供可点击的表头对表格进行排序，并添加一些附加功能，如根据特定属性过滤数据。
- en: 'By the end of this mission we''ll have built something that looks like the
    following screenshot:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到此任务结束时，我们将建立如下屏幕截图所示的东西：
- en: '![Mission Briefing](img/9106OS_10_01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![任务简报](img/9106OS_10_01.jpg)'
- en: Why Is It Awesome?
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么这很棒？
- en: Building complex UIs that respond rapidly to user interaction is hard. It takes
    time, and the more complex or interactive an application is, the longer it takes
    and the more code it requires. And the more code an application requires, the
    harder it is to keep it organized and maintainable.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 构建快速响应用户交互的复杂 UI 是困难的。这需要时间，而且应用程序越复杂或交互性越强，花费的时间就越长，需要的代码也越多。而应用程序需要的代码越多，就越难以保持组织和可维护性。
- en: While jQuery is good at helping us to write concise code, it was never designed
    with building large-scale, dynamic, and interactive applications in mind. It's
    powerful, and great at what it does and what it was designed to do; it just wasn't
    designed to build entire applications with.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 jQuery 擅长帮助我们编写简洁的代码，但它从未旨在构建大规模、动态和交互式应用程序。它功能强大，擅长自己的工作以及它被设计用来做的事情；只是它并没有被设计用来构建整个应用程序。
- en: Something else is needed when building large-scale applications, something that
    provides a framework within which we can keep code organized and maintainable.
    Knockout.js is one such framework designed to do just that.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建大规模应用程序时需要其他东西，需要提供一个框架，可以在其中组织和维护代码。Knockout.js 就是这样一个旨在实现此目标的框架之一。
- en: Knockout.js is known as an MVVM framework, which is based on three core components
    – the **Model**, the **View**, and the **ViewModel**. This is similar to the better-known
    MVC pattern. The intent of these and other similar patterns is to provide a clear
    separation of the visual part of an application and the code required to manage
    the data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout.js 被称为一个 MVVM 框架，它基于三个核心组件 - **模型**、**视图** 和 **视图模型**。这类似于更为人熟知的 MVC
    模式。这些和其他类似的模式的目的是提供清晰的应用程序可视部分和管理数据所需代码之间的分离。
- en: The **Model** can be thought of as the data for the application. Really, the
    actual data is a result of the Model, but when working on the client side, we
    can forget about how the data is accessed by the server-side code because usually
    we just make an AJAX request and the data is delivered to us.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型** 可以被认为是应用程序的数据。实际上，实际数据是模型的结果，但在客户端工作时，我们可以忽略数据是如何被服务器端代码访问的，因为通常我们只是发出
    AJAX 请求，数据就会被传递给我们。'
- en: The **View** is the visual representation of that data, the actual HTML and
    CSS used to present the Model to the user. When using Knockout.js, this part of
    the application can also include bindings, which map elements on the page to specific
    bits of data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图** 是数据的可视化表示，实际的 HTML 和 CSS 用于向用户呈现模型。在使用 Knockout.js 时，应用程序的这一部分也可以包括绑定，将页面上的元素映射到特定的数据部分。'
- en: The **ViewModel** sits between the Model and the View, and is quite literally
    a model of the View – a simplified representation of the state of the View. It
    manages the user interaction, makes and handles requests for data, and then feeds
    the data back to the user interface.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图模型** 位于模型和视图之间，实际上是视图的模型 - 视图状态的简化表示。它管理用户交互，生成并处理对数据的请求，然后将数据反馈到用户界面。'
- en: Your Hotshot Objectives
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的炫酷目标
- en: 'The tasks needed to complete this mission are listed below:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此任务所需的任务如下：
- en: Rendering the initial table
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染初始表格
- en: Sorting the table
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对表格进行排序
- en: Setting the page size
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置页面大小
- en: Adding Previous and Next links
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加上一页和下一页链接
- en: Adding numerical page links
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加数字页面链接
- en: Managing class names
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理类名
- en: Resetting the page
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重置页面
- en: Filtering the table
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤表格
- en: Mission Checklist
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务清单
- en: "We'll be using Knockout.js in this project, so you'll need to grab a copy of\
    \ it now. The latest version, 2.2.1 at the time this book went to print, can be\
    \ downloaded from: [http://knockoutjs.com/downloads/index.html](http:// \Lhttp://knockoutjs.com/downloads/index.html).\
    \ This should be saved in the `js` directory within the main `jquery-hotshots`\
    \ project folder as `knockout-2.2.1.js`."
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: "在这个项目中我们将使用 Knockout.js，所以现在你需要获取它的副本。这本书印刷时的最新版本为 2.2.1，可以从以下网址下载：[http://knockoutjs.com/downloads/index.html](http://\
    \ \Lhttp://knockoutjs.com/downloads/index.html)。应将其保存在主`jquery-hotshots`项目文件夹内的`js`目录中，命名为`knockout-2.2.1.js`。"
- en: We also need some data for this project. We'll need to use a reasonably large
    data set consisting of data that can be ordered in a variety of ways. We'll be
    using the periodic table of elements, in JSON format, as our data source.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一些数据来完成这个项目。我们将需要使用一个相当大的数据集，其中包含可以按多种方式排序的数据。我们将使用元素周期表的 JSON 格式作为我们的数据源。
- en: 'I''ve provided a file as part of this example called `table-data.js`, which
    contains an object with a property called `elements`. The value of this property
    is an array of objects, where each object represents an element. The objects are
    in the following format:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提供了一个文件作为这个示例的一部分，名为`table-data.js`，其中包含一个名为`elements`的属性的对象。该属性的值是一个对象数组，其中每个对象表示一个元素。对象的格式如下：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Rendering the initial table
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染初始表格
- en: In our first task of the project, we'll build a super-simple ViewModel, add
    a basic View, and render the Model into a bare `<table>` without any enhancements
    or additional functionality. This will allow us to familiarize ourselves with
    some of the basic principles of Knockout, without dropping us in at the deep end.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的第一个任务中，我们将构建一个超级简单的 ViewModel，添加一个基本的 View，并将 Model 渲染到一个裸的`<table>`中，没有任何增强或附加功能。这将使我们能够熟悉
    Knockout 的一些基本原理，而不是直接投入到深水区。
- en: Prepare for Lift Off
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: At this point we create the files we'll be using in this project. Save a copy
    of the template file as `sortable-table.html` in the root project directory.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此时我们创建项目中将要使用的文件。将模板文件另存为`sortable-table.html`，保存在根项目目录中。
- en: We'll also need a style sheet called `sortable-table.css`, which we should save
    in the `css` folder, and a JavaScript file called `sortable-table.js`, which should
    of course be saved in the `js` directory.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个名为`sortable-table.css`的样式表，应将其保存在`css`文件夹中，并且一个名为`sortable-table.js`的
    JavaScript 文件，当然应将其保存在`js`目录中。
- en: The HTML file should link to each of these resources, as well as the `knockout-2.2.1.js`
    file. The style sheet should be linked to directly after `common.css`, which we've
    used in most of the projects in the book so far, while `knockout.js`, `table-data.js`,
    and the custom script file for this project (`sortable-table.js`) should come
    after the link to jQuery, in that order.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 文件应链接到每个资源，以及`knockout-2.2.1.js`文件。样式表应在`common.css`之后直接链接，我们迄今为止在本书中大部分项目中都使用了它，而`knockout.js`、`table-data.js`和这个项目的自定义脚本文件（`sortable-table.js`）应在链接到
    jQuery 之后添加，按照这个顺序。
- en: Engage Thrusters
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'First of all we can build the ViewModel. In `sortable-table.js`, add the following
    code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们可以构建 ViewModel。在`sortable-table.js`中，添加以下代码：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we can add the View, which is built from some simple HTML. Add the following
    markup to the `<body>` of `sortable-table.html`, before the `<script>` elements:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以添加 View，它由一些简单的 HTML 构建而成。将以下标记添加到`sortable-table.html`的`<body>`中，位于`<script>`元素之前：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Lastly, we can add some basic styling to our `<table>` and its contents by
    adding the following code to `sortable-table.css`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过将以下代码添加到`sortable-table.css`来为我们的`<table>`及其内容添加一些基本样式：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Objective Complete - Mini Debriefing
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 迷你简报
- en: In our script, we first added the usual callback function to be executed when
    the document loads. Within this we created the ViewModel using an object literal
    stored in the variable `vm`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的脚本中，首先添加了通常的回调函数，在文档加载时执行。在此之中，我们使用存储在变量`vm`中的对象字面量创建了 ViewModel。
- en: The only property this object has is `elements`, the value of which is set using
    a Knockout method. Knockout adds a global `ko` object that we can use to call
    methods. One of these methods is `observableArray()`. This method accepts an array
    as an argument, and the array passed in to the method becomes observable. This
    is the data for our application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象唯一的属性是`elements`，其值是使用 Knockout 方法设置的。Knockout 添加了一个全局的`ko`对象，我们可以使用它来调用方法。其中之一是`observableArray()`方法。该方法接受一个数组作为参数，并且传递给该方法的数组将变为可观察的。这就是我们应用程序的数据。
- en: In Knockout, primitives such as strings or numbers can be observable and this
    allows them to notify subscribers when their values change. Observable arrays
    are similar, except that they are used with arrays. Whenever a value is added
    or removed from an observable array, it will notify any subscribers.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Knockout 中，诸如字符串或数字之类的基本类型可以是可观察的，这使它们能够在其值更改时通知订阅者。可观察数组类似，只是它们与数组一起使用。每当向可观察数组添加或删除值时，它都会通知任何订阅者。
- en: After defining our ViewModel, we need to apply any bindings that may be present
    in the View. We'll look at the bindings in just a moment; for now just be aware
    that until we call Knockout's `applyBindings()` method, any bindings we add to
    our View won't be applied.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了我们的 ViewModel 之后，我们需要应用可能存在于 View 中的任何绑定。我们马上就会看到这些绑定；暂时只需知道，在调用 Knockout
    的 `applyBindings()` 方法之前，我们添加到 View 的任何绑定都不会生效。
- en: The HTML we added is almost unremarkable, it's just a simple `<table>`, with
    a column for each property of an element. If you take a look inside the `table-data.js`
    file, you'll see the properties of each element in the array match the `<th>`
    elements.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的 HTML 几乎毫无特色，只是一个简单的`<table>`，每个元素的属性都有一个列。如果你查看`table-data.js`文件，你会看到数组中每个元素的属性与`<th>`元素匹配。
- en: The first interesting thing is the `data-bind` attribute we added to the `<tbody>`
    element. This is the mechanism Knockout uses to implement declarative binding.
    This is how we connect elements in the View to properties of the ViewModel.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件有趣的事情是我们添加到`<tbody>`元素的`data-bind`属性。这是 Knockout 用于实现声明式绑定的机制。这是我们将 View
    中的元素与 ViewModel 属性连接起来的方式。
- en: The value of the `data-bind` attribute consists of two parts – the binding and
    the ViewModel property to connect to. The first part is the binding, which we
    set to `foreach`. This is one of Knockout's flow-control bindings, and acts in
    a similar way to a standard `for` loop in regular JavaScript.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`data-bind`属性的值由两部分组成 - 绑定和要连接到的 ViewModel 属性。第一部分是绑定，我们将其设置为`foreach`。这是 Knockout
    的流程控制绑定之一，其行为方式类似于常规 JavaScript 中的标准`for`循环。'
- en: The second part of the binding is the ViewModel property to bind to. The one
    property our ViewModel has at present is `elements`, which contains an observable
    array. The `foreach` binding maps to an array and then renders any child elements
    it has for each item in the array.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定的第二部分是要绑定到的 ViewModel 属性。我们目前的 ViewModel 只有一个属性，即`elements`，其中包含一个可观察数组。`foreach`绑定将映射到一个数组，然后为数组中的每个项渲染任何子元素。
- en: The child elements that this element has are a `<tr>` and a series of `<td>`
    elements, so we'll get a row in the table for each item in the `elements` array.
    In order to populate the `<td>` elements with content we'll use another Knockout
    binding – the `text` binding.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此元素的子元素是一个`<tr>`和一系列`<td>`元素，因此我们将在`elements`数组中的每个项中获得一个表格行。为了将`<td>`元素填充内容，我们将使用另一个
    Knockout 绑定 - `text`绑定。
- en: The `text` binding binds to a single observable property, so we have a `<td>`
    that is bound to each property in the objects within the `elements` array. The
    text of each `<td>` will be set to the value of each property in the current array
    item.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`text`绑定绑定到单个可观察属性，因此我们有一个`<td>`绑定到`elements`数组中每个对象的每个属性。每个`<td>`的文本将设置为当前数组项中每个属性的值。'
- en: The CSS we added at the end of the task was purely for presentational purposes
    and contains nothing relevant to Knockout or jQuery. At this point we should be
    able to run the page in a browser and see the data from `table-data.js` displayed
    in a neat `<table>`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在任务结束时添加的 CSS 纯粹是为了表现目的，与 Knockout 或 jQuery 无关。此时，我们应该能够在浏览器中运行页面，并在一个整洁的`<table>`中看到来自`table-data.js`的数据显示出来。
- en: Classified Intel
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机密情报
- en: The binding between elements of the View and properties of the ViewModel are
    at the heart of Knockout. The ViewModel is a simplified version of the state of
    the UI. Because of the bindings, any time the underlying ViewModel changes, the
    view will be updated to reflect those changes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: View元素和ViewModel属性之间的绑定是Knockout的核心。ViewModel是UI状态的简化版本。由于绑定，每当底层ViewModel发生更改时，视图将更新以反映这些更改。
- en: So if we programmatically add a new element object to the observable array,
    the `<table>` will instantly be updated to show the new element. Similarly, if
    we remove an item from the array in the ViewModel, the corresponding `<tr>` will
    be immediately removed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们以编程方式向可观察数组添加一个新的元素对象，则`<table>`将立即更新以显示新元素。类似地，如果我们从ViewModel中的数组中删除一个项目，则相应的`<tr>`将立即被删除。
- en: Sorting the table
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对表格进行排序
- en: In this task we can change the `<th>` elements so that they are clickable. When
    one of them is clicked, we can then sort the table rows by the column that was
    clicked.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们可以更改`<th>`元素，使其可点击。当其中一个被点击时，我们可以按照被点击的列对表格行进行排序。
- en: Engage Thrusters
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'First of all we can update the `<tr>`and the `<th>` elements that it contains
    in `sortable-table.html`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以更新`sortable-table.html`中包含的`<tr>`和`<th>`元素：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next we can add some new observable properties to our ViewModel in `sortable-table.js`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在`sortable-table.js`中的ViewModel中添加一些新的可观察属性：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We also add a new method called `sort`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个名为`sort`的新方法：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Lastly, we can add some additional CSS to style our clickable `<th>` elements:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以添加一些额外的CSS来样式化我们可点击的`<th>`元素：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Objective Complete - Mini Debriefing
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 小结
- en: We first updated our HTML with some more bindings. First we added the `click`
    binding using the `data-bind` attribute on the parent `<tr>`. The `click` binding
    is used to add an event handler to any HTML element.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用更多的绑定更新了我们的HTML。首先，我们使用`data-bind`属性在父级`<tr>`上添加了`click`绑定。`click`绑定用于向任何HTML元素添加事件处理程序。
- en: The handler function can be a ViewModel method or any regular JavaScript function.
    In this example, we bound the handler to a function called `sort`, which will
    be a method of our ViewModel.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序函数可以是ViewModel方法或任何常规JavaScript函数。在这个示例中，我们将处理程序绑定到一个名为`sort`的函数，它将是我们ViewModel的一个方法。
- en: Note also that we've added the binding to the parent `<tr>` and not the individual
    `<th>` elements. We can exploit the fact that events bubble up to their parent
    elements to implement a very simple and computationally cheap form of event delegation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将绑定添加到父级`<tr>`而不是各个`<th>`元素。我们可以利用事件向上冒泡的特性来实现一种非常简单且计算成本低廉的事件委派形式。
- en: We also added the `css` binding to each of the `<th>` elements. The `css` binding
    is used to add a class name to an element. So the class name that the element
    acquires depends on the ViewModel property it is bound to. Each of our `<th>`
    elements is bound to a different ViewModel property and will be used as part of
    our sorting.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为每个`<th>`元素添加了`css`绑定。`css`绑定用于向元素添加类名。因此，元素获取的类名取决于它绑定到的ViewModel属性。我们的每个`<th>`元素都绑定到不同的ViewModel属性，并将用作我们排序的一部分。
- en: 'Next we made some changes to our script file. First we added a series of new
    observable properties. We added the following properties:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们对我们的脚本文件进行了一些更改。首先，我们添加了一系列新的可观察属性。我们添加了以下属性：
- en: '`nameOrder`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nameOrder`'
- en: '`numberOrder`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numberOrder`'
- en: '`symbolOrder`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`symbolOrder`'
- en: '`weightOrder`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weightOrder`'
- en: '`discoveredOrder`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`discoveredOrder`'
- en: Each of these properties is observable, which is required to allow the `<th>`
    element's class names to update automatically when any of the properties change.
    Each of the properties are initially set to the string `ascending` so this is
    the class name that each `<th>`element will be given.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性中的每一个都是可观察的，这是必需的，以便当任何一个属性发生更改时，`<th>`元素的类名会自动更新。每个属性最初都设置为字符串`ascending`，因此每个`<th>`元素都将被赋予这个类名。
- en: Sorting the data
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对数据进行排序
- en: Next we added our `sort` method to the ViewModel. Because this method is part
    of an event-handling binding (the `click` binding we added to the `<tr>`), the
    method will automatically be passed two arguments – the ViewModel as the first,
    and an event object as the second. We can make use of both of these within the
    function.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将我们的`sort`方法添加到ViewModel中。因为此方法是事件处理绑定的一部分（我们添加到`<tr>`的`click`绑定），所以该方法将自动传递两个参数
    - 第一个是ViewModel，第二个是事件对象。我们可以在函数中使用这两个参数。
- en: First we define some variables. We use jQuery to select whichever `<th>` element
    was clicked. We can determine this using the `target` property of the event object,
    which we wrap in jQuery so that we can call jQuery methods on the selected element.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们定义一些变量。我们使用jQuery选择被点击的任何`<th>`元素。我们可以使用事件对象的`target`属性来确定这一点，然后我们用jQuery包装它，以便我们可以在所选元素上调用jQuery方法。
- en: We can then get the `data-bind` attribute of the element using jQuery's `attr()`
    method, which we can then split on the space between the binding name and the
    property it is bound to. So for example, if we were to click on the `<th>` containing
    **Name** in a browser our first variable, `orderProp`, would be set to `nameOrder`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用jQuery的`attr()`方法获取元素的`data-bind`属性，然后根据绑定名称和绑定到的属性之间的空格拆分它。所以例如，如果我们在浏览器中点击包含**Name**的`<th>`，我们的第一个变量`orderProp`将被设置为`nameOrder`。
- en: The next variable `orderVal` is set to the current value of the ViewModel property
    that the `orderProp` variable points to. Knockout provides a simple way to get
    or set any ViewModel property programmatically.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个变量`orderVal`被设置为ViewModel属性的当前值，`orderProp`变量指向的属性。Knockout提供了一种简单的方法来以编程方式获取或设置任何ViewModel属性。
- en: 'If we want to get the value of a property, we call the property as if it were
    a function, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想获取属性的值，我们将其调用为函数，如下所示：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we want to set the property, we still call it like a function, but we pass
    in the value we would like to set as an argument:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想设置属性，我们仍然像调用函数一样调用它，但是我们将要设置的值作为参数传递：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So, continuing the example of when the `<th>` containing **Name** is clicked,
    the `orderVal` variable would have the value `ascending`, because this is the
    default value of each of the `…Order` properties. Notice how we get the correct
    value using the `orderProp` variable and square-bracket notation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，继续上述点击包含**Name**的`<th>`的例子，`orderVal`变量将具有值`ascending`，因为这是每个`…Order`属性的默认值。请注意我们如何使用`orderProp`变量和方括号表示法获取正确的值。
- en: Our last variable, `comparatorProp`, is convenient to store the property of
    the objects within the `elements` array that we are going to sort by. Our ViewModel
    properties have the string `Order` at the end of them, but the properties inside
    the objects in the `elements` array do not. So to get the correct property we
    just have to split the string on the uppercase `O` and take the first item from
    the array returned by `split()`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一个变量`comparatorProp`很方便地存储我们将要根据其对`elements`数组中的对象进行排序的属性。我们的ViewModel属性在末尾有字符串`Order`，但是`elements`数组中的对象内部的属性没有。因此，为了获取正确的属性，我们只需要在大写`O`上拆分字符串，并从`split()`返回的数组中取第一个项目。
- en: observableArray
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: observableArray
- en: Next we use the `sort()` method to perform the sort. It looks like we're using
    JavaScript's regular `sort()` function for this, but actually, we aren't. Don't
    forget, the `elements` array isn't just a regular array; it's an **observableArray**,
    so while we could get the underlying array out of the element's `viewModel` property,
    and then call the regular JavaScript `sort()` function on it, Knockout gives us
    a better way.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们使用`sort()`方法进行排序。看起来我们在使用JavaScript的普通`sort()`函数，但实际上我们并不是。不要忘记，`elements`数组不只是一个普通数组；它是一个**observableArray**，因此虽然我们可以从元素的`viewModel`属性中获取基础数组，然后在其上调用普通的JavaScript`sort()`函数，但Knockout提供了更好的方法。
- en: Knockout provides a range of standard array functions from JavaScript that we
    can call on observable arrays. For the most part these work in very similar ways
    to their original JavaScript counterparts, but it's almost always better to use
    the Knockout variants where possible because they are better supported across
    browsers, especially legacy browsers, than the original JavaScript versions. Some
    of the Knockout methods also give us little extra bits of functionality or convenience
    too.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout提供了一系列可以在observable数组上调用的标准JavaScript数组函数。在很大程度上，这些函数的工作方式与它们的原始JavaScript对应函数非常相似，但是尽可能使用Knockout变体通常更好，因为它们在浏览器中得到了更好的支持，特别是传统浏览器，比原始JavaScript版本。一些Knockout方法还为我们提供了一些额外的功能或便利。
- en: One example of this is with Knockout's `sort()` method. This isn't the reason
    we've used the method here, but it is an example of how Knockout can improve the
    original JavaScript function.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个例子是使用Knockout的`sort()`方法。这并不是我们在这里使用该方法的原因，但这是Knockout如何改进原始JavaScript函数的一个例子。
- en: JavaScript's built-in default `sort()` function does not sort numbers very well,
    because it automatically converts numbers into strings and then performs the sort
    based on the string instead of the number, leading to results that we do not expect.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript内置的默认`sort()`函数对数字的排序效果不是很好，因为它会自动将数字转换为字符串，然后根据字符串而不是数字进行排序，导致我们得到意料之外的结果。
- en: Knockout's `sort()` method does not do this, and can sort arrays of strings
    or numbers equally as successfully. We don't know at this point whether we'll
    be sorting strings, numbers, or both because the objects in the `elements` array
    contains both strings and numbers, sometimes in the same properties.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout的`sort()`方法不会自动对字符串或数字数组进行排序。在这一点上，我们不知道我们将排序字符串，数字，还是两者兼有，因为`elements`数组中的对象既包含字符串又包含数字，有时在同一个属性中。
- en: Like the JavaScript `sort()` function, a function passed to Knockout's `sort()`
    method will automatically be passed two values, which are the current items to
    sort. Also like JavaScript's `sort()` function, Knockout's `sort()` method should
    return `0` if the values being compared are equal, a negative number if the first
    value is lower, or a positive number if the first value is higher.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 就像JavaScript的`sort()`函数一样，传递给Knockout的`sort()`方法的函数将自动传递两个值，这两个值是当前要排序的项。与JavaScript的`sort()`函数一样，Knockout的`sort()`方法应返回`0`，如果要比较的值相等，返回负数，如果第一个值较小，或者返回正数，如果第一个值较大。
- en: Within the function passed to `sort()`, we first get the values we're going
    to compare from the objects. Both of the values passed to the function will be
    objects, but we only want to compare a property from within each of these objects,
    so we store the properties we'll be comparing in the `propA` and `propB` variables
    for convenience.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在传递给`sort()`的函数中，我们首先从对象中获取我们将要比较的值。传递给函数的两个值都将是对象，但我们只想比较每个对象内部的一个属性，所以我们为了方便起见将要比较的属性存储在`propA`和`propB`变量中。
- en: Comparing different value types
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较不同类型的值
- en: I mentioned a moment ago that sometimes we might be comparing values of different
    types. This could occur if we are sorting by the date column, which may contain
    a number in the form of a year, or it may be the string `Antiquity`, which some
    of the objects have.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到有时我们可能会比较不同类型的值。这可能发生在我们按日期列排序时，其中可能包含形式为年份的数字，或者可能是字符串`Antiquity`，而这些对象中有一些包含这样的值。
- en: So we check whether the two values being compared are of the same type using
    JavaScript's `typeof` operator and a regular `if` statement. If they aren't the
    same type we check whether each property is a string, and if so, convert its value
    to the number `0`. Within the `if` statement, we use JavaScript's ternary statement
    for conciseness.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们使用JavaScript的`typeof`运算符和普通的`if`语句来检查要比较的两个值是否属于相同的类型。如果它们不是相同的类型，我们检查每个属性是否是字符串，如果是，就将其值转换为数字`0`。在`if`语句内部，我们使用JavaScript的三元运算符来简洁地表达。
- en: Checking the order
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查顺序
- en: We then check whether the `orderProp` variable we set a moment ago is set to
    ascending. If it is, we perform a standard sort. We check whether the two values
    are equal and if so, return `0`. If the two values are not equal we can then check
    whether the first value is less than the second and return `-1` if it is, or `1`
    if it isn't. To keep this entire statement on a single line we can use a compound
    ternary.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查我们在一会儿设置的`orderProp`变量是否设置为ascending。如果是，我们执行标准排序。我们检查两个值是否相等，如果是，返回`0`。如果两个值不相等，我们可以检查第一个值是否小于第二个值，如果是，返回`-1`，如果不是，返回`1`。为了将整个语句保持在一行上，我们可以使用复合的三元运算符。
- en: If the order is not `ascending`, it must be `descending`, so we can perform
    a descending sort instead. The code for this is almost identical, except that
    we return `1` if the first value is less than the second value, and `-1` if not,
    the reverse of the statement in the first branch of the conditional.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果顺序不是`ascending`，那么必须是`descending`，所以我们可以执行降序排序。这段代码几乎与之前的代码相同，只是如果第一个值小于第二个值，我们返回`1`，如果不是，我们返回`-1`，这与条件语句的第一个分支相反。
- en: We then need to update the value of the `…Order` property for the column we
    have just sorted. This piece of code acts like a simple toggle switch – if the
    value is currently set to `ascending`, we set it to `descending`. If it's set
    to `descending`, we simply set it to `ascending`. The behavior that this allows
    is that when a `<th>` element is clicked for the first time, it will perform the
    default ascending sort. If it is clicked a second time, it will perform a descending
    sort.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要更新我们刚刚排序过的列的`…Order`属性的值。这段代码的作用类似于一个简单的开关 - 如果值当前设置为`ascending`，我们将其设置为`descending`。如果它设置为`descending`，我们只需将其设置为`ascending`。这种行为允许的是，当单击`<th>`元素第一次时，它将执行默认的升序排序。如果再次单击它，它将执行降序排序。
- en: Lastly we want to reset any other `…Order` properties of our ViewModel if they
    have been changed. We use a simple JavaScript `for in` loop to iterate over the
    properties of our ViewModel. For each property we check whether it contains the
    string `Order`, and that it is not the property that we've just updated.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们的ViewModel的其他`…Order`属性已更改，我们希望重置它们。我们使用一个简单的JavaScript `for in`循环来迭代我们的ViewModel的属性。对于每个属性，我们检查它是否包含字符串`Order`，以及它是否不是我们刚刚更新的属性。
- en: Provided both of these conditions pass, we reset the value of the current property
    to the default value `ascending`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两个条件都满足，我们将当前属性的值重置为默认值`ascending`。
- en: Adding icons
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加图标
- en: The CSS we added is used to add a little sort icon to each `<th>` element when
    it is hovered. We can exploit the CSS shape technique to create a down pointing
    arrow for ascending, and an up pointing arrow for descending. We also use the
    `:after` CSS pseudo selector to avoid hardcoding a non-semantic element, such
    as `<span>` or similar, to display the shape. Which arrow is display is determined
    by the class name that we bound to the `…Order` properties of our ViewModel.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的CSS用于在悬停时向每个`<th>`元素添加一个小的排序图标。我们可以利用CSS形状技术来创建一个向下指向的箭头，表示升序，和一个向上指向的箭头，表示降序。我们还使用`:after`
    CSS伪选择器来避免硬编码非语义元素，比如`<span>`或类似的元素，来显示形状。显示哪个箭头取决于我们绑定到ViewModel的`…Order`属性的类名。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you've never used CSS shapes before, I'd strongly recommend that you look
    into them because they are a fantastic way of creating icons without requiring
    non-semantic placeholder elements, or HTTP-heavy images. For more information,
    check out the CSS shapes guide at [http://css-tricks.com/examples/ShapesOfCSS/](http://css-tricks.com/examples/ShapesOfCSS/).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前从未使用过CSS形状，我强烈建议您研究一下，因为它们是创建图标的绝佳方法，而无需非语义占位符元素或HTTP重的图像。有关更多信息，请查看 [http://css-tricks.com/examples/ShapesOfCSS/](http://css-tricks.com/examples/ShapesOfCSS/)
    上的CSS形状指南。
- en: 'At this point we should be able to run the page in a browser and click on any
    of the headings once to perform an ascending sort, or click twice to perform a
    descending sort:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们应该能够在浏览器中运行页面，并单击任何一个标题，一次执行升序排序，或者点击两次执行降序排序：
- en: '![Adding icons](img/9106OS_10_02.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![添加图标](img/9106OS_10_02.jpg)'
- en: Setting the page size
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置页面大小
- en: So the sorting functionality we added is pretty awesome. But the `<table>` is
    still quite large and unwieldy – too large in fact to be seen on the page in its
    entirety. So it's perfect for paging.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们添加的排序功能非常棒。但是`<table>`仍然相当大且笨重 - 实际上太大了，无法完整地在页面上显示。所以分页正好适用。
- en: One thing we need to do is determine how many items should constitute a single
    page of data. We could hardcode a value into our script for the number of items
    to show per page, but a better way is to add a facility to the UI so that the
    users can set the number of items to display per page themselves. This is what
    we'll do in this task.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的一件事是确定每页应包含多少项数据。我们可以在脚本中硬编码一个值，表示每页显示的项目数，但更好的方法是添加一个UI功能，让用户可以自己设置每页显示的项目数。这就是我们将在此任务中做的事情。
- en: Engage Thrusters
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'We can start by adding some additional markup. Add the following elements directly
    after the `<tbody>` element:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从添加一些额外的标记开始。直接在`<tbody>`元素之后添加以下元素：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We also need to make a minor change to the `<tbody>` element. It currently
    has a `foreach` binding to the observed array of elements. We''re going to add
    a new property to our ViewModel in a moment and we need to update the binding
    in `sortable-table.html` so that it is linked to this new property:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要对`<tbody>`元素进行一些小改动。它目前具有对观察到的元素数组的`foreach`绑定。我们将在稍后为我们的ViewModel添加一个新属性，然后需要更新`sortable-table.html`中的绑定，以便它链接到这个新属性：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next we can add a few new ViewModel properties in `sortable-table.js`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在 `sortable-table.js` 中添加一些新的 ViewModel 属性：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Lastly, we can add a special new variable known as a **computed observable**.
    This should come after the `vm` variable:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以添加一个特殊的新变量，称为 **computed observable**。这应该在 `vm` 变量之后出现：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Objective Complete - Mini Debriefing
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成目标 - 小结
- en: We started out in this task by adding a `<tfoot>` element containing a row and
    a single cell. Inside the cell is a container for our paging elements. We then
    have a `<label>` and a `<select>` element.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从添加一个包含一个行和一个单元格的 `<tfoot>` 元素开始这项任务。单元格内是用于我们分页元素的容器。然后我们有一个 `<label>` 和一个
    `<select>` 元素。
- en: The `<select>` element contains a few options for showing different numbers
    of items, including an option to see all the data. It also uses Knockout's `value
    data-bind` attribute to link the value of the `<select>` element to a property
    on our ViewModel called `pageSize`. This binding means that any time the `<select>`
    element's value changes, such as when a user makes a selection, the ViewModel
    property will be updated automatically.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`<select>` 元素包含一些选项，用于显示不同数量的项目，包括一个查看所有数据的选项。它还使用 Knockout 的 `value data-bind`
    属性将 `<select>` 元素的值链接到 ViewModel 上的一个名为 `pageSize` 的属性。这种绑定意味着每当 `<select>` 元素的值更改时，例如用户进行选择时，ViewModel
    属性将自动更新。'
- en: This binding goes both ways, so if we were to update the `pageSize` property
    programmatically in our script, the element on the page would automatically be
    updated.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此绑定是双向的，因此如果我们在脚本中以编程方式更新 `pageSize` 属性，则页面上的元素将自动更新。
- en: We then linked the `<tbody>foreach` binding to a new property on our VeiwModel
    called `elementsPaged`. We'll use this new property to store a subset of the items
    in the `elements` array. The actual items in this property will constitute a single
    page of data.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 `<tbody>foreach` 绑定到我们的 ViewModel 上的一个新属性，称为 `elementsPaged`。我们将使用这个新属性来存储
    `elements` 数组中项目的一个子集。该属性中的实际项目将构成数据的单个页面。
- en: Next we added some new properties to the object literal stored in the `vm` variable,
    also known as our ViewModel. These properties include `currentPage`, `pageSize`,
    and `elementsPaged` properties that we just discussed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在存储在 `vm` 变量中的对象字面量中添加了一些新属性，也称为我们的 ViewModel。这些属性包括我们刚刚讨论的 `currentPage`、`pageSize`
    和 `elementsPaged` 属性。
- en: The last thing we do is add a Knockout feature called a computed observable.
    This is an extremely useful facility that lets us monitor one or more variables
    and execute code whenever any of the observables change values.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后要做的是添加一个名为 **computed observable** 的 Knockout 功能。这是一个非常有用的功能，它让我们监视一个或多个变量，并在任何可观察变量更改值时执行代码。
- en: We use the `ko.computed()` method to set up the computed observable as a method
    of the ViewModel, passing in a function as the first argument. The ViewModel is
    passed in as the second argument. We're not within a method attached to our ViewModel
    now, so we need to pass the ViewModel in to the `computed()` method in order to
    have this set to the ViewModel.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `ko.computed()` 方法将计算的 observable 设置为 ViewModel 的一个方法，将函数作为第一个参数传入。ViewModel
    作为第二个参数传入。现在我们不在一个附加到我们的 ViewModel 的方法中，所以我们需要将 ViewModel 传递给 `computed()` 方法，以便将其设置为
    ViewModel。
- en: Within the function passed as the first argument we reference the three new
    ViewModel properties we just added. Any ViewModel properties referenced within
    this function will be monitored for changes and the function invoked whenever
    this occurs.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在作为第一个参数传递的函数中，我们引用了刚刚添加的三个新 ViewModel 属性。在此函数中引用的任何 ViewModel 属性都将被监视变化，并在此发生时调用该函数。
- en: All the function does is check whether the `pageSize()` property is equal to
    the string `all`. If it is, it simply adds all of the objects in the elements
    array to the `elementsPaged` array. It does this by taking a slice of the `elements`
    array that starts at the very first item. When `slice()` is used with a single
    argument it will slice to the end of the array, which is exactly what we need
    to get the entire array.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的全部功能是检查 `pageSize()` 属性是否等于字符串 `all`。如果是，则将元素数组中的所有对象简单地添加到 `elementsPaged`
    数组中。它通过取 `elements` 数组的一个切片来实现这一点，该切片从第一个项目开始。当 `slice()` 与一个参数一起使用时，它将切片到数组的末尾，这正是我们需要获得整个数组的方式。
- en: If `pageSize` does not equal the string `all`, we first need to make sure it's
    an integer. Because this ViewModel property is linked to the `<select>` element
    on the page, sometimes the value might be a string of the number instead of an
    actual number. We can ensure it's always a number by using the `parseInt()` JavaScript
    function on the property and storing it in the variable `pagesize` for use throughout
    the rest of the function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`pageSize`不等于字符串`all`，我们首先需要确保它是一个整数。因为这个 ViewModel 属性与页面上的`<select>`元素相关联，有时值可能是一个数字的字符串而不是实际的数字。我们可以通过在属性上使用`parseInt()`
    JavaScript 函数并将其存储在变量`pagesize`中，在函数的其余部分中使用它来确保它始终是一个数字。
- en: Next we need to determine what the start index passed as the first argument
    to `slice()` should be. To work this out we just multiply the value of the `pageSize`
    property by the `currentPage` property, which is initially set to `0`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确定传递给`slice()`作为第一个参数的起始索引应该是什么。要解决此问题，我们只需将`pageSize`属性的值乘以最初设置为`0`的`currentPage`属性的值。
- en: We can then populate the `elementsPaged` array with a slice of the `elements`
    array starting at the `startIndex` value we just determined and ending at the
    `endIndex` value, which will be the `startIndex` plus the number of items per
    page.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`elements`数组的一个片段来填充`elementsPaged`数组，该片段从我们刚刚确定的`startIndex`值开始，到`endIndex`值结束，该值将是`startIndex`加上每页项目数。
- en: When we run the page in our browser, the `<select>` box will initially have
    the value 10 set, which will trigger our computed observable, selecting the first
    10 items in the `elements` array, and display them in the `<table>`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中运行页面时，`<select>`框将最初设置为值10，这将触发我们的计算可观察到的行为，选择`elements`数组中的前10个项目，并在`<table>`中显示它们。
- en: We should find that we can use the `<select>` to change how many items are displayed
    dynamically.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该发现，我们可以使用`<select>`来动态更改显示的条目数量。
- en: Classified Intel
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机密情报
- en: In this task we used the `slice()` Knockout method. You may have thought that
    we were using JavaScript's native `Array.slice()` method, but actually we were
    using the Knockout version and there's an easy way to spot this.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在此任务中，我们使用了`slice()` Knockout 方法。您可能认为我们使用的是 JavaScript 的原生`Array.slice()`方法，但实际上我们使用的是
    Knockout 版本，而且有一种简单的方法来识别它。
- en: Usually when we want to get the value inside an observable property, we invoke
    the property like a function. So when we wanted to get the `pageSize` property
    of the ViewModel, we used `this.pageSize()`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们想要获取可观察属性内部的值时，我们会像调用函数一样调用属性。因此，当我们想要获取 ViewModel 的`pageSize`属性时，我们使用了`this.pageSize()`。
- en: When we called the `slice()` method however, we didn't invoke the elements property
    like a function, so the actual array within the property wasn't returned. The
    `slice()` method was called directly on the observable.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们调用`slice()`方法时，我们没有像调用函数那样调用元素属性，因此实际数组在属性内部并未返回。`slice()`方法直接在可观察对象上调用。
- en: Knockout re-implements a range of native methods that can be called on arrays,
    including `push()`, `pop()`, `unshift()`, `shift()`, `reverse()`, and `sort()`,
    which we used in the last task.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout 重新实现了一系列可以在数组上调用的原生方法，包括`push()`、`pop()`、`unshift()`、`shift()`、`reverse()`和`sort()`，我们在上一个任务中使用了它们。
- en: It's recommended to use the Knockout versions of these methods rather than the
    native JavaScript ones because they are supported across all browsers that Knockout
    supports, and so that dependency tracking is maintained and the UI of your application
    is kept in sync.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用这些方法的 Knockout 版本而不是原生 JavaScript 版本，因为它们在 Knockout 支持的所有浏览器中都受到支持，从而保持了依赖跟踪并保持了应用程序的
    UI 同步。
- en: Adding Previous and Next Links
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加上一页和下一页链接
- en: At this point our page is now only displaying the first 10 items. We need to
    add an interface that allows the user to navigate to other pages of data. In this
    task we can add **Next** and **Previous** links so that the pages can be viewed
    in a linear sequence.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的页面现在只显示前10个项目。我们需要添加一个界面，允许用户导航到其他数据页面。在此任务中，我们可以添加**上一页**和**下一页**链接，以便以线性顺序查看页面。
- en: Engage Thrusters
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'We''ll start out once again by adding the HTML component of this feature. Directly
    after the `<select>` element within the `<tfoot>` element, add the following new
    markup:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次从添加此功能的 HTML 组件开始。在`<tfoot>`元素中的`<select>`元素之后直接添加以下新标记：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next we can add some new methods to our ViewModel. These can go directly after
    the `sort` method that we added earlier in `sortable-table.js`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以向我们的 ViewModel 添加一些新方法。这些可以直接添加到我们之前在`sortable-table.js`中添加的`sort`方法后面：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Lastly, we can add a little CSS to tidy up the new elements we added in this
    part, as well as the ones we added in the last part by adding the following code
    to `sortable-table.css`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过将以下代码添加到 `sortable-table.css` 来为此部分添加的新元素以及上一部分添加的元素添加一些 CSS 以进行整理：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Objective Complete - Mini Debriefing
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 小结
- en: We started out by adding a `<nav>` element containing two `<a>` elements to
    the page, which make the **Previous** and **Next** links. We add data bindings
    to the links that connect the **Previous** link to the `goToPrevPage()` method,
    and the **Next** link to the `goToNextPage()` method.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过向页面添加包含两个 `<a>` 元素的 `<nav>` 元素来开始，这些元素制作了**上一页**和**下一页**链接。我们为链接添加了数据绑定，将**上一页**链接连接到
    `goToPrevPage()` 方法，将**下一页**链接连接到 `goToNextPage()` 方法。
- en: We then added a small utility method, as well as these two new methods to our
    ViewModel. Our methods don't have to accept parameters like the `sort()` method
    did, and we can access our ViewModel within the methods using `this`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加了一个小的实用方法，以及这两个新方法到我们的 ViewModel。我们的方法不必像 `sort()` 方法那样接受参数，我们可以在方法中使用
    `this` 访问我们的 ViewModel。
- en: The first method `totalPages()` simply returns the total number of pages by
    dividing the total number of items in the `elements` array by the value held in
    the `pageSize` property.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法 `totalPages()` 简单地通过将 `elements` 数组中的总项目数除以 `pageSize` 属性中保存的值来返回总页数。
- en: Sometimes the `currentPage` property will equal the string `all`, which will
    return `NaN` when used in a Math operation, so we can add the double-bar OR (`||`)
    to return `1` when this is the case. We also use `Math.ceil()` to ensure we get
    a whole number, so when there are 11.8 pages of data (the default based on 10
    items per page), the method will return 12\. The `Ceil()` function will always
    round up, because we can't have part of a page.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有时 `currentPage` 属性将等于字符串 `all`，当在数学运算中使用时将返回 `NaN`，因此我们可以添加双竖线 OR (`||`) 来在这种情况下返回
    `1`。我们还使用 `Math.ceil()` 来确保我们获得一个整数，因此当有 11.8 页的数据时（基于每页 10 个项目的默认值），该方法将返回 12。`Ceil()`
    函数将总是向上舍入，因为我们不能有部分页面。
- en: The `createPage` computed observable that we added in the last task actually
    does most of the work for us. The next two methods simply update the `currentPage`
    property, which in turn automatically triggers the `createPage()` computed observable.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个任务中添加的 `createPage` 计算的可观察对象实际上为我们做了大部分工作。接下来的两个方法只是更新了 `currentPage`
    属性，这将自动触发 `createPage()` 计算的可观察对象。
- en: In the `goToNextPage()` method we first check that we aren't already on the
    last page, and as long as we aren't, we increase the `currentPage` property by
    one. We use the `totalPages()` method when we check whether we're on the last
    page.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `goToNextPage()` 方法中，我们首先检查我们是否已经在最后一页，只要我们不是，我们就将 `currentPage` 属性增加一。在我们检查是否在最后一页时，我们使用
    `totalPages()` 方法。
- en: The `goToPrevPage()` method is just as simple. This time we check that we aren't
    already on the first page of data (if `currentPage` is equal to `0`), and if we
    aren't, we decrease the value of `currentPage` by `1`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`goToPrevPage()` 方法同样简单。这次我们检查我们是否已经在数据的第一页（如果 `currentPage` 等于 `0`），如果不是，我们将
    `currentPage` 的值减去 `1`。'
- en: The tiny bit of CSS we added simply tidies up the elements in the `<tfoot>`
    element, allowing them to float alongside each other, and makes the new links
    a little bigger than they would be by default.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的少量 CSS 只是整理了 `<tfoot>` 元素中的元素，使它们能够与彼此并排浮动，并使新链接比默认情况下稍大一些。
- en: Adding numerical page links
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加数字页面链接
- en: We can now add as many links as are required in order to allow the user to visit
    any of the pages directly. These are the numerical page links that link to each
    single page directly.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加任意数量的链接，以便允许用户直接访问任何页面。这些是直接链接到每个单独页面的数字页面链接。
- en: Engage Thrusters
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'First of all we need to add a new observable property to our ViewModel, directly
    after the existing observables in `sortable-table.js`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的 ViewModel 中的现有可观察属性之后直接添加一个新的可观察属性，在 `sortable-table.js` 中：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After this we can add a new method to our ViewModel. This can be added after
    the `goToPrevPage()` method, within the `vm` object literal:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们可以向我们的 ViewModel 中添加一个新方法。这可以添加在 `goToPrevPage()` 方法之后，位于 `vm` 对象字面量内部：
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Don''t forget to add a comma after the `goToPrevPage()` method! We can then
    add a new computed observable, in the same way that we have previously. This can
    come directly after the `createPage` computed observable that we added in the
    last task:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在`goToPrevPage()`方法后面加上逗号！然后我们可以添加一个新的计算可观察属性，方式与我们之前添加的一样。这可以直接放在我们在上一个任务中添加的`createPage`计算可观察属性之后：
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we need to add some new markup to the HTML page. This should be added
    between the **Previous** and **Next** links that we added in the last task:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在 HTML 页面中添加一些新的标记。这应该在我们在上一个任务中添加的**Previous**和**Next**链接之间添加：
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Lastly we can add a little CSS to position the new elements in `sortable-table.css`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以添加一点 CSS 来定位`sortable-table.css`中的新元素：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Objective Complete - Mini Debriefing
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 小结。
- en: First of all we added a new `pages` observable array to our ViewModel. We didn't
    give it an array to begin with; we'll add this dynamically at the appropriate
    time.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在 ViewModel 中添加了一个新的`pages`可观察数组。一开始我们没有给它一个数组；我们会在合适的时候动态添加。
- en: The computed observable we added as `createPages` is used to build an array
    where each item in the array represents a page of data. We can get the total number
    of pages using our `totalPages()` method as we did before.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的计算可观察属性`createPages`用于构建一个数组，其中数组中的每个项目表示数据的一个页面。我们可以像之前一样使用我们的`totalPages()`方法获取总页数。
- en: Once this has been determined, which will be whenever the `pageSize()` observable
    changes, we can then populate the observable array that we just added.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了这一点，也就是每当`pageSize()`可观察属性发生变化时，我们就可以填充刚刚添加的可观察数组。
- en: The objects added to the array are created using a simple `for` loop to create
    an object and push it into an array. Once we've built an object for each page
    we can then set the array as the value of the `pages` property.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到数组中的对象是使用简单的`for`循环创建的，以创建一个对象并将其推入数组中。一旦我们为每个页面构建了一个对象，我们就可以将数组设置为`pages`属性的值。
- en: Each object we create has just a single property, called `num`, the value of
    which is the current value of the `x` counter variable used by the loop.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的每个对象都只有一个属性，称为`num`，其值是循环中使用的`x`计数器变量的当前值。
- en: In the HTML page, we used the `foreach` data binding to iterate over the array
    we added to the `pages` array. For each object in the array, we create an `<li>`
    element and an `<a>` element. The `<a>` has two bindings specified using the `data-bind`
    attribute.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTML 页面中，我们使用`foreach`数据绑定来迭代我们添加到`pages`数组中的数组。对于数组中的每个对象，我们创建一个`<li>`元素和一个`<a>`元素。`<a>`使用`data-bind`属性指定了两个绑定。
- en: The first is the `text` binding, which sets the text of the element. In this
    case, we set the text to be the value of the `num` property that each object has.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是`text`绑定，它设置元素的文本。在这种情况下，我们将文本设置为每个对象具有的`num`属性的值。
- en: The second binding is a click binding, which calls a method called `changePage`.
    However, within the `foreach` binding, the context is set to the current object
    in the `pages` array, so we need to use the special `$parent` context property
    to access the method on the ViewModel.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个绑定是一个点击绑定，它调用一个名为`changePage`的方法。然而，在`foreach`绑定中，上下文被设置为`pages`数组中的当前对象，所以我们需要使用特殊的`$parent`上下文属性来访问
    ViewModel 上的方法。
- en: Lastly we added the `changePage` method used by the `<a>` elements. All we need
    to do in this simple method is get the text of the element that was clicked, remove
    `1` from its value because the actual page numbers are zero-based, and update
    the `curentPage` observable property of our ViewModel. Inside this method for
    some reason the value of `this` is not set to the element that was clicked, as
    we would expect from our encounters with the `sort()` method that we added earlier.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了`changePage`方法，它被`<a>`元素使用。在这个简单的方法中，我们需要做的就是获取被点击元素的文本，从其值中减去`1`，因为实际的页码是从零开始的，并更新我们
    ViewModel 的`curentPage`可观察属性。在这个方法中，由于某种原因，`this`的值并没有设置为被点击的元素，正如我们之前遇到的`sort()`方法所期望的那样。
- en: Because the `<a>` elements that will trigger the `changePage` method are created
    within a `foreach` binding, the first argument passed to `changePage` will be
    the object within the pages array that the `<a>` element is associated with. Luckily
    we can still access the ViewModel using the variable `vm`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因为触发`changePage`方法的`<a>`元素是在`foreach`绑定内创建的，所以传递给`changePage`的第一个参数将是`pages`数组中与`<a>`元素关联的对象。幸运的是，我们仍然可以使用变量`vm`访问
    ViewModel。
- en: The CSS we added simply floats the list items alongside each other, spaces them
    out a little, and sets the color and size of the text.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的 CSS 简单地将列表项浮动在一起，稍微间隔开它们，并设置文本的颜色和大小。
- en: Classified Intel
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机密情报
- en: As well as the `$parent` context property that allows us to access the parent
    object of the ViewModel property being iterated in a `foreach` binding, we can
    also make use of `$data`, which points to the array being iterated.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `$parent` 上下文属性允许我们访问在 `foreach` 绑定中迭代的 ViewModel 属性的父对象之外，我们还可以利用 `$data`，它指向正在迭代的数组。
- en: As well as this, there is also an `$index` property that allows us to access
    the current iteration index, which we could have used in this example, instead
    of setting the `num` property on each object.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，还有一个 `$index` 属性，允许我们访问当前迭代的索引，我们可以在这个示例中使用它，而不是在每个对象上设置 `num` 属性。
- en: Managing class names
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理类名
- en: In this task we can show feedback to the user to describe which page is currently
    being viewed. We can also disable the **Previous** or **Next** links if we're
    on the first or last page of data. We can do all this using a little bit more
    script and some simple CSS.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们可以向用户显示反馈，描述当前正在查看的页面。如果我们在数据的第一页或最后一页，我们也可以禁用 **Previous** 或 **Next**
    链接。我们可以使用更多的脚本和一些简单的 CSS 来完成所有这些。
- en: Engage Thrusters
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'First we need to add another method to our ViewModel, directly after the existing
    ones in `sortable-table.js`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在 `sortable-table.js` 中的现有方法后直接添加另一个方法到我们的 ViewModel 中：
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We then need to call this method from several places in our existing code.
    First, we need to call it at the end of the `createPage()` and `createPages()`
    computed observables, by adding the following code to the end of the last line
    in each function (the line that begins with `this`):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要从我们现有的代码中的几个位置调用这个方法。首先，我们需要在 `createPage()` 和 `createPages()` 计算观察函数的末尾调用它，通过在每个函数的最后一行（以
    `this` 开头的行）添加以下代码：
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, in order to add the initial class names before the table is interacted
    with, we need to call it after the `applyBindings()` method after the ViewModel:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了在与表格交互之前添加初始类名，我们需要在 ViewModel 之后的 `applyBindings()` 方法之后调用它：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Lastly, we can add the additional CSS that I mentioned in the task introduction:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以添加任务介绍中提到的额外 CSS：
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Objective Complete - Mini Debriefing
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 小结
- en: The first thing we did in this task was to add a new method to our ViewModel
    – the `manageClasses()` method. This method is responsible for adding or removing
    the `disabled` class from the **Previous** and **Next** links, and for adding
    the active class to the numbered link corresponding to the current page.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们首先向我们的 ViewModel 添加了一个新方法 - `manageClasses()` 方法。该方法负责向 **Previous**
    和 **Next** 链接添加或移除 `disabled` 类，并向当前页对应的数字链接添加活动类。
- en: Inside the method, we first cache a selector for the containing `<nav>` element
    so that we can access the elements we need to update as efficiently as possible.
    We also get the `curentPage` ViewModel property as we'll be comparing its value
    a few times.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法内部，我们首先缓存包含 `<nav>` 元素的选择器，以便我们能够尽可能高效地访问需要更新的元素。我们还获取 `curentPage` ViewModel
    属性，因为我们将多次比较其值。
- en: We then find the elements that have the `disabled` and `active` classes, and
    remove them. Notice how we use jQuery's `end()` method after removing the `active`
    class to get back to the original `<nav>` selection.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们找到具有 `disabled` 和 `active` 类的元素，并将它们移除。注意我们在移除 `active` 类后如何使用 jQuery 的
    `end()` 方法返回到原始的 `<nav>` 选择。
- en: All we need to do now is to put the classes back onto the appropriate elements.
    If the `currentPage` is `0`, we add the `disabled` class to the first link in
    the `<nav>` using jQuery's `:first-child` selector in conjunction with the `children()`
    method.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要将类重新放回适当的元素上。如果 `currentPage` 是 `0`，我们使用 jQuery 的 `:first-child` 选择器与
    `children()` 方法一起将 `disabled` 类添加到 `<nav>` 中的第一个链接。
- en: Alternatively, if we're on the last page, we add the `disabled` class to the
    last child of the `<nav>` instead, this time using the `:last-child` selector.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们在最后一页，我们将 `disabled` 类添加到 `<nav>` 的最后一个子元素，这次使用 `:last-child` 选择器。
- en: Selecting the element to apply the `active` class to is done easily using the
    jQuery `eq()` method, which reduces a selection of elements down to a single element
    as the specified index. We use the `currentpage` as the index of the element to
    retain in the selection.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 jQuery 的 `eq()` 方法轻松地选择要应用 `active` 类的元素，该方法将元素的选择减少到作为指定索引的单个元素。我们使用 `currentpage`
    作为要在选择中保留的元素的索引。
- en: The CSS was added purely to give the elements with the class names different
    styling so it was easy to see when the classes are added and removed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 仅用于为具有不同样式的类名的元素添加样式，因此可以轻松地看到类何时添加和删除。
- en: When we run the page in a browser now, we should find that the **Previous**
    link is disabled to begin with, and the number `1` is active. If we visit any
    of the pages, that number will gain the `active` class.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在浏览器中运行页面时，我们应该发现**上一页**链接一开始是禁用的，并且数字`1`是活动的。如果我们访问任何页面，该数字将获得 `active` 类。
- en: Resetting the page
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重置页面
- en: Now that we've wired up our numeric paging links, a problem has become apparent.
    Sometimes, when changing the number of items per page, an empty table is displayed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经连接了我们的数字分页链接，一个问题变得明显起来。有时，在更改每页项目数时，将显示空表格。
- en: We can fix this by adding another binding to the `<select>` element that resets
    the current page whenever the `<select>`element's `value` changes.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向 `<select>` 元素添加另一个绑定来修复此问题，该绑定在 `<select>` 元素的 `value` 更改时重置当前页面。
- en: Engage Thrusters
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'First of all we can add the new binding to the HTML. Change the `<select>`
    element so that it appears as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以将新的绑定添加到 HTML 中。将 `<select>` 元素更改为以下内容：
- en: '[PRE26]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we can add the `goToFirstPage()` method to the ViewModel:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将 `goToFirstPage()` 方法添加到 ViewModel 中：
- en: '[PRE27]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Objective Complete - Mini Debriefing
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 迷你总结
- en: First of all we added the `event` binding as a second binding to the `<select>`
    element responsible for setting the number of items per page. The format of this
    binding is slightly different than other bindings we've used in this project.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 `event` 绑定添加为 `<select>` 元素的第二个绑定，负责设置每页项的数量。此绑定的格式与我们在此项目中使用的其他绑定略有不同。
- en: After the name of the binding, `event` in this case, we specify the name of
    the event and the handler to call when the event occurs within curly braces. The
    reason why this format is used is because if we want, we are able to specify multiple
    events and handlers within the braces.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在绑定的名称之后，`event` 在本例中，我们在大括号内指定事件的名称和事件发生时要调用的处理程序。之所以使用此格式是因为如果需要，我们可以在括号内指定多个事件和处理程序。
- en: We then added the new event handler, `goToFirstPage()`, as a method of our ViewModel.
    All we need to do within the handler is set the `currentPage` observable to `0`,
    which will automatically move us back to the first page of results. This will
    occur whenever the `<select>` element's value changes.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将新的事件处理程序 `goToFirstPage()` 添加为 ViewModel 的方法。在处理程序中，我们只需要将 `currentPage`
    可观察值设置为 `0`，这将自动将我们移回到结果的第一页。每当 `<select>` 元素的值发生变化时，都会发生这种情况。
- en: Filtering the table
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对表进行过滤
- en: To finish off the project we can add filtering so that the different types of
    elements can be shown. The data for the table contains a column we haven't used
    yet – the `state` of the element (the actual physical element, not an HTML element!)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成项目，我们可以添加过滤器，以便可以显示不同类型的元素。表的数据包含我们尚未使用的列——元素的 `state`（实际物理元素，而不是 HTML 元素！）
- en: In this task, we can add a `<select>` element that allows us to filter elements
    by their state.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在此任务中，我们可以添加一个 `<select>` 元素，以允许我们根据其状态对元素进行过滤。
- en: Engage Thrusters
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'First we need to add a new observable array to the ViewModel, which will be
    used to store objects that represent the different states an element can be:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要向 ViewModel 添加一个新的可观察数组，该数组将用于存储表示元素可能的不同状态的对象：
- en: '[PRE28]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can also add a simple non-observable property to the ViewModel:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以向 ViewModel 添加一个简单的非可观察属性：
- en: '[PRE29]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next we need to populate the new array. We can do this outside of our ViewModel,
    directly after where we call `vm.manageClasses()`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要填充新数组。我们可以在调用 `vm.manageClasses()` 之后直接执行此操作：
- en: '[PRE30]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then we can add the new HTML that will create the `<select>` element used to
    filter the `<table>` data:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以添加新的 HTML，该 HTML 将创建用于过滤 `<table>` 数据的 `<select>` 元素：
- en: '[PRE31]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we need to add a final method to our ViewModel that will actually filter
    the data when a selection is made:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要向 ViewModel 添加一个最终方法，该方法在进行选择时实际过滤数据：
- en: '[PRE32]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Lastly, we can add just a little CSS to `sortable-table.css`, just to tidy
    up the new elements:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以向`sortable-table.css`添加一点CSS，只是为了整理新元素：
- en: '[PRE33]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Objective Complete - Mini Debriefing
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成目标 - 小结
- en: First we added a new observable array called `states` that will be used to contain
    the different states of the elements that make up our data. These states are solid,
    liquid, gas, or unknown.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加了一个名为`states`的新的可观察数组，该数组将用于包含构成我们数据的元素的不同状态。这些状态是固体、液体、气体或未知状态。
- en: We also added a simple property to the ViewModel called `originalElements`,
    which will be used to store the complete collection of elements. This property
    is just a regular object property because we don't need to observe its value.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还向ViewModel添加了一个简单的属性，称为`originalElements`，它将用于存储完整的元素集合。该属性只是一个常规对象属性，因为我们不需要观察其值。
- en: Populating the states array
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 填充状态数组
- en: Next we populate the states array with all of the unique states found in the
    data. We only need to populate this array once, so it can appear outside of the
    ViewModel. We start out by creating an empty array and an empty object.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将状态数组填充为数据中找到的所有唯一状态。我们只需要填充一次这个数组，所以它可以出现在ViewModel之外。我们首先创建一个空数组和一个空对象。
- en: We then add a single item to the array which will be used for the first `<option>`
    element within the `<select>` element and will function as a label before the
    `<select>` box is interacted with.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们向数组添加一个单个项目，该项目将用于`<select>`元素中的第一个`<option>`元素，并在与`<select>`框交互之前作为标签起作用。
- en: We can then use jQuery's `each()` method to iterate the `elements` array. For
    each item in the array (which if you remember, will be an object representing
    a single element) we get its `state` and check whether this is stored in the reference
    object. We can check this using the `hasOwnProperty()` JavaScript function.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用jQuery的`each()`方法迭代`elements`数组。对于数组中的每个项目（如果您记得的话，它将是表示单个元素的对象），我们获取其`state`并检查这是否存储在引用对象中。我们可以使用`hasOwnProperty()`JavaScript函数来检查这一点。
- en: If the state doesn't already exist in the object, we add it. If it does already
    exist, we don't need to do anything. If the object doesn't contain the state,
    we also push the state into the empty array.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态在对象中不存在，我们将其添加。如果已经存在，则我们不需要做任何事情。如果对象不包含该状态，我们还将状态推入空数组。
- en: Once the `each()` loop has finished, we should then have an array that contains
    a single instance of each `state` found in the data, so we can add this array
    as the value of the `states` observable array.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`each()`循环结束，我们应该有一个数组，其中包含数据中找到的每个`state`的单个实例，因此我们可以将此数组添加为`states`可观察数组的值。
- en: Building the <select> box
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建`<select>`框
- en: The underlying markup for the filtering feature is quite straightforward. We
    added a container `<div>` with a couple of class names, a `<label>` and a `<select>`.
    The `<label>` class name is just added for accessibility, we won't display it
    because the first `<option>` of the `<select>` element will function as a label.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤功能的底层标记非常简单。我们添加了一个带有几个类名的容器`<div>`，一个`<label>`和一个`<select>`。`<label>`类名只是为了可访问性而添加的，我们不会显示它，因为`<select>`元素的第一个`<option>`将作为标签。
- en: The `<select>` element has several Knockout bindings. We use the `foreach` binding,
    which is connected to the states array, so once this is populated, the `<option>`
    elements for the `<select>` will be added automatically.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`<select>`元素有几个Knockout绑定。我们使用了`foreach`绑定，它连接到状态数组，因此一旦这个数组被填充，`<select>`的`<option>`元素就会自动添加。'
- en: We also used the `event` binding once again to add a handler for the `change`
    event, which will be fired whenever the `<select>` box is interacted with.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还一次使用了`event`绑定，为`change`事件添加了一个处理程序，每当与`<select>`框交互时就会触发。
- en: Inside the `<select>` element, we add a template for the `<option>` elements.
    Each option will be given the `text` and `value` of the `state` property of the
    current object in the `states` array.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<select>`元素内部，我们为`<option>`元素添加了一个模板。每个选项将被赋予`states`数组中当前对象的`state`属性的`text`和`value`。
- en: Filtering the data
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤数据
- en: We then added the method to our ViewModel responsible for filtering the data
    displayed in the `<table>`. The first thing we do in the method is check that
    the first `<option>` has not been selected, because this is just a label and doesn't
    correlate to a state.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加了负责过滤`<table>`中显示的数据的ViewModel的方法。在方法中，我们首先检查第一个`<option>`是否未被选中，因为这只是一个标签，不对应任何状态。
- en: We can determine this by looking at the `selectedIndex` property of the `target`
    element (`<select>`), which is available in the `originalEvent` object. This itself
    is part of the event object that is passed to our event handler automatically.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看`target`元素(`<select>`)的`selectedIndex`属性来确定这一点，该属性在`originalEvent`对象中可用。这本身是自动传递给我们的事件处理程序的事件对象的一部分。
- en: Because we're going to be changing the `elements` observable array (in order
    to trigger the paging of the filtered elements) we want to store the original
    elements for later. We can store them in the `originalElements` property of the
    ViewModel.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将要更改`elements`可观察数组（以触发对过滤元素的分页），所以我们希望稍后存储原始元素。我们可以将它们存储在ViewModel的`originalElements`属性中。
- en: Next, we need to build a new array that contains only the elements that have
    the `state` that was selected in the `<select>` element. To do this we can create
    an empty array and then iterate over the `elements` array and check the `state`
    of each element. If it matches, we push it into the new array.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要构建一个新数组，其中仅包含具有在`<select>`元素中选择的`state`的元素。为此，我们可以创建一个空数组，然后迭代`elements`数组并检查每个元素的`state`。如果匹配，则将其推入新数组。
- en: We can get the `state` that was selected from the `<select>` element again using
    the event object passed to our event handler. This time we use the `value` property
    of the `target` element in the `originalEvent` object.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次使用传递给我们的事件处理程序的事件对象来获取从`<select>`元素中选择的`state`。这次我们在`originalEvent`对象中使用`target`元素的`value`属性。
- en: Once the new array has been populated, we update the `elements` array so that
    it contains just the new array we have just created, and then set the `currentPage`
    to `0`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦新数组被填充，我们就更新`elements`数组，使其仅包含我们刚刚创建的新数组，然后将`currentPage`设置为`0`。
- en: The filters that we've added are mutually exclusive, so only one filter can
    be applied at any one time. Once a filter has been selected, we want to hide the
    `<select>` box so that another filter cannot be selected.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的过滤器是互斥的，因此一次只能应用一个过滤器。选择过滤器后，我们希望隐藏`<select>`框，以便无法选择另一个过滤器。
- en: We can also create a label that shows which filter is currently being applied.
    This label is made from a `<span>` element which shows the text of the filter,
    and also contains an `<a>` element that can be used to remove the filter and return
    the `<table>` back to its initial state of showing all of the elements.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建一个标签，显示当前正在应用的过滤器。此标签由一个`<span>`元素制成，显示过滤器的文本，并且还包含一个`<a>`元素，可用于删除过滤器并将`<table>`返回到其最初显示所有元素的状态。
- en: We can use jQuery's `on()` method to attach the handler for the `<a>` element
    as soon as it is created and appended to the page. Within the handler, we simply
    set the `elements` property of the ViewModel back to the array saved in the `originalEvents`
    property and again reset the `<table>` back to the first page by setting the `currentPage`
    property to `0`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用jQuery的`on()`方法在创建并附加到页面后立即附加`<a>`元素的处理程序。在处理程序中，我们只需将ViewModel的`elements`属性设置回保存在`originalEvents`属性中的数组，并将`<table>`重新设置为第一页，方法是将`currentPage`属性设置为`0`。
- en: 'We should now find that we can select one of the options in the `<select>`
    box, see just the filtered data and the filter label, then click on the red cross
    sign in the filter label to go back to the initial `<table>`. A filtered selection
    of the data and the filter label is shown in the following screenshot:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该发现，我们可以在`<select>`框中选择其中一个选项，仅查看过滤后的数据和过滤标签，然后单击过滤标签中的红色叉号以返回初始的`<table>`。以下是数据的筛选选择和筛选标签的截图：
- en: '![Filtering the data](img/9106OS_10_03.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![数据过滤](img/9106OS_10_03.jpg)'
- en: Mission Accomplished
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务完成
- en: Our application runs mostly on Knockout functionality, which allows us to easily
    populate dynamic elements with content, add event handlers, and generally manage
    the state of the application. We use jQuery too, mostly in a DOM selection capacity,
    and also occasionally when we wish to use a utility, such as the `$.each()` method
    that we leveraged several times.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序主要依赖Knockout功能运行，它允许我们轻松地将动态元素填充到内容中，添加事件处理程序，并通常管理应用程序的状态。我们也使用jQuery，主要是在DOM选择容量方面，还偶尔使用它来使用实用程序，例如我们多次利用的`$.each()`方法。
- en: It would have been equally as possible to build this application purely using
    jQuery and without using Knockout at all; however, jQuery itself was never designed
    nor intended to be the complete solution to building complex dynamic applications.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 完全可以纯粹使用 jQuery 构建此应用程序，而不使用 Knockout；但是，jQuery 本身从未被设计或打算成为构建复杂动态应用程序的完整解决方案。
- en: What we generally find when we try to build complex dynamic applications using
    jQuery alone, is that our script very quickly becomes a bloated mess of event
    handlers that is neither easy to read, or maintain, or update at a future point.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试仅使用 jQuery 构建复杂动态应用程序时，通常会发现我们的脚本很快变成一堆事件处理程序的混乱代码，既不容易阅读，也不易于维护或在将来更新。
- en: Using Knockout to handle maintaining the state of an application, and using
    jQuery to fulfill the role it was intended for, gives us the ideal toolkit for
    building highly dynamic, data-driven, complex applications using very little code.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Knockout 来处理应用程序状态的维护，并使用 jQuery 来实现它的预期角色，为我们提供了使用非常少的代码构建高度动态、数据驱动的复杂应用程序的理想工具集。
- en: Throughout this example, I've tried to keep individual methods as simple as
    possible and have them do one thing well and one thing only. Keeping individual
    units of functionality isolated in this way helps to keep our code maintainable
    because it is easy to see what each existing function does, and easy to add new
    features without breaking what already exists.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个示例中，我尽量使各个方法尽可能简单，并且让它们只做一件事情。以这种方式将功能单元保持隔离有助于保持代码的可维护性，因为很容易看到每个现有函数的功能，也很容易添加新功能而不会破坏已有的内容。
- en: You Ready To Go Gung HO? A Hotshot Challenge
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你准备好全力以赴了吗？挑战热门的高手？
- en: Knockout makes it easy to build a `<table>` from an array of data, and because
    the data is dynamic, it's easy to edit it or add new items to it, and have the
    data in our application updated. Although the data is stored locally in a file
    in this example, it would be trivial to store the data on the server and populate
    our elements array at page load using a simple AJAX function.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout 可以轻松地从数据数组中构建一个`<table>`，由于数据是动态的，因此很容易编辑它或向其添加新项目，并使应用程序中的数据得以更新。尽管在此示例中数据是存储在本地文件中的，但将数据存储在服务器上并在页面加载时使用简单的
    AJAX 函数填充我们的元素数组是很简单的。
- en: This would be the first thing to do if you wanted to take this example further.
    Once this has been done, why not see if you can make the table cells editable
    so that their values can be changed, or add a feature that allows you to insert
    new rows into the `<table>`. Once you've done this, you'll want to post the new
    data back to the server so that it can be stored permanently.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想进一步学习这个示例，这将是首要任务。完成这个任务后，为什么不试试使表格单元格可编辑，以便可以更改它们的值，或添加一个允许你插入新行到`<table>`的功能。完成这些后，你会想把新数据发送回服务器，以便永久存储。
