<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">RxJS Advanced</h1>
                </header>
            
            <article>
                
<p>We just finished our last chapter that taught us more about what operators exist and how to utilize them effectively. Armed with this knowledge, we will now go into this subject in more depth. We will go from learning about what parts exist, to actually understanding the nature of RxJS. Knowing the nature of RxJS involves understanding more about what makes it tick. To uncover this, we need to cover topics such as what the differences are between hot, warm, and cold Observables; knowing about Subjects and what they are good for; and the sometimes ignored topic of Schedulers.</p>
<p>There are also other aspects of working with Observables that we want to cover, namely, how to deal with errors and how to test your Observables.</p>
<p class="mce-root">In this chapter, you will learn about:</p>
<ul>
<li>Hot, cold, and warm Observables</li>
<li>Subjects: how they differ from Observables, and when to use them</li>
<li>Pipeable operators, a recent addition to the RxJS library, and how they affect how you compose Observables</li>
<li>Marble testing, the testing machinery in place that helps you with testing your Observables</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hot, cold, and warm Observables</h1>
                </header>
            
            <article>
                
<p>There are hot, cold, and warm Observables. What do we actually mean by that? For starters, let's say that most things you will deal with are cold Observables. Not helping? If we say that cold Observables are lazy, does that help? No? OK, let's talk about Promises for a second. Promises are hot. They are hot because when we execute their code, it happens straight away. Let's see an example of that:</p>
<pre>// hot-cold-warm/promise.js<br/><br/>function getData() {<br/>  return new Promise(resolve =&gt; {<br/>    console.log("this will be printed straight away");<br/>    setTimeout(() =&gt; resolve("some data"), 3000); <br/>  });<br/>}<br/><br/>// emits 'some data' after 3 seconds<br/>getData().then(data =&gt; console.log("3 seconds later", data));</pre>
<p>If you come from a non-RxJS background, you will most likely, at this point, think: OK, yes, that's what I expected. This is the point we are trying to make, though: Calling <kbd>getData()</kbd> makes your code run straight away. This differs from RxJS in the sense that similar RxJS code will actually not run until there is a listener/subscriber that cares about the result. RxJS answers the old philosophical question: Does a tree make a sound when it falls in the forest if no one is there to listen? In the case of Promises, it does. In the case of an Observable, it doesn't. Let's clarify what we just said with a similar code example using RxJS and Observables:</p>
<pre>// hot-cold-warm/observer.js<br/><br/>const Rx = require("rxjs/Rx");<br/><br/>function getData() {<br/>  return Rx.Observable(observer =&gt; {<br/>    console.log("this won't be printed until a subscriber exists");<br/>    setTimeout(() =&gt; {<br/>      observer.next("some data");<br/>      observer.complete();<br/>    }, 3000);<br/>  });<br/>}<br/><br/>// nothing happens<br/>getData();</pre>
<p>In RxJS, code like this is considered cold, or lazy. We need a subscriber for something to actually happen. We can add a subscriber like so:</p>
<pre>// hot-cold-warm/observer-with-subscriber<br/><br/>const<span> Rx </span><span>=</span><span> require("</span><span>rxjs/Rx"</span><span>);<br/></span><br/>function<span> getData() {<br/></span>  return<span> Rx.Observable.create(observer </span><span>=&gt;</span><span> {<br/></span>    console.log(<span>"this won't be printed until a subscriber exists"</span><span>);<br/></span>    <br/>    setTimeout(() <span>=&gt;</span><span> {<br/></span>      observer.next("<span>some data"</span><span>);<br/></span>      observer.complete();<br/>    }, <span>3000</span><span>);<br/></span>  });<br/>}<br/><br/>const<span> </span><span>stream$</span><span> </span><span>=</span><span> </span><span>getData();<br/></span>stream$.subscribe(data<span> </span><span>=&gt;</span><span> </span><span>console.log("</span><span>data from observer"</span><span>, data));</span></pre>
<p>This is a major difference in how Observables behave versus Promises, and it's important to know. This is a cold Observable; so, what is a hot Observable? It would be easy to think, at this point, that a hot Observable is something that executes straight away; there is more to it than that, however. One of the official explanations of what a hot Observable is, is that anything that subscribes to it will share the Producer with other Subscribers. The Producer is what spouts out values internally inside the Observable. This means that the data is shared. Let's look at a cold Observable subscription scenario and contrast that with a hot Observable subscription scenario. We will start with the cold scenario:</p>
<pre>// hot-cold-warm/cold-observable.js<br/>const Rx = require("rxjs/Rx");<br/><br/>const stream$ = Rx.Observable.interval(1000).take(3);<br/><br/>// subscriber 1 emits 0, 1, 2<br/>stream$.subscribe(data =&gt; console.log(data));<br/><br/>// subscriber 2, emits 0, 1, 2<br/>stream$.subscribe(data =&gt; console.log(data));<br/><br/>// subscriber 3, emits 0, 1, 2, after 2 seconds<br/>setTimeout(() =&gt; {<br/>  stream$.subscribe(data =&gt; console.log(data)); <br/>}, 3000);</pre>
<p>In the preceding code, we have three different subscribers that receive their own copy of emitted values. The values start from the beginning, every time we add a new subscriber. That might be expected when looking at the two first subscribers. As for the third one, it is added as a subscriber after two seconds. Yes, even that subscriber receives its own set of values. The explanation is that each subscriber receives its own Producer upon subscription. </p>
<p>With hot Observables, there is just one producer, which means the scenario above will play out differently. Let's write down the code for a hot Observable scenario:</p>
<pre>// hot observable scenario<br/><br/>// subscriber 1 emits 0, 1, 2<br/>hotStream$.subscribe(data =&gt; console.log(data));<br/><br/>// subscriber 2, emits 0, 1, 2<br/>hotStream$.subscribe(data =&gt; console.log(data));<br/><br/>// subscriber 3, emits 2, after 2 seconds<br/>setTimeout(() =&gt; {<br/>  hotStream$.subscribe(data =&gt; console.log(data)); <br/>}, 3000);</pre>
<p>The reason the third subscriber is outputting only the value <kbd>2</kbd> is that the other values have been emitted already. The third subscriber wasn't around to see that happen. On the third value emit, it is around, and that is the reason it receives the value <kbd>2</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making a stream hot</h1>
                </header>
            
            <article>
                
<p>This <kbd>hotStream$</kbd>, how can it be created? You did say that most of the streams being created are cold? We have an operator for doing just that, or two operators, in reality. We can make a stream go from cold to hot by using the operators <kbd>publish()</kbd> and <kbd>connect()</kbd>. Let's start with a cold Observable and add the mentioned operators, like so:</p>
<pre><span>// hot-cold-warm/hot-observable.js<br/><br/>const Rx = require("rxjs/Rx");<br/></span><br/>let<span> </span><span>start</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Date</span><span>();<br/></span>let<span> </span><span>stream</span><span> </span><span>=</span><span> </span><span>Rx</span><span>.</span><span>Observable<br/></span>  .<span>interval</span><span>(</span><span>1000</span><span>)<br/></span>  .<span>take</span><span>(</span><span>5</span><span>)<br/></span>  <strong>.publish</strong><span><strong>();</strong><br/></span><br/>setTimeout<span>(() </span><span>=&gt;</span><span> {<br/></span>  stream<span>.</span><span>subscribe</span><span>(</span><span>data</span><span> </span><span>=&gt;</span><span> {<br/></span>    console<span>.</span><span>log</span><span>(</span><span>`subscriber 1 </span><span>${new</span><span> </span><span>Date</span><span>() </span><span>-</span><span> </span><span>start</span><span>}</span><span>`</span><span>, </span><span>data</span><span>);<br/></span>  });<br/>}, <span>2000</span><span>);<br/></span><br/>setTimeout<span>(() </span><span>=&gt;</span><span> {<br/></span>  stream<span>.</span><span>subscribe</span><span>(</span><span>data</span><span> </span><span>=&gt;</span><span> {<br/></span>    console<span>.</span><span>log</span><span>(</span><span>`subscriber 2 </span><span>${new</span><span> </span><span>Date</span><span>() </span><span>-</span><span> </span><span>start</span><span>}</span><span>`</span><span>, </span><span>data</span><span>)<br/></span>  });<br/>}, <span>3000</span><span>);<br/></span><br/><strong>stream.connect</strong><span><strong>();</strong><br/></span>stream<span>.</span><span>subscribe</span><span>(<br/></span><span>  data</span><span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>log</span><span>(<br/></span><span>    `subscriber 0 - I was here first </span><span>${new</span><span> </span><span>Date</span><span>() </span><span>-</span><span> </span><span>start</span><span>}</span><span>`</span><span>, <br/></span><span>    data<br/></span><span>  )<br/>);</span></pre>
<p>We can see from the preceding code that we create our Observable and instruct it to emit values, one value per second. Furthermore, it should stop after five emitted values. We then call the operator <kbd>publish()</kbd>. This puts us in ready mode. We then set up a few subscriptions to happen after two seconds and three seconds, respectively. This is followed by us calling <kbd>connect()</kbd> on the stream. This will make the stream go from hot to cold. Thereby, our stream starts emitting values, and any subscriber, whenever it starts subscribing, will share a producer with any future subscriber. Lastly, we add a subscriber to happen straight after the call to <kbd>connect()</kbd>. Let's show what the output becomes with the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-247 image-border" src="assets/ee47651c-91e2-4dba-be28-5072cf65726e.png" style=""/></div>
<p>Our first subscriber is emitting values after one second. Our second subscriber kicks in after yet another second. This time its value is <kbd>1</kbd>; it has missed out on the first value. After yet another second, the third subscriber has been attached. The first value that subscriber emits is <kbd>2</kbd>; it missed out on the two first values. We clearly see how the operators <kbd>publish()</kbd> and <kbd>connect()</kbd> help to create our hot Observable, but also how it matters when you start subscribing to a hot Observable.</p>
<p>Why on earth would I want a hot Observable? What's the area for application? Well, imagine you have a live stream, a football game that you stream to many subscribers/viewers. They wouldn't want to see what happens from the first minute of the game when they arrive late, but, rather, where the match is right now, at the time of subscription (when they park themselves in front of the television). So, there definitely exist cases where hot Observables are the way to go.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Warm streams</h1>
                </header>
            
            <article>
                
<p>So far, we have been describing and discussing cold Observables and hot Observables, but there is a third kind: the warm Observable. A warm Observable can be thought of as being created as a cold Observable, but turning into a hot Observable under certain conditions. Let's look at such a case by introducing the <kbd>refCount()</kbd> operator:</p>
<pre><span>// hot-cold-warm/warm-observer.js<br/><br/>const Rx = require("rxjs/Rx");<br/></span><br/>let<span> </span><span>warmStream</span><span> </span><span>=</span><span> </span><span>Rx</span><span>.</span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>1000</span><span>).</span><span>take</span><span>(</span><span>3</span><span>).</span><span>publish</span><span>()<strong>.</strong></span><strong>refCount</strong><span><strong>()</strong>;<br/></span>let<span> </span><span>start</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Date</span><span>();<br/><br/></span>setTimeout<span>(() </span><span>=&gt; </span><span>{<br/></span>  warmStream<span>.</span><span>subscribe</span><span>(</span><span>data </span><span>=&gt;</span><span> {<br/></span>    console<span>.</span><span>log</span><span>(</span><span>`subscriber 1 - </span><span>${new</span><span> </span><span>Date</span><span>() </span><span>-</span><span> </span><span>start</span><span>}</span><span>`</span><span>,</span><span>data</span><span>);<br/></span>  });<br/>}, <span>2000</span><span>);</span></pre>
<p>OK, so we started to use the operator <kbd>publish()</kbd>, and it looks like we are about to use our <kbd>connect()</kbd> operator and that we have a hot Observable, right? Well, yes, but instead of calling <kbd>connect()</kbd>, we call <kbd>refCount()</kbd>. This operator will warm our Observable up so that when the first subscriber arrives, it will act like a cold Observable. OK? That just sounds like a cold Observable, right? Let's have a look at the output first:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-248 image-border" src="assets/db091650-11ef-4095-b8e9-65cd305e6bef.png" style=""/></div>
<p>To answer the preceding question, yes, it's correct that it just behaves like a cold Observable; we aren't missing out on any emitted values. The interesting thing happens when we get a second subscriber. Let's add that second subscriber and see what the effects are:</p>
<pre><span>// hot-cold-warm/warm-observable-subscribers.js<br/><br/>const Rx = require("rxjs/Rx");<br/></span><br/>let<span> </span><span>warmStream</span><span> </span><span>=</span><span> </span><span>Rx</span><span>.</span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>1000</span><span>).</span><span>take</span><span>(</span><span>3</span><span>).</span><span>publish</span><span>().</span><span>refCount</span><span>();<br/></span>let<span> </span><span>start</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Date</span><span>();<br/><br/></span>setTimeout<span>(() </span><span>=&gt; </span><span>{<br/></span>  warmStream<span>.</span><span>subscribe</span><span>(</span><span>data </span><span>=&gt;</span><span> {<br/></span>    console<span>.</span><span>log</span><span>(</span><span>`subscriber 1 - </span><span>${new</span><span> </span><span>Date</span><span>() </span><span>-</span><span> </span><span>start</span><span>}</span><span>`</span><span>,</span><span>data</span><span>);<br/></span>  });<br/>}, <span>1000</span><span>);<br/></span><br/><strong>setTimeout(() =&gt; {<br/>  warmStream.subscribe(data =&gt; {<br/>    console.log(`subscriber 2 - ${new Date() - start}`,data);<br/>  });</strong><br/><strong>}, 3000);</strong></pre>
<p>Our second subscriber is added; now, let's have a look at what the result is:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-249 image-border" src="assets/152ed024-9bf4-44ae-89a5-96fb02bf1d4f.png" style=""/></div>
<p>What we can see from the results above is that the first subscriber is alone in receiving the number <kbd>0</kbd>. When the second subscriber arrives, its first value is <kbd>1</kbd>, which proves the stream has gone from acting like a cold Observable to a hot Observable. </p>
<p>There is another way we can do warm Observables, and that is through using the <kbd>share()</kbd> operator. The <kbd>share()</kbd> operator can be seen as more of a smart operator that allows our Observable to go from cold to hot, depending on the situation. That can be a really great idea sometimes. So, there are the following situations for Observables:</p>
<ul>
<li>Created as a hot Observable; the stream hasn't completed, and none of the subscribers are more than one</li>
<li>Falls back into being a cold Observable; any previous subscription has had time to end before a new subscription arrives</li>
<li>Created as a cold Observable; the Observable itself has had time to complete before the subscription happens</li>
</ul>
<p>Let's try to show in code how the first bullet can happen:</p>
<pre><span>// hot-cold-warm/warm-observable-share.js<br/><br/>const Rx = require("rxjs/Rx");<br/></span><br/>let<span> </span><span>stream$</span><span> </span><span>=</span><span> </span><span>Rx</span><span>.</span><span>Observable</span><span>.</span><span>create</span><span>((</span><span>observer</span><span>) </span><span>=&gt;</span><span> {<br/></span>  let<span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;<br/></span>  let<span> </span><span>id</span><span> </span><span>=</span><span> </span><span>setInterval</span><span>(() </span><span>=&gt;</span><span> {<br/></span>    observer<span>.</span><span>next</span><span>(</span><span>i</span><span>++</span><span>);<br/></span>  }, <span>400</span><span>);<br/></span><br/>  return<span> () </span><span>=&gt;</span><span> {<br/></span>    clearInterval<span>(</span><span>id</span><span>);<br/></span>  };<br/>})<strong>.share</strong><span><strong>()</strong>;<br/></span><br/>let<span> </span><span>sub0</span><span>, </span><span>sub</span><span>;<br/></span><br/>// first subscription happens immediately<br/>sub0<span> </span><span>=</span><span> </span><span>stream$</span><span>.</span><span>subscribe</span><span>(<br/></span>  (<span>data</span><span>) </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>log</span><span>("</span><span>subscriber 0"</span><span>, </span><span>data</span><span>),<br/></span>  err<span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>error</span><span>(</span><span>err</span><span>),<br/></span>  () <span>=&gt;</span><span> </span><span>console</span><span>.</span><span>log</span><span>("</span><span>completed"</span><span>)</span>);<br/><br/>// second subscription happens after 1 second<br/>setTimeout<span>(() </span><span>=&gt;</span><span> {<br/></span>  sub<span> </span><span>=</span><span> </span><span>stream$</span><span>.</span><span>subscribe</span><span>(<br/></span>  (<span>data</span><span>) </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>log</span><span>("</span><span>subscriber 1"</span><span>, </span><span>data</span><span>),<br/></span>  err<span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>error</span><span>(</span><span>err</span><span>),<br/></span>  () <span>=&gt;</span><span> </span><span>console</span><span>.</span><span>log</span><span>("</span><span>completed"</span><span>)</span>);<br/>}, <span>1000</span><span>);<br/></span><br/>// everything is unscubscribed after 2 seconds<br/>setTimeout<span>(() </span><span>=&gt;</span><span> {<br/></span>  sub0<span>.</span><span>unsubscribe</span><span>();<br/></span>  sub<span>.</span><span>unsubscribe</span><span>();<br/></span>}, <span>2000</span><span>);</span></pre>
<p>The preceding code describes a situation where we defined a stream with a subscription that happens straight away. The second subscription happens after one second. Now, according to the definition of the <kbd>share()</kbd> operator, this means that the stream will be created as a cold Observable, but will, at the time of the second subscriber, be turned into a hot Observable, as there is a pre-existing subscriber and the stream has yet to complete. Let's inspect our output to verify that this is the case:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-250 image-border" src="assets/3bef68a1-abca-490f-9274-b52f2a7be5d1.png" style=""/></div>
<p>The first subscriber seems to be clearly alone in the values it gets. When the second subscriber arrives, it seems to share the producer, as it doesn't start from zero, but, rather, it starts listening where the first subscriber is.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Subjects</h1>
                </header>
            
            <article>
                
<p>We are used to using Observables in a certain way. We construct them from something and we start listening to values that they emit. There is usually very little we can do to affect what is being emitted after the point of creation. Sure, we can change it and filter it, but it is next to impossible to add more to our <kbd>Observable</kbd> unless we merge it with another stream. Let's have a look at when we are really in control of what is being emitted when it comes to Observables, using the <kbd>create()</kbd> operator:</p>
<pre>let stream$ = Rx.Observable.create(observer =&gt; {<br/>  observer.next(1);<br/>  observer.next(2);<br/>});<br/><br/>stream$.subscribe(data =&gt; console.log(data));</pre>
<p>We see the Observable acting as a wrapper around the thing that really emits our values, the Observer. In our Observer instance, the Observer is calling <kbd>next()</kbd>, with a parameter to emit values – values that we listen to in our <kbd>subscribe()</kbd> method.</p>
<p>This section is about the Subject. The Subject differs from the Observable in that it can affect the content of the stream after its creation. Let's have a look at just that with the following piece of code:</p>
<pre>// subjects/subject.js<br/><br/>const Rx = require("rxjs/Rx");<br/><br/>let subject = new Rx.Subject();<br/><br/>// emits 1<br/>subject.subscribe(data =&gt; console.log(data));<br/><br/>subject.next(1);</pre>
<p>The first thing we notice is how we just call the constructor instead of using a factory method like <kbd>create()</kbd> or <kbd>from()</kbd> or similar, as we do on an Observable. The second thing we notice is how we subscribe to it on the second line, and only on the last line do we emit values by calling <kbd>next()</kbd>. Why is the code written in this order? Well, if we didn't write it this way and have the <kbd>next()</kbd> call happen as the second thing, our subscription wouldn't be there, and the value would have been emitted straight away. We know two things for sure, though: we are calling <kbd>next()</kbd>, and we are calling <kbd>subscribe()</kbd>, which makes <kbd>Subject</kbd> a double nature. We did mention another thing the <kbd>Subject</kbd> was capable of: changing the stream after creation. Our call to <kbd>next()</kbd> is literally doing that. Let's add a few more calls so we ensure we really get the idea:</p>
<pre>// subjects/subjectII.js<br/><br/>const Rx = require("rxjs/Rx");<br/><br/>let<span> </span><span>subject</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Rx</span><span>.</span><span>Subject</span><span>();<br/></span><br/>// emits 10 and 100 2 seconds after<br/>subject<span>.</span><span>subscribe</span><span>(</span><span>data</span><span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>log</span><span>(</span><span>data</span><span>));<br/></span>subject<span>.</span><span>next</span><span>(</span><span>10</span><span>);<br/></span><br/>setTimeout<span>(() </span><span>=&gt;</span><span> {<br/></span>  subject<span>.</span><span>next</span><span>(</span><span>100</span><span>);<br/></span>}, <span>2000</span><span>);</span></pre>
<p>As we stated before, all the calls we make to the <kbd>next()</kbd> method enable us to affect the stream; we see in our <kbd>subscribe()</kbd> method that every call to <kbd>next()</kbd> leads to the <kbd>subscribe()</kbd> being hit, or, technically, the first function we pass into it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Subject for cascading lists</h1>
                </header>
            
            <article>
                
<p>So, what's the point? Why should we use Subjects over Observables? That's actually a quite deep question. There are many ways of solving most streaming-related problems; problems where it is tempting to use a Subject can often be solved through some other way. Let's have a look at what you could be using it for, though. Let's talk about cascading drop-down lists. What we mean by that is that we want to know what restaurants exist in a city. Imagine, therefore, that we have a drop-down list that allows us to select what country we are interested in. Once we select a country, we should select the city we are interested in from a drop-down list of cities. Thereafter, we get to select from a list of restaurants, and, finally, pick the restaurant that interests us. In the markup, it most likely looks like this:</p>
<pre>// subjects/cascading.html<br/><br/>&lt;<span>html</span><span>&gt;<br/></span>&lt;<span>body</span><span>&gt;<br/></span>  &lt;<span>select</span><span> </span><span>id</span><span>=</span><span>"countries"</span><span>&gt;&lt;/</span><span>select</span><span>&gt;<br/></span>  &lt;<span>select</span><span> </span><span>id</span><span>=</span><span>"cities"</span><span>&gt;&lt;/</span><span>select</span><span>&gt;<br/></span>  &lt;<span>select</span><span> </span><span>id</span><span>=</span><span>"restaurants"</span><span>&gt;&lt;/</span><span>select</span><span>&gt;<br/><br/></span>  &lt;<span>script</span><span> </span><span>src</span><span>=</span><span>"https://unpkg.com/rxjs/bundles/Rx.min.js"</span><span>&gt;</span><span>&lt;</span><span>/</span><span>script</span><span>&gt;<br/></span>  &lt;<span>script</span><span> </span><span>src</span><span>=</span><span>"cascadingIV.js"</span><span>&gt;</span><span>&lt;</span><span>/</span><span>script</span><span>&gt;<br/></span>&lt;/<span>body</span><span>&gt;<br/></span>&lt;/<span>html</span><span>&gt;</span><span><br/></span></pre>
<p>At the start of the application, we haven't selected anything, and the only drop-down list that is selected is the first one, and it is filled with countries. Imagine that we therefore set up the following code in JavaScript:</p>
<pre>// subjects/cascadingI.js<br/><br/>let countriesElem = document.getElementById("countries");<br/>let citiesElem = document.getElementBtyId("cities");<br/>let restaurantsElem = document.getElementById("restaurants");<br/><br/>// talk to /cities/country/:country, get us cities by selected country<br/>let countriesStream = Rx.Observable.fromEvent(countriesElem, "select");<br/><br/>// talk to /restaurants/city/:city, get us restaurants by selected restaurant<br/>let citiesStream = Rx.Observable.fromEvent(citiesElem, "select");<br/><br/>// talk to /book/restaurant/:restaurant, book selected restaurant<br/>let restaurantsElem = Rx.Observable.fromEvent(restaurantsElem, "select");<br/> </pre>
<p>At this point, we have established that we want to listen to the selected events of each drop-down list, and we want, in the cases of countries or cities droplist, filter the upcoming droplist. Say we select a specific country then we want to repopulate/filter the cities droplist so that it only shows cities for the selected country. For the restaurant drop-down list, we want to perform a booking based on our restaurant selection. Sounds pretty simple, right? We need some subscribers. The cities drop-down list needs to listen to changes in the countries drop-down list. So we add that to our code:</p>
<pre>// subjects/cascadingII.js<br/><br/>let countriesElem = document.getElementById("countries");<br/>let citiesElem = document.getElementBtyId("cities");<br/>let restaurantsElem = document.getElementById("restaurants");<br/><br/>fetchCountries();<br/><br/>function<span> </span><span>buildList</span><span>(</span><span>list</span><span>, </span><span>items</span><span>) {<br/></span>  list<span>.</span><span>innerHTML</span><span> </span><span>="</span><span>"</span><span>;<br/></span>  items<span>.</span><span>forEach</span><span>(</span><span>item</span><span> </span><span>=&gt;</span><span> {<br/></span>    let<span> </span><span>elem</span><span> </span><span>=</span><span> </span><span>document</span><span>.</span><span>createElement</span><span>("</span><span>option"</span><span>);<br/></span>    elem<span>.</span><span>innerHTML</span><span> </span><span>=</span><span> </span><span>item</span><span>;<br/></span>    list<span>.</span><span>appendChild</span><span>(</span><span>elem</span><span>);<br/></span>  });<br/>}<br/><br/>function<span> </span><span>fetchCountries</span><span>() {<br/></span>  return<span> </span><span>Rx</span><span>.</span><span>Observable</span><span>.</span><span>ajax</span><span>("</span><span>countries.json"</span><span>)<br/></span>    .<span>map</span><span>(</span><span>r </span><span>=&gt;</span><span> </span><span>r</span><span>.</span><span>response</span><span>)<br/></span>    .<span>subscribe</span><span>(</span><span>countries</span><span> </span><span>=&gt;</span><span> </span><span>buildList</span><span>(</span><span>countriesElem</span><span>, </span><span>countries</span><span>.</span><span>data</span><span>));<br/></span>}<br/><br/>function populateCountries() {<br/>  fetchCountries()<br/>    .map(r =&gt; r.response)<br/>    .subscribe(countries =&gt; buildDropList(countriesElem, countries));<br/>}<br/><br/><strong>let cities$ = new Subject();<br/>cities$.subscribe(cities =&gt; buildList(citiesElem, cities</strong><span><strong>))</strong>;<br/></span><br/>Rx<span>.</span><span>Observable</span><span>.</span><span>fromEvent</span><span>(</span><span>countriesElem</span><span>, "</span><span>change"</span><span>)<br/></span>  <strong>.map(ev =&gt; ev.target.value)<br/>  .do(val =&gt; clearSelections())<br/>  .switchMap(selectedCountry =&gt; fetchBy(selectedCountry))<br/>  .subscribe( cities =&gt; cities$.next(cities.data</strong><span><strong>))</strong>;<br/></span><br/>Rx.Observable.from(citiesElem, "select");<br/><br/>Rx.Observable.from(restaurantsElem, "select");</pre>
<p>So, here, we have a behavior of performing an AJAX request when we select a country; we get a filtered list of cities, and we introduce the new subject instance <kbd>cities$</kbd>.  We call the <kbd>next()</kbd> method on it with our filtered cities as a parameter. Finally, we listen to changes to the <kbd>cities$</kbd> stream by calling the <kbd>subscribe()</kbd> method on the stream. As you can see, when data arrives, we rebuild our cities drop-down list there.</p>
<p>We realize that our next step is to react to changes from us doing a selection in the cities drop-down list. So, let's set that up:</p>
<pre>// subjects/cascadingIII.js<br/><br/>let countriesElem = document.getElementById("countries");<br/>let citiesElem = document.getElementBtyId("cities");<br/>let restaurantsElem = document.getElementById("restaurants");<br/><br/>fetchCountries();<br/><br/>function<span> </span><span>buildList</span><span>(</span><span>list</span><span>, </span><span>items</span><span>) {<br/></span>  list<span>.</span><span>innerHTML</span><span> </span><span>= "</span><span>"</span><span>;<br/></span>  items<span>.</span><span>forEach</span><span>(</span><span>item</span><span> </span><span>=&gt;</span><span> {<br/></span>    let<span> </span><span>elem</span><span> </span><span>=</span><span> </span><span>document</span><span>.</span><span>createElement</span><span>("</span><span>option"</span><span>);<br/></span>    elem<span>.</span><span>innerHTML</span><span> </span><span>=</span><span> </span><span>item</span><span>;<br/></span>    list<span>.</span><span>appendChild</span><span>(</span><span>elem</span><span>);<br/></span>  });<br/>}<br/><br/>function<span> </span><span>fetchCountries</span><span>() {<br/></span>  return<span> </span><span>Rx</span><span>.</span><span>Observable</span><span>.</span><span>ajax</span><span>("</span><span>countries.json"</span><span>)<br/></span>    .<span>map</span><span>(</span><span>r </span><span>=&gt;</span><span> </span><span>r</span><span>.</span><span>response</span><span>)<br/></span>    .<span>subscribe</span><span>(</span><span>countries</span><span> </span><span>=&gt;</span><span> </span><span>buildList</span><span>(</span><span>countriesElem</span><span>, </span><span>countries</span><span>.</span><span>data</span><span>));<br/></span>}<br/><br/>function populateCountries() {<br/>  fetchCountries()<br/>    .map(r =&gt; r.response)<br/>    .subscribe(countries =&gt; buildDropList(countriesElem, countries));<br/>}<br/><br/>let cities$ = new Subject();<br/>cities$.subscribe(cities =&gt; buildList(citiesElem, cities<span>));<br/></span><br/><strong>let restaurants$ = new Rx.Subject();<br/>restaurants$.subscribe(restaurants =&gt; buildList(restaurantsElem, restaurants</strong><span><strong>));</strong><br/><br/></span>Rx<span>.</span><span>Observable</span><span>.</span><span>fromEvent</span><span>(</span><span>countriesElem</span><span>, "</span><span>change"</span><span>)<br/></span>  .map(ev =&gt; ev.target.value)<br/>  .do( val =&gt; clearSelections())<br/>  .switchMap(selectedCountry =&gt; fetchBy(selectedCountry))<br/>  .subscribe( cities =&gt; cities$.next(cities.data<span>));<br/></span><br/>Rx.Observable.from(citiesElem, "select")<br/><strong>  .map(ev =&gt; ev.target.value)<br/>  .switchMap(selectedCity =&gt; fetchBy(selectedCity))<br/>  .subscribe( restaurants =&gt; restaurants$.next(restaurants.data));<br/><br/></strong>// talk to /book/restaurant/:restaurant, book selected restaurant<br/>Rx.Observable.from(restaurantsElem, "select");</pre>
<p>In the preceding code, we added some code to react to a selection being made in our cities drop-down list. We also added some code to listen to changes in the <kbd>restaurants$</kbd> stream, which finally led to our restaurants drop-down list being repopulated. The last step is to listen to changes on us selecting a restaurant in the restaurants drop-down list. What should happen here is up to you, dear reader. A suggestion is that we query some API for the selected restaurant's opening hours, or its menu. Use your creativity. We will leave you with some final subscription code, though:</p>
<pre>// subjects/cascadingIV.js<br/><br/>let<span> </span><span>cities$</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Rx</span><span>.</span><span>Subject</span><span>();<br/></span>cities$<span>.</span><span>subscribe</span><span>(</span><span>cities</span><span> </span><span>=&gt;</span><span> </span><span>buildList</span><span>(</span><span>citiesElem</span><span>, </span><span>cities</span><span>));<br/></span><br/>let<span> </span><span>restaurants$</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Rx</span><span>.</span><span>Subject</span><span>();<br/></span>restaurants$<span>.</span><span>subscribe</span><span>(</span><span>restaurants</span><span> </span><span>=&gt;</span><span> </span><span>buildList</span><span>(</span><span>restaurantsElem</span><span>, </span><span>restaurants</span><span>));<br/></span><br/>function<span> </span><span>buildList</span><span>(</span><span>list</span><span>, </span><span>items</span><span>) {<br/></span><span>  </span>list<span>.</span><span>innerHTML</span><span> </span><span>= ""</span><span>;<br/>  </span>items<span>.</span><span>forEach</span><span>(</span><span>item</span><span> </span><span>=&gt;</span><span> {<br/>    </span>let<span> </span><span>elem</span><span> </span><span>=</span><span> </span><span>document</span><span>.</span><span>createElement</span><span>("</span><span>option"</span><span>);<br/></span>    elem<span>.</span><span>innerHTML</span><span> </span><span>=</span><span> </span><span>item</span><span>;<br/></span>    list<span>.</span><span>appendChild</span><span>(</span><span>elem</span><span>);<br/></span>  });<br/>}<br/><br/>function<span> </span><span>fetchCountries</span><span>() {<br/></span>  return<span> </span><span>Rx</span><span>.</span><span>Observable</span><span>.</span><span>ajax</span><span>("</span><span>countries.json"</span><span>)<br/></span>    .<span>map</span><span>(</span><span>r </span><span>=&gt;</span><span> </span><span>r</span><span>.</span><span>response</span><span>)<br/></span>    .<span>subscribe</span><span>(</span><span>countries</span><span> </span><span>=&gt;</span><span> </span><span>buildList</span><span>(</span><span>countriesElem, </span><span>countries</span><span>.</span><span>data</span><span>));<br/></span>}<br/><br/>function<span> </span><span>fetchBy</span><span>(</span><span>by</span><span>) {<br/></span>  return<span> </span><span>Rx</span><span>.</span><span>Observable</span><span>.</span><span>ajax</span><span>(</span><span>`</span><span>${</span><span>by</span><span>}</span><span>.json`</span><span>)<br/>  </span>.<span>map</span><span>(</span><span>r</span><span>=&gt;</span><span> </span><span>r</span><span>.</span><span>response</span><span>);<br/></span>}<br/><br/>function<span> </span><span>clearSelections</span><span>() {<br/></span>  citiesElem<span>.</span><span>innerHTML</span><span> </span><span>=</span><span> ""</span><span>;<br/></span>  restaurantsElem<span>.</span><span>innerHTML</span><span> </span><span>=</span><span> ""</span><span>;<br/></span>}<br/><br/>let<span> </span><span>countriesElem</span><span> </span><span>=</span><span> </span><span>document</span><span>.</span><span>getElementById</span><span>("</span><span>countries"</span><span>);<br/></span>let<span> </span><span>citiesElem</span><span> </span><span>=</span><span> </span><span>document</span><span>.</span><span>getElementById</span><span>("</span><span>cities"</span><span>);<br/></span>let<span> </span><span>restaurantsElem</span><span> </span><span>=</span><span> </span><span>document</span><span>.</span><span>getElementById</span><span>("</span><span>restaurants"</span><span>);<br/></span><br/>fetchCountries<span>();<br/></span><br/>Rx<span>.</span><span>Observable</span><span>.</span><span>fromEvent</span><span>(</span><span>countriesElem</span><span>,</span><span> "</span><span>change"</span><span>)<br/></span>  .<span>map</span><span>(</span><span>ev</span><span> </span><span>=&gt;</span><span> </span><span>ev</span><span>.</span><span>target</span><span>.</span><span>value</span><span>)<br/></span>  .<span>do</span><span>(</span><span>val</span><span> </span><span>=&gt;</span><span> </span><span>clearSelections</span><span>())<br/></span>  .<span>switchMap</span><span>(</span><span>selectedCountry</span><span> </span><span>=&gt;</span><span> </span><span>fetchBy</span><span>(</span><span>selectedCountry</span><span>))<br/></span>  .<span>subscribe</span><span>(</span><span>cities</span><span> </span><span>=&gt;</span><span> </span><span>cities$</span><span>.</span><span>next</span><span>(</span><span>cities</span><span>.</span><span>data</span><span>));<br/></span><br/>Rx<span>.</span><span>Observable</span><span>.</span><span>fromEvent</span><span>(</span><span>citiesElem</span><span>,</span><span> "</span><span>change"</span><span>)<br/></span><span>  </span>.<span>map</span><span>(</span><span>ev</span><span> </span><span>=&gt;</span><span> </span><span>ev</span><span>.</span><span>target</span><span>.</span><span>value</span><span>)<br/>  </span>.<span>switchMap</span><span>(</span><span>selectedCity</span><span> </span><span>=&gt;</span><span> </span><span>fetchBy</span><span>(</span><span>selectedCity</span><span>))<br/>  </span>.<span>subscribe</span><span>(</span><span>restaurants</span><span> </span><span>=&gt;</span><span> </span><span>restaurants$</span><span>.</span><span>next</span><span>(</span><span>restaurants</span><span>.</span><span>data</span><span>));<br/><br/></span>Rx<span>.</span><span>Observable</span><span>.</span><span>fromEvent</span><span>(</span><span>restaurantsElem</span><span>,</span><span> "</span><span>change"</span><span>)<br/></span><span>  </span><strong>.map(ev =&gt; ev.target.value)<br/>  .subscribe(selectedRestaurant =&gt; console.log("selected restaurant", selectedRestaurant));</strong></pre>
<p>This became a quite long code example, and it should be said that this is not the best way of solving a problem like this, but it does demonstrate how a Subject works: it can add value to the stream when it wants, and it can be subscribed to.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">BehaviorSubject</h1>
                </header>
            
            <article>
                
<p>So far, we have been looking at the default type of Subject, and we have uncovered a little of its secrets. However, there are many more types of Subjects. One such interesting type of Subject is the <kbd>BehaviorSubject</kbd>. So, why do we need a <kbd>BehaviorSubject</kbd>, and for what? Well, when dealing with a default Subject, we are able to add values to the stream, as well as subscribe to the stream. The <kbd>BehaviorSubject</kbd> gives us some added capabilities, in the form of:</p>
<ul>
<li>A starter value, which is great if we are able to show something to the UI while waiting for an AJAX call to finish</li>
<li>We can query on the latest value; in some situations, it is interesting to know what the last emitted value was</li>
</ul>
<p>To address the first bullet, let's write some code and showcase this capability:</p>
<pre>// subjects/behavior-subject.js<br/><br/>let behaviorSubject = new Rx.BehaviorSubject("default value");<br/><br/>// will emit 'default value'<br/>behaviorSubject.subscribe(data =&gt; console.log(data));<br/><br/>// long running AJAX scenario<br/>setTimeout(() =&gt; {<br/>  return Rx.Observable.ajax("data.json")<br/>    .map(r =&gt; r.response)<br/>    .subscribe(data =&gt; behaviorSubject.next(data));<br/>}, 12000);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ReplaySubject</h1>
                </header>
            
            <article>
                
<p>With a normal Subject, it matters when we start subscribing. If we start emitting values before our subscription is set up, those values are simply lost. If we have a <kbd>BehaviorSubject</kbd>, we have a somewhat better scenario. Even if we are late in subscribing, so a value has already been emitted, the very last emitted value is still possible to gain access to. Then the following question arises: What if two or more values are emitted before a subscription happens and we care about those values – what then?</p>
<p>Let's illustrate this scenario and see what happens with a Subject and <kbd>BehaviorSubject</kbd>, respectively:</p>
<pre>// example of emitting values before subscription<br/><br/>const Rx = require("rxjs/Rx");<br/><br/>let<span> </span><span>subject</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Rx</span><span>.</span><span>Subject</span><span>();<br/></span>subject<span>.</span><span>next</span><span>(</span><span>"subject first value"</span><span>);<br/><br/>// emits 'subject second value'<br/></span>subject<span>.</span><span>subscribe</span><span>(</span><span>data</span><span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>log</span><span>(</span><span>"subscribe - subject"</span><span>, </span><span>data</span><span>));<br/></span>subject<span>.</span><span>next</span><span>(</span><span>"subject second value"</span><span>);<br/></span><br/>let<span> </span><span>behaviourSubject</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Rx</span><span>.</span><span>BehaviorSubject</span><span>(</span><span>"behaviorsubject initial value"</span><span>);<br/></span>behaviourSubject<span>.</span><span>next</span><span>(</span><span>"behaviorsubject first value"</span><span>);<br/></span>behaviourSubject<span>.</span><span>next</span><span>(</span><span>"behaviorsubject second value"</span><span>);<br/><br/>// emits 'behaviorsubject second value', 'behaviorsubject third value' <br/></span>behaviourSubject<span>.</span><span>subscribe</span><span>(</span><span>data</span><span> </span><span>=&gt;<br/></span>  console<span>.</span><span>log</span><span>(</span><span>"subscribe - behaviorsubject"</span><span>, </span><span>data</span><span>)<br/></span>);<br/><br/>behaviourSubject<span>.</span><span>next</span><span>(</span><span>"behaviorsubject third value"</span><span>);</span></pre>
<p>What we can see from the preceding code is that Subject is not a good candidate if we care about values prior to us subscribing. The <kbd>BehaviorSubject</kbd> constructors are slightly better for that scenario, but if we really care about prior values, and a lot of them, then we should have a look at the <kbd>ReplaySubject</kbd>.  The <kbd><span>ReplaySubject</span></kbd> has the ability to specify two things: a buffer size and a window size. A buffer size is simply the amount of values it should remember from the past, and the window size specifies for how long it should remember them for. Let us demonstrate this in code:</p>
<pre>// subjects/replay-subject.js<br/><br/>const Rx = require("rxjs/Rx");<br/><br/>let<span> </span><span>replaySubject</span><span> </span><span>=</span><span> new </span><span>Rx</span><span>.</span><span>ReplaySubject</span><span>(</span><span>2</span><span>);<br/></span><br/>replaySubject<span>.</span><span>next</span><span>(</span><span>1</span><span>);<br/></span>replaySubject<span>.</span><span>next</span><span>(</span><span>2</span><span>);<br/></span>replaySubject<span>.</span><span>next</span><span>(</span><span>3</span><span>);<br/><br/>// emitting 2 and 3<br/></span>replaySubject<span>.</span><span>subscribe</span><span>(</span><span>data</span><span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>log</span><span>(</span><span>data</span><span>));</span></pre>
<p>In the preceding code, we can see how we emit <kbd>2</kbd> and <kbd>3</kbd>, that is, the two latest emitted values. This is due to the fact that we specify the buffer size in the <kbd>ReplaySubject</kbd> constructor to be 2. The only value we loose out on is 1. Had we, on the other hand, specified a 3 in our constructor, all three values would have reached the subscriber. So much for the buffer size and how that works; what about the window size property? Let's illustrate how that works with the following code:</p>
<pre>// subjects/replay-subject-window-size.js<br/><br/>const Rx = require("rxjs/Rx");<br/><br/>let<span> </span><span>replaySubjectWithWindow</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Rx</span><span>.</span><span>ReplaySubject</span><span>(</span><span>2</span><span>, </span><strong>2000</strong><span>);<br/></span>replaySubjectWithWindow<span>.</span><span>next</span><span>(</span><span>1</span><span>);<br/></span>replaySubjectWithWindow<span>.</span><span>next</span><span>(</span><span>2</span><span>);<br/></span>replaySubjectWithWindow<span>.</span><span>next</span><span>(</span><span>3</span><span>);<br/></span><br/>setTimeout<span>(() </span><span>=&gt;</span><span> {<br/></span>  replaySubjectWithWindow<span>.</span><span>subscribe</span><span>(</span><span>data</span><span> </span><span>=&gt;<br/></span>    console<span>.</span><span>log</span><span>(</span><span>"replay with buffer and window size"</span><span>, </span><span>data</span><span>)</span>);<br/>  }, <br/><span>2010</span><span>);</span></pre>
<p>Here, we specify the window size as 2,000 milliseconds; that is how long the values should be held in the buffer. We can see below that we delay the creation of our subscription to occur after 2,010 milliseconds. The end result of this is that no values will be emitted, as the buffer will have been emptied before the subscription has time to occur. A higher value of the window size would have fixed this issue.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AsyncSubject</h1>
                </header>
            
            <article>
                
<p>The <kbd>AsyncSubject</kbd> has a capacity of one, which means we can emit a ton of values, but only the latest one is something that is stored. It isn't really lost, either, but you won't see it unless you complete the stream. Let's look at a piece of code that illustrates just this:</p>
<pre>// subjects/async-subject.js<br/><br/>let<span> </span><span>asyncSubject</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Rx</span><span>.</span><span>AsyncSubject</span><span>();<br/></span>asyncSubject<span>.</span><span>next</span><span>(</span><span>1</span><span>);<br/></span>asyncSubject<span>.</span><span>next</span><span>(</span><span>2</span><span>);<br/></span>asyncSubject<span>.</span><span>next</span><span>(</span><span>3</span><span>);<br/></span>asyncSubject<span>.</span><span>next</span><span>(</span><span>4</span><span>);<br/></span><br/>asyncSubject<span>.</span><span>subscribe</span><span>(</span><span>data</span><span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>log</span><span>(</span><span>data</span><span>), </span><span>err</span><span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>error</span><span>(</span><span>err</span><span>));</span><span><br/></span></pre>
<p>Earlier, we had fours values being emitted, but nothing seems to reach the subscriber. At this point, we don't know whether this is because it just acts like a subject and throws away all emitted values that happen before a subscription or not. Let's therefore call the <kbd>complete()</kbd> method and see how that plays out:</p>
<pre>// subjects/async-subject-complete.js<br/><br/>let<span> </span><span>asyncSubject</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Rx</span><span>.</span><span>AsyncSubject</span><span>();<br/></span>asyncSubject<span>.</span><span>next</span><span>(</span><span>1</span><span>);<br/></span>asyncSubject<span>.</span><span>next</span><span>(</span><span>2</span><span>);<br/></span>asyncSubject<span>.</span><span>next</span><span>(</span><span>3</span><span>);<br/></span>asyncSubject<span>.</span><span>next</span><span>(</span><span>4</span><span>);<br/><br/>// emits 4<br/></span>asyncSubject<span>.</span><span>subscribe</span><span>(</span><span>data</span><span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>log</span><span>(</span><span>data</span><span>),</span><span> </span><span>err</span><span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>error</span><span>(</span><span>err</span><span>));<br/></span>asyncSubject<span>.</span><span>complete</span><span>();</span><span><br/></span></pre>
<p>This will emit a <kbd>4</kbd> due to the fact that <kbd>AsyncSubject</kbd> only remembers the last value and we are calling the <kbd>complete()</kbd> method, thereby signaling the completion of the stream.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Error handling</h1>
                </header>
            
            <article>
                
<p>Error handling is a very big topic. It is an area that is easy to underestimate. Normally, when coding, we could be led to believe we just need to do certain things, such as ensure we don't have syntax errors or runtime errors. With streams, we mostly think of runtime errors. The question is, how should we act when an error occurs? Should we pretend like it rains and just throw the error away? Should we hope for a different outcome if we try the same code some time in the future, or should we maybe just give up when a certain type of error exists? Let's try to collect our thoughts and look at the different error approaches that exist within RxJS.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Catch and continue</h1>
                </header>
            
            <article>
                
<p>Sooner or later, we will have a stream that will throw an error. Let's see what that can look like:</p>
<pre>// example of a stream with an error<br/><br/>let stream$ = Rx.Observable.create(observer =&gt; {<br/>  observer.next(1);<br/>  <strong>observer.error('an error is thrown');</strong>  <br/>  observer.next(2);<br/>});<br/><br/>stream$.subscribe(<br/>  data =&gt; console.log(data), // 1 <br/>  <strong>error =&gt; console.error(error) // 'error is thrown'</strong><br/>);</pre>
<p>In the preceding code, we set up a scenario where we first emit a value, followed by emitting an error. The first value is captured in our first callback in our subscribe method. The second emitted thing, the error, is captured by our error callback. The third emitted value does not get emitted to our subscriber because our stream has been interrupted by the error. There is something we can do here, and that is to use the <kbd>catch()</kbd> operator. Let's apply that to our stream and see what happens:</p>
<pre>// error-handling/error-catch.js<br/>const Rx = require("rxjs/Rx");<br/><br/>let<span> </span><span>stream$</span><span> </span><span>=</span><span> </span><span>Rx</span><span>.</span><span>Observable</span><span>.</span><span>create</span><span>(</span><span>observer</span><span> </span><span>=&gt;</span><span> {<br/></span>  observer<span>.</span><span>next</span><span>(</span><span>1</span><span>);<br/>  </span>observer<span>.</span><span>error</span><span>(</span><span>"an error is thrown"</span><span>);<br/></span>  observer<span>.</span><span>next</span><span>(</span><span>2</span><span>);<br/></span>})<strong>.catch(err =&gt; Rx.Observable.of(err</strong><span><strong>))</strong>;<br/><br/></span>stream$<span>.</span><span>subscribe</span><span>(<br/></span><span>  data</span><span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>log</span><span>(</span><span>data</span><span>), // emits 1 and 'error is thrown'<br/></span><span>  error</span><span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>error</span><span>(</span><span>error</span><span>)<br/>);</span><span><br/></span></pre>
<p>Here, we capture our error with the <kbd>catch()</kbd> operator. In the <kbd>catch()</kbd> operator, we take our error and emit it as a normal Observable using the <kbd>of()</kbd> operator. What happens to the <kbd>2</kbd> we emit, though? Still no luck with that one. The <kbd>catch()</kbd> operator is able to take our error and turn it into a normal emitted value; instead of an error, we don't get all the values from the stream. </p>
<p>Let's have a look at a scenario when we are dealing with multiple streams:</p>
<pre>// example of merging several streams<br/><br/>let<span> </span><span>merged$</span><span> </span><span>=</span><span> </span><span>Rx</span><span>.</span><span>Observable</span><span>.</span><span>merge</span><span>(<br/></span>  Rx<span>.</span><span>Observable</span><span>.</span><span>of</span><span>(</span><span>1</span><span>),<br/></span>  Rx<span>.</span><span>Observable</span><span>.</span><span>throw</span><span>(</span><span>"err"</span><span>),<br/></span>  Rx<span>.</span><span>Observable</span><span>.</span><span>of</span><span>(</span><span>2</span><span>)<br/></span>);<br/><br/>merged$<span>.</span><span>subscribe</span><span>(</span><span>data</span><span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>log</span><span>(</span><span>"merged"</span><span>, </span><span>data</span><span>));</span></pre>
<p>In the scenario above, we merge three streams. The first stream emits the number <kbd>1</kbd> and nothing else gets emitted. This is due to our second stream tearing everything down, as it emits an error. Let's try to apply our newfound <kbd>catch()</kbd> operator and see what happens:</p>
<pre>// error-handling/error-merge-catch.js<br/><br/>const Rx = require("rxjs/Rx");<br/><br/>let<span> </span><span>merged$</span><span> </span><span>=</span><span> </span><span>Rx</span><span>.</span><span>Observable</span><span>.</span><span>merge</span><span>(<br/></span>  Rx<span>.</span><span>Observable</span><span>.</span><span>of</span><span>(</span><span>1</span><span>),<br/></span>  Rx<span>.</span><span>Observable</span><span>.</span><span>throw</span><span>(</span><span>"err"</span><span>)<strong>.</strong></span><strong>catch(err =&gt; Rx.Observable.of(err</strong><span><strong>))</strong>,<br/></span>  Rx<span>.</span><span>Observable</span><span>.</span><span>of</span><span>(</span><span>2</span><span>)<br/></span>);<br/><br/>merged$<span>.</span><span>subscribe</span><span>(</span><span>data</span><span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>log</span><span>(</span><span>"merged"</span><span>, </span><span>data</span><span>));</span></pre>
<p>We run the above code and we notice that the <kbd>1</kbd> is emitted, the error is emitted as a normal value, and, finally, even the <kbd>2</kbd> is emitted. Our conclusion here is that it is a good idea to apply a <kbd>catch()</kbd> operator to a stream before it is being merged with our streams.</p>
<p>As before, we can also conclude that the <kbd>catch()</kbd> operator is able to stop the stream from just erroring out, but that other values that would have been emitted after the error are effectively lost. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ignoring the error </h1>
                </header>
            
            <article>
                
<p>As we saw in the former section, the <kbd>catch()</kbd> operator does a good job of ensuring that a stream that errors out doesn't cause any problems when being merged with another stream. The <kbd>catch()</kbd> operator enables us to take the error, investigate it, and create a new Observable that will emit a value as though nothing happened. Sometimes, however, you don't want to even deal with streams that error out. For such a scenario, there is a different operator, called <kbd>onErrorResumeNext()</kbd>:</p>
<pre>// error-handling/error-ignore.js<br/>const Rx = require("rxjs/Rx");<br/><br/>let<span> </span><span>mergedIgnore$</span><span> </span><span>=</span><span> </span><span>Rx</span><span>.</span><span>Observable</span><span>.</span><strong>onErrorResumeNext</strong><span>(<br/></span>  Rx<span>.</span><span>Observable</span><span>.</span><span>of</span><span>(</span><span>1</span><span>),<br/></span>  Rx<span>.</span><span>Observable</span><span>.</span><span>throw</span><span>(</span><span>"err"</span><span>),<br/></span>  Rx<span>.</span><span>Observable</span><span>.</span><span>of</span><span>(</span><span>2</span><span>)<br/></span>);<br/><br/>mergedIgnore$<span>.</span><span>subscribe</span><span>(</span><span>data</span><span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>log</span><span>(</span><span>"merge ignore"</span><span>, </span><span>data</span><span>));</span></pre>
<p>The implication of using the <kbd>onErrorResumeNext()</kbd> operator is that the second stream, the one that emits an error, gets completely ignored, and the values <kbd>1</kbd> and <kbd>2</kbd> get emitted. This is a very nice operator to use if your scenario is only about caring for the streams that do not error out.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Retry</h1>
                </header>
            
            <article>
                
<p>There are different reasons why you would want to retry a stream. It's easier to imagine why you would want to if your stream is dealing with AJAX calls. Network connections may be unreliable at times with the local network you are on, or the service you are trying to hit may be temporarily down for some reason. Regardless of the reason, you have a situation where hitting that endpoint will some of the time reply with an answer, and some of the time return a 401 error. What we are describing here is the business case for adding retry logic to your streams. Let's have a look at a stream designed to fail:</p>
<pre>// error-handling/error-retry.js<br/>const Rx = require("rxjs/Rx");<br/><br/>let<span> </span><span>stream$</span><span> </span><span>=</span><span> </span><span>Rx</span><span>.</span><span>Observable</span><span>.</span><span>create</span><span>(</span><span>observer</span><span> </span><span>=&gt;</span><span> {<br/></span>  observer<span>.</span><span>next</span><span>(</span><span>1</span><span>);<br/></span>  observer<span>.</span><span>error</span><span>(</span><span>"err"</span><span>);<br/></span>})<br/>.<span>retry</span><span>(</span><span>3</span><span>);<br/><br/>// emits 1 1 1 1 err<br/>stream$<br/></span>  .<span>subscribe</span><span>(</span><span>data</span><span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>log</span><span>(</span><span>data</span><span>));</span></pre>
<p>The output of the code above is the value <kbd>1</kbd> being emitted four times, followed by our error. What happens is that our streams' values are retried three times before the error callback is hit in the subscribe. Using the <kbd>retry()</kbd> operator delays when the error is actually treated as an error. The preceding example doesn't make sense to retry, though, as the error will always occur. Therefore, let's take a better example – an AJAX call where the network connection may come and go:</p>
<pre>// example of using a retry with AJAX<br/><br/>let<span> </span><span>ajaxStream$</span><span> </span><span>=</span><span> </span><span>Rx</span><span>.</span><span>Observable</span><span>.</span><span>ajax</span><span>(</span><span>"UK1.json"</span><span>)</span><span><br/></span>  .<span>map</span><span>(</span><span>r</span><span> </span><span>=&gt;</span><span> </span><span>r</span><span>.</span><span>response</span><span>)<br/></span>  .<span>retry</span><span>(</span><span>3</span><span>);<br/></span><br/>ajaxStream$<span>.</span><span>subscribe</span><span>(<br/></span>  data<span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>log</span><span>(</span><span>"ajax result"</span><span>, </span><span>data</span><span>),<br/></span>  err<span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>error</span><span>(</span><span>"ajax error"</span><span>, </span><span>err</span><span>)<br/></span>);</pre>
<p>Here, we are attempting an AJAX request towards a file that doesn't seem to exist. Having a look at the console, we are faced with the following result:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-251 image-border" src="assets/1abf96ff-ea61-4bd1-a20b-f276d562a645.png" style=""/></div>
<p>What we see in the above logging are four failed AJAX requests that lead to an error. We have essentially just switched our simple stream to a more credible AJAX request stream, with the same behavior. Should the file suddenly start to exist, we may have a scenario with two failed attempts and one successful attempt. Our approach has a flaw, though: we retry our AJAX attempts far too often. If we are actually dealing with an intermittent network connection, we need to have some kind of delay between attempts. It is reasonable to set a delay between attempts of at least 30 seconds or more. We can accomplish that by using a slightly different retry operator that takes milliseconds rather than a number of attempts as an argument. It looks like the following:</p>
<pre>// retry with a delay<br/><br/>let<span> </span><span>ajaxStream$</span><span> </span><span>=</span><span> </span><span>Rx</span><span>.</span><span>Observable</span><span>.</span><span>ajax</span><span>(</span><span>"UK1.json"</span><span>)<br/></span>  .<span>do</span><span>(</span><span>r</span><span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>log</span><span>(</span><span>"emitted"</span><span>))<br/></span>  .<span>map</span><span>(</span><span>r</span><span> </span><span>=&gt;</span><span> </span><span>r</span><span>.</span><span>response</span><span>)<br/></span>  .<span>retryWhen</span><span>(</span><span>err</span><span> </span><span>=&gt;</span><span> {<br/></span>    return<span> </span><span>err</span>.<span>delay</span><span>(</span><span>3000</span><span>);<br/></span>  });</pre>
<p>What we do here is use the operator <kbd>retryWhen()</kbd>. The <kbd>retryWhen()</kbd> operator's mission in life is to return a stream. At this point, you can manipulate the stream it returns by appending a <kbd>.delay()</kbd> operator that takes a number of milliseconds. The result from doing so is that it will retry the AJAX call for all eternity, which may not be what you want. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advanced Retry</h1>
                </header>
            
            <article>
                
<p>What we most likely want is to combine the delay between retry attempts with being able to specify how many times we want to retry the stream. Let's have a look at how we can accomplish that:</p>
<pre>// error-handling/error-retry-advanced.js<br/><br/>const Rx = require("rxjs/Rx");<br/><br/>let<span> </span><span>ajaxStream$</span><span> </span><span>=</span><span> </span><span>Rx</span><span>.</span><span>Observable</span><span>.</span><span>ajax</span><span>(</span><span>"UK1.json"</span><span>)<br/></span>  .<span>do</span><span>(</span><span>r</span><span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>log</span><span>(</span><span>"emitted"</span><span>))<br/></span>  .<span>map</span><span>(</span><span>r</span><span> </span><span>=&gt;</span><span> </span><span>r</span><span>.</span><span>response</span><span>)<br/></span>  .<span>retryWhen</span><span>(</span><span>err</span><span> </span><span>=&gt;</span><span> {<br/></span>    return<span> </span><span>err<br/></span>    .<span>delay</span><span>(</span><span>3000</span><span>)<br/></span>    <strong>.take(3)</strong><span>;<br/></span>});<span><br/></span></pre>
<p>The interesting part here is that we use the operator <kbd>.take()</kbd>. We specify the number of emitted values we want from this inner Observable. We have now accomplished a nice approach in which we are able to control the number of retries and the delay between retries. There is an aspect to this that we haven't tried, namely, how we want all the retries to end when it finally gives up. In the preceding code, the stream just completes after the stream is retried after <em>x</em> number of times with no successful result. However, we may want the stream to error out instead. We can accomplish this by just adding an operator to the code, like this:</p>
<pre>// error-handling/error-retry-advanced-fail.js<br/><br/>let<span> </span><span>ajaxStream$</span><span> </span><span>=</span><span> </span><span>Rx</span><span>.</span><span>Observable</span><span>.</span><span>ajax</span><span>(</span><span>"UK1.json"</span><span>)<br/></span>  .<span>do</span><span>(</span><span>r</span><span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>log</span><span>(</span><span>"emitted"</span><span>))<br/></span>  .<span>map</span><span>(</span><span>r</span><span> </span><span>=&gt;</span><span> </span><span>r</span><span>.</span><span>response</span><span>)<br/></span>  .<span>retryWhen</span><span>(</span><span>err</span><span> </span><span>=&gt;</span><span> {<br/></span>    return<span> </span><span>err<br/></span>    .<span>delay</span><span>(</span><span>3000</span><span>)<br/></span>    .take(3)<br/><span>    </span><strong>.concat(Rx.Observable.throw("giving up"))</strong><span>;<br/></span>});</pre>
<p>Here, we are adding a <kbd>concat()</kbd> operator that adds a stream that just fails. So we are guaranteed, after three failed attempts, to have an error happen. This is usually a better approach than having the stream silently complete after <em>x</em> number of failed attempts.</p>
<p>This isn't a perfect approach, though; imagine that you want to investigate what type of error you get back. In the case of AJAX requests being made, it matters whether we get a 400-something error or a 500-something error back as HTTP status code. They mean different things.  With 500 errors, something is very wrong on the backend, and we probably want to give up straight away. With a 404 error, however, this implies the resource isn't there, but in the case with an intermittent network connection, this means the resource can't be reached due to our connection being offline. For that reason, a 404 error might be worth retrying. To solve that in code, we need to inspect the value being emitted to determine what to do. We can inspect values using the <kbd>do()</kbd> operator.</p>
<p>In the following code, we investigate the type of HTTP status of the response and determine how to handle it:</p>
<pre>// error-handling/error-retry-errorcodes.js<br/><br/>const Rx = require("rxjs/Rx");<br/><br/>function<span> </span><span>isOkError</span><span>(</span><span>errorCode</span><span>) {<br/></span>  return<span> </span><span>errorCode</span><span> </span><span>&gt;=</span><span> </span><span>400</span><span> </span><span>&amp;&amp;</span><span> </span><span>errorCode</span><span> </span><span>&lt;</span><span> </span><span>500</span><span>;<br/></span>}<br/><br/>let<span> </span><span>ajaxStream$</span><span> </span><span>=</span><span> </span><span>Rx</span><span>.</span><span>Observable</span><span>.</span><span>ajax</span><span>(</span><span>"UK1.json"</span><span>)<br/></span>  .<span>do</span><span>(</span><span>r</span><span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>log</span><span>(</span><span>"emitted"</span><span>))<br/></span>  .<span>map</span><span>(</span><span>r</span><span> </span><span>=&gt;</span><span> </span><span>r</span><span>.</span><span>response</span><span>)<br/></span>  .<span>retryWhen</span><span>(</span><span>err</span><span> </span><span>=&gt;</span><span> {<br/></span>    return<span> </span><span>err<br/></span>      .<span>do</span><span>(</span><span>val</span><span> </span><span>=&gt;</span><span> {<br/></span>        if<span> (</span><span>!</span><span>isOkError</span><span>(</span><span>val</span><span>.</span><span>status</span><span>) </span><span>||</span><span> </span><span>timesToRetry</span><span> </span><span>===</span><span> </span><span>0</span><span>) {<br/></span>          throw<span> </span><span>"give up"</span><span>;<br/></span>        }<br/>      })<br/>      .<span>delay</span><span>(</span><span>3000</span><span>);<br/></span>  });</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Marble testing</h1>
                </header>
            
            <article>
                
<p>Testing asynchronous code can be challenging. For one, we have the time factor. The way we specify what operators to use for our crafted algorithm leads to the algorithm taking anywhere from 2 seconds to 30 minutes to execute. Therefore, it will at first feel like there is no point in testing it, because it can't be done within a reasonable time. We have a way to test RxJS, though; it is called Marble testing and it allows us to control how fast time passes so we have a test that can execute it in milliseconds.</p>
<p>The idea of a Marble is known to us. We can represent one or many streams and the effect an operator has one two or more streams. We do this by drawing the streams as a line and values as circles on the lines. The operator is shown as verb below the input streams. Following operator is a third stream, the result of taking the input streams and applying the operator, a so - called marble diagram. The line represents a continuous timeline. We take this concept and bring it to testing. What this means is that we can express our incoming values as a graphical representation and apply our algorithm to it and assert on the result.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Set up</h1>
                </header>
            
            <article>
                
<p>Let's set up our environment correctly so we can write marble tests. We need the following:</p>
<ul>
<li>The NPM library jasmine-marbles</li>
<li>A scaffolded Angular application</li>
</ul>
<p>With that we scaffold our Angular project, like so:</p>
<pre><strong>ng new MarbleTesting</strong></pre>
<p>After the project has been scaffolded, it's time to add our NPM library, like so:</p>
<pre><strong>cd MarbleTesting</strong><br/><strong>npm install jasmine-marbles --save</strong></pre>
<p>Now we have finished the setup, so the time has come to write tests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing your first marble test</h1>
                </header>
            
            <article>
                
<p>Let's create a new file <kbd>marble-testing.spec.ts</kbd>. It should look like the following:</p>
<pre>// marble-testing\MarbleTesting\src\app\marble-testing.spec.ts<br/><br/>import<span> { cold } </span><span>from</span><span> </span><span>"jasmine-marbles"</span><span>;<br/></span>import<span> </span><span>"rxjs/add/operator/map"</span><span>;<br/><br/></span>describe("marble tests", () =&gt; {<br/>  it(<span>"map - should increase by 1"</span><span>, () </span><span>=&gt;</span><span> {<br/></span>    const<span> one$ </span><span>=</span><span> cold(</span><span>"x-x|"</span><span>, { x: </span><span>1</span><span> });<br/></span>    expect(one$.map(x <span>=&gt;</span><span> x </span><span>+</span><span> </span><span>1</span><span>)).toBeObservable(cold(</span><span>"x-x|"</span><span>, { x: </span><span>2</span><span> }));<br/></span>  });<br/>});</pre>
<p>A lot of interesting things are happening here. We import the function <kbd>cold()</kbd> from the NPM library marble-testing. Thereafter we set up a test suite by calling <kbd>describe()</kbd>, followed by a test specification, by calling <kbd>it()</kbd>. Then we call our <kbd>cold()</kbd> function and provide it a string. Let's have a close look at that function call:</p>
<pre>const<span> stream$ </span><span>=</span><span> cold(</span><span>"x-x|"</span><span>, { x: </span><span>1</span><span> });</span></pre>
<p>The above code set up a stream that expects to values to be emitted followed by the stream ending. How do we know that? It's time to explain what <kbd>x-x|</kbd> means. <kbd>x</kbd> is just any value, the hyphen <kbd>-</kbd> means time has passed. The pipe <kbd>|</kbd> means our stream has ended. The second argument in the cold function is a mapping object that tells us what the x means. In this case, it has come to mean the value 1. </p>
<p>Moving on, let's have a look at the next line:</p>
<pre>expect(stream$.map(x <span>=&gt;</span><span> x </span><span>+</span><span> </span><span>1</span><span>)).toBeObservable(cold(</span><span>"x-x|"</span><span>, { x: </span><span>2</span><span> }));</span></pre>
<p>The preceding code applies the operator <kbd>.map()</kbd> and increased the value with one for each value emitted in the stream. Thereafter, we call the <kbd>.toBeObservable()</kbd> helper method and verify it against an expected condition, </p>
<pre><span>cold(</span><span>"x-x|"</span><span>, { x: </span><span>2</span><span> })</span></pre>
<p>The previous condition states that we expect the stream to should emit two values, but that the values should now have the number 2. This makes sense, as our <kbd>map()</kbd> function performs just that.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fleshing out with more tests</h1>
                </header>
            
            <article>
                
<p>Let's write one more test. This time we will be testing the <kbd>filter()</kbd> operator. This one is interesting, as it filters away values that does not fulfill a certain condition. Our test file should now look like the following:</p>
<pre>import<span> { cold } </span><span>from</span><span> </span><span>"jasmine-marbles"</span><span>;<br/></span>import<span> </span><span>"rxjs/add/operator/map"</span><span>;<br/></span><strong>import "rxjs/add/operator/filter"</strong><span><strong>;</strong><br/></span><br/>describe(<span>"marble testing"</span><span>, () </span><span>=&gt;</span><span> {<br/></span>  it(<span>"map - should increase by 1"</span><span>, () </span><span>=&gt;</span><span> {<br/></span>    const<span> one$ </span><span>=</span><span> cold(</span><span>"x-x|"</span><span>, { x: </span><span>1</span><span> });<br/></span>    expect(one$.map(x <span>=&gt;</span><span> x </span><span>+</span><span> </span><span>1</span><span>)).toBeObservable(cold(</span><span>"x-x|"</span><span>, { x: </span><span>2</span><span> }));<br/></span>  });<br/><br/>  <strong>it("filter - should remove values", () =&gt; {<br/>    const stream$ = cold("x-y|", { x: 1, y: 2 });<br/>    expect(stream$.filter(x =&gt; x &gt; 1)).toBeObservable(cold("--y|", { y: 2 }));<br/>  });</strong><br/>});</pre>
<p>This test is set up in pretty much the same way as our first test. This time we use the <kbd>filter()</kbd> operator but what stands out is our expected stream:</p>
<pre>cold("--y|", { y: 2 })</pre>
<p><kbd>--y</kbd>, means that our first values is removed. Based on how the filter condition is defined, we are not surprised. The reason for the double hyphen, <kbd>-</kbd>, though, is that time still passes, but instead of an emitted value a hyphen takes its place. </p>
<p>To learn more about Marble testing, have a look at the following link from the official documentation, <a href="https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md">https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pipeable operators</h1>
                </header>
            
            <article>
                
<p>We haven't mentioned it much so far, but the RxJS library weighs in quite heavily when used in an app. In today's world of mobile first, every kilobyte counts when it comes to libraries that you include in your app. They count because the user may be on a 3G connection, and if it takes too long to load, your user may leave, or just may end up not liking your app, as it feels slow to load, and this may cause you to have bad reviews or lose users. So far, we have used two different ways of importing RxJS:</p>
<ul>
<li>Importing the whole library; this one is quite costly in terms of size</li>
<li>Importing only the operators we need; this ensures that the bundle decreases significantly</li>
</ul>
<p>The different options have looked like this, for importing the whole library and all its operators:</p>
<pre><span class="pl-k">import</span><span> </span><span class="pl-smi">Rx</span><span> </span><span class="pl-k">from</span><span> </span><span class="pl-s"><span class="pl-pds">"</span>rxjs/Rx<span class="pl-pds">"</span></span><span>;</span></pre>
<p>Or like this, to only import what we need:</p>
<pre>import { Observable } from 'rxjs/Observable';<br/>import "rxjs/add/operator/map";<br/>import "rxjs/add/operator/take";<br/><br/>let stream = Observable.interval(1000)<br/>  .map(x =&gt; x +1)<br/>  .take(2)</pre>
<p>That looks good, right? Well, yes, but it is a flawed approach. Let's explain what happens when you type:</p>
<pre>import "rxjs/add/operator/map";</pre>
<p>By typing the preceding, we add to the prototype of the <kbd>Observable</kbd>. Looking in the source code for RxJS, it looks like this:</p>
<pre>var<span> </span><span>Observable_1</span><span> </span><span>=</span><span> </span><span>require</span><span>(</span><span>'../../Observable'</span><span>);<br/></span>var<span> </span><span>map_1</span><span> </span><span>=</span><span> </span><span>require</span><span>(</span><span>'../../operator/map'</span><span>);<br/><br/></span>Observable_1<span>.</span><span>Observable</span><span>.</span><span>prototype</span><span>.</span><span>map</span><span> </span><span>=</span><span> </span><span>map_1</span><span>.</span><span>map</span><span>;</span></pre>
<p>As you can see from the preceding code, we import the <kbd>Observable</kbd> as well as the operator in question and we add the operator to the prototype by assigning it to a <kbd>map</kbd> property on the prototype. What's flawed with that, you might wonder? The problem is tree shaking, a process we use to get rid of unused code. Tree shaking has a hard time determining what you use and don't use, respectively. You may actually import a <kbd>map()</kbd> operator and it gets added to the Observable. As the code changes over time, you may end up not using it anymore. You may argue that you should remove the import at that point, but you might have a lot of code, and it is easy to overlook. It would be better if only used operators were included in the final bundle. It is, as we mentioned before, hard for the tree-shaking process to know what is used and what is not, with the current approach. For that reason, a big rewrite has happened in RxJS, adding something called pipeable operators, which help us with the above problem. There is also another downside to patching the prototype, and that is the fact that it creates a dependency. If the library changes and the operator is no longer added when we patch it (calling the import), then we have a problem. We won't detect the problem until runtime. We would rather be told that the operator has gone through us importing and explicitly using it, like so:</p>
<pre>import { operator } from 'some/path';<br/><br/>operator();</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating reusable operators with let()</h1>
                </header>
            
            <article>
                
<p>The <kbd>let()</kbd> operator lets you have the whole operator and operate on it, rather than just manipulating the values as you would do with the <kbd>map()</kbd> operator, for example. Using the <kbd>let()</kbd> operator could look like this:</p>
<pre>import<span> </span><span>Rx</span><span> </span><span>from</span><span> </span><span>"rxjs/Rx"</span><span>;<br/></span><br/>let<span> </span><span>stream</span><span> </span><span>=</span><span> </span><span>Rx</span><span>.</span><span>Observable</span><span>.</span><span>of</span><span>(</span><span>0</span><span>,</span><span>1</span><span>,</span><span>2</span><span>);<br/></span>let<span> </span><span>addAndFilter</span><span> </span><span>=</span><span> </span><span>obs</span><span> </span><span>=&gt;</span><span> </span><span>obs</span><span>.</span><span>map</span><span>( </span><span>x </span><span>=&gt;</span><span> </span><span>x</span><span> </span><span>*</span><span> </span><span>10</span><span>).</span><span>filter</span><span>(</span><span>x</span><span> </span><span>=&gt;</span><span> </span><span>x</span><span> </span><span>%</span><span> </span><span>10</span><span> </span><span>===</span><span> </span><span>0</span><span>);<br/></span>let<span> </span><span>sub3</span><span> </span><span>=</span><span> </span><span>obs</span><span> </span><span>=&gt;</span><span> </span><span>obs</span><span>.</span><span>map</span><span>(</span><span>x</span><span> </span><span>=&gt;</span><span> </span><span>x</span><span> </span><span>-</span><span> </span><span>3</span><span>);<br/></span><br/>stream<br/>  .<span>let</span><span>(</span><span>addAndFilter</span><span>)<br/></span>  .<span>let</span><span>(</span><span>sub3</span><span>)<br/></span>  .<span>subscribe</span><span>(</span><span>x</span><span> </span><span>=&gt;</span><span> </span><span>console</span><span>.</span><span>log</span><span>(</span><span>'let'</span><span>, </span><span>x</span><span>));</span><span><br/></span></pre>
<p>In the preceding example, we were able to define a group of operators such as <kbd>addAndFilter</kbd> and <kbd>sub3</kbd> and use them on the stream with the <kbd>let()</kbd> operator. This enables us to create composable and reusable operators. It is with this very knowledge that we now move on to the concept of pipeable operators.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Shifting to pipeable operators</h1>
                </header>
            
            <article>
                
<p>As we mentioned already, pipeable operators are here, and you can find them by importing the respective operators from the <kbd>rxjs/operators</kbd> directory, like so:</p>
<pre>import { map } from "rxjs/operators/map";<br/>import { filter } from "rxjs/operators/filter";</pre>
<p>To use it, we are now relying on the <kbd>pipe()</kbd> operator that we use as the parent operator, if you will. Using the preceding operators will therefore look like this:</p>
<pre>import { map } from "rxjs/operators/map";<br/>import { filter } from "rxjs/operators";<br/>import { of } from "rxjs/observable/of";<br/>import { Observable } from "rxjs/Observable";<br/><br/>let stream = of(1,2);<br/>stream.pipe(<br/>  map(x =&gt; x + 1),<br/>  filter(x =&gt; x &gt; 1)<br/>)<br/>.subscribe(x =&gt; console.log("piped", x)); // emits 2 and 3</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter has taken us deep into RxJS by covering topics such as hot, cold, and warm Observables, and what that generally means in terms of when to subscribe to a stream and how they share their Producer under certain conditions. Next up, we covered Subjects, and the fact that Observable isn't the only thing you can subscribe to. Subjects also allow as to append values to the stream whenever we want, and we also learned that there exist different types of Subjects, depending on the situation at hand.</p>
<p>We ventured deeper into an important topic, testing, and tried to explain the difficulty in testing asynchronous code. We talked about the current state of the testing situation and what libraries to use here and now for your testing scenarios. Lastly, we covered pipeable operators, and our new preferred way of importing and composing operators to ensure we end up with the smallest possible bundle size. </p>
<p>With all this RxJS knowledge, it is now time to take on the Redux pattern and its core concepts in the coming chapter, so we are ready to tackle NgRx in the final chapter of this book. It's time to get excited, if you weren't before.</p>


            </article>

            
        </section>
    </body></html>