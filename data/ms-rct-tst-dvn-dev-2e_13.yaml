- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Test-Driving GraphQL
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动 GraphQL
- en: '**GraphQL** offers an alternative to HTTP requests for fetching data. It offers
    a whole bunch of additional features that can be added to data requests.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**GraphQL** 为获取数据提供了 HTTP 请求的替代方案。它为数据请求提供了一系列额外的功能。'
- en: As with Redux, GraphQL systems can seem complicated, but TDD helps to provide
    an approach to understanding and learning.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Redux 类似，GraphQL 系统可能看起来很复杂，但 TDD 有助于提供理解和学习的途径。
- en: In this chapter, we’ll use the `CustomerHistory` component that displays details
    of a single customer and their appointment history.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 `CustomerHistory` 组件来显示单个客户的详细信息及其预约历史。
- en: This is a bare-bones GraphQL implementation that shows the fundamentals of test-driving
    the technology. If you’re using other GraphQL libraries instead of Relay, the
    techniques we’ll explore in this chapter will also apply.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基础的 GraphQL 实现，展示了测试驱动技术的核心。如果您使用的是其他 GraphQL 库而不是 Relay，本章中我们将探讨的技术也适用。
- en: 'Here’s what the new `CustomerHistory` component looks like:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新 `CustomerHistory` 组件的外观：
- en: '![Figure 13.1 – The new CustomerHistory component ](img/Figure_13.01_B18423.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – 新的 CustomerHistory 组件](img/Figure_13.01_B18423.jpg)'
- en: Figure 13.1 – The new CustomerHistory component
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 新的 CustomerHistory 组件
- en: 'This chapter covers the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Compiling the schema before you begin
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始之前编译模式
- en: Test-driving the Relay environment
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动 Relay 环境
- en: Fetching GraphQL data from within a component
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从组件内部获取 GraphQL 数据
- en: By the end of the chapter, you’ll have explored the test-driven approach to
    GraphQL.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将探索测试驱动方法在 GraphQL 中的应用。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter can be found here:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在此处找到：
- en: '[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter13)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter13)'
- en: Compiling the schema before you begin
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在开始之前编译模式
- en: 'The code samples for this chapter already contain some additions:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码示例已经包含了一些新增内容：
- en: The `react-relay`, `relay-compiler`, and `babel-plugin-relay` packages.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-relay`、`relay-compiler` 和 `babel-plugin-relay` 包。'
- en: Babel configuration to ensure your build understands the new GraphQL syntax.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Babel 配置以确保您的构建过程理解新的 GraphQL 语法。
- en: Relay configuration in the `relay.config.json` file. The primary piece of configuration
    is the location of the schema.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `relay.config.json` 文件中的 Relay 配置。主要的配置项是模式的存储位置。
- en: A GraphQL schema in the file `src/schema.graphql`.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件 `src/schema.graphql` 中的 GraphQL 模式。
- en: A server endpoint at `POST/graphql`, which services incoming GraphQL requests.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个位于 `POST/graphql` 的服务器端点，用于处理传入的 GraphQL 请求。
- en: 'It’s beyond the scope of this book to go into each of these, but you will need
    to compile the schema before you begin, which can be done by typing the following
    command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不涉及这些内容的每个细节，但您在开始之前需要编译模式，可以通过输入以下命令来完成：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `npm run build` command has also been modified to run this command for you,
    just in case you forget. Once everything is compiled, you’re ready to write some
    tests.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm run build` 命令也已修改，以便在您忘记的情况下为您运行此命令。一旦所有内容都编译完成，您就可以开始编写测试了。'
- en: Testing the Relay environment
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 Relay 环境
- en: There are a few different ways to approach the integration of Relay into a React
    application. The method we’ll use in this book is the `fetchQuery` function, which
    is analogous to the `global.fetch` function we’ve already used for standard HTTP
    requests.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的方法可以将 Relay 集成到 React 应用程序中。本书中我们将使用 `fetchQuery` 函数，该函数与我们已经用于标准 HTTP
    请求的 `global.fetch` 函数类似。
- en: However, Relay’s `fetchQuery` function has a much more complicated setup than
    `global.fetch`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Relay 的 `fetchQuery` 函数的设置比 `global.fetch` 复杂得多。
- en: One of the parameters of the `fetchQuery` function is the *environment*, and
    in this section, we’ll see what that is and how to construct it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchQuery` 函数的一个参数是 *环境*，在本节中，我们将了解这是什么以及如何构建它。'
- en: Why Do We Need to Construct an Environment?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要构建一个环境？
- en: The Relay environment is an extension point where all manner of functionality
    can be added. Data caching is one example. If you’re interested in how to do that,
    check out the *Further reading* section at the end of this chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 继电器环境是一个扩展点，可以添加各种功能。数据缓存就是一个例子。如果你对此感兴趣，请查看本章末尾的*进一步阅读*部分。
- en: We will build a function named `buildEnvironment`, and then another named `getEnvironment`
    that provides a singleton instance of this environment so that the initialization
    only needs to be done once. Both functions return an object of type `Environment`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个名为`buildEnvironment`的函数，然后是另一个名为`getEnvironment`的函数，它提供这个环境的单例实例，这样初始化只需要进行一次。这两个函数都返回一个类型为`Environment`的对象。
- en: One of the arguments that the `Environment` constructor requires is a function
    named `performFetch`. This function, unsurprisingly, is the bit that actually
    fetches data – in our case, from the `POST /graphql` server endpoint.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Environment`构造函数所需的参数之一是一个名为`performFetch`的函数。不出所料，这个函数实际上是获取数据的部分——在我们的例子中，是从`POST
    /graphql`服务器端点获取数据。'
- en: In a separate test, we'll check whether `performFetch` is passed to the new
    `Environment` object. We need to treat `performFetch` as its own unit because
    we’re not going to be testing the behavior of the resulting environment, only
    its construction.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个单独的测试中，我们将检查`performFetch`是否传递给了新的`Environment`对象。我们需要将`performFetch`视为其自身的单元，因为我们不会测试结果环境的操作行为，而只是测试其构建。
- en: Building a performFetch function
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建performFetch函数
- en: 'Let’s begin by creating our own `performFetch` function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建自己的`performFetch`函数：
- en: 'Create a new file, `test/relayEnvironment.test.js`, and add the following setup.
    This sets up our `global.fetch` spy in the same way as usual. There are two new
    constants here, `text` and `variables`, which we’ll use soon:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，`test/relayEnvironment.test.js`，并添加以下设置。这以通常的方式设置我们的`global.fetch`间谍。这里有两个新的常量，`text`和`variables`，我们将很快使用：
- en: '[PRE1]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, add the first test, checking that we make the appropriate HTTP request.
    The call to `performFetch` takes two parameters that contain `text` (wrapped in
    an object) and `variables`. This mimics how the Relay environment will call the
    `performFetch` function for each request:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加第一个测试，检查我们是否发出了适当的HTTP请求。`performFetch`函数调用包含两个参数，它们包含`text`（封装在对象中）和`variables`。这模仿了继电器环境将如何为每个请求调用`performFetch`函数：
- en: '[PRE2]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a new file, `src/relayEnvironment.js`, and make the test pass with the
    following code:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，`src/relayEnvironment.js`，并使用以下代码使测试通过：
- en: '[PRE3]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the second of our tests for the HTTP request dance, which ensures we pass
    the correct request configuration:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加我们HTTP请求舞蹈的第二个测试，确保我们传递了正确的请求配置：
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Make that pass by adding the two lines highlighted here:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加这里突出显示的两行代码来使它通过：
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, add the third and final test of our HTTP request dance. This one checks
    that we pass the right request data – the required `text` query and the `variables`
    argument included within it:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加我们HTTP请求舞蹈的第三个和最后一个测试。这个测试检查我们是否传递了正确的请求数据——所需的`text`查询和包含在内的`variables`参数：
- en: '[PRE6]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Make that pass by defining the `body` property for the `fetch` request, as
    shown here:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过定义`fetch`请求的`body`属性来使它通过，如下所示：
- en: '[PRE7]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Understanding Operation, Text, and Variables
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 理解操作、文本和变量
- en: The `text` property of the `operation` argument is a static piece of data that
    defines the query, and the `variables` argument will be the piece that is relevant
    to this specific request.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`operation`参数的`text`属性是定义查询的静态数据，而`variables`参数将是与这个特定请求相关的部分。'
- en: The tests we’re writing in this chapter do not go as far as checking the *behavior*
    of this Relay plumbing code. When writing this type of unit test, which doesn’t
    exercise behavior, it’s important to note that some kind of **end-to-end test**
    will be necessary. That will ensure your unit tests have the right specification.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们编写的测试并不包括检查这个继电器管道代码的*行为*。在编写这种不涉及行为的单元测试时，重要的是要注意，将需要某种类型的**端到端测试**。这将确保你的单元测试具有正确的规范。
- en: 'The next test checks that we return the right data from the function. Relay
    expects our `performFetch` function to return a promise that will either resolve
    or reject. In this case, we’re resolving it to the `fetch` response:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个测试检查我们从函数返回正确的数据。继电器期望我们的`performFetch`函数返回一个承诺，该承诺将解决或拒绝。在这种情况下，我们将其解决为`fetch`响应：
- en: '[PRE8]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Make that pass:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使其通过：
- en: '[PRE9]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we need to handle the error cases. We need the promise to reject if an
    HTTP error occurred. We use a new form of the `expect` function that we haven’t
    seen before; it takes a promise and expects it to reject:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要处理错误情况。如果发生了 HTTP 错误，我们需要让 promise 拒绝。我们使用我们之前没有见过的 `expect` 函数的新形式；它接受一个
    promise 并期望它拒绝：
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In our production code, we’ll test whether the fetch response’s `ok` property
    is `false`, and reject the promise if it is. Add the following function:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的生产代码中，我们将测试 fetch 响应的 `ok` 属性是否为 `false`，如果是，则拒绝 promise。添加以下函数：
- en: '[PRE11]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Call that function within your promise chain. After this, our `performFetch`
    function is complete:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 promise 链中调用该函数。之后，我们的 `performFetch` 函数就完成了：
- en: '[PRE12]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You’ve now learned how to specify and test the `performFetch` function required
    for the `Environment` constructor. Now, we’re ready to do that construction.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经学会了如何指定和测试 `Environment` 构造函数所需的 `performFetch` 函数。现在，我们准备进行这个构造。
- en: Test-driving the Environment object construction
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 Environment 对象的构造
- en: We’re going to build a function named `buildEnvironment`, that takes all the
    various pieces we need to build an `Environment` object. The reason there are
    so many pieces is that they are all extension points that enable the configuration
    of the Relay connection.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个名为 `buildEnvironment` 的函数，它接受构建 `Environment` 对象所需的所有各种部分。之所以有这么多部分，是因为它们都是扩展点，使得配置
    Relay 连接成为可能。
- en: These pieces are our `performFetch` function and a bunch of other Relay types
    that come directly from the `relay-runtime` package. We’ll use `jest.mock` to
    mock all these out in one fell swoop.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些部分是我们的 `performFetch` 函数和一些直接来自 `relay-runtime` 包的 Relay 类型。我们将使用 `jest.mock`
    一次性模拟所有这些。
- en: 'Let’s get started:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'In the same test file, `test/relayEnvironment.test.js`, update your import
    to include the new function:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的测试文件 `test/relayEnvironment.test.js` 中，更新你的导入以包含新的函数：
- en: '[PRE13]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, it’s time to import all the relevant pieces we need from the `relay-runtime`
    package and mock them out. Add the following to the top of the file:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候从 `relay-runtime` 包中导入所有我们需要的相关部分并模拟它们了。在文件顶部添加以下内容：
- en: '[PRE14]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For our first test, we need to test that the `Environment` constructor was
    called:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的第一个测试，我们需要测试 `Environment` 构造函数是否被调用：
- en: '[PRE15]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Start by adding all the imports in the production code in `src/relayEnvironment.js`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `src/relayEnvironment.js` 的生产代码中添加所有导入：
- en: '[PRE16]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Make the test pass by adding this code at the bottom of the file:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在文件底部添加以下代码来使测试通过：
- en: '[PRE17]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The second test makes sure we pass the right arguments to `Environment`. Its
    first argument is the result of calling `Network.create`, and the second argument
    is the result of constructing a `Store` object. The tests need to mock those out
    and then check the return values:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个测试确保我们向 `Environment` 函数传递了正确的参数。它的第一个参数是调用 `Network.create` 的结果，第二个参数是构造
    `Store` 对象的结果。测试需要模拟这些并检查返回值：
- en: '[PRE18]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Mocking Constructors
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟构造函数
- en: Note the difference in how we mock out constructors and function calls. To mock
    out a new `Store` and a new `Environment`, we need to use `mockImplementation(fn)`.
    To mock out `Network.create`, we need to use `mockReturnValue(returnValue)`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们模拟构造函数和函数调用的差异。为了模拟一个新的 `Store` 和一个新的 `Environment`，我们需要使用 `mockImplementation(fn)`。为了模拟
    `Network.create`，我们需要使用 `mockReturnValue(returnValue)`。
- en: 'Make the test pass by updating the function to pass those arguments to the
    `Environment` constructor:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过更新函数以将这些参数传递给 `Environment` 构造函数来使测试通过：
- en: '[PRE19]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next up, we need to ensure that `Network.create` gets a reference to our `performFetch`
    function:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保 `Network.create` 获取到我们的 `performFetch` 函数的引用：
- en: '[PRE20]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Make that pass by passing `performFetch` to the `Network.create` function:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将 `performFetch` 传递给 `Network.create` 函数来实现这个通过：
- en: '[PRE21]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `Store` constructor needs a `RecordSource` object. Add a new mock implementation
    for `RecordSource` in your test setup:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Store` 构造函数需要一个 `RecordSource` 对象。在你的测试设置中添加一个新的模拟实现 `RecordSource`：'
- en: '[PRE22]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following test to specify the behavior we want:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下测试以指定我们想要的行为：
- en: '[PRE23]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Make that pass by constructing a new `RecordSource` object:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过构造一个新的 `RecordSource` 对象来实现这个通过：
- en: '[PRE24]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: And that, would you believe, is it for `buildEnvironment`! At this stage, you
    will have a valid `Environment` object.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，`buildEnvironment` 就完成了！在这个阶段，你将拥有一个有效的 `Environment` 对象。
- en: Test-driving a singleton instance of Environment
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 Environment 单例实例
- en: Because creating `Environment` takes a substantial amount of plumbing, it’s
    common to construct it once and then use that value for the rest of the application.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因为创建 `Environment` 需要大量的配置工作，所以通常我们会创建一次，然后在整个应用程序中使用这个值。
- en: An Alternative Approach Using RelayEnvironmentProvider
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 RelayEnvironmentProvider 的替代方法
- en: There is an alternative approach to using the singleton instance shown here,
    which is to use React Context. The `RelayEnvironmentProvider` component provided
    by Relay can help you with that. For more information, see the *Further reading*
    section at the end of the chapter.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这里显示的单例实例的替代方法之一是使用 React Context。Relay 提供的 `RelayEnvironmentProvider` 组件可以帮助你做到这一点。有关更多信息，请参阅本章末尾的
    *进一步阅读* 部分。
- en: 'Let’s build the `getEnvironment` function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建 `getEnvironment` 函数：
- en: 'Import the new function at the top of `test/relayEnvironment.test.js`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `test/relayEnvironment.test.js` 的顶部导入新的函数：
- en: '[PRE25]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'At the bottom of the file, add a third `describe` block with the one and only
    one test for this function:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件的底部，添加一个包含一个测试的第三个 `describe` 块，针对这个函数：
- en: '[PRE26]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In `src/relayEnvironment.js`, make that pass by introducing a top-level variable
    that stores the result of `getEnvironment` if it hasn’t yet been called:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/relayEnvironment.js` 中，通过引入一个顶层变量来存储 `getEnvironment` 的结果（如果尚未调用）来实现这一点：
- en: '[PRE27]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: That’s all for the environment boilerplate. We now have a shiny `getEnvironment`
    function that we can use within our React components.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 环境模板代码就到这里。我们现在有一个闪亮的 `getEnvironment` 函数，我们可以在我们的 React 组件中使用它。
- en: In the next section, we’ll start on the `CustomerHistory` component.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始构建 `CustomerHistory` 组件。
- en: Fetching GraphQL data from within a component
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在组件内部获取 GraphQL 数据
- en: 'Now that we have a Relay environment, we can begin to build out our feature.
    Recall from the introduction that we’re building a new `CustomerHistory` component
    that displays customer details and a list of the customer’s appointments. A GraphQL
    query to return this information already exists in our server, so we just need
    to call it in the right way. The query looks like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 Relay 环境，我们可以开始构建我们的功能。回想一下介绍中提到的，我们正在构建一个新的 `CustomerHistory` 组件，用于显示客户详情和客户的预约列表。返回此信息的
    GraphQL 查询已经存在于我们的服务器中，所以我们只需要以正确的方式调用它。查询看起来像这样：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This says we get a customer record for a given customer ID (specified by the
    `$id` parameter), together with a list of their appointments.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示我们为指定的客户 ID（由 `$id` 参数指定）获取一个客户记录，以及他们的预约列表。
- en: 'Our component will perform this query when it’s mounted. We’ll jump right in
    with that functionality, by testing the call to `fetchQuery`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件挂载时，我们的组件将执行此查询。我们将直接测试 `fetchQuery` 的调用：
- en: 'Create a new file, `test/CustomerHistory.test.js`, and add the following setup.
    We’re going to break this setup into parts, as it’s long! First up is our import,
    and the call to mock `relay-runtime` again, so that we can stub `fetchQuery`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件，`test/CustomerHistory.test.js`，并添加以下设置。我们将把这个设置分成几个部分，因为它很长！首先是我们导入，以及再次调用模拟
    `relay-runtime`，这样我们就可以模拟 `fetchQuery`：
- en: '[PRE29]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, let’s define some sample data:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义一些示例数据：
- en: '[PRE30]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, let’s get `beforeEach` in place. This stubs out `fetchQuery` with a special
    `sendCustomer` fake, mimicking the return value of a `fetchQuery` request:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们确保 `beforeEach` 正确设置。这个占位符使用特殊的 `sendCustomer` 模拟，来模仿 `fetchQuery` 请求的返回值：
- en: '[PRE31]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The Return Value of fetchQuery
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: fetchQuery 的返回值
- en: This function has a relatively complex usage pattern. A call to `fetchQuery`
    returns an object with `subscribe` and `unsubscribe` function properties We call
    `subscribe` with an object with a `next` callback property. That callback is called
    by Relay’s `fetchQuery` each time the query returns a result set. We can use that
    callback to set our component state. Finally, the `unsubscribe` function is returned
    from the `useEffect` block so that it’s called when the component is unmounted
    or the relevant props change.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有一个相对复杂的用法模式。对 `fetchQuery` 的调用返回一个具有 `subscribe` 和 `unsubscribe` 函数属性的对象。我们使用具有
    `next` 回调属性的对象调用 `subscribe`。该回调由 Relay 的 `fetchQuery` 在查询返回结果集时调用。我们可以使用该回调来设置组件状态。最后，`unsubscribe`
    函数从 `useEffect` 块返回，以便在组件卸载或相关属性更改时调用。
- en: 'Finally, add the test, which checks that we call `fetchQuery` in the expected
    way:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加测试，检查我们是否以预期的方式调用 `fetchQuery`：
- en: '[PRE32]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let’s make that pass. Create a new file, `src/CustomerHistory.js`, and start
    it off with the imports and the exported `query` definition:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们确保这一点。创建一个新的文件，`src/CustomerHistory.js`，并从导入和导出的 `query` 定义开始：
- en: '[PRE33]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the component, together with a `useEffect` Hook:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加该组件，以及一个 `useEffect` 钩子：
- en: '[PRE34]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you run tests now, you might see an error, as shown here:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在运行测试，你可能会看到错误，如下所示：
- en: '[PRE35]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To fix this, run the following command to compile your GraphQL query:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个问题，运行以下命令来编译你的 GraphQL 查询：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we can add a test to show what happens when we pull out some data:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以添加一个测试来显示当我们提取一些数据时会发生什么：
- en: '[PRE37]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To make that pass, update the `useEffect` block to return the `unsubscribe`
    function property:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使测试通过，更新 `useEffect` 块以返回 `unsubscribe` 函数属性：
- en: '[PRE38]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, update your component to render that data, pulling in the customer data:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，更新你的组件以渲染这些数据，包括客户数据：
- en: '[PRE39]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, update your component to include a new state variable, `customer`. This
    is set by calling `setCustomer` in our definition of the next callback:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，更新你的组件以包括一个新的状态变量 `customer`。这是通过在我们的下一个回调定义中调用 `setCustomer` 来设置的：
- en: '[PRE40]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Make the test pass by extending your JSX to render the customer data:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过扩展你的 JSX 来渲染客户数据，使测试通过：
- en: '[PRE41]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, add a test to also render the customer’s phone number:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个测试来渲染客户的电话号码：
- en: '[PRE42]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Make that pass with the change shown here:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下更改使测试通过：
- en: '[PRE43]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, let’s get started on rendering the appointments:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们开始渲染预约信息：
- en: '[PRE44]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'That’s a quick one to fix; add in the `h3` element, as shown here:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这很容易修复；添加一个 `h3` 元素，如下所示：
- en: '[PRE45]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we’ll render a table for each of the appointments available:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为每个可用的预约渲染一个表格：
- en: '[PRE46]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add that table:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下表格：
- en: '[PRE47]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'For the next set of tests, we’ll use a `columnValues` helper, which will find
    a rendered table element and pull out an array of all the values in a column.
    We can use this to test that our code displays data for a list of appointments,
    rather than just one:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于下一组测试，我们将使用一个 `columnValues` 辅助函数，它将找到一个渲染的表格元素并提取列中的所有值。我们可以使用这个来测试我们的代码显示的是一系列预约的数据，而不仅仅是单个数据：
- en: '[PRE48]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Add a new `tbody` element here, just below `thead`. This makes a reference
    to a new `AppointmentRow` component, which we haven’t built yet, but we will do
    so in the next step:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `thead` 下方添加一个新的 `tbody` 元素。这引用了一个我们还没有构建的新 `AppointmentRow` 组件，但我们将在这个下一步中完成它：
- en: '[PRE49]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, let’s define `AppointmentRow`. Add this above the `CustomerHistory` definition.
    After this, your test should pass:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义 `AppointmentRow`。在 `CustomerHistory` 定义之上添加此代码。之后，你的测试应该通过：
- en: '[PRE50]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let’s add in the other columns, starting with the stylist:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加其他列，从样式列开始：
- en: '[PRE51]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Add that as the next column in `AppointmentRow`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它作为 `AppointmentRow` 的下一个列添加：
- en: '[PRE52]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next is the `service` field:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是 `service` 字段：
- en: '[PRE53]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Again, that involves simply adding a further `td` element to `AppointmentRow`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，这仅仅涉及在 `AppointmentRow` 中添加一个额外的 `td` 元素：
- en: '[PRE54]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Finally, for rendering information, we’ll show the `notes` field too.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了渲染信息，我们还将显示 `notes` 字段。
- en: '[PRE55]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Complete the `AppointmentRow` component, as shown here:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成如这里所示的 `AppointmentRow` 组件：
- en: '[PRE56]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We’re almost done. Let’s display a `describe` block, just below the test that
    we’ve just completed. It uses a `noSend` fake that does nothing; there’s no call
    to `next`. This can be used to mimic the scenario when data is still loading:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们几乎完成了。让我们在刚刚完成的测试下方显示一个 `describe` 块。它使用一个不执行任何操作的 `noSend` 模拟；没有调用 `next`。这可以用来模拟数据仍在加载的情况：
- en: '[PRE57]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To make that pass, introduce a conditional just before the JSX:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使测试通过，在 JSX 之前引入一个条件：
- en: '[PRE58]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, let’s handle the case when there’s an error fetching data. This uses
    another fake, `errorSend`, that invokes the error callback. It’s like the `next`
    callback and can be used to set state, which we’ll see in the next step:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们处理在获取数据时出现错误的情况。这使用了另一个模拟的 `errorSend`，它调用错误回调。它就像 `next` 回调一样，可以用来设置状态，我们将在下一步中看到：
- en: '[PRE59]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To make that pass, you’ll need to introduce a new `status` state variable.
    Initially, this has the `loading` value. When successful, it changes to `loaded`,
    and when an error occurs, it changes to `failed`. For the `failed` state, we render
    the specified error message:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使测试通过，你需要引入一个新的 `status` 状态变量。最初，它具有 `loading` 值。当成功时，它变为 `loaded`，当发生错误时，它变为
    `failed`。对于 `failed` 状态，我们渲染指定的错误消息：
- en: '[PRE60]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: That completes the new `CustomerHistory` component. You have now learned how
    to test-drive the use of Relay’s `fetchQuery` function in your application, and
    this component is now ready to integrate with `App`. This is left as an exercise.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了新的 `CustomerHistory` 组件。你现在已经学会了如何在你的应用程序中测试驱动 Relay 的 `fetchQuery` 函数的使用，并且这个组件现在可以与
    `App` 集成了。这被留作练习。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has explored how to test-drive the integration of a GraphQL endpoint
    using Relay. You have seen how to test-drive the building of the Relay environment,
    and how to build a component that uses the `fetchQuery` API.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了如何使用Relay测试驱动集成GraphQL端点。你看到了如何测试驱动构建Relay环境，以及如何构建使用`fetchQuery` API的组件。
- en: In *Part 3*, *Interactivity*, we’ll begin work in a new code base that will
    allow us to explore more complex use cases involving undo/redo, animation, and
    WebSocket manipulation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第三部分*，*交互性*中，我们将开始在一个新的代码库中工作，这将使我们能够探索涉及撤销/重做、动画和WebSocket操作更复杂的用例。
- en: In [*Chapter 14*](B18423_14.xhtml#_idTextAnchor277), *Building a Logo Interpreter*,
    we’ll begin by writing new Redux middleware to handle undo/redo behavior.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第14章*](B18423_14.xhtml#_idTextAnchor277), *构建Logo解释器*中，我们将首先编写新的Redux中间件来处理撤销/重做行为。
- en: Exercises
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Integrate the `CustomerHistory` component into the rest of your application
    by taking the following steps:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤将`CustomerHistory`组件集成到你的应用程序的其余部分：
- en: Add a new route at `/viewHistory?customer=<customer id>` that displays the `CustomerHistory`
    component, using a new intermediate `CustomerHistoryRoute` component.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/viewHistory?customer=<customer id>`处添加一个新的路由，显示`CustomerHistory`组件，使用一个新的中间`CustomerHistoryRoute`组件。
- en: Add a new `Link` to the search actions on the `CustomerSearch` screen, titled
    **View history**, that, when pressed, navigates to the new route.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CustomerSearch`屏幕上的搜索操作中添加一个新的`Link`，标题为**查看历史记录**，当按下时，将导航到新路由。
- en: Further reading
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The `RelayEnvironmentProvider` component:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`RelayEnvironmentProvider`组件：'
- en: '[https://relay.dev/docs/api-reference/relay-environment-provider/](https://relay.dev/docs/api-reference/relay-environment-provider/)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://relay.dev/docs/api-reference/relay-environment-provider/](https://relay.dev/docs/api-reference/relay-environment-provider/)'
- en: Part 3 – Interactivity
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分 – 交互性
- en: This part introduces a new code base that allows us to explore more complex
    scenarios where TDD can be applied. You’ll take a deep dive into Redux middleware,
    animation, and WebSockets. The goal is to show how complex tasks are approached
    using the TDD workflow.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分介绍了一个新的代码库，使我们能够探索更多复杂场景，在这些场景中可以应用TDD。你将深入探究Redux中间件、动画和WebSockets。目标是展示如何使用TDD工作流程来处理复杂任务。
- en: 'This part includes the following chapters:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 14*](B18423_14.xhtml#_idTextAnchor277), *Building a Logo Interpreter*'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B18423_14.xhtml#_idTextAnchor277), *构建Logo解释器*'
- en: '[*Chapter 15*](B18423_15.xhtml#_idTextAnchor306), *Adding Animation*'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B18423_15.xhtml#_idTextAnchor306), *添加动画*'
- en: '[*Chapter 16*](B18423_16.xhtml#_idTextAnchor322), *Working with WebSockets*'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第16章*](B18423_16.xhtml#_idTextAnchor322), *与WebSockets协作*'
