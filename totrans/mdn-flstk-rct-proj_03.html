<html><head></head><body>
<div id="_idContainer032" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-29"><a id="_idTextAnchor028" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-30" class="calibre5"><a id="_idTextAnchor029" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.2.1">Getting to Know Node.js and MongoDB</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">In the previous chapter, we set up our IDE and a basic project for frontend development. </span><span class="kobospan" id="kobo.3.2">In this chapter, we will first learn how to write and run scripts with Node.js. </span><span class="kobospan" id="kobo.3.3">Then, we will move on to introducing Docker as a way to set up a database service. </span><span class="kobospan" id="kobo.3.4">Once we have set up Docker and a container for our database, we are going to access it to learn more about MongoDB, the document database that we will use going forward. </span><span class="kobospan" id="kobo.3.5">Finally, we will connect everything we have learned in this chapter by accessing MongoDB via </span><span><span class="kobospan" id="kobo.4.1">Node.js scripts.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.5.1">By the end of this chapter, you will have an understanding of the most important tools and concepts in backend development with JavaScript. </span><span class="kobospan" id="kobo.5.2">This chapter gives us a good foundation to create a backend service for our first full-stack application in the </span><span><span class="kobospan" id="kobo.6.1">upcoming chapters.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.7.1">In this chapter, we are going to cover the following </span><span><span class="kobospan" id="kobo.8.1">main topics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.9.1">Writing and running scripts </span><span><span class="kobospan" id="kobo.10.1">with Node.js</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.11.1">Introducing Docker, a platform </span><span><span class="kobospan" id="kobo.12.1">for containers</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.13.1">Introducing MongoDB, a </span><span><span class="kobospan" id="kobo.14.1">document database</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.15.1">Accessing the MongoDB database </span><span><span class="kobospan" id="kobo.16.1">via Node.js</span></span></li>
</ul>
<h1 id="_idParaDest-31" class="calibre5"><a id="_idTextAnchor030" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.17.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.18.1">Before we start, please install the following (in addition to all technical requirements from </span><a href="B19385_01.xhtml#_idTextAnchor016" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.19.1">Chapter 1</span></em></span></a><span class="kobospan" id="kobo.20.1">, </span><em class="italic"><span class="kobospan" id="kobo.21.1">Preparing for Full-stack Development</span></em><span class="kobospan" id="kobo.22.1">), if you do not already have </span><span><span class="kobospan" id="kobo.23.1">them installed:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><span class="kobospan" id="kobo.24.1">Docker v24.0.6</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.25.1">Docker </span><span><span class="kobospan" id="kobo.26.1">Desktop v4.25.2</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.27.1">MongoDB </span><span><span class="kobospan" id="kobo.28.1">Shell v2.1.0</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.29.1">The versions listed are the ones used in the book. </span><span class="kobospan" id="kobo.29.2">While installing a newer version should not be an issue, please note that certain steps might work differently on a newer version. </span><span class="kobospan" id="kobo.29.3">If you are having an issue with the code and steps provided in this book, please try using the </span><span><span class="kobospan" id="kobo.30.1">mentioned versions.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.31.1">You can find the code for this chapter on </span><span><span class="kobospan" id="kobo.32.1">GitHub: </span></span><a href="https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch2" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.33.1">https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch2</span></span></a><span><span class="kobospan" id="kobo.34.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.35.1">The CiA video for this chapter can be found </span><span><span class="kobospan" id="kobo.36.1">at: </span></span><a href="https://youtu.be/q_LHsdJEaPo" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.37.1">https://youtu.be/q_LHsdJEaPo</span></span></a><span><span class="kobospan" id="kobo.38.1">.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.39.1">Important</span></p>
<p class="callout"><span class="kobospan" id="kobo.40.1">If you cloned the full repository for the book, Husky may not find the </span><strong class="source-inline1"><span class="kobospan" id="kobo.41.1">.git</span></strong><span class="kobospan" id="kobo.42.1"> directory when running </span><strong class="source-inline1"><span class="kobospan" id="kobo.43.1">npm install</span></strong><span class="kobospan" id="kobo.44.1">. </span><span class="kobospan" id="kobo.44.2">In that case, just run </span><strong class="source-inline1"><span class="kobospan" id="kobo.45.1">git init</span></strong><span class="kobospan" id="kobo.46.1"> in the root of the corresponding </span><span><span class="kobospan" id="kobo.47.1">chapter folder.</span></span></p>
<h1 id="_idParaDest-32" class="calibre5"><a id="_idTextAnchor031" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.48.1">Writing and running scripts with Node.js</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.49.1">For us to become full-stack developers, it is important to get familiar with backend technologies. </span><span class="kobospan" id="kobo.49.2">As we are already familiar with JavaScript from writing frontend applications, we can use Node.js to develop backend services using JavaScript. </span><span class="kobospan" id="kobo.49.3">In this section, we are going to create our first simple Node.js script to get familiar with the differences between backend scripts and </span><span><span class="kobospan" id="kobo.50.1">frontend code.</span></span></p>
<h2 id="_idParaDest-33" class="calibre7"><a id="_idTextAnchor032" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.51.1">Similarities and differences between JavaScript in the browser and in Node.js</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.52.1">Node.js</span><a id="_idIndexMarker050" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.53.1"> is built on V8, the JavaScript engine used by Chromium-based browsers (Google Chrome, Brave, Opera, Vivaldi, and Microsoft Edge). </span><span class="kobospan" id="kobo.53.2">As such, JavaScript code will run the same way in the browser and Node.js. </span><span class="kobospan" id="kobo.53.3">However, there are some differences, specifically in the environment. </span><span class="kobospan" id="kobo.53.4">The environment is built on top of the engine and allows us to render something on a website in the browser (using the </span><strong class="source-inline"><span class="kobospan" id="kobo.54.1">document</span></strong><span class="kobospan" id="kobo.55.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.56.1">window</span></strong><span class="kobospan" id="kobo.57.1"> objects). </span><span class="kobospan" id="kobo.57.2">In Node.js, there are certain modules provided to interface with the operating system, for tasks such as creating files and handling network requests. </span><span class="kobospan" id="kobo.57.3">These modules allow us to create a backend service </span><span><span class="kobospan" id="kobo.58.1">using Node.js.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.59.1">Let’s have a look at the</span><a id="_idIndexMarker051" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.60.1"> Node.js architecture</span><a id="_idIndexMarker052" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.61.1"> versus JavaScript in </span><span><span class="kobospan" id="kobo.62.1">the browser:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer018">
<span class="kobospan" id="kobo.63.1"><img alt="Figure 2.1 – The Node.js architecture versus JavaScript in the browser" src="image/B19385_02_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.64.1">Figure 2.1 – The Node.js architecture versus JavaScript in the browser</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.65.1">As we can see from the visualization, both Node.js and browser JavaScript run on a JavaScript engine, which is always V8 in Node.js, and can be V8 for Chromium-based browsers, SpiderMonkey for Firefox, or JavaScriptCore </span><span><span class="kobospan" id="kobo.66.1">for Safari.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.67.1">Now that we know that we can run JavaScript code in Node.js, let’s try </span><span><span class="kobospan" id="kobo.68.1">it out!</span></span></p>
<h2 id="_idParaDest-34" class="calibre7"><a id="_idTextAnchor033" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.69.1">Creating our first Node.js script</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.70.1">Before we can </span><a id="_idIndexMarker053" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.71.1">start writing backend services, we need to get familiar with the Node.js environment. </span><span class="kobospan" id="kobo.71.2">So, let’s start by writing a simple “hello </span><span><span class="kobospan" id="kobo.72.1">world” example:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.73.1">Copy the </span><strong class="source-inline1"><span class="kobospan" id="kobo.74.1">ch1</span></strong><span class="kobospan" id="kobo.75.1"> folder from the previous chapter to a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.76.1">ch2</span></strong><span class="kobospan" id="kobo.77.1"> folder, </span><span><span class="kobospan" id="kobo.78.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.79.1">$ cp -R ch1 ch2</span></strong></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.80.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.81.1">On macOS, it is important to run the command with a capitalized </span><strong class="source-inline1"><span class="kobospan" id="kobo.82.1">-R</span></strong><span class="kobospan" id="kobo.83.1"> flag, not </span><strong class="source-inline1"><span class="kobospan" id="kobo.84.1">-r</span></strong><span class="kobospan" id="kobo.85.1">. </span><span class="kobospan" id="kobo.85.2">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.86.1">-r</span></strong><span class="kobospan" id="kobo.87.1"> flag deals differently with symlinks and causes the </span><strong class="source-inline1"><span class="kobospan" id="kobo.88.1">node_modules/</span></strong><span class="kobospan" id="kobo.89.1"> folder to break. </span><span class="kobospan" id="kobo.89.2">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.90.1">-r</span></strong><span class="kobospan" id="kobo.91.1"> flag only exists for historic reasons and should not be used on macOS. </span><span class="kobospan" id="kobo.91.2">Always prefer using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.92.1">-R</span></strong> <span><span class="kobospan" id="kobo.93.1">flag instead.</span></span></p>
<ol class="calibre15">
<li value="2" class="calibre11"><span class="kobospan" id="kobo.94.1">Open the </span><a id="_idIndexMarker054" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.95.1">new </span><strong class="source-inline1"><span class="kobospan" id="kobo.96.1">ch2</span></strong><span class="kobospan" id="kobo.97.1"> folder in </span><span><span class="kobospan" id="kobo.98.1">VS Code.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.99.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.100.1">backend</span></strong><span class="kobospan" id="kobo.101.1"> folder in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.102.1">ch2</span></strong><span class="kobospan" id="kobo.103.1"> folder. </span><span class="kobospan" id="kobo.103.2">This will contain our </span><span><span class="kobospan" id="kobo.104.1">backend code.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.105.1">In the </span><strong class="source-inline1"><span class="kobospan" id="kobo.106.1">backend</span></strong><span class="kobospan" id="kobo.107.1"> folder, create a </span><strong class="source-inline1"><span class="kobospan" id="kobo.108.1">helloworld.js</span></strong><span class="kobospan" id="kobo.109.1"> file and enter the </span><span><span class="kobospan" id="kobo.110.1">following code:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.111.1">
console.log('hello node.js world!')</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.112.1">Open a Terminal in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.113.1">ch2</span></strong><span class="kobospan" id="kobo.114.1"> folder and run the following command to execute the </span><span><span class="kobospan" id="kobo.115.1">Node.js script:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.116.1">$ node backend/helloworld.js</span></strong></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.117.1">You will see that the console output shows </span><strong class="source-inline"><span class="kobospan" id="kobo.118.1">hello node.js world!</span></strong><span class="kobospan" id="kobo.119.1">. </span><span class="kobospan" id="kobo.119.2">When writing Node.js code, we can make use of familiar functions from the frontend JavaScript world and run the same</span><a id="_idIndexMarker055" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.120.1"> JavaScript code on </span><span><span class="kobospan" id="kobo.121.1">the backend!</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.122.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.123.1">While most frontend JavaScript code will run just fine in Node.js, not all code from the frontend will automatically work in a Node.js environment. </span><span class="kobospan" id="kobo.123.2">There are certain objects, such as </span><strong class="source-inline1"><span class="kobospan" id="kobo.124.1">document</span></strong><span class="kobospan" id="kobo.125.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.126.1">window</span></strong><span class="kobospan" id="kobo.127.1">, that are specific to a browser environment. </span><span class="kobospan" id="kobo.127.2">This is important to keep in mind, especially when we introduce server-side </span><span><span class="kobospan" id="kobo.128.1">rendering later.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.129.1">Now that we have a basic understanding of how Node.js works, let’s get started handling files </span><span><span class="kobospan" id="kobo.130.1">with Node.js.</span></span></p>
<h2 id="_idParaDest-35" class="calibre7"><a id="_idTextAnchor034" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.131.1">Handling files in Node.js</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.132.1">Unlike in</span><a id="_idIndexMarker056" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.133.1"> the browser </span><a id="_idIndexMarker057" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.134.1">environment, Node.js provides functions to handle files on our computer via the </span><strong class="source-inline"><span class="kobospan" id="kobo.135.1">node:fs</span></strong><span class="kobospan" id="kobo.136.1"> (filesystem) module. </span><span class="kobospan" id="kobo.136.2">For example, we could make use of this functionality to read and write various files or even use files as a </span><span><span class="kobospan" id="kobo.137.1">simple database.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.138.1">Follow these steps to create your first Node.js script that </span><span><span class="kobospan" id="kobo.139.1">handles files:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.140.1">Create a new </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.141.1">backend/files.js</span></strong></span><span><span class="kobospan" id="kobo.142.1"> file.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.143.1">Import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.144.1">writeFileSync</span></strong><span class="kobospan" id="kobo.145.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.146.1">readFileSync</span></strong><span class="kobospan" id="kobo.147.1"> functions from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.148.1">node:fs</span></strong><span class="kobospan" id="kobo.149.1"> internal Node.js module. </span><span class="kobospan" id="kobo.149.2">This module does not need to be installed via npm, as it is provided by the </span><span><span class="kobospan" id="kobo.150.1">Node.js runtime.</span></span><pre class="source-code"><span class="kobospan1" id="kobo.151.1">
import { writeFileSync, readFileSync } from 'node:fs'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.152.1">Create a simple array containing users, with a name and </span><span><span class="kobospan" id="kobo.153.1">email address:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.154.1">
const users = [{ name: 'Adam Ondra', email: 'adam.ondra@climb.ing' }]</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.155.1">Before we can save this array to a file, we first need to convert it to a string by </span><span><span class="kobospan" id="kobo.156.1">using </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.157.1">JSON.stringify</span></strong></span><span><span class="kobospan" id="kobo.158.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.159.1">
const usersJson = JSON.stringify(users)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.160.1">Now we can save our JSON string to a file by using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.161.1">writeFileSync</span></strong><span class="kobospan" id="kobo.162.1"> function. </span><span class="kobospan" id="kobo.162.2">This function takes two arguments – first the filename, then the string to be written to </span><span><span class="kobospan" id="kobo.163.1">the file:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.164.1">
writeFileSync('backend/users.json', usersJson)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.165.1">After writing to the file, we can attempt reading it again using </span><strong class="source-inline1"><span class="kobospan" id="kobo.166.1">readFileSync</span></strong><span class="kobospan" id="kobo.167.1"> and parsing the JSON string </span><span><span class="kobospan" id="kobo.168.1">using </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.169.1">JSON.parse</span></strong></span><span><span class="kobospan" id="kobo.170.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.171.1">
const readUsersJson = readFileSync('backend/users.json')
const readUsers = JSON.parse(readUsersJson)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.172.1">Finally, we log the </span><span><span class="kobospan" id="kobo.173.1">parsed array:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.174.1">
console.log(readUsers)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.175.1">Now we can run our script. </span><span class="kobospan" id="kobo.175.2">You will see that the array gets logged and a </span><strong class="source-inline1"><span class="kobospan" id="kobo.176.1">users.json</span></strong><span class="kobospan" id="kobo.177.1"> file was created in our </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.178.1">backend/</span></strong></span><span><span class="kobospan" id="kobo.179.1"> folder:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.180.1">$ node backend/files.js</span></strong></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.181.1">You may have </span><a id="_idIndexMarker058" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.182.1">noticed that we have been using </span><strong class="source-inline"><span class="kobospan" id="kobo.183.1">writeFileSync</span></strong><span class="kobospan" id="kobo.184.1">, and</span><a id="_idIndexMarker059" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.185.1"> not </span><strong class="source-inline"><span class="kobospan" id="kobo.186.1">writeFile</span></strong><span class="kobospan" id="kobo.187.1">. </span><span class="kobospan" id="kobo.187.2">The default behavior in Node.js is to run everything asynchronously, which means that if we used </span><strong class="source-inline"><span class="kobospan" id="kobo.188.1">writeFile</span></strong><span class="kobospan" id="kobo.189.1">, the file may not have been created yet at the time when we called </span><strong class="source-inline"><span class="kobospan" id="kobo.190.1">readFile</span></strong><span class="kobospan" id="kobo.191.1">, as asynchronous code is not executed </span><span><span class="kobospan" id="kobo.192.1">in order.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.193.1">This behavior might be annoying when writing simple scripts like we did, but is very useful when dealing with, for example, network requests, where we do not want to block other users from accessing our service while dealing with </span><span><span class="kobospan" id="kobo.194.1">another request.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.195.1">After learning about handling files with Node.js, let’s learn more about how asynchronous code is executed in the browser </span><span><span class="kobospan" id="kobo.196.1">and Node.js.</span></span></p>
<h2 id="_idParaDest-36" class="calibre7"><a id="_idTextAnchor035" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.197.1">Concurrency with JavaScript in the browser and Node.js</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.198.1">An </span><a id="_idIndexMarker060" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.199.1">essential and special trait of JavaScript is that most API functions are asynchronous by default. </span><span class="kobospan" id="kobo.199.2">This means that code does not simply run in the sequence in which it is defined. </span><span class="kobospan" id="kobo.199.3">Specifically, JavaScript is event-driven. </span><span class="kobospan" id="kobo.199.4">In the browser, this means that JavaScript code will run because of user interactions. </span><span class="kobospan" id="kobo.199.5">For example, when a button is clicked, we define an </span><strong class="source-inline"><span class="kobospan" id="kobo.200.1">onClick</span></strong><span class="kobospan" id="kobo.201.1"> handler to execute </span><span><span class="kobospan" id="kobo.202.1">some code.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.203.1">On the server side, input/output operations, such as reading and writing files, and network requests, are handled asynchronously. </span><span class="kobospan" id="kobo.203.2">This means that we can handle multiple network requests at once, without having to deal with threads or multiprocessing ourselves. </span><span class="kobospan" id="kobo.203.3">Specifically, in Node.js, </span><strong class="source-inline"><span class="kobospan" id="kobo.204.1">libuv</span></strong><span class="kobospan" id="kobo.205.1"> is </span><a id="_idIndexMarker061" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.206.1">responsible for assigning threads for I/O operations while giving us, as a programmer, access to a single runtime thread to write our code in. </span><span class="kobospan" id="kobo.206.2">However, this does not mean that each connection to our backend will create a new thread. </span><span class="kobospan" id="kobo.206.3">Threads are created on the fly when advantageous. </span><span class="kobospan" id="kobo.206.4">As a developer, we do not have to deal with multi-threading and can focus on developing with asynchronous code </span><span><span class="kobospan" id="kobo.207.1">and callbacks.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.208.1">If code is synchronous, it is executed directly by putting it on</span><a id="_idIndexMarker062" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.209.1"> the </span><strong class="bold"><span class="kobospan" id="kobo.210.1">call stack</span></strong><span class="kobospan" id="kobo.211.1">. </span><span class="kobospan" id="kobo.211.2">If code is asynchronous, the operation is started, and the instance of that operation is stored in a queue, together with a callback function. </span><span class="kobospan" id="kobo.211.3">The Node.js runtime will first execute all code left in the stack. </span><span class="kobospan" id="kobo.211.4">Then, the </span><strong class="bold"><span class="kobospan" id="kobo.212.1">event loop</span></strong><span class="kobospan" id="kobo.213.1"> will </span><a id="_idIndexMarker063" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.214.1">come in and check whether there are any completed tasks in the queue. </span><span class="kobospan" id="kobo.214.2">If that is the case, the callback function is executed by putting it on the stack. </span><span class="kobospan" id="kobo.214.3">A callback function can then again either execute synchronous or asynchronous code. </span><span class="kobospan" id="kobo.214.4">When we add an event listener – for example, an </span><strong class="source-inline"><span class="kobospan" id="kobo.215.1">onClick</span></strong><span class="kobospan" id="kobo.216.1"> listener in the browser – when the user clicks the related element, the callback will also be put in the task queue, which means it will be executed when nothing else is left on the stack. </span><span class="kobospan" id="kobo.216.2">Similarly, in Node.js, we can add listeners for network events, and execute a callback when a request </span><span><span class="kobospan" id="kobo.217.1">comes in.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.218.1">In contrast </span><a id="_idIndexMarker064" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.219.1">to multi-threaded servers, a Node.js server accepts all requests in a single thread, which contains the event loop. </span><span class="kobospan" id="kobo.219.2">Multi-threaded servers have the disadvantage that threads can block I/O completely and slow down the server. </span><span class="kobospan" id="kobo.219.3">Node.js, however, delegates operations in a fine-grained way on the fly to threads. </span><span class="kobospan" id="kobo.219.4">This results in less blocking of I/O operations by default. </span><span class="kobospan" id="kobo.219.5">The downside with Node.js is that we have less control over how the multi-threading happens and thus need to be careful to avoid using synchronous functions whenever possible. </span><span class="kobospan" id="kobo.219.6">Otherwise, we will block the main Node.js thread and slow down our server. </span><span class="kobospan" id="kobo.219.7">For simplicity, we still use synchronous functions in this chapter. </span><span class="kobospan" id="kobo.219.8">Going forward, in the next chapters, we will avoid using those and rely solely on asynchronous functions (when possible) to get the </span><span><span class="kobospan" id="kobo.220.1">best performance.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.221.1">The following diagram visualizes the difference between multi-threaded servers and a </span><span><span class="kobospan" id="kobo.222.1">Node.js server:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer019">
<span class="kobospan" id="kobo.223.1"><img alt="Figure 2.2 – The difference between multi-threaded servers and a Node.js server" src="image/B19385_02_2.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.224.1">Figure 2.2 – The difference between multi-threaded servers and a Node.js server</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.225.1">We can see this asynchrony in action by using </span><strong class="source-inline"><span class="kobospan" id="kobo.226.1">setTimeout</span></strong><span class="kobospan" id="kobo.227.1">, a function that you may be familiar with from frontend code. </span><span class="kobospan" id="kobo.227.2">It waits a specified number of milliseconds and then executes</span><a id="_idIndexMarker065" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.228.1"> the code specified in the callback function. </span><span class="kobospan" id="kobo.228.2">For example, if we run the following code (with a Node.js script or in the browser, the result is the same </span><span><span class="kobospan" id="kobo.229.1">for both):</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.230.1">
console.log('first')
setTimeout(() =&gt; {
  console.log('second')
}, 1000)
console.log('third')</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.231.1">We can see that they get printed in the </span><span><span class="kobospan" id="kobo.232.1">following order:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.233.1">
first
third
second</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.234.1">This makes sense, because we are delaying the “second” </span><strong class="source-inline"><span class="kobospan" id="kobo.235.1">console.log</span></strong><span class="kobospan" id="kobo.236.1"> by a second. </span><span class="kobospan" id="kobo.236.2">However, the same output will happen if we execute the </span><span><span class="kobospan" id="kobo.237.1">following code:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.238.1">
console.log('first')
setTimeout(() =&gt; {
  console.log('second')
}, 0)
console.log('third')</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.239.1">Now that we are waiting zero milliseconds before executing the code, you would think that “second” gets printed after “first.” </span><span class="kobospan" id="kobo.239.2">However, that is not the case. </span><span class="kobospan" id="kobo.239.3">Instead, we get the same output </span><span><span class="kobospan" id="kobo.240.1">as before:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.241.1">
first
third
second</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.242.1">The reason is</span><a id="_idIndexMarker066" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.243.1"> that when we use </span><strong class="source-inline"><span class="kobospan" id="kobo.244.1">setTimeout</span></strong><span class="kobospan" id="kobo.245.1">, the JavaScript engine calls either a web API (on the browser) or a native API (on Node.js). </span><span class="kobospan" id="kobo.245.2">This API runs in native code in the engine, tracks the timeout internally, and puts the callback into the task queue, because the timer completes right away. </span><span class="kobospan" id="kobo.245.3">While this is happening, the JavaScript engine continues processing the other code by pushing it onto the stack and executing it. </span><span class="kobospan" id="kobo.245.4">When the stack is empty (there is no more code to execute), the event loop advances. </span><span class="kobospan" id="kobo.245.5">It sees that there is something in the task queue, so it executes that code, resulting in “second” being </span><span><span class="kobospan" id="kobo.246.1">printed last.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.247.1">Tip</span></p>
<p class="callout"><span class="kobospan" id="kobo.248.1">You can use the Loupe tool</span><a id="_idIndexMarker067" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.249.1"> to visualize the inner workings of the Call Stack, web APIs, Event Loop, and Callback/Task </span><span><span class="kobospan" id="kobo.250.1">Queue: </span></span><a href="http://latentflip.com/loupe/" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.251.1">http://latentflip.com/loupe/</span></span></a></p>
<p class="calibre3"><span class="kobospan" id="kobo.252.1">Now that we have learned how asynchronous code is handled in the browser and Node.js, let’s create our first web server </span><span><span class="kobospan" id="kobo.253.1">with Node.js!</span></span></p>
<h2 id="_idParaDest-37" class="calibre7"><a id="_idTextAnchor036" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.254.1">Creating our first web server</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.255.1">Now that we have</span><a id="_idIndexMarker068" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.256.1"> learned the basics of how Node.js works, we can use the </span><strong class="source-inline"><span class="kobospan" id="kobo.257.1">node:http</span></strong><span class="kobospan" id="kobo.258.1"> library to create a simple web server. </span><span class="kobospan" id="kobo.258.2">For our first simple server, we are just going to return a </span><strong class="bold"><span class="kobospan" id="kobo.259.1">200 OK</span></strong><span class="kobospan" id="kobo.260.1"> response and some plain text on any request. </span><span class="kobospan" id="kobo.260.2">Let’s get started with </span><span><span class="kobospan" id="kobo.261.1">the steps:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.262.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.263.1">backend/simpleweb.js</span></strong><span class="kobospan" id="kobo.264.1"> file, open it, and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.265.1">createServer</span></strong><span class="kobospan" id="kobo.266.1"> function from the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.267.1">node:http</span></strong></span><span><span class="kobospan" id="kobo.268.1"> module:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.269.1">
import { createServer } from 'node:http'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.270.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.271.1">createServer</span></strong><span class="kobospan" id="kobo.272.1"> function is asynchronous, so it requires us to pass a callback function to it. </span><span class="kobospan" id="kobo.272.2">This function will be executed when a request comes in from the server. </span><span class="kobospan" id="kobo.272.3">It has two arguments, a request object (</span><strong class="source-inline1"><span class="kobospan" id="kobo.273.1">req</span></strong><span class="kobospan" id="kobo.274.1">) and a response object (</span><strong class="source-inline1"><span class="kobospan" id="kobo.275.1">res</span></strong><span class="kobospan" id="kobo.276.1">). </span><span class="kobospan" id="kobo.276.2">Use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.277.1">createServer</span></strong><span class="kobospan" id="kobo.278.1"> function to define a </span><span><span class="kobospan" id="kobo.279.1">new server:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.280.1">
const server = createServer((req, res) =&gt; {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.281.1">For now, we will ignore the request object and only return a static response. </span><span class="kobospan" id="kobo.281.2">First, we set the status code </span><span><span class="kobospan" id="kobo.282.1">to </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.283.1">200</span></strong></span><span><span class="kobospan" id="kobo.284.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.285.1">
  res.statusCode = 200</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.286.1">Then, we set the </span><strong class="source-inline1"><span class="kobospan" id="kobo.287.1">Content-Type</span></strong><span class="kobospan" id="kobo.288.1"> header to </span><strong class="source-inline1"><span class="kobospan" id="kobo.289.1">text/plain</span></strong><span class="kobospan" id="kobo.290.1">, such that the browser knows what kind of response data it is </span><span><span class="kobospan" id="kobo.291.1">dealing with:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.292.1">
  res.setHeader('Content-Type', 'text/plain')</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.293.1">Lastly, we end the request by returning a </span><strong class="source-inline1"><span class="kobospan" id="kobo.294.1">Hello HTTP world!</span></strong><span class="kobospan" id="kobo.295.1"> string in </span><span><span class="kobospan" id="kobo.296.1">the response:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.297.1">
  res.end('Hello HTTP world!')
})</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.298.1">After defining the server, we need to make sure to listen on a certain host and port. </span><span class="kobospan" id="kobo.298.2">These will define where the server will be available. </span><span class="kobospan" id="kobo.298.3">For now, we use localhost on port </span><strong class="source-inline1"><span class="kobospan" id="kobo.299.1">3000</span></strong><span class="kobospan" id="kobo.300.1"> to make sure our server is available </span><span><span class="kobospan" id="kobo.301.1">via </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.302.1">http://localhost:3000/</span></strong></span><span><span class="kobospan" id="kobo.303.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.304.1">
const host = 'localhost'
const port = 3000</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.305.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.306.1">server.listen</span></strong><span class="kobospan" id="kobo.307.1"> function is also asynchronous and requires us to pass a callback function, which will execute as soon as the server is up and running. </span><span class="kobospan" id="kobo.307.2">We can simply log something here </span><span><span class="kobospan" id="kobo.308.1">for now:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.309.1">
server.listen(port, host, () =&gt; {
  console.log(`Server listening on http://${host}:${port}`)
})</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.310.1">Run the Node.js script </span><span><span class="kobospan" id="kobo.311.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.312.1">$ node backend/simpleweb.js</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.313.1">You will notice that we</span><a id="_idIndexMarker069" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.314.1"> get our </span><strong class="bold"><span class="kobospan" id="kobo.315.1">Server listening on http://localhost:3000</span></strong><span class="kobospan" id="kobo.316.1"> log message, so we know the server was started successfully. </span><span class="kobospan" id="kobo.316.2">This time, the Terminal does not return control to us; the script keeps running. </span><span class="kobospan" id="kobo.316.3">We can now open </span><strong class="source-inline1"><span class="kobospan" id="kobo.317.1">http://localhost:3000</span></strong><span class="kobospan" id="kobo.318.1"> in </span><span><span class="kobospan" id="kobo.319.1">a browser:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer020">
<span class="kobospan" id="kobo.320.1"><img alt="Figure 2.3 – A plaintext response from our first web server!" src="image/B19385_02_3.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.321.1">Figure 2.3 – A plaintext response from our first web server!</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.322.1">Now that we have set up a simple web server, we can extend it to serve a JSON file instead of simply </span><span><span class="kobospan" id="kobo.323.1">returning plaintext.</span></span></p>
<h2 id="_idParaDest-38" class="calibre7"><a id="_idTextAnchor037" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.324.1">Extending the web server to serve our JSON file</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.325.1">We can now try </span><a id="_idIndexMarker070" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.326.1">combining our knowledge of the </span><strong class="source-inline"><span class="kobospan" id="kobo.327.1">node:fs</span></strong><span class="kobospan" id="kobo.328.1"> module with the HTTP server to create a server that serves the previously created </span><strong class="source-inline"><span class="kobospan" id="kobo.329.1">users.json</span></strong><span class="kobospan" id="kobo.330.1"> file. </span><span class="kobospan" id="kobo.330.2">Let’s get started with </span><span><span class="kobospan" id="kobo.331.1">the steps:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.332.1">Copy the </span><strong class="source-inline1"><span class="kobospan" id="kobo.333.1">backend/simpleweb.js</span></strong><span class="kobospan" id="kobo.334.1"> file to a new </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.335.1">backend/webfiles.js</span></strong></span><span><span class="kobospan" id="kobo.336.1"> file.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.337.1">At the beginning of the file, add an import </span><span><span class="kobospan" id="kobo.338.1">of </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.339.1">readFileSync</span></strong></span><span><span class="kobospan" id="kobo.340.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.341.1">
import { readFileSync } from 'node:fs'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.342.1">Change the </span><strong class="source-inline1"><span class="kobospan" id="kobo.343.1">Content-Type</span></strong><span class="kobospan" id="kobo.344.1"> header </span><span><span class="kobospan" id="kobo.345.1">to </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.346.1">application/json</span></strong></span><span><span class="kobospan" id="kobo.347.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.348.1">
  res.setHeader('Content-Type', </span><strong class="bold1"><span class="kobospan1" id="kobo.349.1">'application/json'</span></strong><span class="kobospan1" id="kobo.350.1">)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.351.1">Replace the string in </span><strong class="source-inline1"><span class="kobospan" id="kobo.352.1">res.end()</span></strong><span class="kobospan" id="kobo.353.1"> with the JSON string from our file. </span><span class="kobospan" id="kobo.353.2">In this case, we do not need to parse the JSON, as </span><strong class="source-inline1"><span class="kobospan" id="kobo.354.1">res.end()</span></strong><span class="kobospan" id="kobo.355.1"> expects a </span><span><span class="kobospan" id="kobo.356.1">string anyway:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.357.1">
  res.end(</span><strong class="bold1"><span class="kobospan1" id="kobo.358.1">readFileSync('backend/users.json')</span></strong><span class="kobospan1" id="kobo.359.1">)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.360.1">If it is still running, stop the previous server script via </span><em class="italic"><span class="kobospan" id="kobo.361.1">Ctrl</span></em><span class="kobospan" id="kobo.362.1"> + </span><em class="italic"><span class="kobospan" id="kobo.363.1">C</span></em><span class="kobospan" id="kobo.364.1">. </span><span class="kobospan" id="kobo.364.2">We need to do this because we cannot listen on the same </span><span><span class="kobospan" id="kobo.365.1">port twice.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.366.1">Run the server and refresh the page to see the JSON from the file being printed. </span><span class="kobospan" id="kobo.366.2">Try changing the </span><strong class="source-inline1"><span class="kobospan" id="kobo.367.1">users.json</span></strong><span class="kobospan" id="kobo.368.1"> file and see how it is read again on the next request (when refreshing </span><span><span class="kobospan" id="kobo.369.1">the website):</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.370.1">$ node backend/webfiles.js</span></strong></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.371.1">While useful as an exercise, files are not a proper database to be used in production. </span><span class="kobospan" id="kobo.371.2">As such, we are later going to introduce MongoDB as a database. </span><span class="kobospan" id="kobo.371.3">We are going to run the MongoDB server in Docker, so let’s first briefly have a look </span><span><span class="kobospan" id="kobo.372.1">at Docker.</span></span></p>
<h1 id="_idParaDest-39" class="calibre5"><a id="_idTextAnchor038" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.373.1">Introducing Docker, a platform for containers</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.374.1">Docker</span><a id="_idIndexMarker071" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.375.1"> is a platform that allows us to package, manage, and run applications in loosely isolated </span><a id="_idIndexMarker072" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.376.1">environments, called </span><strong class="bold"><span class="kobospan" id="kobo.377.1">containers</span></strong><span class="kobospan" id="kobo.378.1">. </span><span class="kobospan" id="kobo.378.2">Containers are lightweight, are isolated from each other, and include all dependencies needed to run an application. </span><span class="kobospan" id="kobo.378.3">As such, we can use containers to easily set up various services and apps without having to deal with managing dependencies or conflicts </span><span><span class="kobospan" id="kobo.379.1">between them.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.380.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.381.1">There are also other tools, such as </span><a id="_idIndexMarker073" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.382.1">Podman (which even has a compatibility layer for the Docker CLI commands), and </span><a id="_idIndexMarker074" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.383.1">Rancher Desktop, which also supports Docker </span><span><span class="kobospan" id="kobo.384.1">CLI commands.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.385.1">We can use Docker locally to set up and run services in an isolated environment. </span><span class="kobospan" id="kobo.385.2">Doing so avoids polluting our host environment and ensures that there is a consistent state to build upon. </span><span class="kobospan" id="kobo.385.3">This consistency is especially important when working in larger development teams, as it ensures that everyone is working with the </span><span><span class="kobospan" id="kobo.386.1">same state.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.387.1">Additionally, Docker makes it easy to deploy containers to various cloud services and run them in</span><a id="_idIndexMarker075" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.388.1"> a </span><strong class="bold"><span class="kobospan" id="kobo.389.1">continuous integration/continuous delivery</span></strong><span class="kobospan" id="kobo.390.1"> (</span><span><strong class="bold"><span class="kobospan" id="kobo.391.1">CI/CD</span></strong></span><span><span class="kobospan" id="kobo.392.1">) workflow.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.393.1">In this section, we will first get an overview of the Docker platform. </span><span class="kobospan" id="kobo.393.2">Then, we will learn how to create a container and how to access Docker from VS Code. </span><span class="kobospan" id="kobo.393.3">At the end, we will understand how Docker works and how it can be used to </span><span><span class="kobospan" id="kobo.394.1">manage services.</span></span></p>
<h2 id="_idParaDest-40" class="calibre7"><a id="_idTextAnchor039" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.395.1">The Docker platform</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.396.1">The Docker platform essentially consists of </span><span><span class="kobospan" id="kobo.397.1">three parts:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.398.1">Docker Client</span></strong><span class="kobospan" id="kobo.399.1">: Can run</span><a id="_idIndexMarker076" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.400.1"> commands by sending them to </span><a id="_idIndexMarker077" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.401.1">the </span><strong class="bold"><span class="kobospan" id="kobo.402.1">Docker daemon</span></strong><span class="kobospan" id="kobo.403.1">, which is either running on the local machine or a </span><span><span class="kobospan" id="kobo.404.1">remote environment.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.405.1">Docker Host</span></strong><span class="kobospan" id="kobo.406.1">: Contains the </span><a id="_idIndexMarker078" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.407.1">Docker daemon, images, </span><span><span class="kobospan" id="kobo.408.1">and containers.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.409.1">Docker Registry</span></strong><span class="kobospan" id="kobo.410.1">: Hosts and stores </span><a id="_idIndexMarker079" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.411.1">docker images, extensions, and plugins. </span><span class="kobospan" id="kobo.411.2">By default, the public registry </span><strong class="bold"><span class="kobospan" id="kobo.412.1">Docker Hub</span></strong><span class="kobospan" id="kobo.413.1"> will be </span><a id="_idIndexMarker080" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.414.1">used to search </span><span><span class="kobospan" id="kobo.415.1">for images.</span></span></li>
</ul>
<div class="calibre2">
<div class="img---figure" id="_idContainer021">
<span class="kobospan" id="kobo.416.1"><img alt="Figure 2.4 – Overview of the Docker platform" src="image/B19385_02_4.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.417.1">Figure 2.4 – Overview of the Docker platform</span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.418.1">Docker images</span></strong><span class="kobospan" id="kobo.419.1"> can be </span><a id="_idIndexMarker081" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.420.1">thought of as read-only templates and are used to create containers. </span><span class="kobospan" id="kobo.420.2">Images can be based on other images. </span><span class="kobospan" id="kobo.420.3">For example, the </span><strong class="source-inline"><span class="kobospan" id="kobo.421.1">mongo</span></strong><span class="kobospan" id="kobo.422.1"> image, which contains a MongoDB server, is based on the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.423.1">ubuntu</span></strong></span><span><span class="kobospan" id="kobo.424.1"> image.</span></span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.425.1">Docker containers</span></strong><span class="kobospan" id="kobo.426.1"> are </span><a id="_idIndexMarker082" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.427.1">instances of images. </span><span class="kobospan" id="kobo.427.2">They run an operating system with a configured service (such as a MongoDB server on Ubuntu). </span><span class="kobospan" id="kobo.427.3">Additionally, they can be configured, for example, to forward some ports from within the container to the host, or to mount a storage volume in the container that stores data on the host machine. </span><span class="kobospan" id="kobo.427.4">By default, a container is isolated from the host machine, so if we want to access ports or storage from it on the host, we need to tell Docker to </span><span><span class="kobospan" id="kobo.428.1">allow this.</span></span></p>
<h2 id="_idParaDest-41" class="calibre7"><a id="_idTextAnchor040" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.429.1">Installing Docker</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.430.1">The easiest way to set up the </span><a id="_idIndexMarker083" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.431.1">Docker platform for local development is using Docker Desktop. </span><span class="kobospan" id="kobo.431.2">It can be downloaded from the</span><a id="_idIndexMarker084" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.432.1"> official Docker website (</span><a href="https://www.docker.com/products/docker-desktop/" class="calibre6 pcalibre1 pcalibre"><span class="kobospan" id="kobo.433.1">https://www.docker.com/products/docker-desktop/</span></a><span class="kobospan" id="kobo.434.1">). </span><span class="kobospan" id="kobo.434.2">Follow the instructions to install it and start the Docker engine. </span><span class="kobospan" id="kobo.434.3">After installation, you should have a </span><strong class="source-inline"><span class="kobospan" id="kobo.435.1">docker</span></strong><span class="kobospan" id="kobo.436.1"> command available in your Terminal. </span><span class="kobospan" id="kobo.436.2">Run the following command to verify that it is </span><span><span class="kobospan" id="kobo.437.1">working properly:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.438.1">
$ docker -v</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.439.1">This command should output the Docker version, like in the </span><span><span class="kobospan" id="kobo.440.1">following example:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.441.1">
Docker version 24.0.6, build ed223bc</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.442.1">After installing and starting Docker, we can move on to creating </span><span><span class="kobospan" id="kobo.443.1">a container.</span></span></p>
<h2 id="_idParaDest-42" class="calibre7"><a id="_idTextAnchor041" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.444.1">Creating a container</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.445.1">Docker Client can instantiate a </span><a id="_idIndexMarker085" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.446.1">container from an image via the </span><strong class="source-inline"><span class="kobospan" id="kobo.447.1">docker run</span></strong><span class="kobospan" id="kobo.448.1"> command. </span><span class="kobospan" id="kobo.448.2">Let’s now create an </span><strong class="source-inline"><span class="kobospan" id="kobo.449.1">ubuntu</span></strong><span class="kobospan" id="kobo.450.1"> container and run a shell (</span><strong class="source-inline"><span class="kobospan" id="kobo.451.1">/bin/bash</span></strong><span class="kobospan" id="kobo.452.1">) </span><span><span class="kobospan" id="kobo.453.1">in it:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.454.1">
$ docker run -i -t ubuntu:24.04 /bin/bash</span></pre> <p class="callout-heading"><span class="kobospan" id="kobo.455.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.456.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.457.1">:24.04</span></strong><span class="kobospan" id="kobo.458.1"> string after the image name is called</span><a id="_idIndexMarker086" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.459.1"> the </span><strong class="bold"><span class="kobospan" id="kobo.460.1">tag</span></strong><span class="kobospan" id="kobo.461.1">, and it can be used to pin images to certain versions. </span><span class="kobospan" id="kobo.461.2">In this book, we use tags to pull specific versions of images so that the steps are reproducible even when new versions are released. </span><span class="kobospan" id="kobo.461.3">By default, if no tag is specified, Docker will attempt to use the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.462.1">latest</span></strong></span><span><span class="kobospan" id="kobo.463.1"> tag.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.464.1">A new shell will open. </span><span class="kobospan" id="kobo.464.2">We can verify that this shell is running in the container by executing the following command to see which operating system </span><span><span class="kobospan" id="kobo.465.1">is running:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.466.1">
$ uname -a</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.467.1">If you get a version number that ends with </span><strong class="source-inline"><span class="kobospan" id="kobo.468.1">-linuxkit</span></strong><span class="kobospan" id="kobo.469.1">, you have successfully run a command in the container, because LinuxKit is a toolkit to create small </span><span><span class="kobospan" id="kobo.470.1">Linux VMs!</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.471.1">You can now type the following command to exit the shell and </span><span><span class="kobospan" id="kobo.472.1">the container:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.473.1">
$ exit</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.474.1">The following figure shows the result of running </span><span><span class="kobospan" id="kobo.475.1">these commands:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer022">
<span class="kobospan" id="kobo.476.1"><img alt="Figure 2.5 – Running our first Docker container" src="image/B19385_02_5.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.477.1">Figure 2.5 – Running our first Docker container</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.478.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.479.1">docker run</span></strong><span class="kobospan" id="kobo.480.1"> command does </span><span><span class="kobospan" id="kobo.481.1">the following:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.482.1">If you have never run a </span><a id="_idIndexMarker087" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.483.1">container based on the </span><strong class="source-inline1"><span class="kobospan" id="kobo.484.1">ubuntu</span></strong><span class="kobospan" id="kobo.485.1"> image before, Docker will start by pulling the image from the Docker registry (this is equivalent to executing </span><strong class="source-inline1"><span class="kobospan" id="kobo.486.1">docker </span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.487.1">pull ubuntu</span></strong></span><span><span class="kobospan" id="kobo.488.1">).</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.489.1">After the image is downloaded, Docker creates a new container (the equivalent to executing </span><strong class="source-inline1"><span class="kobospan" id="kobo.490.1">docker </span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.491.1">container create</span></strong></span><span><span class="kobospan" id="kobo.492.1">).</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.493.1">Then, Docker configures a read-write filesystem for the container and creates a default </span><span><span class="kobospan" id="kobo.494.1">network interface.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.495.1">Finally, Docker starts the container and executes the specified command. </span><span class="kobospan" id="kobo.495.2">In our case, we specified the </span><strong class="source-inline1"><span class="kobospan" id="kobo.496.1">/bin/bash</span></strong><span class="kobospan" id="kobo.497.1"> command. </span><span class="kobospan" id="kobo.497.2">Because we passed the </span><strong class="source-inline1"><span class="kobospan" id="kobo.498.1">-i</span></strong><span class="kobospan" id="kobo.499.1"> (keeps </span><strong class="source-inline1"><span class="kobospan" id="kobo.500.1">STDIN</span></strong><span class="kobospan" id="kobo.501.1"> open) and </span><strong class="source-inline1"><span class="kobospan" id="kobo.502.1">-t</span></strong><span class="kobospan" id="kobo.503.1"> (allocates a pseudo-tty) options, Docker attaches the container’s shell to our currently running Terminal, allowing us to use the container as if we were directly accessing a Terminal on our </span><span><span class="kobospan" id="kobo.504.1">host machine.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.505.1">As we can see, Docker is very useful for creating self-contained environments for our apps and services to run in. </span><span class="kobospan" id="kobo.505.2">Later in this book, we are going to learn how to package our own apps in Docker containers. </span><span class="kobospan" id="kobo.505.3">For now, we are only going to use Docker to run services without having to install them on our </span><span><span class="kobospan" id="kobo.506.1">host system.</span></span></p>
<h2 id="_idParaDest-43" class="calibre7"><a id="_idTextAnchor042" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.507.1">Accessing Docker via VS Code</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.508.1">We</span><a id="_idIndexMarker088" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.509.1"> can also access Docker via the VS Code extension </span><a id="_idIndexMarker089" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.510.1">we installed in </span><a href="B19385_01.xhtml#_idTextAnchor016" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.511.1">Chapter 1</span></em></span></a><span class="kobospan" id="kobo.512.1">, </span><em class="italic"><span class="kobospan" id="kobo.513.1">Preparing for Full-stack Development</span></em><span class="kobospan" id="kobo.514.1">. </span><span class="kobospan" id="kobo.514.2">To do so, click the Docker icon in the left sidebar of VS Code. </span><span class="kobospan" id="kobo.514.3">The Docker sidebar will open, showing you a list of containers, images, registries, networks, volumes, contexts, and </span><span><span class="kobospan" id="kobo.515.1">relevant resources:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer023">
<span class="kobospan" id="kobo.516.1"><img alt="Figure 2.6 – The Docker sidebar in VS Code" src="image/B19385_02_6.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.517.1">Figure 2.6 – The Docker sidebar in VS Code</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.518.1">Here, you can see which containers are stopped and which ones are running. </span><span class="kobospan" id="kobo.518.2">You can right-click on a container to start, stop, restart, or remove it. </span><span class="kobospan" id="kobo.518.3">You can also view its logs to debug what is going on inside the container. </span><span class="kobospan" id="kobo.518.4">Additionally, you can attach a shell to the container to get access to its </span><span><span class="kobospan" id="kobo.519.1">operating system.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.520.1">Now that we know the essentials of Docker, we can create a container for our MongoDB </span><span><span class="kobospan" id="kobo.521.1">database server.</span></span></p>
<h1 id="_idParaDest-44" class="calibre5"><a id="_idTextAnchor043" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.522.1">Introducing MongoDB, a document database</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.523.1">MongoDB, at</span><a id="_idIndexMarker090" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.524.1"> the time of writing, is the most popular NoSQL database. </span><span class="kobospan" id="kobo.524.2">Unlike </span><strong class="bold"><span class="kobospan" id="kobo.525.1">Structured Query Language</span></strong><span class="kobospan" id="kobo.526.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.527.1">SQL</span></strong><span class="kobospan" id="kobo.528.1">) databases (such as MySQL or PostgreSQL), NoSQL means that the</span><a id="_idIndexMarker091" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.529.1"> database specifically does not use SQL to query the database. </span><span class="kobospan" id="kobo.529.2">Instead, NoSQL databases have various other ways to query the database and often have a vastly different structure of how data is stored </span><span><span class="kobospan" id="kobo.530.1">and queried.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.531.1">The following main types of NoSQL </span><span><span class="kobospan" id="kobo.532.1">databases</span></span><span><a id="_idIndexMarker092" class="calibre6 pcalibre1 pcalibre"/></span><span><span class="kobospan" id="kobo.533.1"> exist:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.534.1">Key-value stores (for </span><span><span class="kobospan" id="kobo.535.1">example, Valkey/Redis)</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.536.1">Column-oriented databases (for example, </span><span><span class="kobospan" id="kobo.537.1">Amazon Redshift)</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.538.1">Graph-based databases (for </span><span><span class="kobospan" id="kobo.539.1">example, Neo4j)</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.540.1">Document-based databases (for </span><span><span class="kobospan" id="kobo.541.1">example, MongoDB)</span></span></li>
</ul>
<div class="calibre2">
<div class="img---figure" id="_idContainer024">
<span class="kobospan" id="kobo.542.1"><img alt="Figure 2.7 – Overview of NoSQL databases" src="image/B19385_02_7.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.543.1">Figure 2.7 – Overview of NoSQL databases</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.544.1">MongoDB is </span><a id="_idIndexMarker093" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.545.1">a document-based database, which means that each entry in the database is stored as a document. </span><span class="kobospan" id="kobo.545.2">In MongoDB, these documents are basically JSON objects (internally, they are stored as BSON – a binary JSON format to save space and improve performance, among other advantages). </span><span class="kobospan" id="kobo.545.3">Instead, SQL databases store data as rows in tables. </span><span class="kobospan" id="kobo.545.4">As such, MongoDB provides a lot more flexibility. </span><span class="kobospan" id="kobo.545.5">Fields can be freely added or left out in documents. </span><span class="kobospan" id="kobo.545.6">The downside of such a structure is that we do not have a consistent schema for documents. </span><span class="kobospan" id="kobo.545.7">However, this can be solved by using libraries, such as Mongoose, which we will learn about in </span><a href="B19385_03_split_000.xhtml#_idTextAnchor050" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.546.1">Chapter 3</span></em></span></a><span class="kobospan" id="kobo.547.1">, </span><em class="italic"><span class="kobospan" id="kobo.548.1">Implementing a Backend Using Express, Mongoose ODM, </span></em><span><em class="italic"><span class="kobospan" id="kobo.549.1">and Jest</span></em></span><span><span class="kobospan" id="kobo.550.1">.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer025">
<span class="kobospan" id="kobo.551.1"><img alt="Figure 2.8 – Comparison between MongoDB and SQL databases" src="image/B19385_02_8.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.552.1">Figure 2.8 – Comparison between MongoDB and SQL databases</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.553.1">MongoDB is </span><a id="_idIndexMarker094" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.554.1">also based on a JavaScript engine. </span><span class="kobospan" id="kobo.554.2">Since version 3.2, it has been using SpiderMonkey (the JavaScript engine that Firefox uses) instead of V8. </span><span class="kobospan" id="kobo.554.3">Nevertheless, this still means we can execute JavaScript code in MongoDB. </span><span class="kobospan" id="kobo.554.4">For example, we can use JavaScript in the </span><strong class="bold"><span class="kobospan" id="kobo.555.1">MongoDB Shell</span></strong><span class="kobospan" id="kobo.556.1"> to</span><a id="_idIndexMarker095" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.557.1"> help with administrative tasks. </span><span class="kobospan" id="kobo.557.2">Again, we must be careful with this, though, as the MongoDB environment is vastly different from a browser or </span><span><span class="kobospan" id="kobo.558.1">Node.js environment.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.559.1">In this section, we will first learn how to set up a MongoDB server using Docker. </span><span class="kobospan" id="kobo.559.2">Then, we will learn more about MongoDB and how to access it directly using the MongoDB Shell for the administration of our database and the data. </span><span class="kobospan" id="kobo.559.3">We are also going to learn how to use VS Code to access MongoDB. </span><span class="kobospan" id="kobo.559.4">At the end of this section, you will have an understanding of how CRUD operations work </span><span><span class="kobospan" id="kobo.560.1">in MongoDB.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.561.1">Note </span></p>
<p class="callout"><span class="kobospan" id="kobo.562.1">CRUD is an acronym for create, read, update, and delete, which are the common operations that backend services </span><span><span class="kobospan" id="kobo.563.1">usually provide.</span></span></p>
<h2 id="_idParaDest-45" class="calibre7"><a id="_idTextAnchor044" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.564.1">Setting up a MongoDB server</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.565.1">Before we can start using </span><a id="_idIndexMarker096" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.566.1">MongoDB, we need to set up a server. </span><span class="kobospan" id="kobo.566.2">Since we already have Docker installed, we can make things easier for ourselves by running MongoDB in a Docker container. </span><span class="kobospan" id="kobo.566.3">Doing so also allows us to have separate, clean MongoDB instances for our apps by creating separate containers. </span><span class="kobospan" id="kobo.566.4">Let’s get started with </span><span><span class="kobospan" id="kobo.567.1">the steps:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.568.1">Make sure Docker Desktop is running and Docker is started. </span><span class="kobospan" id="kobo.568.2">You can verify this by running the following command, which lists all </span><span><span class="kobospan" id="kobo.569.1">running containers:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.570.1">$ docker ps</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.571.1">If Docker is not started properly, you will get a </span><strong class="bold"><span class="kobospan" id="kobo.572.1">Cannot connect to the Docker daemon</span></strong><span class="kobospan" id="kobo.573.1"> error. </span><span class="kobospan" id="kobo.573.2">In that case, make sure Docker Desktop is running and the Docker Engine is </span><span><span class="kobospan" id="kobo.574.1">not paused.</span></span></p><p class="calibre3"><span class="kobospan" id="kobo.575.1">If Docker is started properly, you will see the </span><span><span class="kobospan" id="kobo.576.1">following output:</span></span></p><pre class="source-code"><strong class="bold1"><span class="kobospan1" id="kobo.577.1">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.578.1">If you already have some containers running, it will be followed by a list of </span><span><span class="kobospan" id="kobo.579.1">started containers.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.580.1">Run the following Docker command to create a new container with a </span><span><span class="kobospan" id="kobo.581.1">MongoDB server:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.582.1">$ docker run -d --name dbserver -p 27017:27017 --restart unless-stopped mongo:6.0.4</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.583.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.584.1">docker run</span></strong><span class="kobospan" id="kobo.585.1"> command creates and runs a</span><a id="_idIndexMarker097" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.586.1"> new container. </span><span class="kobospan" id="kobo.586.2">The arguments are </span><span><span class="kobospan" id="kobo.587.1">as follows:</span></span></p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.588.1">-d</span></strong><span class="kobospan" id="kobo.589.1">: Runs the container in the background (</span><span><span class="kobospan" id="kobo.590.1">daemon mode).</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.591.1">--name</span></strong><span class="kobospan" id="kobo.592.1">: Specifies a name for the container. </span><span class="kobospan" id="kobo.592.2">In our case, we named </span><span><span class="kobospan" id="kobo.593.1">it </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.594.1">dbserver</span></strong></span><span><span class="kobospan" id="kobo.595.1">.</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.596.1">-p</span></strong><span class="kobospan" id="kobo.597.1">: Maps a</span><a id="_idIndexMarker098" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.598.1"> port from the container to the host. </span><span class="kobospan" id="kobo.598.2">In our case, we map the default MongoDB server port </span><strong class="source-inline1"><span class="kobospan" id="kobo.599.1">27017</span></strong><span class="kobospan" id="kobo.600.1"> in the container to the same port on our host. </span><span class="kobospan" id="kobo.600.2">This allows us to access the MongoDB server running within our container from outside of it. </span><span class="kobospan" id="kobo.600.3">If you already have a MongoDB server running on that port, feel free to change the first number to some other port, but make sure to also adjust the port number from </span><strong class="source-inline1"><span class="kobospan" id="kobo.601.1">27017</span></strong><span class="kobospan" id="kobo.602.1"> to your specified port in the </span><span><span class="kobospan" id="kobo.603.1">following guides.</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.604.1">--restart unless-stopped</span></strong><span class="kobospan" id="kobo.605.1">: Makes sure to automatically start (and restart) the container unless we manually stop it. </span><span class="kobospan" id="kobo.605.2">This ensures that every time we start Docker, our MongoDB server will already </span><span><span class="kobospan" id="kobo.606.1">be running.</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.607.1">mongo</span></strong><span class="kobospan" id="kobo.608.1">: This is the image name. </span><span class="kobospan" id="kobo.608.2">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.609.1">mongo</span></strong><span class="kobospan" id="kobo.610.1"> image contains a </span><span><span class="kobospan" id="kobo.611.1">MongoDB server.</span></span></li></ul></li> <li class="calibre11"><span class="kobospan" id="kobo.612.1">Install the MongoDB Shell on your host system (not within the container) by following the instructions on the MongoDB </span><span><span class="kobospan" id="kobo.613.1">website (</span></span><a href="https://www.mongodb.com/docs/mongodb-shell/install/" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.614.1">https://www.mongodb.com/docs/mongodb-shell/install/</span></span></a><span><span class="kobospan" id="kobo.615.1">).</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.616.1">On your host system, run the following command to connect to the MongoDB server using the MongoDB Shell (</span><strong class="source-inline1"><span class="kobospan" id="kobo.617.1">mongosh</span></strong><span class="kobospan" id="kobo.618.1">). </span><span class="kobospan" id="kobo.618.2">After the hostname and port, we specify a database name. </span><span class="kobospan" id="kobo.618.3">We are going to call our </span><span><span class="kobospan" id="kobo.619.1">database </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.620.1">ch2</span></strong></span><span><span class="kobospan" id="kobo.621.1">:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.622.1">$ mongosh mongodb://localhost:27017/ch2</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.623.1">You will see some output from the database server, and at the end, we get a shell running on our selected database, as can be seen by the </span><strong class="source-inline"><span class="kobospan" id="kobo.624.1">ch2&gt;</span></strong><span class="kobospan" id="kobo.625.1"> prompt. </span><span class="kobospan" id="kobo.625.2">Here, we can enter commands to be executed on our database. </span><span class="kobospan" id="kobo.625.3">Interestingly, MongoDB, like Node.js, also exposes a JavaScript engine, but with yet another different environment. </span><span class="kobospan" id="kobo.625.4">So, we can run JavaScript code, such as </span><span><span class="kobospan" id="kobo.626.1">the following:</span></span></p><pre class="source-code"><strong class="bold1"><span class="kobospan1" id="kobo.627.1">ch2&gt; console.log("test")</span></strong></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.628.1">The following figure </span><a id="_idIndexMarker099" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.629.1">shows JavaScript code being executed in the </span><span><span class="kobospan" id="kobo.630.1">MongoDB Shell:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer026">
<span class="kobospan" id="kobo.631.1"><img alt="Figure 2.9 – Connecting to our MongoDB database server running in a Docker container" src="image/B19385_02_9.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.632.1">Figure 2.9 – Connecting to our MongoDB database server running in a Docker container</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.633.1">Now that we have a shell connected to our MongoDB database server, we can start practicing running commands directly on </span><span><span class="kobospan" id="kobo.634.1">the database.</span></span></p>
<h2 id="_idParaDest-46" class="calibre7"><a id="_idTextAnchor045" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.635.1">Running commands directly on the database</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.636.1">Before we get started creating a backend service that interfaces with MongoDB, let’s spend some time getting familiar with MongoDB itself via the MongoDB Shell. </span><span class="kobospan" id="kobo.636.2">The MongoDB Shell</span><a id="_idIndexMarker100" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.637.1"> is very important for debugging and doing maintenance tasks on the database, so it is a good idea to get to know </span><span><span class="kobospan" id="kobo.638.1">it well.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.639.1">Creating a collection and inserting and listing documents</span></h3>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.640.1">Collections</span></strong><span class="kobospan" id="kobo.641.1"> in </span><a id="_idIndexMarker101" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.642.1">MongoDB are the equivalent of tables in relational databases. </span><span class="kobospan" id="kobo.642.2">They store documents, which are like JSON objects. </span><span class="kobospan" id="kobo.642.3">To make it easier to understand, a collection can be seen as a very large JSON array containing JSON objects. </span><span class="kobospan" id="kobo.642.4">Unlike simple arrays, collections support the creation of indices, which speed up the lookup of certain fields in documents. </span><span class="kobospan" id="kobo.642.5">In MongoDB, a collection is automatically created when we attempt to insert a document into it or create an index </span><span><span class="kobospan" id="kobo.643.1">for it.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.644.1">Let’s use the MongoDB Shell to insert a document into our database in the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.645.1">users</span></strong></span><span><span class="kobospan" id="kobo.646.1"> collection:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.647.1">To </span><a id="_idIndexMarker102" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.648.1">insert a new user document into the </span><strong class="source-inline1"><span class="kobospan" id="kobo.649.1">users</span></strong><span class="kobospan" id="kobo.650.1"> collection, run the following command in the </span><span><span class="kobospan" id="kobo.651.1">MongoDB Shell:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.652.1">&gt; db.users.insertOne({ username: 'dan', fullName: 'Daniel Bugl', age: 26 })</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.653.1">Commands that access the database are prefixed with </span><strong class="source-inline"><span class="kobospan" id="kobo.654.1">db</span></strong><span class="kobospan" id="kobo.655.1">, then the collection name follows, and finally comes the operation, all separated </span><span><span class="kobospan" id="kobo.656.1">by periods.</span></span></p></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.657.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.658.1">While </span><strong class="source-inline1"><span class="kobospan" id="kobo.659.1">insertOne()</span></strong><span class="kobospan" id="kobo.660.1"> allows us to insert a single document into the collection, there is also an </span><strong class="source-inline1"><span class="kobospan" id="kobo.661.1">insertMany()</span></strong><span class="kobospan" id="kobo.662.1"> method, where we can pass an array of documents to add to </span><span><span class="kobospan" id="kobo.663.1">the collection.</span></span></p>
<ol class="calibre15">
<li value="2" class="calibre11"><span class="kobospan" id="kobo.664.1">We can now</span><a id="_idIndexMarker103" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.665.1"> list all documents from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.666.1">users</span></strong><span class="kobospan" id="kobo.667.1"> collection by running the </span><span><span class="kobospan" id="kobo.668.1">following command:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.669.1">&gt; db.users.find()</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.670.1">Doing so will return an array with our previously </span><span><span class="kobospan" id="kobo.671.1">inserted document:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.672.1">[
  {
    _id: ObjectId("6405f062b0d06adeaeefc3bc"),
    username: 'dan',
    fullName: 'Daniel Bugl',
    age: 26
  }
]</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.673.1">As we can see, MongoDB automatically created a unique ID (</span><strong class="source-inline"><span class="kobospan" id="kobo.674.1">ObjectId</span></strong><span class="kobospan" id="kobo.675.1">) for our document. </span><span class="kobospan" id="kobo.675.2">This ID consists of 12 bytes in hexadecimal format (so each byte is displayed as two characters). </span><span class="kobospan" id="kobo.675.3">The bytes are defined </span><span><span class="kobospan" id="kobo.676.1">as follows:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.677.1">The first 4 bytes are a timestamp, representing the creation of the ID measured in seconds since the </span><span><span class="kobospan" id="kobo.678.1">Unix epoch</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.679.1">The next 5 bytes are a random value unique to the machine and currently running </span><span><span class="kobospan" id="kobo.680.1">database process</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.681.1">The last 3 bytes</span><a id="_idIndexMarker104" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.682.1"> are a randomly initialized </span><span><span class="kobospan" id="kobo.683.1">incrementing counter</span></span></li>
</ul>
<p class="callout-heading"><span class="kobospan" id="kobo.684.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.685.1">The way </span><strong class="source-inline1"><span class="kobospan" id="kobo.686.1">ObjectId</span></strong><span class="kobospan" id="kobo.687.1"> identifiers are generated in MongoDB ensures that IDs are unique, avoiding ID collisions even when two ids are generated at the same time from different instances, without requiring a form of communication between the instances, which would slow down the creation of documents when scaling </span><span><span class="kobospan" id="kobo.688.1">the database.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.689.1">Querying and sorting documents</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.690.1">Now that we have </span><a id="_idIndexMarker105" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.691.1">inserted some documents, we can query them by accessing different fields from the object. </span><span class="kobospan" id="kobo.691.2">We can also sort the list of documents returned from MongoDB. </span><span class="kobospan" id="kobo.691.3">Follow </span><span><span class="kobospan" id="kobo.692.1">these steps:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.693.1">Before we get started querying, let’s insert two more documents into our </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.694.1">users</span></strong></span><span><span class="kobospan" id="kobo.695.1"> collection:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.696.1">&gt; db.users.insertMany([</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.697.1">  { username: 'jane', fullName: 'Jane Doe', age: 32 },</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.698.1">  { username: 'john', fullName: 'John Doe', age: 30 }</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.699.1">])</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.700.1">Now we can start querying for a certain username by using </span><strong class="source-inline1"><span class="kobospan" id="kobo.701.1">findOne</span></strong><span class="kobospan" id="kobo.702.1"> and passing an object with the </span><strong class="source-inline1"><span class="kobospan" id="kobo.703.1">username</span></strong><span class="kobospan" id="kobo.704.1"> field. </span><span class="kobospan" id="kobo.704.2">When using </span><strong class="source-inline1"><span class="kobospan" id="kobo.705.1">findOne</span></strong><span class="kobospan" id="kobo.706.1">, MongoDB will return the first </span><span><span class="kobospan" id="kobo.707.1">matching object:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.708.1">&gt; db.users.findOne({ username: 'jane' })</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.709.1">We can also query for full names, or any other field in the documents from the collection. </span><span class="kobospan" id="kobo.709.2">When using </span><strong class="source-inline1"><span class="kobospan" id="kobo.710.1">find</span></strong><span class="kobospan" id="kobo.711.1">, MongoDB will return an array of </span><span><span class="kobospan" id="kobo.712.1">all matches:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.713.1">&gt; db.users.find({ fullName: 'Daniel Bugl' })</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.714.1">An important </span><a id="_idIndexMarker106" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.715.1">thing to watch out for is that when querying an </span><strong class="source-inline1"><span class="kobospan" id="kobo.716.1">ObjectId</span></strong><span class="kobospan" id="kobo.717.1">, we need to wrap the ID string with an </span><strong class="source-inline1"><span class="kobospan" id="kobo.718.1">ObjectId()</span></strong><span class="kobospan" id="kobo.719.1"> constructor, </span><span><span class="kobospan" id="kobo.720.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.721.1">&gt; db.users.findOne({ _id: ObjectId('6405f062b0d06adeaeefc3bc') })</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.722.1">Make sure to change the string passed to the </span><strong class="source-inline"><span class="kobospan" id="kobo.723.1">ObjectId()</span></strong><span class="kobospan" id="kobo.724.1"> constructor to a valid </span><strong class="source-inline"><span class="kobospan" id="kobo.725.1">ObjectId</span></strong><span class="kobospan" id="kobo.726.1"> returned from the </span><span><span class="kobospan" id="kobo.727.1">previous commands.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.728.1">MongoDB also provides certain query operators, prefixed by </span><strong class="source-inline1"><span class="kobospan" id="kobo.729.1">$</span></strong><span class="kobospan" id="kobo.730.1">. </span><span class="kobospan" id="kobo.730.2">For example, we can find everyone above the age of 30 in our collection by using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.731.1">$gt</span></strong><span class="kobospan" id="kobo.732.1"> operator, </span><span><span class="kobospan" id="kobo.733.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.734.1">&gt; db.users.find({ age: { $gt: 30 } })</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.735.1">You will notice that </span><strong class="source-inline"><span class="kobospan" id="kobo.736.1">John Doe</span></strong><span class="kobospan" id="kobo.737.1"> does not get returned, because his age is exactly 30. </span><span class="kobospan" id="kobo.737.2">If we want to match ages greater than or equal to 30, we need to use the </span><strong class="source-inline"><span class="kobospan" id="kobo.738.1">$</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.739.1">gte</span></strong></span><span><span class="kobospan" id="kobo.740.1"> operator.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.741.1">If we want to sort our results, we can use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.742.1">.sort()</span></strong><span class="kobospan" id="kobo.743.1"> method after </span><strong class="source-inline1"><span class="kobospan" id="kobo.744.1">.find()</span></strong><span class="kobospan" id="kobo.745.1">. </span><span class="kobospan" id="kobo.745.2">For example, we can return all items from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.746.1">users</span></strong><span class="kobospan" id="kobo.747.1"> collection, sorted by</span><a id="_idIndexMarker107" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.748.1"> age ascending (</span><strong class="source-inline1"><span class="kobospan" id="kobo.749.1">1</span></strong><span class="kobospan" id="kobo.750.1"> for ascending, </span><strong class="source-inline1"><span class="kobospan" id="kobo.751.1">-1</span></strong> <span><span class="kobospan" id="kobo.752.1">for descending):</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.753.1">&gt; db.users.find().sort({ age: 1 })</span></strong></pre></li> </ol>
<h3 class="calibre9"><span class="kobospan" id="kobo.754.1">Updating documents</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.755.1">To update a </span><a id="_idIndexMarker108" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.756.1">document in MongoDB, we combine the arguments from the query and insert operations into a single operation. </span><span class="kobospan" id="kobo.756.2">We can use the same criteria to filter documents as we did for </span><strong class="source-inline"><span class="kobospan" id="kobo.757.1">find()</span></strong><span class="kobospan" id="kobo.758.1">. </span><span class="kobospan" id="kobo.758.2">To update a single field from the document, we use the </span><strong class="source-inline"><span class="kobospan" id="kobo.759.1">$</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.760.1">set</span></strong></span><span><span class="kobospan" id="kobo.761.1"> operator:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.762.1"> We can update the </span><strong class="source-inline1"><span class="kobospan" id="kobo.763.1">age</span></strong><span class="kobospan" id="kobo.764.1"> field for the user with the username </span><strong class="source-inline1"><span class="kobospan" id="kobo.765.1">dan</span></strong> <span><span class="kobospan" id="kobo.766.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.767.1">&gt; db.users.updateOne({ username: 'dan' }, { $set: { age: 27 } })</span></strong></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.768.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.769.1">Just like </span><strong class="source-inline1"><span class="kobospan" id="kobo.770.1">findOne</span></strong><span class="kobospan" id="kobo.771.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.772.1">updateOne</span></strong><span class="kobospan" id="kobo.773.1"> only updates the first matching document. </span><span class="kobospan" id="kobo.773.2">If we want to update all documents that match, we can </span><span><span class="kobospan" id="kobo.774.1">use </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.775.1">updateMany</span></strong></span><span><span class="kobospan" id="kobo.776.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.777.1">MongoDB will return an object with information about how many documents matched (</span><strong class="source-inline"><span class="kobospan" id="kobo.778.1">matchedCount</span></strong><span class="kobospan" id="kobo.779.1">), how many were modified (</span><strong class="source-inline"><span class="kobospan" id="kobo.780.1">modifiedCount</span></strong><span class="kobospan" id="kobo.781.1">), and how many were </span><span><span class="kobospan" id="kobo.782.1">upserted (</span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.783.1">upsertedCount</span></strong></span><span><span class="kobospan" id="kobo.784.1">).</span></span></p>
<ol class="calibre15">
<li value="2" class="calibre11"><span class="kobospan" id="kobo.785.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.786.1">updateOne</span></strong><span class="kobospan" id="kobo.787.1"> method accepts a third argument, which is an </span><strong class="source-inline1"><span class="kobospan" id="kobo.788.1">options</span></strong><span class="kobospan" id="kobo.789.1"> object. </span><span class="kobospan" id="kobo.789.2">One useful option here is the </span><strong class="source-inline1"><span class="kobospan" id="kobo.790.1">upsert</span></strong><span class="kobospan" id="kobo.791.1"> option, which, if set to </span><strong class="source-inline1"><span class="kobospan" id="kobo.792.1">true</span></strong><span class="kobospan" id="kobo.793.1">, will insert a document if it does not exist yet, and update it if it does exist already. </span><span class="kobospan" id="kobo.793.2">Let’s first try to update a non-existent user with </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.794.1">upsert: false</span></strong></span><span><span class="kobospan" id="kobo.795.1">:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.796.1">&gt; db.users.updateOne({ username: 'new' }, { $set: { fullName: 'New User' } })</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.797.1">Now we set </span><strong class="source-inline1"><span class="kobospan" id="kobo.798.1">upsert</span></strong><span class="kobospan" id="kobo.799.1"> to </span><strong class="source-inline1"><span class="kobospan" id="kobo.800.1">true</span></strong><span class="kobospan" id="kobo.801.1">, which </span><a id="_idIndexMarker109" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.802.1">inserts </span><span><span class="kobospan" id="kobo.803.1">the user:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.804.1">&gt; db.users.updateOne({ username: 'new' }, { $set: { fullName: 'New User' } }, { upsert: true })</span></strong></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.805.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.806.1">If you want to remove a field from a document, use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.807.1">$unset</span></strong><span class="kobospan" id="kobo.808.1"> operator. </span><span class="kobospan" id="kobo.808.2">If you want to replace the whole document with a new document, you can use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.809.1">replaceOne</span></strong><span class="kobospan" id="kobo.810.1"> method and pass a new document as the second argument </span><span><span class="kobospan" id="kobo.811.1">to it.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.812.1">Deleting documents</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.813.1">To delete </span><a id="_idIndexMarker110" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.814.1">documents from the database, MongoDB provides the </span><strong class="source-inline"><span class="kobospan" id="kobo.815.1">deleteOne</span></strong><span class="kobospan" id="kobo.816.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.817.1">deleteMany</span></strong><span class="kobospan" id="kobo.818.1"> methods, which have a similar API to the </span><strong class="source-inline"><span class="kobospan" id="kobo.819.1">updateOne</span></strong><span class="kobospan" id="kobo.820.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.821.1">updateMany</span></strong><span class="kobospan" id="kobo.822.1"> methods. </span><span class="kobospan" id="kobo.822.2">The first argument is, again, used to </span><span><span class="kobospan" id="kobo.823.1">match documents.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.824.1">Let’s say the user with the username </span><strong class="source-inline"><span class="kobospan" id="kobo.825.1">new</span></strong><span class="kobospan" id="kobo.826.1"> wants to delete their account. </span><span class="kobospan" id="kobo.826.2">To do so, we need to remove them from the </span><strong class="source-inline"><span class="kobospan" id="kobo.827.1">users</span></strong><span class="kobospan" id="kobo.828.1"> collection. </span><span class="kobospan" id="kobo.828.2">We can do so </span><span><span class="kobospan" id="kobo.829.1">as follows:</span></span></p>
<pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.830.1">&gt; db.users.deleteOne({ username: 'new' })</span></strong></pre> <p class="calibre3"><span class="kobospan" id="kobo.831.1">That’s all there is to it! </span><span class="kobospan" id="kobo.831.2">As you can see, it is very simple to do CRUD operations in MongoDB if you already know how to </span><a id="_idIndexMarker111" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.832.1">work with JSON objects and JavaScript, making it the perfect </span><a id="_idIndexMarker112" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.833.1">database for a </span><span><span class="kobospan" id="kobo.834.1">Node.js backend.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.835.1">Now that we have learned how to access MongoDB using the MongoDB Shell, let’s learn about accessing it from within </span><span><span class="kobospan" id="kobo.836.1">VS Code.</span></span></p>
<h2 id="_idParaDest-47" class="calibre7"><a id="_idTextAnchor046" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.837.1">Accessing the database via VS Code</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.838.1">Up until now, we have been</span><a id="_idIndexMarker113" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.839.1"> using the Terminal to access the database. </span><span class="kobospan" id="kobo.839.2">If you remember, in </span><a href="B19385_01.xhtml#_idTextAnchor016" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.840.1">Chapter 1</span></em></span></a><span class="kobospan" id="kobo.841.1">, </span><em class="italic"><span class="kobospan" id="kobo.842.1">Preparing for Full-stack Development</span></em><span class="kobospan" id="kobo.843.1">, we installed a MongoDB extension for VS Code. </span><span class="kobospan" id="kobo.843.2">We can now use this extension to access our database in a more </span><span><span class="kobospan" id="kobo.844.1">visual way:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.845.1">Click on the MongoDB icon on the left sidebar (it should be a leaf icon) and click on the </span><strong class="bold"><span class="kobospan" id="kobo.846.1">Add </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.847.1">Connection</span></strong></span><span><span class="kobospan" id="kobo.848.1"> button:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer027">
<span class="kobospan" id="kobo.849.1"><img alt="Figure 2.10 – The MongoDB sidebar in VS Code" src="image/B19385_02_10.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.850.1">Figure 2.10 – The MongoDB sidebar in VS Code</span></p>
<ol class="calibre15">
<li value="2" class="calibre11"><span class="kobospan" id="kobo.851.1">A new </span><strong class="bold"><span class="kobospan" id="kobo.852.1">MongoDB</span></strong><span class="kobospan" id="kobo.853.1"> tab will</span><a id="_idIndexMarker114" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.854.1"> open up. </span><span class="kobospan" id="kobo.854.2">In this tab, click on </span><strong class="bold"><span class="kobospan" id="kobo.855.1">Connect</span></strong><span class="kobospan" id="kobo.856.1"> in the </span><strong class="bold"><span class="kobospan" id="kobo.857.1">Connect with Connection </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.858.1">String</span></strong></span><span><span class="kobospan" id="kobo.859.1"> box:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer028">
<span class="kobospan" id="kobo.860.1"><img alt="Figure 2.11 – Adding a new MongoDB connection in VS Code" src="image/B19385_02_11.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.861.1">Figure 2.11 – Adding a new MongoDB connection in VS Code</span></p>
<ol class="calibre15">
<li value="3" class="calibre11"><span class="kobospan" id="kobo.862.1">A popup should open at the top. </span><span class="kobospan" id="kobo.862.2">In this popup, enter the following connection string to connect to your </span><span><span class="kobospan" id="kobo.863.1">local database:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.864.1">
mongodb://localhost:27017/</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.865.1">Press </span><em class="italic"><span class="kobospan" id="kobo.866.1">Return/Enter</span></em><span class="kobospan" id="kobo.867.1"> to confirm. </span><span class="kobospan" id="kobo.867.2">A </span><a id="_idIndexMarker115" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.868.1">new connection will be listed in the MongoDB sidebar. </span><span class="kobospan" id="kobo.868.2">You can browse the tree to view databases, collections, and documents. </span><span class="kobospan" id="kobo.868.3">For example, click the first document to </span><span><span class="kobospan" id="kobo.869.1">view it:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer029">
<span class="kobospan" id="kobo.870.1"><img alt="Figure 2.12 – Viewing a document in the MongoDB extension in VS Code" src="image/B19385_02_12.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.871.1">Figure 2.12 – Viewing a document in the MongoDB extension in VS Code</span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.872.1">Tip</span></p>
<p class="callout"><span class="kobospan" id="kobo.873.1">You can also directly edit a document by editing a field in VS Code and saving the file. </span><span class="kobospan" id="kobo.873.2">The updated document will automatically be saved to </span><span><span class="kobospan" id="kobo.874.1">the database.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.875.1">The MongoDB extension is very useful for debugging our database, as it lets us visually spot problems and quickly make edits to documents. </span><span class="kobospan" id="kobo.875.2">Additionally, we can right-click on </span><strong class="bold"><span class="kobospan" id="kobo.876.1">Documents</span></strong><span class="kobospan" id="kobo.877.1"> and </span><strong class="bold"><span class="kobospan" id="kobo.878.1">Search for documents…</span></strong><span class="kobospan" id="kobo.879.1"> to open a new window where we can run MongoDB queries, just like we did in the Terminal. </span><span class="kobospan" id="kobo.879.2">The queries can be executed on the database by clicking on the </span><strong class="bold"><span class="kobospan" id="kobo.880.1">Play</span></strong><span class="kobospan" id="kobo.881.1"> button in the top right. </span><span class="kobospan" id="kobo.881.2">You may need to confirm a dialog with </span><strong class="bold"><span class="kobospan" id="kobo.882.1">Yes</span></strong><span class="kobospan" id="kobo.883.1">, and then the results will show in a new pane, as can be seen in the </span><span><span class="kobospan" id="kobo.884.1">following screenshot:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer030">
<span class="kobospan" id="kobo.885.1"><img alt="Figure 2.13 – Querying MongoDB in VS Code" src="image/B19385_02_13.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.886.1">Figure 2.13 – Querying MongoDB in VS Code</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.887.1">Now that we have learned the basics of using and debugging MongoDB databases, we can start integrating our database in a Node.js backend service, instead of simply storing and reading information </span><span><span class="kobospan" id="kobo.888.1">from files.</span></span></p>
<h1 id="_idParaDest-48" class="calibre5"><a id="_idTextAnchor047" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.889.1">Accessing the MongoDB database via Node.js</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.890.1">We are</span><a id="_idIndexMarker116" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.891.1"> now going to create a new web server that, instead </span><a id="_idIndexMarker117" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.892.1">of returning users from a JSON file, returns the list of users from our previously created </span><span><strong class="source-inline"><span class="kobospan" id="kobo.893.1">users</span></strong></span><span><span class="kobospan" id="kobo.894.1"> collection:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.895.1">In the </span><strong class="source-inline1"><span class="kobospan" id="kobo.896.1">ch2</span></strong><span class="kobospan" id="kobo.897.1"> folder, open a Terminal. </span><span class="kobospan" id="kobo.897.2">Install the </span><strong class="source-inline1"><span class="kobospan" id="kobo.898.1">mongodb</span></strong><span class="kobospan" id="kobo.899.1"> package, which contains the official MongoDB driver </span><span><span class="kobospan" id="kobo.900.1">for Node.js:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.901.1">$ npm install mongodb@6.3.0</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.902.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.903.1">backend/mongodbweb.js</span></strong><span class="kobospan" id="kobo.904.1"> file and open it. </span><span class="kobospan" id="kobo.904.2">Import </span><span><span class="kobospan" id="kobo.905.1">the following:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.906.1">
import { createServer } from 'node:http'
import { MongoClient } from 'mongodb'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.907.1">Define the connection URL and database name and then create a new </span><span><span class="kobospan" id="kobo.908.1">MongoDB client:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.909.1">
const url = 'mongodb://localhost:27017/'
const dbName = 'ch2'
const client = new MongoClient(url)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.910.1">Connect to the database and log a message after we are connected successfully, or when there is an error with </span><span><span class="kobospan" id="kobo.911.1">the connection:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.912.1">
try {
  await client.connect()
  console.log('Successfully connected to database!')
} catch (err) {
  console.error('Error connecting to database:', err)
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.913.1">Next, create </span><a id="_idIndexMarker118" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.914.1">an HTTP server, like we </span><span><span class="kobospan" id="kobo.915.1">did</span></span><span><a id="_idIndexMarker119" class="calibre6 pcalibre1 pcalibre"/></span><span><span class="kobospan" id="kobo.916.1"> before:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.917.1">
const server = createServer(async (req, res) =&gt; {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.918.1">Then, select the database from the client, and the </span><strong class="source-inline1"><span class="kobospan" id="kobo.919.1">users</span></strong><span class="kobospan" id="kobo.920.1"> collection from </span><span><span class="kobospan" id="kobo.921.1">the database:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.922.1">
  const db = client.db(dbName)
  const users = db.collection('users')</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.923.1">Now, execute the </span><strong class="source-inline1"><span class="kobospan" id="kobo.924.1">find()</span></strong><span class="kobospan" id="kobo.925.1"> method on the </span><strong class="source-inline1"><span class="kobospan" id="kobo.926.1">users</span></strong><span class="kobospan" id="kobo.927.1"> collection. </span><span class="kobospan" id="kobo.927.2">In the MongoDB Node.js driver, we also need to call the </span><strong class="source-inline1"><span class="kobospan" id="kobo.928.1">toArray()</span></strong><span class="kobospan" id="kobo.929.1"> method to resolve the iterator to </span><span><span class="kobospan" id="kobo.930.1">an array:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.931.1">
  const usersList = await users.find().toArray()</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.932.1">Finally, set the status code and response header, and return the </span><span><span class="kobospan" id="kobo.933.1">users list:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.934.1">
  res.statusCode = 200
  res.setHeader('Content-Type', 'application/json')
  res.end(JSON.stringify(usersList))
})</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.935.1">Now that we have defined our server, copy over the code from before to listen to </span><strong class="source-inline1"><span class="kobospan" id="kobo.936.1">localhost</span></strong><span class="kobospan" id="kobo.937.1"> on </span><span><span class="kobospan" id="kobo.938.1">port </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.939.1">3000</span></strong></span><span><span class="kobospan" id="kobo.940.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.941.1">
const host = 'localhost'
const port = 3000
server.listen(port, host, () =&gt; {
  console.log(`Server listening on http://${host}:${port}`)
})</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.942.1">Run</span><a id="_idIndexMarker120" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.943.1"> the server by executing </span><span><span class="kobospan" id="kobo.944.1">the </span></span><span><a id="_idIndexMarker121" class="calibre6 pcalibre1 pcalibre"/></span><span><span class="kobospan" id="kobo.945.1">script:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.946.1">$ node backend/mongodbweb.js</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.947.1">Open </span><strong class="source-inline1"><span class="kobospan" id="kobo.948.1">http://localhost:3000</span></strong><span class="kobospan" id="kobo.949.1"> in your browser and you should see the list of users from our database </span><span><span class="kobospan" id="kobo.950.1">being returned:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer031">
<span class="kobospan" id="kobo.951.1"><img alt="Figure 2.14 – Our first Node.js service retrieving data from a MongoDB database!" src="image/B19385_02_14.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.952.1">Figure 2.14 – Our first Node.js service retrieving data from a MongoDB database!</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.953.1">As we have seen, we can use similar methods that we have used in the MongoDB Shell in Node.js as well. </span><span class="kobospan" id="kobo.953.2">However, the APIs of the </span><strong class="source-inline"><span class="kobospan" id="kobo.954.1">node:http</span></strong><span class="kobospan" id="kobo.955.1"> module and the </span><strong class="source-inline"><span class="kobospan" id="kobo.956.1">mongodb</span></strong><span class="kobospan" id="kobo.957.1"> package are very low-level, requiring a lot of code to create an HTTP API and talk to </span><span><span class="kobospan" id="kobo.958.1">the database.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.959.1">In the next chapter, we are going to learn about libraries that abstract these processes to allow for easier creation of HTTP APIs and handling of the database. </span><span class="kobospan" id="kobo.959.2">These libraries are Express and Mongoose. </span><span class="kobospan" id="kobo.959.3">Express is a web framework that allows us to easily define API routes and handle requests. </span><span class="kobospan" id="kobo.959.4">Mongoose allows us to create schemas for documents in our database to more easily create, read, update, and </span><span><span class="kobospan" id="kobo.960.1">delete objects.</span></span></p>
<h1 id="_idParaDest-49" class="calibre5"><a id="_idTextAnchor048" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.961.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.962.1">In this chapter, we learned how to use Node.js to develop scripts that can run on a server. </span><span class="kobospan" id="kobo.962.2">We also learned how to create containers with Docker, and how MongoDB works and can be interfaced with. </span><span class="kobospan" id="kobo.962.3">At the end of this chapter, we even successfully created our first simple backend service using Node.js </span><span><span class="kobospan" id="kobo.963.1">and MongoDB!</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.964.1">In the next chapter, </span><a href="B19385_03_split_000.xhtml#_idTextAnchor050" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.965.1">Chapter 3</span></em></span></a><span class="kobospan" id="kobo.966.1">, </span><em class="italic"><span class="kobospan" id="kobo.967.1">Implementing a Backend Using Express, Mongoose ODM, and Jest</span></em><span class="kobospan" id="kobo.968.1">, we are going to learn how to put together what we learned in this chapter to extend our simple backend service to a production-ready backend for a </span><span><span class="kobospan" id="kobo.969.1">blog application.</span></span></p>
</div>
</body></html>