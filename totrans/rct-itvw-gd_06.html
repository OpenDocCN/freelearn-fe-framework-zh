<html><head></head><body>
<div id="_idContainer037">
<h1 class="chapter-number" id="_idParaDest-210"><a id="_idTextAnchor209"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-211"><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.2.1">Redux: The Best State Management Solution</span></h1>
<p><span class="koboSpan" id="kobo.3.1">As the requirements of your JavaScript single-page applications become more complicated, it will become challenging to maintain the application state. </span><span class="koboSpan" id="kobo.3.2">This application state can be created from server or API responses, the local component state, and the UI state such as pagination controls, active routes, and selected tabs. </span><span class="koboSpan" id="kobo.3.3">The state can be changed with the help of direct or indirect models or UI interactions in your application. </span><span class="koboSpan" id="kobo.3.4">At some point, you may lose control over when, why, and how the state has been changed. </span><span class="koboSpan" id="kobo.3.5">This issue has been resolved by state management design patterns and libraries such as Flux, Redux, MobX, Recoil, Rematch, Vuex, and </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Choosing the right state management solution is crucial for any medium- to large-scale React application. </span><span class="koboSpan" id="kobo.5.2">After reading this chapter, you will be able to answer questions fluently about the Flux pattern and Redux architecture, core principles, main components, handling asynchronous data flow, middleware such as Saga and Thunk, and Redux DevTools </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">for debugging.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1"> In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Understanding the Flux pattern </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">and Redux</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Core principles of Redux, components, </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">and APIs</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Redux middleware – Saga </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">and Thunk</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Standardizing Redux logic </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">using RTK</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Debugging applications using </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Redux DevTools</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.19.1">Redux was initially created for React applications and it is quite popular among all the state management libraries available. </span><span class="koboSpan" id="kobo.19.2">Let’s learn more about the Flux pattern, Redux fundamentals, and core concepts in the next section for a better understanding of the </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">Redux library.</span></span></p>
<h1 id="_idParaDest-212"><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.21.1">Understanding the Flux pattern and Redux</span></h1>
<p><span class="koboSpan" id="kobo.22.1">Flux has been created as a design pattern to manage the data flow in React applications. </span><span class="koboSpan" id="kobo.22.2">This is a slight modification of the </span><em class="italic"><span class="koboSpan" id="kobo.23.1">Observer</span></em><span class="koboSpan" id="kobo.24.1"> pattern, which defines a subscription mechanism in which any state change to one object notifies all other </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">objects (</span></span><a href="https://en.wikipedia.org/wiki/Observer_pattern"><span class="No-Break"><span class="koboSpan" id="kobo.26.1">https://en.wikipedia.org/wiki/Observer_pattern</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.27.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">In 2015, the Redux library was introduced. </span><span class="koboSpan" id="kobo.28.2">It was inspired by Flux architecture but implemented differently. </span><span class="koboSpan" id="kobo.28.3">The next couple of questions focus on Flux and Redux core concepts for the strong foundation of the Redux state </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">management library.</span></span></p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.30.1">What is the Flux pattern? </span><span class="koboSpan" id="kobo.30.2">Can you explain the data flow?</span></h2>
<p><span class="koboSpan" id="kobo.31.1">Flux is a pattern for managing the unidirectional data flow in your application and acts as a replacement for the</span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.32.1"> traditional MVC pattern. </span><span class="koboSpan" id="kobo.32.2">It is neither a framework nor a library but a new kind of architecture to resolve the state management complexities in client-side web applications. </span><span class="koboSpan" id="kobo.32.3">It has been developed and used by Facebook internally while working</span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.33.1"> with </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">React applications.</span></span></p>
<p><span class="koboSpan" id="kobo.35.1">Flux has four major components in its data flow: Action, Dispatcher, Store, and View. </span><span class="koboSpan" id="kobo.35.2">Here’s a little more </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">about them:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.37.1">Action</span></strong><span class="koboSpan" id="kobo.38.1">: This represents a JavaScript object that is </span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.39.1">sent to the dispatcher to trigger the </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">data flow.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.41.1">Dispatcher</span></strong><span class="koboSpan" id="kobo.42.1">: This is a singleton</span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.43.1"> registry of callbacks to update the store, and it works as a central hub of the data flow in the Flux application. </span><span class="koboSpan" id="kobo.43.2">It has no real intelligence and simply dispatches the payload from the action to </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">the store.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.45.1">Store</span></strong><span class="koboSpan" id="kobo.46.1">: This is the place where the</span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.47.1"> application state and logic </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">are maintained.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.49.1">View</span></strong><span class="koboSpan" id="kobo.50.1">: This receives the data from</span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.51.1"> the store and re-renders the app. </span><span class="koboSpan" id="kobo.51.2">The view is going to trigger the action for any </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">user interactions.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.53.1">The step-by-step data flow of the Flux architecture based on the preceding components looks </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">like this:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.55.1">If any user performs any UI interactions, an event will be generated, and the views will send actions to </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">the dispatcher.</span></span></li>
<li><span class="koboSpan" id="kobo.57.1">Dispatchers send those </span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.58.1">actions to the </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">respective stores.</span></span></li>
<li><span class="koboSpan" id="kobo.60.1">Stores update the state and notify the views </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">to re-render.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.62.1">The following diagram describes how the data flow happens in a Flux-based </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">web application:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer035">
<span class="koboSpan" id="kobo.64.1"><img alt="Figure 6.1: Flux data flow" src="image/Figure_06.01_B18603.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.65.1">Figure 6.1: Flux data flow</span></p>
<p><span class="koboSpan" id="kobo.66.1">In most applications, we will also create </span><em class="italic"><span class="koboSpan" id="kobo.67.1">action creators</span></em><span class="koboSpan" id="kobo.68.1"> as a library of helper methods that not only create action objects but also pass the action to </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">the dispatcher.</span></span></p>
<h2 id="_idParaDest-214"><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.70.1">What are the advantages of Flux?</span></h2>
<p><span class="koboSpan" id="kobo.71.1">The Flux architecture comes with</span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.72.1"> the following advantages and is helpful to use in client-side </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">web applications:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.74.1">It is easy to understand because of its unidirectional </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">data flow</span></span></li>
<li><span class="koboSpan" id="kobo.76.1">The Flux components are decoupled, and each component has its </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">own responsibility</span></span></li>
<li><span class="koboSpan" id="kobo.78.1">It is an open source architecture rather than a framework or </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">a library</span></span></li>
<li><span class="koboSpan" id="kobo.80.1">Runtime errors will be reduced because of </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">its design</span></span></li>
<li><span class="koboSpan" id="kobo.82.1">It is easy </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">to maintain</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.84.1">The Flux architecture helps move the implementation of API communication, caching, and localization code out from the view or </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">UI layer.</span></span></p>
<h2 id="_idParaDest-215"><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.86.1">How do you differentiate Flux from MVC?</span></h2>
<p><span class="koboSpan" id="kobo.87.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.88.1">Model, View, Controller</span></strong><span class="koboSpan" id="kobo.89.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.90.1">MVC</span></strong><span class="koboSpan" id="kobo.91.1">) design pattern </span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.92.1">was introduced in 1976 in the Smalltalk programming language. </span><span class="koboSpan" id="kobo.92.2">As the application grows, this pattern becomes complex with its multi-data </span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.93.1">flow. </span><span class="koboSpan" id="kobo.93.2">The Facebook team solved this problem by introducing the</span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.94.1"> Flux architecture. </span><span class="koboSpan" id="kobo.94.2">The major differences between MVC and Flux design patterns are listed in the </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">following table.</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-4">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.96.1">MVC</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.97.1">Flux</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.98.1">The data flow direction </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">is bi-directional</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.100.1">The data flow direction </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">is unidirectional</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.102.1">The controller handles </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">the logic</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.104.1">The store handles </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">the logic</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.106.1">There is no store concept </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">in MVC</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.108.1">There can be multiple stores </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">in Flux</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.110.1">It </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">is synchronous</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.112.1">It </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">is asynchronous</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.114.1">Debugging is difficult due to the bi-directional </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">data flow</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.116.1">Debugging is easier with </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">the dispatcher</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.118.1">It is used for both client-side and </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">server-side frameworks</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.120.1">It is used for client-side </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">frameworks only</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.122.1">Table 6.1: MVC versus Flux</span></p>
<p><span class="koboSpan" id="kobo.123.1">Flux is not totally a different approach from MVC, but it is an improved MVC pattern. </span><span class="koboSpan" id="kobo.123.2">If the application is complex and has a complicated data model, it’s better to opt for Flux </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">over MVC.</span></span></p>
<h2 id="_idParaDest-216"><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.125.1">What is Redux?</span></h2>
<p><span class="koboSpan" id="kobo.126.1">Redux is a popular and predictable state container library designed to write JavaScript applications that behave </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.127.1">consistently across client, server, and native environments, and at the same time, is easy to test. </span><span class="koboSpan" id="kobo.127.2">It is inspired by Facebook’s Flux architecture. </span><span class="koboSpan" id="kobo.127.3">The unnecessary complexities that existed in the Flux pattern have been eliminated </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">by it.</span></span></p>
<p><span class="koboSpan" id="kobo.129.1">It is quite straightforward to use a component state when the application contains fewer components. </span><span class="koboSpan" id="kobo.129.2">As the number of components increases and the application becomes larger, it will be challenging to maintain the state of each component in your application. </span><span class="koboSpan" id="kobo.129.3">In this case, Redux comes to the rescue to manage the state of large applications by creating a global store, and all the needed components use this global store without passing down props from one component to </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">the other.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.131.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.132.1">Redux is a lightweight library with a size of around 2 KB, including </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">its dependencies.</span></span></p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.134.1">What are the differences between Flux and Redux?</span></h2>
<p><span class="koboSpan" id="kobo.135.1">Even though Redux is</span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.136.1"> inspired by the Flux architecture, there are a few major differences, as listed in </span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.137.1">the </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">following table.</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-2">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.139.1">Flux</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.140.1">Redux</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.141.1">This was developed </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">by Facebook</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.143.1">This was developed by Dan Abramov and </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">Andrew Clark</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.145.1">It is an application architecture to manage the </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">application state</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.147.1">It is an open source JavaScript library to manage </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">the state</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.149.1">Flux provides multiple stores in </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">the application</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.151.1">The intended pattern in Redux is to have only one store in </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">the application</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.153.1">It consists of four </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">major components:</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.155.1">Action</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.156.1">Dispatcher</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.157.1">Store</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.158.1">View</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.159.1">It consists of three </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">major components:</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.161.1">Action</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.162.1">Reducer</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.163.1">Store</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.164.1">The store manages the </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">logic handling</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.166.1">Reducers manage the </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">logic handling</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.168.1">It has a </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">singleton dispatcher</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.170.1">It won’t use </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">any dispatcher</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.172.1">The store’s state can </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">be mutable</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.174.1">The store’s state </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">is immutable</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.176.1">Table 6.2: Flux versus Redux</span></p>
<p><span class="koboSpan" id="kobo.177.1">Apart from the preceding</span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.178.1"> differences, Redux reduces complexity via functional </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.179.1">composition, unlike Flux, which uses </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">callback registration.</span></span></p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.181.1">When do you need to use Redux?</span></h2>
<p><span class="koboSpan" id="kobo.182.1">Redux is used to maintain and</span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.183.1"> update the data across your application with a shared state for multiple components. </span><span class="koboSpan" id="kobo.183.2">But it may not be needed for all kinds of applications. </span><span class="koboSpan" id="kobo.183.3">It comes with a big learning curve and the need to write </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">more code.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">The following is a list of use cases where Redux </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">is useful:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.187.1">You have large </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.188.1">amounts of application state that needs to be shared by many components in </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">the app</span></span></li>
<li><span class="koboSpan" id="kobo.190.1">You need to follow a single source of truth for your </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">application state</span></span></li>
<li><span class="koboSpan" id="kobo.192.1">The application state needs to be </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">updated frequently</span></span></li>
<li><span class="koboSpan" id="kobo.194.1">The logic of updating the application state </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">is complex</span></span></li>
<li><span class="koboSpan" id="kobo.196.1">You need to monitor how the state update happens over </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">a period</span></span></li>
<li><span class="koboSpan" id="kobo.198.1">The application code is not a small-scale code base and many team members need to work </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">on it</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.200.1">Moreover, if you can manage state within React or any other frontend framework itself, then you don’t need to </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">use Redux.</span></span></p>
<p><span class="koboSpan" id="kobo.202.1">Redux is not just a tiny library; it is also a pattern based on core principles, a working system with three major</span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.203.1"> components, and provides several add-ons and vast APIs to cover common use cases in Redux applications. </span><span class="koboSpan" id="kobo.203.2">Let’s dive deep into all these topics in the </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">next section.</span></span></p>
<h1 id="_idParaDest-219"><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.205.1">Core principles of Redux, components, and APIs</span></h1>
<p><span class="koboSpan" id="kobo.206.1">Even though Redux is inspired by the important qualities of Flux architecture, it has its own foundation principles and various components that make the Redux system handle state management in massive applications. </span><span class="koboSpan" id="kobo.206.2">As part of this section, you will get a clear understanding of Redux internals and their usage to answer medium- to </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">advanced-level questions.</span></span></p>
<h2 id="_idParaDest-220"><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.208.1">What are the core principles of Redux?</span></h2>
<p><span class="koboSpan" id="kobo.209.1">Redux is based on three core principles. </span><span class="koboSpan" id="kobo.209.2">These</span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.210.1"> principles are helpful to understand the library in a </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">better way:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.212.1">Single source of truth</span></strong><span class="koboSpan" id="kobo.213.1">: The global state of your application is stored in a single store in the form of an object tree. </span><span class="koboSpan" id="kobo.213.2">Since all the states exist in a single place, it is called a single </span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.214.1">source </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">of truth.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.216.1">The single tree makes it easier to debug and inspect the application. </span><span class="koboSpan" id="kobo.216.2">As a result, you can easily implement </span><em class="italic"><span class="koboSpan" id="kobo.217.1">Undo</span></em><span class="koboSpan" id="kobo.218.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.219.1">Redo</span></em><span class="koboSpan" id="kobo.220.1"> functionalities, which were hard to implement previously. </span><span class="koboSpan" id="kobo.220.2">The entire state of the application is retrieved by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">getState()</span></strong><span class="koboSpan" id="kobo.222.1"> function, </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.224.1">
console.log(store.getState());</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.225.1">This single tree is also helpful to persist the state in development for a faster </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">development cycle.</span></span></p></li> </ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.227.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.228.1">The one-store approach of Redux is one of the major differences from the multi-store approach </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">of Flux.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.230.1">The state is read-only</span></strong><span class="koboSpan" id="kobo.231.1">: The only possible way to modify the state is to emit an action, an object form</span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.232.1"> that describes what happened. </span><span class="koboSpan" id="kobo.232.2">That means an application cannot change the state directly, but instead, expresses an intent to change the state by passing </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">an action.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.234.1">The following is an example code snippet that adds a new city to </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">cities</span></strong><span class="koboSpan" id="kobo.236.1"> state by dispatching </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">an action:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.238.1">
store.dispatch({
  type: 'ADD_CITY',
  payload: "London"
})</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.239.1">Since the preceding action is a plain JavaScript object, it can be serialized, stored, logged, and replayed for </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">debugging purposes.</span></span></p></li> <li><strong class="bold"><span class="koboSpan" id="kobo.241.1">Changes are made with pure functions</span></strong><span class="koboSpan" id="kobo.242.1">: Reducers need to be written to specify how the state is transformed by actions. </span><span class="koboSpan" id="kobo.242.2">They are simply pure functions that take arguments such as the previous state and action and return a new state. </span><span class="koboSpan" id="kobo.242.3">You need to remember that the new state object has been returned instead of modifying the </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">old state.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.244.1">The following sample reducer adds a new city and updates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">cities</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.246.1">state variable:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.247.1">
function cities(cities = [], action) {
  switch (action.type) {
    case 'ADD_CITY':
      return [
        ...cities,
        {
          name: action.payload,
          position: 1
        }
      ]
    default:
      return cities;
  }
}</span></pre></li> </ul>
<p><span class="koboSpan" id="kobo.248.1">Initially, your application can start with a single reducer. </span><span class="koboSpan" id="kobo.248.2">Once your application grows, you can split the large reducer into</span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.249.1"> multiple small reducers that manage specific parts of the state tree. </span><span class="koboSpan" id="kobo.249.2">Moreover, you can also control the order of reducers invoked, passing the additional data, and making them reusable in the application for </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">common tasks.</span></span></p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.251.1">How does Redux work? </span><span class="koboSpan" id="kobo.251.2">What are the main components of Redux?</span></h2>
<p><span class="koboSpan" id="kobo.252.1">The Redux system works by holding the entire state of the application in a central store. </span><span class="koboSpan" id="kobo.252.2">Each UI component </span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.253.1">that is a child of the Redux's provider can access this stored state instead of sending the props from one component to the other. </span><span class="koboSpan" id="kobo.253.2">The entire</span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.254.1"> process of the Redux workflow is </span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.255.1">based on three main core</span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.256.1"> components: </span><strong class="bold"><span class="koboSpan" id="kobo.257.1">Actions</span></strong><span class="koboSpan" id="kobo.258.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.259.1">Reducers</span></strong><span class="koboSpan" id="kobo.260.1">, and </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.261.1">the Store</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.263.1">The workflow of Redux using the core</span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.264.1"> components is explained with a simple todo example for better understanding in the following code. </span><span class="koboSpan" id="kobo.264.2">In the example, daily activities such as eating and running are considered as todos and added to the store using the </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">Redux workflow:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.266.1">Actions</span></strong><span class="koboSpan" id="kobo.267.1">: Actions are plain JavaScript objects that contain </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">type</span></strong><span class="koboSpan" id="kobo.269.1"> fields that denote what kind of action to </span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.270.1">perform, and other data fields that are </span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.271.1">used to change the state. </span><span class="koboSpan" id="kobo.271.2">They are the only way to send the application data (for example, through form data, user interaction, or API calls) to the Redux store. </span><span class="koboSpan" id="kobo.271.3">All these actions are created via action creators, which are just functions that </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">return actions.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.273.1">The following code snippet is an example of adding a todo action creator named </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">addTodo</span></strong><span class="koboSpan" id="kobo.275.1"> that returns a </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">todo action:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.277.1">
function addTodo(todo) {
  return {
    type: 'ADD_TODO',
    payload: todo
  }
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.278.1">The preceding action also contains todo details as a payload. </span><span class="koboSpan" id="kobo.278.2">It will be executed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">store.dispatch(addTodo)</span></strong><span class="koboSpan" id="kobo.280.1"> method, which sends this action to </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">the store.</span></span></p></li> <li><strong class="bold"><span class="koboSpan" id="kobo.282.1">Reducers</span></strong><span class="koboSpan" id="kobo.283.1">: Actions describe what to</span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.284.1"> do but they don’t tell us how to do it. </span><span class="koboSpan" id="kobo.284.2">So, reducers are used to handle how the store’s state will change in </span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.285.1">response to an action. </span><span class="koboSpan" id="kobo.285.2">Reducers are similar to event listeners, which handle events based on the received </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">action type.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.287.1">The reducer has logic to add a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">todo</span></strong><span class="koboSpan" id="kobo.289.1">, which looks like the following </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">code snippet:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.291.1">
const todoReducer = (state = initialState, action) =&gt; {
  switch (action.type) {
    case "ADD_TODO":
      const { name, priority } = action.payload;
      return [...state.todos, { name, priority }];
    default:
      return state;
  }
};</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.292.1">The preceding reducer takes the initial state and action as arguments. </span><span class="koboSpan" id="kobo.292.2">If the switch case matches with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">ADD_TODO</span></strong><span class="koboSpan" id="kobo.294.1"> action type, it copies the existing todos from the state, updates the todos with a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">todo</span></strong><span class="koboSpan" id="kobo.296.1"> value, and returns the todo new list. </span><span class="koboSpan" id="kobo.296.2">Otherwise, the existing state </span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.297.1">with unchanged todos will be returned. </span><span class="koboSpan" id="kobo.297.2">You can add more</span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.298.1"> functional cases based on possible actions such as updating, deleting, and filtering todos in </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">the application.</span></span></p></li> </ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.300.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.301.1">It is not restricted to using switch-case code blocks only to decide what the new state should be. </span><span class="koboSpan" id="kobo.301.2">You can also use </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">if/else</span></strong><span class="koboSpan" id="kobo.303.1"> loops or any other </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">programming constructs.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.305.1">Store</span></strong><span class="koboSpan" id="kobo.306.1">: The store is used to </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.307.1">hold the application state and the same state modified by React </span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.308.1">components by dispatching actions to the store. </span><span class="koboSpan" id="kobo.308.2">Redux provides the following helper methods for creating the store, accessing it, and dispatching actions to </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">the store:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">createStore</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.311.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">configureStore</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">dispatch(action)</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">getState()</span></strong></span></li></ul><p class="list-inset"><span class="koboSpan" id="kobo.315.1">These helper methods are going to be used to create or update the todos state in the store, as </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">shown here:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.317.1">
import { createStore } from "redux";
import todoReducer from "reducers/todoReducer";
const store = createStore(todoReducer); // Create a store
const firstTodo = addTodo({ name: "Running", priority: 2 });
console.log(firstTodo);
store.dispatch(firstTodo); // Dispatch a todo
const secondTodo = addTodo({ name: "Eating", priority: 1 });
console.log(secondTodo);
store.dispatch(secondTodo);
console.log(store.getState()); // Returns the todos list</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.318.1">In the preceding code, new todo</span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.319.1"> actions have been created and dispatched to update the existing todo list in the store. </span><span class="koboSpan" id="kobo.319.2">The updated todos state is </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">also accessible.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.321.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">createStore</span></strong><span class="koboSpan" id="kobo.323.1"> method has </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.324.1">been deprecated and it is recommended to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">configureStore</span></strong><span class="koboSpan" id="kobo.326.1"> method from the RTK by the Redux team. </span><span class="koboSpan" id="kobo.326.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">configureStore</span></strong><span class="koboSpan" id="kobo.328.1"> method provides additional defaults for the store setup and the inclusion of the Redux DevTools extension automatically. </span><span class="koboSpan" id="kobo.328.2">In the previous code snippet, we used </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">createStore</span></strong><span class="koboSpan" id="kobo.330.1"> from plain Redux, and you will see the usage of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">configureStore</span></strong><span class="koboSpan" id="kobo.332.1"> method when we introduce </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">the RTK.</span></span></p></li> </ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.334.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.335.1">As the application grows, the specific parts of the state information from the store’s state can be accessed using functions known as </span><em class="italic"><span class="koboSpan" id="kobo.336.1">selectors</span></em><span class="koboSpan" id="kobo.337.1">. </span><span class="koboSpan" id="kobo.337.2">The reselect library is popular for memoized </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">selector functions.</span></span></p>
<p><span class="koboSpan" id="kobo.339.1">It is also possible to extend the</span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.340.1"> store functionality by adding store enhancers and </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.341.1">middleware. </span><span class="koboSpan" id="kobo.341.2">These topics will be covered in the upcoming questions in </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">this chapter.</span></span></p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.343.1">Can I use Redux with non-React UI libraries?</span></h2>
<p><span class="koboSpan" id="kobo.344.1">Even though Redux is mostly</span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.345.1"> used with React and React Native libraries, it can be used with any other UI library (i.e., Redux works as a data store for various UI libraries). </span><span class="koboSpan" id="kobo.345.2">But you need to use the UI binding library to integrate Redux with your </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.346.1">UI framework or library. </span><span class="koboSpan" id="kobo.346.2">For example, React Redux is the official binding library to tie Redux together with the React library. </span><span class="koboSpan" id="kobo.346.3">There are bindings available for AngularJS, Angular, Vue, Mithril, Ember, and many other frameworks too. </span><span class="koboSpan" id="kobo.346.4">Redux provides a subscription mechanism that can be used by any other code, but it is mostly useful when you integrate with declarative views or UIs created via React or other </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">similar libraries.</span></span></p>
<h2 id="_idParaDest-223"><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.348.1">What are the rules followed by reducers?</span></h2>
<p><span class="koboSpan" id="kobo.349.1">In Redux, the reducer </span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.350.1">component should follow some specific rules. </span><span class="koboSpan" id="kobo.350.2">Those rules are </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">listed here:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.352.1">Reducers should only derive the new state value based on the current state and </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">action arguments.</span></span></li>
<li><span class="koboSpan" id="kobo.354.1">Reducers shouldn’t modify the existing state. </span><span class="koboSpan" id="kobo.354.2">However, they can perform immutable updates by copying the existing state and making changes to the copied </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">values instead.</span></span></li>
<li><span class="koboSpan" id="kobo.356.1">They are not allowed to perform any asynchronous logic, calculate random values, or any </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">side effects.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.358.1">The functions that follow the preceding</span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.359.1"> rules are also known as </span><strong class="bold"><span class="koboSpan" id="kobo.360.1">pure functions</span></strong><span class="koboSpan" id="kobo.361.1">. </span><span class="koboSpan" id="kobo.361.2">In other words, reducers are simply pure functions. </span><span class="koboSpan" id="kobo.361.3">By following these rules, reducers make Redux code and state predictable without </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">any bugs.</span></span></p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.363.1">What is the difference between the mapStateToProps() and mapDispatchToProps() methods?</span></h2>
<p><span class="koboSpan" id="kobo.364.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">mapStateToProps()</span></strong><span class="koboSpan" id="kobo.366.1"> method is a utility function used to select the part of the data from the store that the connected</span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.367.1"> component needs. </span><span class="koboSpan" id="kobo.367.2">The selected state is going to be passed as props to the component to which </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">connect()</span></strong><span class="koboSpan" id="kobo.369.1"> is applied. </span><span class="koboSpan" id="kobo.369.2">In this way, this method is helpful to avoid passing the </span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.370.1">entire application state to </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">the component.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">The following example passes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">city</span></strong><span class="koboSpan" id="kobo.374.1"> value as a prop to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">WeatherReport</span></strong><span class="koboSpan" id="kobo.376.1"> component to find the </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">weather information:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.378.1">
const mapStateToProps = (state) =&gt; {
  return {
    city: state.user.address.city,
  };
};
connect(mapStateToProps)(WeatherReport);</span></pre> <p><span class="koboSpan" id="kobo.379.1">Now, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">WeatherReport</span></strong><span class="koboSpan" id="kobo.381.1"> component only accepts </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">city</span></strong><span class="koboSpan" id="kobo.383.1"> as a prop. </span><span class="koboSpan" id="kobo.383.2">You can easily use this component anywhere else in the application by decoupling Redux code from </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">React components:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.385.1">
&lt;WeatherReport city={city} /&gt;</span></pre> <p><span class="koboSpan" id="kobo.386.1">The shorthand notation for this function is </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">mapState</span></strong><span class="koboSpan" id="kobo.388.1"> and this function is called every time the store </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">state changes.</span></span></p>
<p><span class="koboSpan" id="kobo.390.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">mapDispatchToProps()</span></strong><span class="koboSpan" id="kobo.392.1"> method is a utility function that is used to specify which actions your component might need to dispatch. </span><span class="koboSpan" id="kobo.392.2">This function provides action dispatching functions </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">as props.</span></span></p>
<p><span class="koboSpan" id="kobo.394.1">The following function specifies the actions required for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">WeatherReport</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.396.1">React component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.397.1">
const mapDispatchToProps = (dispatch) =&gt; {
  return {
    changeCity: (city) =&gt; {
      dispatch(changeCity(city));
    },
  };
};</span></pre> <p><span class="koboSpan" id="kobo.398.1">The preceding code snippet performs a city change action. </span><span class="koboSpan" id="kobo.398.2">This is done by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">props.changeCity(city)</span></strong><span class="koboSpan" id="kobo.400.1"> action directly in the component instead of calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">props.dispatch(changeCity(city))</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.402.1">verbose expression.</span></span></p>
<p><span class="koboSpan" id="kobo.403.1">There is a recommended object</span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.404.1"> shorthand notation for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">mapDispatchToProps</span></strong><span class="koboSpan" id="kobo.406.1"> function. </span><span class="koboSpan" id="kobo.406.2">In this approach, Redux wraps it in another function that looks like </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">(…args) =&gt; dispatch(changeCity(…args))</span></strong><span class="koboSpan" id="kobo.408.1"> and passes that wrapper function as a prop to </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">your component.</span></span></p>
<p><span class="koboSpan" id="kobo.410.1">Now, the preceding code can be simplified </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.412.1">
const mapDispatchToProps = {
   toggleCity
};</span></pre> <p><span class="koboSpan" id="kobo.413.1">In summary, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">mapStateToProps</span></strong><span class="koboSpan" id="kobo.415.1"> function is used to render the stored data to the component and </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">mapDispatchToProps</span></strong><span class="koboSpan" id="kobo.417.1"> is used to provide the action creators as props to </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">the component.</span></span></p>
<h2 id="_idParaDest-225"><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.419.1">What is a store enhancer?</span></h2>
<p><span class="koboSpan" id="kobo.420.1">A store enhancer is a higher-order function </span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.421.1">that accepts a store creator function (i.e., </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">createStore</span></strong><span class="koboSpan" id="kobo.423.1">) and returns a new enhanced store creator function. </span><span class="koboSpan" id="kobo.423.2">This is helpful to customize the original Redux store, and it will override the store methods such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">dispatch</span></strong><span class="koboSpan" id="kobo.425.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">getState</span></strong><span class="koboSpan" id="kobo.427.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">subscribe</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.431.1">Take a look at the following snippet to see how the store enhancer </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">implementation looks:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.433.1">
const ourCustomEnhancer =
  (createStore) =&gt; (reducer, initialState, enhancer) =&gt; {
    const customReducer = (state, action) =&gt; {
      // Logic to return new state
    };
    const store = createStore(customReducer, initialState, enhancer);
    //Add enhancer logic
    return {
      ...store,
      //Override the some store properties or add new properties
    };
  };</span></pre> <p><span class="koboSpan" id="kobo.434.1">Store enhancer is quite</span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.435.1"> similar to the concept of </span><strong class="bold"><span class="koboSpan" id="kobo.436.1">higher-order component</span></strong><span class="koboSpan" id="kobo.437.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.438.1">HOC</span></strong><span class="koboSpan" id="kobo.439.1">) in React. </span><span class="koboSpan" id="kobo.439.2">So you can</span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.440.1"> also call the HOC as </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.441.1">component enhancer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.443.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.444.1">Middleware provides additional functionality to the Redux dispatch function and enhancers provide additional functionality to the </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">Redux store.</span></span></p>
<p><span class="koboSpan" id="kobo.446.1">Real-time applications contain</span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.447.1"> logic that involves side effects such as external API calls, generating random values, saving files, and updating local storage. </span><span class="koboSpan" id="kobo.447.2">By default, Redux has no support for these kinds of side effects to be executed. </span><span class="koboSpan" id="kobo.447.3">However, Redux middleware makes it possible to intercept the dispatched actions and inject additional complex behavior, including side effects. </span><span class="koboSpan" id="kobo.447.4">Next, we will get a better idea </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">about that.</span></span></p>
<h1 id="_idParaDest-226"><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.449.1">Redux middleware – Saga and Thunk</span></h1>
<p><span class="koboSpan" id="kobo.450.1">The basic Redux store can only </span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.451.1">perform simple synchronous state updates by dispatching an action. </span><span class="koboSpan" id="kobo.451.2">Middleware</span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.452.1"> such as </span><strong class="bold"><span class="koboSpan" id="kobo.453.1">Redux Thunk</span></strong><span class="koboSpan" id="kobo.454.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.455.1">Redux Saga</span></strong><span class="koboSpan" id="kobo.456.1"> help extend the</span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.457.1"> store capabilities by</span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.458.1"> writing the async logic to interact with the store. </span><span class="koboSpan" id="kobo.458.2">These middleware are helpful to avoid directly causing side effects in our actions, action creators, </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">or components.</span></span></p>
<h2 id="_idParaDest-227"><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.460.1">What is Redux middleware? </span><span class="koboSpan" id="kobo.460.2">How do you create middleware?</span></h2>
<p><span class="koboSpan" id="kobo.461.1">Redux middleware provides a</span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.462.1"> third-party extension to intercept every action sent to the reducer by modifying the action or canceling the action. </span><span class="koboSpan" id="kobo.462.2">It is helpful for logging, error reporting, routing, and making asynchronous API calls. </span><span class="koboSpan" id="kobo.462.3">Although Redux middleware is like Node.js middleware (for example, Express and Koa), it solves </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">different problems.</span></span></p>
<p><span class="koboSpan" id="kobo.464.1">In the following example, let’s</span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.465.1"> demonstrate the creation of a custom middleware named </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">loggerMiddleware</span></strong><span class="koboSpan" id="kobo.467.1"> to log the various actions in the console with </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">step-by-step instructions:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.469.1">As a first step, you need to import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">applyMiddleware</span></strong><span class="koboSpan" id="kobo.471.1"> function from the Redux library </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.473.1">
import { applyMiddleware } from "redux";</span></pre></li> <li><span class="koboSpan" id="kobo.474.1">Create a middleware named </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">loggerMiddleware</span></strong><span class="koboSpan" id="kobo.476.1"> to intercept the action for logging purposes with the following </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">structured syntax:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.478.1">
const loggerMiddleware = (store) =&gt; (next) =&gt;
  (action) =&gt; {
  console.log("action", action);
  return next(action);
};</span></pre></li> <li><span class="koboSpan" id="kobo.479.1">After the </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">loggerMiddleware</span></strong><span class="koboSpan" id="kobo.481.1"> function has been created, it needs to be passed to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">applyMiddleware</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.483.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.484.1">
const middleware = applyMiddleware(loggerMiddleware);</span></pre></li> <li><span class="koboSpan" id="kobo.485.1">Finally, we need to pass the custom middleware to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">createStore</span></strong><span class="koboSpan" id="kobo.487.1"> function. </span><span class="koboSpan" id="kobo.487.2">Even though the middleware is assigned as a third argument to the store, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">createStore</span></strong><span class="koboSpan" id="kobo.489.1"> function automatically identifies the middleware based on </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">the type:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.491.1">
const store = createStore(reducer, middleware);</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.492.1">Before the action is dispatched to </span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.493.1">the store, the middleware gets executed by logging the action details in the console. </span><span class="koboSpan" id="kobo.493.2">Since the next function has been invoked inside the middleware, the reducer will also be executed to update the state in </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">the store.</span></span></p>
<p><span class="koboSpan" id="kobo.495.1">It is also possible to create multiple middleware by passing them to </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">applyMiddleware</span></strong><span class="koboSpan" id="kobo.497.1"> function </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.499.1">
const middleware = applyMiddleware(
  loggerMiddleware,
  firstMiddleware,
  secondMiddleware,
  thirdMiddleware
);</span></pre> <p><span class="koboSpan" id="kobo.500.1">In the preceding code, all these middleware are executed one after </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">the other.</span></span></p>
<h2 id="_idParaDest-228"><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.502.1">How do you handle asynchronous tasks in Redux?</span></h2>
<p><span class="koboSpan" id="kobo.503.1">Most modern web applications need to deal with asynchronous tasks. </span><span class="koboSpan" id="kobo.503.2">In React, there are two popular libraries available to handle them: </span><strong class="bold"><span class="koboSpan" id="kobo.504.1">Redux Thunk</span></strong><span class="koboSpan" id="kobo.505.1"> and </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.506.1">Redux Saga</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.508.1">Redux Thunk middleware is </span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.509.1">used to write an action creator that returns a function instead of just an action object in the Redux application. </span><span class="koboSpan" id="kobo.509.2">The functions returned from the action creator are called thunk functions and are used to delay the computation. </span><span class="koboSpan" id="kobo.509.3">These functions accept two arguments – the </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">dispatch</span></strong><span class="koboSpan" id="kobo.511.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">getState</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.513.1"> methods:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.514.1">
const thunkFunction = (dispatch, getState) =&gt; {
  // This is the place where you can write logic to
     dispatch other actions or read state
}
store.dispatch(thunkFunction);</span></pre> <p><span class="koboSpan" id="kobo.515.1">All thunk functions are invoked through the store’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">dispatch</span></strong><span class="koboSpan" id="kobo.517.1"> method but not from the application code. </span><span class="koboSpan" id="kobo.517.2">The same behavior can be seen with the preceding code </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.519.1">Similar to action creators generating actions for dispatching, you can use Thunk action creators to generate thunk functions. </span><span class="koboSpan" id="kobo.519.2">For example, the list of posts created by a specific user can be retrieved using the thunk action creator named </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">getPostsByAuthor</span></strong><span class="koboSpan" id="kobo.521.1">, which generates anonymous </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">thunk functions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.523.1">
export const getPostsByAuthor = (authorId) =&gt; async (dispatch) =&gt; {
  const response = await client.get(`/api/posts/${authorId}`);
  dispatch(postsLoaded(response.posts));
};</span></pre> <p><span class="koboSpan" id="kobo.524.1">After that, you can access the action creator inside the UI component for any user interaction. </span><span class="koboSpan" id="kobo.524.2">The following </span><strong class="source-inline"><a id="_idIndexMarker537"/></strong><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">AuthorComponent</span></strong><span class="koboSpan" id="kobo.526.1"> accesses the list of posts on the lazy </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">loading event:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.528.1">
function AuthorComponent({ authorId }) {
  //...
</span><span class="koboSpan" id="kobo.528.2">  const onLazyLoading = () =&gt; {
    dispatch(getPostsByAuthor(authorId))
  }
}</span></pre> <p><span class="koboSpan" id="kobo.529.1">The last important step is configuring the </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">redux-thunk</span></strong><span class="koboSpan" id="kobo.531.1"> middleware to the Redux store to dispatch the thunk functions. </span><span class="koboSpan" id="kobo.531.2">There are two possible options available. </span><span class="koboSpan" id="kobo.531.3">Thunk middleware needs to be passed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">applyMiddleware()</span></strong><span class="koboSpan" id="kobo.533.1"> method to add thunk middleware to the store manually. </span><span class="koboSpan" id="kobo.533.2">But if you are using RTK, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">configureStore</span></strong><span class="koboSpan" id="kobo.535.1"> API automatically adds the thunk middleware during the store creation (i.e., it doesn’t require any </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">additional configuration).</span></span></p>
<h2 id="_idParaDest-229"><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.537.1">What are the use cases of Redux Thunk?</span></h2>
<p><span class="koboSpan" id="kobo.538.1">Redux Thunk can</span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.539.1"> have any arbitrary logic and it can be used for a variety of purposes. </span><span class="koboSpan" id="kobo.539.2">The most common use cases of Redux Thunk are listed </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.541.1">When you’re trying to move complex logic out of </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">React components</span></span></li>
<li><span class="koboSpan" id="kobo.543.1">When you are making async requests such as Ajax calls and other </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">async logic</span></span></li>
<li><span class="koboSpan" id="kobo.545.1">When you need to create a logic that needs to dispatch multiple distinct actions in </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">a row</span></span></li>
<li><span class="koboSpan" id="kobo.547.1">When you are planning to write a logic that needs to access </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">getState</span></strong><span class="koboSpan" id="kobo.549.1"> or other state values to </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">make decisions</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.551.1">In summary, the main use case of Redux Thunk middleware is for handling actions that are </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">not synchronous.</span></span></p>
<h2 id="_idParaDest-230"><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.553.1">What is Redux Saga?</span></h2>
<p><span class="koboSpan" id="kobo.554.1">Redux Saga is a popular competitor for Redux Thunk middleware for handling asynchronous side effects. </span><span class="koboSpan" id="kobo.554.2">Redux Saga uses an</span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.555.1"> ES6 feature known as </span><strong class="bold"><span class="koboSpan" id="kobo.556.1">generators</span></strong><span class="koboSpan" id="kobo.557.1"> that helps in writing</span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.558.1"> asynchronous code. </span><span class="koboSpan" id="kobo.558.2">These generators are functions that can be paused, resumed, exited in the middle of execution, and re-entered later during </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">the operations.</span></span></p>
<p><span class="koboSpan" id="kobo.560.1">The side effects will be generated using special helper functions from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">redux-saga</span></strong><span class="koboSpan" id="kobo.562.1"> package. </span><span class="koboSpan" id="kobo.562.2">Some of those commonly used functions are </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">listed here:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">Call</span></strong><span class="koboSpan" id="kobo.565.1">: An effect description that instructs the middleware to call other functions </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">in Saga</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">Put</span></strong><span class="koboSpan" id="kobo.568.1">: Used to dispatch an action to </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">the store</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">Yield</span></strong><span class="koboSpan" id="kobo.571.1">: A built-in function that allows the use of generator </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">functions sequentially</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">takeLatest</span></strong><span class="koboSpan" id="kobo.574.1">: Invokes the function handler only once at a time and cancels the previous tasks by running again with the </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">latest data</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">takeEvery</span></strong><span class="koboSpan" id="kobo.577.1">: Invokes the function handler every time infinitely and concurrently whenever the </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">action fires</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.579.1">The Saga functions listen for the actions that got dispatched and trigger side effects written in your code. </span><span class="koboSpan" id="kobo.579.2">For </span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.580.1">example, the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">postsSaga</span></strong><span class="koboSpan" id="kobo.582.1"> function listens for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">GET_POSTS</span></strong><span class="koboSpan" id="kobo.584.1"> action and invokes the Posts API to retrieve the </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">author's posts:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.586.1">
import { takeLatest, put, call } from "redux-saga/effects";
import { GET_POSTS } from "./actionTypes";
import { getPostsSuccess, getPostsFail } from "./actions";
import { getPosts } from "../backend/api/posts ";
function* fetchAuthorPosts() {
  try {
    const response = yield call(getPosts);
    yield put(getPostsSuccess(response));
  } catch (error) {
    yield put(getPostsFail(error.response));
  }
}
function* postsSaga() {
  yield takeLatest(GET_POSTS, fetchAuthorPosts);
}
export default postsSaga;</span></pre> <p><span class="koboSpan" id="kobo.587.1">In the preceding code, either</span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.588.1"> the successful response or failed response dispatched to the store. </span><span class="koboSpan" id="kobo.588.2">This response depends on API call happened through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">call</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.590.1">helper function.</span></span></p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.591.1">How do you choose between Redux Saga and Redux Thunk?</span></h2>
<p><span class="koboSpan" id="kobo.592.1">Both Redux Thunk and Redux Saga middleware are helpful in allowing the Redux store to interact with external API calls (or side effects) asynchronously. </span><span class="koboSpan" id="kobo.592.2">But the decision to choose one of them totally </span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.593.1">depends on your project requirements and personal preference. </span><span class="koboSpan" id="kobo.593.2">Redux Thunk is a good choice if you are new to the React or Redux ecosystem and the project is small in size. </span><span class="koboSpan" id="kobo.593.3">Moreover, Redux Thunk requires less</span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.594.1"> boilerplate code and is easy </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">to understand.</span></span></p>
<p><span class="koboSpan" id="kobo.596.1">On the other hand, Redux Saga is suitable for big projects where you need to split the logic into multiple files. </span><span class="koboSpan" id="kobo.596.2">However, the main advantage of Redux Saga over Redux Thunk is the ability to write clean and readable tests for </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">asynchronous code.</span></span></p>
<p><span class="koboSpan" id="kobo.598.1">The plain Redux requires a lot of boilerplate code to fulfill the state management requirements. </span><span class="koboSpan" id="kobo.598.2">Developers need to implement common tasks such as store setup, writing reducers and actions, and so on. </span><span class="koboSpan" id="kobo.598.3">Also, you may need to import APIs from other packages based on needs. </span><span class="koboSpan" id="kobo.598.4">So, this entire process makes it difficult for developers to learn and implement the Redux solution. </span><span class="koboSpan" id="kobo.598.5">RTK is going to standardize the process and simplify it with </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">its helpers.</span></span></p>
<h1 id="_idParaDest-232"><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.600.1">Standardizing Redux logic using RTK</span></h1>
<p><span class="koboSpan" id="kobo.601.1">The RTK package provides the necessary tools to ease Redux development. </span><span class="koboSpan" id="kobo.601.2">This package not only eases</span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.602.1"> development but also prevents common </span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.603.1">mistakes, provides suggested best practices, and many </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">more features.</span></span></p>
<h2 id="_idParaDest-233"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.605.1">What is RTK?</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.606.1">Redux Toolkit</span></strong><span class="koboSpan" id="kobo.607.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.608.1">RTK</span></strong><span class="koboSpan" id="kobo.609.1">) is a set of tools</span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.610.1"> that simplifies Redux development and is used as an officially recommended approach to writing Redux logic. </span><span class="koboSpan" id="kobo.610.2">It was previously known as Redux Smarter Kit. </span><span class="koboSpan" id="kobo.610.3">The node package for this toolkit is available with the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">@reduxjs/toolkit</span></strong><span class="koboSpan" id="kobo.612.1">, which is wrapped around the core </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">redux</span></strong><span class="koboSpan" id="kobo.614.1"> package. </span><span class="koboSpan" id="kobo.614.2">In summary, this package provides utilities and common dependencies that are required for building a </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">Redux application.</span></span></p>
<p><span class="koboSpan" id="kobo.616.1">This tool helps cover common use cases such as setting up the store, creating the reducers and actions, writing immutable update logic, and creating entire slices of state </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">at once.</span></span></p>
<p><span class="koboSpan" id="kobo.618.1">By default, RTK automatically supports the following officially recommended set of tools or libraries to cover most of the common </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">use cases:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.620.1">Redux DevTools</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.621.1">Immer</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.622.1">Redux Thunk</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.623.1">Reselect</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.624.1">RTK supports TypeScript through which APIs provide excellent type safety and reduce the number of types used in </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">the code.</span></span></p>
<h2 id="_idParaDest-234"><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.626.1">What are the problems solved by RTK?</span></h2>
<p><span class="koboSpan" id="kobo.627.1">RTK is helpful to</span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.628.1"> speed up the development process and apply the recommended best practices automatically. </span><span class="koboSpan" id="kobo.628.2">It solves the following three major issues found in the </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">Redux library:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.630.1">Configuring a Redux store that is </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">too complicated</span></span></li>
<li><span class="koboSpan" id="kobo.632.1">This Redux library requires a lot of dependencies for building a </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">large-scale application</span></span></li>
<li><span class="koboSpan" id="kobo.634.1">Redux requires too much boilerplate code, which impacts the efficiency and quality of </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">the code</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.636.1">The toolkit provides certain options to configure the global store, creating actions and reducers that make the development simpler by abstracting the </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">Redux API.</span></span></p>
<h2 id="_idParaDest-235"><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.638.1">What is RTK Query? </span><span class="koboSpan" id="kobo.638.2">How do you use it?</span></h2>
<p><span class="koboSpan" id="kobo.639.1">RTK Query is a powerful data fetching and client-side caching tool to simplify common use cases in Redux applications. </span><span class="koboSpan" id="kobo.639.2">For</span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.640.1"> example, this tool supports use cases such as loading data in the web application, avoiding the need for hand-written data fetching and caching logic, and so on. </span><span class="koboSpan" id="kobo.640.2">If you are using the RTK package, this query feature is going to</span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.641.1"> be available as an optional add-on. </span><span class="koboSpan" id="kobo.641.2">Also, this feature is built-in on top of the RTK API methods such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">createSlice</span></strong><span class="koboSpan" id="kobo.643.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">createAsyncThunk</span></strong><span class="koboSpan" id="kobo.645.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">its implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.647.1">Let’s explain the usage of RTK Query with a data fetching use case in the </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">web application.</span></span></p>
<p><span class="koboSpan" id="kobo.649.1">First, you need to import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">createAPI</span></strong><span class="koboSpan" id="kobo.651.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">fetchBaseQuery</span></strong><span class="koboSpan" id="kobo.653.1"> API methods from the RTK Query package. </span><span class="koboSpan" id="kobo.653.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">createAPI</span></strong><span class="koboSpan" id="kobo.655.1"> method accepts an object that includes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">baseQuery</span></strong><span class="koboSpan" id="kobo.657.1"> configuration created by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">fetchBaseQuery</span></strong><span class="koboSpan" id="kobo.659.1"> API and a list of API endpoints to interact with </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">the server.</span></span></p>
<p><span class="koboSpan" id="kobo.661.1">In this example, two endpoints are going to be created – one for creating the user and the other one for listing </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">the users:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.663.1">
import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";
export const usersServerApi = createApi({
  reducerPath: "api",
  baseQuery: fetchBaseQuery({
    baseUrl: "https://jsonplaceholder.typicode.com/",
  }),
  endpoints: (builder) =&gt; ({
    users: builder.query({
      query: (page = 1) =&gt; `users?page=${page}&amp;limit=10`,
    }),
    createUser: builder.mutation({
      query: (name) =&gt; ({
        url: "users",
        method: "POST",
        body: { name },
      }),
    }),
  }),
});
export const { useUsersQuery, useCreateUserMutation } = usersServerApi;</span></pre> <p><span class="koboSpan" id="kobo.664.1">As shown in the preceding code, RTK Query auto-generates React Hooks for each endpoint that is available to use in function components through </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">export declaration.</span></span></p>
<p><span class="koboSpan" id="kobo.666.1">Next, the store needs to be </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.667.1">configured by mapping RTK Query’s generated slice reducer into root reducer along with a custom middleware that handles data fetching. </span><span class="koboSpan" id="kobo.667.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">setupListners</span></strong><span class="koboSpan" id="kobo.669.1"> API is an optional utility to enable </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">refreshOnFocus</span></strong><span class="koboSpan" id="kobo.671.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">refreshOnReconnect</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.673.1"> behaviors:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.674.1">
import { configureStore } from "@reduxjs/toolkit";
import { setupListeners } from "@reduxjs/toolkit/query";
import { usersServerApi } from "./services/usersAPI";
export const store = configureStore({
  reducer: {
    [usersServerApi.reducerPath]: usersServerApi.reducer,
  },
  middleware: (getDefaultMiddleware) =&gt;
    getDefaultMiddleware().concat(usersServerApi.middleware),
});
setupListeners(store.dispatch);</span></pre> <p><span class="koboSpan" id="kobo.675.1">After that, you need to wrap our application with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">Provider</span></strong><span class="koboSpan" id="kobo.677.1"> component from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">react-redux</span></strong><span class="koboSpan" id="kobo.679.1"> package to pass the store as a prop to all the child components, just like any </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">Redux application:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.681.1">
const rootElement = document.getElementById("root");
render(
  &lt;Provider store={store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;,
  rootElement
);</span></pre> <p><span class="koboSpan" id="kobo.682.1">Once that is done, you can make</span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.683.1"> requests in your component through queries. </span><span class="koboSpan" id="kobo.683.2">The list of users on the second page can be retrieved as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.685.1">
const { data, error, isLoading } = useUsersQuery(2)</span></pre> <p><span class="koboSpan" id="kobo.686.1">In addition to users </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">data</span></strong><span class="koboSpan" id="kobo.688.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">error</span></strong><span class="koboSpan" id="kobo.690.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">isLoading</span></strong><span class="koboSpan" id="kobo.692.1"> fields, the preceding query also provides other Boolean utilities such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">isFetching</span></strong><span class="koboSpan" id="kobo.694.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">isError</span></strong><span class="koboSpan" id="kobo.696.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">isSuccess</span></strong><span class="koboSpan" id="kobo.698.1">, which might be of use, depending on </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">functional requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.700.1">Redux is the best state solution for large-scale applications. </span><span class="koboSpan" id="kobo.700.2">However, it will be challenging to debug the bugs that arise in these kinds of applications. </span><span class="koboSpan" id="kobo.700.3">Redux DevTools makes the development and debugging experience easy by tracing when, where, and how your application’s state has </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">been changed.</span></span></p>
<h1 id="_idParaDest-236"><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.702.1">Debugging applications using Redux DevTools</span></h1>
<p><span class="koboSpan" id="kobo.703.1">Just like Chrome DevTools is</span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.704.1"> used to manipulate the content of the web page on the fly, Redux DevTools allows you to directly manipulate Redux operations in the web application. </span><span class="koboSpan" id="kobo.704.2">Nowadays, this tool has become a standard development tool for developing any kind of </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">Redux application.</span></span></p>
<h2 id="_idParaDest-237"><a id="_idTextAnchor236"/><span class="koboSpan" id="kobo.706.1">What is Redux DevTools?</span></h2>
<p><span class="koboSpan" id="kobo.707.1">Redux DevTools is a</span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.708.1"> development-purpose-only tool for debugging an application’s state changes. </span><span class="koboSpan" id="kobo.708.2">It is used to perform time-travel debugging and live editing for Redux with hot reloading, actions history, undo, and replay features. </span><span class="koboSpan" id="kobo.708.3">If you don’t want to install Redux DevTools as a standalone app or integrate it as a React component in the client app, it can be used as a browser extension for Chrome, Firefox, or </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">Edge browsers.</span></span></p>
<p><span class="koboSpan" id="kobo.710.1">The following is an example DevTools snapshot representing the sequence of fetching todos, completing, and deleting </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">todo operations:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<span class="koboSpan" id="kobo.712.1"><img alt="Figure 6.2: Redux DevTools UI" src="image/Figure_06.02_B18603.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.713.1">Figure 6.2: Redux DevTools UI</span></p>
<p><span class="koboSpan" id="kobo.714.1">In the preceding screenshot, the left panel represents the list of actions with </span><em class="italic"><span class="koboSpan" id="kobo.715.1">Skip</span></em><span class="koboSpan" id="kobo.716.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.717.1">Jump</span></em><span class="koboSpan" id="kobo.718.1"> options on selecting the particular action and the right panel describes the current state, differences in state, and other </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">useful features.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.720.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.721.1">RTK’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">configureStore</span></strong><span class="koboSpan" id="kobo.723.1"> API automatically sets up integration with </span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">Redux DevTools.</span></span></p>
<h2 id="_idParaDest-238"><a id="_idTextAnchor237"/><span class="koboSpan" id="kobo.725.1">What are the major features of Redux DevTools?</span></h2>
<p><span class="koboSpan" id="kobo.726.1">Some of the major features of </span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.727.1">Redux DevTools are </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">listed here:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.729.1">It provides the ability to inspect every state and </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">action payload</span></span></li>
<li><span class="koboSpan" id="kobo.731.1">You can go back in time by canceling </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">the actions</span></span></li>
<li><span class="koboSpan" id="kobo.733.1">Once the reducer code changes, each staged action will </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">be re-evaluated</span></span></li>
<li><span class="koboSpan" id="kobo.735.1">If there is an error thrown from the reducer, you can trace which action caused the error and what the error </span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">is about</span></span></li>
<li><span class="koboSpan" id="kobo.737.1">You can persist debug sessions across page reloads using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">persistState()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.739.1">store enhancer</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.740.1">It is also possible to dispatch actions without writing any code in the application using the </span><strong class="bold"><span class="koboSpan" id="kobo.741.1">dispatch</span></strong><span class="koboSpan" id="kobo.742.1"> option of </span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">Redux DevTools.</span></span></p>
<h1 id="_idParaDest-239"><a id="_idTextAnchor238"/><span class="koboSpan" id="kobo.744.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.745.1">This chapter has offered comprehensive knowledge of Redux state management solutions for React applications. </span><span class="koboSpan" id="kobo.745.2">We began this chapter with a brief introduction to Flux, its architecture, differences with the MVC pattern, and use cases, followed by Redux fundamentals, differences with Flux, and its advantages as a state management solution. </span><span class="koboSpan" id="kobo.745.3">We also covered topics such as the core principles of Redux, their components, various add-ons, and data flows. </span><span class="koboSpan" id="kobo.745.4">After that, we went through understanding async tasks, popular middleware libraries in Redux, how to use them in React applications, and their use cases. </span><span class="koboSpan" id="kobo.745.5">Finally, we covered the debugging techniques and Redux DevTools to track the </span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">state changes.</span></span></p>
<p><span class="koboSpan" id="kobo.747.1">In the next chapter, we will understand the various approaches to applying CSS in React applications. </span><span class="koboSpan" id="kobo.747.2">First, we will start with a regular CSS styling approach in React using inline styles and external styles. </span><span class="koboSpan" id="kobo.747.3">Then, we will go through advanced techniques such as locally scoped CSS using CSS Modules and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">styled-components</span></strong><span class="koboSpan" id="kobo.749.1"> library based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">CSS-in-JS solution.</span></span></p>
</div>
</body></html>