<html><head></head><body>
<div id="_idContainer020">
<h1 class="chapter-number" id="_idParaDest-54"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-55"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.2.1">Scaling Performance in Vue.js 3</span></h1>
<p><span class="koboSpan" id="kobo.3.1">This chapter depends solely on the knowledge of the previous chapters, where we explored the different libraries to develop large-scale and enterprise-ready applications with Vue.js 3. </span><span class="koboSpan" id="kobo.3.2">This chapter will dive deeper into scaling an extensive Vue application. </span><span class="koboSpan" id="kobo.3.3">You will learn how to scale performance with asynchronous lazy loading, image compression, code splitting, tree shaking, and many other tricks to better increase the performance of your Vue.js 3 </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">enterprise-ready application.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">We will cover the following key topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Why do we need Vue.js </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">performance optimization?</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">The primary reasons for poor </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">Vue performance</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Checking your Vue.js application’s </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">bundle size</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Optimizing the performance of an enterprise </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">Vue application</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.15.1">Once you’ve mastered each of these topics, you will be ready to get stuck into building your first enterprise-ready application with </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">Vue 3.</span></span></p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.17.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.18.1">To get started with this chapter, I recommend you read through </span><a href="B17237_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.19.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.20.1">, </span><em class="italic"><span class="koboSpan" id="kobo.21.1">Getting Started with Vue.js 3</span></em><span class="koboSpan" id="kobo.22.1">, where you will get an overview of Vue 3 and the Composition API, intensively used in </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">this chapter.</span></span></p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.24.1">Why do we need Vue.js performance optimization?</span></h1>
<p><span class="koboSpan" id="kobo.25.1">In this section, we will learn </span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.26.1">why performance stability in an application is important and how to develop an application with performance </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">in mind.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">Developing an application without taking actionable steps to ensure the stable performance of the application can cost the application a lot. </span><span class="koboSpan" id="kobo.28.2">Developing an application that takes a while to load, navigate, submit, or take any user actions will result in losing users, thereby gradually losing on the initial plan of </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">Suppose the end users are not satisfied with the enterprise application’s user experience and load time, Vue.js performance, and efficiency. </span><span class="koboSpan" id="kobo.30.2">In this case, the time invested and the lines of code written don’t matter; the user might not return to </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">Here are some different facts from</span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.33.1"> Kinsta that show how poor performance can affect the performance of an enterprise application on the </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">market: </span></span><a href="https://kinsta.com/blog/laravel-caching/"><span class="No-Break"><span class="koboSpan" id="kobo.35.1">https://kinsta.com/blog/laravel-caching/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.36.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">An online study (</span><a href="https://kinsta.com/learn/page-speed/#slow-how-slow"><span class="koboSpan" id="kobo.38.1">https://kinsta.com/learn/page-speed/#slow-how-slow</span></a><span class="koboSpan" id="kobo.39.1">) found that it cost Amazon $1.6 billion in sales per year for every 1 second of load </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">lag time.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">Another Google study (</span><a href="https://www.thinkwithgoogle.com/future-of-marketing/digital-transformation/the-google-gospel-of-speed-urs-hoelzle/"><span class="koboSpan" id="kobo.42.1">https://www.thinkwithgoogle.com/future-of-marketing/digital-transformation/the-google-gospel-of-speed-urs-hoelzle/</span></a><span class="koboSpan" id="kobo.43.1">) reported that if search results are slow even by a fraction of a second, people will search less. </span><span class="koboSpan" id="kobo.43.2">What this means is that a 400-millisecond delay leads to a 0.44% drop in </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">search volume.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">A further study shows that four out of five internet users will click away if a video stalls </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">while loading.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">The preceding study shows that a slight sluggishness in your web page load time can have a massive impact on your users’ experience and the loss of a huge amount </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">of funds.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">Now that we know why we need performance stability in our application, in the next section, let’s look at the primary reasons behind poor </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">Vue performance.</span></span><a id="_idTextAnchor091"/></p>
<h1 id="_idParaDest-58"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.51.1">The primary reasons for poor Vue performance</span></h1>
<p><span class="koboSpan" id="kobo.52.1">There are many </span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.53.1">known reasons behind poor Vue performance, and we will explore the primary and most notable reasons in </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">this section.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">The apparent reason for a Vue application slowing down is in the structure. </span><span class="koboSpan" id="kobo.55.2">As an enterprise application, it’s evident that the bigger the application, the slower the </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">application becomes.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">For example, one of the significant reasons behind poor performance in enterprise Vue applications may vary in </span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.58.1">different projects and how they deal with </span><strong class="bold"><span class="koboSpan" id="kobo.59.1">server-side </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.60.1">rendering</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.61.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.62.1">SSR</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">The primary reason for poor performance in any Vue </span><strong class="bold"><span class="koboSpan" id="kobo.65.1">single-page application</span></strong><span class="koboSpan" id="kobo.66.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.67.1">SPA</span></strong><span class="koboSpan" id="kobo.68.1">) or SSR enterprise application</span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.69.1"> is the bundle size. </span><span class="koboSpan" id="kobo.69.2">The larger the bundle size, the slower the </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">Vue performance.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">There are other common reasons behind poor performance in enterprise Vue applications, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.73.1">Not structuring the CSS and JS </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">files properly</span></span></li>
<li><span class="koboSpan" id="kobo.75.1">Not using third-party </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">libraries wisely</span></span></li>
<li><span class="koboSpan" id="kobo.77.1">Unwanted hits to </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">API requests</span></span></li>
<li><span class="koboSpan" id="kobo.79.1">Overlooking code splitting and </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">lazy loading</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.81.1">There are more reasons</span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.82.1"> for poor performance, and we have just listed a few. </span><span class="koboSpan" id="kobo.82.2">Before we discuss how to resolve them, let’s explore how to check for the bundle size of an enterprise Vue application in the </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">next sec</span><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.84.1">tion.</span></span></p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.85.1">Checking your Vue application’s bundle size</span></h1>
<p><span class="koboSpan" id="kobo.86.1">The bundle </span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.87.1">size is the total size of your Vue application that will be loaded by the browser. </span><span class="koboSpan" id="kobo.87.2">The larger the size, the slower your </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">application loads.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">There are two different ways to check your Vue bundle size when working with the </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">Vue framework.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">Let’s go through each of these methods in </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">more d</span><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.93.1">etail.</span></span></p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.94.1">Generating a report</span></h2>
<p><span class="koboSpan" id="kobo.95.1">You can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">build</span></strong><span class="koboSpan" id="kobo.97.1"> command with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">--report</span></strong><span class="koboSpan" id="kobo.99.1"> flag to generate your application report. </span><span class="koboSpan" id="kobo.99.2">This</span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.100.1"> method gives a visual representation of all the packages used and each bundle size. </span><span class="koboSpan" id="kobo.100.2">Further, with the information generated from this visual report, you can figure out how to replace any package that takes up more space and size </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">than expected.</span></span></p>
<p><span class="koboSpan" id="kobo.102.1">Also, note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">build</span></strong><span class="koboSpan" id="kobo.104.1"> command will only build a report when </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">webpack-bundle-analyzer</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.106.1">is installed.</span></span></p>
<p><span class="koboSpan" id="kobo.107.1">To generate a report for your application, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.109.1">First, install the package </span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.110.1">with the </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">following command:</span></span><pre class="console">
<strong class="bold"><span class="koboSpan" id="kobo.112.1">npm install webpack-bundle-analyzer</span></strong></pre></li>
<li><span class="koboSpan" id="kobo.113.1">Next, create a script for the command in your </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">package.json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.115.1"> file:</span></span><pre class="console">
<strong class="bold"><span class="koboSpan" id="kobo.116.1">"build-report": "vue-cli-service build --report"</span></strong></pre></li>
<li><span class="koboSpan" id="kobo.117.1">And lastly, execute the following command to generate </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">the report:</span></span><pre class="console">
<strong class="bold"><span class="koboSpan" id="kobo.119.1">npm run build-report</span></strong></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.120.1">After running the preceding command, a file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">report.html</span></strong><span class="koboSpan" id="kobo.122.1"> is created inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">dist</span></strong><span class="koboSpan" id="kobo.124.1"> folder. </span><span class="koboSpan" id="kobo.124.2">When you open the file, you will see </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<span class="koboSpan" id="kobo.126.1"><img alt="Figure 3.1 – Application bundle-size﻿ report" src="image/Figure_3.01_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.127.1">Figure 3.1 – Application bundle-size</span><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.128.1"> report</span></p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.129.1">Running the npm build command</span></h2>
<p><span class="koboSpan" id="kobo.130.1">Running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">build</span></strong><span class="koboSpan" id="kobo.132.1"> method </span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.133.1">of your Vue </span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.134.1">application will generate a list of different chunks and bundle sizes. </span><span class="koboSpan" id="kobo.134.2">From this information, you can see additional warnings concerning which chunk has a bigger bundle size and how you can improve it. </span><span class="koboSpan" id="kobo.134.3">Here’s how </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">it looks:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<span class="koboSpan" id="kobo.136.1"><img alt="Figure 3.2 – Chunks and bundle sizes" src="image/Figure_3.02_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.137.1">Figure 3.2 – Chunks and bundle sizes</span></p>
<p><span class="koboSpan" id="kobo.138.1">In this section, we learned why</span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.139.1"> we need Vue.js performance optimization, the primary reasons for poor performance, and the different ways to check Vue.js </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">bundle size.</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">In the next section, we</span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.142.1"> will learn how to optimize the performance of a Vue application using different </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">standar</span><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.144.1">d methods.</span></span></p>
<h1 id="_idParaDest-62"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.145.1">Optimizing the performance of an enterprise Vue application</span></h1>
<p><span class="koboSpan" id="kobo.146.1">One of the downsides of </span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.147.1">creating an enterprise application is the size of the application regarding the code base, the data size, and the speed it takes to respond to </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">users’ actions.</span></span></p>
<p><span class="koboSpan" id="kobo.149.1">One solution could be to implement a proper caching mechanism on both the backend and frontend of the </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">enterprise application.</span></span></p>
<p><span class="koboSpan" id="kobo.151.1">You will agree that it’s challenging to develop an application. </span><span class="koboSpan" id="kobo.151.2">Still, it is more challenging to create an application with optimized performance or even solve the performance bottleneck of an </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">enterprise application.</span></span></p>
<p><span class="koboSpan" id="kobo.153.1">In this section, we will look </span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.154.1">at some tips that you can implement to improve the performance of your enterprise </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">Vue </span><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.156.1">application.</span></span></p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.157.1">Asynchronous/lazy component loading</span></h2>
<p><span class="koboSpan" id="kobo.158.1">We will start with</span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.159.1"> asynchronous/lazy components loading to lessen your challenges to explore Vue.js </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">performance optimization.</span></span></p>
<p><span class="koboSpan" id="kobo.161.1">Asynchronous/lazy components loading in Vue.js is a term used to describe loading modules/components when the user needs a module/component. </span><span class="koboSpan" id="kobo.161.2">In an enterprise application, it is unnecessary to load all the modules from the JavaScript bundle whenever the user visits the website, as doing so will cause a </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">performance bottleneck.</span></span></p>
<p><span class="koboSpan" id="kobo.163.1">In enterprise projects, you will agree that there are complex components with many modals, tooltips, and other interconnected components that will slow down the performance of your application if not </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">lazy loaded.</span></span></p>
<p><span class="koboSpan" id="kobo.165.1">Before we explore how to lazy load components, you can check the actual JavaScript code used on your web page by following these </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">simple steps:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.167.1">Click on </span><strong class="bold"><span class="koboSpan" id="kobo.168.1">DevTools</span></strong><span class="koboSpan" id="kobo.169.1">. </span><span class="koboSpan" id="kobo.169.2">The following screen </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">will appear:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer017">
<span class="koboSpan" id="kobo.171.1"><img alt="Figure 3.3 – Sample of live DevTools in Chrome" src="image/Figure_3.03_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.172.1">Figure 3.3 – Sample of live DevTools in Chrome</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.173.1">Press </span><em class="italic"><span class="koboSpan" id="kobo.174.1">Cmd</span></em><span class="koboSpan" id="kobo.175.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.176.1">Shift</span></em><span class="koboSpan" id="kobo.177.1"> + </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.178.1">P</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.180.1">Type </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">Coverage</span></strong><span class="koboSpan" id="kobo.182.1">. </span><span class="koboSpan" id="kobo.182.2">Once you</span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.183.1"> type it, the following message will appear at the bottom of </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">the screen:</span></span></li>
</ol>
<p class="IMG---Figure"><strong class="source-inline"> </strong></p>
<div>
<div class="IMG---Figure" id="_idContainer018">
<span class="koboSpan" id="kobo.185.1"><img alt="Figure 3.4 – A screenshot showing the Coverage tab" src="image/Figure_3.04_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.186.1">Figure 3.4 – A screenshot showing the Coverage tab</span></p>
<ol>
<li value="4"><span class="No-Break"><span class="koboSpan" id="kobo.187.1">Click </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.188.1">Record</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.190.1">After recording</span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.191.1"> and analyzing the web page, it will highlight some URLs in red, which shows that the URLs are not in use and can </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">be lazy-loaded:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer019">
<span class="koboSpan" id="kobo.193.1"><img alt="Figure 3.5 – A screenshot showing different URLs when analyzing with DevTools" src="image/Figure_3.05_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.194.1">Figure 3.5 – A screenshot showing different URLs when analyzing with DevTools</span></p>
<p><span class="koboSpan" id="kobo.195.1">If lazy loading is </span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.196.1">appropriately implemented, the bundle size of your enterprise application can be reduced to 60%, thereby increasing the speed of </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.198.1">Lastly, let’s explore how to enforce lazy loading. </span><span class="koboSpan" id="kobo.198.2">We can use Webpack dynamic imports over regular imports to separate the chunk of lazily </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">loaded modules.</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">Traditionally, this is how components/modules are imported </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">in JavaScript:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.202.1">
// photo.js
const Photo = {
  testPhoto: function () {
    console.log("This is just a Photo Component!")
  }
}
export default Photo
// app.js
import Photo from './photo.js'
Photo.testPhoto()</span></pre>
<p><span class="koboSpan" id="kobo.203.1">By importing this module this way, Webpack will create a file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">photo.js</span></strong><span class="koboSpan" id="kobo.205.1"> as a node to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">app.js</span></strong><span class="koboSpan" id="kobo.207.1"> file in its dependency graph and bundle it together even when the user doesn’t need to use </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">the module.</span></span></p>
<p><span class="koboSpan" id="kobo.209.1">But to improve things a</span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.210.1"> little, we can use dynamic imports or lazy loading to achieve and overcome the performance bottleneck with the previous method. </span><span class="koboSpan" id="kobo.210.2">The following code block shows dynamic/lazy loading </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">in action:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.212.1">
// app.js
const getPhoto = () =&gt; import('./photo.js')
// later when some user action tasks place as hitting the
// route
getPhoto()
  .then({ testPhoto } =&gt; testPhoto())</span></pre>
<p><span class="koboSpan" id="kobo.213.1">Lazy loading in Vue.js is one of the best practices to reduce the bundle size and optimize performance. </span><span class="koboSpan" id="kobo.213.2">Vue recommends that bundles should not exceed a size of 244 KiB, but you can also try to optimize your web page to make sure that it’s not very slow in performance, even with a bundle size a little higher than recommended. </span><span class="koboSpan" id="kobo.213.3">Develop a habit of knowing which modules you don’t need unless there’s an explicit user action, and download them lazily for </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">bette</span><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.215.1">r performance.</span></span></p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.216.1">WebP images and image compression</span></h2>
<p><span class="koboSpan" id="kobo.217.1">One of the primary reasons for large bundle sizes and slow applications is that images contribute a lot to an application’s bundle size. </span><span class="koboSpan" id="kobo.217.2">If images are not correctly optimized, it can increase the</span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.218.1"> loading time of an application when the application renders images of </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">considerable sizes.</span></span></p>
<p><span class="koboSpan" id="kobo.220.1">There are different ways to achieve image optimization, and we are going to discuss two of the </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">popular methods:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.222.1">Compressing </span></span><span class="No-Break"><a id="_idIndexMarker097"/></span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">images</span></span></li>
<li><span class="koboSpan" id="kobo.224.1">Optimizing </span><strong class="bold"><span class="koboSpan" id="kobo.225.1">content delivery netw</span><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.226.1">ork</span></strong><span class="koboSpan" id="kobo.227.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.228.1">CDN</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">) images</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.230.1">Compressing images</span></h3>
<p><span class="koboSpan" id="kobo.231.1">If your enterprise application contains small images in number, these images will be served locally while</span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.232.1"> applying a different compression algorithm to reduce the sizes of </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">each image.</span></span></p>
<p><span class="koboSpan" id="kobo.234.1">There are thousands of online tools to compress images, and the following is the list of some </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">popular ones:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.236.1">TinyPNG</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.237.1">Compressnow</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.238.1">Image Compressor</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.239.1">Adobe Photoshop</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.240.1">Also, the best compression algorithm used to reduce the si</span><a href="https://developers.google.com/speed/webp"><span class="koboSpan" id="kobo.241.1">zes of an image i</span></a><span class="koboSpan" id="kobo.242.1">s the WebP image format (</span><a href="https://developers.google.com/speed/webp"><span class="koboSpan" id="kobo.243.1">https://developers.google.com/speed/webp</span></a><span class="koboSpan" id="kobo.244.1">), which is developed and main</span><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.245.1">tained </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">by Google.</span></span></p>
<h3><span class="koboSpan" id="kobo.247.1">Optimizing CDN images</span></h3>
<p><span class="koboSpan" id="kobo.248.1">A CDN is used to</span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.249.1"> optimize images. </span><span class="koboSpan" id="kobo.249.2">It provides</span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.250.1"> transformation features for reducing image sizes by up to 70% without affecting the UI and pixelating. </span><span class="koboSpan" id="kobo.250.2">It’s also advisable to use a CDN when your enterprise application deals with extensive </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">media use.</span></span></p>
<p><span class="koboSpan" id="kobo.252.1">The most popular </span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.253.1">CDN tools for image</span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.254.1"> optimization are </span><strong class="bold"><span class="koboSpan" id="kobo.255.1">Cloudinary</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.256.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.257.1">ImageKit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.259.1">Media takes a considerable</span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.260.1"> amount of space in any enterprise application and therefore can cause lagging and slow performance</span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.261.1"> if not optimized an</span><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.262.1">d </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">served appropriately.</span></span><a href="https://developer.mozilla.org/en-US/docs/Glossary/Code_splitting"/></p>
<h2 id="_idParaDest-65"><a href="https://developer.mozilla.org/en-US/docs/Glossary/Code_splitting"><span id="_idTextAnchor108"/><span class="koboSpan" id="kobo.264.1">Co</span></a><span class="koboSpan" id="kobo.265.1">de splitting</span></h2>
<p><span class="koboSpan" id="kobo.266.1">MDN explains the </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">following (</span></span><a href="https://developer.mozilla.org/en-US/docs/Glossary/Code_splitting"><span class="No-Break"><span class="koboSpan" id="kobo.268.1">https://developer.mozilla.org/en-US/docs/Glossary/Code_splitting</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.269.1">):</span></span></p>
<p class="author-quote"><span class="koboSpan" id="kobo.270.1">“Code splitting is the splitting of code into various bundles or components which can then be loaded on demand or in parallel.</span></p>
<p class="author-quote"><span class="koboSpan" id="kobo.271.1">As an application grows in complexity or is maintained, CSS and JavaScripts files or bundles grow in byte size, especially as the number and size of included third-party libraries increases.”</span></p>
<p><span class="koboSpan" id="kobo.272.1">When creating an enterprise </span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.273.1">application, there will always be many routes, files, and bundles that will increase the byte size of the enterprise application. </span><span class="koboSpan" id="kobo.273.2">Code splitting is the answer to separating and only loading smaller and on-demand files, thereby increasing the load time of your </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">enterprise application.</span></span></p>
<p><span class="koboSpan" id="kobo.275.1">Let’s our enterprise application has two pages and we implement it with the popular </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">vue-router</span></strong><span class="koboSpan" id="kobo.277.1"> library, as we </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">have here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.279.1">
```
// routing.js
import Dashboard from './Dashboard.vue'
import Photo from './Photo.vue'
const routes = [
  { path: '/', component: Dashboard }
  { path: '/photo, component: Photo }
]
```</span></pre>
<p><span class="koboSpan" id="kobo.280.1">Due to the coding standard in Vue.js, all the components in our script will be downloaded when the user visits any page. </span><span class="koboSpan" id="kobo.280.2">This activity causes slow performance due to the number of pages, the complexity of each page, and the large </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">bundle size.</span></span></p>
<p><span class="koboSpan" id="kobo.282.1">To avoid this issue, we can implement a proper route code splitting that will separate our large bundle into different route bundles, meaning each page will have its small bundle to download when a user visits </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">that page.</span></span></p>
<p><span class="koboSpan" id="kobo.284.1">With the technique of</span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.285.1"> dynamic imports, rather than importing the components directly as demonstrated previously, we can pass the dynamic route and lazy-load the component, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.287.1">
```
// routing.js
const routes = [
  { path: '/', component: () =&gt; import('./Dashboard.vue') }
  { path: '/photo, component: () =&gt; import('./Photo.vue') }
]
```</span></pre>
<p><span class="koboSpan" id="kobo.288.1">By following this method, you can halve your bundle size. </span><span class="koboSpan" id="kobo.288.2">Also, it is important to be sure which components can be </span><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.289.1">u</span><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.290.1">sed with </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">dynamic imports.</span></span></p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.292.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.293.1">In this chapter, we dove deeper into scaling an extensive Vue application. </span><span class="koboSpan" id="kobo.293.2">We discussed how to scale performance with asynchronous lazy loading, image compression, code splitting, tree shaking, and many other tricks to better increase the performance of your Vue.js 3 </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">enterprise-ready application.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">We also covered in detail why performance optimization is needed and what your enterprise application can lose if performance is not deliberately built into the application. </span><span class="koboSpan" id="kobo.295.2">We also discussed the reasons for poor performance in an enterprise application and how to </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">fix them.</span></span></p>
<p><span class="koboSpan" id="kobo.297.1">Next, we discussed how to check our Vue.js application’s bundle size, demonstrating this with simple instructions on how to generate package reports using Webpack and commands. </span><span class="koboSpan" id="kobo.297.2">We also discussed how to understand the report and discover how to improve an application from the generated report to further boost our enterprise </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">application’s performance.</span></span></p>
<p><span class="koboSpan" id="kobo.299.1">In the next chapter, we will learn how to handle a sizable enterprise-ready project, from managing larger file structures to using a micro frontend architecture. </span><span class="koboSpan" id="kobo.299.2">You will also learn how to handle the internationalization and localization of your Vue.js </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">3 project.</span></span></p>
</div>
</body></html>