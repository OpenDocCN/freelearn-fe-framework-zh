- en: 9\. Working with Vuex – State, Getters, Actions, and Mutations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9. 使用Vuex – 状态、Getters、Actions和Mutations
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn how to use Vuex to build more complex Vue applications.
    You'll learn the specifics concerning how to add Vuex to a Vue application, how
    to define state with the Vuex store, and then use getters, actions, and mutations
    to read data from, and update it in, the store. By the end of the chapter, you
    will have seen multiple examples of how Vuex transforms your Vue applications,
    preparing them to grow much more complex in a much more manageable fashion.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用Vuex构建更复杂的Vue应用程序。你将了解如何将Vuex添加到Vue应用程序中，如何使用Vuex存储定义状态，然后使用getter、actions和mutations从存储中读取数据，并在存储中更新数据。到本章结束时，你将看到多个Vuex如何改变你的Vue应用程序的例子，使它们能够以更可管理的方式变得更加复杂。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'In the previous chapter, you learned how to use the Event Bus pattern to help
    solve an important problem: communicating events back and forth between complex
    and highly nested sets of components. The Event Bus pattern provided a simple
    **pub and sub** system by which any component could emit an event and any component
    could then listen to that event as well. While writing your own solution to this
    problem is a great way to keep your coding skills sharp, it would be better, in
    this case, to use an already developed, well-tested solution already in use in
    the Vue community—**Vuex** ([https://vuex.vuejs.org/](https://vuex.vuejs.org/)):'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何使用事件总线模式来帮助解决一个重要问题：在复杂且高度嵌套的组件集合之间双向通信事件。事件总线模式提供了一个简单的**发布/订阅**系统，任何组件都可以发出事件，任何组件也可以监听该事件。虽然自己编写解决方案是保持编码技能锐利的好方法，但在这种情况下，使用已经在Vue社区中开发、经过充分测试的解决方案会更好——**Vuex**
    ([https://vuex.vuejs.org/](https://vuex.vuejs.org/))：
- en: '![Figure 9.1: The Vuex home page'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1：Vuex首页'
- en: '](img/B15218_09_01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_09_01.jpg)'
- en: 'Figure 9.1: The Vuex home page'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：Vuex首页
- en: Vuex is a core part of the Vue ecosystem and provides what we already built
    in the previous chapter along with much more. Let's take a high-level look at
    the main features of Vuex.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex是Vue生态系统的一个核心部分，它提供了我们在上一章中构建的内容以及更多。让我们从高层次上了解一下Vuex的主要功能。
- en: Store
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储
- en: At a high level, a Vuex instance, or one use of Vuex, is considered a **store**.
    The store is the top-level container employing everything described in the following
    subsections.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，一个Vuex实例或Vuex的一次使用被认为是一个**存储**。存储是使用以下子节中描述的一切的最高级容器。
- en: State
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态
- en: The most important aspect of Vuex is the **state**, or data, that it represents.
    This is the *single source of truth* that all components can rely on. As the state
    changes, every component making use of the state can be assured its copy will
    always be in sync. Imagine a Vue application that lets you edit blog entries.
    The store could consist of the blog entries themselves as well as values for the
    current blog entry you're editing. As blog entries are edited in one place, any
    other place using them gets updated immediately.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex最重要的方面是它所代表的**状态**或数据。这是所有组件都可以依赖的*单一事实来源*。随着状态的变化，任何使用状态的组件都可以确保其副本始终与状态同步。想象一个允许你编辑博客条目的Vue应用程序。存储可以包括博客条目本身以及你正在编辑的当前博客条目的值。当在某个地方编辑博客条目时，任何使用它们的其他地方都会立即更新。
- en: Getters
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Getters
- en: While Vue can directly read state data from a Vuex instance, sometimes you may
    need to provide additional logic or an abstraction to the data itself. Much like
    how Vue provides a `computed` property for virtual or derived data, **getters**
    provide an abstraction to the state for cases where you need to manipulate the
    data before it is returned. Returning to our previous example of working with
    blog entries, imagine a getter that returns the top blog entries by views. The
    getter abstracts away the logic of how "popular" blog entries are and lets you
    easily change that logic in the future.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Vue可以直接从Vuex实例读取状态数据，但有时你可能需要为数据本身提供额外的逻辑或抽象。就像Vue为虚拟或派生数据提供`computed`属性一样，**getter**为需要在使用前操纵数据的情况提供了对状态的抽象。回到我们之前处理博客条目的例子，想象一个返回按浏览量最高的博客条目的getter。getter抽象掉了“热门”博客条目的逻辑，并允许你轻松地在将来更改该逻辑。
- en: Mutations
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变更
- en: Components making use of state data in Vuex never directly modify that data.
    Instead, a component can execute a **mutation**. Think of it as an order from
    the component for Vuex to perform a change to its state. By using mutations to
    wrap changes to state, Vuex can ensure every component making use of that state
    is kept up to date on changes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vuex 中使用状态数据的组件永远不会直接修改该数据。相反，组件可以执行一个**突变**。将其视为组件对 Vuex 执行状态更改的命令。通过使用突变来封装对状态的更改，Vuex
    可以确保使用该状态的每个组件都能及时了解更改。
- en: Actions
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为
- en: '**Actions** are like mutations, except that they must be used to handle asynchronous
    changes. Asynchronous actions are any logic that takes an indeterminate amount
    of time to finish. The most common example would be a network call to a remote
    API. Synchronous calls are those that execute and finish immediately. It will
    make more sense when you see them being used, but generally, anything asynchronous
    should be done via actions while synchronous logic can be done via mutations.
    Actions will typically chain to mutations once they have completed whatever asynchronous
    work they need to do.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**行为**类似于突变，但它们必须用于处理异步更改。异步行为是任何需要不确定时间才能完成的逻辑。最常见的例子是对远程 API 的网络调用。同步调用是那些立即执行并完成的调用。当你看到它们被使用时，这会更有意义，但一般来说，任何异步操作都应该通过行为完成，而同步逻辑可以通过突变完成。一旦完成了所需的异步工作，行为通常会链接到突变。'
- en: Modules
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: The last aspect of Vuex this chapter will cover is modules. **Modules** are
    simply a way to package more complex sets of data for larger applications. While
    one simple state may be fine for a typical application, a much larger application
    can have a much more complex state that needs better organization via modules.
    In *Chapter 11*, *Working with Vuex – Organizing Larger Stores*, you will see
    how modules can be used to better organize the Vuex instance.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将要涵盖 Vuex 的最后一个方面是模块。**模块**只是将更复杂的数据集打包起来，用于更大的应用程序。虽然一个简单的状态可能适合典型应用程序，但一个更大的应用程序可能有一个更复杂的状态，需要通过模块进行更好的组织。在*第
    11 章*，*与 Vuex 一起工作 – 组织更大的存储库*中，你将看到如何使用模块来更好地组织 Vuex 实例。
- en: Installing Vuex
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Vuex
- en: 'There are two main methods of using Vuex, depending on the type of Vue application
    you''re building. If you are not using the CLI to scaffold out an application
    and simply added Vue via a script tag, you can include Vuex the same way. Assuming
    you''ve downloaded both Vue and Vuex to a folder named `js`, you would load them
    both like so:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你正在构建的 Vue 应用程序类型，使用 Vuex 的主要有两种方法。如果你没有使用 CLI 搭建应用程序，只是通过脚本标签添加 Vue，你可以以相同的方式包含
    Vuex。假设你已经将 Vue 和 Vuex 下载到一个名为 `js` 的文件夹中，你会这样加载它们：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can also load both Vue and Vuex via **Content Delivery Networks** (**CDNs**):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过**内容分发网络**（**CDNs**）加载 Vue 和 Vuex：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is important that Vuex is loaded after Vue. Doing so makes Vuex available
    to your Vue code without any other configuration.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在 Vue 之后加载 Vuex 非常重要。这样做可以使 Vuex 对你的 Vue 代码可用，而无需任何其他配置。
- en: 'If you created an application using the CLI, remember first that the CLI itself
    will prompt you during creation if you want to add Vuex:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 CLI 创建了应用程序，请记住 CLI 本身将在创建过程中提示你是否要添加 Vuex：
- en: '![Figure 9.2: Selecting Vuex during application scaffolding'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.2：在应用程序搭建过程中选择 Vuex]'
- en: '](img/B15218_09_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_09_02.jpg]'
- en: 'Figure 9.2: Selecting Vuex during application scaffolding'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2：在应用程序搭建过程中选择 Vuex
- en: 'If you didn''t do this though, you can still add Vuex later using the CLI:
    `vue add vuex`. When Vuex is added (or selected during scaffolding), your Vue
    application is modified in the ways we''ll discuss now.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有这样做，你仍然可以使用 CLI 添加 Vuex：`vue add vuex`。当 Vuex 被添加（或在搭建过程中选择）时，你的 Vue 应用程序将以我们将要讨论的方式进行修改。
- en: 'First, a new folder, `store`, is added, containing one file, `index.js`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加一个新的文件夹 `store`，其中包含一个文件 `index.js`：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is an empty store with spots prepared for your state, mutations, actions,
    and modules. Note that there isn't a place for getters defined here, but you can
    absolutely add them. This is just the default layout for a new store, and you
    can modify it as you see fit.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个空的存储库，为你的状态、突变、行为和模块预留了位置。请注意，这里没有为定义的获取器预留空间，但你绝对可以添加它们。这只是一个新存储库的默认布局，你可以根据需要对其进行修改。
- en: 'Next, `main.js` is modified to load and install this store:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`main.js` 被修改为加载和安装此存储库：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Again, this is how the CLI scaffolds using Vuex, and if you prefer to use another
    method (perhaps a different folder name than `store`), you are free to do so.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是CLI使用Vuex的方式，如果你更喜欢使用另一种方法（可能是一个不同于`store`的文件夹名），你完全自由这样做。
- en: Working with State
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理状态
- en: 'At the lowest level in a Vuex store, you will find the actual data (the state)
    that Vuex manages. All components have access to the state via a special `$store`
    variable. While there''s more within this variable, to read the state, you can
    use `$store.state.someStateValue`. So, for example: `Hello, my name is {{ $store.state.name
    }}` would output the name value from your Vuex store in a component. For simple
    operations reading from the store, that''s all you need.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vuex store的最低级别，你会找到Vuex实际管理的数据（状态）。所有组件都可以通过特殊的`$store`变量访问状态。虽然这个变量中还有更多内容，但要读取状态，你可以使用`$store.state.someStateValue`。所以，例如：`Hello,
    my name is {{ $store.state.name }}`会在组件中输出Vuex store中的名称值。对于简单的从store读取操作，这就足够了。
- en: We will now learn how to display state values in the following exercise.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下练习中学习如何显示状态值。
- en: 'Exercise 9.01: Displaying State Values'
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.01：显示状态值
- en: In this exercise, you will create an empty Vue application using Vuex. The previous
    section described how that was done via the CLI, and if you followed along, you've
    got one ready to go. If not, go ahead and create one now, ensuring you enable
    Vuex. In this exercise, we'll simply set a few values in the state and display
    them in a component.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个空的Vue应用程序并使用Vuex。前面的部分描述了如何通过CLI完成此操作，如果你跟随着做，你现在应该有一个准备好了。如果没有，请现在创建一个，确保你启用了Vuex。在这个练习中，我们将在状态中设置一些值并在组件中显示它们。
- en: To access the code files for this exercise, refer to [https://packt.live/32s4RkN](https://packt.live/32s4RkN).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://packt.live/32s4RkN](https://packt.live/32s4RkN)。
- en: 'Once you''ve scaffolded the application, open `store/index.js` and modify the
    `state` block to add three new values. The data here is arbitrary and can be anything
    that JavaScript can handle (strings, numbers, arrays, and so on):'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你搭建了应用程序，打开`store/index.js`并修改`state`块以添加三个新值。这里的数据是任意的，可以是JavaScript可以处理的所有内容（字符串、数字、数组等等）：
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we need to modify the component to display the values from the state. Open
    up `App.vue` and modify it like so:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要修改组件以显示来自状态的价值。打开`App.vue`并按如下方式修改它：
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, edit the `HelloWorld.vue` component to also display a value from the state:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，编辑`HelloWorld.vue`组件以显示来自状态的一个值：
- en: '[PRE6]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To see your application, type `npm run serve` in your terminal. When the CLI
    is done, you can then open the URL displayed in your browser to see your application,
    which should appear as follows:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要查看你的应用程序，请在终端中输入`npm run serve`。当CLI完成时，你可以在浏览器中打开显示的URL来查看你的应用程序，它应该如下所示：
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, both the main component and the child component have access
    to the state and see the same values. This shouldn't be a surprise, but it's always
    nice to confirm that things are working as expected.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，主组件和子组件都可以访问状态并看到相同的值。这不应该令人惊讶，但总是很好确认事情按预期工作。
- en: 'While directly accessing state values makes things easy, let''s look at a more
    complex usage: derived values with getters.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 直接访问状态值虽然简单，但让我们看看更复杂的用法：使用getter获取派生值。
- en: Applying Getters
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用getter
- en: In the previous exercise, you saw how simple it was to directly access state,
    but there are times when you may need more complex views of your state. To make
    this easier, Vuex supports a feature called **getters**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，你看到了直接访问状态是多么简单，但有时你可能需要更复杂的对状态视图。为了使这更容易，Vuex支持一个名为**getter**的功能。
- en: 'Getters have their own block within the store, and you can define as many as
    necessary. Each getter is passed the state as an argument, which lets you use
    whatever you need to create your value. Finally, the name of the getter is how
    it will be exposed. Consider this simple example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Getter在store中拥有自己的块，你可以定义尽可能多的getter。每个getter都会将状态作为参数传递，这让你可以使用任何你需要来创建你的值。最后，getter的名称就是它将被暴露的方式。考虑这个简单的例子：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This store defines three state values (`name`, `gender`, and `job`), and also
    provides a "virtual" property named `bio` that returns a description of the data.
    Note that the getter only uses two of the state values, and that's totally fine.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此store定义了三个状态值（`name`、`gender`和`job`），还提供了一个名为`bio`的“虚拟”属性，它返回数据的描述。请注意，getter只使用了两个状态值，这是完全可以的。
- en: 'To reference the getter in your component, you use `$store.getters.name`, where
    `name` is the name of the getter. So, to access the bio getter defined in the
    preceding code, you would use the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要在组件中引用获取器，你使用 `$store.getters.name`，其中 `name` 是获取器的名称。因此，要访问前面代码中定义的 bio 获取器，你会使用以下：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Along with being passed the state, getters are passed *other* getters as their
    second argument, which allows one getter to call another getter, if necessary.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 除了传递状态外，获取器还通过其第二个参数传递 *其他* 获取器，这允许一个获取器在必要时调用另一个获取器。
- en: In the next exercise, we will see an example of putting this to use.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将看到一个如何使用它的示例。
- en: 'Exercise 9.02: Adding Getters to a Vuex Store'
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.02：向 Vuex 存储添加获取器
- en: In this exercise, you will build an example that makes use of the Getters feature.
    You will add Getters to a Vuex store and add a call to it from the main Vue application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将构建一个利用获取器功能的示例。你将为 Vuex 存储添加获取器，并从主 Vue 应用程序中调用它。
- en: To access the code files for this exercise, refer to [https://packt.live/36ixlyf](https://packt.live/36ixlyf).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅 [https://packt.live/36ixlyf](https://packt.live/36ixlyf)。
- en: Scaffold a new application, remembering to use Vuex in the settings (and if
    you forget, just use `vue add vuex`). Type `npm run serve` to start the application
    and open the URL in your browser.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搭建一个新的应用程序，记得在设置中使用 Vuex（如果你忘记了，只需使用 `vue add vuex`）。输入 `npm run serve` 以启动应用程序并在浏览器中打开
    URL。
- en: 'Open your store file (`store/index.js`) and then modify it to define two state
    values and a getter that will return both:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的存储文件（`store/index.js`），然后修改它以定义两个状态值和一个获取器，该获取器将返回两者：
- en: '[PRE10]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now open `App.vue` and modify it such that you make use of the `name` getter:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开 `App.vue` 并修改它，以便使用 `name` 获取器：
- en: '[PRE11]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see in the following screenshot, this will show the complete name
    based on the logic used in the getter:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如以下截图所示，这将显示基于获取器中使用的逻辑的完整名称：
- en: '[PRE12]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: While rather simple, hopefully, you can see the power of what Getters achieves
    here. Right now, we have a concept of a name that consists of a first and last
    name. That isn't terribly complex logic, but by placing it within the Vuex store,
    we defined it as one place that's available to all components within our application.
    If this name definition changed (perhaps with the last name listed first, separated
    by a comma), you could modify it once and be done.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然相当简单，但希望你能看到获取器在这里实现的力量。目前，我们有一个由姓氏和名字组成的名称概念。这不是非常复杂的逻辑，但通过将其放置在 Vuex 存储中，我们将其定义为我们应用程序中所有组件都可以访问的一个位置。如果这个名称定义发生了变化（例如，姓氏在前，用逗号分隔），你只需修改一次即可完成。
- en: Next, we'll consider how to enhance Getters with additional logic.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将考虑如何通过附加逻辑增强获取器。
- en: Getters with Parameters
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带参数的获取器
- en: 'While Getters can be accessed directly via `$store.getters` properties, you
    may run into situations where you need a bit more control over how the getter
    works. Parameters provide a way to customize how Getters works. Consider the following store:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然获取器可以通过 `$store.getters` 属性直接访问，但你可能会遇到需要更多控制获取器工作方式的情况。参数提供了一种自定义获取器工作方式的方法。考虑以下存储：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There's only one state value in this store, and it's an array of books. Each
    book has a type (nonfiction or fiction), title, and page count. To make it easy
    to get one book versus another, two getters are used. They filter by either fiction
    or nonfiction books.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在此存储中只有一个状态值，它是一个书籍数组。每本书都有一个类型（非小说或小说）、标题和页数。为了便于获取一本书而不是另一本书，使用了两个获取器。它们通过小说或非小说书籍进行筛选。
- en: 'Here''s how you could use this in a component. First, we iterate over the `fiction`
    getter and then the `nonfiction` one:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在组件中使用它的方法。首先，我们遍历 `fiction` 获取器，然后是 `nonfiction` 获取器：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding template, two unordered lists are used to iterate over each
    type of book. The result can be seen as shown here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模板中，使用了两个无序列表来遍历每种类型的书籍。结果如下所示：
- en: '![Figure 9.3: Rendering fiction and non-fiction books via getters'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.3：通过获取器渲染小说和非小说书籍'
- en: '](img/B15218_09_03.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_09_03.jpg)'
- en: 'Figure 9.3: Rendering fiction and non-fiction books via getters'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3：通过获取器渲染小说和非小说书籍
- en: Okay, so far so good. But what if you want to get books based on their page
    count? That isn't a simple boolean or string property, but rather a number. But,
    because getters can accept parameters, we can create a new getter that lets us
    ask for a maximum number of pages. (We could support more than one parameter,
    so, if you wanted a getter that asked for books within a range of values, you
    could support both a min and max number of pages.) In order to create a getter
    that accepts a parameter, your code itself must return a function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，到目前为止一切顺利。但如果你想要根据页数获取书籍呢？这并不是一个简单的布尔值或字符串属性，而是一个数字。但是，因为获取器可以接受参数，我们可以创建一个新的获取器，允许我们请求最大页数。（我们可以支持多个参数，所以，如果你想要一个获取器来请求在一定范围内的书籍，你可以支持最小和最大页数。）为了创建一个接受参数的获取器，您的代码本身必须返回一个函数。
- en: 'Here''s an example where we define a getter that returns a portion of the full
    name:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，我们定义了一个返回全名一部分的获取器：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The resulting getter can then be used with the `length` parameter: `{{ $store.getters.shortName(10)
    }}`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的获取器可以使用 `length` 参数：`{{ $store.getters.shortName(10) }}`。
- en: In the next exercise, you'll build an application that makes use of the Getter
    with the parameters feature.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，您将构建一个利用带有参数的获取器功能的应用程序。
- en: 'Exercise 9.03: Employing a Getter with Parameters'
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.03：使用带参数的获取器
- en: You will test out this feature in the following exercise. By adding parameters
    to a getter, you'll be able to build more flexible getters that are more useful
    across different components. In this exercise, you will create a getter that takes
    one parameter.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在下面的练习中测试这个功能。通过向获取器添加参数，您将能够构建更灵活的获取器，这些获取器在不同组件中更有用。在这个练习中，您将创建一个接受一个参数的获取器。
- en: To access the code files for this exercise, refer to [https://packt.live/2Ioi2vy](https://packt.live/2Ioi2vy).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅 [https://packt.live/2Ioi2vy](https://packt.live/2Ioi2vy)。
- en: 'Scaffold yet another application using Vuex and, once open, edit the store
    to include a set of books and getters for fiction, non-fiction, and page size.
    This is found in the store directory in `index.js`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Vuex 再次搭建一个应用程序，一旦打开，编辑 store 以包括一组书籍和用于虚构、非虚构和页码的获取器。这可以在 `store` 目录中的 `index.js`
    找到：
- en: '[PRE16]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now edit `App.vue` to use all three getters – first the fiction and nonfiction
    getters, and then books that have `150` or fewer pages:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编辑 `App.vue` 以使用所有三个获取器——首先是虚构和非虚构获取器，然后是页数不超过 `150` 的书籍：
- en: '[PRE17]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once done, you can see the result by starting your Vue application (type `npm
    run serve` in your terminal) and opening the URL in your browser. Here is what
    you should see:'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成后，您可以通过启动您的 Vue 应用程序（在终端中输入 `npm run serve`）并在浏览器中打开 URL 来查看结果。以下是您应该看到的内容：
- en: '![Figure 9.4: The parameterized getter in action'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.4：参数化获取器的作用'
- en: '](img/B15218_09_04.jpg)'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15218_09_04.jpg]'
- en: 'Figure 9.4: The parameterized getter in action'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4：参数化获取器的作用
- en: In this exercise, we learned how to use more powerful getters that use parameters.
    This makes them flexible and more adaptable to what your components may need.
    Now that you've seen multiple ways of reading data from a Vuex store, it's time
    to look at how to modify state.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何使用更强大的带有参数的获取器。这使得它们更加灵活，更能适应组件可能的需求。现在您已经看到了从 Vuex store 中读取数据的多种方式，是时候看看如何修改状态了。
- en: Modifying State with Mutations
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用突变修改状态
- en: So far, you've seen how to read data from a Vuex store, both with direct access
    to state and by using getters. But to actually change the state of a store, Vuex
    supports the idea of mutations. Mutations are methods you define in your store
    that handle changing state. So, for example, instead of your component simply
    setting a new value in the state, your component will ask the store to perform
    a mutation, and the store handles that logic itself.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到了如何从 Vuex store 中读取数据，无论是通过直接访问状态还是通过使用获取器。但为了实际改变 store 的状态，Vuex
    支持突变的概念。突变是在您的 store 中定义的方法，用于处理状态的变化。例如，而不是您的组件简单地设置状态中的新值，您的组件将要求 store 执行突变，而
    store 本身处理那个逻辑。
- en: 'Here''s a simple example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding snippet, the store has two values in its state, `totalCats`
    and `name`. Two mutations exist to allow you to change these values. All mutations
    are passed a state object that gives you direct access to read and change values.
    The first mutation, `newCat`, simply increments the `totalCats` value. The second
    mutation, `setName`, shows an example of a mutation that takes an argument. In
    this case, you could use `setName` to change the name value in the store.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，存储在其状态中有两个值，`totalCats` 和 `name`。存在两个突变以允许你更改这些值。所有突变都传递一个状态对象，它为你提供直接访问以读取和更改值。第一个突变
    `newCat` 简单地增加 `totalCats` 的值。第二个突变 `setName` 展示了一个接受参数的突变示例。在这种情况下，你可以使用 `setName`
    来更改存储中的名称值。
- en: 'In order to execute a mutation, your components will use the `commit` method.
    See the following, for example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行一个突变，你的组件将使用 `commit` 方法。例如，如下所示：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can also pass multiple values if you pass them as an object instead of a
    simple value. In the next exercise, you'll get a chance to practice building your
    own mutations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将它们作为对象而不是简单值传递，你也可以传递多个值。在下一个练习中，你将有机会练习构建你自己的突变。
- en: 'Exercise 9.04: Working with Mutations'
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.04：使用突变
- en: In this exercise, you will build an application that uses mutations to modify
    state data in Vuex. Scaffold a new application and, once ready, open up the store
    file located in `store/index.js`. Your store is going to be somewhat based on
    the preceding examples.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将构建一个使用突变来修改Vuex中状态数据的应用程序。搭建一个新的应用程序，一旦准备就绪，打开位于 `store/index.js` 的存储文件。你的存储将基于前面的示例。
- en: To access the code files for this exercise, refer to [https://packt.live/3kcARiN](https://packt.live/3kcARiN).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅 [https://packt.live/3kcARiN](https://packt.live/3kcARiN)。
- en: 'Define a `totalCats` state variable and name state value, then three mutations
    to work with them – one mutation to increase the number of cats, one to reduce
    it, and one final one to set the name:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 `totalCats` 状态变量和名称状态值，然后定义三个突变来处理它们——一个突变用于增加猫的数量，一个用于减少它，最后一个用于设置名称：
- en: '[PRE20]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Next, you will build a simple interface to work with this store. The template
    needs to have a UI to report on the name and the number of cats. You also need
    a text field and button to handle updating the name.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，你将构建一个简单的界面来与这个存储进行交互。模板需要有一个UI来报告名称和猫的数量。你还需要一个文本字段和按钮来处理名称的更新。
- en: 'Open `App.vue` and update it to include outputting the current values from
    the store as well as providing a simple form to allow updates:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `App.vue` 并更新它以包含输出存储中的当前值以及提供一个简单的表单以允许更新：
- en: '[PRE21]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Build the `Cat` component. This component will have simple buttons to execute
    the mutations we defined to both increase and decrease the number of cats:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建 `Cat` 组件。此组件将具有简单的按钮来执行我们定义的突变，以增加和减少猫的数量：
- en: '[PRE22]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once done, start up your application as you have before with `npm run serve`
    and open the displayed URL in your browser. Your application should look like so:'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成后，像以前一样使用 `npm run serve` 启动你的应用程序，并在浏览器中打开显示的URL。你的应用程序应该看起来是这样的：
- en: '![Figure 9.5: Vue application with mutation support'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.5：具有突变支持的Vue应用程序]'
- en: '](img/B15218_09_05.jpg)'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_09_05.jpg)'
- en: 'Figure 9.5: Vue application with mutation support'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.5：具有突变支持的Vue应用程序]'
- en: While this was a trivial exercise, there are a few important things to note.
    First, notice how both the root and child components have no problems interacting
    with the store. Your component hierarchy can be incredibly deep, and it simply
    just works. Secondly, notice how the Vue application is simpler because the logic
    of working with the data is in the store. The two components we worked with simply
    display data and handle passing off mutation calls to the store. If our logic
    ever needs to update, we can handle it in the store, and everything will be updated
    properly.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个简单的练习，但有一些重要的事情需要注意。首先，注意根组件和子组件与存储交互时没有问题。你的组件层次结构可以非常深，而且它只是简单地工作。其次，注意Vue应用程序更简单，因为与数据交互的逻辑在存储中。我们处理的两个组件只是显示数据并处理将突变调用传递给存储。如果我们的逻辑需要更新，我们可以在存储中处理，并且一切都会正确更新。
- en: So far, you've seen how to implement changes to your store in an immediate,
    synchronous way. You'll now learn how to handle asynchronous updates.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了如何以立即、同步的方式实现对存储的更改。现在，你将学习如何处理异步更新。
- en: Using Actions for Asynchronous State Changes
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动作进行异步状态更改
- en: Actions in Vuex are the primary way of handling asynchronous logic for your
    store. Mutations have to be synchronous, but actions can be asynchronous if they
    choose. The other difference is that actions get a `context` object that represents
    the store itself. This lets actions call mutations or work with the state directly.
    In general, most developers will call mutations from their actions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex中的操作是处理存储异步逻辑的主要方式。突变必须是同步的，但操作可以选择异步。另一个区别是，操作会得到一个`context`对象，它代表存储本身。这使得操作可以调用突变或直接与状态交互。一般来说，大多数开发者会从他们的操作中调用突变。
- en: This probably seems a bit confusing, but in general, think of actions as your
    asynchronous support for your store. It will make sense once we see an example
    or two.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来有些令人困惑，但一般来说，将操作视为您存储的异步支持。一旦我们看到一个或两个示例，它就会变得有意义。
- en: 'Let''s look at a sample action. The following snippet contains one mutation
    and an asynchronous action that will make use of the mutation:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例操作。以下代码片段包含一个突变和一个将使用该突变的异步操作：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Looking at `loadBooks`, you can see it makes a network request, and when done,
    it makes a call to the preceding mutation and lets it store the result data.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`loadBooks`，您可以看到它执行网络请求，完成后，它调用前面的突变并允许它存储结果数据。
- en: 'Calling an action is slightly different than mutations; instead of a `commit`
    call, you use `dispatch`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 调用一个操作与突变略有不同；而不是使用`commit`调用，您使用`dispatch`：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Like mutations, actions can take arguments that get passed to the action method
    as the second argument. Next, you'll build an example of this in action.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与突变一样，操作可以接受参数，这些参数作为第二个参数传递给操作方法。接下来，您将构建一个示例来展示这一点。
- en: 'Exercise 9.05: Using Actions for Asynchronous Logic'
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.05：使用操作进行异步逻辑
- en: In this exercise, you will build an example of an action requiring asynchronous
    logic in order to complete. This closely resembles many real-world scenarios where
    the data required for the application is found on a remote API. You'll implement
    the network call and work with the results in your Vuex store.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将构建一个需要异步逻辑才能完成的操作示例。这类似于许多现实世界场景，其中应用程序所需的数据位于远程API上。您将在Vuex存储中实现网络调用并处理结果。
- en: For this example, you will set up a JSON resource available in your `public`
    folder under a subdirectory named `data`. When Vue builds your code, it will copy
    anything in the `public` folder to the application, making it available at runtime.
    The JSON file contains an array of four books. Each book has a type, title, and
    number of pages.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您将在`public`文件夹下的一个名为`data`的子目录中设置一个可用的JSON资源。当Vue构建您的代码时，它将复制`public`文件夹中的任何内容到应用程序中，使其在运行时可用。该JSON文件包含一个包含四本书的数组。每本书都有一个类型、标题和页数。
- en: To access the code files for this exercise, refer to [https://packt.live/3eE6KQd](https://packt.live/3eE6KQd).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://packt.live/3eE6KQd](https://packt.live/3eE6KQd)。
- en: 'While not necessary, this is how the JSON data looks. Feel free to build your
    own:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然不是必需的，但这是JSON数据的样子。您可以自由地构建自己的：
- en: '[PRE25]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In a new store (located in the usual place at `store/index.js`), set up an
    empty array for books, and then define an action that will use the Fetch API to
    retrieve the JSON content. (You''ll see more examples of using APIs in *Chapter
    10*, *Working with Vuex - Fetching Remote Data*, as well as a more powerful way
    of doing HTTP, in the form of the `Axios` library.) When the data is retrieved,
    it should then call a mutation to store the result:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的存储（位于`store/index.js`的常规位置），为书籍设置一个空数组，然后定义一个操作，该操作将使用Fetch API检索JSON内容。（您将在*第10章*，*使用Vuex
    - 获取远程数据*中看到更多使用API的示例，以及一种更强大的HTTP操作方式，即`Axios`库。）当数据被检索后，它应该调用一个突变来存储结果：
- en: '[PRE26]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In order to call this action, add a `dispatch` call in your component to run
    the actions and then add code to display the books:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了调用此操作，请在您的组件中添加一个`dispatch`调用以运行操作，然后添加代码来显示书籍：
- en: '[PRE27]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In *Figure 9.6*, you can see the result of the asynchronous action requesting
    its data:'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在*图9.6*中，您可以查看异步操作请求其数据的**结果**：
- en: '![Figure 9.6: An example of data loaded asynchronously'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.6：异步加载数据的示例'
- en: '](img/B15218_09_06.jpg)'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_09_06.jpg)'
- en: 'Figure 9.6: An example of data loaded asynchronously'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6：异步加载数据的示例
- en: Now you've seen an example of working with asynchronous operations in your Vuex
    store. Note that you can use actions even if your code is synchronous. This may
    be a good idea in general if you aren't sure whether your data is going to be
    asynchronous in the future. Now let's look at a nice way to simplify some boilerplate
    Vuex syntax.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经看到了在 Vuex 存储中处理异步操作的一个例子。请注意，即使你的代码是同步的，你也可以使用操作。如果你不确定数据将来是否将是异步的，这通常是一个好主意。现在让我们看看简化一些
    Vuex 语法模板的一个好方法。
- en: Simplifying with mapState and mapGetters
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 mapState 和 mapGetters 简化
- en: As one of the last features we'll cover with Vuex, let's look at `mapState`
    and `mapGetters`. These are handy utilities that help map state values and getters
    into your component's computed property. As a practical matter, it makes your
    HTML templates simpler. So instead of `{{ $store.state.firstName }}`, you can
    simply use `{{ firstName }}`. Instead of using `{{ $store.getters.name }}`, you
    can just use `{{ name }}`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们将要使用 Vuex 覆盖的最后一个功能之一，让我们看看 `mapState` 和 `mapGetters`。这些实用的工具帮助将状态值和获取器映射到组件的计算属性中。作为一个实际问题，它使你的
    HTML 模板更简单。所以，你不必使用 `{{ $store.state.firstName }}`，你可以简单地使用 `{{ firstName }}`。不必使用
    `{{ $store.getters.name }}`，你只需使用 `{{ name }}`。
- en: Both `mapState` and `mapGetters` can either take an array of values to map or
    an object where each key represents the name you wish to use in your component
    and the value is the `state value` or `getter` in the Vuex store. They are both
    used with your Vue application's `computed` block.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapState` 和 `mapGetters` 都可以接受一个要映射的值数组，或者是一个对象，其中每个键代表你希望在组件中使用的名称，值是 Vuex
    存储中的 `state value` 或 `getter`。它们都与你的 Vue 应用程序的 `computed` 块一起使用。'
- en: 'In this first example, two state values and three getters are mapped by their
    name alone:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个例子中，两个状态值和三个获取器仅通过它们的名称进行映射：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'But if those names were perhaps too generic, or perhaps conflicted with existing
    data, you could specify other names for them:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果这些名称可能过于通用，或者可能与现有数据冲突，你可以为它们指定其他名称：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In order to use both `mapState` and `mapGetters`, you will need to import them first:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 `mapState` 和 `mapGetters`，你首先需要导入它们：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Usage of both these features will definitely help reduce the amount of code
    you write to work with Vuex.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个功能肯定有助于减少你编写与 Vuex 一起工作的代码量。
- en: You will learn how to add `mapState` and `mapGetters` with the help of the following
    exercise.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过以下练习了解如何添加 `mapState` 和 `mapGetters`。
- en: 'Exercise 9.06: Adding mapState and mapGetters'
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.06：添加 mapState 和 mapGetters
- en: Let's look at a simple example of this. In *Exercise 9.02*, we used getters
    to create a shortcut for getting a name value. We can simplify that code by applying
    what we just learned. We can use the map functions to simplify our code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的例子。在 *Exercise 9.02* 中，我们使用获取器创建了一个获取名称值的快捷方式。我们可以通过应用我们刚刚学到的知识来简化这段代码。我们可以使用映射函数来简化我们的代码。
- en: To access the code files for this exercise, refer to [https://packt.live/3ldBxpb](https://packt.live/3ldBxpb).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅 [https://packt.live/3ldBxpb](https://packt.live/3ldBxpb)。
- en: 'Create a new Vue application with Vuex and then copy over the store (located
    at `store/index.js`) into this new version. You will need state values for the
    first and last name, and a getter that returns the complete name:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Vue 应用程序并使用 Vuex，然后将存储（位于 `store/index.js`）复制到这个新版本中。你需要姓名和姓氏的状态值，以及一个返回完整姓名的获取器：
- en: '[PRE31]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Edit the main component. You will want to edit all three values from the store
    (both the state values and the getter), but make use of `mapState` and `mapGetters`
    to simplify it:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑主组件。你将想要编辑存储中的所有三个值（状态值和获取器），但可以使用 `mapState` 和 `mapGetters` 来简化它：
- en: '[PRE32]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you can see, by using `mapState` and `mapGetters`, we''ve provided a way
    for the template portion of the app to make use of the data somewhat simpler:'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，通过使用 `mapState` 和 `mapGetters`，我们为应用的模板部分提供了一种使数据稍微简单一些的方法：
- en: '[PRE33]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When done, you should see exactly the same output as you've seen before. The
    important part is that the amount of code you needed to write was reduced!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你应该看到与之前完全相同的输出。重要的是，你需要编写的代码量减少了！
- en: In the next section, we'll briefly talk about `mapMutations` and `mapActions`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将简要介绍 `mapMutations` 和 `mapActions`。
- en: Simplifying with mapMutations and mapActions
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 mapMutations 和 mapActions 简化
- en: 'The final features we''ll cover are very similar to the previous one: `mapMutations`
    and `mapActions`. As you can probably guess, these two features work very similarly
    to `mapState` and `mapGetters`, in that they provide a shorthand way to connect
    your code to Vuex mutations and actions without writing boilerplate code.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的最终功能与上一个功能非常相似：`mapMutations` 和 `mapActions`。正如你可能猜到的，这两个功能与 `mapState`
    和 `mapGetters` 的工作方式非常相似，即它们提供了一种简写方式，可以将您的代码连接到 Vuex 的 mutations 和 actions，而无需编写样板代码。
- en: 'They follow the exact same format in that you can specify a list of items to
    map or specify a list while also providing a different name, as in the following
    example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 它们遵循相同的格式，您可以在其中指定一个要映射的项目列表，或者指定一个列表同时提供不同的名称，如下面的示例所示：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'These can be used in your Vue component''s `methods` block:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以在您的 Vue 组件的 `methods` 块中使用：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This then allows your Vue code to call either `setBooks` or `loadBooks` without
    specifying the `store` object, or `dispatch` and `commit`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这然后允许您的 Vue 代码调用 `setBooks` 或 `loadBooks` 而无需指定 `store` 对象，或 `dispatch` 和 `commit`。
- en: Now, let's try to create a simple shopping cart and a price calculator on our
    own.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试自己创建一个简单的购物车和价格计算器。
- en: 'Activity 9.01: Creating a Simple Shopping Cart and Price Calculator'
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 9.01：创建简单的购物车和价格计算器
- en: Imagine a hypothetical corporate hardware site that lets employees select products
    they need shipping to their office. This cart is much simpler than a typical e-commerce
    site as it doesn't need to process credit cards or even ask the person where they
    are (IT knows where you sit!). It still needs to present you with a list of items,
    let you select how much you want, and then provide you with a total price that
    will be billed to your department.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个假设的硬件公司网站，允许员工选择他们需要运送到办公室的产品。这个购物车比典型的电子商务网站简单得多，因为它不需要处理信用卡，甚至不需要询问他们在哪里（IT
    知道你在哪里坐！）它仍然需要向您展示一个项目列表，让您选择您想要的数量，并提供一个将向您的部门收取的总价。
- en: In this activity, you need to build a Vuex store that represents the available
    products and their prices. You will need multiple components to handle the different
    aspects of the application and properly interact with the store data.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您需要构建一个 Vuex 存储库来表示可用的产品和它们的价格。您将需要多个组件来处理应用程序的不同方面，并正确地与存储数据交互。
- en: '**Steps:**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤：**'
- en: Build a store and define an array of products and a cart in the state. Every
    product will have `name` and `price` properties.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在状态中构建一个存储库并定义一个产品数组和购物车。每个产品都将有 `name` 和 `price` 属性。
- en: Define a component that lists out each product and price.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个组件来列出每个产品和价格。
- en: Modify the component to have buttons to add, or remove, one of the products
    from your cart.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改组件以添加或删除购物车中的一个产品按钮。
- en: Define a second component that shows the current cart (every product and quantity).
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义第二个组件以显示当前购物车（每个产品和数量）。
- en: Use a third component that displays the total cart price and has a button to
    complete the checkout. The total price is the sum of each product in the cart
    multiplied by the quantity of the product. For this activity, the `checkout` button
    should simply alert the user that the checkout process is done but take no other steps.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用第三个组件来显示购物车总价，并有一个按钮来完成结账。总价是购物车中每个产品的数量乘以产品数量的总和。对于这个活动，`结账` 按钮应该简单地提醒用户结账过程已完成，但不要采取其他步骤。
- en: 'You should get the following output initially, showing an empty cart:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您最初应该得到以下输出，显示一个空购物车：
- en: '![Figure 9.7: Initial display of the cart'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.7：购物车的初始显示]'
- en: '](img/B15218_09_07.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_09_07.jpg]'
- en: 'Figure 9.7: Initial display of the cart'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.7：购物车的初始显示]'
- en: 'As you add and remove items, you''ll see the cart and totals update in real
    time:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当您添加和删除项目时，您将看到购物车和总计实时更新：
- en: '![Figure 9.8: The cart with items of multiple quantities added'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.8：添加了多个数量项目的购物车]'
- en: '](img/B15218_09_08.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_09_08.jpg]'
- en: 'Figure 9.8: The cart with items of multiple quantities added'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.8：添加了多个数量项目的购物车]'
- en: As you can see, as products are added, the cart display updates to show quantity
    values and the total in the `Checkout` section accurately reflects the total price.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当产品被添加时，购物车显示会更新以显示数量值，而 `结账` 部分的总计会准确反映总价。
- en: Note
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor399).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以通过[这个链接](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor399)找到。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have seen most of Vuex's features and should now have an
    idea of how to both read from and write to the store. You employed mutations for
    synchronous changes and actions for asynchronous modifications. You created getters
    to provide access to virtual values based on your state. You have also seen how
    components look when working with the store. They've got less logic and simply
    hand off that part to the store. In larger Vue applications, this will become
    even more important. Your components will handle the UI and UX, but let the store
    handle the data layer. Having the store as a single source of truth, then, relieves
    you of so much "grunt" work that you will come to greatly appreciate Vuex, even
    in smaller applications.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经看到了 Vuex 的大多数功能，现在应该对如何从存储中读取和写入有一个概念。你使用了突变（mutations）来进行同步更改，并使用了动作（actions）来进行异步修改。你创建了获取器（getters）来提供基于你状态的虚拟值的访问。你也看到了组件在处理存储时的样子。它们拥有更少的逻辑，并且简单地将这部分工作交给存储。在更大的
    Vue 应用程序中，这一点将变得更加重要。你的组件将处理 UI 和 UX，但让存储处理数据层。因此，拥有作为单一事实来源的存储，将大大减轻你的许多“苦力”工作，你将非常感激
    Vuex，即使在较小的应用程序中也是如此。
- en: In the next chapter, you will learn about using remote data with Vuex stores.
    Working with remote APIs is a common need in modern web applications. Integrating
    these APIs in Vuex will make it easier for the rest of your Vue application to
    use the data provided by remote services.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何使用 Vuex 存储与远程数据。在现代网络应用中，与远程 API 一起工作是一个常见的需求。将这些 API 集成到 Vuex 中将使你的
    Vue 应用程序的其他部分更容易使用远程服务提供的数据。
