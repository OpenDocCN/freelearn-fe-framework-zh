- en: Enhancing Our Components with Pipes and Directives
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过管道和指令增强我们的组件
- en: In the previous chapters, we built several components that rendered data on
    screen with the help of input and output properties. We will leverage the knowledge
    in this chapter to take our components to the next level with the use of directives
    and pipes. In a nutshell, while pipes give us the opportunity to digest and transform
    the information we bind in our templates, directives allow us to conduct more
    ambitious functionalities where we can access the host element properties and
    also bind our very own custom event listeners and data bindings.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们构建了几个组件，借助输入和输出属性在屏幕上呈现数据。我们将利用本章的知识，通过使用指令和管道，将我们的组件提升到一个新的水平。简而言之，管道为我们提供了在模板中绑定的信息进行解析和转换的机会，而指令允许我们进行更有野心的功能，我们可以访问宿主元素的属性，并绑定我们自己的自定义事件监听器和数据绑定。
- en: 'In this chapter, we will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Have a comprehensive overview of the built-in directives of Angular
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全面了解Angular的内置指令
- en: Discover how we can refine our data output with pipes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探讨如何使用管道来优化我们的数据输出
- en: See how we can design and build our own custom pipes and directives
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看如何设计和构建我们自己的自定义管道和指令
- en: Leverage built-in objects for manipulating our templates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用内置对象来操作我们的模板
- en: Put all the preceding topics and many more into practice to build a fully interactive
    to-do items table
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有前述主题和更多内容付诸实践，以构建一个完全交互式的待办事项表
- en: Directives in Angular
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular中的指令
- en: Angular defines directives as components without views. In fact, a component
    is a directive with an associated template view. This distinction is used because
    directives are a prominent part of the Angular core and each (plain directives
    and component directives) needs the other to exist. Directives can basically affect
    the way HTML elements or custom elements behave and display their content.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Angular将指令定义为没有视图的组件。事实上，组件是具有关联模板视图的指令。之所以使用这种区别，是因为指令是Angular核心的一个重要部分，每个指令（普通指令和组件指令）都需要另一个存在。指令基本上可以影响HTML元素或自定义元素的行为和显示其内容。
- en: Core directives
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心指令
- en: Let's take a closer look at the framework's core directives, and then you will
    learn how to build your own directives later on in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细研究一下框架的核心指令，然后您将在本章后面学习如何构建自己的指令。
- en: NgIf
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NgIf
- en: 'As the official documentation states, the `ngIf` directive removes or recreates
    a portion of the DOM tree based on an expression. If the expression assigned to
    the `ngIf` directive evaluates to `false`, then the element is removed from the
    DOM. Otherwise, a clone of the element is reinserted into the DOM. We could enhance
    our countdown timer by leveraging this directive, like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如官方文档所述，`ngIf`指令根据表达式删除或重新创建DOM树的一部分。如果分配给`ngIf`指令的表达式求值为`false`，则该元素将从DOM中移除。否则，元素的克隆将重新插入DOM中。我们可以通过利用这个指令来增强我们的倒计时器，就像这样：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When our timer reaches 0, the paragraph that displays the `Time up!` text will
    be rendered on the screen. You have probably noticed the asterisk that prepends
    the directive. This is because Angular embeds the HTML control marked with the
    `ngIf` directive (and all its HTML subtrees, if any) in a`<ng-template>`tag, which
    will be used later on to render the content on the screen. Covering how Angular
    treats templates is definitely out of the scope of this book, but let's just point
    out that this is syntactic sugar provided by Angular to act as a shortcut to other,
    more verbose syntax based on template tags.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的计时器达到0时，将在屏幕上呈现显示“时间到！”文本的段落。您可能已经注意到了在指令前面加上的星号。这是因为Angular将标有`ngIf`指令的HTML控件（以及其所有HTML子树，如果有的话）嵌入到`<ng-template>`标记中，稍后将用于在屏幕上呈现内容。涵盖Angular如何处理模板显然超出了本书的范围，但让我们指出，这是Angular提供的一种语法糖，作为其他更冗长的基于模板标记的语法的快捷方式。
- en: Perhaps you are wondering what difference does it make to render some chunk
    of HTML on screen with `*ngIf="conditional"`rather than with `[hidden]="conditional"`.
    The former will clone and inject pieces of templated HTML snippets in the markup,
    removing it from the DOM when the condition evaluates to `false`, while the latter
    does not inject or remove any markup from the DOM. It simply sets the visibility
    of the already existing chunk of HTML annotated with that DOM attribute.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 也许您想知道使用`*ngIf="conditional"`在屏幕上呈现一些HTML片段与使用`[hidden]="conditional"`有什么区别。前者将克隆并注入模板化的HTML片段到标记中，在条件评估为`false`时从DOM中删除它，而后者不会从DOM中注入或删除任何标记。它只是设置带有该DOM属性的已存在的HTML片段的可见性。
- en: NgFor
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NgFor
- en: 'The `ngFor` directive allows us to iterate through a collection (or any other
    iterable object) and bind each of its items to a template of our choice, where
    we can define convenient placeholders to interpolate the item data. Each instantiated
    template is scoped to the outer context, where the loop directive is placed, so
    we can access other bindings. Let''s imagine we have a component named `Staff`:
    it features a field named employees, which represents an array of `Employee` objects.
    We can enlist those employees and job titles in this way:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngFor`指令允许我们遍历集合（或任何其他可迭代对象），并将其每个项目绑定到我们选择的模板，我们可以在其中定义方便的占位符来插入项目数据。每个实例化的模板都作用域限定在外部上下文中，我们可以访问其他绑定。假设我们有一个名为`Staff`的组件：它具有一个名为employees的字段，表示一个`Employee`对象数组。我们可以这样列出这些员工和职位：'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see in the example provided, we turn each item fetched from the iterable
    object on each loop into a local reference so that we can easily bind this item
    in our template. A thing to highlight is that the expression starts with the keyword
    `let`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在提供的示例中看到的，我们将从每次循环中获取的可迭代对象中的每个项目转换为本地引用，以便我们可以轻松地在我们的模板中绑定这个项目。需要强调的是，表达式以关键字`let`开头。
- en: This directive observes changes in the underlying iterable object and will add,
    remove, or sort the rendered templates as items are added, removed, or reordered in
    the collection.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令观察底层可迭代对象的更改，并将根据项目在集合中添加、删除或重新排序而添加、删除或排序呈现的模板。
- en: Advanced looping
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级循环
- en: 'Besides from just looping all the items in a list, it is possible to keep track
    of other usable properties as well. Every property can be used the same way by
    us adding another statement after the declaration of the items:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了只循环列表中的所有项目之外，还可以跟踪其他可用属性。每个属性都可以通过在声明项目后添加另一个语句来使用：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**First/last**, this is a Boolean that keeps track of whether we are on the
    first or last item in our loop, should we want to render that item differently.
    It can be accessed in the following way:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**First/last**，这是一个布尔值，用于跟踪我们是否在循环中的第一个或最后一个项目上，如果我们想要以不同的方式呈现该项目。可以通过以下方式访问它：'
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Index**, is a number to tell us what index we are on; it starts at 0.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**Index**，是一个数字，告诉我们我们在哪个索引上；它从0开始。'
- en: '**Even/odd** is a Boolean to indicate whether we are even on an even or odd
    index.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**Even/odd**是一个布尔值，指示我们是否在偶数或奇数索引上。'
- en: '**TrackBy**, to explain what `trackBy` does, let''s first talk about the problem
    it attempts to solve. The problem is that the data the  `*ngFor`is pointing to
    may change, elements may be added or removed, and even the whole list may be replaced.
    The naive approach to the adding/removing of elements is to carry out create/remove
    on the DOM tree for all those elements. If same naive approach is used for displaying
    a new list instead of the old list we used to display this, it will be very expensive
    and slow. Angular deals with this by keeping DOM elements in memory because creation
    is costly. Internally, Angular uses something called object identity to keep track
    of every item in a list. `trackBy`, however, allows you to change from object
    identity to a specific property on your item. The default object identity is good
    in most cases, but if you start experiencing performance problems consider changing
    what property on your item `*ngFor` should look at like so:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**TrackBy**，要解释“trackBy”做什么，让我们首先谈谈它试图解决的问题。问题是，`*ngFor`指向的数据可能会发生变化，元素可能会被添加或删除，甚至整个列表可能会被替换。对于添加/删除元素的天真方法是对所有这些元素在DOM树上进行创建/删除。如果使用相同的天真方法来显示新列表而不是我们用来显示这个旧列表，那将是非常昂贵和缓慢的。Angular通过将DOM元素保存在内存中来处理这个问题，因为创建是昂贵的。在内部，Angular使用称为对象标识的东西来跟踪列表中的每个项目。然而，`trackBy`允许您从对象标识更改为项目上的特定属性。默认的对象标识在大多数情况下都很好，但是如果您开始遇到性能问题，请考虑更改`*ngFor`应查看的项目的属性，如下所示：'
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Else
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Else
- en: 'Else is a new construct per Angular 4.0 and is a short hand you can use to
    help you with conditional statements. Imagine you have the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Else是Angular 4.0的一个新构造，并且是一个简写，可以帮助您处理条件语句。想象一下，如果您有以下内容：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our use case here is pretty clear; if we have a person set then display its
    name, otherwise show a default text. We can write this in another way using `else`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里的用例非常清楚；如果我们设置了一个人，那么显示它的名字，否则显示默认文本。我们可以使用“else”以另一种方式编写这个：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'What''s happening here is how we define our conditional:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的是我们如何定义我们的条件：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We are saying if `person` is set then go ahead, if not display the template `noperson`
    . `noperson`   can be applied to a normal HTML element as well as an   `ng-template`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说如果“person”已设置，那么继续，如果没有显示模板“noperson”。 “noperson”也可以应用于普通的HTML元素以及“ng-template”。
- en: Applying style
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用样式
- en: 'There are three ways to apply styling in your markup:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的标记中应用样式有三种方法：
- en: Interpolation
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插值
- en: NgStyle
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NgStyle
- en: NgClass
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NgClass
- en: Interpolation
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插值
- en: 'This version is about using the curly brackets and have them resolve what class/classes
    should be applied. You would write an expression that looks like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本是关于使用花括号并让它们解析应该应用什么类/类。您可以编写一个看起来像这样的表达式：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This reads as if your item has a selected property then apply the CSS class
    selected, or else apply empty string, which is no class. While this might be sufficient
    in a lot of cases, it has drawbacks especially if more than one style needs to
    be applied as there is more than one condition that needs checking.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果您的项目具有选定的属性，则应用CSS类selected，否则应用空字符串，即没有类。虽然在许多情况下这可能足够，但它也有缺点，特别是如果需要应用多个样式，因为有多个需要检查的条件。
- en: Interpolation expression is considered costly in terms of performance, and is
    normally discouraged.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 插值表达式在性能方面被认为是昂贵的，通常是不鼓励使用的。
- en: NgStyle
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NgStyle
- en: 'As you probably have guessed already, this directive allows us to bind CSS
    styles by evaluating a custom object or expression. We can bind an object whose
    keys and values map CSS properties, or just define specific properties and bind
    data to them:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的那样，这个指令允许我们通过评估自定义对象或表达式来绑定CSS样式。我们可以绑定一个对象，其键和值映射CSS属性，或者只定义特定属性并将数据绑定到它们：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If our component defines the `myColor` and `myFontWeight` properties with the
    `red` and `bold` values, respectively, the color and weight of the text will change
    accordingly. The directive will always reflect the changes made within the component,
    and we can also pass an object instead of binding data on a per property basis:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的组件定义了`myColor`和`myFontWeight`属性，分别具有`red`和`bold`的值，那么文本的颜色和粗细将相应地改变。该指令将始终反映组件内所做的更改，我们还可以传递一个对象，而不是按属性基础绑定数据：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: NgClass
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NgClass
- en: 'Similar to `ngStyle`, `ngClass` allows us to define and toggle class names
    programmatically in a DOM element using a convenient declarative syntax. This
    syntax has its own intricacies, however. Let''s see each one of the three case
    scenarios available for this example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ngStyle`类似，`ngClass`允许我们以一种方便的声明性语法在DOM元素中定义和切换类名。然而，这种语法有其自己的复杂性。让我们看看这个例子中可用的三种情况：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For instance, we can use a string type so that if `myClassNames` contains a
    string with one or several classes delimited by a space, all of them will be bound
    to the paragraph.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用字符串类型，这样如果`myClassNames`包含一个由空格分隔的一个或多个类的字符串，所有这些类都将绑定到段落上。
- en: We can use an array as well so that each element will be added.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用数组，这样每个元素都会被添加。
- en: Last but not least, we can use an object in which each key corresponds to a
    CSS class name referred to by a Boolean value. Each key name marked as `true`
    will become an active class. Otherwise, it will be removed. This is usually the
    preferred way of handling class names.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们可以使用一个对象，其中每个键对应于由布尔值引用的CSS类名。标记为`true`的每个键名将成为一个活动类。否则，它将被移除。这通常是处理类名的首选方式。
- en: 'There is an alternate syntax to `ngClass`, which is in the following format:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngClass`还有一种替代语法，格式如下：'
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In short it is a comma separated version where it will apply a class when a
    condition is `true`. More than one class can be applied if more than one condition
    is `true`. It would look something like this if used in a more realistic scenario:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这是一个逗号分隔的版本，在条件为`true`时将应用一个类。如果有多个条件为`true`，则可以应用多个类。如果在更现实的场景中使用，它会看起来像这样：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The resulting markup could be the following if `jedi.side` has the value `light`
    then add CSS class light to the span element:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的标记可能如下，如果`jedi.side`的值为`light`，则将CSS类light添加到span元素中：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: NgSwitch, ngSwitchCase, and ngSwitchDefault
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NgSwitch、ngSwitchCase和ngSwitchDefault
- en: The `ngSwitch` directive is used to switch templates within a specific set depending
    on the condition required for displaying each one. The implementation follows
    several steps; therefore, three different directives are explained in this section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngSwitch`指令用于根据显示每个模板所需的条件在特定集合内切换模板。实现遵循几个步骤，因此在本节中解释了三个不同的指令。'
- en: The `ngSwitch` will evaluate a given expression and then toggle and display
    those child elements marked with an`ngSwitchCase` attribute directive, whose value
    matches the value thrown by the expression defined in the parent `ngSwitch`element.
    A special mention is required about the children element marked with the `ngSwitchDefault`directive
    attribute. This attribute qualifies the template that will be displayed when no
    other value defined by its `ngSwitchCase` siblings matches the parent conditional
    expression.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngSwitch`将评估给定的表达式，然后切换和显示那些带有`ngSwitchCase`属性指令的子元素，其值与父`ngSwitch`元素中定义的表达式抛出的值匹配。需要特别提到带有`ngSwitchDefault`指令属性的子元素。该属性限定了当其`ngSwitchCase`兄弟元素定义的任何其他值都不匹配父条件表达式时将显示的模板。'
- en: 'We''ll see all of this in an example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一个例子中看到所有这些：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The parent `[ngSwitch]`parameter evaluates the `weatherForecastDay` context
    variable, and each nested`ngSwitchCase`directive will be tested against it. We
    can use expressions instead, but we want to wrap `ngSwitchCase` in brackets so
    that Angular can properly evaluate its content as context variables instead of
    taking it as a text string.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 父`[ngSwitch]`参数评估`weatherForecastDay`上下文变量，每个嵌套的`ngSwitchCase`指令将针对其进行测试。我们可以使用表达式，但我们希望将`ngSwitchCase`包装在括号中，以便Angular可以正确地将其内容评估为上下文变量，而不是将其视为文本字符串。
- en: Coverage for the `NgPlural` and `NgPluralCase` sits outside of the scope of
    this book, but basically provide a convenient way to render or remove templates
    DOM blocks that match a switch expression, either strictly numeric or just a string,
    in a similar fashion to how the `ngSwitch` and `ngSwitchWhen` directives do.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`NgPlural`和`NgPluralCase`的覆盖范围超出了本书的范围，但基本上提供了一种方便的方法来呈现或删除与开关表达式匹配的模板DOM块，无论是严格的数字还是字符串，类似于`ngSwitch`和`ngSwitchWhen`指令的方式。'
- en: Manipulating template bindings with pipes
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用管道操作模板绑定
- en: So, we saw how we can use directives to render content depending on the data
    that our component classes manage, but there is another powerful feature that
    we will be using thoroughly in our daily practice with Angular. We are talking
    about pipes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们看到了如何使用指令根据我们的组件类管理的数据来呈现内容，但是还有另一个强大的功能，我们将在日常实践中充分利用Angular。我们正在谈论管道。
- en: 'Pipes allow us to filter and funnel the outcome of our expressions on a view
    level to transform or just better display the data we are binding. Their syntax
    is pretty simple, basically consisting of the pipe name following the expression
    that we want to transform, separated by a pipe symbol (hence the name):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 管道允许我们在视图级别过滤和引导我们表达式的结果，以转换或更好地显示我们绑定的数据。它们的语法非常简单，基本上由管道符号分隔的要转换的表达式后面跟着管道名称（因此得名）：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding example, we are displaying an uppercase greeting on the screen.
    Since we do not know whether the name will be in uppercase or not, we ensure a
    consistent output by transforming the value of the name whenever it is not an
    uppercase version at the view level. Pipes are chainable, and Angular has a wide
    range of pipe types already baked in. As we will see further in this chapter,
    we can also build our own pipes to fine-grain data output in cases where the built-in
    pipes are simply not enough.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在屏幕上显示了一个大写的问候语。由于我们不知道名字是大写还是小写，所以我们通过在视图级别转换名称的值来确保一致的输出。管道是可链式的，Angular已经内置了各种管道类型。正如我们将在本章中进一步看到的，我们还可以构建自己的管道，以在内置管道不足以满足需求的情况下对数据输出进行精细调整。
- en: The uppercase/lowercase pipe
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大写/小写管道
- en: 'The name uppercase/lowercase pipe says it all. As in the example provided previously,
    this pipe sets the string output in uppercase or lowercase. Insert the following
    code anywhere in your view and check out the output for yourself:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 大写/小写管道的名称就是它的含义。就像之前提供的示例一样，这个管道可以将字符串输出设置为大写或小写。在视图中的任何位置插入以下代码，然后自行检查输出：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The decimal, percent, and currency pipes
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小数、百分比和货币管道
- en: Numeric data can come in a wide range of flavors, and this pipe is especially
    convenient when it comes to better formatting and localizing the output. These
    pipes use the Internationalization API, and therefore they are reliable in Chrome
    and Opera browsers only.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 数值数据可以有各种各样的类型，当涉及到更好的格式化和本地化输出时，这个管道特别方便。这些管道使用国际化API，因此只在Chrome和Opera浏览器中可靠。
- en: The decimal pipe
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小数管道
- en: 'The decimal pipe will help us define the grouping and sizing of numbers using
    the active locale in our browser. Its format is as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 小数管道将帮助我们使用浏览器中的活动区域设置定义数字的分组和大小。其格式如下：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, `number_expression` is a number and `digitInfo` has the following format:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`number_expression`是一个数字，`digitInfo`的格式如下：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Each binding would correspond to the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每个绑定对应以下内容：
- en: '`minIntegerDigits`: The minimum number of integer digits to use. It defaults
    to 1.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minIntegerDigits`：要使用的整数位数的最小数字。默认为1。'
- en: '`minFractionDigits`: The minimum number of digits after the fraction. It defaults
    to 0.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minFractionDigits`：分数后的最小数字位数。默认为0。'
- en: '`maxFractionDigits`: The maximum number of digits after the fraction. It defaults
    to 3.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxFractionDigits`：分数后的最大数字位数。默认为3。'
- en: 'Keep in mind that the acceptable range for each of these numbers and other
    details will depend on your native internationalization implementation. Let''s
    try to explain how this works by creating the following component:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，每个数字和其他细节的可接受范围将取决于您的本地国际化实现。让我们尝试通过创建以下组件来解释这是如何工作的：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here we have an example of four different expressions that showcases us manipulating
    the number, fractions as well as locale. In the first case, we don't give any
    instructions other than to use the `number`pipe. In the second example, we are
    are specifying the number of fractions as well as numbers to show, by typing number: `'2.1-5'`.
    This means we show the two number on the left side of the fraction marker and
    5 on the right side. Because we only we have a 3 to the left we need to pad it
    with a zero. On the right side we just show 5 decimals. In the third example,
    we instruct it to show 7 numbers to the left and 5 to the right of the fraction
    marker. This means we need to pad the left side with 6 zeros. This also means
    that the thousand markers are being added. Our fourth example demonstrates the
    locale functionality. We see that the displayed result is space character for
    thousand separator and comma instead of point as fraction sign.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '这里有一个四种不同表达式的示例，展示了我们如何操作数字、分数以及区域设置。在第一种情况下，我们除了使用`number`管道之外没有给出任何指令。在第二个示例中，我们指定了要显示的小数位数和数字，通过输入`number:
    ''2.1-5''`。这意味着我们在分数标记的左侧显示两个数字，右侧显示5个数字。因为左侧只有3个数字，我们需要用零来填充。右侧我们只显示5位小数。在第三个示例中，我们指示它显示7个数字在分数标记的左侧，右侧显示5个数字。这意味着我们需要在左侧填充6个零。这也意味着千位分隔符被添加了。我们的第四个示例演示了区域设置功能。我们看到显示的结果是千位分隔符的空格字符，小数点的逗号。'
- en: 'There is one thing to remember, though; for locale setting to work, we need
    to install the correct locale in our root module. The reason is that Angular only
    have en-US locale set up from the beginning. It is quite easy to add more locales
    though.  We need to add the following code to `app.module.ts`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不过有一件事要记住；要使区域设置起作用，我们需要在根模块中安装正确的区域设置。原因是Angular只有从一开始就设置了en-US区域设置。不过添加更多区域设置非常容易。我们需要将以下代码添加到`app.module.ts`中：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The percent pipe
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 百分比管道
- en: 'The percent pipe formats a number as local percent. Other than this, it inherits
    from the number pipe so that we can further format the output to provide a better
    integer and decimal sizing and grouping. Its syntax is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 百分比管道将数字格式化为本地百分比。除此之外，它继承自数字管道，以便我们可以进一步格式化输出，以提供更好的整数和小数大小和分组。它的语法如下：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The currency pipe
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 货币管道
- en: 'This pipe formats a number as a local currency, providing support for selecting
    the currency code such as USD for the US dollar or EUR for the euro and setting
    up how we want the currency info to be displayed. Its syntax is as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个管道将数字格式化为本地货币，支持选择货币代码，如美元的USD或欧元的EUR，并设置我们希望货币信息显示的方式。它的语法如下：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding statement, `currencyCode` is obviously the ISO 4217 currency
    code, while `display` is a string that
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的语句中，`currencyCode`显然是ISO 4217货币代码，而`display`是一个字符串
- en: can either be `code`, assume the value `symbol` or `symbol-narrow`. The value `symbol-narrow`indicates
    whether to use the currency symbol (for example, `$`). The value `symbol` instructs
    to use the currency code (for example, USD) in the output. Similar to the decimal
    and percent pipes, we can format the output to provide a better integer and decimal
    sizing and grouping through the `digitInfo` value, we can also format based on
    locale.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 可以是`code`，假设值为`symbol`或`symbol-narrow`。值`symbol-narrow`指示是否使用货币符号（例如，$）。值`symbol`指示在输出中使用货币代码（例如USD）。与小数和百分比管道类似，我们可以通过`digitInfo`值格式化输出，还可以根据区域设置格式化。
- en: 'In the following, example, we demonstrate all three forms:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们演示了所有三种形式：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The slice pipe
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片管道
- en: 'The purpose of this pipe is equivalent to the role played by `Array.prototype.slice()`
    and `String.prototype.slice()` when it comes to subtracting a subset (slice) of
    a collection list, array, or string, respectively. Its syntax is pretty straightforward
    and follows the same conventions as those of the aforementioned `slice()` methods:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个管道的目的相当于`Array.prototype.slice()`和`String.prototype.slice()`在减去集合列表、数组或字符串的子集（切片）时所起的作用。它的语法非常简单，遵循与前述`slice()`方法相同的约定：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Basically, we configure a starting index where we will begin slicing either
    the items array or the string on an optional end index, which will fall back to
    the last index on the input when omitted.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们配置一个起始索引，我们将从中开始切片项目数组或字符串的可选结束索引，当省略时，它将回退到输入的最后索引。
- en: Both start and end arguments can take positive and negative values, as the JavaScript
    `slice()` methods do. Refer to the JavaScript API documentation for a full rundown
    on all of the available scenarios.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 开始和结束参数都可以取正值和负值，就像JavaScript的`slice()`方法一样。请参考JavaScript API文档，了解所有可用场景的详细情况。
- en: Last but not least, please note that when operating on a collection, the returned
    list is always a copy—even when all elements are being returned.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，请注意，在操作集合时，返回的列表始终是副本，即使所有元素都被返回。
- en: The date pipe
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期管道
- en: 'You must have already guessed that the date pipe formats a date value as a
    string based on the requested format. The time zone of the formatted output will
    be the local system time zone of the end user''s machine. Its syntax is pretty
    simple:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定已经猜到了，日期管道根据请求的格式将日期值格式化为字符串。格式化输出的时区将是最终用户机器的本地系统时区。它的语法非常简单：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The expression input must be a date object or a number (milliseconds since
    the UTC epoch). The format argument is highly customizable and accepts a wide
    range of variations based on date-time symbols. For our convenience, some aliases
    have been made available as shortcuts to the most common date formats:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式输入必须是一个日期对象或一个数字（自UTC纪元以来的毫秒数）。格式参数是高度可定制的，并接受基于日期时间符号的各种变化。为了我们的方便，一些别名已经被提供为最常见的日期格式的快捷方式：
- en: '`''medium''`: This is equivalent to `''yMMMdjms''` (for example, Sep 3, 2010,
    12:05:08 PM for en-US)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''中等''：这相当于''yMMMdjms''（例如，对于en-US，Sep 3, 2010, 12:05:08 PM）'
- en: '`''short''`: This is equivalent to `''yMdjm''` (for example, 9/3/2010, 12:05
    PM'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''短''：这相当于''yMdjm''（例如，9/3/2010, 12:05 PM'
- en: for en-US)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于en-US）
- en: '`''fullDate''`: This is equivalent to `''yMMMMEEEEd''` (for example, Friday,
    September 3, 2010 for en-US)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''fullDate''：这相当于''yMMMMEEEEd''（例如，对于en-US，Friday, September 3, 2010）'
- en: '`''longDate''`: This is equivalent to `''yMMMMd''` (for example, September
    3, 2010)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''长日期''：这相当于''yMMMMd''（例如，September 3, 2010）'
- en: '`''mediumDate''`: This is equivalent to `''yMMMd''` (for example, Sep 3, 2010
    for en-US)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''中等日期''：这相当于''yMMMd''（例如，对于en-US，Sep 3, 2010）'
- en: '`''shortDate''`: This is equivalent to `''yMd''` (for example, 9/3/2010 for
    en-US)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''短日期''：这相当于''yMd''（例如，对于en-US，9/3/2010）'
- en: '`''mediumTime''`: This is equivalent to `''jms''` (for example, 12:05:08 PM
    for en-US)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''中等时间''：这相当于''jms''（例如，对于en-US，12:05:08 PM）'
- en: '`''shortTime''`: This is equivalent to `''jm''` (for example, 12:05 PM for
    en-US)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''短时间''：这相当于''jm''（例如，对于en-US，12:05 PM）'
- en: The `json` pipe
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json管道
- en: The JSON pipe
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON管道
- en: 'JSON is probably the most straightforward pipe in its definition; it basically
    takes an object as an input and outputs it in JSON format:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: JSON可能是定义中最直接的管道；它基本上以对象作为输入，并以JSON格式输出它：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output using the Json pipe is the following `{ "name": "chris", "age":
    38, "address": { "street": "Oxford Street", "city": "London" } }`. This shows
    that the pipe has turned single quotes to double quotes and thereby produced valid
    JSON. So, why do we need this? One reason is debugging; it''s a nice way to see
    what a complex object contains and have it nicely printed to the screen. As you
    can see from the preceding field `person`, it contains some simple properties
    but also the complex `address`property. The deeper the object is the nicer it
    is, to have the json pipe.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '使用Json管道的输出如下：{ "name": "chris", "age": 38, "address": { "street": "Oxford
    Street", "city": "London" } }。这表明管道已将单引号转换为双引号，从而生成有效的JSON。那么，我们为什么需要这个？一个原因是调试；这是一个很好的方式来查看复杂对象包含什么，并将其漂亮地打印到屏幕上。正如您从前面的字段''person''中看到的，它包含一些简单的属性，但也包含复杂的''address''属性。对象越深，json管道就越好。'
- en: The i18n pipes
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: i18n管道
- en: As part of Angular's strong commitment to providing a strong internationalization
    toolset, a reduced set of pipes targeting common i18n use cases have been made
    available. This book will only cover the two major ones, but it is quite likely
    that more pipes will be released in the future. Please refer to the official documentation
    for further information after finishing this chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Angular对提供强大国际化工具集的坚定承诺的一部分，已经提供了一组针对常见i18n用例的管道。本书将只涵盖两个主要的管道，但很可能在将来会发布更多的管道。请在完成本章后参考官方文档以获取更多信息。
- en: The i18nPlural pipe
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: i18nPlural管道
- en: 'The `i18nPlural` pipe has a simple usage, where we just evaluate a numeric
    value against an object mapping different string values to be returned depending
    on the result of the evaluation. This way, we can render different strings on
    our template depending if the numeric value is zero, one, two, more than *N*,
    and so on. The syntax is the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`i18nPlural`管道有一个简单的用法，我们只需评估一个数字值与一个对象映射不同的字符串值，根据评估的结果返回不同的字符串。这样，我们可以根据数字值是零、一、二、大于*N*等不同的情况在我们的模板上呈现不同的字符串。语法如下：'
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s look at how this could look for a numeric field `jedis` on your component
    class:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这在你的组件类上的一个数字字段`jedis`上是什么样子的：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we can have this mapping as a field of our component controller class:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将这个映射作为我们组件控制器类的一个字段：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We even bind the numeric value evaluated in the expression by introducing the
    `'#'` placeholder in the string mappings. When no matching value is found, the
    pipe will fall back to the mapping set with the key `'other'`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至通过在字符串映射中引入`'#'`占位符来绑定表达式中评估的数字值。当找不到匹配的值时，管道将回退到使用键`'other'`设置的映射。
- en: The i18nSelect pipe
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: i18nSelect管道
- en: 'The `i18nSelect` pipe is similar to the`i18nPlural` pipe, but it evaluates
    a string value instead. This pipe is perfect for localizing text interpolations
    or providing distinct labels depending on state changes, for instance. For example,
    we could recap on our timer and serve the UI in different languages:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`i18nSelect`管道类似于`i18nPlural`管道，但它评估的是一个字符串值。这个管道非常适合本地化文本插值或根据状态变化提供不同的标签，例如。例如，我们可以回顾一下我们的计时器，并以不同的语言提供UI：'
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In our controller class, we can populate `localizedLabelsMap`, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的控制器类中，我们可以填充`localizedLabelsMap`，如下所示：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It is important to note that we can put this convenient pipe to use in use cases
    other than localizing components, but to provide string bindings depending on
    map keys and the like. Same as the `i18nPlural` pipe, when no matching value is
    found, the pipe will fall back to the mapping set with the `'other' `key.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们可以在除了本地化组件之外的用例中使用这个方便的管道，而是根据映射键和类似的东西提供字符串绑定。与`i18nPlural`管道一样，当找不到匹配的值时，管道将回退到使用`'other'`键设置的映射。
- en: The async pipe
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步管道
- en: Sometimes, we manage observable data or only data that is handled asynchronously
    by our component class, and we need to ensure that our views promptly reflect
    the changes in the information once the observable field changes or asynchronous
    loading has been accomplished after the view has been rendered. The async pipe
    subscribes to an observable or promise and returns the latest value it has emitted.
    When a new value is emitted, the async pipe marks the component to be checked
    for changes. We will return to this concept in [Chapter 7](113fea8a-41c0-4884-95ad-ac95ee0c4c65.xhtml), *Asynchronous
    Data Services with Angular*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们管理可观察数据或仅由组件类异步处理的数据，并且我们需要确保我们的视图及时反映信息的变化，一旦可观察字段发生变化或异步加载在视图渲染后完成。异步管道订阅一个可观察对象或承诺，并返回它发出的最新值。当发出新值时，异步管道标记组件以检查更改。我们将在[第7章](113fea8a-41c0-4884-95ad-ac95ee0c4c65.xhtml)中返回这个概念，*使用Angular进行异步数据服务*。
- en: Putting it all together in a task list
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容放在任务列表中
- en: Now that you have learned all the elements that allow you to build full-blown
    components, it's time to put all of this fresh knowledge into practice. In the
    next pages, we are going to build a simple task list manager. In it, we will see
    a tasks table containing the to-do items we need to build.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了所有的元素，可以让你构建完整的组件，是时候把所有这些新知识付诸实践了。在接下来的页面中，我们将构建一个简单的任务列表管理器。在其中，我们将看到一个包含我们需要构建的待办事项的任务表。
- en: We will also queue up tasks straight from the backlog of tasks available. This
    will help showing the time required to accomplish all the queued tasks and see
    how many tasks are defined in our working agenda.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将直接从可用任务的积压队列中排队任务。这将有助于显示完成所有排队任务所需的时间，并查看我们工作议程中定义了多少任务。
- en: Setting up our main HTML container
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的主HTML容器
- en: 'Before building the actual component, we need to set up our work environment
    first and in order to do so, we will reuse the same HTML boilerplate file we used
    in the previous component. Please set aside the work you''ve done so far and keep
    the `package.json`, `tsconfig.json`, `typings.json`, and `index.html` files we
    used in previous examples. Feel free to reinstall the modules required in case
    you need to, and replace the contents of the body tag in our `index.html` template:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建实际组件之前，我们需要先设置好我们的工作环境，为此，我们将重用在上一个组件中使用的相同的HTML样板文件。请将您迄今为止所做的工作放在一边，并保留我们在以前的示例中使用的`package.json`、`tsconfig.json`、`typings.json`和`index.html`文件。如果需要的话，随时重新安装所需的模块，并替换我们`index.html`模板中的body标签的内容：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In a nutshell, we have just updated the title of the header layout above our
    new `<tasks>` custom elements, which replaces the previous `<timer>`. You might
    want to update the `app.module.ts` file and make sure to point out tasks as a
    component that can be visible outside of our module by entering it in the `exports`
    key array:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们刚刚更新了位于我们新的`<tasks>`自定义元素上方的标题布局的标题，该元素替换了以前的`<timer>`。您可能希望更新`app.module.ts`文件，并确保将任务作为一个可以在我们模块之外可见的组件，输入到`exports`关键数组中：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s highlight here that the application has two modules so far: our root
    module called `AppModule` and our `TaskModule`. Our root module should import
    our `TaskModule` like so:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里强调一下，到目前为止，应用程序有两个模块：我们的根模块称为`AppModule`和我们的`TaskModule`。我们的根模块应该像这样导入我们的`TaskModule`：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Building our task list table with Angular directives
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular指令构建我们的任务列表表格
- en: Create an empty `tasks.ts` file. You might want to use this newly created file
    to build our new component from scratch and embed on it the definitions of all
    the accompanying pipes, directives, and components we will see later in this chapter.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个空的 `tasks.ts` 文件。您可能希望使用这个新创建的文件从头开始构建我们的新组件，并在其中嵌入我们将在本章后面看到的所有伴随管道、指令和组件的定义。
- en: Real-life projects are never implemented this way, since our code must conform
    to the "one class, one file" principle, taking advantage of ECMAScript modules
    for gluing things together. [Chapter 6](93b8f637-859e-4e12-aaa0-4cec5f02c2c3.xhtml),
    *Building an Application with Angular Components*, will introduce you to a common
    set of good practices for building Angular applications, including strategies
    for organizing your directory tree and your different elements (components, directives,
    pipes, services, and so on) in a sustainable way. This chapter, on the contrary,
    will leverage `tasks.ts` to include all the code in a central location and then
    provide a bird's eye view of all the topics we will cover now without having to
    go switching across files. Bear in mind that this is in fact an anti-pattern,
    but for instructional purposes, we will take this approach in this chapter for
    the last time. The order in which elements are declared within the file is important.
    Refer to the code repository in GitHub if exceptions rise.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现实生活中的项目从未以这种方式实现，因为我们的代码必须符合“一个类，一个文件”的原则，利用ECMAScript模块将事物粘合在一起。[第6章](93b8f637-859e-4e12-aaa0-4cec5f02c2c3.xhtml)，*使用Angular组件构建应用程序*，将向您介绍构建Angular应用程序的一套常见最佳实践，包括组织目录树和不同元素（组件、指令、管道、服务等）的可持续方式。相反，本章将利用`tasks.ts`将所有代码包含在一个中心位置，然后提供我们现在将涵盖的所有主题的鸟瞰视图，而无需在文件之间切换。请记住，这实际上是一种反模式，但出于教学目的，我们将在本章中最后一次采用这种方法。文件中声明元素的顺序很重要。如果出现异常，请参考GitHub中的代码存储库。
- en: Before moving on with our component, we need to import the dependencies required,
    formalize the data model we will use to populate the table, and then scaffold
    some data that will be served by a convenient service class.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续我们的组件之前，我们需要导入所需的依赖项，规范我们将用于填充表格的数据模型，然后搭建一些数据，这些数据将由一个方便的服务类提供。
- en: 'Let''s begin by adding to our `tasks.ts` file the following code block, importing
    all the tokens we will require in this chapter. Pay special attention to the tokens
    we are importing from the Angular library. We have covered components and input
    already, but all the rest will be explained later in this chapter:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在我们的`tasks.ts`文件中添加以下代码块，导入我们在本章中将需要的所有标记。特别注意我们从Angular库中导入的标记。我们已经介绍了组件和输入，但其余的内容将在本章后面进行解释：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With the dependency tokens already imported, let''s define the data model for
    our tasks, next to the block of imports:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 已经导入了依赖标记，让我们在导入的代码块旁边定义我们任务的数据模型：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The schema of a `Task` model interface is pretty self-explanatory. Each task
    has a name, a deadline, a field informing how many units need to be shipped, and
    a Boolean field named `queued` that defines if that task has been tagged to be
    done in our next session.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task`模型接口的架构非常容易理解。每个任务都有一个名称，一个截止日期，一个字段用于通知需要运送多少单位，以及一个名为`queued`的布尔字段，用于定义该任务是否已被标记为在下一个会话中完成。'
- en: You might be surprised that we define a model entity with an interface rather
    than a class, but this is perfectly fine when the entity model does not feature
    any business logic requiring implementation of methods or data transformation
    in a constructor or setter/getter function. When the latter is not required, an
    interface just suffices since it provides the static typing we require in a simple
    and more lightweight fashion.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会惊讶我们使用接口而不是类来定义模型实体，但当实体模型不需要实现方法或在构造函数或setter/getter函数中进行数据转换时，这是完全可以的。当后者不需要时，接口就足够了，因为它以简单且更轻量的方式提供了我们需要的静态类型。
- en: 'Now, we need some data and a service wrapper class to deliver such data in
    the form of a collection of `Task` objects. The `TaskService` class defined here
    will do the trick, so append it to your code right after the `Task` interface:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一些数据和一个服务包装类，以集合`Task`对象的形式提供这样的数据。在这里定义的`TaskService`类将起到作用，因此请在`Task`接口之后立即将其附加到您的代码中：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This data store is pretty self-explanatory: it exposes a `taskStore`property
    returning an array of objects conforming to the `Task` interface (hence benefiting
    from static typing) with information about the name, deadline, and time estimate.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据存储相当简单明了：它公开了一个`taskStore`属性，返回一个符合`Task`接口的对象数组（因此受益于静态类型），其中包含有关名称、截止日期和时间估计的信息。
- en: 'Now that we have a data store and a model class, we can begin building an Angular
    component that will consume this data source to render the tasks in our template
    view. Insert the following component implementation after the code you wrote before:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个数据存储和一个模型类，我们可以开始构建一个Angular组件，该组件将使用这个数据源来呈现我们模板视图中的任务。在您之前编写的代码之后插入以下组件实现：
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As you can see, we have defined and instantiated through the bootstrap function
    a new component named `TasksComponent` with the selector `<tasks>` (we already
    included it when we were populating the main `index.html` file, remember?). This
    class exposes two properties: today''s date and a tasks collection that will be
    rendered in a table contained in the component''s view, as we will see shortly.
    To do so, it instantiates in its constructor the data source that we created previously,
    mapping it to the array of models typed as `Task` objects represented by the tasks
    field. We also initialize the today property with an instance of the JavaScript
    built-in `Date` object, which contains the current date.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，我们通过引导函数定义并实例化了一个名为`TasksComponent`的新组件，选择器为`<tasks>`（我们在填充主`index.html`文件时已经包含了它，记得吗？）。这个类公开了两个属性：今天的日期和一个任务集合，它将在组件视图中的表中呈现，我们很快就会看到。为此，在其构造函数中实例化了我们之前创建的数据源，并将其映射到作为`Task`对象类型的模型数组，由任务字段表示。我们还使用JavaScript内置的`Date`对象的实例初始化了today属性，其中包含当前日期。
- en: As you have seen, the component selector does not match its controller class
    naming. We will delve deeper into naming conventions at the end of this chapter,
    as a preparation for [Chapter 6](93b8f637-859e-4e12-aaa0-4cec5f02c2c3.xhtml),
    *Building an Application with Angular Components*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，组件选择器与其控制器类命名不匹配。我们将在本章末深入探讨命名约定，作为[第6章](93b8f637-859e-4e12-aaa0-4cec5f02c2c3.xhtml)《使用Angular组件构建应用程序》的准备工作。
- en: 'Let''s create the stylesheet file now, whose implementation will be really
    simple and straightforward. Create a new file named `tasks.css` at the same location
    where our component file lives. You can then populate it with the following styles
    ruleset:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建样式表文件，其实现将非常简单明了。在我们的组件文件所在的位置创建一个名为`tasks.css`的新文件。然后，您可以使用以下样式规则填充它：
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This newly created stylesheet is so simple that it might seem a bit too much
    to have it as a standalone file. However, this comes as a good opportunity to
    showcase in our example the functionalities of the `styleUrls` property of the
    component metadata.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新创建的样式表非常简单，以至于它可能看起来有点多余作为一个独立的文件。然而，在我们的示例中，这是展示组件元数据的`styleUrls`属性功能的好机会。
- en: 'Things are quite different in regards to our HTML template. This time we will
    not hardcode our HTML template in the component either, but we will point to an
    external HTML file to better manage our presentation code. Please create an HTML
    file and save it as `tasks.html` in the same location where our main component''s
    controller class exists. Once it is created, fill it in with the following HTML
    snippet:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的HTML模板，情况大不相同。这一次，我们也不会在组件中硬编码我们的HTML模板，而是将其指向外部HTML文件，以更好地管理我们的呈现代码。请在与我们的主要组件控制器类相同的位置创建一个HTML文件，并将其保存为`tasks.html`。创建完成后，使用以下HTML片段填充它：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We are basically creating a table that features a neat styling based on the
    Bootstrap framework. Then, we render all our tasks using the always convenient
    `ngFor` directive, extracting and displaying the index of each item in our collection as
    we explained while overviewing the `ngFor` directive earlier in this chapter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们正在创建一个基于Bootstrap框架的具有整洁样式的表格。然后，我们使用始终方便的`ngFor`指令渲染所有任务，提取并显示我们在本章早些时候概述`ngFor`指令时解释的集合中每个项目的索引。
- en: Please look at how we formatted the output of our task's name and deadline interpolations
    by means of pipes, and how conveniently we display (or not) an ellipsis to indicate
    when the text exceeds the maximum number of characters we allocated for the name
    by turning the HTML hidden property into a property bound to an Angular expression.
    All this presentation logic is topped with a red label, indicating whether the
    given task is due whenever its end date is prior to this day.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请看我们如何通过管道格式化任务名称和截止日期的输出，以及如何方便地显示（或不显示）省略号来指示文本是否超过了我们为名称分配的最大字符数，方法是将HTML隐藏属性转换为绑定到Angular表达式的属性。所有这些呈现逻辑都标有红色标签，指示给定任务是否在截止日期之前到期。
- en: You have probably noticed that those action buttons do not exist in our current
    implementation. We will fix this in the next section, playing around with state
    in our components. Back in [Chapter 1](17474bca-f7f9-41ec-ab4c-5f7ac741c0c9.xhtml),
    *Creating Our Very First Component in Angular*, we touched upon the click event
    handler for stopping and resuming the countdown, and then delved deeper into the
    subject in [Chapter 4](41335dde-9066-4998-a0a9-3c42f97cdd9e.xhtml), *Implementing
    Properties and Events in Our Components*, where we covered output properties.
    Let's continue on our research and see how we can hook up DOM event handlers with
    our component's public methods, adding a rich layer of interactivity to our components.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，这些操作按钮在我们当前的实现中不存在。我们将在下一节中修复这个问题，在我们的组件中玩转状态。回到[第1章](17474bca-f7f9-41ec-ab4c-5f7ac741c0c9.xhtml)，*在Angular中创建我们的第一个组件*，我们提到了点击事件处理程序来停止和恢复倒计时，然后在[第4章](41335dde-9066-4998-a0a9-3c42f97cdd9e.xhtml)，*在我们的组件中实现属性和事件*中更深入地讨论了这个主题，我们涵盖了输出属性。让我们继续研究，看看我们如何将DOM事件处理程序与我们组件的公共方法连接起来，为我们的组件添加丰富的交互层。
- en: Toggling tasks in our task list
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的任务列表中切换任务
- en: 'Add the following method to your `TasksComponent` controller class. Its functionality
    is pretty basic; we just literally toggle the value of the queued property for
    a given `Task` object instance:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下方法添加到您的`TasksComponent`控制器类中。它的功能非常基本；我们只是简单地切换给定`Task`对象实例的queued属性的值：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we just need to hook it up with our view buttons. Update our view to include
    a click attribute (wrapped in braces so that it acts as an output property) in
    the button created within the `ngFor` loop. Now that we will have different states
    in our `Task` objects, let''s reflect this in the button labels by implementing
    an`ngSwitch` structure all together:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要将其与我们的视图按钮连接起来。更新我们的视图，包括在“ngFor”循环中创建的按钮中的点击属性（用大括号括起来，以便它充当输出属性）。现在，我们的“Task”对象将具有不同的状态，让我们通过一起实现“ngSwitch”结构来反映这一点：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Our brand new button can execute the `toggleTask()`method in our component class,
    passing as an argument the `Task` object that corresponds to that iteration of
    `ngFor`. On the other hand, the preceding `ngSwitch` implementation allows us
    to display different button labels and icons depending on the state of the `Task`
    object at any given time.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们全新的按钮可以在我们的组件类中执行“toggleTask（）”方法，将“Task”对象作为参数传递给“ngFor”迭代对应的对象。另一方面，先前的“ngSwitch”实现允许我们根据“Task”对象在任何给定时间的状态来显示不同的按钮标签和图标。
- en: We are decorating the newly created buttons with font icons fetched from the
    Glyphicons font family. The icons are part of the Bootstrap CSS bundle we installed
    previously and are in no means related to Angular. Feel free to skip its use or
    to replace it by another icon font family.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在用从Glyphicons字体系列中获取的字体图标装饰新创建的按钮。这些图标是我们之前安装的Bootstrap CSS捆绑包的一部分，与Angular无关。请随意跳过使用它或用另一个图标字体系列替换它。
- en: Execute the code as it is now and check out the results yourself. Neat, isn't
    it? But, maybe we can get more juice from Angular by adding more functionality
    to the task list.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在执行代码并自行检查结果。整洁，不是吗？但是，也许我们可以通过向任务列表添加更多功能来从Angular中获得更多的效果。
- en: Displaying state changes in our templates
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的模板中显示状态变化
- en: 'Now that we can pick the tasks to be done from the table, it would be great
    to have some kind of visual hint of how many units we are meant to ship. The logic
    is as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从表中选择要完成的任务，很好地显示出我们需要运送多少个单位的一些视觉提示将是很好的。逻辑如下：
- en: The user reviews the tasks on the table and picks the ones to be done by clicking
    on each one
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户审查表上的任务，并通过点击每个任务来选择要完成的任务
- en: Every time a row is clicked, the underlying `Task` object state changes and
    its Boolean queued property is toggled
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次点击一行时，底层的“Task”对象状态都会发生变化，并且其布尔排队属性会被切换
- en: The state change is reflected immediately on the surface by displaying a `queued`
    label on the related task item
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态变化立即通过在相关任务项上显示“queued”标签来反映在表面上
- en: The user gets prompt information of the amount of units they need to ship and
    a time estimation to deliver them all
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户得到了需要运送的单位数量的提示信息和交付所有这些单位的时间估计
- en: We see how a row of icons are displayed above the table, displaying the sum
    of all units from all the tasks set to be done
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们看到在表格上方显示了一排图标，显示了所有要完成的任务中所有单位的总和
- en: This functionality will have to react to the state changes of the set of `Task`
    objects we're dealing with. The good news is that thanks to Angular's very own
    change detection system, making components fully aware of state changes is extremely
    easy.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能将不得不对我们处理的“Task”对象集的状态变化做出反应。好消息是，由于Angular自己的变化检测系统，使组件完全意识到状态变化变得非常容易。
- en: Thus, our very first task will be to tweak our `TasksComponent` class to include
    some way to compute and display how many tasks are queued up. We will use that
    information to render or not a block of markup in our component where we will
    inform how many tasks we have lined up and how much aggregated time it will take
    to accomplish them all.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的第一个任务将是调整我们的`TasksComponent`类，以包括一种计算和显示排队任务数量的方法。我们将使用这些信息来在我们的组件中渲染或不渲染一块标记，其中我们将通知我们排队了多少任务，以及完成所有任务需要多少累计时间。
- en: 'The new `queuedTasks`field of our class will provide such information, and
    we will want to insert a new method named `updateQueuedTasks()` in our class that
    will update its numeric value upon instantiating the component or enqueueing tasks.
    On top of that, we will create a key/value mapping that we can use later on to
    render a more expressive title header depending on the amount of queued tasks
    thanks to the `I18nPlural` pipe:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们类的新`queuedTasks`字段将提供这样的信息，我们将希望在我们的类中插入一个名为`updateQueuedTasks()`的新方法，该方法将在实例化组件或排队任务时更新其数值。除此之外，我们将创建一个键/值映射，以便稍后根据排队任务的数量使用`I18nPlural`管道来呈现更具表现力的标题头：
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `updateQueuedTasks()` method makes use of JavaScript''s native `Array.filter()` and `Array.reduce()`methods
    to build a list of queued tasks out of the original task''s collection property.
    The `reduce` method applied over the resulting array gives us the total number
    of units to ship. With a stateful computation of the number of queued units to
    ship now available, it''s time to update our template accordingly. Go to `tasks.html`and
    inject the following chunk of HTML right before the `<h4>Tasks backlog</h4>` element.
    The code is as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateQueuedTasks()`方法利用JavaScript的原生`Array.filter()`和`Array.reduce()`方法从原始任务集合属性中构建一个排队任务列表。应用于结果数组的`reduce`方法给出了要运送的单位总数。现在有了一个有状态的计算排队单位数量的方法，是时候相应地更新我们的模板了。转到`tasks.html`并在`<h4>Tasks
    backlog</h4>`元素之前注入以下HTML代码块。代码如下：'
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The preceding block renders an informative header title at all times, even when
    no tasks have been queued up. We also bind that value in the template and use
    it to estimate through an expression binding the amount of minutes required to
    go through each and every session required.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块始终呈现一个信息性的标题，即使没有任务排队。我们还将该值绑定在模板中，并使用它通过表达式绑定来估算通过每个会话所需的分钟数。
- en: We are hardcoding the duration of each task in the template. Ideally, such constant
    values should be bound from an application variable or a centralized setting.
    Don't worry, we will see how we can improve this implementation in the next chapters.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在在模板中硬编码每个任务的持续时间。理想情况下，这样的常量值应该从应用程序变量或集中设置中绑定。别担心，我们将在接下来的章节中看到如何改进这个实现。
- en: Save your changes and reload the page, and then try to toggle some task items
    on the table to see how the information changes in real time. Exciting, isn't
    it?
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 保存更改并重新加载页面，然后尝试在表格上切换一些任务项目，看看信息如何实时变化。令人兴奋，不是吗？
- en: Embedding child components
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入子组件
- en: Now, let's start building a tiny icon component that will be nested inside the `TasksComponent`component.
    This new component will display a smaller version of our big icon, which we will
    use to display on the template the amount of tasks lined up to be done, as we
    described earlier in this chapter. Let's pave the way towards component trees,
    which we will analyze in detail in [Chapter 6](93b8f637-859e-4e12-aaa0-4cec5f02c2c3.xhtml),
    *Building an Application with Angular Components*. For now, just include the following
    component class before the `TasksComponent`   class you built earlier.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始构建一个微小的图标组件，它将嵌套在`TasksComponent`组件内部。这个新组件将显示我们大图标的一个较小版本，我们将用它来在模板上显示排队等待完成的任务数量，就像我们在本章前面描述的那样。让我们为组件树铺平道路，我们将在[第6章](93b8f637-859e-4e12-aaa0-4cec5f02c2c3.xhtml)中详细分析，*使用Angular组件构建应用程序*。现在，只需在之前构建的`TasksComponent`类之前包含以下组件类。
- en: Our component will expose a public property named task in which we can inject
    a`Task`object. The component will use this `Task`object binding to replicate the
    image rendered in the template as many times as sessions are required by this
    task in its `hoursLeft` property, all this by means of an `ngFor` directive.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件将公开一个名为task的公共属性，我们可以在其中注入一个`Task`对象。组件将使用这个`Task`对象绑定，根据该任务的`hoursLeft`属性所需的会话次数，在模板中复制渲染的图像，这都是通过`ngFor`指令实现的。
- en: 'In our `tasks.ts` file, inject the following block of code before our`TasksComponent`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`tasks.ts`文件中，在`TasksComponent`之前注入以下代码块：
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Before we continue and iterate over our component, it is important to ensure
    we register our component with a module, so that other constructs may know its
    existence, so they can use said component in their template. We register it by
    adding it to the `declarations` property of its module object like so:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续迭代我们的组件之前，重要的是要确保我们将组件注册到一个模块中，这样其他构造体就可以知道它的存在，这样它们就可以在它们的模板中使用该组件。我们通过将它添加到其模块对象的`declarations`属性中来注册它：
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now that the `TaskModule` knows about our component, we can continue and improve
    it.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`TaskModule`知道了我们的组件，我们可以继续改进它。
- en: Our new `TaskIconsComponent` features a pretty simple implementation, with a
    very intuitive selector matching its camel-cased class name and a template where
    we duplicate the given `<img>`tag as many times as objects are populated in the
    icons array property of the controller class, which is populated with the native
    fill method of the `Array` object in the JavaScript API (the fill method fills
    all the elements of an array with a static value passed as an argument), within`ngOnInit()`.
    Wait, what is this? Shouldn't we implement the loop populating the icons array
    member in the constructor instead?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新`TaskIconsComponent`具有一个非常简单的实现，具有一个非常直观的选择器，与其驼峰命名的类名匹配，以及一个模板，在模板中，我们根据控制器类的icons数组属性中填充的对象的数量，多次复制给定的`<img>`标签，这是通过JavaScript
    API中的`Array`对象的fill方法填充的（fill方法用静态值填充数组的所有元素作为参数传递），在`ngOnInit()`中。等等，这是什么？我们不应该在构造函数中实现填充图标数组成员的循环吗？
- en: This method is one of the life cycle hooks that we will overview in the next
    chapter, and probably the most important one. The reason why we populate the icons
    array field here and not in the constructor method is because we need each and
    every data-bound property to be properly initialized before proceeding to run
    the for loop. Otherwise, it will be too soon to access the input value task since
    it will return an undefined value.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是我们将在下一章概述的生命周期钩子之一，可能是最重要的一个。我们之所以在这里填充图标数组字段，而不是在构造方法中，是因为我们需要在继续运行for循环之前，每个数据绑定属性都得到适当的初始化。否则，太早访问输入值任务将会返回一个未定义的值。
- en: The `OnInit` interface demands an `ngOnInit()`method to be integrated in the
    controller class that implements such -interface, and it will be executed once
    all input properties with a binding defined have been checked. We will take a
    bird's eye overview of component lifecycle hooks in [Chapter 6](93b8f637-859e-4e12-aaa0-4cec5f02c2c3.xhtml),
    *Building an Application with Angular Components*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnInit`接口要求在实现此接口的控制器类中集成一个`ngOnInit()`方法，并且一旦所有已定义绑定的输入属性都已检查，它将被执行。我们将在[第6章](93b8f637-859e-4e12-aaa0-4cec5f02c2c3.xhtml)中对组件生命周期钩子进行概述，*使用Angular组件构建应用程序*。'
- en: 'Still, our new component needs to find its way to its parent component. So,
    let''s insert a reference to the component class in the directives property of
    the`TasksComponent` decorator settings:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新组件仍然需要找到其父组件。因此，让我们在`TasksComponent`的装饰器设置的directives属性中插入对组件类的引用：
- en: '[PRE48]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Our next step will be to inject the `<task-icons>`element in the `TasksComponent`
    template. Go back to `tasks.html` and update the code located inside the conditional
    block meant to be displayed when `hoursLeft`is greater than zero. The code is
    as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步将是在`TasksComponent`模板中注入`<task-icons>`元素。回到`tasks.html`，并更新条件块内的代码，以便在`hoursLeft`大于零时显示。代码如下：
- en: '[PRE49]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'There is still some room for improvement though. Unfortunately, the icon size
    is hardcoded in the `TaskIconsComponent`template and that makes it harder to reuse
    that component in other contexts where a different size might be required. Obviously,
    we could refactor the `TaskIconsComponent` class to expose a `size` input property
    and then bind the value received straight into the component template in order
    to resize the image accordingly:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仍然有一些改进的空间。不幸的是，图标大小在`TaskIconsComponent`模板中是硬编码的，这使得在其他需要不同大小的上下文中重用该组件变得更加困难。显然，我们可以重构`TaskIconsComponent`类，以公开一个`size`输入属性，然后将接收到的值直接绑定到组件模板中，以便根据需要调整图像的大小。
- en: '[PRE50]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, we just need to update the implementation of `tasks.html` to declare
    the value we need for the size:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需要更新`tasks.html`的实现，以声明我们需要的大小值：
- en: '[PRE51]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Please note that the `size`attribute is not wrapped between brackets because
    we are binding a hardcoded value. If we wanted to bind a component variable, that
    attribute should be properly declared as `[size]="{{mySizeVariable}}"`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`size`属性没有用括号括起来，因为我们绑定了一个硬编码的值。如果我们想要绑定一个组件变量，那么该属性应该被正确声明为`[size]="{{mySizeVariable}}"`。
- en: We inserted a new DOM element that will show up only when we have hours left.
    We displayed an actual header telling us how many hours we have left, by binding
    the `hoursLeft` property in an H3 DOM element, plus a total estimation in minutes
    for accomplishing all of this contained in the `{{ hoursLeft * 25 }}` expression.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们插入了一个新的DOM元素，只有在剩余小时数时才会显示出来。我们通过在H3 DOM元素中绑定`hoursLeft`属性，显示了一个实际的标题告诉我们剩余多少小时，再加上一个总估计时间，这些都包含在`{{
    hoursLeft * 25 }}`表达式中。
- en: The `ngFor` directive allows us to iterate through the tasks array. In each
    iteration, we render a new `<task-icons>` element.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngFor`指令允许我们遍历tasks数组。在每次迭代中，我们渲染一个新的`<task-icons>`元素。'
- en: We bound the `Task` model object of each iteration, represented by the `queuedTask`
    reference, in the task input property of the`<task-icons>` in the loop template.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在循环模板中将每次迭代的`Task`模型对象，由`queuedTask`引用表示，绑定到了`<task-icons>`的task输入属性中。
- en: We took advantage of the `<task-icons>` element to include additional mouse
    event handlers that point to the following paragraph, which has been flagged with
    the `#tooltip`local reference. So, every time the user hovers the mouse over the
    task icon, the text beneath the icons row will display the respective task name.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用了`<task-icons>`元素来包含额外的鼠标事件处理程序，这些处理程序指向以下段落，该段落已标记为`#tooltip`本地引用。因此，每当用户将鼠标悬停在任务图标上时，图标行下方的文本将显示相应的任务名称。
- en: We ran the extra mile, turning the size of the icon rendered by `<task-icons>`into
    a configurable property as part of the component API. We now have icons that get
    updated in real time as we toggle the information on the table. New problems have
    arisen, however. Firstly, we are displaying icon components matching the hours
    left of each task, without filtering out those that are not queued. On the other
    hand, the overall estimation of time required to achieve all our tasks displays
    the gross number of minutes, and this information will make no sense as we add
    more tasks to the working plan.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们额外努力，将由`<task-icons>`渲染的图标大小作为组件API的可配置属性。我们现在有了实时更新的图标，当我们切换表格上的信息时。然而，新的问题已经出现。首先，我们正在显示与每个任务剩余时间匹配的图标组件，而没有过滤掉那些未排队的图标。另一方面，为了实现所有任务所需的总估计时间，显示的是总分钟数，随着我们添加更多任务，这个信息将毫无意义。
- en: Perhaps, it's time to amend this. It's a good thing that custom pipes have come
    to the rescue!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，现在是时候修改一下了。自定义管道来拯救真是太好了！
- en: Building our own custom pipes
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们自己的自定义管道
- en: We have already seen what pipes are and what their purpose is in the overall
    Angular ecosystem, but now we are going to dive deeper into how we can build our
    own set of pipes to provide custom transformations to data bindings.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了管道是什么，以及它们在整个Angular生态系统中的目的是什么，但现在我们将更深入地了解如何构建我们自己的一组管道，以提供对数据绑定的自定义转换。
- en: Anatomy of a custom pipe
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义管道的解剖
- en: 'Pipes are very easy to define. We essentially need to do the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 定义管道非常容易。我们基本上需要做以下事情：
- en: Import `Pipe` and `PipeTransform`
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入`Pipe`和`PipeTransform`
- en: Implement the `PipeTransform` interface
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`PipeTransform`接口
- en: Add the `Pipe` component to modules
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Pipe`组件添加到模块中
- en: 'The full code for implementing the `Pipe` would look something like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`Pipe`的完整代码看起来像这样：
- en: '[PRE52]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Let's break down the code in the upcoming subsections.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分解即将到来的小节中的代码。
- en: Imports
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入
- en: 'We import the following constructs:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了以下结构：
- en: '[PRE53]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Defining our pipe
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义我们的管道
- en: 'The `Pipe` is a decorator that takes an object literal; we need to at least
    give it a name property:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pipe`是一个装饰器，它接受一个对象文字；我们至少需要给它一个名称属性：'
- en: '[PRE54]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This means that once used, we will refer to its name property like so:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一旦使用，我们将像这样引用它的名称属性：
- en: '[PRE55]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `PipeTransform` is an interface that we need to implement. We can easily
    do so by adding it to our class like so:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`PipeTransform`是我们需要实现的接口。我们可以通过将其添加到我们的类中轻松实现：'
- en: '[PRE56]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here, we can see that we have a transform method, but also the first argument
    being the value itself and the rest is `args`, an array with any number of arguments
    you provide it. We''ve already shown how to use this `Pipe`, but if supplying
    arguments, it looks a little bit different, like so:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们有一个transform方法，但第一个参数是值本身，其余是`args`，一个包含您提供的任意数量参数的数组。我们已经展示了如何使用这个`Pipe`，但是如果提供参数，它看起来有点不同，就像这样：
- en: '[PRE57]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: It is worth noting that for every argument we supply, it ends up in the `args`
    array and we separate it with a colon.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，对于我们提供的每个参数，它最终都会出现在`args`数组中，并且我们用冒号分隔它。
- en: Registering it
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册它
- en: 'To make a construct usable, in this case a pipe, you need to tell the module
    it exists. Just like with components, we need to add to the declarations property
    like so:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要使一个构造可用，比如一个管道，你需要告诉模块它的存在。就像组件一样，我们需要像这样添加到declarations属性中：
- en: '[PRE58]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The pure property
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯属性
- en: 'We can add a property to our `@Pipe` decorator, `pure`, like so:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向我们的`@Pipe`装饰器添加一个属性，`pure`，如下所示：
- en: '[PRE59]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '"Why would we do that in the first place?" you ask. Well, there are situations
    where this might be necessary. If you have a pipe that works on primitives like
    so:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: “为什么我们要这样做？”你问。嗯，有些情况下可能是必要的。如果你有一个像这样处理原始数据的管道：
- en: '[PRE60]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We don''t have an issue. However, if it looks like this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有问题。但是，如果它看起来像这样：
- en: '[PRE61]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We might have a problem. Consider the following code in a component:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会遇到问题。考虑组件中的以下代码：
- en: '[PRE62]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Imagine that we have the following `Pipe` implementation to go with it:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下`Pipe`实现来配合它：
- en: '[PRE63]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This would at first be the output:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这起初会是输出：
- en: '[PRE64]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'However, you expect the output to change to `Chris 38` after 3 seconds, but
    it doesn''t. The pipe only looks at whether the reference have changed or not.
    In this case, it hasn''t because the object is still the same, but a property
    on the object has changed. A way to tell it to react to changes is to specify
    the `pure` property, like we did in the beginning. So, we update our `Pipe` implementation
    to look like this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你期望输出在3秒后改变为`Chris 38`，但它没有。管道只关注引用是否已更改。在这种情况下，它没有，因为对象仍然是相同的，但对象上的属性已更改。告诉它对更改做出反应的方法是指定`pure`属性，就像我们在开始时所做的那样。因此，我们更新我们的`Pipe`实现如下：
- en: '[PRE65]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, we suddenly see the change happen. A word of caution though. This actually
    means the `transform` method is called every time the change detection cycle is
    being triggered. So, this might actually be damaging for performance. You could
    try and cache the value if setting the `pure` property, but you could also try
    to work with reducers and immutable data to solve this in a better way:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们突然看到了变化发生。不过，需要注意的是，这实际上意味着`transform`方法在每次变更检测周期被触发时都会被调用。因此，这对性能可能会造成损害。如果设置`pure`属性，你可以尝试缓存该值，但也可以尝试使用reducer和不可变数据以更好地解决这个问题：
- en: '[PRE66]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The preceding code would change the reference and our Pipe wouldn't kill performance.
    All in all, it's good to know what the pure property does, but be careful.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将更改引用，我们的Pipe不会影响性能。总的来说，了解pure属性的作用是很好的，但要小心。
- en: A custom pipe to better format time output
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好地格式化时间输出的自定义管道
- en: 'Watching the gross number of minutes summed up when lining up tasks to be done
    is not very intuitive, so we need a way to deconstruct this value into hours and
    minutes. Our pipe will have the name `formattedTime` and will be implemented by
    the `formattedTimePipe` class, whose unique transform method receives a number
    representing a total number of minutes and returns a string (proving that pipes
    do not need to return the same type as they receive in the payload) in a readable
    time format:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当排列要完成的任务时，观察总分钟数的增加并不直观，因此我们需要一种方法将这个值分解为小时和分钟。我们的管道将被命名为`formattedTime`，并由`formattedTimePipe`类实现，其唯一的transform方法接收一个表示总分钟数的数字，并返回一个可读的时间格式的字符串（证明管道不需要返回与载荷中接收到的相同类型）。：
- en: '[PRE67]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We should not skip the opportunity to highlight that the naming convention
    for pipes is, the same as we saw with components, the name of the pipe class with
    the `Pipe` suffix plus a selector matching that name without the suffix. Why this
    mismatch between the pipe controller''s class name and the selector? It is common
    practice to prefix the selector strings of our custom pipes and directives with
    a custom prefix in order to prevent collisions with other selectors defined by
    third party pipes and directives:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该错过强调管道的命名约定，与我们在组件中看到的一样，管道类的名称加上`Pipe`后缀，再加上一个与该名称匹配但不带后缀的选择器。为什么管道控制器的类名和选择器之间存在这种不匹配？这是常见的做法，为了防止与第三方管道和指令定义的其他选择器发生冲突，我们通常会给我们自定义管道和指令的选择器字符串添加一个自定义前缀。
- en: '[PRE68]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, we just need to tweak the HTML in the `tasks.html` template file to
    ensure that our EDT expression is properly formatted:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需要调整`tasks.html`模板文件中的HTML，以确保我们的EDT表达式格式正确：
- en: '[PRE69]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now, reload the page and toggle some tasks. The estimated time will be properly
    rendered in hours and minutes.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新加载页面并切换一些任务。预计时间将以小时和分钟正确呈现。
- en: 'Lastly, we must not forget to add our `Pipe` construct to its module `tasks.module.ts`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们不要忘记将我们的`Pipe`构造添加到其模块`tasks.module.ts`中：
- en: '[PRE70]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Filtering out data with custom filters
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义过滤器过滤数据
- en: As we noticed already, we are displaying at this moment an icon component for
    each and every task in the collection served from the tasks service, without filtering
    out what tasks are marked as queued and which aren't. Pipes provide a convenient
    way to map, transform, and digest data bindings, so we can leverage its functionalities
    for filtering out the tasks binding in our `ngFor` loop to return only those tasks
    that are marked as queued.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经注意到的，我们目前为每个任务在从任务服务提供的集合中显示一个图标组件，而没有过滤出哪些任务标记为排队，哪些不是。管道提供了一种方便的方式来映射、转换和消化数据绑定，因此我们可以利用其功能来过滤我们`ngFor`循环中的任务绑定，只返回那些标记为排队的任务。
- en: 'The logic will be pretty simple: since the tasks binding is an array of `Task`
    objects, we just need to make use of the `Array.filter()` method to fetch only
    those `Task` objects whose queued property is set to `true`. We might run the
    extra mile and configure our pipe to take one Boolean argument, indicating whether
    we want to filter out queued or unqueued tasks. The implementation of these requirements
    is as follows, where you can see again the conventions in place for the selector
    and class names:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑将非常简单：由于任务绑定是一个`Task`对象数组，我们只需要利用`Array.filter()`方法来获取那些`queued`属性设置为`true`的`Task`对象。我们可能会额外配置我们的管道以接受一个布尔参数，指示我们是否要过滤出排队或未排队的任务。这些要求的实现如下，您可以再次看到选择器和类名的惯例：
- en: '[PRE71]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The implementation is pretty straightforward, so we will not get into detail
    about it here. However, there is something that is worth highlighting at this
    stage: this is an impure pipe. Bear in mind that the tasks binding is a collection
    of stateful objects that will change in length and content as the user toggles
    tasks on the table. For that reason, we need to instruct the pipe to take advantage
    of Angular''s change detection system so its output is checked by the latter on
    every cycle regardless of whether its input has changed or not. Configuring the
    pure property of the pipe decorator as `false` will do the trick then.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 实现非常简单，所以我们不会在这里详细介绍。然而，在这个阶段有一件值得强调的事情：这是一个不纯的管道。请记住，任务绑定是一个有状态对象的集合，随着用户在表格上切换任务，其长度和内容将发生变化。因此，我们需要指示管道利用Angular的变更检测系统，以便其输出在每个周期都被后者检查，无论其输入是否发生变化。然后，将管道装饰器的`pure`属性配置为`false`就可以解决问题。
- en: 'Now, we just need to update the pipes property of the component using this
    pipe:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要更新使用此管道的组件的pipes属性：
- en: '[PRE72]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Then, update the `ngFor` block in `tasks.html` to properly filter out the unqueued
    tasks:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`tasks.html`中更新`ngFor`块，以正确过滤出未排队的任务：
- en: '[PRE73]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Please check how we configured the pipe as `queuedOnly: true`. Replacing the
    Boolean parameter value by `false` will give us the chance to enlist the tasks
    pertaining to the queues we have not picked.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '请检查我们如何将管道配置为`queuedOnly: true`。将布尔参数值替换为`false`将使我们有机会列出与我们未选择的队列相关的任务。'
- en: Save all your work and reload the page, toggling some tasks then. You will see
    how our overall UI reacts to the latest changes accordingly, and we only enlist
    the icons pertaining to the amount of hours left of queued tasks only.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 保存所有工作并重新加载页面，然后切换一些任务。您将看到我们的整体UI如何根据最新更改做出相应的反应，我们只列出与排队任务的剩余小时数相关的图标。
- en: Building our own custom directives
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们自己的自定义指令
- en: Custom directives encompass a vast world of possibilities and use cases, and
    we would need an entire book for showcasing all the intricacies and possibilities
    they offer.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义指令涵盖了广泛的可能性和用例，我们需要一整本书来展示它们提供的所有复杂性和可能性。
- en: In a nutshell, directives allow you to attach advanced behaviors to elements
    in the DOM. If a directive has a template attached, then it becomes a component.
    In other words, components are Angular directives with a view, but we can build
    directives with no attached views that will be applied to already existing DOM
    elements, making its HTML contents and standard behavior immediately accessible
    to the directive. This applies to Angular components as well, where the directive
    will just access its template and custom attributes and events when necessary.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，指令允许您将高级行为附加到DOM中的元素上。如果指令附有模板，则它将成为一个组件。换句话说，组件是具有视图的Angular指令，但我们可以构建没有附加视图的指令，这些指令将应用于已经存在的DOM元素，使其HTML内容和标准行为立即对指令可用。这也适用于Angular组件，其中指令将在必要时访问其模板和自定义属性和事件。
- en: Anatomy of a custom directive
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义指令的解剖
- en: 'Declaring and implementing a custom directive is pretty easy. We just need
    to import the `Directive` class to provide decorator functionalities to its accompanying
    controller class:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 声明和实现自定义指令非常容易。我们只需要导入`Directive`类，以为其附属的控制器类提供装饰器功能：
- en: '[PRE74]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Then, we define a controller class annotated by the `@Directive`decorator,
    where we will define the directive selector, input and output properties (if required),
    optional events applied to the host element, and injectable provider tokens, should
    our directive''s constructor require specific types to be instantiated by the
    Angular injector when instancing itself (we will cover this in detail in [Chapter
    6](93b8f637-859e-4e12-aaa0-4cec5f02c2c3.xhtml), *Building an Application with
    Angular Components*):'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个由`@Directive`装饰器注释的控制器类，在其中我们将定义指令选择器、输入和输出属性（如果需要）、应用于宿主元素的可选事件，以及可注入的提供者令牌，如果我们的指令构造函数在实例化时需要特定类型由Angular注入器实例化自己（我们将在[第6章](93b8f637-859e-4e12-aaa0-4cec5f02c2c3.xhtml)中详细介绍这一点，*使用Angular组件构建应用程序*）：
- en: 'Let''s warm up by creating a very simple directive:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个非常简单的指令来热身：
- en: '[PRE75]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'And to use it is as simple as typing:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它就像输入一样简单：
- en: '[PRE76]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We use two actors here, `ElementRef` and `Renderer2`, to manipulate the underlying
    element. We could use `elementRef.nativeElement` directly, but this is discouraged
    as this might break server side rendering or when interacting with service workers.
    Instead, we do all manipulations using an instance of `Renderer2`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了两个actor，`ElementRef`和`Renderer2`，来操作底层元素。我们可以直接使用`elementRef.nativeElement`，但这是不鼓励的，因为这可能会破坏服务器端渲染或与服务工作者交互时。相反，我们使用`Renderer2`的实例进行所有操作。
- en: Notice how we don't type the square bracket, but only the selector name.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们不输入方括号，而只输入选择器名称。
- en: A quick recap of what we did here was to inject the `ElementRef` and access
    the `nativeElement` property, which is the actual element. We also put a `@Directive`decorator
    on a class just like we do with components and pipes. The main mindset to have
    when creating directives is to think reusable functionality that not necessarily
    relates to a certain feature. The topic chosen previously was highlighting, but
    we could build other functionalities such as tooltip and collapsible or infinite
    scrolling features with relative ease.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里快速回顾了一下，注入了`ElementRef`并访问了`nativeElement`属性，这是实际元素。我们还像在组件和管道上一样，在类上放置了一个`@Directive`装饰器。创建指令时要有的主要思维方式是考虑可重用的功能，不一定与某个特定功能相关。之前选择的主题是高亮，但我们也可以相对容易地构建其他功能，比如工具提示、可折叠或无限滚动功能。
- en: 'Properties and decorators'' such as selector, `@Input()`, or `@Output()`(same
    with inputs and outputs) will probably resonate to you from the time when we overviewed
    the component decorator spec. Although we haven''t mentioned all the possibilities
    in detail yet, the selector may be declared as one of the following:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 属性和装饰器，比如选择器、`@Input()`或`@Output()`（与输入和输出相同），可能会让您回想起我们概述组件装饰器规范时的时间。尽管我们尚未详细提到所有可能性，但选择器可以声明为以下之一：
- en: '`element-name`: Select by element name'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`element-name`: 通过元素名称选择'
- en: '`.class`: Select by class name'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.class`: 通过类名选择'
- en: '`[attribute]`: Select by attribute name'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[attribute]`: 通过属性名称选择'
- en: '`[attribute=value]`: Select by attribute name and value'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[attribute=value]`: 通过属性名称和值选择'
- en: '`not(sub_selector)`: Select only if the element does not match the'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`not(sub_selector)`: 仅在元素不匹配时选择'
- en: '`sub_selector`'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`sub_selector`'
- en: '`selector1`, `selector2`: Select if either `selector1` or `selector2` matches'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selector1`, `selector2`: 如果`selector1`或`selector2`匹配，则选择'
- en: 'In addition to this, we will find the host parameter, which specifies the events,
    actions, properties, and attributes pertaining to the host element (that is, the
    element where our directive takes action) that we want to access from within the
    directive. We can therefore take advantage of this parameter to bind interaction
    handlers against the container component or any other target element of our choice,
    such as window, document, or body. In this way, we can refer to two very convenient
    local variables when writing a directive event binding:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们还会找到主机参数，该参数指定了与主机元素（即我们指令执行的元素）相关的事件、动作、属性和属性，我们希望从指令内部访问。因此，我们可以利用这个参数来绑定与容器组件或任何其他目标元素（如窗口、文档或主体）的交互处理程序。这样，当编写指令事件绑定时，我们可以引用两个非常方便的本地变量：
- en: '`$event`: This is the current event object that triggered the event.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$event`: 这是触发事件的当前事件对象。'
- en: '`$target`: This is the source of the event. This will be either a DOM element
    or an Angular directive.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$target`: 这是事件的来源。这将是一个DOM元素或一个Angular指令。'
- en: Besides events, we can update specific DOM properties that belong to the host
    component. We just need to link any specific property wrapped in braces with an
    expression handled by the directive as a key-value pair in our directive's host
    definition.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 除了事件，我们还可以更新属于主机组件的特定DOM属性。我们只需要将任何特定属性用大括号括起来，并在我们指令的主机定义中将其作为键值对与指令处理的表达式链接起来。
- en: The optional host parameter can also specify static attributes that should be
    propagated to a host element, if not present already. This is a convenient way
    of injecting HTML properties with computed values.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的主机参数还可以指定应传播到主机元素的静态属性，如果尚未存在。这是一种方便的方式，可以使用计算值注入HTML属性。
- en: 'The Angular team has also made available a couple of convenient decorators
    so that we can more expressively declare our host bindings and listeners straight
    on the code, like this:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Angular团队还提供了一些方便的装饰器，这样我们就可以更加直观地在代码中声明我们的主机绑定和监听器，就像这样：
- en: '[PRE77]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In the next chapters, we will cover the configuration interface of directives
    and components in more detail, paying special attention to its life cycle management
    and how we can easily inject dependencies into our directives. For now, let's
    just build a simple, yet powerful, directive that will make a huge difference
    to how our UI is displayed and maintained.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更详细地介绍指令和组件的配置接口，特别关注它的生命周期管理以及我们如何轻松地将依赖项注入到我们的指令中。现在，让我们只是构建一个简单但强大的指令，它将对我们的UI的显示和维护产生巨大的影响。
- en: Listening to events
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听事件
- en: 'So far, we were able to create our first directive, but it wasn''t very interesting.
    Adding the ability to listen to events, however, would make it more interesting,
    so let''s do that. We will need to use a helper called `HostListener` to listen
    to events, so we start by importing that:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经能够创建我们的第一个指令，但这并不是很有趣。然而，添加监听事件的能力会使它变得更有趣，所以让我们来做吧。我们需要使用一个叫做`HostListener`的辅助工具来监听事件，所以我们首先要导入它：
- en: '[PRE78]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The next thing we need to do is to use it as a decorator and decorate a method;
    yes, a method, not a class. That would look like the following:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的下一件事是将它用作装饰器并装饰一个方法；是的，一个方法，而不是一个类。它看起来像下面这样：
- en: '[PRE79]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Clicking on an element using this directive will lead to an alert window showing
    up. It was quite painless to add events, so let''s try to add the events `mouseover` and `mouseleave`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个指令点击一个元素将会导致一个警告窗口弹出。添加事件非常简单，所以让我们尝试添加`mouseover`和`mouseleave`事件：
- en: '[PRE80]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This gives us a directive that makes the background `red` on `mouseover` and
    reverts back to `yellow` when the mouse cursor leaves the component.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们一个指令，当鼠标悬停在组件上时，背景会变成`红色`，当鼠标离开时会恢复为`黄色`。
- en: Adding input data
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加输入数据
- en: 'Our directive is quite static on what colors are being used for what, so let''s
    ensure that they can be set from the outside. To add the first input, we need
    to use our old friend the `@Input` decorator, but instead of giving it no parameters
    as input as we are used to, we need to supply the name of the directive itself
    like so:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的指令对于使用什么颜色是相当静态的，所以让我们确保它们可以从外部设置。要添加第一个输入，我们需要使用我们的老朋友`@Input`装饰器，但是不像我们习惯的那样不给它任何参数作为输入，我们需要提供指令本身的名称，如下所示：
- en: '[PRE81]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'At this point, we have taken care of the first input; we did that with the
    following:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经处理了第一个输入；我们用以下方法做到了这一点：
- en: '[PRE82]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: But, how do we add more inputs to our directive? We'll cover that in the next
    subsection.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们如何向我们的指令添加更多的输入？我们将在下一小节中介绍这个问题。
- en: Adding more than one input property
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加多个输入属性
- en: 'So you want to add another input, that is relatively easy as well. We just
    add a property to our HTML element like so:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你想要添加另一个输入，这也相对容易。我们只需要在我们的HTML元素中添加一个属性，如下所示：
- en: '[PRE83]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'And in the code we type:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中我们输入：
- en: '[PRE84]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We notice, however, that we have no color until we do our first `mousenter`
    + `mouseleave` and the reason for that is that the constructor runs before our
    `defaultColor` property has been set. To fix that, we need to set up the input
    a bit differently. We need to use a property instead like so:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们注意到在我们进行第一次`mousenter` + `mouseleave`之前，我们没有颜色，原因是构造函数在我们的`defaultColor`属性被设置之前运行。为了解决这个问题，我们需要稍微不同地设置输入。我们需要像这样使用一个属性：
- en: '[PRE85]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: To recap this section on using input, it is clear that we can use the `@Input`
    decorator for both one as well as several inputs. The first input, however, should
    refer to the selector name of the directive and the second is the name of the
    attribute you give it.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下关于使用输入的部分，很明显我们可以使用`@Input`装饰器来处理一个或多个输入。然而，第一个输入应该是指令的选择器名称，第二个输入是你给它的属性的名称。
- en: A second example – error validation
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二个例子 - 错误验证
- en: 'Let''s take this new found knowledge on directives and build a directive that
    indicates that a field is erroneous. We take erroneous to mean we color elements
    and display an error text:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用对指令的这些新知识，构建一个指示字段错误的指令。我们认为错误是指我们着色元素并显示错误文本：
- en: '[PRE86]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'And to use it we just type:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 而要使用它，我们只需输入：
- en: '[PRE87]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Building a task tooltip custom directive
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个任务提示自定义指令
- en: So far, we have built a highlight directive as well as an error displaying directive.
    We've learned how to deal with events as well as multiple inputs.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经构建了一个高亮指令以及一个错误显示指令。我们已经学会了如何处理事件以及多个输入。
- en: 'A short word on tooltip. A tooltip appears when we hover over an element. What
    you normally do to achieve that is to set the title property on the element like
    so:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 关于提示信息的简短说明。当我们悬停在一个元素上时，会出现提示信息。通常你要做的是在元素上设置title属性，就像这样：
- en: '[PRE88]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'There are several approaches to build tooltips generally over such a component.
    One way is to bind to the `title` property like so:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有几种方法可以在这样的组件上构建提示信息。一种方法是绑定到`title`属性，就像这样：
- en: '[PRE89]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'However, if you have more logic in mind it might not be so nice to add all
    that in the markup, so at this point, we can create a directive to hide away the
    tooltip bit like so:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你有更多的逻辑想法，将所有内容都添加到标记中可能不太好，所以在这一点上，我们可以创建一个指令来隐藏提示信息，就像这样：
- en: '[PRE90]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'And using it would be:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它将是：
- en: '[PRE91]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'However, there is another approach we can take to this. What if we wanted to
    alter the `innerText` of another element while hovering over an element? That''s
    quite easy to do, we just need to feed our directive the other element and update
    its `innerText` property like so:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还可以采取另一种方法。如果我们想在悬停在一个元素上时改变另一个元素的innerText呢？这是很容易做到的，我们只需要将我们的指令传递给另一个元素，并更新它的innerText属性，就像这样：
- en: '[PRE92]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This of course means we need to update our directive a little bit to this:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这意味着我们需要稍微更新我们的指令到这样：
- en: '[PRE93]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: A word about naming conventions for custom directives and pipes
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于自定义指令和管道的命名约定
- en: Talking about reusability, the common convention is to prepend a custom prefix
    to the selector. This prevents conflicts with other selectors defined by other
    libraries that we might be using in our project. The same applies to pipes as
    well, as we highlighted already when introducing our very first custom pipe.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到可重用性，通常的约定是在选择器前面添加一个自定义前缀。这可以防止与其他库定义的选择器发生冲突，这些库可能在我们的项目中使用。同样的规则也适用于管道，正如我们在介绍我们的第一个自定义管道时已经强调的那样。
- en: Ultimately, it is up to you and the name convention you embrace, but it is generally
    a good idea to establish a naming convention that prevents this from happening.
    A custom prefix is definitely the easier way.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这取决于你和你采用的命名约定，但建立一个可以防止这种情况发生的命名约定通常是一个好主意。自定义前缀绝对是更容易的方法。
- en: Summary
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Now that we have reached this point, it is fair to say that you know almost
    everything it takes to build Angular components, which are indeed the wheels and
    the engine of all Angular 2 applications. In the forthcoming chapters, we will
    see how we can design our application architecture better, and therefore manage
    dependency injection throughout our components tree, consume data services, leverage
    the new Angular router to show and hide components when required, and manage user
    input and authentication.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经达到这一点，可以说你几乎知道构建Angular组件所需的一切，这些组件确实是所有Angular 2应用程序的核心和引擎。在接下来的章节中，我们将看到如何更好地设计我们的应用程序架构，因此在整个组件树中管理依赖注入，使用数据服务，利用新的Angular路由器在需要时显示和隐藏组件，并管理用户输入和身份验证。
- en: Nevertheless, this chapter is the backbone of Angular development, and we hope
    that you enjoyed it as much as we did when writing about template syntax, component
    APIs based on properties and events, view encapsulation, pipes, and directives.
    Now, get ready to assume new challenges—we are about to move from learning how
    to write components to discovering how we can use them to build bigger applications,
    while enforcing good practices and rational architectures. We will see all this
    in the next chapter.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这一章是Angular开发的支柱，我们希望您和我们一样喜欢它，当我们写关于模板语法、基于属性和事件的组件API、视图封装、管道和指令时。现在，准备好迎接新的挑战——我们将从学习如何编写组件转向发现如何使用它们来构建更大的应用程序，同时强调良好的实践和合理的架构。我们将在下一章中看到所有这些。
