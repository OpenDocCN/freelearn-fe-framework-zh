- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Understanding GraphQL with a Real Project
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过真实项目理解GraphQL
- en: '**GraphQL** is a powerful query language designed to work seamlessly with APIs,
    allowing them to efficiently interact with your existing data. Unlike traditional
    REST APIs, GraphQL provides a comprehensive overview of the data in your API,
    making it easy to request only the exact data you need and nothing more. This
    not only streamlines your API requests but also makes it easier to optimize and
    improve your APIs when necessary. Additionally, GraphQL comes equipped with powerful
    developer tools to further enhance your development experience.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**GraphQL**是一种强大的查询语言，旨在与API无缝协作，使它们能够高效地与现有数据交互。与传统REST API不同，GraphQL提供了API中数据的全面概述，使得请求所需的确切数据变得容易，而不需要更多。这不仅简化了API请求，而且在必要时也使得优化和改进API变得更加容易。此外，GraphQL还配备了强大的开发者工具，以进一步增强您的开发体验。'
- en: In this chapter, we’ll delve into the practical application of GraphQL by building
    a basic login and user registration system for a real-world project. By exploring
    how GraphQL can be utilized in this context, you’ll gain a comprehensive understanding
    of the language and be able to apply it effectively in your own projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨GraphQL的实际应用，通过为现实世界项目构建基本的登录和用户注册系统。通过探索GraphQL在此环境下的应用，您将全面了解该语言，并能够在自己的项目中有效地应用它。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Installing PostgreSQL
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装PostgreSQL
- en: Creating environment variables with a `.env` file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `.env` 文件创建环境变量
- en: Configuring Apollo Server
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Apollo Server
- en: Defining GraphQL queries and mutations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义GraphQL查询和突变
- en: Working with resolvers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用解析器进行工作
- en: Creating Sequelize models
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Sequelize模型
- en: Implementing JWT
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现JWT
- en: Using GraphQL Playground
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GraphQL Playground
- en: Performing authentication
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行身份验证
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you will need the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，您需要以下内容：
- en: Node.js 19+
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 19+
- en: Visual Studio Code
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: PostgreSQL
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: Homebrew ([https://brew.sh](https://brew.sh))
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Homebrew ([https://brew.sh](https://brew.sh))
- en: pgAdmin 4 ([https://www.pgadmin.org/download/](https://www.pgadmin.org/download/))
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pgAdmin 4 ([https://www.pgadmin.org/download/](https://www.pgadmin.org/download/))
- en: You can find the code for this chapter in this book’s GitHub repository at [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter13).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub仓库中找到本章的代码：[https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter13)。
- en: Building a backend login system using PostgreSQL, Apollo Server, GraphQL, Sequelize,
    and JSON Web Tokens
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PostgreSQL、Apollo Server、GraphQL、Sequelize和JSON Web Tokens（JWT）构建后端登录系统
- en: In this section, we will be building a backend login system using PostgreSQL,
    Apollo Server, GraphQL, Sequelize, and **JSON Web Tokens** (**JWTs**). We will
    utilize PostgreSQL for data storage, Sequelize to perform database operations,
    Apollo Server to create a GraphQL API, GraphQL to shape our API, and JWTs for
    user authentication and authorization. Whether you are a beginner or an experienced
    developer, this guide will offer a comprehensive understanding of how to integrate
    these technologies into a robust and secure backend login system. Let us dive
    in.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用PostgreSQL、Apollo Server、GraphQL、Sequelize和**JSON Web Tokens**（**JWTs**）构建后端登录系统。我们将利用PostgreSQL进行数据存储，Sequelize执行数据库操作，Apollo
    Server创建GraphQL API，GraphQL塑造我们的API，JWTs用于用户身份验证和授权。无论您是初学者还是有经验的开发者，本指南将全面了解如何将这些技术集成到一个强大且安全的后端登录系统中。让我们开始吧。
- en: Installing PostgreSQL
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装PostgreSQL
- en: For this example, we will use a PostgreSQL database, so you’ll need to install
    PostgreSQL to be able to run this project on your machine.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将使用PostgreSQL数据库，因此您需要安装PostgreSQL才能在您的机器上运行此项目。
- en: PostgreSQL is an excellent choice for our database. *Why?* It excels in keeping
    data secure and well organized, even in the event of an unexpected issue. It has
    the capability to handle various types of data, which proves to be extremely convenient.
    Additionally, PostgreSQL is extensible, enabling it to go beyond the basics. It
    operates efficiently and can manage a substantial number of users concurrently.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL是我们数据库的一个优秀选择。*为什么？*它在保持数据安全和井然有序方面表现出色，即使在意外问题发生时也是如此。它能够处理各种类型的数据，这证明非常方便。此外，PostgreSQL是可扩展的，使其能够超越基础功能。它运行高效，可以同时管理大量用户。
- en: Moreover, it boasts robust security features that ensure the protection of our
    data. Being an open-source platform, it is not only free but also benefits from
    a large community actively working toward its improvement. If you have prior experience
    with other databases, PostgreSQL is easy to comprehend, as it adheres to the same
    standards. Furthermore, it can handle considerable amounts of data and accommodate
    numerous users simultaneously. This is precisely why it stands as a reliable choice
    for projects such as our login system.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它拥有强大的安全特性，确保我们的数据得到保护。作为一个开源平台，它不仅免费，还能从大量积极致力于其改进的社区中受益。如果你有其他数据库的先前经验，PostgreSQL很容易理解，因为它遵循相同的标准。此外，它能够处理大量数据，并能够同时容纳众多用户。这正是它成为我们登录系统等项目的可靠选择的原因。
- en: 'If you have a macOS machine, the easiest way to install PostgreSQL is by doing
    so with Homebrew. You just need to run the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一台macOS机器，通过Homebrew安装PostgreSQL是最简单的方法。你只需要运行以下命令：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once you’ve installed it, you need to run the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你需要运行以下命令：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This command creates a symbolic link (a type of shortcut) from the PostgreSQL
    `plist` files (which are configuration files used by macOS) to your `~/Library/LaunchAgents`
    directory. The options used with the `ln -sfv` command are as follows: “**s**”
    for **symbolic** (to create a symbolic link), “**f**” for **force** (to remove
    existing destination files), and “**v**” for **verbose** (to display what is happening).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令创建了一个从PostgreSQL `plist`文件（macOS使用的配置文件）到你的`~/Library/LaunchAgents`目录的符号链接（一种快捷方式）。`ln
    -sfv`命令使用的选项如下：“**s**”代表**符号**（创建符号链接），“**f**”代表**强制**（删除现有的目标文件），以及“**v**”代表**详细**（显示正在发生的事情）。
- en: 'Then, you can create two new aliases to start and stop your PostgreSQL server:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以创建两个新的别名来启动和停止你的PostgreSQL服务器：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, you should be able to start your PostgreSQL server by using `pg_start`
    or stop it with `pg_stop`. After this, you need to create your first database,
    like so:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该可以使用`pg_start`启动你的PostgreSQL服务器，或者使用`pg_stop`停止它。之后，你需要创建你的第一个数据库，如下所示：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, you can connect to PostgreSQL using the `psql` command. If you get an
    error stating the role `"postgresql`" does not exist, you can fix it by running
    the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用`psql`命令连接到PostgreSQL。如果你收到一个错误，指出角色`"postgresql"`不存在，你可以通过运行以下命令来修复它：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you did everything correctly, you should see something like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一切操作正确，你应该会看到类似以下的内容：
- en: '![A black screen with white text  Description automatically generated](img/B18414_13_01.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![一个黑色屏幕上带有白色文字的图片 自动生成描述](img/B18414_13_01.png)'
- en: 'Figure 13.1: psql'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1：psql
- en: If you use Windows, you can download PostgreSQL at [https://www.postgresql.org/download/windows/](https://www.postgresql.org/download/windows/)
    and for those that use Linux (Ubuntu), you can download it from [https://www.postgresql.org/download/linux/ubuntu/](https://www.postgresql.org/download/linux/ubuntu/).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Windows，你可以从[https://www.postgresql.org/download/windows/](https://www.postgresql.org/download/windows/)下载PostgreSQL，而对于使用Linux（Ubuntu）的用户，你可以从[https://www.postgresql.org/download/linux/ubuntu/](https://www.postgresql.org/download/linux/ubuntu/)下载。
- en: Best tools for PostgreSQL database management
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PostgreSQL数据库管理的最佳工具
- en: The best tool for PostgreSQL database management is **pgAdmin 4** ([https://www.pgadmin.org/download/](https://www.pgadmin.org/download/)).
    I like this tool as it can be used to create new servers, users, and databases
    and can be used to perform SQL queries and work with data. Remember to create
    a database in order to use it in this example.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL数据库管理的最佳工具是**pgAdmin 4** ([https://www.pgadmin.org/download/](https://www.pgadmin.org/download/))。我喜欢这个工具，因为它可以用来创建新的服务器、用户和数据库，也可以用来执行SQL查询和处理数据。记住，为了在这个例子中使用它，你需要创建一个数据库。
- en: 'Sometimes, you may get an error when you start your PostgreSQL server that
    could say something like **FATAL lock file “postmaster.pid” already exists.**
    If you get this error, you can easily fix it by running the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当你启动 PostgreSQL 服务器时，可能会遇到错误，可能会说类似 **FATAL 锁文件“postmaster.pid”已存在** 的话。如果你遇到这个错误，你可以通过运行以下命令轻松修复它：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With this, you will be able to start your PostgreSQL server.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个方法，你将能够启动你的 PostgreSQL 服务器。
- en: Now that we have completed the setup of PostgreSQL and have the pgAdmin tool
    available for easier database management, we can shift our focus to the next task,
    which is building our backend project.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了 PostgreSQL 的设置，并且有了 pgAdmin 工具来简化数据库管理，我们可以将注意力转移到下一个任务，即构建我们的后端项目。
- en: Creating our backend project
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的后端项目
- en: 'First, you need to create a backend directory in your GraphQL project (`graphql/backend`).
    After that, let’s review the huge list of NPM packages you will need to install
    (focusing on the most relevant):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要在你的 GraphQL 项目中创建一个后端目录（`graphql/backend`）。然后，让我们回顾一下你需要安装的大量 NPM 软件包（重点关注最相关的）：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Please note that some readers of my last book encountered issues with certain
    code that did not work as intended. This is due to updates to package versions
    since the time of writing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我上一本书的一些读者遇到了某些代码的问题，这些代码没有按预期工作。这是由于自写作以来软件包版本的更新导致的。
- en: To ensure that the code in this book functions correctly, I have specified the
    specific versions of packages that I use. It’s important to note that newer versions
    of these packages may contain breaking changes that could impact the functionality
    of the code, so it’s recommended that you use the specified versions to avoid
    any issues.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这本书中的代码能够正确运行，我已经指定了我使用的特定版本的软件包。需要注意的是，这些软件包的新版本可能包含破坏性更改，可能会影响代码的功能，因此建议你使用指定的版本以避免任何问题。
- en: 'The scripts you should have in your `package.json` file should be as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在 `package.json` 文件中拥有的脚本如下：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the next section, we are going to configure our environment variables.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将配置我们的环境变量。
- en: Configuring our .env file
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置我们的 .env 文件
- en: A `.env` file (also known as *dotenv*) is a configuration file to specify your
    application’s environment variables. Normally your application won’t change in
    development, staging, or production environments but they normally need a different
    configuration. The most common variables to change are the base URL, API URL,
    or even your API keys.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`.env` 文件（也称为 *dotenv*）是一个配置文件，用于指定应用程序的环境变量。通常情况下，你的应用程序在开发、预发布或生产环境中不会改变，但它们通常需要不同的配置。最常更改的变量是基本
    URL、API URL，甚至 API 密钥。'
- en: 'Before we jump into the actual login code, we need to create a file called
    `.env` (normally, this file is ignored by **.gitignore**), which will allow us
    to use private data, such as the database connection and security secrets. A file
    already exists in the repository called **.env.example**; you just need to rename
    it and put your connection data inside it. The `.env file` will look something
    like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究实际的登录代码之前，我们需要创建一个名为 `.env` 的文件（通常，这个文件被 **.gitignore** 忽略），这将允许我们使用私有数据，例如数据库连接和安全机密。仓库中已经存在一个名为
    **.env.example** 的文件；你只需要将其重命名并将你的连接数据放入其中。`.env 文件` 将看起来像这样：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Creating a basic config file
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个基本的配置文件
- en: For this project, we need to create a config file to store some security data,
    which should be created at **/backend/config/config.json**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们需要创建一个配置文件来存储一些安全数据，它应该创建在 **/backend/config/config.json**。
- en: 'Here, we will define some basic configurations, such as our server’s port and
    some security information:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将定义一些基本配置，例如我们的服务器端口和一些安全信息：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, you need to create an **index.ts** file in the config directory. This
    will bring in all the database connection information we defined in the `.env`
    file using the dotenv package and then export three configuration variables called
    **$db**, **$security**, and **$server**:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要在配置目录中创建一个 **index.ts** 文件。这将引入我们在 `.env` 文件中定义的所有数据库连接信息，然后导出三个配置变量，分别称为
    **$db**、**$security** 和 **$server**：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If your `.env` file is not in the `root` directory or does not exist, all your
    variables are going to be **undefined**.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 `.env` 文件不在 `root` 目录中或不存在，所有你的变量都将被 **未定义**。
- en: Once you have configured your file and verified the security details of your
    project, the subsequent step toward enhancing our project involves the utilization
    and setup of Apollo Server. This invaluable tool facilitates the management of
    data exchanges between your server and client, streamlining the communication
    process.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您配置了文件并验证了项目的安全细节，接下来增强我们项目的步骤就涉及到利用和设置 Apollo Server。这个无价工具促进了服务器和客户端之间数据交换的管理，简化了通信过程。
- en: Configuring Apollo Server
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Apollo Server
- en: Apollo Server is a highly popular open-source library for working with GraphQL,
    both as a server and client. With extensive documentation and straightforward
    implementation, it has become a go-to choice for many developers. Its intuitive
    interface and flexible architecture make it easy to customize and adapt to your
    specific needs, while its robust features and reliable performance ensure seamless
    integration with your existing code base. Whether you’re a seasoned developer
    or new to GraphQL, Apollo Server is a powerful tool that can help you take your
    projects to the next level.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo Server 是一个高度流行的开源库，用于处理 GraphQL，无论是作为服务器还是客户端。凭借广泛的文档和简单的实现，它已成为许多开发者的首选。其直观的界面和灵活的架构使其易于定制和适应您的特定需求，同时其强大的功能和可靠的表现确保了与现有代码库的无缝集成。无论您是经验丰富的开发者还是
    GraphQL 新手，Apollo Server 都是一个强大的工具，可以帮助您将项目提升到新的水平。
- en: 'The following diagram explains how Apollo Server works in the client and the
    server:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表解释了 Apollo Server 在客户端和服务器中的工作方式：
- en: '![Diagram  Description automatically generated](img/B18414_13_02.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B18414_13_02.png)'
- en: 'Figure 13.2: Apollo Server'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2：Apollo Server
- en: Apollo Server facilitates efficient communication between your app or website
    and the associated database. By utilizing GraphQL, it enables the frontend part
    of your app to request specific data from the backend in a single operation, resulting
    in a faster and smoother data exchange. In essence, it serves as an effective
    intermediary between your user interface and the database.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo Server 促进了您的应用程序或网站与相关数据库之间的有效通信。通过利用 GraphQL，它允许您的应用程序的前端部分在单个操作中从后端请求特定的数据，从而实现更快、更流畅的数据交换。本质上，它充当了用户界面和数据库之间的有效中介。
- en: For our setup, we will use Express to establish our Apollo Server and the Sequelize
    **Object Relational Mapper** (**ORM**) to handle our PostgreSQL database. Express
    is a popular choice to configure Apollo Server due to its seamless integration
    with Apollo and its flexibility, which provides developers with greater freedom.
    Express.js is a lightweight and performance-optimized framework suitable for applications
    of various sizes, from small to large and scalable ones. Moreover, its maturity
    and extensive community support make it a reliable option. Its simplicity, especially
    for those already familiar with JavaScript and Node.js, enables a quick and efficient
    Apollo Server setup. Therefore, we will begin by importing the necessary components.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的设置，我们将使用 Express 来建立我们的 Apollo Server，并使用 Sequelize **对象关系映射器**（**ORM**）来处理我们的
    PostgreSQL 数据库。由于 Express 与 Apollo 的无缝集成及其灵活性，它成为配置 Apollo Server 的流行选择，这为开发者提供了更大的自由度。Express.js
    是一个轻量级且性能优化的框架，适用于从小型到大型和可扩展的各种规模的应用程序。此外，它的成熟度和广泛的社区支持使其成为一个可靠的选择。它的简单性，特别是对于那些已经熟悉
    JavaScript 和 Node.js 的人来说，使得 Apollo Server 的设置快速而高效。因此，我们将首先导入必要的组件。
- en: 'The required file can be found at `/backend/src/index.ts`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的文件可以在 `/backend/src/index.ts` 找到：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'First, we need to set up our `Express.js application` and `cors`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置我们的 `Express.js 应用程序` 和 `cors`：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we need to create our schema using `applyMiddleware` and `makeExecutableSchema`
    by passing `typeDefs` and `resolvers`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要使用 `applyMiddleware` 和 `makeExecutableSchema` 通过传递 `typeDefs` 和 `resolvers`
    来创建我们的模式：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After that, we need to create an instance of Apollo Server, where we need to
    pass the schema and the plugins:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要创建一个 Apollo Server 的实例，其中我们需要传递模式和插件：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we need to synchronize Sequelize. Here, we pass some optional variables
    (`alter` and `force`). If `force` is true and you change your Sequelize models,
    this will delete your tables, including their values, and force you to create
    the tables again, while if `force` is `false` and `alter` is `true`, then you
    will only update the table fields, without this affecting your values. So, you
    need to be careful with this option, as you can lose all your data by accident.
    Then, after the sync, we must run our Apollo Server, which listens to port `4000`
    (**$server.port**):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要同步 Sequelize。在这里，我们传递一些可选变量（`alter` 和 `force`）。如果 `force` 为真并且你更改了 Sequelize
    模型，这将删除你的表，包括它们的值，并强制你再次创建表，而如果 `force` 为 `false` 且 `alter` 为 `true`，那么你将只更新表字段，而不会影响你的值。因此，你需要小心这个选项，因为你不小心可能会丢失所有数据。然后，在同步之后，我们必须运行我们的
    Apollo Server，它监听端口 `4000`（**$server.port**）：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This process will help us in synchronizing our database with our models, ensuring
    that any modifications made to the models will automatically update the corresponding
    tables.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程将帮助我们同步数据库与模型，确保对模型所做的任何修改都将自动更新相应的表。
- en: Defining our GraphQL types, queries, and mutations
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义我们的 GraphQL 类型、查询和变异
- en: Now that you have created your Apollo Server instance, the next step is to create
    your GraphQL types. When setting up a GraphQL server like Apollo, creating GraphQL
    types is crucial. These types ensure that the data returned from your API is reliable
    and conforms to the expected structure. They act as a helpful reference for available
    data and its expected format. By using types, your application can precisely request
    the required data, resulting in faster execution and reduced data consumption.
    Additionally, types help maintain data consistency, resulting in a robust, comprehensible,
    and efficient API.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了 Apollo Server 实例，下一步是创建你的 GraphQL 类型。在设置像 Apollo 这样的 GraphQL 服务器时，创建
    GraphQL 类型至关重要。这些类型确保从你的 API 返回的数据是可靠的，并符合预期的结构。它们作为可用数据和其预期格式的有用参考。通过使用类型，你的应用程序可以精确地请求所需的数据，从而实现更快的执行和减少数据消耗。此外，类型有助于维护数据一致性，从而实现强大、易于理解且高效的
    API。
- en: Scalar types
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标量类型
- en: 'The first thing you need to do is define your scalar types at `/backend/src/graphql/types/Scalar.ts`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的第一件事是在 `/backend/src/graphql/types/Scalar.ts` 中定义你的标量类型：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let’s create our `User` type (`backend/src/graphql/types/User.ts`):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的 `User` 类型（`backend/src/graphql/types/User.ts`）：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, we use some scalar types such as **UUID** and **Datetime** to
    define some fields in our `User` type. In this case, when you define a type in
    GraphQL, you need to do so with the `type` keyword, followed by the type’s name
    capitalized. Then, you can define your fields inside the curly braces, `{}`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用了一些标量类型，如 **UUID** 和 **Datetime**，来定义 `User` 类型中的某些字段。在这种情况下，当你定义 GraphQL
    中的类型时，你需要使用 `type` 关键字，后跟类型名称的首字母大写。然后，你可以在大括号 `{}` 内定义你的字段。
- en: There are some primitive data types in GraphQL such as `String`, `Boolean`,
    `Float`, and `Int`. You can define custom scalar types as we did with **UUID**,
    **Datetime**, and **JSON**, and you can also define custom types such as the `User`
    type and specify whether we want an array of that type, for example, `[User]`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 中有一些原始数据类型，例如 `String`、`Boolean`、`Float` 和 `Int`。你可以定义自定义标量类型，就像我们定义
    **UUID**、**Datetime** 和 **JSON** 一样，你也可以定义自定义类型，例如 `User` 类型，并指定我们是否想要该类型的数组，例如
    `[User]`。
- en: The `!` character after the types means the field is non-nullable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 类型后面的 `!` 字符表示字段不可为空。
- en: Queries
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询
- en: 'GraphQL queries are used to read or fetch values from a data store. Now that
    you know how to define custom types, let’s define our `Query` type. Here, we will
    define `getUsers` and `getUser`. The first will retrieve a list of users, while
    the second will bring us the data of the specific user:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 查询用于从数据存储中读取或获取值。现在你知道如何定义自定义类型，让我们定义我们的 `Query` 类型。在这里，我们将定义 `getUsers`
    和 `getUser`。第一个将检索用户列表，而第二个将提供特定用户的详细信息：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this case, our `getUsers` query will return an array of users (`[User!]`),
    while our `getUser` query, which requires the `at` (access token) attribute, will
    return a single `User!`. Remember that with any query you add here, you will need
    to define it under your `resolvers` later (we will do that in the next section).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的 `getUsers` 查询将返回用户数组（`[User!]`），而我们的 `getUser` 查询，它需要 `at`（访问令牌）属性，将返回单个
    `User!`。记住，对于你添加的任何查询，你都需要在后面的 `resolvers` 中定义它（我们将在下一节中这样做）。
- en: Mutations
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变异
- en: 'Mutations are used to write or post values: that is, to modify data in the
    data store: and return a value if you want to do some comparisons with `REST`,
    such as perform any `POST`, `PUT`, `PATCH`, or `DELETE` actions. The `Mutation`
    type works exactly the same as the `Query` type, in that you need to define your
    mutations and specify what arguments you will receive and what data you will return:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 突变用于写入或发布值：也就是说，修改数据存储中的数据，如果你想要与 `REST` 进行一些比较，例如执行任何 `POST`、`PUT`、`PATCH`
    或 `DELETE` 操作，你可以返回一个值。`Mutation` 类型与 `Query` 类型的工作方式完全相同，你需要定义你的突变并指定你将接收什么参数以及返回什么数据：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, we have defined two mutations. The first is **createUser**,
    to register or create a new user in our data store, while the second one is to
    perform a **login**. As you may have noticed, both receive the input argument
    with some different values (`CreateUserInput` and `LoginInput`), called **input
    types**, which are used as query or mutation parameters. Finally, they will return
    the `User!` and `Token!` types, respectively. Let’s learn how to define those
    inputs:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们定义了两个突变。第一个是 **createUser**，用于在我们的数据存储中注册或创建新用户，而第二个是执行 **登录**。正如你可能已经注意到的，它们都接收带有不同值的输入参数（`CreateUserInput`
    和 `LoginInput`），称为 **输入类型**，这些类型用作查询或突变的参数。最后，它们将分别返回 `User!` 和 `Token!` 类型。让我们学习如何定义这些输入：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The inputs are normally used with mutations, but you can also use them with
    queries.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 输入通常与突变一起使用，但你也可以将它们与查询一起使用。
- en: Merging type definitions
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并类型定义
- en: Now that we’ve defined all our types, queries, and mutations, we need to merge
    all our GraphQL files to create our GraphQL schema, which is basically one big
    file containing all our GraphQL definitions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了所有我们的类型、查询和突变，我们需要合并所有我们的 GraphQL 文件来创建我们的 GraphQL 模式，这基本上是一个包含所有我们的
    GraphQL 定义的大文件。
- en: 'For this, you need to create a file called `/backend/src/graphql/types/index.ts`
    that contains the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，你需要创建一个名为 `/backend/src/graphql/types/index.ts` 的文件，其中包含以下代码：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After successfully merging your type definitions into one comprehensive GraphQL
    schema, the next critical step is to create resolvers. Resolvers are functions
    that have the responsibility of fetching and generating the data that corresponds
    to the fields defined in your GraphQL schema.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功将你的类型定义合并到一个综合的 GraphQL 模式后，下一个关键步骤是创建解析器。解析器是负责从你的 GraphQL 模式中定义的字段获取和生成数据的函数。
- en: Creating our resolvers
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的解析器
- en: A resolver is a function that’s responsible for generating data for a field
    in your GraphQL schema. It can normally generate the data in any way you want,
    in that it can fetch data from a database or by using a third-party API.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器是一个负责为你的 GraphQL 模式中的字段生成数据的函数。它通常可以以任何你想要的方式生成数据，因为它可以从数据库中获取数据或使用第三方 API。
- en: 'To create our user resolvers, you need to create a file called `/backend/src/graphql/resolvers/user.ts`.
    Let’s create a skeleton of what our resolver should look like. Here, we need to
    specify the functions that are defined under **Query** and **Mutation** in our
    GraphQL schema. So, your resolver should look like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的用户解析器，你需要创建一个名为 `/backend/src/graphql/resolvers/user.ts` 的文件。让我们创建我们的解析器应该看起来像的框架。在这里，我们需要指定在
    GraphQL 模式中的 **Query** 和 **Mutation** 下定义的函数。所以，你的解析器应该看起来像这样：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, we return an object with two main nodes called **Query** and
    **Mutation**, and we map the queries and the mutations we defined in our GraphQL
    schema (the `User.ts` file). Of course, we need to make some changes to receive
    some parameters and return some data, but I wanted to show you the basic skeleton
    of a resolver file first.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们返回一个包含两个主要节点 **Query** 和 **Mutation** 的对象，并将我们在 GraphQL 模式中定义的查询和突变映射（`User.ts`
    文件）。当然，我们需要做一些更改以接收一些参数并返回一些数据，但我首先想向你展示解析器文件的基本框架。
- en: 'The first thing you need to do is add some imports to the file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的第一件事是在文件中添加一些导入：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We will create the **getUsers** and **getUser** functions in the next section.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节创建 **getUsers** 和 **getUser** 函数。
- en: Creating the getUsers query
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 getUsers 查询
- en: 'Our first method will be the **getUsers** query. Let’s see how we need to define
    it:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一种方法将是 **getUsers** 查询。让我们看看我们需要如何定义它：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In any query or mutation method, we always receive four parameters: the parent
    (defined as `_`), arguments (defined as `args`), the context (defined as `ctx`),
    and info (which is optional).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何查询或突变方法中，我们总是接收四个参数：父节点（定义为 `_`），参数（定义为 `args`），上下文（定义为 `ctx`），和信息（这是可选的）。
- en: 'If you want to simplify the code a little bit, you can destructure the context,
    like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想稍微简化一下代码，可以像这样解构上下文：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In our next resolver function, we are going to destructure our arguments as
    well. Just as a reminder, the context is passed in our Apollo Server setup (we
    did this previously):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个解析器函数中，我们也将解构我们的参数。提醒一下，上下文是在我们的Apollo Server设置中传递的（我们之前这样做过）：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The context is very important when we need to share something globally in our
    resolvers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要在解析器中全局共享某些内容时，上下文非常重要。
- en: Creating the getUser query
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建getUser查询
- en: 'This function needs to be `async` because we need to perform some asynchronous
    operations, such as getting the connected user via an `at` (access token) if a
    user already has a valid session. Then, we can validate whether this is a real
    user by looking at our database. This helps stop people from modifying the cookies
    or trying to do some form of injection. If we don’t find a connected user, then
    we return an object of the user that contains empty data:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数需要是`async`的，因为我们需要执行一些异步操作，例如，如果用户已经有一个有效的会话，通过`at`（访问令牌）获取已连接的用户。然后，我们可以通过查看我们的数据库来验证这确实是一个真实用户。这有助于阻止人们修改cookies或尝试进行某种形式的注入。如果我们找不到已连接的用户，则返回一个包含空数据的用户对象：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Creating the mutations
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建突变
- en: 'Our mutations are very simple: we just need to execute some functions and pass
    all our arguments by spreading the input value (this comes from our GraphQL schema).
    Let’s see what our `Mutation` node should look like:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的突变非常简单：我们只需要执行一些函数，并通过展开输入值（这来自我们的GraphQL模式）传递所有参数。让我们看看我们的`Mutation`节点应该是什么样子：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You need to pass the **email**, **password**, and **models** to the `doLogin`
    function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将**电子邮件**、**密码**和**模型**传递给`doLogin`函数。
- en: Merging our resolvers
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并我们的解析器
- en: 'As we did with our `types` definitions, we need to merge all our resolvers
    using the `@graphql-tools` packages. You need to create the following file at
    `/backend/src/graphql/resolvers/index.ts`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对`types`定义所做的那样，我们需要使用`@graphql-tools`包合并所有我们的解析器。您需要在`/backend/src/graphql/resolvers/index.ts`创建以下文件：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will combine all your resolvers into an array of resolvers.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把所有您的解析器组合成一个解析器数组。
- en: 'Once your resolvers are merged, bringing all your data-fetching functions into
    one coherent structure, it’s time to move on to the next phase: creating Sequelize
    models. Sequelize is a powerful tool that simplifies the interaction between your
    application and various databases, translating complex SQL commands into user-friendly
    JavaScript.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的解析器合并，将所有您的数据获取函数整合到一个连贯的结构中，就到了下一个阶段：创建Sequelize模型。Sequelize是一个强大的工具，它简化了您的应用程序与各种数据库之间的交互，将复杂的SQL命令转换为用户友好的JavaScript。
- en: Using the Sequelize ORM
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Sequelize ORM
- en: Sequelize is a popular ORM library for Node.js. It enables developers to interact
    with databases like MySQL, PostgreSQL, SQLite, and Microsoft SQL Server by abstracting
    the underlying SQL commands into higher-level, easy-to-use JavaScript objects
    and methods.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize是Node.js的一个流行的ORM库。它使开发者能够通过将底层的SQL命令抽象为高级、易于使用的JavaScript对象和方法，与MySQL、PostgreSQL、SQLite和Microsoft
    SQL Server等数据库进行交互。
- en: Using Sequelize, developers can perform database operations like creating, updating,
    deleting, and querying records without having to write raw SQL queries. Sequelize
    also helps with defining data models, managing associations between tables, and
    handling database migrations.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Sequelize，开发者可以执行创建、更新、删除和查询记录等数据库操作，而无需编写原始SQL查询。Sequelize还帮助定义数据模型、管理表之间的关系以及处理数据库迁移。
- en: 'Some key features of Sequelize ORM include:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize ORM的一些关键特性包括：
- en: '**Model definition**: Sequelize allows you to define models with their attributes,
    data types, and constraints, which map to tables in the underlying database.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型定义**：Sequelize允许您定义具有其属性、数据类型和约束的模型，这些映射到底层数据库中的表。'
- en: '**Associations**: You can easily define relationships between models, such
    as one-to-one, one-to-many, and many-to-many, which map to foreign key constraints
    in the database.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关联**：您可以轻松定义模型之间的关系，例如一对一、一对多和多对多，这些映射到数据库中的外键约束。'
- en: '**Querying**: Sequelize provides a robust querying system that allows you to
    fetch, filter, sort, and paginate data without writing raw SQL.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询**：Sequelize提供了一个强大的查询系统，允许您在不编写原始SQL的情况下获取、过滤、排序和分页数据。'
- en: '**Transactions**: It supports transactions for performing multiple database
    operations atomically.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务**：它支持执行多个数据库操作的事务。'
- en: '**Migrations**: Sequelize offers a migration system to manage schema changes
    over time and keep your database schema in sync with your application’s code.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迁移**: Sequelize 提供了一个迁移系统来管理随时间变化的模式更改，并确保您的数据库模式与应用程序代码保持同步。'
- en: Creating a user model in Sequelize
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Sequelize 中创建用户模型
- en: 'Before we jump into the authentication functions, we need to create our `User`
    model in Sequelize. For this, we need to create a file at `/backend/src/models/User.ts`.
    Our model will have the following fields:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究身份验证函数之前，我们需要在 Sequelize 中创建我们的 `User` 模型。为此，我们需要在 `/backend/src/models/User.ts`
    创建一个文件。我们的模型将包含以下字段：
- en: '`id`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`'
- en: '`username`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`username`'
- en: '`password`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`password`'
- en: '`email`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`'
- en: '`role`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`role`'
- en: '`active`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`active`'
- en: 'Let’s see the code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, we are defining a Sequelize Hook called `beforeCreate`, which
    helps us **encrypt** (using **sha1**) the user password right before the data
    is saved. Finally, we return the `User` model.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在定义一个名为 `beforeCreate` 的 Sequelize 钩子，它在我们保存数据之前帮助我们将用户密码**加密**（使用 **sha1**）。最后，我们返回
    `User` 模型。
- en: Connecting Sequelize to a PostgreSQL database
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Sequelize 连接到 PostgreSQL 数据库
- en: Now that we’ve created the user model, we need to connect Sequelize to our PostgreSQL
    database and put all our models together.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了用户模型，我们需要将 Sequelize 连接到我们的 PostgreSQL 数据库并将所有模型组合在一起。
- en: 'You need to add the following code to the `/backend/src/models/index.ts` file:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将以下代码添加到 `/backend/src/models/index.ts` 文件中：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Authentication functions
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证函数
- en: Step by step, we are putting all the puzzle pieces together. Now, let’s look
    at the authentication functions we will use to validate whether a user is connected
    or not and get the user’s data. For this, we need to use JWTs.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一步一步地，我们将所有拼图碎片拼在一起。现在，让我们看看我们将使用的身份验证函数，以验证用户是否已连接以及获取用户数据。为此，我们需要使用 JWT。
- en: JWT is an open standard outlined in RFC 7519 ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)).
    It serves as a valuable tool to transmit information between parties as a JSON
    object. One of the primary advantages of JWTs is their digital signature, which
    allows them to be easily verified and trusted. The token is signed using the HMAC
    algorithm and a secret or a public key pair using RSA or ECDSA, ensuring that
    it remains secure and tamper-proof. This makes JWTs a reliable choice for authentication
    and authorization purposes in a wide range of applications.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: JWT 是在 RFC 7519 中概述的开放标准（[https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)）。它作为在各方之间作为
    JSON 对象传输信息的宝贵工具。JWT 的一个主要优点是其数字签名，这使得它们可以轻松验证和信任。令牌使用 HMAC 算法和秘密或公钥对（使用 RSA 或
    ECDSA）进行签名，确保其安全且防篡改。这使得 JWT 成为各种应用程序中身份验证和授权的可靠选择。
- en: Creating JWT functions
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 JWT 函数
- en: 'Let’s create some functions that will help verify a JWT and get the user data.
    For this, we need to create the `jwtVerify`, `getUserData`, and `createToken`
    functions. This file should be created at `/backend/src/lib/jwt.ts`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些函数来帮助验证 JWT 并获取用户数据。为此，我们需要在 `/backend/src/lib/jwt.ts` 创建文件：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, `jwt.sign` is used to create a new JWT, while `jwt.verify` is
    used to validate our JWT.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`jwt.sign` 用于创建新的 JWT，而 `jwt.verify` 用于验证我们的 JWT。
- en: Creating authentication functions
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建身份验证函数
- en: 'Now that we’ve created the JWT functions, we need to create some functions
    that will help us log in at `/backend/src/lib/auth.ts`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了 JWT 函数，我们需要创建一些函数来帮助我们登录到 `/backend/src/lib/auth.ts`：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We find a user by a `WHERE` condition:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 `WHERE` 条件查找用户：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finding a user by email:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通过电子邮件查找用户：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If the user does not exist, we return `Invalid Login`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户不存在，我们返回 `Invalid Login`：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We verify that our encrypted password is the same as the `user.password` value:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们验证我们的加密密码是否与 `user.password` 的值相同：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We validate that the user is active:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们验证用户是否处于活动状态：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If the password does not match, we return `Invalid Login`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果密码不匹配，我们返回 `Invalid Login`：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If the account is not active, we return an error:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果账户未处于活动状态，我们返回一个错误：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If the user exists, the password is correct and the account is active, then
    we create the JWT:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户存在，密码正确且账户处于活动状态，则我们创建 JWT：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we validate whether the user exists by email, whether the password is
    correct, and whether the account is active in order to create the JWT.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过电子邮件验证用户是否存在，密码是否正确，以及账户是否处于活动状态，以便创建 JWT。
- en: Defining types and interfaces
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义类型和接口
- en: 'Finally, we need to define our types and interfaces for all our Sequelize models
    and GraphQL inputs. For this, you need to create a file at `/backend/src/types/types.ts`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要为所有我们的 Sequelize 模型和 GraphQL 输入定义我们的类型和接口。为此，您需要在 `/backend/src/types/types.ts`
    中创建一个文件：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, let’s create our interfaces at `/backend/src/types/interfaces.ts`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 `/backend/src/types/interfaces.ts` 中创建我们的接口：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, we need to export both files in `/backend/src/types/index.ts`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要导出 `/backend/src/types/index.ts` 中的两个文件：
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When you need to add more models, remember to always add your types and interfaces
    to those files.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要添加更多模型时，请记住始终将这些类型和接口添加到这些文件中。
- en: 'Finally, you need to create your `tsconfig.json` file in the `root` directory:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要在 `root` 目录中创建您的 `tsconfig.json` 文件：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the next section, we will run our project and create our tables.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将运行我们的项目并创建我们的表。
- en: Running our project for the first time
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一次运行我们的项目
- en: Next up, we’re going to start our project for the first time. If we’ve done
    everything right, we’ll see our `Users` table being set up and our Apollo Server
    will start running.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将第一次启动我们的项目。如果我们一切都做得正确，我们将看到我们的 `Users` 表正在设置，我们的 Apollo 服务器将开始运行。
- en: In this part, we’ll cover how to start our project. After that, we’ll explore
    how to use our GraphQL API. We’ll learn about testing queries, which allow us
    to retrieve data, and mutations, which enable us to modify data. We’ll also discuss
    validations, which are checks to ensure the correctness of our data. Lastly, we’ll
    delve into the process of user login. Let’s get started!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将介绍如何启动我们的项目。之后，我们将探索如何使用我们的 GraphQL API。我们将学习关于测试查询的知识，这些查询允许我们检索数据，以及突变，它使我们能够修改数据。我们还将讨论验证，这是确保我们数据正确性的检查。最后，我们将深入了解用户登录的过程。让我们开始吧！
- en: 'If you followed the previous sections correctly and run the `npm run dev` command,
    you should be able to see that the `Users` table has been created and that Apollo
    Server is running on port `4000`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正确地遵循了前面的部分并运行了 `npm run dev` 命令，您应该能够看到 `Users` 表已创建，并且 Apollo 服务器正在端口 `4000`
    上运行：
- en: '![A picture containing background pattern  Description automatically generated](img/B18414_13_03.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![包含背景图案的图片  自动生成的描述](img/B18414_13_03.png)'
- en: 'Figure 13.3: Running our project for the first time'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3：第一次运行我们的项目
- en: 'Now, let’s say that you want to modify your user model and change the `"username"`
    field to `"username2"`. Let’s see what will happen:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设您想修改您的用户模型并将 `"username"` 字段更改为 `"username2"`。让我们看看会发生什么：
- en: '[PRE46]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This will execute the following SQL query:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行以下 SQL 查询：
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, let’s suppose you changed the `force` constant in your `index.ts` file
    to `true`. The following will happen:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设您将 `index.ts` 文件中的 `force` 常量更改为 `true`。以下将发生：
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_13_04.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本  自动生成的描述](img/B18414_13_04.png)'
- en: 'Figure 13.4: DROP TABLE IF EXISTS'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4：DROP TABLE IF EXISTS
- en: As you can see, if `force` is `true`, it will execute `DROP TABLE IF EXISTS
    "Users" CASCADE;`. This will completely remove your table and values and then
    recreate your table from scratch. That’s why you need to be careful when you use
    the `force` option.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果 `force` 为 `true`，它将执行 `DROP TABLE IF EXISTS "Users" CASCADE;`。这将完全删除您的表和值，然后从头开始重新创建您的表。这就是为什么您在使用
    `force` 选项时需要小心。
- en: 'At this point, if you open [http://localhost:4000/graphql](http://localhost:4000/graphql),
    you should be able to see your new GraphQL Explorer:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果您打开 [http://localhost:4000/graphql](http://localhost:4000/graphql)，您应该能够看到您的新
    GraphQL 探索器：
- en: '![](img/B18414_13_05.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18414_13_05.png)'
- en: 'Figure 13.5: GraphQL Explorer'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5：GraphQL 探索器
- en: Click on the **Query your server** button and then we are ready to test our
    queries and mutations.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**查询您的服务器**按钮，然后我们就可以开始测试我们的查询和突变了。
- en: Testing GraphQL queries and mutations
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 GraphQL 查询和突变
- en: 'Great! At this point, you’re very close to executing your first GraphQL query
    and mutation. The first query we will execute is going to be `getUsers`. The following
    is the correct syntax to run a query:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！在这个时候，您已经非常接近执行您的第一个 GraphQL 查询和突变了。我们将执行的第一个查询将是 `getUsers`。以下运行查询的正确语法：
- en: '[PRE48]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When you don’t have any attribute to pass to the query, you just need to specify
    the name of the query under the `query {...}` block and then specify the fields
    you want to retrieve once you’ve executed your query. In this case, we want to
    fetch the `id`, `username`, `email`, and `role` fields.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当你没有属性要传递给查询时，你只需要在 `query {...}` 块下指定查询的名称，然后在你执行查询后指定你想要检索的字段。在这种情况下，我们想要检索
    `id`、`username`、`email` 和 `role` 字段。
- en: 'If you run this query, you will probably get an empty array of data. This is
    because we don’t have any users registered yet:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个查询，你可能会得到一个空的数据数组。这是因为我们还没有注册任何用户：
- en: '![](img/B18414_13_06.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18414_13_06.png)'
- en: 'Figure 13.6: getUsers query'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6：getUsers 查询
- en: This means we need to execute our `createUser mutation` in order to register
    our first user. One thing I like about GraphQL Explorer is that you have all the
    schema documentation in the **Schema** icon on the left-hand side. If you click
    on the **Schema** icon, you will see all your queries and mutations listed.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要执行我们的 `createUser 变异` 来注册我们的第一个用户。我喜欢 GraphQL Explorer 的一个地方是，你可以在左侧的
    **Schema** 图标中找到所有的模式文档。如果你点击 **Schema** 图标，你会看到所有你的查询和变异列出来。
- en: 'Let’s click there and select our `createUser mutation` to see what needs to
    be called and what data may be returned:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们点击那里并选择我们的 `createUser 变异` 来查看需要调用什么以及可能返回什么数据：
- en: '![Graphical user interface, application, Teams  Description automatically generated](img/B18414_13_07.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，团队，自动生成的描述](img/B18414_13_07.png)'
- en: 'Figure 13.7: Schema'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7：模式
- en: 'As you can see, the `createUser mutation` needs an `input` argument, which
    is `CreateUserInput`. Let’s click on that input:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`createUser 变异`需要一个 `input` 参数，它是 `CreateUserInput`。让我们点击那个输入：
- en: '![Graphical user interface, application, Teams  Description automatically generated](img/B18414_13_08.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，团队，自动生成的描述](img/B18414_13_08.png)'
- en: 'Figure 13.8: CreateUserInput'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8：CreateUserInput
- en: Awesome! Now, we know that we need to pass the **username**, **password**, **email**,
    **role**, and **active** fields in order to create a new user. Let’s do this!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在，我们知道我们需要传递 **username**、**password**、**email**、**role** 和 **active**
    字段来创建一个新用户。让我们这么做吧！
- en: 'Create a new tab so that you don’t lose the code of your first query and then
    write the mutation:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新标签页，这样你就不会丢失第一个查询的代码，然后编写变异：
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As you can see, your mutation needs to be written under the `mutation {...}`
    block, and you must pass the `input` argument as an object in the **Variables**
    section. Finally, you must specify the fields you want to retrieve once the mutation
    has been executed correctly. If everything is OK, you should see something like
    this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你的变异需要在 `mutation {...}` 块下编写，你必须将 `input` 参数作为一个对象在 **Variables** 部分传递。最后，一旦变异正确执行，你必须指定你想要检索的字段。如果一切正常，你应该看到类似这样的内容：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18414_13_09.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，自动生成的描述](img/B18414_13_09.png)'
- en: 'Figure 13.9: CreateUser mutation'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.9：CreateUser 变异
- en: 'If you’re curious and wish to take a look at the terminal where you run your
    Apollo Server, you will see the SQL query that was performed for this user:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇并想看看你运行 Apollo Server 的终端，你会看到为这个用户执行的 SQL 查询：
- en: '[PRE50]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `VALUES` variables are handled by Apollo Server, so you won’t see the actual
    values in there, but you can find out which operation is being executed in the
    database.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`VALUES` 变量由 Apollo Server 处理，所以你不会在那里看到实际的值，但你可以找出正在数据库中执行的操作。'
- en: Now, go back to your first query (`getUsers`) and run it again!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到你的第一个查询（`getUsers`）并再次运行它！
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18414_13_10.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，自动生成的描述](img/B18414_13_10.png)'
- en: 'Figure 13.10: getUsers query'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.10：getUsers 查询
- en: 'Nice: this is your first query and mutation that have been executed correctly
    in GraphQL. If you want to see this data in your database, you can use OmniDB
    or PgAdmin4 to view your `Users` table in your PostgreSQL database:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 很好：这是你在 GraphQL 中正确执行的第一个查询和变异。如果你想在你数据库中看到这些数据，你可以使用 OmniDB 或 PgAdmin4 来查看你的
    PostgreSQL 数据库中的 `Users` 表：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18414_13_11.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，自动生成的描述](img/B18414_13_11.png)'
- en: 'Figure 13.11: Database query'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.11：数据库查询
- en: As you can see, our first record has its own `id` field (UUID) and also has
    an encrypted password field (remember our `beforeCreate` Hook in the user model?).
    By default, Sequelize will create the `createdAt` and `updatedAt` fields.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的第一条记录有自己的 `id` 字段（UUID）以及一个加密的密码字段（记得我们在用户模型中的 `beforeCreate` 钩子吗？）。默认情况下，Sequelize
    将创建 `createdAt` 和 `updatedAt` 字段。
- en: Testing model validations and querying users
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试模型验证和查询用户
- en: 'As you may recall, regarding our user model, you will want to make sure all
    the validations we did work fine, such as whether the user is unique or whether
    their email is valid and unique. You just need to execute the exact same mutation
    again:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所回忆的，关于我们的用户模型，你想要确保我们做的所有验证都正常工作，比如用户是否唯一，或者他们的电子邮件是否有效且唯一。你只需要再次执行完全相同的突变：
- en: '![Text  Description automatically generated with medium confidence](img/B18414_13_12.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成，中等置信度](img/B18414_13_12.png)'
- en: 'Figure 13.12: Username must be unique'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.12：用户名必须唯一
- en: 'As you can see, we will get a “**username must be unique**” error message because
    we’ve already registered the “admin” username. Now, let’s try to change the username
    to “**admin2**” but leave the email as is (**admin@js.education**):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们会得到一个“**用户名必须唯一**”的错误信息，因为我们已经注册了“admin”用户名。现在，让我们尝试将用户名更改为“**admin2**”，但保持电子邮件不变（**admin@js.education**）：
- en: '![Text  Description automatically generated with low confidence](img/B18414_13_13.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成，低置信度](img/B18414_13_13.png)'
- en: 'Figure 13.13: Email must be unique'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.13：电子邮件必须唯一
- en: 'We will also get an “**email must be unique**” error for the email. Now, try
    to change the email to something invalid, such as **admin@myfakedomain**:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会得到一个“**电子邮件必须唯一**”的错误。现在，尝试将电子邮件更改为无效的地址，例如 **admin@myfakedomain**：
- en: '![A picture containing timeline  Description automatically generated](img/B18414_13_14.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![包含时间线的图片描述自动生成](img/B18414_13_14.png)'
- en: 'Figure 13.14: Invalid email'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.14：无效的电子邮件
- en: 'Now, we’re getting an `"Invalid email"` error message. This is just amazing,
    don’t you think? Now, let’s stop playing with the validations and add a new valid
    user (**username**: admin2 and **email**: admin2@js.education). Once you’ve created
    your second user, run our **getUsers** query once more. However, this time, add
    the `active` field to the list of fields we want to return:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们得到了一个“`Invalid email`”错误信息。这真是太神奇了，不是吗？现在，让我们停止玩验证，并添加一个新有效用户（**用户名**：admin2
    和 **电子邮件**：admin2@js.education）。一旦你创建了第二个用户，再次运行我们的 **getUsers** 查询。然而，这次，将 `active`
    字段添加到我们想要返回的字段列表中：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B18414_13_15.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，描述自动生成，中等置信度](img/B18414_13_15.png)'
- en: 'Figure 13.15: getUsers query'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.15：getUsers 查询
- en: Now, we have two registered users, and both are inactive accounts (`"active"
    = false`).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有两个注册用户，并且这两个都是非活动账户（`"active" = false`）。
- en: 'One thing I love about GraphQL is that when you’re writing your queries or
    mutations and you don’t remember a certain field, GraphQL will always show you
    the list of available fields for that query or mutation. For example, if you just
    write the letter `p` for the password, you will see something like this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢 GraphQL 的一个地方是，当你编写查询或突变，并且你不记得某个字段时，GraphQL 总会显示该查询或突变可用的字段列表。例如，如果你只写密码的字母
    `p`，你会看到类似这样的内容：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B18414_13_16.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，描述自动生成，中等置信度](img/B18414_13_16.png)'
- en: 'Figure 13.16: Autocomplete'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.16：自动完成
- en: Now, we are ready to try and log in!
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备尝试登录！
- en: Performing a login
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行登录
- en: 'I want to congratulate you for getting to this point in this book: I know we
    have covered a lot, but we are almost there! Now, we are going to try and log
    in with GraphQL (how crazy is that?).'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我想恭喜你来到这本书的这一部分：我知道我们已经覆盖了很多内容，但我们几乎要完成了！现在，我们将尝试使用 GraphQL 登录（这有多疯狂？）。
- en: 'First, we need to write our login mutation:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要编写我们的登录突变：
- en: '[PRE51]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, we need to log our user in by using “`fake@email.com`" as our email and
    “`123456`" as our password. These do not exist in our database:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要使用“`fake@email.com`”作为我们的电子邮件地址和“`123456`”作为我们的密码来登录我们的用户。这些信息在我们的数据库中不存在：
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_13_17.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本描述自动生成](img/B18414_13_17.png)'
- en: 'Figure 13.17: Invalid login after using non-existent login details'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.17：使用不存在的登录详情后的无效登录
- en: 'Because the email does not exist in our database, an `Invalid Login` error
    message will be returned. Now, let’s add the correct email but use a fake password:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 因为邮箱在我们的数据库中不存在，所以会返回一个`无效登录`错误信息。现在，让我们添加正确的邮箱，但使用一个假的密码：
- en: '![Text  Description automatically generated](img/B18414_13_18.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B18414_13_18.png)'
- en: 'Figure 13.18: Invalid login after inputting the correct email but a fake password'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.18：输入正确的邮箱但使用假密码后的无效登录
- en: As you can see, we receive the exact same error (`Invalid Login`). This is because
    we don’t want to provide too much information about what’s wrong with the login,
    as someone may be trying to hack into your system. If we say something such as
    `Invalid password` or `Your email does not exist in our system`, we give the attackers
    extra information that they may find useful.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们收到了完全相同的错误（`无效登录`）。这是因为我们不希望提供太多关于登录错误的详细信息，因为有人可能正在尝试入侵您的系统。如果我们说像“密码无效”或“您的邮箱不在我们的系统中”这样的话，我们就会给攻击者提供可能对他们有用的额外信息。
- en: 'Now, let’s try to connect with the correct user and password (`admin@js.education`
    and `123456`) and see what happens:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用正确的用户名和密码（`admin@js.education`和`123456`）进行连接，看看会发生什么：
- en: '![Text  Description automatically generated](img/B18414_13_19.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B18414_13_19.png)'
- en: 'Figure 13.19: Your account is not activated yet'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.19：您的账户尚未激活
- en: Now, we receive an error stating`Your account is not activated yet`. This is
    OK because our user has not been activated yet. Normally, when a user is registered
    in a system, you need to send a link to their email so that they can activate
    their account. We don’t have this feature at the moment, but let’s suppose we
    sent that email, and the user has already activated their account. We can simulate
    this by manually changing the value in our database using OnmiDB or PgAdmin4\.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们收到一个错误信息，显示“您的账户尚未激活”。这是正常的，因为我们的用户尚未激活。通常情况下，当用户在一个系统中注册时，你需要发送一个链接到他们的邮箱，以便他们可以激活他们的账户。我们目前没有这个功能，但假设我们已经发送了那封邮件，并且用户已经激活了他们的账户。我们可以通过使用OnmiDB或PgAdmin4手动更改数据库中的值来模拟这种情况。
- en: 'We can do this by performing an `UPDATE` SQL query:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行一个`UPDATE` SQL查询来完成这个操作：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18414_13_20.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，邮箱描述自动生成](img/B18414_13_20.png)'
- en: 'Figure 13.20: UPDATE SQL query'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.20：UPDATE SQL查询
- en: Now, let’s try to log in again!
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次尝试登录！
- en: '![Text  Description automatically generated](img/B18414_13_21.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B18414_13_21.png)'
- en: 'Figure 13.21: Login token'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.21：登录令牌
- en: 'Nice: we are in, baby! This is you at this point:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 好的：我们进去了，宝贝！这是你现在的情况：
- en: '![](img/B18414_13_22.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18414_13_22.png)'
- en: 'Figure 13.22: Anonymous'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.22：匿名
- en: 'Now that we’ve logged in and retrieved our JWT, let’s copy that huge string
    and use it in our **getUser** query to see whether we can get the user’s data:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经登录并获取了我们的JWT，让我们复制那个长字符串，并在我们的**getUser**查询中使用它，看看我们是否能获取用户的数据：
- en: '![](img/B18414_13_23.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18414_13_23.png)'
- en: 'Figure 13.23: Access token'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.23：访问令牌
- en: 'If everything went well, then you should get the user’s data:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该能获取到用户的数据：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18414_13_24.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序描述自动生成](img/B18414_13_24.png)'
- en: 'Figure 13.24: getUser data'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.24：getUser数据
- en: 'If you change or remove any letter from the string (meaning the token is invalid),
    then you should get empty user data:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更改或删除字符串中的任何字母（意味着令牌无效），你应该会得到空的用户数据：
- en: '![Text  Description automatically generated](img/B18414_13_25.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B18414_13_25.png)'
- en: 'Figure 13.25: Empty getUser data'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.25：空的getUser数据
- en: Now that our login system works perfectly in the backend, it is time to implement
    this in the frontend application. We’ll do this in the next section.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们后端的登录系统运行得非常完美，是时候在前端应用程序中实现这个功能了。我们将在下一节中这样做。
- en: Building a frontend login system with Apollo Client
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Apollo Client构建前端登录系统
- en: 'In the previous section, we learned how to build the backend for a login system
    using Apollo Server to create our GraphQL queries and mutations. You are probably
    thinking, *Great, I have the backend working, but how can I use this on the frontend?*
    And you’re right: I always like to explain things with full examples and not just
    show basic things, even if this will take longer to do. So let’s get started!'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何使用 Apollo Server 创建我们的 GraphQL 查询和突变来构建登录系统的后端。你可能正在想，“太好了，后端已经工作，但我如何在前端使用它？”
    你是对的：我总是喜欢用完整的示例来解释事物，而不仅仅是展示基本的东西，即使这会花费更长的时间。那么，让我们开始吧！
- en: You can find the code for the example in this section at [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter13/graphql/frontend](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter13/graphql/frontend).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这个部分的代码示例在 [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter13/graphql/frontend](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter13/graphql/frontend)
    找到。
- en: Configuring Webpack 5
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Webpack 5
- en: Instead of using a **vite** project, we will configure a React project from
    scratch using Webpack 5 and Node.js.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不使用 **vite** 项目，而是从头开始配置一个使用 Webpack 5 和 Node.js 的 React 项目。
- en: 'The first thing we need to do is create the frontend directory and install
    all the packages inside. To do this, we will execute the following commands:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建前端目录并安装所有包。为此，我们将执行以下命令：
- en: '[PRE52]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `buffer`, `crypto-browserify`, and `stream-browserify` are polyfills that
    were included by default in Webpack up to and including version 4\. However, in
    the latest version (Webpack 5), these are not included anymore, so you will get
    the following error:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`buffer`、`crypto-browserify` 和 `stream-browserify` 是在 Webpack 4 及之前版本中默认包含的
    polyfills。然而，在最新版本（Webpack 5）中，这些 polyfills 已不再包含，因此你将遇到以下错误：'
- en: '![Text  Description automatically generated](img/B18414_13_26.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B18414_13_26.png)'
- en: 'Figure 13.26: Webpack < 5 used to include polyfills for Node.js core modules
    by default'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.26：Webpack < 5 默认包含 Node.js 核心模块的 polyfills
- en: 'You need to have those scripts in your `package.json`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在你的 `package.json` 中包含以下脚本：
- en: '[PRE53]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'I like to split my Webpack configuration into separate files to identify more
    easily what is for the client, for the server, for development, and for production.
    First let’s create our `presets` directory under `/frontend/webpack/presets`,
    and then create our `webpack.client.ts` to specify our client configuration:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢将我的 Webpack 配置拆分为单独的文件，以便更容易地识别客户端、服务器、开发环境和生产环境的配置。首先，让我们在 `/frontend/webpack/presets`
    下创建我们的 `presets` 目录，然后创建我们的 `webpack.client.ts` 以指定客户端配置：
- en: '[PRE54]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'That is our client preset; now let’s create the server preset under `/frontend/webpack/presets/webpack.server.ts`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的客户端预设；现在让我们在 `/frontend/webpack/presets/webpack.server.ts` 下创建服务器预设：
- en: '[PRE55]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'After you’ve created the presets, you need to create the `loadPresets.ts` file
    that will handle those presets. This file must exist under `/frontend/webpack/loadPresets.ts`:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建预设之后，你需要创建一个 `loadPresets.ts` 文件来处理这些预设。此文件必须位于 `/frontend/webpack/loadPresets.ts`：
- en: '[PRE56]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Besides the client and server presets, we need to create some other configuration
    files: one for development, another for production, and a file that will contain
    a common configuration between both. First let’s create the common configuration
    at `/frontend/webpack/webpack.common.ts`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 除了客户端和服务器预设之外，我们还需要创建一些其他配置文件：一个用于开发，另一个用于生产，以及一个将包含两者之间共同配置的文件。首先，让我们在 `/frontend/webpack/webpack.common.ts`
    创建公共配置：
- en: '[PRE57]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then we need to create the development configuration at `/frontend/webpack/webpack.development.ts`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在 `/frontend/webpack/webpack.development.ts` 创建开发配置：
- en: '[PRE58]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As you can see in development, we include the `HotModuleReplacementPlugin`
    for the **HMR** to reload the site every time we make a change. After this, you
    need to create the production configuration file at `/frontend/webpack/webpack.production.ts`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在开发中看到的，我们包括 `HotModuleReplacementPlugin` 以实现 **HMR**，每次我们进行更改时都会重新加载网站。之后，你需要创建生产配置文件在
    `/frontend/webpack/webpack.production.ts`：
- en: '[PRE59]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, we have to create our Webpack types file at `/frontend/webpack/webpack.types.ts`.
    These are the TypeScript types we will use for Webpack:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须在 `/frontend/webpack/webpack.types.ts` 创建我们的 Webpack 类型文件。这些是我们将用于 Webpack
    的 TypeScript 类型：
- en: '[PRE60]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'At this point, you need to create the `index.xhtml` file, which should be at
    `/frontend/src/client/index.xhtml`. This will be our initial HTML file handled
    by `HtmlWebpackPlugin`:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您需要创建`index.xhtml`文件，该文件应位于`/frontend/src/client/index.xhtml`。这将是我们的初始HTML文件，由`HtmlWebpackPlugin`处理：
- en: '[PRE61]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In the next section, we will configure our TypeScript.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将配置我们的TypeScript。
- en: Configuring our TypeScript
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置我们的TypeScript
- en: TypeScript is a special version of JavaScript, the language typically used to
    write web apps. What makes TypeScript interesting is its ability to identify mistakes
    in our code earlier, potentially saving us significant time. This feature becomes
    particularly valuable when working on large-scale projects. Therefore, we will
    utilize TypeScript for our project. Let’s now delve into the process of setting
    it up.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript是JavaScript的一种特殊版本，通常是编写Web应用的编程语言。TypeScript有趣之处在于它能够更早地识别我们代码中的错误，这可能会为我们节省大量时间。当在大规模项目中工作时，此功能尤其有价值。因此，我们将为我们的项目使用TypeScript。现在让我们深入了解设置过程。
- en: 'Our `tsconfig.json` file should look like this:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`tsconfig.json`文件应如下所示：
- en: '[PRE62]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now, let’s learn how to configure the Express server.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何配置Express服务器。
- en: Configuring the Express server
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Express服务器
- en: 'Our application requires a Express server so that we can perform validations.
    These will help us find out whether the user is connected (using a custom middleware,
    which I’ll explain later) and can also configure our Express sessions. We have
    four main routes on our site:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序需要一个Express服务器，以便我们可以执行验证。这些验证将帮助我们找出用户是否已连接（使用自定义中间件，我将在后面解释）并且还可以配置我们的Express会话。我们在网站上主要有四个路由：
- en: '`/`: Our home page (handled by React).'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`：我们的主页（由React处理）。'
- en: '`/dashboard`: Our dashboard, which is protected. Only connected users with
    god or admin permissions are allowed (handled by Express first then by React).'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dashboard`：我们的仪表板，受保护。只有具有god或admin权限的已连接用户允许（首先由Express处理，然后由React处理）。'
- en: '`/login`: Our login page (handled by React).'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/login`：我们的登录页面（由React处理）。'
- en: '`/logout`: This will delete our existing session (handled by Express).'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/logout`：这将删除我们现有的会话（由Express处理）。'
- en: 'Let’s look at our server code. The following file should exist at `/frontend/src/server.ts`.
    This is in order to create our Express app and run our React app:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的服务器代码。以下文件应位于`/frontend/src/server.ts`。这是为了创建我们的Express应用并运行我们的React应用：
- en: '[PRE63]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As you can see, we protect our dashboard route with the `isConnected` middleware.
    Here, we validate that we only accept users that are not connected in the login
    route.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用`isConnected`中间件保护我们的仪表板路由。在这里，我们验证我们只接受在登录路由中未连接的用户。
- en: Creating our frontend configuration
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的前端配置
- en: 'Now, we need to create our frontend configuration. So, let’s create the configuration
    at `/frontend/src/config.ts`. This file will assist us to manage our GraphQL port
    and server, as well as incorporate security configurations such as our secret
    key and the expiration options:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建我们的前端配置。因此，让我们在`/frontend/src/config.ts`创建配置。此文件将帮助我们管理我们的GraphQL端口和服务器，以及集成安全配置，如我们的密钥和过期选项：
- en: '[PRE64]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Next, we need to create a user-called middleware and the **jwt** functions to
    validate whether the user is connected and has the correct privileges.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个用户调用的中间件以及**jwt**函数来验证用户是否已连接并且具有正确的权限。
- en: Creating the user middleware
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户中间件
- en: In web development, a middleware is a function that has access to the request
    object (**req**), the response object (**res**), and the next function in the
    application’s request-response cycle. The next function is a function in the Express
    router that, when invoked, executes the middleware succeeding the current middleware.
    This creates a chain of functions, each of which can perform a specific task or
    modify the request and response objects as needed. By utilizing middleware, you
    can streamline your code and simplify complex processes.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web开发中，中间件是一个可以访问请求对象（**req**）、响应对象（**res**）以及应用请求-响应周期中的下一个函数的功能。下一个函数是Express路由器中的一个函数，当被调用时，会执行当前中间件之后的中间件。这创建了一个函数链，每个函数都可以执行特定的任务或根据需要修改请求和响应对象。通过利用中间件，您可以简化代码并简化复杂的过程。
- en: 'The following diagram provides a visual representation of the middleware flow:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表提供了中间件流程的视觉表示：
- en: '![Bubble chart  Description automatically generated](img/B18414_13_27.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![气泡图  描述自动生成](img/B18414_13_27.png)'
- en: 'Figure 13.27: Visual representation of the middleware flow'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.27：中间件流程的视觉表示
- en: 'In our case, we will create the **isConnected** middleware to validate if a
    user is connected and has the correct privileges. If not, we will break the flow
    and redirect them to the login page. If the user is valid, we will execute the
    next piece of middleware, which will render our React application. The following
    diagram describes this process:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将创建 **isConnected** 中间件来验证用户是否已连接并且具有正确的权限。如果没有，我们将中断流程并将他们重定向到登录页面。如果用户有效，我们将执行下一个中间件，这将渲染我们的
    React 应用程序。以下图表描述了此过程：
- en: '![A picture containing diagram  Description automatically generated](img/B18414_13_28.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![包含图表的图片 自动生成描述](img/B18414_13_28.png)'
- en: 'Figure 13.28: Auth middleware'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.28：认证中间件
- en: 'Let’s apply the theoretical part to our code. The required file should exist
    at `/frontend/src/server/lib/middlewares/user.ts`:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将理论部分应用到我们的代码中。所需的文件应位于 `/frontend/src/server/lib/middlewares/user.ts`：
- en: '[PRE65]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Basically, with this middleware, we can control whether we want to validate
    whether the user is connected (`isLogged = true`). Then, we can validate specific
    roles (`roles = ['god', 'admin']`) and redirect the user if they are not connected
    or do not have the correct roles (`redirectTo = '/'`).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，通过这个中间件，我们可以控制是否要验证用户是否已连接（`isLogged = true`）。然后，我们可以验证特定的角色（`roles = ['god',
    'admin']`），如果用户未连接或没有正确的角色，则将用户重定向（`redirectTo = '/'`）。
- en: As you can see, we are using the `getUserData` function from `jwt`. We’ll create
    our `jwt` functions in the next section.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在使用来自 `jwt` 的 `getUserData` 函数。我们将在下一节创建我们的 `jwt` 函数。
- en: Creating JWT functions
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 JWT 函数
- en: 'Earlier, when I explained the backend code, I talked about JWTs. In the frontend,
    we need those functions to validate our token and get the user’s data. Let’s create
    a file containing the following code at `/frontend/src/server/lib/jwt.ts`:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在我之前解释后端代码时，我提到了 JWT。在前端，我们需要这些函数来验证我们的令牌并获取用户数据。让我们在 `/frontend/src/server/lib/jwt.ts`
    创建包含以下代码的文件：
- en: '[PRE66]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As you can see, our `getUserData` function will retrieve the user data using
    `accessToken`, which we grabbed from the cookies.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的 `getUserData` 函数将使用 `accessToken` 从 cookies 中检索用户数据，这是我们之前获取的。
- en: A JWT must be valid for security reasons and to ensure that the user’s identity
    is verified. The server verifies this token whenever a user makes a request. If
    the token is invalid, the server will not fulfill the user’s request. Additionally,
    the token helps protect user information, as it cannot be altered without the
    server’s knowledge. Moreover, these tokens have an expiration time, requiring
    users to log in again. This prevents unauthorized individuals from using a stolen
    token to impersonate the user. Hence, ensuring the validity of a JWT is of utmost
    importance.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全原因和确保用户的身份得到验证，JWT 必须有效。服务器在用户发起请求时验证此令牌。如果令牌无效，服务器将不会满足用户的需求。此外，令牌有助于保护用户信息，因为它不能在没有服务器知识的情况下被更改。此外，这些令牌有有效期，需要用户再次登录。这防止了未经授权的个人使用被盗令牌来冒充用户。因此，确保
    JWT 的有效性至关重要。
- en: Creating our GraphQL queries and mutations
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的 GraphQL 查询和突变
- en: We’ve already created the required queries and mutations in our backend project.
    At this point, however, we need to create some files that will execute them in
    our frontend project. For now, we just need to define our `getUserData` query
    and our login mutation to perform the login in the frontend.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在我们的后端项目中创建了所需的查询和突变。然而，此时我们需要在我们的前端项目中创建一些文件来执行它们。目前，我们只需要定义我们的 `getUserData`
    查询和登录突变，以便在前端执行登录。
- en: 'Let’s create our `getUser` query at `/frontend/src/client/graphql/user/getUser.query.ts`:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `/frontend/src/client/graphql/user/getUser.query.ts` 创建我们的 `getUser` 查询：
- en: '[PRE67]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Our login mutation should be at `/frontend/src/graphql/user/login.mutation.ts`:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的登录突变应在 `/frontend/src/graphql/user/login.mutation.ts`：
- en: '[PRE68]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Now that we have defined our query and mutation, let’s create the user context
    so that we can use them.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了查询和突变，让我们创建用户上下文，以便我们可以使用它们。
- en: Creating user context to handle login and connected user
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户上下文以处理登录和已连接用户
- en: In our user context, we will have a login method that will execute our mutation
    and validate whether the email and password are correct. We will also export the
    user data.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的用户上下文中，我们将有一个登录方法，它将执行我们的突变并验证电子邮件和密码是否正确。我们还将导出用户数据。
- en: 'Let’s create this context at `/frontend/src/client/contexts/user.tsx`:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `/frontend/src/client/contexts/user.tsx` 创建此上下文：
- en: '[PRE69]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: As you can see, we handle the login and have the `connectedUser` data in our
    context. Here, we execute `GET_USER_QUERY` all the time to verify whether the
    user is connected (validating against the database and not just with the cookies).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们处理了登录，并在我们的上下文中有了 `connectedUser` 数据。在这里，我们始终执行 `GET_USER_QUERY` 以验证用户是否已连接（验证数据库而不是仅通过
    cookies）。
- en: Configuring Apollo Client
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Apollo 客户端
- en: 'So far, we have created a lot of code, but none of it is going to work if we
    don’t configure Apollo Client. To configure Apollo Client, we need to add it to
    our index file at `/frontend/src/client/index.tsx`:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了大量的代码，但如果我们不配置 Apollo 客户端，那么这些代码将无法工作。要配置 Apollo 客户端，我们需要将其添加到我们的索引文件
    `/frontend/src/client/index.tsx` 中：
- en: '[PRE70]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Basically, we pass `config.api.uri`, which is where GraphQL Playground is running
    ([http://localhost:4000/graphql](http://localhost:4000/graphql)), and then wrap
    our `AppRoutes` component with the `ApolloProvider` component.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们传递 `config.api.uri`，这是 GraphQL Playground 运行的地方 ([http://localhost:4000/graphql](http://localhost:4000/graphql))，然后使用
    `ApolloProvider` 组件包装我们的 `AppRoutes` 组件。
- en: Creating our app routes
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的应用路由
- en: 'We will use `react-router-dom` to create our application routes. Let’s create
    the required code at `/frontend/src/client/AppRoutes.tsx`:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `react-router-dom` 创建我们的应用程序路由。让我们在 `/frontend/src/client/AppRoutes.tsx`
    创建所需的代码：
- en: '[PRE71]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: As you can see, we are adding some pages to our routes, such as `HomePage`,
    `DashboardPage` (protected), and `LoginPage`. If the user tries to access a different
    URL, then we will display an `Error404` component. We’ll create these pages in
    the next section.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在向我们的路由中添加一些页面，例如 `HomePage`、`DashboardPage`（受保护）和 `LoginPage`。如果用户尝试访问不同的
    URL，那么我们将显示 `Error404` 组件。我们将在下一节中创建这些页面。
- en: Creating our pages
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的页面
- en: 'The `Home` page should be at `/frontend/src/client/pages/home.tsx`:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`Home` 页面应该位于 `/frontend/src/client/pages/home.tsx`：'
- en: '[PRE72]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `Dashboard` page should be at `/frontend/src/client/pages/dashboard.tsx`:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dashboard` 页面应该位于 `/frontend/src/client/pages/dashboard.tsx`：'
- en: '[PRE73]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `Login` page should be at `/frontend/src/client/pages/login.tsx`:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`Login` 页面应该位于 `/frontend/src/client/pages/login.tsx`：'
- en: '[PRE74]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Finally, we need to create our Error404 page `(/frontend/src/client/pages/error404.tsx`):'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要创建我们的 404 错误页面 `(/frontend/src/client/pages/error404.tsx)`：
- en: '[PRE75]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We are almost done. The last piece of this puzzle is to create the `Login` and
    `Dashboard` components. We’ll do that in the next section.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了。这个谜题的最后一块是创建 `Login` 和 `Dashboard` 组件。我们将在下一节中完成。
- en: Creating our login components
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的登录组件
- en: I created some basic components for our login and our dashboard. Of course,
    their styles can be improved, but let’s see how they work and how our login system
    is going to look.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我为我们的登录和仪表板创建了一些基本组件。当然，它们的样式可以改进，但让我们看看它们是如何工作的，以及我们的登录系统将看起来如何。
- en: 'The first file you need to create is called `LoginLayout.tsx` at `/frontend/src/client/components/users/LoginLayout.tsx`:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要创建的第一个文件是位于 `/frontend/src/client/components/users/LoginLayout.tsx` 的 `LoginLayout.tsx`：
- en: '[PRE76]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The layout file is useful when we want to add a specific layout to our components.
    It is also useful to consume data from a context and pass the data or functions
    as props.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 布局文件在我们想要为组件添加特定布局时很有用。它还有助于从上下文中获取数据并将数据或函数作为属性传递。
- en: 'Our `Login` component should look like this (`/frontend/src/client/components/users/Login.tsx`):'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Login` 组件应该看起来像这样 (`/frontend/src/client/components/users/Login.tsx`)：
- en: '[PRE77]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We’ll create the `dashboard` components next.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将接下来创建 `dashboard` 组件。
- en: Creating our dashboard components
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的仪表板组件
- en: 'When creating our `dashboard` components, the first one should be the `DashboardLayout.tsx`
    file at `/frontend/src/client/components/dashboard/DashboardLayout.tsx`:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的 `dashboard` 组件时，第一个应该是位于 `/frontend/src/client/components/dashboard/DashboardLayout.tsx`
    的 `DashboardLayout.tsx` 文件：
- en: '[PRE78]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This is how we protect our `dashboard` page to allow only connected users.
    Now, let’s create our `dashboard` component at `/frontend/src/components/dashboard/Dashboard.tsx`:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们保护 `dashboard` 页面以仅允许已连接用户的方法。现在，让我们在 `/frontend/src/components/dashboard/Dashboard.tsx`
    创建我们的 `dashboard` 组件：
- en: '[PRE79]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: And with that, we’re done! We’ll test the login system in the next section.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就完成了！我们将在下一节测试登录系统。
- en: Testing our login system
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试我们的登录系统
- en: 'If you followed the previous sections correctly, then you should be able to
    run the login system successfully. To do this, we need to open three terminals:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正确地遵循了前面的章节，那么您应该能够成功运行登录系统。为此，我们需要打开三个终端：
- en: In the first one, you need to run your backend project (**npm run dev**).
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个中，您需要运行您的后端项目（**npm run dev**）。
- en: In the other, you need to run the Node.js server in the frontend project (**npm
    run dev**).
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在另一个方面，您需要在前端项目中运行Node.js服务器（**npm run dev**）。
- en: 'The third terminal is that when you open `http://localhost:3000`for the first
    time, you should be able to see the `Home` page:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个终端是当您第一次打开`http://localhost:3000`时，您应该能够看到`Home`页面：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18414_13_29.png)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件描述自动生成](img/B18414_13_29.png)'
- en: 'Figure 13.29: Home page'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.29：主页
- en: 'Then, if you click on the **Go to Dashboard** ([http://localhost:3000/dashboard](http://localhost:3000/dashboard))
    link, you will be redirected to [http://localhost:3000/login?redirectTo=/dashboard](http://localhost:3000/login?redirectTo=/dashboard),
    as shown in the following screenshot:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果您点击**转到仪表板**（[http://localhost:3000/dashboard](http://localhost:3000/dashboard)）链接，您将被重定向到[http://localhost:3000/login?redirectTo=/dashboard](http://localhost:3000/login?redirectTo=/dashboard)，如下面的截图所示：
- en: '![Graphical user interface, application  Description automatically generated](img/B18414_13_30.png)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B18414_13_30.png)'
- en: 'Figure 13.30: Login page'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.30：登录页面
- en: 'This is our login form. If you try to log in with fake credentials, you should
    get an error:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的登录表单。如果您尝试使用虚假凭证登录，您应该会收到一个错误：
- en: '![Graphical user interface, application  Description automatically generated](img/B18414_13_31.png)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B18414_13_31.png)'
- en: 'Figure 13.31: Invalid login'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.31：无效登录
- en: 'If you want to see the GraphQL request, you can do so on the **Headers** tab:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看GraphQL请求，您可以在**头部**选项卡上这样做：
- en: '![Text  Description automatically generated](img/B18414_13_32.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B18414_13_32.png)'
- en: 'Figure 13.32: GraphQL request'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.32：GraphQL请求
- en: 'Here, you can see the query you execute and the variables you send (email and
    password). You can see the response on the **Preview** tab:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以查看您执行的查询和您发送的变量（电子邮件和密码）。您可以在**预览**选项卡上看到响应：
- en: '![Text  Description automatically generated](img/B18414_13_33.png)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B18414_13_33.png)'
- en: 'Figure 13.33: Invalid login'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.33：无效登录
- en: As you can see, we get an `"Invalid Login"` error message, and that’s why we
    render it in our `login` component.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们得到了一个`"Invalid Login"`错误消息，这就是为什么我们在`login`组件中渲染它。
- en: 'Now, let’s try to connect with the correct account (**admin@js.education**
    and **123456**). If your login is correct, then you should be redirected to the
    dashboard, where you will see the following page:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用正确的账户（**admin@js.education**和**123456**）进行连接。如果您的登录正确，那么您应该被重定向到仪表板，在那里您将看到以下页面：
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B18414_13_34.png)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，聊天或文本消息描述自动生成](img/B18414_13_34.png)'
- en: 'Figure 13.34: Welcome, admin! page'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.34：欢迎，admin！页面
- en: 'Additionally, you can take a look at the query being executed to retrieve the
    user data (**getUser**):'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以查看用于检索用户数据的查询（**getUser**）：
- en: '![A screenshot of a computer screen  Description automatically generated](img/B18414_13_35.png)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图描述自动生成](img/B18414_13_35.png)'
- en: 'Figure 13.35: getUser data'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.35：获取用户数据
- en: 'Here, you will see that the payload is returned:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将看到返回的负载：
- en: '![Text  Description automatically generated](img/B18414_13_36.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B18414_13_36.png)'
- en: 'Figure 13.36: getUserData payload'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.36：getUserData负载
- en: 'We get the user information from the access token (**at**). If you refresh
    the page, you should remain connected to the page. This is because we saved a
    cookie containing our token:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从访问令牌（**at**）中获取用户信息。如果您刷新页面，您应该保持连接到页面。这是因为我们保存了一个包含我们的令牌的cookie：
- en: '![Text  Description automatically generated](img/B18414_13_37.png)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B18414_13_37.png)'
- en: 'Figure 13.37: Cookies'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.37：Cookies
- en: 'Now, let’s try to modify the cookie by changing any letter of the token. For
    example, let’s change the first two letters (**ey**) to **XX**:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试通过更改令牌中的任何字母来修改cookie。例如，让我们将前两个字母（**ey**）更改为**XX**：
- en: '![Table  Description automatically generated](img/B18414_13_38.png)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![表格描述自动生成](img/B18414_13_38.png)'
- en: 'Figure 13.38: Updating a cookie'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.38：更新cookie
- en: 'Here, you will receive empty data for the user. This will invalidate the session
    and redirect you to the login page again:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将收到用户的空数据。这将使会话无效，并再次将您重定向到登录页面：
- en: '![Text  Description automatically generated](img/B18414_13_39.png)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B18414_13_39.png)'
- en: 'Figure 13.39: Empty data'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.39：空数据
- en: Now, you have learned how to implement GraphQL in a backend and how to consume
    queries and mutations in the frontend.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经学会了如何在后端实现GraphQL以及如何在前端消费查询和突变。
- en: This login system is part of a course I’m doing on YouTube, where I’m teaching
    viewers how to develop a headless CMS from scratch, so if you’re eager to learn
    more, you can check out the course at [https://www.youtube.com/watch?v=4n1AfD6aV4M](https://www.youtube.com/watch?v=4n1AfD6aV4M).
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 这个登录系统是我正在YouTube上开设的一门课程的组成部分，我在课程中教授观众如何从头开始开发一个无头CMS，所以如果你渴望了解更多，你可以查看课程[https://www.youtube.com/watch?v=4n1AfD6aV4M](https://www.youtube.com/watch?v=4n1AfD6aV4M)。
- en: Summary
  id: totrans-451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: I hope you found this chapter on GraphQL, JWT creation, login functionality,
    and Sequelize model creation informative and engaging. It provided a wealth of
    valuable insights and practical tips that you can apply to your own projects,
    helping you to streamline your development process and achieve your goals more
    efficiently. By mastering these concepts, you’ll be better equipped to build robust,
    scalable applications that meet the needs of your users and drive your success.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你觉得这一章关于GraphQL、JWT创建、登录功能以及Sequelize模型创建的内容既信息丰富又引人入胜。它提供了大量宝贵的见解和实用技巧，你可以将这些应用到自己的项目中，帮助你简化开发过程，更高效地实现目标。通过掌握这些概念，你将更好地装备自己，构建强大、可扩展的应用程序，满足用户需求并推动你的成功。
- en: Thank you for reading, and I look forward to sharing more with you in the next
    chapter, where you will learn how to create a monorepository and a multi-site
    project.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您的阅读，我期待在下一章中与您分享更多内容，届时你将学习如何创建单仓库和多站点项目。
