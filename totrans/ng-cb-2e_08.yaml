- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mastering Angular Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting user input is an integral part of almost any modern app that we use.
    Whether it is authenticating users, asking for feedback, or filling out business-critical
    forms, knowing how to implement and present forms to end users is always an interesting
    challenge. In this chapter, you’ll learn about **Angular forms** and how you can
    create great user experiences using them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the recipes that we’re going to cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first template-driven form with validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first reactive form with form validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing forms in Angular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server-side validation using asynchronous validator functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing complex forms with reactive `FormArray`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own custom form control using `ControlValueAccessor`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the recipes in this chapter, ensure your setup is complete as per the ''Technical
    Requirements'' in the ''Angular-Cookbook-2E'' GitHub repository. For setup details,
    visit: [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md).
    The starter code for this chapter is located at [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter08](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter08).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first template-driven form with validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start getting familiar with Angular forms in this recipe. In this one,
    you’ll learn about the basic concepts of template-driven forms and will create
    a basic Angular form, using the template-driven forms API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter08/ng-tdf`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_08_01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 8.1: ng-tdf app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have an Angular app that already has a bunch of components and some UI setup.
    We need to implement the functionality to add a new version to the logs. We’ll
    use a template-driven form to allow the user to pick an app and submit a release
    version. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll add the `FormsModule` in the `src/app/components/version-control/version-control.component.ts`
    file in the project, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll use a template-variable with `NgForm` and `NgModel` on the form
    input inside the component’s HTML file to use template-driven forms. Update the
    `version-control.component.html` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s create a method that will be triggered when the form is submitted. Update
    the `version-control.component.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have the form submit handler, let’s add the event listener to the
    template. Update the `version-control.component.html` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After adding this, you should be able to add new versions. However, you can
    use any value for the input or even provide nothing, and it will add as a new
    version. See the following screenshot for an example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_08_02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 8.2: ng-tdf app without form validation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We’ll add some form validation going forward. First of all, we’ll make sure
    we only change the value of the `versionName` property when the form has a valid
    input. Update the `formSubmit` method in the `version-control.component.ts` file,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now add some validations in the template file. We’ll make the required
    input and ensure that the version provided follows semantic versioning. Update
    the `version-control.component.html` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you try submitting the form now with an invalid value, you’ll see that the
    version provided doesn’t get added to the logs, but if you provide a valid version
    like `2.1.0`, it will be added to the logs. However, this isn’t great in terms
    of UX, since it doesn’t tell us what’s wrong.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s show some error messages based on the form validation we have. Update
    the `version-control.component.html`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you now submit the form without any input, you should see the following
    error:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_08_03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 8.3: ng-tdf app with form validation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: And if you try giving it the wrong value, you’ll see a different error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Great! Within a few minutes, we were able to create our first template-driven
    form in Angular with form validation. If you refresh the app now and add some
    versions, you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_08_04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 8.4: ng-tdf app final output'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that you know how the template-driven forms are created, let’s see the next
    section to understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key to using template-driven forms in Angular resides in `FormsModule`,
    the `ngForm` directive, and the `ngModel` binding. This would almost always include
    template variables along with the `name` attributes for inputs in the template.
    We began by adding the `FormsModule` in the `VersionControlComponent` class, which
    is necessary to use the `ngForm` directive and the `[(ngModel)]` two-way data
    binding. Then, we added the `[(ngModel)]` to the version input. We also added
    the `ngForm` attributeon the `form` element, similarly creating a `#versionForm`
    variable so that we can use it to see if the entire form is valid. Then, we added
    the `ngSubmit` handler to the `form` element so that we could trigger a method
    when the form is submitted. We also added the respective method named `formSubmit`
    in the `VersionControlComponent` class as well. Notice that we pass the `versionForm`
    variable to the `formSubmit` method, which makes it easier to test the functionality
    for us. Upon submitting the form, we use the form in the `formSubmit` method to
    get the value of the input and to create a new `version-log` item. Notice that
    we access the control/input by using `form.controls['version']`. The key version
    directly corresponds to the value of the `name` attribute on the input element
    in the template. `ngForm` automatically creates a `FormControl` instance for us,
    using the value of the `name` attribute of the input, and thus we can access it
    that way. Also, notice that if you provide an invalid version for the new release
    log, the app will show the respective errors based on either the empty input,
    or an invalid version format. This is because we have the `required`attribute
    set on the `<input />` element as well as the `pattern` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Building a template-driven form in Angular*: [https://angular.io/guide/forms#building-a-template-driven-form](https://angular.io/guide/forms#building-a-template-driven-form)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Show and hide* *validation error messages* (Angular docs): [https://angular.io/guide/forms#show-and-hide-validation-error-messages](https://angular.io/guide/forms#show-and-hide-validation-error-messages
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first reactive form with validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve learned about template-driven forms in the previous recipe and are now
    confident in building Angular apps with them. Now, guess what? reactive forms
    are even better. Many known engineers and businesses in the Angular community
    recommend using only reactive forms for Angular apps. The reason is that when
    it comes to complex forms, Reactive forms make it easy to manage, i.e., you can
    decouple your form’s logic from the template and add validators dynamically, etc.
    In this recipe, you’ll build your first Reactive form and will learn its basic
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter08/ng-reactive-forms`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_08_05.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 8.5: ng-reactive-forms app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let’s see the steps involved in this
    recipe in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have an app that has a `VcLogsComponent`, which shows a bunch of
    version logs that we create. We also have a `VersionControlComponent`, which has
    a form with which the release logs will be created. We now have to make our current
    form a Reactive form, using the reactive forms API. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to import `ReactiveFormsModule` into the imports of our
    `AppModule`. Let’s do it by modifying the `app/components/version-control/version-control.component.ts`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll create the Reactive form shortly. First, import the required dependencies
    in the `version-control.component.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll create a `FormGroup` in our `VersionControlComponent` class with
    a control named `version`. A `FormGroup` allows us to group multiple controls
    together in a form. Modify the `version-control.component.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have the Reactive form in place, let’s bind the `versionForm` in
    the template to the `<form>` element. Update the `version-control.component.html`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Great! Now that we have the form group bound, we can also bind the `version`
    form control. Modify the `version-control.component.html` file further, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s decide what will happen when we submit this form. We’ll call a method
    named `formSubmit` in the template and pass `versionForm` to it when the form
    is submitted. Modify the `version-control.component.html` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `formSubmit` method doesn’t yet exist. Let’s create it now in the `VersionControlComponent`
    class. Modify the `version-control.component.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you try submitting the form now with an invalid value, you’ll see that the
    version provided doesn’t get added to the logs, but if you provide a valid version
    like `2.1.0`, it will be added to the logs. However, this isn’t great in terms
    of UX, since it doesn’t tell us what’s wrong.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s show some error messages based on the form validation we have. Update
    the `version-control.component.html`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you now type something in the form and clear the input, you should see an
    error, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_08_06.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 8.6: ng-reactive-forms app with form validation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: And if you try giving it the wrong value, you’ll see a different error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Great! Within a few minutes, we were able to create our Reactive form in Angular
    with form validation. See the next section to understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work with reactive forms in Angular, we need to import the `ReactiveFormsModule`
    in the components in the case of standalone components, and in the `NgModule`
    if you’re using modules. In the recipe, we do exactly that, i.e., import the `ReactiveFormsModule`
    in the `VersionControlComponent` class’s `imports` array. After that, we create
    a `FormGroup`, which is a Reactive form, and it takes an object as an argument
    for the constructor function. The object passed to the constructor can have further
    `FormControl`, nested form groups, and `FormArray`, etc. because they all inherit
    the `AbstractControl` class, as shown in *Figure 8.6*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18469_08_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: Base class AbstractControl being inherited'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our recipe, we provide a key named `version` against a `FormControl`. The
    `FormControl` constructor method takes two arguments in our recipe; the first
    one is the default value, and the second is an array of `Validators`. Notice that
    we’re using the following validators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Also, notice that the pattern we’re using to validate semantic versioning is
    `([0-9]+)\.([0-9]+)\.([0-9]+)`. We then use the `FormGroup` (i.e., the `versionForm`
    variable) in the template on the `<form>` element, using the `[formGroup]` binding.
    We then bind the `version` `FormControl` in the template using the `formControlName`
    attribute. We handle the form submission using the `(ngSubmit)` listener on the
    `<form>` element. In the `VersionControlComponent` class, we have the `formSubmit`
    method to handle the form submission. This is also what we bind the event listener
    to in the template. When this method is called, we check if the form is valid.
  prefs: []
  type: TYPE_NORMAL
- en: The validation on each `FormGroup`, `FormArray`, or `FormControl` happens on
    the `change`, `blur`, or `submit` event. And since they are inherited from the
    `AbstractControl` class, they can be configured via the `updateOn` property on
    the `AbstractControl`. In our case, the validation happens on `change` by default.
    If the form is not valid, we simply do not do anything. Otherwise, we set the
    value of the `versionName` property, which adds a new log to the logs list.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we show the errors based on the form validation in the template, using
    the `errors`property on the `version` form control. When the form is empty after
    making any initial change to it, the `errors` object on the form control gets
    the `required` property set to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: When the user adds a value to the input, the `required` property is removed,
    and the validation of `pattern` gets triggered, and if the pattern `([0-9]+)\.([0-9]+)\.([0-9]+)`
    doesn’t match the value of the input, we get the `pattern` property added to the
    form control’s `errors` object. Notice that in *step 8*, we use these properties
    from the `errors` object to show the relevant error.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular’s guide to reactive forms: [https://angular.io/guide/reactive-forms](https://angular.io/guide/reactive-forms)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing forms in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make sure we build robust and bug-free forms for end users, it is a really
    good idea to have tests relating to your forms. It makes code more resilient and
    less prone to errors. In this recipe, you’ll learn how to test your template-driven
    forms using unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter08/ng-testing-forms`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project along with the backend server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_08_08.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 8.8: ng-testing-forms app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let’s see the steps involved in this
    recipe in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have an app that contains three different components. The first one has
    a template-driven form, the second one has a reactive form with validations, and
    the third has a reactive form with both synchronous and asynchronous validations.
    The implementation of all three of them is identical, except the third component’s
    validation kicks in as soon as the form is dirty instead of waiting to be submitted.
    The form also has validations applied to the inputs. Let us start looking into
    how we can test this form:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, run the following command to run the unit tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the command is run, you should see all the tests passing on the console
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_08_09.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 8.9: Unit tests running with ng-testing-forms'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let us write the tests for the template-driven form. This is easy. We will
    update the `version-control-tdf.component.spec.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you look at the tests now, you should see all the tests passing as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_08_10.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 8.10: First test for template-driven forms passing'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s add another test to the file. This will test if we are able to see the
    error message of the required input. Let’s update the `version-control-tdf.component.spec.ts`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s add one more test. This will test if we are able to see the message for
    the pattern of the version being valid. Add the following test to the same file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Great! You should see all the tests still passing. The fun fact is that the
    tests are identical for the Reactive form (with synchronous validators only) example
    as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Copy all the three tests we added from *step 2* to *step 4* to the file `version-control-rf.component.spec.ts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now comes the tricky part, i.e., working with `async` validators. We cannot
    just copy and paste the tests for this one and expect the tests to pass when we
    have an incorrect version provided in the form. We need some additional work to
    do in this case. First, copy the same tests from the `version-control-tdf.component.spec.ts`
    file into the `version-control-rf-async.component.spec.ts` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will notice that we have two tests failing now, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_08_11.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 8.11: Tests failing for a form with asynchronous validators, using a
    service'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We are going to mock the `FormValidationService` for our tests. Update the
    `version-control-rf-async.component.spec.ts`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let us provide our mock service to the `TestBed` for the tests in the same
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the above change, the tests `'should submit the form with valid version'`
    and `'should show required error'` should pass. Yay! However, the last test failed.
    We will fix that.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s update the final failing test. We are going to update our `FormValidationServiceMock`
    object to return a `pattern` error if there is an invalid input. Update the file
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And voila! All of the tests should be passing now, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_08_12.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 8.12: All tests passing for the recipe'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Awesome! You now know a bunch of techniques to test your Angular forms. However,
    some of these techniques might still require some explanation. See the next section
    to understand how it all works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing Angular forms can be a bit of a challenge, as it depends on how complex
    the form is, what use cases you want to test, and how complex those use cases
    are. This is also true for cases where you have several dependencies to work with.
    In our recipe, we started with the template-driven forms, and it was easy for
    us to test them, since the component has a `ViewChild()` of the type `NgForm`.
    This makes it easier to write our first test that sets the value of the `version`
    form control. Then, we click the **Submit** button and expect the component’s
    `versionName` property value to be the one we entered in the form. Easy peasy!
  prefs: []
  type: TYPE_NORMAL
- en: For the second test, we first set the value of the form to `2.2.4`, and then
    we empty the form by setting the value to an empty string. Then, we submit the
    form and expect the value of the component’s `versionName` property to remain
    unchanged and still be `0.0.0`. However, what we also check is that, inside the
    form, we can see the error that says, `'Version number is required'`. Notice that
    we use the `fixture.debugElement.nativeElement.querySelector` method to get the
    desired error element, and then we check its `textContent` value.
  prefs: []
  type: TYPE_NORMAL
- en: For the test to check the pattern, we do the same as for the second test, but
    instead of emptying the input, we provide `'``invalid input'` as the new value
    to the form control. The template-driven form picks it and shows the error `'Version
    number does not match the pattern (x.x.x)'`, which is what we expect in the test
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: The same three tests work exactly the same as the `Reactive Forms` example we
    have. The difference this time is that the `versionForm` property in the component
    is not `NgForm` but, rather, a `FormGroup`. It is amazing that Angular has the
    same API (i.e., the same methods) in both `NgForm`and `FormGroup`to set and retrieve
    the values. This is because it creates a top-level `FormGroup` behind the scenes,
    thus making our tests the same.
  prefs: []
  type: TYPE_NORMAL
- en: For the tests with `async` validators, we did something special. Apart from
    copying and pasting the tests from the other examples, we had to mock the `FormValidationService`.
    This is because this example had an asynchronous validator function, which comes
    from the `FormValidationService`class, and it is a general best practice to mock
    all the dependencies of a unit so that we can purely test it.
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating a stub named `FormValidationServiceMock` (we’ll learn more
    about stubs in *Chapter 10* ,*Writing Unit Tests in Angular with Jest*). Then,
    we provide this stub in the `TestBed` against the `FormValidationService` class.
    Finally, we make sure that our `versionValidator` method in the stub returns the
    correct error when the input is not valid. And that’s it. Without many changes
    in the tests themselves, we are able to test all three kinds of forms with minor
    adjustments. I hope you learned quite a few techniques in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Testing* *template-driven forms*: [https://angular.io/guide/forms-overview#testing-template-driven-forms](https://angular.io/guide/forms-overview#testing-template-driven-forms)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server-side validation using asynchronous validator functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Form validations are straightforward in Angular, with the reason being the super-awesome
    validators that Angular provides out of the box. These validators are synchronous,
    meaning that as soon as you change the input, the validators kick in and provide
    you with information about the validity of the values right away. However, sometimes,
    you might rely on some validations from a backend API or have some asynchronous
    logic that you need to execute to validate the form value. These situations would
    require something called asynchronous validators. In this recipe, you’re going
    to create your first asynchronous validator.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter08/ng-rf-async-validator`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project along with the backend server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_08_13.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 8.13: Asynchronous validators app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running, let’s see the steps involved in this recipe
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already have the backend with an endpoint that can accept a version as a
    query parameter, returning a `boolean` for if the provided version is a valid
    version according to the pattern (`x.x.x`) and is a newer version than the previously
    provided one. We’ll create an `async` validator to make sure that the new releases
    have a valid version. Let’s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will modify the `VersionService` class in the `version.service.ts`
    file, as follows, to add a method to validate the form input via the `http://localhost:3333/api/version/validate`
    endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now create an **Async Validator Function** (`AsyncValidatorFn`) inside
    the `VersionService` class. This is something we will bind later to the form in
    the app. Let us update the `version.service.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will use the `versionValidator` method we just created inside the `VersionControlComponent`
    class with the `versionForm`. To do that, let’s modify the `version-control.component.ts`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you now try submitting a version equal to or lower than the last submitted
    one, you will receive an error, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_08_14.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 8.14: Error being shown when a lower or equal version number is provided'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Cool! So, you now know how to create an asynchronous validator function in Angular
    for form validation within reactive forms. Since you’ve finished the recipe, refer
    to the next section to see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular provides an effortless way to create `async` validator functions, and
    they’re handy too. We use an `async` validator function when there needs to be
    a validation that can be time-consuming and we don’t want to block the main thread,
    or when we rely on a backend service for validation. For example, in this recipe,
    we started by creating the validator method named `versionValidator` inside a
    new service, called `VersionService`. Notice that we are using a couple of RxJS
    operators in the method, including `timer`, `switchMap`, and `map`. We use the
    `timer` operator to debounce and wait for the user to stop typing for **500**
    milliseconds. We then use the `switchMap` operator combined with the `validateVersion`
    method to make an HTTP call to the backend, validating the version. The benefit
    of `switchMap` here is that it cancels out existing HTTP calls, if any. Then,
    we use the `map` operator to remove the error from the HTTP call. If there’s no
    error, we return an empty object from the map function’s callback. If we have
    an error, we set the `[error]` as `true` in the `errors` object, as shown in *step
    4*.
  prefs: []
  type: TYPE_NORMAL
- en: After creating the validator function, we attached it to the form control for
    the version name by using the `FormControl.setAsyncValidators` method in the `VersionControlComponent`
    class. We then used the validation errors, named `pattern` and `oldVersion`, in
    the template to show the relevant error message on the UI.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`AsyncValidator` Angular docs: [https://angular.io/api/forms/AsyncValidator#provide-a-custom-async-validator-directive](https://angular.io/api/forms/AsyncValidator#provide-a-custom-async-validator-directive)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing complex forms with reactive FormArray
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is definitely one of the most requested recipes from the readers of the
    first edition of *Angular Cookbook*. In this recipe, we’ll work with reactive
    Forms and specifically, the `FormArray` class from reactive forms. We’re going
    to implement a complex form, which has a list of projects that can be submitted
    with reactive forms. The user will be able to add as many projects as they want
    and will be able to remove the ones they don’t want.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter08/ng-form-arrays`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_08_15.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 8.15: reactive FormArray app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let’s see the steps involved in this
    recipe in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have an app that already implements a Reactive form. However, we can only
    add one project so far. We will use reactive `FormArray` to let the user submit
    multiple projects, and we will use the Reactive `FormBuilder`, which is a nice
    little API from the `@angular/forms` package that makes it easy to create and
    maintain reactive forms in Angular. Let us begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let’s use the Reactive `FormBuilder` to add a `FormArray` to
    the existing Reactive form in the `portfolio-form.component.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have the `projects` `FormArray`, let’s use that in the template
    so that we can show the form inputs for the projects, according to the form array.
    Let’s modify the `portfolio-form.component.html` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You’ll notice that the object on the right in the app has a `projects` array
    now. However, we can see no inputs for the projects at the moment. That’s because
    the form array is empty, as shown in the following figure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_08_16.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 8.16: reactive FormArray app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We’ll add one form group to the form array by default when the app starts.
    To do this, modify the `portfolio-form.component.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you look at the app now, you should see one set of inputs for the projects,
    as shown in the following figure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_08_17.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 8.17: One set of inputs for projects by default'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s add a button for the user to be able to add more projects. We’ll modify
    the `portfolio-form.component.html` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the code above, you should see new project inputs appearing with the click
    of the `+` button.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s add our final feature for this recipe, which is showing buttons to remove
    the project’s input row. We’ll first add a method in the `portfolio-form.component.ts`
    file that receives the index of the row to be removed as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll update the template to add the `Remove` button. Update the `portfolio-form.component.html`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you now look at the app, you should be able to add or remove projects to
    the form as you like, as shown in the following figure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_08_18.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 8.18: Final result with form arrays'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Great! You now know how to work with reactive `FormArray`. Refer to the next
    section to understand how it all works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular’s `FormArray` is an amazing tool built into the reactive Forms in Angular.
    It aggregates all values of each child `FormControl` or `FormGroup` into an array.
    The beauty of the `FormArray` is that if any one of the child `FormControls` is
    invalid, the whole array becomes invalid. In this recipe, we start by using the
    `FormBuilder` from the `ReactiveFormsModule` in the `PortfolioFormComponent` class.
    We initialize it with an empty `FormArray` and then push one `FormGroup` to it
    when the component mounts (using the `ngOnInit`method). This is so we can see
    one set of form inputs for the projects. Note that we use the `addNewProject`
    method for this. Also note that we use a `getter` function, named `projectsFormArr`,
    so that we can easily access the `FormArray` to be able to loop over it, add Form
    Groups to it, and remove the desired `FormGroups` from it when needed. We then
    loop over the `projectsFormArr.controls` array so that we can display the inputs
    via the HTML template, using the `*ngFor` directive.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we modify the template to add the + button so that we can add more projects
    to the form array. Note the statement in the `*ngFor` has `let isLast = last`.
    The `*ngFor` directive provides us with the first and last variables automatically,
    so we can use them in our template. This statement creates a variable named `isLast`
    for us, and it assigns the value of the `last` variable provided by the `*ngFor`
    directive (which is a Boolean) to it. This is so we can show the + button only
    on the last row instead of on every row.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we add the `remove` button to each row except for the last one so we
    can remove the respective `FormGroup` from the `FormArray`. Note that here we
    also add `let i = index` to the template in the `*ngFor` directive. This is because
    our `removeProject` method in the TypeScript file expects the index of the `FormGroup`
    in the `FormArray` to be passed in it when it is called. Hence, we’re able to
    get the index for each `FormGroup` from the `*ngFor` directive and can pass the
    index to the `removeProject` method. We use `[hidden]="isLast"` on each `remove`
    button so that it is hidden onthe last row only. This is because we show the +
    button on the last row and we need to have at least one empty row for the projects.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular `FormArray`: [https://angular.io/api/forms/FormArray](https://angular.io/api/forms/FormArray)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own custom form control using ControlValueAccessor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular forms are great. While they support the default HTML tags like `input`,
    `textarea`, etc., sometimes, you might want to define your own components that
    take a value from the user. What if your components could work seamlessly with
    Angular forms, i.e., using f`ormControlName`, `ngModel`, and so on? That would
    be cool, right?
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you’ll learn how to create a component with your own custom
    form control using the `ControlValueAccessor` API, allowing you to use your component
    with both template-driven forms and reactive forms.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter08/ng-form-cva`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_08_19.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 8.19: Custom form control app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let’s see the steps involved in this
    recipe in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have a simple Angular app. It has two inputs and a **Submit** button. The
    inputs are for a review, and they ask the user to provide a value for the rating
    of this imaginary item and any comments the user wants to provide. We’ll convert
    the rating input into a custom `FormControl` using the `ControlValueAccessor`
    API. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a component for our custom `FormControl` Open the terminal in
    the project root and run the following command and select the `@nx/angular:component
    schematics` and “As provided” when asked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll now create the `star` UI for the `rating` component. Modify the `rating.component.html`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the styles for the `rating` component to the `rating.component.scss` file
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to modify the `RatingComponent` class to introduce the necessary
    methods and properties. Let’s modify the `rating.component.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s import the `RatingComponent` class in the `HomeComponent` class because
    `RatingComponent` is a `standalone` component. Update the `home.component.ts`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to use this `rating` component instead of the input that we already
    have in the `home.component.html` file. Modify the file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you refresh the app now and hover over the stars, you can see the color
    change. The selected rating is also highlighted as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_08_20.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 8.20: Rating component with hovered stars'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s now implement the `ControlValueAccessor` interface for our `rating` component.
    It requires a couple of methods to be implemented. Modify the `rating.component.ts`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll now add the required methods to disable the input when required and to
    set the value of the form control – in other words, the `setDisabledState` and
    `writeValue` methods. We’ll also add the `disabled` property to our `RatingComponent`
    class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to use the `disabled` property to prevent any UI changes when it is
    `true`. The value of the `value` variable should not be updated either. Modify
    the `rating.component.ts` file to do so, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the above change, you’ll notice that hovering over the stars doesn’t do
    anything now because of the `disabled` property being set to `true`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s make sure that we send the value of the `value` variable to `ControlValueAccessor`
    because that’s what we want to access later. Also, let’s set the `disabled` property
    back to `false`. Update the `selectRating` method in the `RatingComponent` class,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to tell Angular that our `RatingComponent` class has a `value` accessor;
    otherwise, using the `formControlName` attribute on the `<app-rating>` element
    will throw errors. Let’s add an `NG_VALUE_ACCESSOR` provider to the `RatingComponent`
    class’s decorator, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you refresh the app now, select a rating, and hit the **Submit** button,
    you should see the values being logged, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_08_21.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 8.21: Form value logged using the custom form control'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Voilà! You just learned how to create a custom form control using `ControlValueAccessor`.
    Refer to the next section to understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We started the recipe by creating a component we can use to provide a rating
    for the review we submit. We started by adding the template and the styles for
    the `rating` component. Note that we are using an `[ngClass]` directive on each
    of the `star` elements to add the `rating__star--active` class conditionally.
    Let’s discuss each condition now:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(isMouseOver && hoveredRating >= star)`: This condition relies on the `isMouseOver`
    and `hoveredRating` variables. The `isMouseOver` variable becomes `true` as soon
    as we mouse over any star and is turned back to `false` when we move away from
    the star. This means that it is only `true` when we’re hovering over a star. `hoveredRating`
    tells us which star we’re hovering over at any moment and is assigned the star’s
    value – in other words, a value from `1` to `5`. So, this condition is only `true`
    when we’re doing a mouseover, and the hovered star’s rating is greater than the
    value of the current star. So, if we’re hovering over the fourth star, all the
    stars from value `1` to `4` will be highlighted, as they’ll have the `rating__star--active`
    class conditionally assigned to them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(!isMouseOver && value >= star)`: This condition relies on the `isMouseOver`
    variable that we discussed previously and the `value` variable. The `value` variable
    holds the value of the selected rating, which is updated when we click on a star.
    So, this condition is applied when we’re not doing a mouseover, and we have the
    value of the `value` variable greater than the current star. This is especially
    beneficial when you have a greater value assigned to the `value` variable and
    try to hover over a star with a lesser value, in which case, all the stars with
    values greater than the hovered star will not be highlighted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we used three events on each star, `mouseenter`, `mouseleave`, and `click`,
    and then used our `onRatingMouseEnter`, `onRatingMouseLeave`, and `selectRating`
    methods, respectively, for these events. All of this was designed to ensure that
    the entire UI is fluent and provides a good user experience. We then implemented
    the `ControlValueAccessor` interface for our `rating` component. When we do that,
    we need to define the `onChange` and `onTouched` methods as empty methods, which
    we did as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we used the `registerOnChange` and `registerOnTouched` methods from `ControlValueAccessor`
    to assign our methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We registered these methods because whenever we make a change in our component
    and want to let `ControlValueAccessor` know that the value has changed, we need
    to call the `onChange` method ourselves. We do that in the `selectRating` method
    as follows, which makes sure that when we select a rating, we set the form control’s
    value to the value of the selected rating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The other way around is when we need to know when the form control’s value
    is changed from outside the component. In this case, we need to assign the updated
    value to the `value` variable. We do that in the `writeValue` method from the
    `ControlValueAccessor` interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: What if we don’t want the user to provide a value for the rating? In other words,
    we want the rating form control to be disabled. For this, we use the `setDisabledState`
    method from the `ControlValueAccessor` interface, so whenever the form control’s
    `disabled` state is changed, we set the `disabled` property to reflect the changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we wanted Angular to know that this `RatingComponent` class has a
    value accessor. This is so that we can use the reactive forms API – specifically,
    the `formControlName` attribute with the `<app-rating>` selector – and use it
    as a form control. To do that, we provide our `RatingComponent` class as a provider
    to its `@Component` definition decorator, using the `NG_VALUE_ACCESSOR` injection
    token, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we’re using the `useExisting` property with the `forwardRef` method
    providing our `RatingComponent` class in it. We need to provide `multi: true`
    because Angular itself registers some value accessors using the `NG_VALUE_ACCESSOR`
    injection token, and there may also be third-party form controls.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we’ve set everything up, we use `formControlName` on our `rating` component
    in the `home.component.html` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Custom form control in Angular by `thoughtram`: [https://blog.thoughtram.io/angular/2016/07/27/custom-form-controls-in-angular-2.html](https://blog.thoughtram.io/angular/2016/07/27/custom-form-controls-in-angular-2.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ControlValueAccessor` docs: [https://angular.io/api/forms/ControlValueAccessor](https://angular.io/api/forms/ControlValueAccessor)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/AngularCookbook2e](Chapter_8.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1388317275422265.png)'
  prefs: []
  type: TYPE_IMG
