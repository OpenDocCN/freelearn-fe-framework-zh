- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Angular and RxJS – Awesomeness Combined
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 和 RxJS – 强强联合
- en: '**Angular** and **RxJS** create a killer combination of awesomeness. By combining
    these, you can handle your data reactively, work with streams, and implement complex
    business logic in your Angular apps. That’s exactly what you’re going to learn
    about in this chapter.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**Angular** 和 **RxJS** 构成了一个令人惊叹的强大组合。通过结合这些技术，你可以在 Angular 应用程序中以响应式的方式处理数据，处理流，并在
    Angular 应用程序中实现复杂的企业逻辑。这正是本章将要介绍的内容。'
- en: 'Here are the recipes we’re going to cover in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将介绍以下食谱：
- en: Sequential and parallel HTTP calls in Angular with RxJS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Angular 中使用 RxJS 进行顺序和并行 HTTP 请求
- en: Listening to multiple observable streams
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听多个可观察流
- en: Unsubscribing streams to avoid memory leaks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消订阅流以避免内存泄漏
- en: Using Angular’s `async` pipe to unsubscribe streams automagically
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Angular 的 `async` 管道自动取消订阅流
- en: Using the `map` operator to transform data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `map` 操作符转换数据
- en: Using the `switchMap` and `debounceTime` operators with autocompletes for better
    performance
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `switchMap` 和 `debounceTime` 操作符与自动完成功能以获得更好的性能
- en: Creating a custom RxJS operator
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义 RxJS 操作符
- en: Retrying failed HTTP calls with RxJS
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 RxJS 重试失败的 HTTP 请求
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For the recipes in this chapter, ensure your setup is complete as per the ''Technical
    Requirements'' in the ''Angular-Cookbook-2E'' GitHub repository. For setup details,
    visit: [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md).
    The starter code for this chapter is located at [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter05](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter05).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的食谱，确保你的设置已按照 'Angular-Cookbook-2E' GitHub 仓库中的 'Technical Requirements'（技术要求）完成。有关设置详情，请访问：[https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md)。本章的起始代码位于
    [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter05](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter05)。
- en: Sequential and parallel http calls in Angular with RxJS
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Angular 中使用 RxJS 进行顺序和并行 HTTP 请求
- en: In this recipe, you’ll learn how to use different RxJS operators to make sequential
    and parallel HTTP calls in Angular apps. We’ll work with the famous Star Wars
    API (**swapi**) to get some data to display on the UI.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，你将学习如何使用不同的 RxJS 操作符在 Angular 应用程序中进行顺序和并行 HTTP 请求。我们将使用著名的星球大战 API（**swapi**）获取一些数据以在
    UI 上显示。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter05/rx-seq-parallel-http`
    inside the cloned repository:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用程序位于克隆的仓库中的 `start/apps/chapter05/rx-seq-parallel-http`：
- en: Open the code repository in your code editor.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以运行项目：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会在新浏览器标签页中打开应用程序，你应该会看到以下内容：
- en: '![](img/B18469_05_01.png)'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_05_01.png)'
- en: 'Figure 5.1: The rx-seq-parallel-http app running on http://localhost:4200'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.1：运行在 http://localhost:4200 的 rx-seq-parallel-http 应用程序
- en: Now that we have the app running, we will move on to the steps for the recipe.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经运行了应用程序，我们将继续进行食谱的步骤。
- en: How to do it…
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'We have an Angular app that uses the Star Wars API (swapi) to fetch a person
    from Star Wars, and the films the person has been in. All of this happens using
    a lot of HTTP calls, and our code is totally garbage so far. This is because we
    first show the loader, but we hide it before we’ve retrieved all the data. Also,
    if you keep refreshing the page, you’ll see that the sequence of the films can
    change each time. Hence, we see the UI jumping a lot. Our desired approach is
    to fetch the person, then fetch all the films, and then hide the loader. We will
    implement this approach using RxJS. Let’s begin:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个使用 Star Wars API (swapi) 从星球大战中获取人物及其参与的电影的 Angular 应用程序。所有这些操作都通过大量的 HTTP
    请求完成，而我们的代码到目前为止完全是垃圾。这是因为我们首先显示加载器，但在我们检索所有数据之前就将其隐藏了。此外，如果你不断刷新页面，你会看到电影序列每次都会改变。因此，我们看到了
    UI 跳动很多。我们希望的方法是先获取人物，然后获取所有电影，然后隐藏加载器。我们将使用 RxJS 实现这种方法。让我们开始吧：
- en: 'First, we’ll avoid using the `setTimeout` function to rely on the person data
    being available in `1500ms`. We would rather move this inside the `subscribe`
    block and will also handle errors appropriately. Update the `fetchData` method
    inside the `app.component.ts` as follows:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将避免使用`setTimeout`函数，而是依赖于在`1500ms`内获取到人员数据。我们更愿意将此操作移至`subscribe`块内部，并且也会适当地处理错误。按照以下方式更新`app.component.ts`中的`fetchData`方法：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This has a potential problem. And that is, as soon as the first film is retrieved,
    the loader is hidden because we set `this.loadingData` to `false`.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这存在一个潜在问题。那就是，一旦检索到第一部电影，加载器就会隐藏，因为我们把`this.loadingData`设置为`false`。
- en: 'Now, we will add the `mergeMap` operator using the `pipe` method to be able
    to chain calls later. For now, we will just move the code for adding the `filmObjects`
    array in the `this.person` object inside the `mergeMap` callback. Update the `fetchData`
    method as follows now:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用`pipe`方法添加`mergeMap`操作符，以便以后能够链式调用。目前，我们只需将添加`filmObjects`数组到`this.person`对象的代码移至`mergeMap`回调中。现在按照以下方式更新`fetchData`方法：
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that the UI becomes *a bit better*. The loader still hides as soon as
    one of the films is retrieved from the server. However, we want to hide the loader
    when all of them have been retrieved. Also, the sequence of the films is still
    unpredictable.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到UI变得*稍微好一些*。加载器仍然会在从服务器检索到任何一部电影后立即隐藏。然而，我们希望在所有电影都检索完毕后隐藏加载器。此外，电影的顺序仍然不可预测。
- en: 'Now, we’ll use the `forkJoin` function to make the API calls for the films
    in parallel and to wait for the combined response. We’re doing it instead of the
    `of` operator, which just passes the film URLs from the `mergeMap` function. Update
    the `fetchData` method as follows and update the imports at the top:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用`forkJoin`函数并行地对电影进行API调用，并等待合并后的响应。我们这样做而不是使用`of`操作符，因为`of`操作符只是从`mergeMap`函数传递电影URL。按照以下方式更新`fetchData`方法，并更新顶部的导入：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Woohoo! Now if you refresh the app, you’ll notice two things. First, the loader
    always stops only when all the data has been fetched. And second, the sequence
    of the films is always the same (and correct).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 哇哦！现在如果你刷新应用，你会注意到两件事。首先，加载器只有在所有数据都检索完毕后才会停止。其次，电影的顺序总是相同（并且正确）。
- en: Now that you’ve finished the recipe, let’s move on to the next section to understand
    how it all works.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了食谱，让我们继续到下一部分，了解这一切是如何工作的。
- en: How it works…
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `mergeMap` operator allows us to chain observables by returning an **observable**
    from its callback. You can think of it like how we chain `Promise.then`, but this
    is for observables. A popular alternative is the `switchMap` operator, which works
    like the `mergeMap` operator but also cancels the previous call/execution if called
    twice or more before the first call/execution completes. We first removed the
    `setTimeout` function (which is mostly nonsensical to put into the code for these
    cases because the result is not always predictable with respect to time) and moved
    the logic of fetching films inside the `subscribe` block of fetching the person.
    We also used the `of` operator to return the `personObject` object from the `mergeMap`
    function’s callback. The `mergeMap` function is used to chain observables together
    and, in our context, it can be chained to wait for one HTTP call to finish so
    we can execute the other ones. In *step 3*, we intend to execute multiple HTTP
    calls together in parallel for all the films for the person. We do this using
    the `forkJoin` operator, which takes an array of observables. In this case, those
    observables are HTTP calls for each film. `forkJoin` also makes it possible to
    wait for all the parallel calls to finish and then trigger the `subscribe` block’s
    callback. One more thing `forkJoin` does is it provides us with the responses
    in the form of an array having the responses in the same sequences as the observables.
    This makes the responses predictable, and we always show the same data on the
    UI.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`mergeMap` 操作符允许我们通过从其回调中返回一个 **可观察对象** 来链式连接可观察对象。您可以将它想象成我们链式调用 `Promise.then`，但这是针对可观察对象的。一个流行的替代方案是
    `switchMap` 操作符，它的工作方式类似于 `mergeMap` 操作符，但在第一次调用/执行完成之前被调用两次或更多次时，也会取消之前的调用/执行。我们首先移除了
    `setTimeout` 函数（将这些情况放入代码中通常没有意义，因为结果在时间上并不总是可预测的），并将获取人物信息的逻辑移动到获取人物信息的 `subscribe`
    块中。我们还使用了 `of` 操作符从 `mergeMap` 函数的回调中返回 `personObject` 对象。`mergeMap` 函数用于将可观察对象链式连接起来，在我们的上下文中，它可以链式等待一个
    HTTP 调用完成，以便我们可以执行其他的调用。在 *步骤 3* 中，我们打算并行执行所有人物的电影的多个 HTTP 调用。我们使用 `forkJoin`
    操作符来完成这项工作，它接受一个可观察对象的数组。在这种情况下，这些可观察对象是针对每部电影的 HTTP 调用。`forkJoin` 还使得等待所有并行调用完成并触发
    `subscribe` 块的回调成为可能。`forkJoin` 还做的一件事是，它以与可观察对象相同的顺序提供响应的数组形式给我们。这使得响应可预测，并且我们总是在
    UI 上显示相同的数据。'
- en: See also
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Catch the Dot Game*—RxJS documentation ([https://www.learnrxjs.io/learn-rxjs/recipes/catch-the-dot-game](https://www.learnrxjs.io/learn-rxjs/recipes/catch-the-dot-game))'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*捕捉点游戏*—RxJS 文档 ([https://www.learnrxjs.io/learn-rxjs/recipes/catch-the-dot-game](https://www.learnrxjs.io/learn-rxjs/recipes/catch-the-dot-game))'
- en: RxJS `mergeMap` operator documentation ([https://www.learnrxjs.io/learn-rxjs/operators/transformation/mergemap](https://www.learnrxjs.io/learn-rxjs/operators/transformation/mergemap))
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJS `mergeMap` 操作符文档 ([https://www.learnrxjs.io/learn-rxjs/operators/transformation/mergemap](https://www.learnrxjs.io/learn-rxjs/operators/transformation/mergemap))
- en: RxJS `merge` operator documentation ([https://www.learnrxjs.io/learn-rxjs/operators/combination/forkjoin](https://www.learnrxjs.io/learn-rxjs/operators/combination/forkjoin))
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJS `merge` 操作符文档 ([https://www.learnrxjs.io/learn-rxjs/operators/combination/forkjoin](https://www.learnrxjs.io/learn-rxjs/operators/combination/forkjoin))
- en: Listening to multiple observable streams
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听多个可观察流
- en: In this recipe, we’ll work with the `combineLatest` operator to listen to multiple
    observable streams at once. Using this operator results in having an array as
    an output, combining all the streams. This approach is appropriate for when you
    want the latest output from all the streams, combined in a single subscription.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 `combineLatest` 操作符一次性监听多个可观察流。使用此操作符将导致输出为一个数组，合并所有流。当您希望从所有流中获取最新的输出并合并到一个订阅中时，这种方法是合适的。
- en: Getting ready
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'The app that we are going to work with resides in `start/apps/chapter05/rx-multiple-streams`
    inside the cloned repository:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用程序位于克隆的仓库中的 `start/apps/chapter05/rx-multiple-streams` 目录下：
- en: Open the code repository in your code editor.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用程序，您应该看到以下内容：
- en: '![](img/B18469_05_02.png)'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片 B18469_05_02](img/B18469_05_02.png)'
- en: 'Figure 5.2: The rx-multiple-streams app running on http://localhost:4200'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.2：在 http://localhost:4200 上运行的 rx-multiple-streams 应用程序
- en: Now that we have the app running locally, let’s see the steps of the recipe
    in the next section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用，让我们在下一节中查看食谱的步骤。
- en: How to do it…
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'For this recipe, we have an app that displays a box. The box has a size (width
    and height), a border radius, a background color, and a color for its text. It
    also has four inputs using the **Reactive Forms** API to modify all the mentioned
    factors. Right now, we have to apply the changes manually with the click of a
    button even if the inputs change. What if we could subscribe to the changes to
    the inputs and update the box right away without having the user click the button?
    That’s what we’re going to do here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们有一个显示盒子的应用。这个盒子有一个大小（宽度和高度）、边框半径、背景颜色和文本颜色。它还有四个使用**Reactive Forms**
    API来修改所有这些因素的输入。目前，即使输入发生变化，我们也必须手动点击按钮来应用更改。如果我们能够订阅输入的变化并立即更新盒子，而不需要用户点击按钮，那会怎么样？这正是我们要在这里做的：
- en: 'We’ll begin by creating a method named `listenToInputChanges`. We’ll create
    an array of controls we want to work with. Update the code of `home.component.ts`
    as follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个名为`listenToInputChanges`的方法。我们将创建一个我们想要工作的控件数组。更新`home.component.ts`的代码，如下所示：
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we’ll loop over the controls to give them the initial value so that when
    the observable stream is subscribed, they have a value to work with. Update the
    `listenToInputChanges` method further as follows:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将遍历控件，给它们赋予初始值，这样当Observable流被订阅时，它们就有值可以工作了。进一步更新`listenToInputChanges`方法，如下所示：
- en: '[PRE6]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we’ll replace the `boxStyles` property with an `Observable` named `boxStyles$`.
    Then we’ll wrap the `valueChanges` streams of each form control inside a `combineLatest`
    operator to join them. Finally, we’ll assign the result of this joined stream
    to the `boxStyles$` observable. Update the `home.component.ts` file as follows:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将用名为`boxStyles$`的`Observable`替换`boxStyles`属性。然后，我们将每个表单控制的`valueChanges`流包裹在`combineLatest`操作符中，以将它们连接起来。最后，我们将连接流的输出分配给`boxStyles$`Observable。更新`home.component.ts`文件，如下所示：
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we will use a `map` operator with `pipe` on the combined stream to map
    it to the `BoxStyle` type values. Update the `listenToInputChanges` method in
    the `home/home.component.ts` file, as follows:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将在组合流上使用`map`操作符和`pipe`来将其映射到`BoxStyle`类型值。更新`home/home.component.ts`文件中的`listenToInputChanges`方法，如下所示：
- en: '[PRE8]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We need to remove the `setBoxStyles` and `applyChanges` methods and the usages
    of the `applyChanges` method from the `home.component.ts` file. Update the file,
    as follows:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要从`home.component.ts`文件中移除`setBoxStyles`和`applyChanges`方法以及`applyChanges`方法的用法。更新文件，如下所示：
- en: '[PRE9]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We also need to remove the usage of the `applyChanges` method from the template
    as well. Remove the `(ngSubmit)` handler from the `<form>` element in the `home.component.html`
    file so that it looks like this:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要从模板中移除`applyChanges`方法的用法。从`home.component.html`文件中的`<form>`元素移除`(ngSubmit)`处理器，使其看起来像这样：
- en: '[PRE10]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We also need to get rid of the `submit-btn-container` element from the `home.component.html`
    template as we don’t need it anymore. Delete the following chunk from the file:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要从`home.component.html`模板中移除`submit-btn-container`元素，因为我们不再需要它了。从文件中删除以下部分：
- en: '[PRE11]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that we can work with the `boxStyles$` Observable, let’s use it in the
    template, i.e., the `home.component.html` file, instead of the `boxStyles` property:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用`boxStyles$`Observable了，让我们在模板中使用它，即`home.component.html`文件，而不是`boxStyles`属性：
- en: '[PRE12]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: And voilà! If you refresh the app, you should be able to see the box appearing
    with the default styles. And if you change any of the options, you’ll see the
    changes reflected as well.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！如果你刷新应用，你应该能看到带有默认样式的盒子出现。如果你更改了任何选项，你也会看到相应的变化。
- en: Congratulations on finishing the recipe. You’re now the master of handling multiple
    streams using the `combineLatest` operator. See the next section to understand
    how it works.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你完成了这个食谱。你现在已经是使用`combineLatest`操作符处理多个流的专家了。查看下一节以了解它是如何工作的。
- en: How it works…
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The beauty of Reactive Forms is that they provide much more flexibility than
    the regular `ngModel` binding or even template-driven forms. And for each form
    control, we can subscribe to its `valueChanges` observable, which receives a new
    value whenever the input is changed. So, instead of relying on the **Submit**
    button’s click, we subscribe directly to the `valueChanges` property of each **form
    control**. In a regular scenario, that would result in four different streams
    for four inputs, which means we would have four subscriptions that we need to
    take care of and make sure we unsubscribe them. This is where the `combineLatest`
    operator comes into play. We used the `combineLatest` operator to combine those
    four streams into one, which means we needed to unsubscribe only one stream on
    component destruction. But hey! Remember that we don’t need to do this if we use
    the `async` pipe? That’s exactly what we did. We removed the subscription from
    the `home.component.ts` file and used the `pipe` method with the `map` operator.
    The `map` operator transformed the data according to our needs and then returned
    the transformed data to be set to the `boxStyles$` observable. Finally, we used
    the `async` pipe in our template to subscribe to the `boxStyles$` observable and
    assigned its value as `[ngStyle]` to our box element. Since `valueChanges` is
    a `Subject` instead of a `ReplaySubject`, we also piped a `startWith` with `valueChanges`
    to provide an initial value. If we don’t use `startWith`, the box won’t show unless
    all the inputs have a value changed manually at least once. Try it!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Reactive Forms 的美丽之处在于，它们比常规的 `ngModel` 绑定或模板驱动的表单提供了更多的灵活性。对于每个表单控件，我们可以订阅其
    `valueChanges` 可观察对象，每当输入改变时，它都会接收到一个新的值。因此，我们不需要依赖于 **提交** 按钮的点击，而是直接订阅每个 **表单控件**
    的 `valueChanges` 属性。在常规场景中，这会导致四个不同的流对应四个输入，这意味着我们需要处理四个订阅并确保取消订阅它们。这就是 `combineLatest`
    操作符发挥作用的地方。我们使用了 `combineLatest` 操作符将这四个流合并为一个，这意味着我们只需要在组件销毁时取消订阅一个流。但是，嘿！记得如果我们使用
    `async` 管道，我们就不需要这样做吗？这正是我们做的。我们从 `home.component.ts` 文件中移除了订阅，并使用 `pipe` 方法与
    `map` 操作符。`map` 操作符根据我们的需求转换数据，然后将转换后的数据返回设置到 `boxStyles$` 可观察对象。最后，我们在模板中使用 `async`
    管道订阅 `boxStyles$` 可观察对象，并将其值作为 `[ngStyle]` 分配给我们的盒子元素。由于 `valueChanges` 是一个 `Subject`
    而不是一个 `ReplaySubject`，我们还通过 `startWith` 将 `valueChanges` 管道化，以提供一个初始值。如果我们不使用
    `startWith`，盒子将不会显示，除非所有输入至少手动更改一次值。试试看！
- en: See also
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '`combineLatest` operator documentation ([https://www.learnrxjs.io/learn-rxjs/operators/combination/combinelatest](https://www.learnrxjs.io/learn-rxjs/operators/combination/combinelatest))'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`combineLatest` 操作符文档（[https://www.learnrxjs.io/learn-rxjs/operators/combination/combinelatest](https://www.learnrxjs.io/learn-rxjs/operators/combination/combinelatest)）'
- en: Visual representation of the `combineLatest` operator ([https://rxjs-dev.firebaseapp.com/api/index/function/combineLatest](https://rxjs-dev.firebaseapp.com/api/index/function/combineLatest))
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`combineLatest` 操作符的视觉表示（[https://rxjs-dev.firebaseapp.com/api/index/function/combineLatest](https://rxjs-dev.firebaseapp.com/api/index/function/combineLatest)）'
- en: Unsubscribing streams to avoid memory leaks
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消订阅流以避免内存泄漏
- en: Streams are fun to work with and they’re awesome. You’ll know more about RxJS
    and streams when you’ve finished this chapter. One reality is facing unseen problems
    that occur when streams are used without caution. One of the biggest mistakes
    to make with streams is to not unsubscribe them when we no longer need them, and
    in this recipe, you’ll learn how to unsubscribe streams to avoid memory leaks
    in your Angular apps.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 流式处理很有趣，它们很棒。当你完成这一章时，你会对 RxJS 和流有更多的了解。一个现实是，当不小心使用流时，会遇到一些未预见的问题。使用流时犯的最大错误之一是在不再需要它们时没有取消订阅，在这个菜谱中，你将学习如何取消订阅流以避免
    Angular 应用中的内存泄漏。
- en: Getting ready
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter05/rx-unsubscribing-streams`
    inside the cloned repository:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用程序位于克隆的仓库中的 `start/apps/chapter05/rx-unsubscribing-streams`：
- en: Open the code repository in your code editor.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE13]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用程序，你应该看到以下内容：
- en: '![](img/B18469_05_03.png)'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_05_03.png)'
- en: 'Figure 5.3: The rxjs-unsubscribing-streams app running on http://localhost:4200'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.3：在 http://localhost:4200 上运行的 rxjs-unsubscribing-streams 应用程序
- en: Now that we have the app running locally, let’s see the steps of the recipe
    in the next section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用，让我们在下一节中查看食谱的步骤。
- en: How to do it…
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'We currently have an app with two routes—that is, **Home** and **About**. This
    is to show you that unhandled subscriptions can cause memory leaks in an app.
    The default route is **Home**, and in the `HomeComponent` class, we handle a single
    stream that outputs data using the `interval` operator function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前有一个有两个路由的应用——即**主页**和**关于**。这是为了向你展示未处理的订阅可能会在应用中引起内存泄漏。默认路由是**主页**，在`HomeComponent`类中，我们使用`interval`操作符函数处理一个输出数据的流：
- en: Tap the **Start Stream** button, and you should see the stream emitting values.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**开始流**按钮，你应该会看到流正在发出值。
- en: Then, navigate to the **About** page by tapping the **About** button from the
    header (top right), and then come back to the **Home** page.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过点击页眉（右上角）的**关于**按钮导航到**关于**页面，然后返回到**主页**页面。
- en: Do you see anything weird? No? Everything looks fine, right? Well, not exactly.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你看到什么奇怪的吗？没有？一切看起来都正常，对吧？嗯，并不完全是这样。
- en: 'To see whether we have an unhandled subscription, let’s put `console.log` inside
    the `startStream` method in the `home.component.ts` file—specifically, inside
    the `subscribe` function’s block, as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了查看我们是否有未处理的订阅，让我们在`home.component.ts`文件中的`startStream`方法内放置`console.log`——具体来说，在`subscribe`函数的块内，如下所示：
- en: '[PRE14]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you now perform the same steps as mentioned in *Step 1*, you’ll see the
    following output on the console, as shown in *Figure 5.4*:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在按照*步骤 1* 中提到的步骤操作，你将在控制台上看到以下输出，如图*图 5.4*所示：
- en: '![](img/B18469_05_04.png)'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![img/B18469_05_04.png]'
- en: 'Figure 5.4: interval emitting values on the About page'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.4：在关于页面上间隔发出值
- en: Want to have some more fun? Try performing *Step 1* a couple of times without
    refreshing the page even once. What you’ll see will be *chaos!*
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 想要更多乐趣吗？尝试多次执行*步骤 1*，甚至一次都不刷新页面。你将看到的将是*混乱！*
- en: 'So, to solve the issue, we’ll use the simplest approach—that is, unsubscribing
    the stream when the user navigates away from the route. Let’s implement the `ngOnDestroy`
    lifecycle method for that, as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，为了解决这个问题，我们将使用最简单的方法——即在用户离开路由时取消订阅流。让我们为它实现`ngOnDestroy`生命周期方法，如下所示：
- en: '[PRE15]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Great! If you follow the instructions from *Step 1* again, you’ll see that there’s
    no further log on the console once you navigate away from the **Home** page, and
    our app doesn’t have an unhandled stream causing memory leaks now. Read the next
    section to understand how it works.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！如果你再次按照*步骤 1* 的说明操作，你会发现一旦你离开**主页**页面，控制台上就没有进一步的日志了，而且我们的应用现在没有未处理的流导致内存泄漏。阅读下一节以了解它是如何工作的。
- en: How it works…
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When we create an `Observable/stream` and we subscribe to it, RxJS automagically
    adds our provided `subscribe` function block as a handler to the `Observable`.
    So, whenever there’s a value emitted from the `Observable`, our method is supposed
    to be called. The fun part is that Angular doesn’t automatically destroy that
    subscription/handler when the component unmounts or when you have navigated away
    from the route. That’s because the core of observables is **RxJS**, not Angular;
    therefore, it isn’t Angular’s responsibility to handle it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个`Observable/stream`并订阅它时，RxJS 会自动将我们提供的`subscribe`函数块作为处理程序添加到`Observable`。所以，每当`Observable`发出值时，我们的方法都应该被调用。有趣的部分是，Angular
    不会在组件卸载或你离开路由时自动销毁那个订阅/处理程序。这是因为可观察的核心是**RxJS**，而不是Angular；因此，这不是Angular 的责任来处理它。
- en: Angular provides certain lifecycle methods, and we used the `OnDestroy` `(ngOnDestroy)`
    method. So, we used the `ngOnDestroy` method to call the `stopStream` method so
    that the subscription is destroyed as soon as the user navigates away from the
    page. This is possible because, when we navigate away from a route, Angular destroys
    that route and thus we can execute our `stopStream` method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 提供了一些生命周期方法，我们使用了`OnDestroy` `(ngOnDestroy)`方法。因此，我们使用了`ngOnDestroy`方法来调用`stopStream`方法，以便在用户离开页面时立即销毁订阅。这是可能的，因为当我们离开一个路由时，Angular
    会销毁该路由，因此我们可以执行我们的`stopStream`方法。
- en: There’s more…
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'In a complex Angular app, there will be cases where you’d have more than one
    subscription in a component, and when the component is destroyed, you’d want to
    clean all those subscriptions at once. Similarly, you might want to unsubscribe
    based on certain events/conditions rather than the `OnDestroy` lifecycle. Here
    is an example where you have multiple subscriptions in hand, and you want to clean
    up all of them together when the component is destroyed:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个复杂的 Angular 应用中，可能会出现一个组件中有多个订阅的情况，当组件被销毁时，你希望一次性清理所有这些订阅。同样，你可能希望根据某些事件/条件来取消订阅，而不是使用
    `OnDestroy` 生命周期。以下是一个例子，其中你手头有多个订阅，并且希望在组件销毁时一起清理它们：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Notice that we’re not saving the **subscription** from `streamSource` to `this.subscription`
    anymore, and we have also removed the code from the `stopStream` method. The reason
    for this is that we don’t have individual properties/variables for each subscription.
    Instead, we’ll have a single variable to work with. Let’s look at the following
    recipe steps to get things rolling:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不再将 `streamSource` 中的 **订阅** 保存到 `this.subscription` 中，并且也从 `stopStream`
    方法中移除了代码。这样做的原因是我们没有为每个订阅设置单独的属性/变量。相反，我们将有一个单独的变量来处理。让我们看看以下步骤来开始操作：
- en: 'First, we’ll create a property in the `HomeComponent` class named `isStreamActive`:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在 `HomeComponent` 类中创建一个名为 `isStreamActive` 的属性：
- en: '[PRE17]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we’ll import the `takeWhile` operator from `rxjs/operators`, as follows:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将从 `rxjs/operators` 中导入 `takeWhile` 操作符，如下所示：
- en: '[PRE18]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We’ll now use the `takeWhile` operator with each of our streams to make them
    work only when the `isStreamActive` property is set to `true`. Since `takeWhile`
    takes a `predicate` method, it should look like this:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将使用 `takeWhile` 操作符与每个流一起使用，使它们仅在 `isStreamActive` 属性设置为 `true` 时工作。由于 `takeWhile`
    接受一个 `predicate` 方法，它应该看起来像这样：
- en: '[PRE19]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you click the **Start Stream** button right now on the **Home** page, you
    still won’t see any output or logs because the `isStreamActive` property is still
    **undefined**.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在点击 **开始流** 按钮在 **主页** 上，你仍然看不到任何输出或日志，因为 `isStreamActive` 属性仍然是 **未定义**
    的。
- en: 'To make the streams work, we’ll set the `isStreamActive` property to `true`
    in the `startStream` method. The code should look like this:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使流工作，我们在 `startStream` 方法中将 `isStreamActive` 属性设置为 `true`。代码应该看起来像这样：
- en: '[PRE20]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After this step, if you now try to start the stream and navigate away from the
    page, you’ll still see the same issue with the streams—that is, they’ve not been
    unsubscribed.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步之后，如果你现在尝试开始流并离开页面，你仍然会看到流的问题——也就是说，它们没有被取消订阅。
- en: 'To unsubscribe all streams at once, we’ll set the value of `isStreamActive`
    to `false` in the `stopStream` method, as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要一次性取消所有流的订阅，我们在 `stopStream` 方法中将 `isStreamActive` 的值设置为 `false`，如下所示：
- en: '[PRE21]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, update the template to handle which button is disabled based on the
    `isStreamActive` property instead of `subscription`. Update the `home.component.html`
    file as follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新模板以根据 `isStreamActive` 属性而不是 `subscription` 来处理哪个按钮被禁用。按照以下方式更新 `home.component.html`
    文件：
- en: '[PRE22]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: And boom! Now, if you navigate away from the route while the streams are emitting
    values, the streams will stop immediately as soon as you navigate away from the
    **Home** route. Voilà!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当你在流正在发出值时离开路由，流将立即停止。哇！
- en: See also
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Read about RxJS subscription ([https://www.learnrxjs.io/learn-rxjs/concepts/rxjs-primer#subscription](https://www.learnrxjs.io/learn-rxjs/concepts/rxjs-primer#subscription))
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 RxJS 订阅 ([https://www.learnrxjs.io/learn-rxjs/concepts/rxjs-primer#subscription](https://www.learnrxjs.io/learn-rxjs/concepts/rxjs-primer#subscription))
- en: '`takeWhile` operator docs ([https://www.learnrxjs.io/learn-rxjs/operators/filtering/takewhile](https://www.learnrxjs.io/learn-rxjs/operators/filtering/takewhile))'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`takeWhile` 操作符文档 ([https://www.learnrxjs.io/learn-rxjs/operators/filtering/takewhile](https://www.learnrxjs.io/learn-rxjs/operators/filtering/takewhile))'
- en: Using Angular’s async pipe to unsubscribe streams automatically
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Angular 的异步管道自动取消订阅流
- en: As you learned in the previous recipe, it is crucial to unsubscribe the streams
    you subscribe to. What if we had an even simpler way to unsubscribe them when
    the component gets destroyed—that is, letting Angular take care of it somehow?
    In this recipe, you’ll learn how to use Angular’s `async` pipe with an observable
    to directly bind the data in the stream to the Angular template instead of having
    to subscribe in the `*.component.ts` file.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在前面的食谱中所学，取消订阅你订阅的流是至关重要的。如果我们有一种更简单的方法在组件销毁时取消订阅它们——也就是说，让Angular以某种方式处理它——会怎样？在这个食谱中，你将学习如何使用Angular的`async`管道与可观察对象直接绑定流中的数据到Angular模板，而不是需要在`*.component.ts`文件中进行订阅。
- en: Getting ready
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter05/ng-async-pipe`
    inside the cloned repository:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用程序位于克隆的仓库中的`start/apps/chapter05/ng-async-pipe`：
- en: Open the code repository in your code editor.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以运行项目：
- en: '[PRE23]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用程序，你应该看到以下内容：
- en: '![](img/B18469_05_05.png)'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_05_05.png)'
- en: 'Figure 5.5: The ng-async-pipe app running on http://localhost:4200'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.5：运行在http://localhost:4200上的ng-async-pipe应用程序
- en: Now that we have the app running locally, let’s see the steps of the recipe
    in the next section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地上运行了应用程序，接下来让我们看看下一节中食谱的步骤。
- en: How to do it…
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The app we have right now has three streams/observables observing values at
    different intervals. We’re relying on the `isStreamActive` property to keep the
    subscription alive or make it stop when the property is set to `false`. We’ll
    remove the usage of `takeWhile` and somehow make everything work similarly to
    what we have right now.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前拥有的应用程序有三个流/可观察对象在不同的间隔观察值。我们依赖于`isStreamActive`属性来保持订阅活跃或当属性设置为`false`时停止它。我们将删除`takeWhile`的使用，并设法让一切工作得和现在一样。
- en: 'First, add a property of type `Observable` in the `HomeComponent` class named
    `streamOutput$`. Update the code in the `home.component.ts` file as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`HomeComponent`类中添加一个名为`streamOutput$`的类型为`Observable`的属性。按照以下方式更新`home.component.ts`文件中的代码：
- en: '[PRE24]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We’ll now combine all the streams to give out a single output—that is, the
    `outputStreamData` array. We’ll remove all the existing `pipe` and `subscribe`
    functions from the `startStream` method, so the code should now look like this:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将所有流合并以输出单个输出——即`outputStreamData`数组。我们将从`startStream`方法中删除所有现有的`pipe`和`subscribe`函数，因此代码现在应该看起来像这样：
- en: '[PRE25]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Since we want to stop the stream on the **Stop Stream** button click, we’ll
    use the `takeWhile` operator in the stream to work with the stream to only emit
    values when we click the **Start Stream** button and to stop when we hit the **Stop
    Stream** button. Update the `startStream` method in `home.component.ts` as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们希望在点击**停止流**按钮时停止流，我们将在流中使用`takeWhile`操作符来与流一起工作，只有在点击**开始流**按钮时才发出值，并在点击**停止流**按钮时停止。按照以下方式更新`home.component.ts`中的`startStream`方法：
- en: '[PRE26]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Remove the `ngOnDestroy` method since our stream is going to unsubscribe automatically
    when we leave the component (go to another route). This is because we’re using
    the `async` pipe and Angular itself handles the subscription and unsubscription
    for us when using the `async pipe`. Also, we should remove the `implements OnDestroy`
    statement and remove the `OnDestroy` import.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`ngOnDestroy`方法，因为当我们将离开组件（转到另一个路由）时，我们的流将自动取消订阅。这是因为我们正在使用`async`管道，Angular本身在使用`async`管道时会为我们处理订阅和取消订阅。此外，我们应该删除`implements
    OnDestroy`语句和`OnDestroy`导入。
- en: 'Finally, modify the template in `home.component.html` to use the `streamOutput$`
    observable with the `async` pipe to loop over the output array:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，修改`home.component.html`中的模板，以使用`streamOutput$`可观察对象和`async`管道来循环输出数组：
- en: '[PRE27]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To verify that the subscription *really* gets destroyed on component destruction,
    let’s put `console.log` in the `startStream` method inside the `tap` operator,
    as follows:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证在组件销毁时订阅确实被销毁，让我们在`startStream`方法中的`tap`操作符内添加`console.log`，如下所示：
- en: '[PRE28]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Hurray! With this change, you can try refreshing the app; navigate away from
    the **Home** route, and you’ll see that the console logs stop as soon as you navigate
    away from the homepage. Also, you can start and stop the stream to see the output
    on the console. Do you feel great about what we just got by removing all that
    extra code? I certainly do. We’ll see in the next section how it all works.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 哈哈！随着这个更改，你可以尝试刷新应用；离开**主页**路由，你会看到一旦你离开主页，控制台日志就会停止。此外，你还可以开始和停止流以在控制台看到输出。你对刚刚通过移除所有额外代码所得到的结果感到满意吗？我当然满意。在下一节中，我们将看到这一切是如何工作的。
- en: How it works…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Angular’s `async` pipe automatically destroys/unsubscribes the subscription
    as soon as the component is destroyed. This gives us a great opportunity to use
    it where possible. In the recipe, we basically combined all the streams using
    the `merge` operator. The fun part was that for the `streamsOutput$` property,
    we wanted an observable of the output array on which we could loop over. However,
    merging the streams only combines them and emits the latest value emitted by any
    of the streams. So, we added a `pipe` function with the `scan` operator to take
    the latest output of the combined stream and add it to an array of all the previously
    emitted outputs. This sort of works like the `reduce` function of a JavaScript
    array.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的`async`管道会在组件销毁时自动销毁/取消订阅，这为我们提供了一个很好的机会在可能的地方使用它。在菜谱中，我们基本上使用`merge`操作符组合了所有流。有趣的部分是，对于`streamsOutput$`属性，我们想要一个输出数组的可观察对象，我们可以遍历它。然而，合并流只会将它们组合起来，并发出任何流发出的最新值。因此，我们添加了一个带有`scan`操作符的`pipe`函数，以获取组合流的最新输出并将其添加到之前发出的所有输出数组中。这有点像JavaScript数组中的`reduce`函数。
- en: Fun fact—streams don’t emit any value unless they’re subscribed to. “*But Ahsan,
    we didn’t subscribe to the stream, we just merged and mapped the data. Where’s
    the subscription?*” Glad you asked. Angular’s `async` pipe subscribes to the stream
    itself, which triggers `console.log` as well, which we added in *Step 6* using
    the `tap` function.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的事实——流在未被订阅的情况下不会发出任何值。“*但是Ahsan，我们没有订阅流，我们只是合并并映射了数据。订阅在哪里？*”很高兴你问了。Angular的`async`管道会自动订阅流本身，这会触发`console.log`，这是我们使用`tap`函数在*步骤6*中添加的。
- en: IMPORTANT NOTE
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `async` pipe has a limitation, which is that you cannot stop the subscription
    until the component is destroyed. For cases where you want to subscribe and unsubscribe
    on a conditional basis, you’d want to go for operators such as the `takeWhile/takeUntil`
    operator or use a regular `unsubscribe` function yourself when the component is
    destroyed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`管道有一个限制，就是你不能在组件销毁之前停止订阅。对于想要有条件地订阅和取消订阅的情况，你可能需要选择像`takeWhile/takeUntil`这样的操作符，或者当组件销毁时自己使用常规的`unsubscribe`函数。'
- en: See also
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Angular `async` pipe documentation ([https://angular.io/api/common/AsyncPipe](https://angular.io/api/common/AsyncPipe))
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular `async`管道文档([https://angular.io/api/common/AsyncPipe](https://angular.io/api/common/AsyncPipe))
- en: Using the map operator to transform data
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用map操作符转换数据
- en: When making the API/HTTP calls in a web application, it is often the case that
    the server doesn’t return the data in a form that is easy to directly render to
    the UI. We often need some sort of transformation of the data received from the
    server to map it to something our UI can work with. In this recipe, you’re going
    to learn how to use the `map` operator to transform responses from an HTTP call.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用中制作API/HTTP调用时，通常服务器不会以易于直接渲染到UI的形式返回数据。我们通常需要将服务器接收到的数据进行某种转换，以便将其映射到我们的UI可以处理的内容。在这个菜谱中，你将学习如何使用`map`操作符来转换HTTP调用的响应。
- en: Getting ready
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter05/rx-map-operator`
    inside the cloned repository:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆的仓库中的`start/apps/chapter05/rx-map-operator`目录内：
- en: Open the code repository in your code editor.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE29]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用，你应该看到以下内容：
- en: '![](img/B18469_05_06.png)'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_05_06.png)'
- en: 'Figure 5.6: The rx-map-operator app running on http://localhost:4200'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.6：运行在http://localhost:4200的rx-map-operator应用
- en: Now that we have the app running locally, let’s see the steps of the recipe
    in the next section.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地上运行了应用，让我们在下一节中查看菜谱的步骤。
- en: How to do it…
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Our template (`app.component.html`) for the app is set up already. And so is
    our `app.component.ts` file and the `appData` data structure that we require.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用模板（`app.component.html`）已经设置好了。同样，我们的`app.component.ts`文件和所需的`appData`数据结构也已经设置。
- en: 'We’ll start by creating a method in the `swapi.service.ts` file to fetch the
    data. We want only one function to be able to bring the data from different API
    calls, combine it, and return it. Update the file as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在`swapi.service.ts`文件中创建一个方法来获取数据。我们希望只有一个函数能够从不同的API调用中获取数据，将其合并，并返回。按照以下方式更新文件：
- en: '[PRE30]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*You’re going to see that TypeScript is mad at us. Don’t worry about it. We’ll
    make it happy in time*.'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*你将看到TypeScript对我们很生气。不用担心，我们会在适当的时候让它高兴起来*。'
- en: 'Let’s add the following code to first get the person, and then get the films
    of that person in the `fetchData` function:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`fetchData`函数中添加以下代码，首先获取人物，然后获取该人物的影片：
- en: '[PRE31]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now we can decide what to do when we receive the films back.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们可以在收到影片后决定要做什么。
- en: 'We’ll map over the response from the `films` HTTP calls and add that to the
    `personInfo` object. Update the `swapi.service.ts` file as follows:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将遍历`films` HTTP调用返回的响应，并将其添加到`personInfo`对象中。按照以下方式更新`swapi.service.ts`文件：
- en: '[PRE32]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, let’s use the `fetchData` method from `SwapiService` inside our `app.component.ts`file.
    Update the `fetchData` method in the file as follows and make sure you remove
    unused dependencies from the file:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们在`app.component.ts`文件中使用`SwapiService`的`fetchData`方法。按照以下方式更新文件中的`fetchData`方法，并确保从文件中删除未使用的依赖项：
- en: '[PRE33]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And yes! If you now refresh the app, you’ll notice that the data is being displayed
    in the view:'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是的！如果你现在刷新应用，你会注意到数据正在视图中显示：
- en: '![](img/B18469_05_07.png)'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_05_07.png)'
- en: 'Figure 5.7: The UI showing the received data from swapi'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.7：显示从swapi接收到的数据的UI
- en: Now that you’ve finished the recipe, see the next section on how this works.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了配方，请查看下一节了解它是如何工作的。
- en: How it works…
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `map` operator is one of the most used RxJS operators of all time. Especially
    in Angular when we make HTTP calls. In this recipe, our target was to do as little
    work as possible in the `app.component.ts` file. That’s because as one of the
    community-adopted practices, the component should request data from the service
    and the service should give it in such a way that it can be bound to the UI variables
    as is. The Angular documentation also encourages keeping the component’s code
    as tiny as possible. It is also generally a good idea to distribute your code
    into different layers, i.e., in components, services, pipes, etc. This is to be
    able to scale the application with ease, have better testing possibilities, and
    be able to easily replace the layers with a completely different thing. Therefore,
    we created this `fetchData` method in the `SwapiService` class to use the `fetchPerson`
    and `fetchPersonFilms` methods to first make the HTTP calls, and then we used
    the `map` operator to transform the data into exactly the data structure our component/UI
    is expecting.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`运算符是所有时间中最常用的RxJS运算符之一。特别是在Angular中，当我们进行HTTP调用时。在这个配方中，我们的目标是尽可能少地在`app.component.ts`文件中做工作。这是因为作为社区采纳的实践之一，组件应该从服务请求数据，服务应该以这种方式提供数据，以便它可以绑定到UI变量。Angular文档也鼓励将组件的代码保持尽可能小。通常，将代码分布到不同的层，即组件、服务、管道等，也是一个好主意。这是为了能够轻松地扩展应用程序，有更好的测试可能性，并且能够轻松地用完全不同的事物替换层。因此，我们在`SwapiService`类中创建了`fetchData`方法，使用`fetchPerson`和`fetchPersonFilms`方法首先进行HTTP调用，然后我们使用了`map`运算符将数据转换成组件/UI期望的确切数据结构。'
- en: See also
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '`map` operator documentation ([https://www.learnrxjs.io/learn-rxjs/operators/transformation/map](https://www.learnrxjs.io/learn-rxjs/operators/transformation/map))'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`运算符文档（[https://www.learnrxjs.io/learn-rxjs/operators/transformation/map](https://www.learnrxjs.io/learn-rxjs/operators/transformation/map))'
- en: Using the switchMap and debounceTime operators with autocompletes for better
    performance
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用switchMap和debounceTime运算符以及自动完成功能以获得更好的性能
- en: For a lot of apps, we have features such as searching content as the user types.
    This is a really good **User Experience** (**UX**) as the user doesn’t have to
    press a button to do a search. However, if we send an HTTP call to the server
    on every key press, that’s going to result in a lot of HTTP calls being sent,
    and we can’t know which HTTP call will complete first; thus, we can’t be sure
    if we will have the correct data shown in the view or not. In this recipe, you’ll
    learn how to use the `switchMap` operator to cancel out the last subscription
    and create a new one instead. This would result in canceling previous HTTP calls
    and keeping only one HTTP call—the last one. We’ll use the `debounceTime` operator
    to wait for the input to be idle before it even tries to make one call.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多应用程序，我们具有用户键入时搜索内容等特性。这对于用户体验（**UX**）来说非常好，因为用户不需要按按钮就可以进行搜索。然而，如果我们每次按键都向服务器发送HTTP调用，这将导致发送大量的HTTP调用，我们无法知道哪个HTTP调用会首先完成；因此，我们无法确定是否会在视图中显示正确的数据。在本食谱中，您将学习如何使用`switchMap`操作符取消最后一个订阅并创建一个新的订阅。这将导致取消之前的HTTP调用，并保留一个HTTP调用——最后一个。我们将使用`debounceTime`操作符等待输入空闲后再尝试进行调用。
- en: Getting ready
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter05/rx-switchmap-operator`
    inside the cloned repository:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用程序位于克隆的仓库中的`start/apps/chapter05/rx-switchmap-operator`目录内：
- en: Open the code repository in your code editor.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以运行项目：
- en: '[PRE34]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用程序，您应该看到以下内容：
- en: '![](img/B18469_05_08.png)'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_05_08.png)'
- en: 'Figure 5.8: The rx-switchmap-operator app running on http://localhost:4200'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.8：在http://localhost:4200上运行的rx-switchmap-operator应用程序
- en: 'Now that we have the app running locally, open **Chrome DevTools** and go to
    the **Network** tab. Type `wolf` in the search input, and you’ll see four calls
    being sent to the API server, as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地上运行了应用程序，打开**Chrome DevTools**并转到**网络**标签页。在搜索输入中键入`wolf`，您会看到向API服务器发送了四个调用，如下所示：
- en: '![](img/B18469_05_09.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18469_05_09.png)'
- en: 'Figure 5.9: A separate HTTP call is sent for each input change'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9：为每次输入更改发送单独的HTTP调用
- en: How to do it…
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: You can start typing into the search box on the homepage to see the filtered
    users, and if you see the **Network** tab, you’ll notice that whenever the input
    changes, we send a new HTTP call. Let’s avoid sending a call on each keypress
    by using the `switchMap` operator.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在主页上的搜索框中开始键入以查看过滤后的用户，如果您看到**网络**标签页，您会注意到每当输入更改时，我们都会发送一个新的HTTP调用。让我们通过使用`switchMap`操作符来避免在每次按键时发送调用。
- en: 'First, import the `switchMap` operator from `rxjs/operators` in the `users/users.component.ts`
    file, as follows:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`users/users.component.ts`文件中从`rxjs/operators`导入`switchMap`操作符，如下所示：
- en: '[PRE35]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We will now modify our subscription to the `username` form control— specifically,
    the `valueChanges` observable to use the `switchMap` operator for the `this.userService.searchUsers(query)`
    method call. This returns an `Observable` containing the result of the HTTP call.
    The code should look like this:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将修改对`username`表单控制的订阅——具体来说，是使用`switchMap`操作符来调用`this.userService.searchUsers(query)`方法的`valueChanges`可观察对象。这返回一个包含HTTP调用结果的`Observable`。代码应该看起来像这样：
- en: '[PRE36]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you refresh the app now, open **Chrome DevTools**, and check the network
    type while typing `wolf` really fast, you’ll see that all the previous calls are
    canceled and we only have the latest HTTP call succeeding:'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您现在刷新应用程序，打开**Chrome DevTools**，在快速输入`wolf`时检查网络类型，您会看到所有之前的调用都被取消，我们只有最新的HTTP调用成功：
- en: '![](img/B18469_05_10.png)'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_05_10.png)'
- en: 'Figure 5.10: switchMap canceling prior HTTP calls'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.10：switchMap取消之前的HTTP调用
- en: Well, this looks better, but the `backend/api` endpoint still receives those
    calls.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 好吧，看起来不错，但`backend/api`端点仍然接收那些调用。
- en: 'We’re going to use the `debounceTime` operator now to wait for the search input
    to be idle before starting to execute a call. Update the `users.component.ts`
    file as follows:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将使用`debounceTime`操作符等待搜索输入空闲后再开始执行调用。按照以下方式更新`users.component.ts`文件：
- en: '[PRE37]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Figure 5.11* shows that there is only one call sent to the server, even after
    typing four letters in the search input:'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图5.11*显示，即使在搜索输入中键入四个字母之后，也只向服务器发送了一个调用：'
- en: '![](img/B18469_05_11.png)'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_05_11.png)'
- en: 'Figure 5.11: debounceTime waiting for the input to be idle'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.11：等待输入空闲的debounceTime
- en: Woot! We now have only one call that’ll succeed, process the data, and end up
    in the view; see the next section on how it works.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们现在只有一个调用会成功，处理数据，并最终显示在视图中；请看下一节了解它是如何工作的。
- en: How it works…
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `switchMap` operator cancels the previous (inner) subscription and subscribes
    to a new observable instead. In our case, the parent observable (the input element’s
    `valueChanges` emitter) emits a value, and the `switchMap` operator cancels the
    previous operation in progress. That’s why it cancels all the HTTP calls sent
    before in our example and just subscribes to the last one. However, the call still
    reaches the API endpoint. If this was our server, we may still receive the API
    calls, so we use the `debounceTime` operator on the form control to wait for the
    input to be idle (for 500 ms) before we even send our first call.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`switchMap`操作符取消之前的（内部）订阅，并订阅一个新的可观察对象。在我们的例子中，父级可观察对象（输入元素的`valueChanges`发射器）发出一个值，`switchMap`操作符取消正在进行的上一个操作。这就是为什么它会取消我们例子中之前发送的所有HTTP调用，并仅订阅最后一个。然而，调用仍然到达API端点。如果这是我们自己的服务器，我们可能仍然会收到API调用，所以我们使用`debounceTime`操作符在表单控件上等待输入空闲（500毫秒），然后我们才发送第一个调用。'
- en: See also
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '`switchMap` operator documentation ([https://www.learnrxjs.io/learn-rxjs/operators/transformation/switchmap](https://www.learnrxjs.io/learn-rxjs/operators/transformation/switchmap))'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switchMap`操作符文档([https://www.learnrxjs.io/learn-rxjs/operators/transformation/switchmap](https://www.learnrxjs.io/learn-rxjs/operators/transformation/switchmap))'
- en: '`debounceTime` operator documentation ([https://www.learnrxjs.io/learn-rxjs/operators/filtering/debouncetime](https://www.learnrxjs.io/learn-rxjs/operators/filtering/debouncetime))'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debounceTime`操作符文档([https://www.learnrxjs.io/learn-rxjs/operators/filtering/debouncetime](https://www.learnrxjs.io/learn-rxjs/operators/filtering/debouncetime))'
- en: Creating a custom RxJS operator
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义RxJS操作符
- en: By following the other recipes in this chapter, I have to ask if you’ve become
    a fan of RxJS yet? *Have you?* Well, I am. And in this recipe, you’re going to
    level up your RxJS game. You’re going to create your own custom RxJS operator
    that just taps into any observable stream and logs the values on the console.
    We’ll call it the `logWithLabel` operator.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循本章中的其他食谱，我必须问你是否已经成为RxJS的粉丝了？*你成为了吗？*好吧，我是。在这个食谱中，你将提升你的RxJS技能。你将创建自己的自定义RxJS操作符，它可以直接连接到任何可观察流并在控制台上记录值。我们将称之为`logWithLabel`操作符。
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter05/rx-custom-operator`
    inside the cloned repository:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆的仓库中的`start/apps/chapter05/rx-custom-operator`：
- en: Open the code repository in your code editor.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令来提供项目服务：
- en: '[PRE38]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This should open the app in a new browser tab. If you click the **Start Stream**
    button while you have the DevTools open, you should see the following:'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用。如果你在打开DevTools的同时点击**开始流**按钮，你应该看到以下内容：
- en: '![](img/B18469_05_12.png)'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_05_12.png)'
- en: 'Figure 5.12: The rx-custom-operator app running on http://localhost.4200'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.12：在http://localhost.4200上运行的rx-custom-operator应用
- en: Let’s jump into the recipe steps in the next section.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中跳转到食谱步骤。
- en: How to do it…
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We’re going to create a custom RxJS operator named `logWithLabel`, which will
    log the values of the observable stream on the console with a label.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`logWithLabel`的自定义RxJS操作符，它将在控制台上带有标签记录可观察流中的值。
- en: 'Create a new file inside the `app` folder and name it `log-with-label.ts`.
    Then add the following code inside the file:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app`文件夹内创建一个新文件，并将其命名为`log-with-label.ts`。然后在文件中添加以下代码：
- en: '[PRE39]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now we can import the `logWithLabel` operator from the `log-with-label.ts`
    file inside the `home/home.component.ts` file, as follows:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以从`home/home.component.ts`文件中的`log-with-label.ts`文件导入`logWithLabel`操作符，如下所示：
- en: '[PRE40]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And that’s it! If you refresh the app and click the **Start Stream** button,
    you can see the output using the `logWithLabel` operator, as follows:'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就这样！如果你刷新应用并点击**开始流**按钮，你可以使用`logWithLabel`操作符查看输出，如下所示：
- en: '![](img/B18469_05_13.png)'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_05_13.png)'
- en: 'Figure 5.13: Logs using the logWithLabel custom RxJS operator'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.13：使用logWithLabel自定义RxJS操作符记录的日志
- en: See the next section to understand how it all works.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅下一节了解它是如何工作的。
- en: How it works…
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A custom RxJS operator is a function that should take an observable source stream
    and return *something*. That *something* is usually an observable. In this recipe,
    we wanted to tap into the stream to log something on the console every time the
    stream emits a value. We also wanted to have a custom label for the logs for this
    stream. This is why we ended up creating the custom operator as a `factory` function
    that can take `label` as input, i.e., when we call the `logWithLabel` function
    (let’s call it `function A`), it returns a function (let’s call it `function B`)
    from within. The returned function (`B`) is what RxJS calls with the observable
    stream when we use the `logWithLabel` method inside the `pipe` function of the
    stream. Inside `function B`, we use the `tap` operator from RxJS to intercept
    the source observable and to log the values on the console using the `label` provided.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一个自定义 RxJS 操作符是一个函数，它应该接受一个可观察源流并返回*某物*。那个*某物*通常是可观察的。在这个菜谱中，我们希望深入到流中，每次流发出值时在控制台记录一些内容。我们还希望为这个流的日志添加一个自定义标签。这就是我们最终创建自定义操作符作为`工厂`函数的原因，它可以接受`label`作为输入，即当我们调用`logWithLabel`函数（让我们称它为`函数
    A`）时，它返回一个函数（让我们称它为`函数 B`）。返回的函数（`B`）是 RxJS 在我们使用`pipe`函数中的`logWithLabel`方法时与可观察流一起调用的。在`函数
    B`内部，我们使用 RxJS 的`tap`操作符来拦截源可观察流并在控制台使用提供的`label`记录值。
- en: See also
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '`tap` operator documentation ([https://rxjs.dev/api/operators/tap](https://rxjs.dev/api/operators/tap))'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tap`操作符文档([https://rxjs.dev/api/operators/tap](https://rxjs.dev/api/operators/tap))'
- en: '`Observable` documentation ([https://rxjs.dev/guide/observable](https://rxjs.dev/guide/observable))'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable`文档([https://rxjs.dev/guide/observable](https://rxjs.dev/guide/observable))'
- en: Retrying failed HTTP calls with RxJS
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 RxJS 重试失败的 HTTP 请求
- en: In this recipe, you’re going to learn how to retry HTTP calls smartly with RxJS
    operators. We’re going to use a technique called the **exponential backoff** technique.
    This means that we retry the HTTP calls but with each next call having a delay
    more than the previous time for the attempt, and we stop after several maximum
    tries. Sounds exciting? Let’s get into it.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何使用 RxJS 操作符智能地重试 HTTP 请求。我们将使用一种称为**指数退避**的技术。这意味着我们将重试 HTTP 请求，但每次后续调用都比前一次尝试的延迟更长，并在尝试几次最大次数后停止。听起来很激动人心吗？让我们开始吧。
- en: Getting ready
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter05/rx-retry-http-calls`
    inside the cloned repository:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要与之合作的应用程序位于克隆的仓库中的`start/apps/chapter05/rx-retry-http-calls`：
- en: Open the code repository in your code editor.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project with the backend server:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以使用后端服务器提供项目：
- en: '[PRE41]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用程序，你应该看到以下内容：
- en: '![](img/B18469_05_14.png)'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_05_14.png)'
- en: 'Figure 5.14: The rx-retry-http-calls running on http://localhost.4200'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.14：在 http://localhost.4200 上运行的 rx-retry-http-calls
- en: Let’s jump into the recipe steps in the next section.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳到下一节中的菜谱步骤。
- en: How to do it…
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We’re going to create a custom RxJS operator named `backoff` that will retry
    the HTTP calls for us with the exponential `backoff` strategy.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`backoff`的自定义 RxJS 操作符，它将使用指数`退避`策略为我们重试 HTTP 请求。
- en: 'Create a new file inside the `app` folder and name it `retry-backoff.ts`. Then
    add the following code inside the file:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app`文件夹内创建一个新文件，并将其命名为`retry-backoff.ts`。然后在文件中添加以下代码：
- en: '[PRE42]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now let’s use this operator in `app.component.ts` to retry the HTTP calls.
    Update the file as follows:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`app.component.ts`中使用这个操作符来重试 HTTP 请求。按照以下方式更新文件：
- en: '[PRE43]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If you refresh the app, you’ll notice that now we retry the HTTP calls. But
    all of the retries are done instantly (notice the **Waterfall** column), as shown
    in *Figure 5.15*. We don’t want that. We want every next try to be done with an
    increasing delay.
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你刷新应用程序，你会注意到现在我们正在重试 HTTP 请求。但所有的重试都是立即完成的（注意**瀑布**列），如图 5.15 所示。我们不想这样。我们希望每次尝试都以递增的延迟完成。
- en: '![](img/B18469_05_15.png)'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_05_15.png)'
- en: 'Figure 5.15: Retrying HTTP calls multiple times instantly'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.15：立即多次重试 HTTP 请求
- en: 'Update the `retry-backoff.ts` file to add a delay using the `timer` operator
    and some calculations, as follows:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `retry-backoff.ts` 文件更新为使用 `timer` 操作符和一些计算来添加延迟，如下所示：
- en: '[PRE44]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And that’s it! If you refresh the app, you’ll see that every next retry of
    the HTTP call has an increased delay compared to the previous one. Notice how
    far off the last HTTP call is in the **Waterfall** column (it is on the right
    edge of *Figure 5.16*):'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就这样！如果您刷新应用程序，您会看到每次 HTTP 调用的后续重试的延迟都比前一次增加。注意最后一个 HTTP 调用在 **Waterfall** 列中的位置有多远（它在
    *图 5.16* 的右边缘）：
- en: '![](img/B18469_05_16.png)'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_05_16.png)'
- en: 'Figure 5.16: Retrying HTTP calls with exponential backoff'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.16：使用指数退避重试 HTTP 调用
- en: See the next section to understand how it all works.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下一节以了解它是如何工作的。
- en: How it works…
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `retry` operator has two overloads (at the time of writing this book). One
    of them takes `number` and RxJS will just have the observable retried the number
    of times equal to `number` (until it throws an exception). The other overload
    is that it takes a configuration object. In the configuration object, we’re using
    the `delay` function to handle our logic. The `delay` function receives `error`
    and the `retryCount` from RxJS, which we use to throw the error if we have already
    done our maximum tries or to pass forward `retryCount`. We get the maximum number
    of tries from our `retryBackoff` function’s arguments. Finally, we make the `map`
    and `mergeMap` opeartors work with `delay`. Using the `map` operator, we take
    a square of the `retryCount` variable’s value. And then, in the `mergeMap` operator,
    we multiply the square value with the delay provided to the `retryBackoff` function.
    As a result, every next request takes the delay equal to `((retryCount * retryCount)
    * delay)`. Notice that we’re using the `timer` function to have RxJS wait before
    it can retry the HTTP call again.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`retry` 操作符有两个重载（在撰写本书时）。其中一个接受 `number` 参数，RxJS 将仅重试观察者指定次数（直到抛出异常）。另一个重载是它接受一个配置对象。在配置对象中，我们使用
    `delay` 函数来处理我们的逻辑。`delay` 函数接收来自 RxJS 的 `error` 和 `retryCount`，我们使用它们来抛出错误，如果我们已经尝试了最大次数，或者传递
    `retryCount`。我们从 `retryBackoff` 函数的参数中获取最大尝试次数。最后，我们使 `map` 和 `mergeMap` 操作符与
    `delay` 一起工作。使用 `map` 操作符，我们取 `retryCount` 变量值的平方。然后，在 `mergeMap` 操作符中，我们将平方值与传递给
    `retryBackoff` 函数的延迟相乘。结果，每次后续请求的延迟等于 `((retryCount * retryCount) * delay)`。请注意，我们使用
    `timer` 函数让 RxJS 在再次重试 HTTP 调用之前等待。'
- en: See also
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '**RxJS custom operators** ([https://indepth.dev/posts/1421/rxjs-custom-operators](https://indepth.dev/posts/1421/rxjs-custom-operators))'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RxJS 自定义操作符** ([https://indepth.dev/posts/1421/rxjs-custom-operators](https://indepth.dev/posts/1421/rxjs-custom-operators))'
- en: '**Exponential backoff** documentation ([https://angular.io/guide/practical-observable-usage#exponential-backoff](https://angular.io/guide/practical-observable-usage#exponential-backoff))'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指数退避**文档 ([https://angular.io/guide/practical-observable-usage#exponential-backoff](https://angular.io/guide/practical-observable-usage#exponential-backoff))'
- en: Learn more on Discord
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多信息
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的 Discord 社区——在那里您可以分享反馈、向作者提问以及了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/AngularCookbook2e](Chapter_5.xhtml)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '[AngularCookbook2e](https://packt.link/AngularCookbook2e)'
- en: '![](img/QR_Code1388317275422265.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1388317275422265.png)'
