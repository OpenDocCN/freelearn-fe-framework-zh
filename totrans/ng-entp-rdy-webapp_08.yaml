- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Designing Authentication and Authorization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计身份验证和授权
- en: Designing a high-quality authentication and authorization system without frustrating
    the end user is a difficult problem to solve. Authentication is the act of verifying
    the identity of a user, and authorization specifies the privileges that a user
    must have to access a resource. Both processes, auth for short, must seamlessly
    work in tandem to address the needs of users with varying roles, needs, and job
    functions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个高质量的身份验证和授权系统，同时不令最终用户感到沮丧是一个难以解决的问题。身份验证是验证用户身份的行为，授权指定用户必须拥有的权限才能访问资源。这两个过程，简称auth，必须无缝协同工作，以满足具有不同角色、需求和职能的用户的需求。
- en: On today's web, users have a high baseline level of expectations from any auth
    system they encounter through the browser, so this is an important part of your
    application to get absolutely right the first time. The user should always be
    aware of what they can and can't do in your application. If there are errors,
    failures, or mistakes, the user should be clearly informed about why they occurred.
    As your application grows, it will be easy to miss all the ways that an error
    condition could be triggered. Your implementation should be easy to extend or
    maintain, otherwise this basic backbone of your application will require a lot
    of maintenance. In this chapter, we will walk through the various challenges of
    creating a great auth UX and implement a solid baseline experience.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的网络中，用户对通过浏览器遇到的任何身份验证系统都有很高的基本期望水平，因此这是你应用中一个非常重要的部分，必须第一次就绝对正确。用户应该始终了解他们在你的应用中可以做什么和不能做什么。如果有错误、失败或错误，用户应该清楚地了解它们发生的原因。随着你的应用增长，很容易错过所有可能触发错误条件的方式。你的实现应该易于扩展或维护，否则你应用的基本骨架将需要大量的维护。在本章中，我们将探讨创建出色的身份验证用户体验的各种挑战，并实现一个坚实的基础体验。
- en: We will continue the router-first approach to designing SPAs by implementing
    the auth experience of LemonMart. In *Chapter 7*, *Creating a Router-First Line-of-Business
    App*, we defined user roles, finished our build-out of all major routing, and
    completed a rough walking-skeleton navigation experience of LemonMart. This means
    that we are well prepared to implement a role-based conditional navigation experience
    that captures the nuances of a seamless auth experience.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续采用路由优先的方法来设计单页应用（SPA），通过实现LemonMart的身份验证体验。在第7章*创建路由优先的业务应用*中，我们定义了用户角色，完成了所有主要路由的构建，并完成了LemonMart的初步导航体验。这意味着我们已经为实施基于角色的条件导航体验做好了充分准备，这种体验能够捕捉无缝身份验证体验的细微差别。
- en: 'In this chapter, we will implement a token-based auth scheme around the User
    entity that we defined in the last chapter. For a robust and maintainable implementation,
    we will deep dive into **object-oriented programming** (**OOP**) with abstraction,
    inheritance, and factories, along with implementing a cache service, a UI service,
    and two different auth schemes: an in-memory fake auth service for educational
    purposes and a Google Firebase auth service that you can leverage in real-world
    applications.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将围绕我们在上一章中定义的用户实体实现一个基于令牌的身份验证方案。为了实现一个健壮且易于维护的实现，我们将深入探讨面向对象编程（**OOP**），包括抽象、继承和工厂，同时实现缓存服务、UI服务以及两种不同的身份验证方案：用于教育目的的内存中模拟身份验证服务和可用于实际应用的Google
    Firebase身份验证服务。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: Designing an auth workflow
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计身份验证工作流程
- en: TypeScript operators for safe data handling
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript操作符用于安全数据处理
- en: Reusable services leveraging OOP concepts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用面向对象编程（OOP）概念的可重用服务
- en: Dynamic UI components and navigation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态UI组件和导航
- en: Role-based routing using guards
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用守卫进行基于角色的路由
- en: Firebase authentication recipe
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firebase身份验证配方
- en: Providing a service using a factory
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工厂提供服务
- en: The most up-to-date versions of the sample code for the book are on GitHub at
    the linked repository that follows. The repository contains the final and completed
    state of the code. You can verify your progress at the end of this chapter by
    looking for the end-of-chapter snapshot of code under the `projects` folder.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍的示例代码的最新版本可以在GitHub上找到，链接的仓库包含代码的最终和完成状态。你可以在本章末尾通过查找`projects`文件夹下的代码章节快照来验证你的进度。
- en: 'For *Chapter 8*:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*第8章*：
- en: Clone the repository [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart
    )
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆仓库 [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
- en: Execute `npm install` on the root folder to install dependencies
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根文件夹上执行`npm install`以安装依赖项
- en: The code sample for this chapter is under the sub-folder
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本章的代码示例位于子文件夹
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To run the Angular application for this chapter, execute
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行本章的Angular应用程序，请执行
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To run the Angular unit tests for this chapter, execute
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行本章的Angular单元测试，请执行
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To run Angular e2e tests for this chapter, execute
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行本章的Angular端到端测试，请执行
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To build a production-ready Angular application for this chapter, execute
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建本章的生产就绪Angular应用程序，请执行
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that the `dist/ch8` folder at the root of the repository will contain the
    compiled result.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，存储库根目录下的`dist/ch8`文件夹将包含编译结果。
- en: Be aware that the source code in the book or on GitHub may not always match
    the code generated by Angular CLI. There may also be slight differences in implementation
    between the code in the book and what's on GitHub because the ecosystem is ever-evolving.
    It is natural for the sample code to change over time. Also, on GitHub, expect
    to find corrections, fixes to support newer versions of libraries, or side-by-side
    implementations of multiple techniques for you to observe. You are only expected
    to implement the ideal solution recommended in the book. If you find errors or
    have questions, please create an issue or submit a pull request on GitHub for
    the benefit of all readers.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，书中或GitHub上的源代码可能并不总是与Angular CLI生成的代码匹配。由于生态系统不断演变，书中代码与GitHub上代码之间的实现也可能存在细微差异。随着时间的推移，示例代码发生变化是自然的。此外，在GitHub上，您可能会找到更正、支持库新版本的修复或多种技术的并排实现，供您观察。您只需实现书中推荐的理想解决方案即可。如果您发现错误或有问题，请创建一个issue或提交一个pull
    request到GitHub，以供所有读者受益。
- en: Let's start with going over how a token-based auth workflow functions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从了解基于令牌的认证工作流程如何运作开始。
- en: Designing an auth workflow
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计认证工作流程
- en: A well-designed authentication workflow is stateless so that there's no concept
    of an expiring session. Users are free to interact with your stateless REST APIs
    from as many devices and tabs as they wish, simultaneously or over time. **JSON
    Web Token** (**JWT**) implements distributed claims-based authentication that
    can be digitally signed or integration that is protected and/or encrypted using
    a **Message Authentication Code** (**MAC**). This means that once a user's identity
    is authenticated (that is, a password challenge on a login form), they receive
    an encoded claim ticket or a token, which can then be used to make future requests
    to the system without having to reauthenticate the identity of the user.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计良好的认证工作流程是无状态的，因此没有会话过期的概念。用户可以自由地从他们想要的任何设备和标签页与您的无状态REST API交互，同时或随着时间的推移。**JSON
    Web Token**（**JWT**）实现了基于声明的分布式认证，可以数字签名或使用**消息认证码**（**MAC**）进行保护/加密。这意味着一旦用户的身份得到认证（即在登录表单上的密码挑战），他们就会收到一个编码的声明票据或令牌，然后可以使用它来向系统发出未来的请求，而无需重新认证用户身份。
- en: The server can independently verify the validity of this claim and process the
    requests without requiring any prior knowledge of having interacted with this
    user. Thus, we don't have to store session information regarding a user, making
    our solution stateless and easy to scale. Each token will expire after a predefined
    period and due to their distributed nature, they can't be remotely or individually
    revoked; however, we can bolster real-time security by interjecting custom account
    and user role status checks to ensure that the authenticated user is authorized
    to access server-side resources.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以独立验证此声明的有效性并处理请求，而无需了解之前是否与该用户交互的任何先验知识。因此，我们不需要存储关于用户的会话信息，这使得我们的解决方案无状态且易于扩展。每个令牌在预定义的期限后都会过期，由于它们的分布式特性，它们不能远程或单独撤销；然而，我们可以通过插入自定义账户和用户角色状态检查来增强实时安全性，以确保认证用户有权访问服务器端资源。
- en: JWTs implement the **Internet Engineering Task Force** (**IETF**) industry standard
    RFC 7519, found at [https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: JWT实现了**互联网工程任务组**（**IETF**）行业标准RFC 7519，可在[https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)找到。
- en: A good authorization workflow enables conditional navigation based on a user's
    role so that users are automatically taken to the optimal landing screen; they
    are not shown routes or elements that are not suitable for their roles and if,
    by mistake, they try to access a restricted path, they are prevented from doing
    so. You must remember that any client-side role-based navigation is merely a convenience
    and is not meant for security. This means that every call made to the server should
    contain the necessary header information, with the secure token, so that the user
    can be reauthenticated by the server and their role independently verified. Only
    then will they be allowed to retrieve secured data. Client-side authentication
    can't be trusted, which is why password reset screens must be built with a server-side
    rendering technology so that both the user and the server can verify that the
    intended user is interacting with the system.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的授权工作流程可以根据用户的角色进行条件导航，这样用户就可以自动被带到最优的着陆页面；不会显示不适合他们角色的路径或元素，如果他们不小心尝试访问受限路径，将阻止他们这样做。你必须记住，任何客户端基于角色的导航仅仅是一种便利，并不用于安全。这意味着对服务器的每个调用都应该包含必要的头信息，包括安全令牌，以便服务器可以重新验证用户并独立验证其角色。只有这样，他们才能被允许检索受保护的数据。客户端认证不可信，这就是为什么密码重置屏幕必须使用服务器端渲染技术来构建，以便用户和服务器都可以验证预期的用户正在与系统交互。
- en: JWT life cycle
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JWT生命周期
- en: 'JWTs complement a stateless REST API architecture with an encrypted token mechanism
    that allows convenient, distributed, and high-performance authentication and authorization
    of requests sent by clients. There are three main components of a token-based
    authentication scheme:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: JWTs通过加密令牌机制补充无状态REST API架构，允许方便、分布式和高性能地认证和授权客户端发送的请求。基于令牌的认证方案有三个主要组成部分：
- en: '**Client-side**: Captures login information and hides disallowed actions for
    a good UX'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**: 捕获登录信息并隐藏不允许的操作以提供良好的用户体验'
- en: '**Server-side**: Validates that every request is both authenticated and has
    the proper authorization'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器端**: 验证每个请求都经过身份验证并且具有适当的授权'
- en: '**Auth service**: Generates and validates encrypted tokens, and independently
    verifies the auth status of user requests from a data store'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证服务**: 生成和验证加密令牌，并独立验证用户请求的认证状态'
- en: A secure system presumes that data sent/received between clients (applications
    and browsers), systems (servers and services), and databases is encrypted using
    **transport layer security** (**TLS**), which is essentially a newer version of
    **secure sockets layer** (**SSL**). This means that your REST API must be hosted
    with a properly configured SSL certificate, serving all API calls over HTTPS,
    so that user credentials are never exposed between the client and the server.
    Similarly, any database or third-party service call should happen over TLS. This
    ensures the security of the data in transit.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一个安全的系统假设客户端（应用程序和浏览器）、系统（服务器和服务）和数据库之间发送/接收的数据使用**传输层安全性**（**TLS**）进行加密，这本质上是一个**安全套接字层**（**SSL**）的新版本。这意味着你的REST
    API必须使用正确配置的SSL证书托管，通过HTTPS提供所有API调用，以确保用户凭据在客户端和服务器之间永远不会暴露。同样，任何数据库或第三方服务调用都应该通过TLS进行。这确保了传输中数据的安全性。
- en: At-rest (when the data is sitting in the database) passwords should be stored
    using a secure one-way hashing algorithm with good salting practices.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在静止状态（数据坐在数据库中时），应该使用安全的单向哈希算法和良好的加盐实践来存储密码。
- en: 'Did all the talk of hashing and salting make you think of breakfast? Unfortunately,
    they''re cryptography-related terms. If you''re interested in learning more, check
    out this article: [https://crackstation.net/hashing-security.htm](https://crackstation.net/hashing-security.htm).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的哈希和加盐的讨论让你想起了早餐吗？不幸的是，它们是密码学相关的术语。如果你有兴趣了解更多，请查看这篇文章：[https://crackstation.net/hashing-security.htm](https://crackstation.net/hashing-security.htm)。
- en: Sensitive user information, such as **personally identifiable information**
    (**PII**), should be encrypted at rest with a secure two-way encryption algorithm,
    unlike passwords. Passwords are hashed, so we verify that the user is providing
    the same password without the system knowing what the password is. With PII, we
    must be able to decrypt the data so that we can display it to the user. But since
    the data is encrypted at rest, if the database is compromised then the hacked
    data is worthless.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于敏感的用户信息，如**个人身份信息**（**PII**），应使用安全的双向加密算法在静止状态下进行加密，与密码不同。密码是经过散列的，因此我们验证用户提供的密码是否与系统所知的密码相同。对于PII，我们必须能够解密数据，以便我们可以将其显示给用户。但由于数据在静止状态下加密，如果数据库被破坏，那么被黑客窃取的数据就毫无价值。
- en: Following a layered approach to security is critical, because attackers will
    need to accomplish the unlikely feat of compromising all layers of your security
    at the same time to cause meaningful harm to your business.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 采取分层的安全方法至关重要，因为攻击者需要同时破坏你安全系统的所有层，这是一个不太可能完成的任务，以对你的业务造成实质性伤害。
- en: '**Fun fact**: When you hear about massive data breaches from major corporations,
    most of the time the root cause is a lack of proper implementation of in-transit
    or at-rest security. Sometimes this is because it is too computationally expensive
    to continually encrypt/decrypt data, so engineers rely on being behind firewalls.
    In that case, once the outer perimeter is breached, as they say, the fox has access
    to the hen house.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**有趣的事实**：当你听到来自大型公司的重大数据泄露事件时，大多数情况下，根本原因是对传输中或静止状态下的安全措施实施不当。有时这是因为持续加密/解密数据计算成本过高，因此工程师依赖于防火墙的保护。在这种情况下，一旦外围被突破，正如他们所说，狐狸就进入了鸡舍。'
- en: 'Consider the following sequence diagram, which highlights the life cycle of
    JWT-based authentication:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下序列图，它突出了基于JWT的认证生命周期：
- en: '![](img/B14094_08_01.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_08_01.png)'
- en: 'Figure 8.1: The life cycle of JWT-based authentication'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：基于JWT的认证生命周期
- en: Initially, a user logs in by providing their username and password. Once validated,
    the user's authentication status and role are encrypted in a JWT with an expiration
    date and time, and it is sent back to the browser.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，用户通过提供用户名和密码进行登录。一旦验证通过，用户的认证状态和角色将被加密在一个带有过期日期和时间的JWT中，并将其发送回浏览器。
- en: Our Angular (or any other) application can cache this token in local or session
    storage securely so that the user isn't forced to log in with every request. This
    way, we don't resort to insecure practices like storing user credentials in cookies
    to provide a good UX.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序（Angular或其他）可以安全地将此令牌缓存到本地或会话存储中，这样用户就不必在每次请求时都强制登录。这样，我们就不会采取像在cookie中存储用户凭据这样的不安全做法，以提供良好的用户体验。
- en: 'You will get a better understanding of the JWT life cycle when you implement
    your own auth service later in this chapter. In the following sections, we will
    design a fully featured auth workflow around the **User** data entity, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在本章后面实现自己的认证服务时，你会对JWT生命周期有更深入的理解。在接下来的几节中，我们将围绕**用户**数据实体设计一个功能齐全的认证工作流程，如下所示：
- en: '![](img/B14094_08_02.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_08_02.png)'
- en: 'Figure 8.2: The User entity'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：用户实体
- en: The User entity described is slightly different to our initial entity model.
    The entity model reflects how data is stored in the database. The entity is a
    flattened (or simplified) representation of the user record. Even a flattened
    entity has complex objects, like **name**, which has properties for first, middle,
    and last. Furthermore, not all properties are required. Additionally, when interacting
    with auth systems and other APIs, we may receive incomplete, incorrect, or maliciously
    formed data, so our code will have to effectively deal with `null` and `undefined`
    variables.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 描述的用户实体与我们最初的实体模型略有不同。实体模型反映了数据在数据库中的存储方式。实体是用户记录的扁平化（或简化）表示。即使是一个扁平化的实体也有复杂的对象，如**姓名**，它具有首字母、中间名和姓氏等属性。此外，并非所有属性都是必需的。此外，当与认证系统和其他API交互时，我们可能会收到不完整、错误或恶意构造的数据，因此我们的代码必须有效地处理`null`和`undefined`变量。
- en: Next, let's see how we can leverage TypeScript operators to effectively deal
    with unexpected data.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何利用TypeScript运算符有效地处理意外数据。
- en: TypeScript operators for safe data handling
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript的安全数据处理运算符
- en: JavaScript is a dynamically typed language. At runtime, the JavaScript engine
    executing our code, like Chrome's V8, doesn't know the type of the variable we're
    using. As a result, the engine must infer the type. We can have basic types like
    `boolean`, `number`, `array`, or `string`, or we can have a complex type, which
    is essentially a JSON object. In addition, variables can be `null` or `undefined`.
    In broad terms, `undefined` represents something that hasn't been initialized
    and `null` represents something that isn't currently available.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种动态类型语言。在运行时，执行我们代码的 JavaScript 引擎，如 Chrome 的 V8，不知道我们使用的变量的类型。因此，引擎必须推断类型。我们可以有基本类型，如
    `boolean`、`number`、`array` 或 `string`，或者我们可以有复杂类型，这本质上是一个 JSON 对象。此外，变量可以是 `null`
    或 `undefined`。从广义上讲，`undefined` 表示尚未初始化的东西，而 `null` 表示当前不可用的事物。
- en: In strongly typed languages, the concept of `undefined` doesn't exist. Basic
    types have default values, like a `number` is a zero or a `string` is an empty
    string. However, complex types can be `null`. A `null` reference means that the
    variable is defined, but there's no value behind it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在强类型语言中，`undefined` 的概念不存在。基本类型有默认值，例如 `number` 是零或 `string` 是空字符串。然而，复杂类型可以是
    `null`。`null` 引用意味着变量已定义，但后面没有值。
- en: The inventor of the `null` reference, Tony Hoare, called it his "billion-dollar
    mistake."
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`null` 引用的发明者托尼·霍尔（Tony Hoare）称其为他的“十亿美元的错误”。'
- en: TypeScript brings the concepts of strongly typed languages to JavaScript, so
    it must bridge the gap between the two worlds. As a result, TypeScript defines
    types like `null`, `undefined`, `any`, and `never` to make sense of JavaScript's
    type semantics. I've added links to relevant TypeScript documentation in the *Further
    reading* section for a deeper dive into TypeScript types.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 将强类型语言的概念引入 JavaScript，因此它必须在两个世界之间架起桥梁。因此，TypeScript 定义了 `null`、`undefined`、`any`
    和 `never` 等类型，以便理解 JavaScript 的类型语义。我在 *进一步阅读* 部分添加了相关 TypeScript 文档的链接，以便深入了解
    TypeScript 类型。
- en: As the TypeScript documentation puts it, TypeScript treats `null` and `undefined`
    differently in order to match the JavaScript semantics. For example, the union
    type `string | null` is a different type than `string | undefined` and `string
    | undefined | null`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如 TypeScript 文档所述，TypeScript 为了匹配 JavaScript 语义，对 `null` 和 `undefined` 处理不同。例如，联合类型
    `string | null` 与 `string | undefined` 和 `string | undefined | null` 是不同的类型。
- en: 'There''s another nuance: checking to see whether a value equals `null` using
    `==` versus `===`. Using the double equals operator, checking that `foo != null`
    means that `foo` is defined and not `null`. However, using the triple equals operator,
    `foo !== null` means that `foo` is not `null`, but could be `undefined`. However,
    these two operators don''t consider the truthiness of the variable, which includes
    the case of an empty string.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个细微差别是：使用 `==` 和 `===` 来检查一个值是否等于 `null`。使用双等号运算符，检查 `foo != null` 表示 `foo`
    已定义且不是 `null`。然而，使用三等号运算符，`foo !== null` 表示 `foo` 不是 `null`，但可能是 `undefined`。然而，这两个运算符并没有考虑变量的真值，这包括空字符串的情况。
- en: These subtle differences have a great impact on how you write code, especially
    when using the strict TypeScript rules that are applied when you create your Angular
    application using the `--strict` option. It is important to remember that TypeScript
    is a development time tool and not a runtime tool. At runtime, we're still dealing
    with the realities of a dynamically typed language. Just because we declared a
    type to be a string, it doesn't mean that we will receive a string.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些细微差别对您编写代码的方式有很大影响，尤其是在使用 `--strict` 选项创建 Angular 应用程序时应用的严格 TypeScript 规则。重要的是要记住，TypeScript
    是一个开发时工具，而不是运行时工具。在运行时，我们仍在处理动态类型语言的现实。仅仅因为我们声明了一个类型为字符串，并不意味着我们会收到一个字符串。
- en: Next, let's see how we can deal with issues related to working with unexpected
    values.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何处理与处理意外值相关的问题。
- en: Null and undefined checking
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`null` 和 `undefined` 检查'
- en: When working with other libraries or dealing with information sent or received
    outside of your application, you must deal with the fact that the variable you
    receive might be `null` or `undefined`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当与其他库一起工作或处理来自或发送到您应用程序之外的信息时，您必须处理接收到的变量可能是 `null` 或 `undefined` 的事实。
- en: Outside of your application means dealing with user input, reading from a cookie
    or `localStorage`, URL parameters from the router, or an API call over HTTP, to
    name a few examples.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序外部意味着处理用户输入、从 cookie 或 `localStorage` 读取、从路由器获取 URL 参数，或者通过 HTTP 进行 API
    调用等。
- en: 'In our code, we mostly care about the truthiness of a variable. This means
    that a variable is defined, not null, and if it''s a basic type, it has a non-default
    value. Given a `string`, we can check whether the `string` is truthy with a simple
    `if` statement:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们主要关心变量的真值。这意味着变量已被定义，不是`null`，如果它是一个基本类型，它有一个非默认值。给定一个`string`，我们可以通过简单的`if`语句检查`string`是否为真值：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If `foo` is `null`, `undefined`, or an empty string, the variable will be evaluated
    as `falsy`. For certain situations, you may want to use the conditional or ternary
    operator instead of `if-else`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`foo`是`null`、`undefined`或空字符串，变量将被评估为`falsy`。在特定情况下，你可能想使用条件运算符或三元运算符而不是`if-else`。
- en: The conditional or ternary operator
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件运算符或三元运算符
- en: 'The conditional or ternary operator has the `?:` syntax. On the left-hand side
    of the question mark, the operator takes a conditional statement. On the right-hand
    side, we provide the outcomes for true and false around the colon: `conditional
    ? true-outcome : false-outcome`. The conditional or ternary operator is a compact
    way to represent `if-else` conditions, and can be very useful for increasing the
    readability of your code base. This operator is not a replacement for an `if-else`
    block, but it is great when you''re using the output of the `if-else` condition.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '条件运算符或三元运算符具有`?:`语法。在问号的左侧，运算符接受一个条件语句。在冒号的右侧，我们提供真值和假值的输出：`conditional ? true-outcome
    : false-outcome`。条件运算符或三元运算符是表示`if-else`条件的一种紧凑方式，并且对于提高代码库的可读性非常有用。这个运算符不是`if-else`块的替代品，但当你使用`if-else`条件的输出时，它非常出色。'
- en: 'Consider the following example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding `if-else` block can be re-written as:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`if-else`块可以重写为：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this case, the conditional or ternary operator makes the code more compact
    and easier to understand at a glance. Another common scenario is returning a default
    value, where the variable is `falsy`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，条件运算符或三元运算符使代码更加紧凑，并且一眼就能理解。另一个常见场景是当变量是`falsy`时返回默认值。
- en: We will consider the null coalescing operator next.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑空值合并运算符。
- en: The null coalescing operator
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空值合并运算符
- en: The null coalescing operator is `||`. This operator saves us from repetition,
    when the truthy result of the conditional is the same as the conditional itself.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 空值合并运算符是`||`。这个运算符在条件运算的结果与条件本身相同时，可以避免重复。
- en: 'Consider the example where if `foo` is defined, we would like to use the value
    of `foo`, but if it is `undefined`, we need a default value of `''bar''`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，如果`foo`被定义，我们希望使用`foo`的值，但如果它是`undefined`，我们需要一个默认值`'bar'`：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see, `foo` is repeated twice. We can avoid the duplication by using
    the null coalescing operator:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`foo`被重复了两次。我们可以通过使用空值合并运算符来避免重复：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So, if `foo` is `undefined`, `null` or an empty string, `bar` will be output.
    Otherwise, the value of `foo` will be used. But in some cases, we need to only
    use the default value if the value is `undefined` or `null`. We will consider
    the nullish coalescing operator next.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果`foo`是`undefined`、`null`或空字符串，将输出`bar`。否则，将使用`foo`的值。但在某些情况下，我们只需要在值是`undefined`或`null`时使用默认值。我们将考虑空值合并运算符。
- en: The nullish coalescing operator
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空值合并运算符
- en: 'The nullish coalescing operator is `??`. This operator is like the null coalescing
    operator, with one crucial difference. Checking the truthiness of a variable is
    not enough when dealing with data received from an API or user input, where an
    empty string may be a valid value. As we covered earlier in this section, checking
    for `null` and `undefined` is not as straightforward as it seems. But we know
    that by using the double equals operator, we can ensure that `foo` is defined
    and not null:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 空值合并运算符是`??`。这个运算符类似于空值合并运算符，但有一个关键的区别。当处理从API或用户输入接收到的数据时，检查变量的真值可能不足以确定，因为空字符串可能是一个有效的值。正如我们在本节前面所讨论的，检查`null`和`undefined`并不像看起来那么简单。但我们知道，通过使用双等号运算符，我们可以确保`foo`被定义且不是`null`：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding case, if `foo` is an empty string or another value, we will
    get the value of `foo` output. If it is `null` or `undefined`, we will get `''bar''`.
    A more compact way to do this is by using the nullish coalescing operator:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，如果`foo`是一个空字符串或其他值，我们将得到`foo`的值输出。如果它是`null`或`undefined`，我们将得到`'bar'`。一个更紧凑的方法是使用空值合并运算符：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code will yield the same result as the previous example. However,
    when dealing with complex objects, we need to consider whether their properties
    are `null` or `undefined` as well. For this, we will consider the optional chaining
    operator.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生与上一个示例相同的结果。然而，在处理复杂对象时，我们还需要考虑它们的属性是否是`null`或`undefined`。为此，我们将考虑使用可选链运算符。
- en: Optional chaining
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选链
- en: The optional chaining operator is `?`. It is like Angular's safe navigation
    operator, which was covered in *Chapter 3*, *Creating a Basic Angular App*. Optional
    chaining ensures that a variable or property is defined and not `null` before
    attempting to access a child property or invoke a function. So the statement `foo?.bar?.callMe()`
    executes without throwing an error, even if `foo` or `bar` is `null` or `undefined`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 可选链运算符是`?`。它类似于Angular的安全导航运算符，这在*第3章*，*创建一个基本的Angular应用*中已经介绍过。可选链确保在尝试访问子属性或调用函数之前，变量或属性已被定义且不是`null`。因此，即使`foo`或`bar`是`null`或`undefined`，`foo?.bar?.callMe()`语句也会执行而不会抛出错误。
- en: 'Consider the **User** entity, which has a `name` object with properties for
    `first`, `middle`, and `last`. Let''s see what it would take to safely provide
    a default value of an empty string for a middle name using the nullish coalescing
    operator:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑**用户**实体，它有一个`name`对象，包含`first`、`middle`和`last`属性。让我们看看使用空值合并运算符为中间名提供一个空字符串默认值需要什么：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see, we need to check whether a parent object is truthy before accessing
    a child property. If `middle` is `null`, an empty string is output. Optional chaining
    makes this task simpler:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在访问子属性之前，我们需要检查父对象是否为真值。如果`middle`是`null`，则输出一个空字符串。可选链使这项任务变得简单：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using optional chaining and the nullish coalescing operator together, we can
    eliminate repetition and deliver robust code that can effectively deal with the
    realities of JavaScript's dynamic runtime.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可选链和空值合并运算符一起，我们可以消除重复，并交付出健壮的代码，能够有效地处理JavaScript动态运行时的现实情况。
- en: So, when designing your code, you have to make decisions on whether to introduce
    the concept of null to your logic or work with default values like empty strings.
    In the next section, as we implement the User entity, you will see how these choices
    play out. So far, we have only used interfaces to define the shape of our data.
    Next, let's build the User entity, leveraging OOP concepts like classes, enums,
    and abstraction to implement it, along with an auth service.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在设计代码时，你必须决定是否在你的逻辑中引入空值的概念，或者使用默认值，如空字符串。在下一节中，当我们实现用户实体时，你会看到这些选择是如何体现的。到目前为止，我们只使用了接口来定义我们数据的结构。接下来，让我们构建用户实体，利用面向对象编程（OOP）的概念，如类、枚举和抽象来实现它，以及一个认证服务。
- en: Reusable services leveraging OOP concepts
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用OOP概念的可重用服务
- en: As mentioned, we have only worked with interfaces to represent data. We still
    want to continue using interfaces when passing data around various components
    and services. Interfaces are great for describing the kind of properties or functions
    an implementation has, but they suggest nothing about the behavior of these properties
    or functions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们只使用接口来表示数据。我们仍然希望在传递数据到各种组件和服务时继续使用接口。接口非常适合描述实现具有哪些属性或函数，但它们对这些属性或函数的行为没有任何暗示。
- en: With ES2015 (ES6), JavaScript gained native support for classes, which is a
    crucial concept of the OOP paradigm. Classes are actual implementations of behavior.
    As opposed to just having a collection of functions in a file, a class can properly
    encapsulate behavior. A class can then be instantiated as an object using the
    new keyword.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES2015（ES6）中，JavaScript获得了对类的本地支持，这是面向对象范式的一个关键概念。类是行为的实际实现。与文件中只包含函数集合相比，类可以正确地封装行为。然后可以使用`new`关键字将类实例化为对象。
- en: TypeScript takes the ES2015 (and beyond) implementation of classes and introduces
    necessary concepts like abstract classes, private, protected, and public properties,
    and interfaces to make it possible to implement OOP patterns.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript采用了ES2015（及以后）的类实现，并引入了必要的概念，如抽象类、私有、受保护和公共属性，以及接口，使得实现OOP模式成为可能。
- en: OOP is an imperative programming style, compared to the reactive programming
    style that RxJS enables. Classes form the bedrock of OOP, whereas observables
    do the same for reactive programming using RxJS.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）是一种命令式编程风格，与RxJS启用的响应式编程风格相比。类是OOP的基石，而可观察者（observables）在RxJS中为响应式编程提供了同样的作用。
- en: 'I encourage you to become familiar with OOP terminology. Please see the *Further
    reading* section for some useful resources. You should become familiar with:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你熟悉OOP术语。请参阅*进一步阅读*部分，了解一些有用的资源。你应该熟悉：
- en: Classes versus objects
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类与对象
- en: Composition (interfaces)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合（接口）
- en: Encapsulation (private, protected, and public properties, and property getters
    and setters)
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 封装（私有、受保护和公共属性，以及属性获取器和设置器）
- en: Polymorphism (inheritance, abstract classes, and method overriding)
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多态（继承、抽象类和方法重写）
- en: As you know, Angular uses OOP patterns to implement components and services.
    For example, interfaces are used to implement life cycle hooks such as `OnInit`.
    Let's see how these patterns are implemented within the context of JavaScript
    classes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，Angular使用面向对象编程（OOP）模式来实现组件和服务。例如，接口用于实现生命周期钩子，如`OnInit`。让我们看看这些模式如何在JavaScript类中实现。
- en: JavaScript classes
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript类
- en: In this section, I will demonstrate how you can use classes in your own code
    design to define and encapsulate the behavior of your models, such as the `User`
    class. Later in this chapter, you will see examples of class inheritance with
    abstract base classes, which allows us to standardize our implementation and reuse
    base functionality in a clean and easy-to-maintain manner.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将演示如何在你自己的代码设计中使用类来定义和封装模型的行为，例如`User`类。在本章的后面部分，你将看到使用抽象基类的类继承示例，这允许我们标准化我们的实现，并以干净、易于维护的方式重用基本功能。
- en: I must point out that OOP has very useful patterns that can increase the quality
    of your code; however, if you overuse it then you will start losing the benefits
    of the dynamic, flexible, and functional nature of JavaScript.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须指出，OOP具有非常有用的模式，可以提高你代码的质量；然而，如果你过度使用它，你将开始失去JavaScript动态、灵活和功能性的好处。
- en: Sometimes all you need are a bunch of functions in a file, and you'll see examples
    of that throughout the book.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你只需要一个文件中的一系列函数，你将在整本书中看到这些例子。
- en: A great way to demonstrate the value of classes would be to standardize the
    creation of a default `User` object. We need this because a `BehaviorSubject`
    object needs to be initialized with a default object. It is best to do this in
    one place, rather than copy-paste the same implementation in multiple places.
    It makes a lot of sense for the `User` object to own this functionality instead
    of an Angular service creating default `User` objects. So, let's implement a `User`
    class to achieve this goal.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 展示类价值的一个好方法是将默认`User`对象的创建标准化。我们需要这样做，因为`BehaviorSubject`对象需要用默认对象初始化。最好在一个地方完成这个操作，而不是在多个地方复制粘贴相同的实现。让`User`对象拥有这个功能而不是由Angular服务创建默认`User`对象是非常有意义的。所以，让我们实现一个`User`类来实现这个目标。
- en: 'Let''s begin by defining our interfaces and enums:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义我们的接口和枚举开始：
- en: 'Define user roles as an `enum` at the location `src/app/auth/auth.enum.ts`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/app/auth/auth.enum.ts`位置定义用户角色为一个`enum`：
- en: '[PRE14]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Create a `user.ts` file under the `src/app/user/user` folder.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/app/user/user`文件夹下创建一个`user.ts`文件。
- en: 'Define a new interface named `IUser` in the `user.ts` file:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`user.ts`文件中定义一个新的接口`IUser`：
- en: '[PRE15]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that every complex property that is defined on the interface can also be
    represented as a `string`. In transit, all objects are converted to strings using
    `JSON.stringify()`. No type information is included. We also leverage interfaces
    to represent `Class` objects in-memory, which can have complex types. So, our
    interface properties must reflect both cases using union types. For example, `role`
    can either be of type `Role` or `string`. Similarly, `dateOfBirth` can be a `Date`
    or a `string`.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在接口上定义的每个复杂属性也可以表示为一个`string`。在传输过程中，所有对象都使用`JSON.stringify()`转换为字符串。不包含任何类型信息。我们还利用接口在内存中表示具有复杂类型的`Class`对象。因此，我们的接口属性必须使用联合类型反映这两种情况。例如，`role`可以是`Role`类型或`string`。同样，`dateOfBirth`可以是`Date`或`string`。
- en: We define `address` as an inline type, because we don't use the concept of an
    address outside of this class. In contrast, we define `IName` as its own interface,
    because in *Chapter 11*, *Recipes – Reusability, Routing, and Caching*, we will
    implement a separate component for names. We also define a separate interface
    for phones, because they are represented as an array. When developing a form,
    we need to be able to address individual array elements, like `IPhone`, in the
    template code.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将`address`定义为内联类型，因为我们不在这个类之外使用地址的概念。相比之下，我们将`IName`定义为其自己的接口，因为在第11章“食谱 -
    可重用性、路由和缓存”中，我们将实现一个单独的组件来处理名称。我们还为电话定义了一个单独的接口，因为它们被表示为数组。在开发表单时，我们需要能够在模板代码中引用数组中的单个元素，如`IPhone`。
- en: It is the norm to insert a capital `I` in front of interface names so they are
    easy to identify. Don't worry, there are no compatibility issues with using the
    `IPhone` interface on Android phones!
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在接口名称前插入一个大的`I`是规范做法，以便于识别。不用担心，使用`IPhone`接口在Android手机上没有兼容性问题！
- en: 'In `user.ts`, define the `IName` and `IPhone` interfaces, and implement the
    `PhoneType` enum:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`user.ts`中定义`IName`和`IPhone`接口，并实现`PhoneType`枚举：
- en: '[PRE16]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that in the `PhoneType` enum, we explicitly defined `string` values. By
    default, `enum` values are converted into strings as they're typed, which can
    lead to issues with values stored in a database falling out of sync with how a
    developer chooses to spell a variable name. With explicit and all lowercase values,
    we reduce the risk of bugs.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在`PhoneType`枚举中，我们明确地定义了`string`值。默认情况下，`enum`值在输入时会被转换为字符串，这可能导致数据库中存储的值与开发者选择拼写变量名的方式不一致，从而引发问题。通过明确地使用全部小写值，我们降低了出现错误的风险。
- en: 'Finally, define the `User` class, which implements the `IUser` interface:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，定义`User`类，它实现了`IUser`接口：
- en: '[PRE17]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that by defining all properties with default values in the constructors
    as `public` properties, we hit two birds with one stone; otherwise, we would need
    to define properties and initialize them separately. This way, we achieve a concise
    implementation.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，通过在构造函数中将所有属性定义为`public`属性并赋予默认值，我们一举两得；否则，我们需要分别定义属性并初始化它们。这样，我们实现了简洁的实现方式。
- en: Using a static `Build` function, we can quickly hydrate the object with data
    received from the server. We can also implement the `toJSON()` function to customize
    the serialization behavior of our object before sending the data up to the server.
    But before that, let's add a calculated property.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用一个静态的`Build`函数，我们可以快速用从服务器接收到的数据填充对象。我们还可以实现`toJSON()`函数来定制对象在发送到服务器之前的序列化行为。但在那之前，让我们添加一个计算属性。
- en: We can use calculated properties in templates or in toast messages to conveniently
    display values assembled from multiple parts. A great example is extracting a
    full name from the `name` object as a property in the `User` class.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以在模板或吐司消息中使用计算属性方便地显示由多个部分组成的值。一个很好的例子是从`name`对象中提取完整名称作为`User`类中的一个属性。
- en: A calculated property for assembling a full name encapsulates the logic for
    combining a first, middle, and last name, so you don't have to rewrite this logic
    in multiple places, adhering to the DRY principle!
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个用于组装完整名称的计算属性封装了合并姓氏、中间名和姓氏的逻辑，这样你就不必在多个地方重写这个逻辑，遵循DRY原则！
- en: 'Implement a `fullName` property getter in the `User` class:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`User`类中实现一个`fullName`属性获取器：
- en: '[PRE18]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add `fullName` `IUser` as `readonly` and an optional property:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`fullName`属性定义为`IUser`的`readonly`和可选属性：
- en: '[PRE19]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can now use the `fullName` property through the `IUser` interface.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你现在可以通过`IUser`接口使用`fullName`属性。
- en: 'Implement the `toJSON` function:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`toJSON`函数：
- en: '[PRE20]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that when serializing the object, we delete the `_id` and `fullName` fields.
    These are values that we don't want to be stored in the database. The `fullName`
    field is a calculated property, so it doesn't need to be stored. The `_id` is
    normally passed as a parameter in a `GET` or a `PUT` call to locate the record.
    This avoids mistakes that may result in overwriting the `id` fields of existing
    objects.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在序列化对象时，我们删除了`_id`和`fullName`字段。这些是我们不希望存储在数据库中的值。`fullName`字段是一个计算属性，因此不需要存储。`_id`通常在`GET`或`PUT`调用中作为参数传递，用于定位记录。这避免了可能导致的覆盖现有对象`id`字段错误的错误。
- en: Now that we have the `User data` entity implemented, next let's implement the
    auth service.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了`User data`实体，接下来让我们实现认证服务。
- en: Abstraction and inheritance
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象和继承
- en: We aim to design a flexible auth service that can implement multiple auth providers.
    In this chapter, we will implement an in-memory provider and a Google Firebase
    provider. In *Chapter 10*, *RESTful APIs and Full-Stack Implementation*, we will
    implement a custom provider to interact with our backend.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是设计一个灵活的认证服务，可以实现多个认证提供者。在本章中，我们将实现内存提供者和Google Firebase提供者。在*第10章*，*RESTful
    API和全栈实现*中，我们将实现一个自定义提供者以与我们的后端交互。
- en: By declaring an abstract base class, we can describe the common login and logout
    behavior of our application, so when we implement another auth provider, we don't
    have to re-engineer our application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过声明一个抽象基类，我们可以描述我们应用程序的常见登录和注销行为，因此当我们实现另一个认证提供者时，我们不需要重新设计我们的应用程序。
- en: In addition, we can declare abstract functions, which the implementors of our
    base class would have to implement, enforcing our design. Any class that implements
    the base class would also get the benefit of the code implemented in the base
    class, so we wouldn't need to repeat the same logic in two different places.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以声明抽象函数，我们的基类的实现者必须实现这些函数，强制我们的设计。任何实现基类的类都将获得基类中实现代码的好处，因此我们不需要在两个不同的地方重复相同的逻辑。
- en: 'The following class diagram reflects the architecture and inheritance hierarchy
    of our abstract `AuthService`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类图反映了我们的抽象`AuthService`的架构和继承层次结构：
- en: '![](img/B14094_08_03.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_08_03.png)'
- en: 'Figure 8.3: The AuthService inheritance structure'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：AuthService继承结构
- en: '`AuthService` implements the interface `IAuthService`, as shown:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthService`实现了`IAuthService`接口，如下所示：'
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The interface reflects the public properties that the service exposes. The service
    provides the authentication status as the `authStatus$` observable and the current
    user as `currentUser$`, and it provides three functions to `login`, `logout`,
    and `getToken`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口反映了服务公开的属性。服务提供认证状态作为`authStatus$`可观察对象和当前用户作为`currentUser$`，并提供三个函数`login`、`logout`和`getToken`。
- en: '`AuthService` inherits caching functionality from another abstract class called
    `CacheService`. Since `AuthService` is an abstract class, it can''t be used on
    its own, so we implement three auth providers, `InMemoryAuthService`, `FirebaseAuthService`,
    and `CustomAuthService`, as seen at the bottom of the diagram.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthService`从另一个名为`CacheService`的抽象类继承缓存功能。由于`AuthService`是一个抽象类，因此不能单独使用，所以我们实现了三个认证提供者，`InMemoryAuthService`、`FirebaseAuthService`和`CustomAuthService`，如图中底部所示。'
- en: Note that all three auth services implement all abstract functions. In addition,
    the `FirebaseAuthService` overrides the base `logout` function to implement its
    own behavior. All three classes inherit from the same abstract class and expose
    the same public interface. All three will execute the same auth workflow against
    different auth servers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有三个认证服务都实现了所有抽象函数。此外，`FirebaseAuthService`覆盖了基类的`logout`函数以实现其自己的行为。所有三个类从同一个抽象类继承，并公开相同的公共接口。所有三个将执行相同的认证工作流程，针对不同的认证服务器。
- en: The in-memory auth service doesn't communicate with a server. The service is
    for demonstration purposes only. It implements fake JWT encoding, so we can demonstrate
    how the JWT life cycle works.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 内存中的认证服务不与服务器通信。此服务仅用于演示目的。它实现了假的JWT编码，因此我们可以演示JWT生命周期的工作方式。
- en: Let's start by creating the auth service.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建认证服务。
- en: Create the auth service
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建认证服务
- en: 'We will start by creating the abstract auth service and the in-memory service:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建抽象认证服务和内存服务：
- en: 'Add an auth service:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个认证服务：
- en: '[PRE22]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Rename `in-memory-auth.service.ts` to `auth.inmemory.service.ts` so the different
    auth providers visually group together in File Explorer.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`in-memory-auth.service.ts`重命名为`auth.inmemory.service.ts`，以便在文件资源管理器中将不同的认证提供者视觉上分组在一起。
- en: 'Remove the config object `{ providedIn: ''root'' }` from the `@Injectable()`
    decorator of `auth.service.ts` and `auth.inmemory.service.ts`.'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '从`auth.service.ts`和`auth.inmemory.service.ts`的`@Injectable()`装饰器中移除配置对象`{ providedIn:
    ''root'' }`。'
- en: 'Ensure that `authService` is provided in `app.module.ts`, but the `InMemoryAuthService`
    is actually used and not the abstract class:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在`app.module.ts`中提供`authService`，但实际上使用的是`InMemoryAuthService`而不是抽象类：
- en: '[PRE23]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Creating a separate folder for the service organizes various components related
    to auth, such as the `enum` definition for the user role. Additionally, we will
    be able to add an `authService` fake to the same folder for automated testing.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为服务创建一个单独的文件夹，可以组织与认证相关的各种组件，例如用户角色的`enum`定义。此外，我们还将能够将`authService`假对象添加到同一文件夹中，以进行自动化测试。
- en: Implement an abstract auth service
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现一个抽象认证服务
- en: Now, let's build an abstract auth service that will orchestrate logins and logouts,
    while encapsulating the logic of how to manage JWTs, auth status, and information
    regarding the current user. By leveraging the abstract class, we should be able
    to implement our own auth service against any auth provider without modifying
    the internal behavior of our application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建一个抽象认证服务，该服务将协调登录和注销，同时封装管理 JWT、认证状态和有关当前用户信息的逻辑。通过利用抽象类，我们应该能够针对任何认证提供者实现我们自己的认证服务，而无需修改我们应用程序的内部行为。
- en: The abstract auth service that is being demonstrated enables rich and intricate
    workflows. It is a solution that you can drop into your applications without modifying
    the internal logic. As a result, it is a complicated solution.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正在演示的抽象认证服务能够实现丰富和复杂的流程。这是一个你可以直接放入你的应用程序中而无需修改内部逻辑的解决方案。因此，它是一个复杂的解决方案。
- en: 'This auth service will enable us to demonstrate logging in with an email and
    password, caching, and conditional navigation concepts based on authentication
    status and a user''s role:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此认证服务将使我们能够演示使用电子邮件和密码登录、缓存以及基于认证状态和用户角色的条件导航概念：
- en: 'Start by installing a JWT decoding library, and, for faking authentication,
    a JWT encoding library:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先安装一个 JWT 解码库，以及用于模拟认证的 JWT 编码库：
- en: '[PRE24]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Implement an `IAuthStatus` interface to store decoded user information, a helper
    interface, and the secure by default `defaultAuthStatus`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个 `IAuthStatus` 接口以存储解码的用户信息、一个辅助接口和默认安全的 `defaultAuthStatus`：
- en: '[PRE25]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`IAuthStatus` is an interface that represents the shape of a typical JWT that
    you may receive from your authentication service. It contains minimal information
    about the user and the user''s role. The auth status object can be attached to
    the header of every REST call to APIs to verify the user''s identity. The auth
    status can be optionally cached in `localStorage` to remember the user''s login
    state; otherwise, they would have to re-enter their password with every page refresh.'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`IAuthStatus` 是一个接口，表示你可能从认证服务接收到的典型 JWT 的形状。它包含有关用户和用户角色的最小信息。认证状态对象可以附加到每个
    API 调用的头部，以验证用户的身份。认证状态可以可选地缓存在 `localStorage` 中以记住用户的登录状态；否则，他们每次刷新页面时都必须重新输入密码。'
- en: In the preceding implementation, we're assuming the default role of `None`,
    as defined in the `Role` enum. By not giving any role to the user by default,
    we're following a least-privileged access model. The user's correct role will
    be set after they log in successfully with the information received from the auth
    API.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的实现中，我们假设默认角色为 `None`，如 `Role` 枚举中定义。通过默认不给用户分配任何角色，我们遵循最小权限访问模型。用户正确的角色将在他们使用从
    auth API 收到的信息成功登录后设置。
- en: 'Define the `IAuthService` interface in `auth.service.ts`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `auth.service.ts` 中定义 `IAuthService` 接口：
- en: '[PRE26]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Make `AuthService` an `abstract` class, as shown:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `AuthService` 设为 `abstract` 类，如下所示：
- en: '[PRE27]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Implement the interface, `IAuthService`, using VS Code''s quick fix functionality:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 VS Code 的快速修复功能实现接口，`IAuthService`：
- en: '[PRE28]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Implement the `authStatus$` and `currentUser$` properties as `readonly` and initialize
    our data anchors with their default values:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `authStatus$` 和 `currentUser$` 属性为 `readonly`，并用它们的默认值初始化我们的数据锚点：
- en: '[PRE29]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that we removed the type definitions of the properties. Instead, we're
    letting TypeScript infer the type from the initialization.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们移除了属性的类型定义。相反，我们让 TypeScript 从初始化中推断类型。
- en: You must always declare your data anchors as `readonly`, so you don't accidentally
    overwrite the data stream by re-initializing a data anchor as a new `BehaviorSubject`.
    Doing so would render any prior subscribers orphaned, leading to memory leaks,
    and have many unintended consequences.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须始终将你的数据锚点声明为 `readonly`，这样你就不会意外地通过将数据锚点重新初始化为新的 `BehaviorSubject` 来覆盖数据流。这样做会导致任何先前的订阅者成为孤儿，导致内存泄漏，并产生许多意想不到的后果。
- en: All implementors of `IAuthService` need to be able to log the user in, transform
    the token we get back from the server so we can read it and store it, support
    access to the current user, and the auth status, and provide a way to log the
    user out. We have successfully put in the functions for our public methods and
    implemented default values for our data anchors to create hooks for the rest of
    our application to use. But so far, we have only defined what our service can
    do, and not how it can do it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 所有实现 `IAuthService` 的类都需要能够登录用户，将我们从服务器获取的令牌进行转换，以便我们可以读取和存储它，支持访问当前用户和认证状态，并提供一种注销用户的方式。我们已经成功地将公共方法的功能放入其中，并为我们的数据锚点实现了默认值，以创建其余应用程序使用的钩子。但到目前为止，我们只定义了我们的服务可以做什么，而没有定义它是如何做到的。
- en: As always, the devil is in the details, and the hard part is the "how." Abstract
    functions can help us to complete the implementation of a workflow in a service
    within our application, while leaving the portions of the service that must implement
    external APIs undefined.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 总是如此，魔鬼在于细节，难点在于“如何”。抽象函数可以帮助我们在应用程序中的服务内完成工作流程的实现，同时将必须实现外部API的部分服务留空。
- en: Abstract functions
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽象函数
- en: Auth services that implement the abstract class should be able to support any
    kind of auth provider, and any kind of token transformation, while being able
    to modify behaviors like user retrieval logic. We must be able to implement login,
    logout, token, and auth status management without implementing calls to specific
    services.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 实现抽象类的认证服务应该能够支持任何类型的认证提供者和任何类型的令牌转换，同时能够修改如用户检索逻辑等行为。我们必须能够实现登录、注销、令牌和认证状态管理，而不需要实现对特定服务的调用。
- en: By defining abstract functions, we can declare a series of methods that must
    implement a given set of inputs and outputs—a signature without an implementation.
    We can then use these abstract functions to orchestrate the implementation of
    our auth workflow.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义抽象函数，我们可以声明一系列必须实现给定输入和输出的方法——一个没有实现的签名。然后我们可以使用这些抽象函数来编排我们的认证工作流程的实现。
- en: Our design goal here is driven by the Open/Closed principle. The `AuthService`
    will be open to extension through its ability to be extended to work with any
    kind of token-based auth provider, but closed to modification. Once we're done
    implementing the `AuthService`, we won't need to modify its code to add additional
    auth providers.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里的设计目标是受 Open/Closed 原则驱动的。`AuthService` 将通过其扩展能力来工作与任何基于令牌的认证提供者，但对其修改是封闭的。一旦我们完成了
    `AuthService` 的实现，我们就无需修改其代码来添加额外的认证提供者。
- en: 'Now we need to define the abstract functions that our auth providers must implement,
    as shown in *Figure 8.3* from earlier in the chapter:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要定义我们的认证提供者必须实现的抽象函数，如本章前面 *图8.3* 所示：
- en: '`authProvider(email, password)`: `Observable<IServerAuthResponse>` can log
    us in via a provider and return a standardized `IServerAuthResponse`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`authProvider(email, password)`: `Observable<IServerAuthResponse>` 可以通过提供者登录并返回一个标准化的
    `IServerAuthResponse`'
- en: '`transformJwtToken(token)`: `IAuthStatus` can normalize the token a provider
    returns to the interface of `IAuthStatus`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transformJwtToken(token)`: `IAuthStatus` 可以将提供者返回给 `IAuthStatus` 接口令牌进行标准化'
- en: '`getCurrentUser()`: `Observable<User>` can retrieve the user profile of the logged-in
    user'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCurrentUser()`: `Observable<User>` 可以检索已登录用户的用户资料'
- en: 'We can then use these functions in our `login`, `logout`, and `getToken` methods
    to implement the auth workflow:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在我们的 `login`、`logout` 和 `getToken` 方法中使用这些函数来实现认证工作流程：
- en: 'Define the abstract methods that the derived classes should implement as protected
    properties, so they''re accessible in the derived class, but not publicly:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将派生类应实现的方法定义为受保护的属性，这样它们在派生类中可访问，但不是公开的：
- en: '[PRE30]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Leveraging these stubbed out methods, we can now implement a `login` method
    that performs a login and retrieves the currently logged-in user, making sure
    to update the `authStatus$` and `currentUser$` data streams.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 利用这些已编写的函数，我们现在可以实现一个 `login` 方法，执行登录并检索当前登录用户，确保更新 `authStatus$` 和 `currentUser$`
    数据流。
- en: 'Before we move on, implement a `transformError` function to handle errors of
    different types like `HttpErrorResponse` and `string`, providing them in an observable
    stream. In a new file named `common.ts` under `src/app/common` create the `transformError`
    function:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们继续之前，实现一个 `transformError` 函数来处理不同类型的错误，如 `HttpErrorResponse` 和 `string`，并将它们提供在可观察流中。在
    `src/app/common` 下的一个名为 `common.ts` 的新文件中创建 `transformError` 函数：
- en: '[PRE31]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In `auth.service.ts`, implement the `login` method:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`auth.service.ts`中实现`login`方法：
- en: '[PRE32]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `login` method encapsulates the correct order of operations by calling the
    `authProvider` with the `email` and `password` information, then decoding the
    received JWT, transforming it, and updating `authStatus$`. Then `getCurrentUser()`
    is called only if `status.isAuthenticated` is `true`. Later, `currentUser$` is
    updated and, finally, we catch any errors using our custom `transformError` function.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`login`方法通过调用带有`email`和`password`信息的`authProvider`来封装正确的操作顺序，然后解码接收到的JWT，转换它，并更新`authStatus$`。然后只有在`status.isAuthenticated`为`true`时才调用`getCurrentUser()`。之后，更新`currentUser$`，最后，我们使用自定义的`transformError`函数捕获任何错误。'
- en: We activate the observable stream by calling `subscribe` on it. In the case
    of an error, we call `logout()` to maintain the correct status of our application
    and bubble up errors to consumers of `login` by re-throwing the error using `throwError`.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们通过在它上面调用`subscribe`来激活可观察流。在出现错误的情况下，我们调用`logout()`以保持应用程序的正确状态，并通过使用`throwError`重新抛出错误，将错误冒泡到`login`的消费者。
- en: Now, the corresponding `logout` function needs to be implemented. Logout is
    triggered by the **Logout** button from the application toolbar in the case of
    a failed login attempt, as shown earlier, or if an unauthorized access attempt
    is detected. We can detect unauthorized access attempts by using a router auth
    guard as the user is navigating the application, which is a topic covered later
    in the chapter.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，需要实现相应的`logout`函数。在登录尝试失败的情况下，或者在检测到未经授权的访问尝试时，都会触发注销。我们可以通过使用路由认证守卫来检测未经授权的访问尝试，因为用户正在导航应用程序，这是本章后面将要讨论的主题。
- en: 'Implement the `logout` method:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现注销方法：
- en: '[PRE33]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We log out by pushing out the `defaultAuthStatus` as the next value in the `authStatus$`
    stream. Note the use of `setTimeout`, which allows us to avoid timing issues when
    core elements of the application are all changing statuses at once.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将`defaultAuthStatus`作为`authStatus$`流中的下一个值来注销。注意`setTimeout`的使用，它允许我们在应用程序的核心元素同时更改状态时避免时序问题。
- en: Think about how the `login` method adheres to the Open/Closed principle. The
    method is open to extension through the abstract functions `authProvider`, `transformJwtToken`,
    and `getCurrentUser`. By implementing these functions in a derived class, we maintain
    the ability to externally supply different auth providers without having to modify
    the `login` method. As a result, the implementation of the method remains closed
    to modification, thus adhering to the Open/Closed principle.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到`login`方法如何遵循开放/封闭原则。该方法通过抽象函数`authProvider`、`transformJwtToken`和`getCurrentUser`进行扩展。通过在派生类中实现这些函数，我们保持了外部提供不同认证提供者的能力，而无需修改`login`方法。因此，方法的实现保持对修改的封闭，从而遵循开放/封闭原则。
- en: The true value of creating abstract classes is the ability to encapsulate common
    functionality in an extensible way.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 创建抽象类的真正价值在于能够以可扩展的方式封装常见功能。
- en: You may ignore the `getToken` function for now, as we are not yet caching our
    JWT. Without caching, the user would have to log in with every page refresh. Let's
    implement caching next.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 目前您可以忽略`getToken`函数，因为我们还没有缓存JWT。在没有缓存的情况下，用户每次刷新页面时都必须登录。让我们接下来实现缓存。
- en: Abstract caching service using localStorage
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用localStorage的抽象缓存服务
- en: We must be able to cache the authentication status of the logged-in user. As
    mentioned, otherwise, with every page refresh, the user will have to go through
    the login routine. We need to update `AuthService` so that it persists the auth
    status.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须能够缓存已登录用户的认证状态。如前所述，否则，每次页面刷新时，用户都必须通过登录流程。我们需要更新`AuthService`以持久化认证状态。
- en: 'There are three main ways to store data:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 存储数据主要有三种方式：
- en: '`cookie`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cookie`'
- en: '`localStorage`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localStorage`'
- en: '`sessionStorage`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sessionStorage`'
- en: Cookies should not be used to store secure data because they can be sniffed
    or stolen by bad actors. In addition, cookies can store only 4 KB of data and
    can be set to expire.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 应当避免使用Cookies来存储安全数据，因为它们可以被恶意行为者嗅探或窃取。此外，Cookies只能存储4 KB的数据，并且可以被设置为过期。
- en: '`localStorage` and `sessionStorage` are similar to each other. They are protected
    and isolated browser-side stores that allow the storage of larger amounts of data
    for your application. Unlike cookies, you can''t set an expiration date-time on
    values stored in either store. Values stored in either store survive page reloads
    and restores, making them better candidates than cookies for caching information.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`localStorage`和`sessionStorage`彼此相似。它们是受保护和隔离的浏览器端存储，允许为您的应用程序存储更多的数据。与cookies不同，您不能为存储在任一存储中的值设置过期日期和时间。存储在任一存储中的值在页面重新加载和恢复时仍然存在，这使得它们比cookies更适合缓存信息。'
- en: The major difference between `localStorage` and `sessionStorage` is that the
    values are removed when the browser window is closed. In most cases, user logins
    are cached anywhere from minutes to a month or more depending on your business,
    so relying on whether the user closes the browser window isn't very useful. Through this
    process of elimination, I prefer `localStorage` because of the isolation it provides
    and long-term storage capabilities.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`localStorage`和`sessionStorage`之间的主要区别在于，当浏览器窗口关闭时，值会被移除。在大多数情况下，用户登录的缓存时间从几分钟到一个月或更长时间，具体取决于您的业务，因此依赖于用户是否关闭浏览器窗口并不是很有用。通过这个过程排除，我更喜欢`localStorage`，因为它提供了隔离性和长期存储能力。'
- en: JWTs can be encrypted and include a timestamp for expiration. In theory, this
    counters the weaknesses of both cookies and `localStorage`. If implemented correctly,
    either option should be secure for use with JWTs, but `localStorage` is still
    preferred.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: JWT可以被加密并包含一个过期时间戳。从理论上讲，这抵消了cookies和`localStorage`的弱点。如果正确实现，任一选项都应安全用于JWT，但`localStorage`仍然更受欢迎。
- en: 'Let''s start by implementing a caching service that can abstract away our method
    of caching. We can then derive from this service to cache our authentication information:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现一个可以抽象我们缓存方法的缓存服务开始。然后我们可以从这个服务派生出缓存我们的认证信息：
- en: 'Start by creating an abstract `cacheService` that encapsulates the method of caching:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个抽象的`cacheService`，它封装了缓存方法：
- en: '[PRE34]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This cache service base class can be used to give caching capabilities to any
    service. It is not the same as creating a centralized cache service that you inject
    into another service. By avoiding a centralized value store, we avoid interdependencies
    between various services.
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个缓存服务基类可以被用来给任何服务提供缓存能力。它不同于创建一个集中式缓存服务并将其注入到另一个服务中。通过避免集中式值存储，我们避免了各种服务之间的相互依赖。
- en: 'Update `AuthService` to extend the `CacheService`, which will enable us to
    implement caching of the JWT in the next section:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`AuthService`以扩展`CacheService`，这将使我们能够在下一节中实现JWT的缓存：
- en: '[PRE35]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that we must call the constructor of the base class from the derived class's
    constructor using the `super` method.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须使用`super`方法从派生类的构造函数中调用基类的构造函数。
- en: 'Let''s go over an example of how to use the base class''s functionality by
    caching the value of the `authStatus` object:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来了解如何通过缓存`authStatus`对象来使用基类的功能：
- en: '[PRE36]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The technique demonstrated in the example leverages RxJS observable streams
    to update the cache whenever the value of `authStatus$` changes. You can use this
    pattern to persist any kind of data without having to litter your business logic
    with caching code. In this case, we wouldn't need to update the `login` function
    to call `setItem`, because it already calls `this.authStatus.next`, and we can
    just tap into the data stream. This helps with staying stateless and avoiding
    side effects by decoupling functions from each other.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中展示的技术利用RxJS可观察流在`authStatus$`的值变化时更新缓存。您可以使用这种模式持久化任何类型的数据，而无需在业务逻辑中散布缓存代码。在这种情况下，我们不需要更新`login`函数来调用`setItem`，因为它已经调用了`this.authStatus.next`，我们只需接入数据流即可。这有助于保持无状态并避免副作用，通过解耦函数来实现。
- en: Note that we also initialize the `BehaviorSubject` using the `getItem` function.
    Using the nullish coalescing operator, we only use cached data if it is not `undefined`
    or `null`. Otherwise, we provide the default value.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还在`BehaviorSubject`中使用`getItem`函数进行初始化。使用空值合并运算符，我们只在缓存的数据不是`undefined`或`null`时使用它。否则，我们提供默认值。
- en: You can implement your own custom cache expiration scheme in the `setItem` and
    `getItem` functions, or leverage a service created by a third party.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`setItem`和`getItem`函数中实现自己的自定义缓存过期方案，或者利用第三方创建的服务。
- en: However, for an additional layer of security, we won't cache the `authStatus`
    object. Instead, we will only cache the encoded JWT, which contains just enough
    information, so we can authenticate requests sent to the server. It is important
    to understand how token-based authentication works to avoid revealing compromising
    secrets. Review the JWT life cycle from earlier in this chapter to improve your
    understanding.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了额外的安全层，我们不会缓存`authStatus`对象。相反，我们只缓存编码后的JWT，它只包含足够的信息，以便我们可以认证发送到服务器的请求。理解基于令牌的认证工作方式对于避免泄露有损的秘密非常重要。回顾本章早些时候的JWT生命周期，以提高你的理解。
- en: Next, let's cache the token.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们缓存令牌。
- en: Caching the JWT
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存JWT
- en: Let's update the authentication service so that it can cache the token.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新认证服务，使其能够缓存令牌。
- en: 'Update `AuthService` to be able to set, get, and clear the token, as shown:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`AuthService`以能够设置、获取和清除令牌，如下所示：
- en: '[PRE37]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Call `clearToken` and `setToken` during `login`, and `clearToken` during `logout`,
    as shown:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`login`期间调用`clearToken`和`setToken`，在`logout`期间调用`clearToken`，如下所示：
- en: '[PRE38]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Every subsequent request will contain the JWT in the request header. You should
    secure every API to check for and validate the token received. For example, if
    a user wants to access their profile, the `AuthService` will validate the token
    to check whether the user is authenticated or not; however, a further database
    call will still be required to check whether the user is also authorized to view
    the data. This ensures an independent confirmation of the user's access to the
    system and prevents any abuse of an unexpired token.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 每个后续请求都将包含请求头中的JWT。你应该确保每个API都检查和验证收到的令牌。例如，如果用户想要访问他们的个人资料，`AuthService`将验证令牌以检查用户是否已认证；然而，还需要进一步的数据库调用以检查用户是否有权查看数据。这确保了对用户系统访问的独立确认，并防止了对未过期令牌的滥用。
- en: If an authenticated user makes a call to an API where they don't have the proper
    authorization, say if a clerk wants to get access to a list of all users, then
    the `AuthService` will return a `falsy` status, and the client will receive a
    **403 Forbidden** response, which will be displayed as an error message to the
    user.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个认证用户调用他们没有适当授权的API，比如说如果一名职员想要获取所有用户的列表，那么`AuthService`将返回一个`falsy`状态，客户端将收到一个**403禁止**响应，这将被显示为错误消息给用户。
- en: A user can make a request with an expired token; when this happens, a **401
    Unauthorized** response is sent to the client. As a good UX practice, we should
    automatically prompt the user to log in again and let them resume their workflow
    without any data loss.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以使用过期的令牌进行请求；当这种情况发生时，客户端将收到一个**401未授权**响应。作为一个良好的用户体验实践，我们应该自动提示用户重新登录，并让他们在没有数据丢失的情况下继续他们的工作流程。
- en: In summary, true security is achieved with robust server-side implementation.
    Any client-side implementation is largely there to enable a good UX around good
    security practices.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，真正的安全是通过强大的服务器端实现来实现的。任何客户端实现主要是为了在良好的安全实践周围提供良好的用户体验。
- en: Implement an in-memory auth service
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现一个内存中的认证服务
- en: 'Now, let''s implement a concrete version of the auth service that we can actually
    use:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现一个具体的认证服务版本，我们可以实际使用：
- en: 'Start by installing a JWT decoding library and, for faking authentication,
    a JWT encoding library:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先安装JWT解码库，以及用于模拟认证的JWT编码库：
- en: '[PRE39]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Extend the abstract `AuthService`:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展抽象的`AuthService`：
- en: '[PRE40]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Implement a fake `authProvider` function that simulates the authentication
    process, including creating a fake JWT on the fly:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个模拟的`authProvider`函数，模拟认证过程，包括动态创建模拟JWT：
- en: '[PRE41]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `authProvider` implements what would otherwise be a server-side method right
    in the service, so we can conveniently experiment with the code while fine-tuning
    our auth workflow. The provider creates and signs a JWT with the temporary `fake-jwt-sign`
    library so that I can also demonstrate how to handle a properly formed JWT.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`authProvider`在服务中实现了原本应该在服务器端实现的方法，这样我们就可以方便地在微调认证工作流程的同时实验代码。提供者使用临时的`fake-jwt-sign`库创建并签名JWT，以便我可以演示如何处理正确形成的JWT。'
- en: Do not ship your Angular application with the `fake-jwt-sign` dependency, since
    it is meant to be server-side code.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要将Angular应用程序与`fake-jwt-sign`依赖项一起发货，因为它意味着是服务器端代码。
- en: 'In contrast, a real auth provider would include a `POST` call to a server.
    See the example code that follows:'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相比之下，一个真实的认证提供者会包括一个发送到服务器的`POST`调用。请参阅以下示例代码：
- en: '[PRE42]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It is pretty straightforward, since the hard work is done on the server side.
    This call can also be made to a third-party auth provider, which I cover in the
    Firebase authentication recipe later in this chapter.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这相当直接，因为困难的工作是在服务器端完成的。这个调用也可以发送到第三方认证提供者，我将在本章后面的Firebase认证食谱中介绍。
- en: Note that the API version, `v1`, in the URL path is defined at the service and
    not as part of the `baseUrl`. This is because each API can change versions independently.
    Login may remain `v1` for a long time, while other APIs may be upgraded to `v2`,
    `v3`, and so on.
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，URL路径中的API版本`v1`是在服务中定义的，而不是作为`baseUrl`的一部分。这是因为每个API可以独立更改版本。登录可能长时间保持为`v1`，而其他API可能升级到`v2`、`v3`等。
- en: 'Implementing `transformJwtToken` will be trivial, because the login function
    provides us with a token that adheres to `IAuthStatus`:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`transformJwtToken`将是微不足道的，因为登录函数为我们提供了一个符合`IAuthStatus`的令牌：
- en: '[PRE43]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, implement `getCurrentUser`, which should return some default user:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现`getCurrentUser`，它应该返回一个默认用户：
- en: '[PRE44]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Next, provide a `defaultUser` as a private property to the class; what follows
    is one that I've created.
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，将`defaultUser`作为私有属性提供给类；以下是我创建的一个示例。
- en: 'Add a private `defaultUser` property to the `InMemoryAuthService` class:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`InMemoryAuthService`类添加一个私有的`defaultUser`属性：
- en: '[PRE45]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Congratulations, you've implemented a concrete, but still fake, auth service.
    Now that you have the in-memory auth service in place, be sure to run your Angular
    application and ensure that there are no errors.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你已经实现了一个具体但仍然虚假的认证服务。现在你已经有了一个内存中的认证服务，请确保运行你的Angular应用程序，并确保没有错误。
- en: Let's test our auth service by implementing a simple login and logout functionality
    accessible through the UI.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过实现一个简单的登录和注销功能来测试我们的认证服务，该功能可以通过用户界面访问。
- en: Simple login
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单登录
- en: Before we implement a fully-featured `login` component, let's wire up pre-baked
    login behavior to the **Login as manager** button we have in the `HomeComponent`.
    We can test the behavior of our auth service before getting into the details of
    delivering a rich UI component.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现一个功能齐全的`login`组件之前，让我们将预制的登录行为连接到`HomeComponent`中的`登录为管理员**`按钮。在深入了解交付丰富UI组件的细节之前，我们可以测试我们的认证服务的功能。
- en: Our goal is to simulate logging in as a manager. To accomplish this, we need
    to hard code an e mail address and a password to log in, and upon successful login,
    maintain the functionality of navigating to the `/manager` route.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是模拟登录为管理员。为了实现这一点，我们需要硬编码一个电子邮件地址和密码来登录，并在成功登录后保持导航到`/manager`路由的功能。
- en: Note that on GitHub the code sample for this section resides in a file named
    `home.component.simple.ts` under the folder structure of `projects/ch8`. The alternate
    file exists for reference purposes only, since the code from this section dramatically
    changes later in the chapter. Ignore the file name difference, as it will not
    impact your coding for this section.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在GitHub上，本节代码示例位于`projects/ch8`文件夹结构下的`home.component.simple.ts`文件中。该备用文件仅用于参考目的，因为本章后面的代码将发生重大变化。忽略文件名差异，因为它不会影响本节代码的编写。
- en: 'Let''s implement a simple login mechanism:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个简单的登录机制：
- en: 'In the `HomeComponent`, implement a `login` function that uses the `AuthService`:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HomeComponent`中实现一个`login`函数，该函数使用`AuthService`：
- en: '[PRE46]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Update the template to remove the `routerLink` and instead call the `login`
    function:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新模板以移除`routerLink`，并调用`login`函数：
- en: '[PRE47]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: On successful login, we need to navigate to the `/manager` route. We can verify
    that we're successfully logged in by listening to the `authStatus$` and `currentUser$`
    observables exposed by the `AuthService`. If `authStatus$.isAuthenticated` is
    `true` and `currentUser$._id` is a non-empty string, that means that we have a
    valid login. We can listen to both observables by using RxJS's `combineLatest`
    operator. Given a valid login condition, we can then use the `filter` operator
    to reactively navigate to the `/manager` route.
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在成功登录后，我们需要导航到`/manager`路由。我们可以通过监听`AuthService`公开的`authStatus$`和`currentUser$`可观察对象来验证我们是否成功登录。如果`authStatus$.isAuthenticated`为`true`且`currentUser$._id`是一个非空字符串，这意味着我们有一个有效的登录。我们可以通过使用RxJS的`combineLatest`运算符来监听这两个可观察对象。在有效的登录条件下，然后我们可以使用`filter`运算符来响应式地导航到`/manager`路由。
- en: 'Update the `login()` function to implement the login conditional and upon success,
    navigate to the `/manager` route:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`login()`函数以实现登录条件和成功后导航到`/manager`路由：
- en: '[PRE48]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that we subscribe to the `combineLatest` operator at the end, which is
    critical in activating the observable streams. Otherwise, our login action will
    remain dormant unless some other component subscribes to the stream. You only
    need to activate a stream once.
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们订阅了`combineLatest`操作符，这在激活可观察流中是至关重要的。否则，除非其他组件订阅了流，否则我们的登录操作将保持休眠状态。您只需要激活一次流。
- en: Now test out the new `login` functionality. Verify that the JWT is created and
    stored in `localStorage` using the **Chrome DevTools| Application** tab, as shown
    here:![](img/B14094_08_04.png)
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在测试一下新的`登录`功能。验证JWT是否已创建并存储在`localStorage`中，如**Chrome DevTools|应用程序**选项卡中所示![img/B14094_08_04.png](img/B14094_08_04.png)
- en: 'Figure 8.4: DevTools showing Application Local Storage'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.4：DevTools显示应用程序本地存储
- en: You can view **Local Storage** under the **Application** tab. Make sure that
    the URL of your application is highlighted. In step 3, you can see that we have
    a key named `jwt` with a valid-looking token.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在**应用程序**选项卡下查看**本地存储**。确保您的应用程序的URL被突出显示。在第3步中，您可以看到我们有一个名为`jwt`的有效令牌。
- en: Note steps 4 and 5 highlighting two warnings, which advise us not to use the
    `InMemoryAuthService` and the `fake-jwt-sign` package in production code.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 注意步骤4和5中突出的两个警告，它们建议我们不要在生产代码中使用`InMemoryAuthService`和`fake-jwt-sign`包。
- en: Use breakpoints to debug and step through the code to get a more concrete understanding
    of how `HomeComponent`, `InMemoryAuthService`, and `AuthService` work together
    to log the user in.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用断点进行调试，并逐步执行代码，以更具体地了解`HomeComponent`、`InMemoryAuthService`和`AuthService`如何协同工作以登录用户。
- en: When you refresh the page, note that you're still logged in, because we're caching
    the token in local storage.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当您刷新页面时，请注意您仍然处于登录状态，因为我们已经在本地存储中缓存了令牌。
- en: Since we're caching the login status, we also need to implement a logout experience
    to complete the auth workflow.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在缓存登录状态，因此我们还需要实现一个注销体验来完成认证工作流程。
- en: Logout
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注销
- en: 'The logout button on the application toolbar is already wired up to navigate
    to the `logout` component we created before. Let''s update this component so it
    can log the user out when navigated to:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序工具栏上的注销按钮已经连接到我们之前创建的`注销`组件。让我们更新这个组件，以便在导航到时能够注销用户：
- en: 'Implement the `logout` component:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现注销组件：
- en: '[PRE49]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note that we are explicitly clearing the JWT by passing in `true` to the `logout`
    function. After we call `logout`, we navigate the user back to the home page.
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们通过将`true`传递给`注销`函数来显式清除JWT。在调用注销后，我们将用户导航回主页。
- en: Test out the `logout` button.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试一下`注销`按钮。
- en: Verify that local storage is cleared after logout.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证注销后本地存储是否已清除。
- en: We have nailed a solid login and logout implementation. However, we're not yet
    done with the fundamentals of our auth workflow.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了稳定的登录和注销。然而，我们还没有完成认证工作流程的基本内容。
- en: Next, we need to consider the expiration status of our JWT.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要考虑JWT的过期状态。
- en: Resuming a JWT session
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恢复JWT会话
- en: It wouldn't be a great UX if you had to log in to Gmail or Amazon every single
    time you visited the site. This is why we cache the JWT, but it would be an equally
    bad UX to keep you logged in forever. A JWT has an expiration date policy, where
    the provider can select a number of minutes or even months to allow your token
    to be valid for depending on security needs. The in-memory service creates tokens
    that expire in one hour, so if a user refreshes their browser window within that
    frame, we should honor the valid token and let the user continue using the application
    without asking them to log back in.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每次访问网站时都必须登录Gmail或Amazon，那么用户体验就不会很好。这就是我们为什么要缓存JWT的原因，但永远保持登录状态同样会带来糟糕的用户体验。JWT有一个过期日期策略，提供商可以选择几分钟甚至几个月的时间来允许您的令牌根据安全需求有效。内存中的服务创建的令牌在一小时内过期，所以如果用户在那一时间段内刷新浏览器窗口，我们应该尊重有效的令牌，并允许用户继续使用应用程序而无需要求他们重新登录。
- en: On the flip side, if the token is expired, we should automatically navigate
    the user to the login screen for a smooth UX.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果令牌已过期，我们应该自动将用户导航到登录屏幕，以实现流畅的用户体验。
- en: 'Let''s get started:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'Update the `AuthService` class to implement a function named `hasExpiredToken`
    to check whether the token is expired, and a helper function named `getAuthStatusFromToken`
    to decode the token, as shown:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`AuthService`类以实现一个名为`hasExpiredToken`的函数来检查令牌是否过期，以及一个名为`getAuthStatusFromToken`的辅助函数来解码令牌，如下所示：
- en: '[PRE50]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Keep your code DRY! Update the `login()` function to use `getAuthStatusFromToken()`
    instead.
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保持你的代码DRY！更新`login()`函数以使用`getAuthStatusFromToken()`。
- en: 'Update the constructor of `AuthService` to check the status of the token:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`AuthService`的构造函数以检查令牌的状态：
- en: '[PRE51]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If the token has expired, we log the user out and clear the token from `localStorage`.
    Otherwise, we decode the token and push the auth status to the data stream.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果令牌已过期，我们注销用户并从`localStorage`中清除令牌。否则，我们解码令牌并将认证状态推送到数据流。
- en: A corner case to consider here is to also trigger the reloading of the current
    user in the event of a resumption. We can do this by implementing a new pipe that
    reloads the current user if activated.
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里需要考虑的一个特殊情况是在恢复时也触发当前用户的重新加载。我们可以通过实现一个新的管道来实现，如果激活，则重新加载当前用户。
- en: 'First, let''s refactor the existing user update logic in the `login()` function
    to a private property named `getAndUpdateUserIfAuthenticated` so we can reuse
    it:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们将`login()`函数中现有的用户更新逻辑重构为一个名为`getAndUpdateUserIfAuthenticated`的私有属性，这样我们就可以重用它：
- en: '[PRE52]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In `AuthService`, define an observable property named `resumeCurrentUser$`
    as a fork of `authStatus$`, and use the `getAndUpdateUserIfAuthenticated` logic:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AuthService`中定义一个名为`resumeCurrentUser$`的可观察属性，作为`authStatus$`的分支，并使用`getAndUpdateUserIfAuthenticated`逻辑：
- en: '[PRE53]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Once `resumeCurrentUser$` is activated and `status.isAuthenticated` is `true`,
    then `this.getCurrentUser()` will be invoked and `currentUser$` will be updated.
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦`resumeCurrentUser$`被激活并且`status.isAuthenticated`为`true`，那么`this.getCurrentUser()`将被调用，并且`currentUser$`将被更新。
- en: 'Update the constructor of `AuthService` to activate the pipeline if the token
    is unexpired:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`AuthService`的构造函数以在令牌未过期时激活管道：
- en: '[PRE54]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Using the preceding technique, we can retrieve the latest user profile data
    without having to deal with caching issues.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的技术，我们可以检索最新的用户配置文件数据，而无需处理缓存问题。
- en: To experiment with token expiration, I recommend that you create a faster-expiring
    token in `InMemoryAuthService`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实验令牌过期，我建议你在`InMemoryAuthService`中创建一个更快过期的令牌。
- en: As demonstrated earlier in the caching section, it is possible to cache the
    user profile data using `this.setItem` and the profile data from cache on first
    launch. This would provide a faster UX and cover cases where users may be offline.
    After the application launches, you could then asynchronously fetch fresh user
    data and update `currentUser$` when new data comes in. You would need to add additional
    caching and tweak the `getCurrentUser()` logic to get such functionality working.
    Oh, and you would need a whole lot of testing! It takes a lot of testing to create
    a high-quality auth experience.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如在前面缓存部分所示，使用`this.setItem`和首次启动时的缓存配置文件数据，可以缓存用户配置文件数据。这将提供更快的用户体验，并覆盖用户可能离线的情况。在应用程序启动后，您可以异步获取新鲜的用户数据，并在新数据到来时更新`currentUser$`。您需要添加额外的缓存并调整`getCurrentUser()`逻辑以使此功能正常工作。哦，您还需要大量的测试！创建高质量的认证体验需要大量的测试。
- en: Congratulations, we're done implementing a robust auth workflow! Next, we need
    to integrate auth with Angular's HTTP client so we can attach the token to the
    HTTP header of every request.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，我们已经完成了健壮的认证工作流的实现！接下来，我们需要将认证与Angular的HTTP客户端集成，以便我们可以将令牌附加到每个请求的HTTP头部。
- en: HTTP interceptor
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP拦截器
- en: 'Implement an HTTP interceptor to inject the JWT into the header of every request
    sent to the user and gracefully handle authentication failures by asking the user
    to log back in:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个HTTP拦截器，将JWT注入到发送给用户的每个请求的头部，并通过要求用户重新登录来优雅地处理认证失败：
- en: 'Create an `AuthHttpInterceptor` under `auth`:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`auth`下创建一个`AuthHttpInterceptor`：
- en: '[PRE55]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note that `AuthService` is leveraged to retrieve the token, and the `redirectUrl`
    is set for the `login` component after a `401` error.
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`AuthService`被用来检索令牌，并且在`401`错误后为`login`组件设置了`redirectUrl`。
- en: 'Update `app.module.ts` to provide the interceptor:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`app.module.ts`以提供拦截器：
- en: '[PRE56]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Ensure that the interceptor is adding the token to requests. To do this, open
    the **Chrome DevTools | Network** tab, log in, and then refresh the page:![](img/B14094_08_05.png)
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保拦截器正在将令牌添加到请求中。为此，打开**Chrome DevTools | 网络**标签，登录，然后刷新页面:![](img/B14094_08_05.png)
- en: 'Figure 8.5: The request header for lemon.svg'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.5：lemon.svg的请求头
- en: In step **4**, you can now observe the interceptor in action. The request for
    the `lemon.svg` file has the bearer token in the request header.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤**4**中，你现在可以观察拦截器的动作。对`lemon.svg`文件的请求在请求头中包含bearer令牌。
- en: Now that we have our auth mechanisms in place, let's take advantage of all the
    supporting code we have written with dynamic UI components and a conditional navigation
    system for a role-based UX.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了认证机制，让我们利用我们编写的所有支持代码，包括动态UI组件和基于角色的UX的条件导航系统。
- en: Dynamic UI components and navigation
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态UI组件和导航
- en: '`AuthService` provides asynchronous auth status and user information, including
    a user''s name and role. We can use all this information to create a friendly
    and personalized experience for users. In this next section, we will implement
    the `LoginComponent` so that users can enter their username and password information
    and attempt a login.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthService`提供异步的认证状态和用户信息，包括用户的名字和角色。我们可以使用所有这些信息为用户创建一个友好且个性化的体验。在本节中，我们将实现`LoginComponent`，以便用户可以输入他们的用户名和密码信息并尝试登录。'
- en: Implementing the login component
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现登录组件
- en: The `login` component leverages the `AuthService` that we just created and implements
    validation errors using reactive forms.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`login`组件利用我们刚刚创建的`AuthService`并使用响应式表单实现验证错误。'
- en: Remember that in `app.module.ts` we provided `AuthService` using the class `InMemoryAuthService`.
    So, during run time, when `AuthService` is injected into the `login` component,
    the in-memory service will be the one in use.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在`app.module.ts`中，我们使用`InMemoryAuthService`类提供了`AuthService`。因此，在运行时，当`AuthService`被注入到`login`组件中时，将使用内存服务。
- en: The `login` component should be designed to be rendered independently of any
    other component, because during a routing event, if we discover that the user
    is not properly authenticated or authorized, we will navigate them to this component.
    We can capture this origination URL as a `redirectUrl` so that once a user logs
    in successfully, we can navigate them back to it.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`login`组件应该设计成独立于任何其他组件渲染，因为在路由事件期间，如果我们发现用户没有正确认证或授权，我们将导航他们到这个组件。我们可以捕获这个原始URL作为`redirectUrl`，这样一旦用户成功登录，我们就可以将他们导航回它。'
- en: 'Let''s begin:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始：
- en: Install the `SubSink` package.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`SubSink`包。
- en: Create a new component named `login` in the root of your application with inline
    styles.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序的根目录中创建一个名为`login`的新组件，并使用内联样式。
- en: 'Let''s start with implementing the routes to the `login` component:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从实现导航到`login`组件的路由开始：
- en: '[PRE57]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Remember that the `'**'` path must be the last one defined.
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，`'**'`路径必须是最后定义的。
- en: 'Using a similar `login` logic to the one we implemented in `HomeComponent`,
    now implement the `LoginComponent` with some styles:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与我们在`HomeComponent`中实现的类似`login`逻辑，现在实现带有一些样式的`LoginComponent`：
- en: Don't forget to import the requisite dependent modules into your Angular application
    for the upcoming steps. This is intentionally left as an exercise for you to locate
    and import the missing modules.
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要忘记为即将进行的步骤将所需的依赖模块导入到您的Angular应用程序中。这有意留作练习，让您找到并导入缺失的模块。
- en: '[PRE58]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We are using `SubSink` to manage our subscriptions. We ensure that we are logged
    out when `ngOnInit` is called. We build the reactive form in a standard manner.
    Finally, the `login` method calls `this.authService.login` to initiate the login
    process.
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用`SubSink`来管理我们的订阅。我们确保在调用`ngOnInit`时注销。我们以标准方式构建响应式表单。最后，`login`方法调用`this.authService.login`以启动登录过程。
- en: We listen to the `authStatus$` and `currentUser$` data streams simultaneously
    using `combineLatest`. Every time there's a change in each stream, our pipe gets
    executed. We filter out unsuccessful login attempts. As the result of a successful
    login attempt, we leverage the router to navigate an authenticated user to their
    profile. In the case of an error sent from the server via the service, we assign
    that error to `loginError`.
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用`combineLatest`同时监听`authStatus$`和`currentUser$`数据流。每当每个流中发生更改时，我们的管道都会执行。我们过滤掉不成功的登录尝试。成功的登录尝试的结果，我们利用路由将认证用户导航到其个人资料。如果服务从服务器发送错误，我们将该错误分配给`loginError`。
- en: 'Here''s an implementation for a login form to capture and validate a user''s
    `email` and `password`, and if there are any server errors, display them:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是一个用于捕获和验证用户`email`和`password`的登录表单的实现，如果存在任何服务器错误，将显示它们：
- en: Don't forget to import `ReactiveFormsModule` in `app.modules.ts`.
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要忘记在`app.modules.ts`中导入`ReactiveFormsModule`。
- en: '[PRE59]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The **Login** button is disabled until the email and password meet client site
    validation rules. Additionally, `<mat-form-field>` will only display one `mat-error`
    at a time, unless you create more space for more errors, so be sure to place your
    error conditions in the correct order.
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**登录**按钮在电子邮件和密码满足客户端验证规则之前是禁用的。此外，`<mat-form-field>`一次只会显示一个`mat-error`，除非您为更多错误创建更多空间，所以请确保将错误条件按正确顺序放置。'
- en: Once you're done implementing the `login` component, you can now update the
    home screen to conditionally display or hide the new component we created.
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现完`login`组件后，现在可以更新主屏幕以有条件地显示或隐藏我们创建的新组件。
- en: 'Update the `HomeComponent` to clean up the code we added previously, so we
    can display the `LoginComponent` when users land on the home page of the app:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`HomeComponent`以清理我们之前添加的代码，这样我们就可以在用户登录应用程序的主页时显示`LoginComponent`：
- en: '[PRE60]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Your application should look similar to this screenshot:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序应该看起来与这个截图相似：
- en: '![](img/B14094_08_06.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_08_06.png)'
- en: 'Figure 8.6: LemonMart with login'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：LemonMart登录界面
- en: There's still some work to be done in terms of implementing and showing/hiding
    the `sidenav` menu, profile, and logout icons given the user's authentication
    status.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用户的认证状态，在实现和显示/隐藏`sidenav`菜单、个人资料和注销图标方面还有一些工作要做。
- en: Conditional navigation
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件导航
- en: Conditional navigation is necessary for creating a frustration-free UX. By selectively
    showing the elements that the user has access to and hiding the ones they don't
    have access to, we allow the user to confidently navigate through the application.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 条件导航对于创建无烦恼的用户体验是必要的。通过选择性地显示用户可以访问的元素并隐藏他们无法访问的元素，我们使用户能够自信地导航应用程序。
- en: 'Let''s start by hiding the `login` component after a user logs in to the application:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在用户登录应用程序后隐藏`login`组件开始：
- en: 'On the `HomeComponent`, inject the `AuthService` into the constructor as a
    `public` variable:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HomeComponent`中，将`AuthService`注入到构造函数中作为`public`变量：
- en: '[PRE61]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Remove the local variable `displayLogin`, because we can directly tap into the
    auth status in the template using the `async` pipe.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除局部变量`displayLogin`，因为我们可以直接在模板中使用`async`管道访问认证状态。
- en: 'Implement a new template using the `ngIf; else` syntax, along with the `async`
    pipe, as shown here:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ngIf; else`语法和`async`管道实现一个新的模板，如下所示：
- en: '[PRE62]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Using the `async` pipe avoids errors like `Error: ExpressionChangedAfterItHasBeenCheckedError:
    Expression has changed after it was checked`. Whenever you see this error, stop
    using local variables and instead use the `async` pipe. It is the reactive thing
    to do!'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '使用`async`管道可以避免像`Error: ExpressionChangedAfterItHasBeenCheckedError: Expression
    has changed after it was checked`这样的错误。每当您看到这个错误时，请停止使用局部变量，而改用`async`管道。这是反应式编程的正确做法！'
- en: 'On the `AppComponent`, we will follow a similar pattern by injecting `AuthService`
    as a `public` variable:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppComponent`中，我们将通过将`AuthService`注入为`public`变量来遵循类似的模式：
- en: '[PRE63]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Update `mat-toolbar` in the template, so that we monitor both `authStatus$`
    and `currentUser$` using the `async` pipe:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板中更新`mat-toolbar`，以便我们使用`async`管道监控`authStatus$`和`currentUser$`：
- en: '[PRE64]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Use `*ngIf` to hide all buttons meant for logged-in users:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`*ngIf`隐藏所有针对已登录用户的按钮：
- en: '[PRE65]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, when a user is logged out, your toolbar should look all clean, with no
    buttons, as shown here:'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，当用户注销时，您的工具栏应该看起来非常干净，没有任何按钮，如下所示：
- en: '![](img/B14094_08_07.png)'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B14094_08_07.png)'
- en: 'Figure 8.7: The LemonMart toolbar before a user logs in'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.7：用户登录前的LemonMart工具栏
- en: 'We can also swap out the generic `account_circle` icon in the `profile` button
    if the user has a picture:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户有图片，我们还可以将“profile”按钮中的通用`account_circle`图标替换掉：
- en: '[PRE66]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We now have a highly functional toolbar that reacts to the auth status of the
    application and is additionally able to display information that belongs to the
    logged-in user.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个高度功能化的工具栏，它可以响应应用程序的认证状态，并且能够显示属于已登录用户的信息。
- en: Common validations for forms
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单的常见验证
- en: 'Before we move on, we need to refactor the validations for `LoginComponent`.
    As we implement more forms in *Chapter 11*, *Recipes – Reusability, Routing, and
    Caching*, you will realize that it gets tedious, fast, to repeatedly type out
    form validations in either template or reactive forms. Part of the allure of reactive
    forms is that they are driven by code, so we can easily extract the validations
    to a shared class, unit test, and reuse them, as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要重构`LoginComponent`的验证。当我们实现第11章中的更多表单，*食谱 - 可重用性、路由和缓存*时，您会发现反复在模板或响应式表单中键入表单验证很快就会变得很繁琐。响应式表单的吸引力之一是它们由代码驱动，因此我们可以轻松地将验证提取到一个共享类、单元测试中，并重用它们，如下所示：
- en: Create a `validations.ts` file under the `common` folder.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`common`文件夹下创建一个`validations.ts`文件。
- en: 'Implement email and password validations:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现电子邮件和密码验证：
- en: '[PRE67]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Depending on your password validation needs, you can use a `RegEx` pattern with
    the `Validations.pattern()` function to enforce password complexity rules or leverage
    the OWASP npm package, `owasp-password-strength-test`, to enable pass-phrases,
    as well as set more flexible password requirements. See the link to the OWASP
    authentication general guidelines in the *Further reading* section.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的密码验证需求，您可以使用`Validations.pattern()`函数配合`RegEx`模式来强制执行密码复杂度规则，或者利用OWASP npm包`owasp-password-strength-test`来启用密码短语，以及设置更灵活的密码要求。请参阅*进一步阅读*部分中OWASP认证通用指南的链接。
- en: 'Update the `login` component with the new validations:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新的验证更新`login`组件：
- en: '[PRE68]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Next, let's encapsulate some common UI behavior in an Angular service.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将一些常见的UI行为封装到一个Angular服务中。
- en: UI service
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UI服务
- en: As we start dealing with complicated workflows, such as the auth workflow, it
    is important to be able to programmatically display a toast notification for the
    user. In other cases, we may want to ask for a confirmation before executing a
    destructive action with a more intrusive pop-up notification.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始处理复杂的流程，如认证流程时，能够以编程方式向用户显示toast通知是很重要的。在其他情况下，我们可能希望在执行具有更侵入性弹出通知的破坏性操作之前请求确认。
- en: No matter what component library you use, it gets tedious to recode the same
    boilerplate just to display a quick notification. A UI service can neatly encapsulate
    a default implementation that can also be customized as needed.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用什么组件库，重复编写相同的样板代码来显示快速通知都会变得很繁琐。一个UI服务可以整洁地封装一个默认实现，同时也可以根据需要自定义。
- en: In the UI service, we will implement a `showToast` and a `showDialog` function
    that can trigger notifications or prompt users for a decision, in such a manner
    that we can use it within the code that implements our business logic.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在UI服务中，我们将实现一个`showToast`和一个`showDialog`函数，可以触发通知或提示用户做出决定，这样我们就可以在实现业务逻辑的代码中使用它。
- en: 'Let''s get started:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: Create a new service named `ui` under `common`.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`common`目录下创建一个名为`ui`的新服务。
- en: 'Implement a `showToast` function using `MatSnackBar`:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`MatSnackBar`实现`showToast`函数：
- en: Check out the documentation for `MatSnackBar` at [https://material.angular.io](https://material.angular.io).
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查看关于`MatSnackBar`的文档，链接为[https://material.angular.io](https://material.angular.io)。
- en: Don't forget to update `app.module.ts` and `material.module.ts` with the various
    dependencies as they are introduced.
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要忘记更新`app.module.ts`和`material.module.ts`，随着各种依赖项的引入，添加相应的依赖。
- en: '[PRE69]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: For a `showDialog` function using `MatDialog`, we must implement a basic `dialog`
    component.
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于使用`MatDialog`的`showDialog`函数，我们必须实现一个基本的`dialog`组件。
- en: Check out the documentation for `MatDialog` at [https://material.angular.io](https://material.angular.io).
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查看关于`MatDialog`的文档，链接为[https://material.angular.io](https://material.angular.io)。
- en: 'Add a new component named `simpleDialog` under the `common` folder provided
    in `app.module.ts` with inline templates and styling, skip testing, and a flat
    folder structure:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app.module.ts`提供的`common`文件夹下添加一个名为`simpleDialog`的新组件，包含内联模板和样式，跳过测试，并保持扁平的文件夹结构：
- en: '[PRE70]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Note that `SimpleDialogComponent` should not have an application selector like
    `selector: ''app-simple-dialog''` since we only plan to use it with `UiService`.
    Remove this property from your component.'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '注意，`SimpleDialogComponent`不应该有一个应用选择器，例如`selector: ''app-simple-dialog''`，因为我们只计划与`UiService`一起使用它。请从您的组件中移除此属性。'
- en: 'Then, implement a `showDialog` function using `MatDialog` to display the `SimpleDialogComponent`:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`MatDialog`实现`showDialog`函数来显示`SimpleDialogComponent`：
- en: '[PRE71]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`ShowDialog` returns an `Observable<boolean>`, so you can implement a follow-on
    action, depending on what selection the user makes. Clicking on **OK** will return
    `true`, and **Cancel** will return `false`.'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ShowDialog` 返回一个 `Observable<boolean>`，因此你可以根据用户所做的选择实现后续操作。点击 **OK** 将返回
    `true`，而 **Cancel** 将返回 `false`。'
- en: In `SimpleDialogComponent`, using `@Inject`, we're able to use all variables
    sent by `showDialog` to customize the content of the dialog.
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `SimpleDialogComponent` 中，使用 `@Inject`，我们可以使用 `showDialog` 发送的变量来自定义对话框的内容。
- en: 'In `app.module.ts`, declare `SimpleDialogComponent` as an `entry` component:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app.module.ts` 中，将 `SimpleDialogComponent` 声明为 `entry` 组件：
- en: '[PRE72]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note that with the Ivy rendering engine, `entryComponents` should be unnecessary
    and is deprecated in Angular 9\. However, at the time of publishing, it is still
    required to declare this component as an `entry` component.
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在 Ivy 渲染引擎中，`entryComponents` 应该是不必要的，并且在 Angular 9 中已被弃用。然而，在发布时，仍然需要将此组件声明为
    `entry` 组件。
- en: 'Update the `login()` function on the `LoginComponent` to display a toast message
    after login:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `LoginComponent` 中的 `login()` 函数，在登录后显示一个 toast 消息：
- en: '[PRE73]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now, a toast message will appear after a user logs in, as shown:'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，用户登录后会出现一个提示消息，如下所示：
- en: '![](img/B14094_08_08.png)'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B14094_08_08.png)'
- en: 'Figure 8.8: Material snackbar'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.8：Material snackbar
- en: The `snackBar` will either take up the full width of the screen or a portion,
    depending on the size of the browser.
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`snackBar` 将根据浏览器的大小，占据整个屏幕宽度或部分宽度。'
- en: 'Experiment with displaying a dialog instead:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试显示一个对话框代替：
- en: '[PRE74]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Now that you've verified that both `showToast` and `showDialog` work, which
    one do you prefer? My rule of thumb is that unless the user is about to take an
    irreversible action, you should choose toast messages over dialogs, so you don't
    interrupt the user's workflow.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经验证了 `showToast` 和 `showDialog` 都能正常工作，你更喜欢哪一个？我的经验法则是，除非用户即将采取不可逆的操作，否则你应该选择
    toast 消息而不是对话框，这样就不会打断用户的操作流程。
- en: Next, let's implement an application-wide side navigation experience as an alternative
    to the toolbar-based navigation we already have, so that users can switch between
    modules with ease.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实现一个全局的侧导航体验，作为我们已有的基于工具栏导航的替代方案，这样用户可以轻松地在模块之间切换。
- en: Side navigation
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 侧导航
- en: 'Enable mobile-first workflows and provide an easy navigation mechanism to quickly
    jump to the desired functionality. Using the authentication service, given a user''s
    current role, only display the links for features they can access. We will be
    implementing the side navigation mock-up as follows:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 启用以移动端优先的工作流程，并提供一个简单的导航机制，以便快速跳转到所需的功能。使用身份验证服务，根据用户的当前角色，仅显示他们可以访问的功能链接。我们将按照以下方式实现侧导航模拟：
- en: '![](img/B14094_08_09.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_08_09.png)'
- en: 'Figure 8.9: Side navigation mock-up'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9：侧导航模拟图
- en: 'Let''s implement the code for the side navigation as a separate component,
    so that it is easier to maintain:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个独立的组件来作为侧导航的代码，这样更容易维护：
- en: In the root of the application, create a component named `NavigationMenu` with
    inline templates and styles.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序的根目录下创建一个名为 `NavigationMenu` 的组件，带有内联模板和样式。
- en: The side navigation isn't technically required until after a user is logged
    in. However, in order to be able to launch the side navigation menu from the toolbar,
    we need to be able to trigger it from `AppComponent`. Since this component will
    be simple, we will eagerly load it. To do this lazily, Angular does have a Dynamic
    Component Loader pattern, which has a high implementation overhead that will only
    make sense if multi-hundred kilobyte savings are made.
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 侧导航在技术上不是必需的，直到用户登录后。然而，为了能够从 `AppComponent` 中触发侧导航菜单，我们需要能够从那里触发它。由于这个组件将是简单的，我们将急切地加载它。为了实现这一点，Angular
    确实有一个动态组件加载模式，它具有很高的实现开销，只有在节省了数百千字节的情况下才有意义。
- en: '`SideNav` will be triggered from the toolbar, and it comes with a `<mat-sidenav-container>`
    parent container that hosts the `SideNav` itself and the content of the application.
    So, we will need to render all application content by placing the `<router-outlet>`
    inside `<mat-sidenav-content>`.'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`SideNav` 将从工具栏触发，并附带一个 `<mat-sidenav-container>` 父容器，该容器本身托管 `SideNav` 以及应用程序的内容。因此，我们需要通过将
    `<router-outlet>` 放置在 `<mat-sidenav-content>` 中来渲染所有应用程序内容。'
- en: 'In `AppComponent`, define some styles that will ensure that the web application
    will expand to fill the entire page and remain properly scrollable for desktop
    and mobile scenarios:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppComponent`中定义一些样式，以确保Web应用将扩展以填充整个页面，并在桌面和移动场景中保持适当的可滚动性：
- en: '[PRE75]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Inject the `MediaObserver` service from Angular Flex Layout in `AppComponent`.
    Also, implement `OnInit` and `OnDestory`, initialize `SubSink`, and add a Boolean
    property named `opened`:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppComponent`中注入Angular Flex Layout的`MediaObserver`服务。同时实现`OnInit`和`OnDestroy`，初始化`SubSink`，并添加一个名为`opened`的布尔属性：
- en: '[PRE76]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: To automatically determine the open/closed status of the side navigation, we
    need to monitor the media observer and the auth status. When the user logs in,
    we would like to show the side navigation, and hide it when the user logs out.
    We can do this with settings `opened` to the value of `authStatus$.isAuthenticated`.
    However, if we only consider `isAuthenticated`, and the user is on a mobile device,
    we will create a less than ideal UX. Watching for the media observer's `mediaValue`,
    we can check to see whether the screen size is set to extra small, or `xs`; if
    so, we can keep the side navigation closed.
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了自动确定侧导航的打开/关闭状态，我们需要监控媒体观察器和认证状态。当用户登录时，我们希望显示侧导航，当用户注销时隐藏它。我们可以通过将`opened`设置为`authStatus$.isAuthenticated`的值来实现这一点。然而，如果我们只考虑`isAuthenticated`，并且用户在移动设备上，我们将创建一个不太理想的用户体验。通过监控媒体观察器的`mediaValue`，我们可以检查屏幕尺寸是否设置为超小，或`xs`；如果是这样，我们可以保持侧导航关闭。
- en: 'Update `ngOnInit` to implement the dynamic side navigation open/closed logic:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`ngOnInit`以实现动态侧导航打开/关闭逻辑：
- en: '[PRE77]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: By monitoring both the media and `authStatus$` streams, we can consider unauthenticated
    scenarios where the side navigation should not be opened even if there's enough
    screen space.
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过监控媒体和`authStatus$`流，我们可以考虑未经认证的场景，即使有足够的屏幕空间，侧导航也不应该打开。
- en: 'Update the template with a responsive `SideNav` that will slide over the content
    in mobile or push the content aside in desktop scenarios:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用响应式的`SideNav`更新模板，在移动场景中滑过内容，在桌面场景中将内容推到一边：
- en: '[PRE78]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The preceding template leverages the Angular Flex Layout media observer that
    was injected earlier for a responsive implementation.
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述模板利用了之前注入的Angular Flex Layout媒体观察器来实现响应式实现。
- en: You can use the `// prettier-ignore` directive above your template to prevent
    Prettier from breaking up your template into too many lines, which can hurt readability
    in certain conditions similar to this one.
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在模板上方使用`// prettier-ignore`指令来防止Prettier将你的模板拆分成太多行，这在某些条件下可能会损害可读性，类似于这种情况。
- en: We will implement navigational links in `NavigationMenuComponent`. The number
    of links in our application will likely grow over time and be subject to various
    role-based business rules. Therefore, if we were to implement these links in `app.component.ts`,
    we would risk that file getting too large. In addition, we don't want `app.component.ts`
    to change very often, since changes made there can impact the entire application.
    It is a good practice to implement the links in a separate component.
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在`NavigationMenuComponent`中实现导航链接。我们的应用程序中的链接数量可能会随着时间的推移而增长，并受到各种基于角色的业务规则的影响。因此，如果我们将这些链接实现为`app.component.ts`，我们可能会使该文件变得过大。此外，我们不希望`app.component.ts`经常更改，因为那里的更改可能会影响整个应用程序。在单独的组件中实现链接是一种良好的做法。
- en: 'Implement navigational links in `NavigationMenuComponent`:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NavigationMenuComponent`中实现导航链接：
- en: '[PRE79]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '`<mat-nav-list>` is functionally equivalent to `<mat-list>`, so you can use
    the documentation of `MatList` for layout purposes. Observe the `subheaders` for
    **Manager**, **Inventory**, and **Clerk** here:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '`<mat-nav-list>`在功能上等同于`<mat-list>`，因此你可以使用`MatList`的文档来布局。在此观察**经理**、**库存**和**职员**的`subheaders`：'
- en: '![](img/B14094_08_10.png)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_08_10.png)'
- en: 'Figure 8.10: The Manager dashboard showing Receipt Lookup on desktop'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10：显示桌面设备上收据查找的经理仪表板
- en: '`routerLinkActive="active-link"` highlights the selected **Receipts** route,
    as shown in the preceding screenshot.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '`routerLinkActive="active-link"`突出显示所选的**收据**路由，如前述截图所示。'
- en: 'Additionally, you can see the difference in appearance and behavior on mobile
    devices as follows:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以看到在移动设备上的外观和行为差异如下：
- en: '![](img/B14094_08_11.png)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_08_11.png)'
- en: 'Figure 8.11: The Manager dashboard showing Receipt Lookup on mobile'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：显示移动设备上收据查找的经理仪表板
- en: Next, let's implement role-based routing.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实现基于角色的路由。
- en: Role-based routing using guards
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用守卫实现基于角色的路由
- en: This is the most elemental and important part of your application. With lazy
    loading, we have ensured that only the bare minimum number of assets will be loaded
    to enable a user to log in.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您应用程序最基本和最重要的部分。通过懒加载，我们确保只加载最少的资源以使用户能够登录。
- en: Once a user logs in, they should be routed to the appropriate landing screen
    as per their user role, so they're not guessing how they need to use the application.
    For example, a cashier needs to only access the point of sale (POS) to check out
    customers, so they can automatically be routed to that screen.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户登录，他们应该根据用户角色被路由到适当的登录屏幕，这样他们就不会猜测如何使用应用程序。例如，收银员只需要访问销售点（POS）来结账客户，所以他们可以自动被路由到该屏幕。
- en: 'The following is a mock-up of the POS screen:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个POS屏幕的模拟图：
- en: '![](img/B14094_08_12.png)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_08_12.png)'
- en: 'Figure 8.12: A POS screen mock-up'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12：POS屏幕模拟图
- en: Let's ensure that users get routed to the appropriate page after logging in
    by updating the `LoginComponent`.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更新`LoginComponent`确保用户在登录后能够被路由到适当的页面。
- en: 'Update the `login` logic to route per role in the function named `homeRoutePerRole`:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`login`逻辑，在名为`homeRoutePerRole`的函数中按角色路由：
- en: '[PRE80]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Similarly, clerks and managers are routed to their landing screens to access
    the features they need to accomplish their tasks, as shown earlier. Since we have
    implemented a default manager role, the corresponding landing experience will
    be launched automatically. The other side of the coin is intentional and unintentional
    attempts to access routes that a user isn't meant to have access to. In the next
    section, you will learn about router guards that can help to check authentication
    and even load requisite data before the form is rendered.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，收银员和管理员会被路由到他们的登录屏幕以访问他们完成任务所需的功能，如前所述。由于我们已经实现了默认的管理员角色，相应的登录体验将自动启动。硬币的另一面是有意或无意尝试访问用户不应访问的路由。在下一节中，你将了解可以帮助检查认证甚至在表单渲染之前加载所需数据的路由守卫。
- en: Router guards
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由守卫
- en: Router guards enable the further decoupling and reuse of logic, and greater
    control over the component life cycle.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 路由守卫使逻辑的进一步解耦和重用成为可能，并提供了对组件生命周期的更多控制。
- en: 'Here are the four major guards you will most likely use:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是您最可能使用的四个主要守卫：
- en: '`CanActivate` and `CanActivateChild`: Used for checking auth access to a route'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CanActivate`和`CanActivateChild`：用于检查路由的认证访问'
- en: '`CanDeactivate`: Used to ask permission before navigating away from a route'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CanDeactivate`：用于在离开路由之前请求权限'
- en: '`Resolve`: Allows the pre-fetching of data from route parameters'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Resolve`：允许从路由参数预取数据'
- en: '`CanLoad`: Allows custom logic to execute before loading feature module assets'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CanLoad`: 允许在加载功能模块资源之前执行自定义逻辑'
- en: Refer to the following sections to discover how to leverage `CanActivate` and
    `CanLoad`. The `Resolve` guard will be covered in *Chapter 11*, *Recipes – Reusability,
    Routing, and Caching*.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下章节以了解如何利用`CanActivate`和`CanLoad`。`Resolve`守卫将在第11章*配方 - 可重用性、路由和缓存*中介绍。
- en: Auth guards
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证守卫
- en: Auth guards enable a good UX by allowing or disallowing accidental navigation
    to a feature module or a component before the module has loaded or before any
    improper data requests have been made to the server. For example, when a manager
    logs in, they're automatically routed to the `/manager/home` path. The browser
    will cache this URL, and it would be completely plausible for a clerk to accidentally
    navigate to the same URL. Angular doesn't know whether a particular route is accessible
    to a user or not and, without an `AuthGuard`, it will happily render the manager's
    home page and trigger server requests that will end up failing.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 认证守卫通过允许或禁止在模块加载之前或在进行任何不适当的数据请求之前意外导航到功能模块或组件，从而实现良好的用户体验。例如，当管理员登录时，他们会被自动路由到`/manager/home`路径。浏览器将缓存此URL，因此收银员意外导航到相同的URL是完全可能的。Angular不知道特定的路由是否对用户可访问，如果没有`AuthGuard`，它将愉快地渲染管理员的首页并触发会导致失败的服务器请求。
- en: Regardless of the robustness of your frontend implementation, every REST API
    you implement should be properly secured server-side.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您的前端实现多么健壮，您实现的每个REST API都应该在服务器端得到适当的保护。
- en: 'Let''s update the router so that `ProfileComponent` can''t be activated without
    an authenticated user and the `ManagerModule` won''t load unless a manager is
    logging in using an `AuthGuard`:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新路由器，以便在没有经过认证的用户激活`ProfileComponent`之前，`ManagerModule`不会加载，除非管理员使用`AuthGuard`登录：
- en: 'Implement an `AuthGuard` service:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个 `AuthGuard` 服务：
- en: '[PRE81]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Use the `CanLoad` guard to prevent the loading of a lazily loaded module, such
    as the manager''s module:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `CanLoad` 守卫来防止加载懒加载的模块，例如管理员的模块：
- en: '[PRE82]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: In this instance, when the `ManagerModule` is being loaded, `AuthGuard` will
    be activated during the `canLoad` event, and the `checkLogin` function will verify
    the authentication status of the user. If the guard returns `false`, the module
    will not be loaded. At this point, we don't have the metadata to check the role
    of the user.
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，当 `ManagerModule` 被加载时，`AuthGuard` 将在 `canLoad` 事件期间被激活，`checkLogin`
    函数将验证用户的认证状态。如果守卫返回 `false`，则模块将不会加载。此时，我们没有元数据来检查用户的角色。
- en: 'Use the `CanActivate` guard to prevent the activation of individual components,
    such as the user''s `profile`:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `CanActivate` 守卫来防止激活单个组件，例如用户的 `profile`：
- en: '[PRE83]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In the case of `user-routing.module.ts`, `AuthGuard` is activated during the
    `canActivate` event, and the `checkLogin` function controls where this route can
    be navigated to. Since the user is viewing their own profile, there's no need
    to check the user's role here.
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `user-routing.module.ts` 的情况下，`AuthGuard` 在 `canActivate` 事件期间被激活，`checkLogin`
    函数控制此路由可以导航到的位置。由于用户正在查看自己的个人资料，因此在这里不需要检查用户的角色。
- en: 'Use `CanActivate` or `CanActivateChild` with an `expectedRole` property to
    prevent the activation of components by other users, such as `ManagerHomeComponent`:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用具有 `expectedRole` 属性的 `CanActivate` 或 `CanActivateChild` 来防止其他用户激活组件，例如 `ManagerHomeComponent`：
- en: '[PRE84]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Inside `ManagerModule`, we can verify whether the user is authorized to access
    a particular route. We can do this by defining some metadata in the route definition,
    like `expectedRole`, which will be passed into the `checkLogin` function by the
    `canActivate` event. If a user is authenticated but their role doesn't match `Role.Manager`,
    `AuthGuard` will return `false` and the navigation will be prevented.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ManagerModule` 内部，我们可以验证用户是否有权访问特定的路由。我们可以通过在路由定义中定义一些元数据来实现，例如 `expectedRole`，它将通过
    `canActivate` 事件传递给 `checkLogin` 函数。如果用户已认证但角色不匹配 `Role.Manager`，`AuthGuard` 将返回
    `false` 并阻止导航。
- en: Next, we will go over some techniques to get our tests passing.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍一些使测试通过的技术。
- en: Auth service fake and common testing providers
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份验证服务模拟和通用测试提供者
- en: We need to provide mocked versions of services like `AuthService` or `UiService`
    using the `commonTestingProviders` function in `common.testing.ts`, using a pattern
    similar to `commonTestingModules`, which was mentioned in *Chapter 7*, *Creating
    a Router-First Line-of-Business App*. This way, we won't have to mock the same
    objects over and over again.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `common.testing.ts` 中使用 `commonTestingProviders` 函数提供类似 `commonTestingModules`
    中提到的模式的服务模拟，例如 `AuthService` 或 `UiService`。这样，我们就不必反复模拟相同的对象。
- en: 'Let''s create the spy objects using the `autoSpyObj` function from `angular-unit-test-helper`
    and go over some less obvious changes we need to implement to get our tests passing:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用来自 `angular-unit-test-helper` 的 `autoSpyObj` 函数创建间谍对象，并回顾一些不那么明显的更改，以使测试通过：
- en: 'Update `commonTestingProviders` in `common.testing.ts`:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `common.testing.ts` 中的 `commonTestingProviders`：
- en: '[PRE85]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Observe the fake being provided for the `MediaObserver` in `app.component.spec.ts`
    and update it to use `commonTestingModules`:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察在 `app.component.spec.ts` 中为 `MediaObserver` 提供的模拟，并将其更新为使用 `commonTestingModules`：
- en: '[PRE86]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: See how the `commonTestingProviders` array is being concatenated with fakes
    that are specific to `app.component.ts`; our new mocks should apply automatically.
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看看 `commonTestingProviders` 数组是如何与针对 `app.component.ts` 的特定模拟进行连接的；我们的新模拟应自动应用。
- en: 'Update the spec file for `LoginComponent` to leverage `commonTestingModules`
    and `commonTestingProviders`:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `LoginComponent` 的规范文件以利用 `commonTestingModules` 和 `commonTestingProviders`：
- en: '[PRE87]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Go ahead and apply this technique to all spec files that have a dependency on
    `AuthService` and `UiService`.
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此技术应用于所有依赖于 `AuthService` 和 `UiService` 的规范文件。
- en: 'The notable exception is services, as in `auth.service.spec.ts`, where you
    do *not* want to use a test double. Since `AuthService` is the class under test,
    make sure it is configured as follows:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值得注意的是，服务除外，例如在 `auth.service.spec.ts` 中，你不想使用测试替身。由于 `AuthService` 是被测试的类，请确保它按以下方式配置：
- en: '[PRE88]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Update `ui.service.spec.ts` with similar considerations.
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用类似的考虑更新 `ui.service.spec.ts`：
- en: Remember, don't move on until all your tests are passed!
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，不要继续前进，直到所有测试都通过！
- en: Firebase authentication recipe
  id: totrans-503
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Firebase 身份验证配方
- en: 'We can leverage our current authentication setup and integrate it with a real
    authentication service. For this section, you need a free Google and Firebase
    account. Firebase is Google''s comprehensive mobile development platform: [https://firebase.google.com](https://firebase.google.com).
    You can create a free account to host your application and leverage the Firebase
    authentication system.'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用当前的认证设置并将其与真实的认证服务集成。对于本节，你需要一个免费的 Google 和 Firebase 账户。Firebase 是 Google
    的综合移动开发平台：[https://firebase.google.com](https://firebase.google.com)。你可以创建一个免费账户来托管你的应用程序并利用
    Firebase 认证系统。
- en: The Firebase console, found at [https://console.firebase.google.com](https://console.firebase.google.com),
    allows you to manage users and send a password reset email without having to implement
    a backend for your application. Later on, you can leverage Firebase functions
    to implement APIs in a serverless manner.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase 控制台，位于 [https://console.firebase.google.com](https://console.firebase.google.com)，允许你管理用户并发送密码重置邮件，而无需为你的应用程序实现后端。稍后，你可以利用
    Firebase 函数以无服务器的方式实现 API。
- en: 'Start by adding your project to Firebase using the Firebase console:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用 Firebase 控制台将你的项目添加到 Firebase：
- en: '![](img/B14094_08_13.png)'
  id: totrans-507
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_08_13.png)'
- en: 'Figure 8.13: The Firebase console'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.13：Firebase 控制台
- en: Click on **Add project**
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **添加项目**
- en: Provide your project name
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供你的项目名称
- en: Enable Google Analytics for your project
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的项目启用 Google Analytics
- en: 'It helps to create a Google Analytics account before attempting this, but it
    should still work. Once your project is created, you should see your project dashboard:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试此操作之前创建一个 Google Analytics 账户可能会有所帮助，但它仍然可以工作。一旦你的项目创建完成，你应该能看到你的项目仪表板：
- en: '![](img/B14094_08_14.png)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_08_14.png)'
- en: 'Figure 8.14: The Firebase project overview'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.14：Firebase 项目概览
- en: On the left-hand side, marked with step **1**, you can see a menu of tools and
    services that you can add to your project. At the top, marked with step **2**,
    you can quickly jump between your projects. First, you need to add an application
    to your project.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，标记为步骤 **1**，你可以看到一个菜单，其中包含你可以添加到项目中的工具和服务。在顶部，标记为步骤 **2**，你可以快速在项目之间切换。首先，你需要向你的项目添加一个应用程序。
- en: Add an application
  id: totrans-516
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一个应用程序
- en: Your project can include multiple distributions of your application, like web,
    iOS, and Android versions. In this chapter, we're only interested in adding a
    web application.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 你的项目可以包含多个应用程序的发行版本，如网页、iOS 和 Android 版本。在本章中，我们只对添加一个网页应用程序感兴趣。
- en: 'Let''s get started:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: On your project dashboard, click on the web application button to add an application,
    which is marked with step **3** in *Figure 8.14*
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目仪表板上，点击网页应用程序按钮以添加一个应用程序，这在 *图 8.14* 中的步骤 **3** 有标记
- en: Provide an application nickname
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个应用程序昵称
- en: Select the option to set up **Firebase Hosting**
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择设置 **Firebase Hosting** 的选项
- en: Continue by hitting the **Register app** button
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击 **注册应用程序** 按钮继续
- en: Skip over the **Add Firebase SDK** section
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳过 **添加 Firebase SDK** 部分
- en: 'Install the Firebase CLI as instructed:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照说明安装 Firebase CLI：
- en: '[PRE89]'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Sign in:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录：
- en: '[PRE90]'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Make sure your current directory is your project's root folder.
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保你的当前目录是项目根文件夹。
- en: 'Initialize your project:'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化你的项目：
- en: '[PRE91]'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Select the **Hosting** option; don't worry, you can add more features later
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **托管** 选项；不用担心，你以后可以添加更多功能
- en: Select the project you created as the default, that is, **lemon-mart-007**
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你创建的项目作为默认项目，即 **lemon-mart-007**
- en: For the public directory enter `dist/lemon-mart` or the `outputPath` defined
    in your `angular.json` file
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于公共目录，输入 `dist/lemon-mart` 或你在 `angular.json` 文件中定义的 `outputPath`。
- en: Say **yes** to configure it as a single-page application.
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 说 **是** 以将其配置为单页应用程序。
- en: 'This will create two new files: `firebase.json` and `.firebaserc`.'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建两个新的文件：`firebase.json` 和 `.firebaserc`。
- en: 'Build your project for production:'
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为生产构建你的项目：
- en: '[PRE92]'
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: or
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE93]'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now you can deploy your Angular application by executing the following command:'
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以通过执行以下命令来部署你的 Angular 应用程序：
- en: '[PRE94]'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Your website should be available on a URL similar to [https://lemon-mart-007.firebaseapp.com](https://lemon-mart-007.firebaseapp.com),
    as shown in the terminal.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 你的网站应该可以在类似 [https://lemon-mart-007.firebaseapp.com](https://lemon-mart-007.firebaseapp.com)
    的 URL 上访问，如终端所示。
- en: Add the `.firebase` folder to `.gitignore` so you don't check in your cache
    files. The other two files, `firebase.json` and `.firebaserc`, are safe to commit.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `.firebase` 文件夹添加到 `.gitignore` 中，这样你就不需要提交你的缓存文件。其他两个文件，`firebase.json` 和
    `.firebaserc`，可以安全提交。
- en: Optionally, connect a custom domain name that you own to the account using the
    Firebase console.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，使用 Firebase 控制台将你拥有的自定义域名连接到账户。
- en: Configure authentication
  id: totrans-545
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置身份验证
- en: Now, let's configure authentication.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置身份验证。
- en: 'In the Firebase console:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firebase控制台中：
- en: Select **Authentication** from the side navigation:![](img/B14094_08_15.png)
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从侧边导航中选择**身份验证**：![图片](img/B14094_08_15.png)
- en: 'Figure 8.15: The Firebase Authentication page'
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.15：Firebase身份验证页面
- en: Select **Email/Password** as the provider
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**电子邮件/密码**作为提供者
- en: Enable it
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用它
- en: Do not enable the email link
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要启用电子邮件链接
- en: Save your configuration
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的配置
- en: 'You can now see the user management console:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以看到用户管理控制台：
- en: '![](img/B14094_08_16.png)'
  id: totrans-555
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_08_16.png)'
- en: 'Figure 8.16: The Firebase user management console'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16：Firebase用户管理控制台
- en: It is fairly straightforward and intuitive to operate, so I will leave the configuration
    of it as an exercise for you.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 它的操作相当直接且直观，所以我将把它留给你作为练习。
- en: Implement Firebase authentication
  id: totrans-558
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现Firebase身份验证
- en: 'Let''s start by adding Angular Fire, the official Firebase library for Angular,
    to our application:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向我们的应用程序添加Angular Fire开始，这是Angular的官方Firebase库：
- en: '[PRE95]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Follow Angular Fire's quickstart guide to finish setting up the library with
    your Angular project, which you can find linked from the readme file on GitHub
    at [https://github.com/angular/angularfire2](https://github.com/angular/angularfire2).
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 按照Angular Fire的快速入门指南完成设置库与你的Angular项目的配置，你可以从GitHub上的readme文件中找到链接，链接为[https://github.com/angular/angularfire2](https://github.com/angular/angularfire2)。
- en: Ensure Firebase modules are provided in `app.module.ts` as per the documentation.
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Firebase模块按照文档要求在`app.module.ts`中提供。
- en: Ensure your Firebase config object is in all your `environment.ts` files.
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的Firebase配置对象在所有的`environment.ts`文件中。
- en: 'Note that any information provided in `environment.ts` is public information.
    So, when you place your Firebase API key in this file, it will be publicly available.
    There''s a small chance that another developer could abuse your API key and run
    up your bill. To protect yourself from any such attack, check out this blog post
    by paachu: *How to secure your Firebase project even when your API key is publicly
    available* at [https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-available-a462a2a58843](https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-).'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在`environment.ts`文件中提供的任何信息都是公开信息。因此，当你将你的Firebase API密钥放在这个文件中时，它将是公开可用的。有很小的可能性，另一个开发者可能会滥用你的API密钥并增加你的账单。为了保护自己免受此类攻击，请查看paachu的这篇博客文章：*如何在API密钥公开可用的同时保护你的Firebase项目*，链接为[https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-available-a462a2a58843](https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-).
- en: 'Create a new `FirebaseAuthService`:'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`FirebaseAuthService`：
- en: '[PRE96]'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Rename the service file to `auth.firebase.service.ts`.
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将服务文件重命名为`auth.firebase.service.ts`。
- en: 'Be sure to remove `{ providedIn: ''root'' }`.'
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '一定要删除`{ providedIn: ''root'' }`。'
- en: 'Implement Firebase auth by extending the abstract auth service:'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过扩展抽象身份验证服务来实现Firebase身份验证：
- en: '[PRE97]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: As you can see, we only had to implement the delta between our already established
    authentication code and Firebase's authentication methods. We didn't have to duplicate
    any code and we even transformed a Firebase `user` object into our application's
    internal user object.
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，我们只需要实现我们已建立的认证代码和Firebase认证方法之间的差异。我们不需要复制任何代码，甚至将Firebase的`user`对象转换成了我们应用程序的内部用户对象。
- en: 'To use Firebase authentication instead of in-memory authentication, update
    the `AuthService` provider in `app.module.ts`:'
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用Firebase身份验证而不是内存身份验证，更新`app.module.ts`中的`AuthService`提供者：
- en: '[PRE98]'
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Once you've completed the steps, add a new user from the Firebase authentication
    console and you should be able to log in using real authentication.
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成步骤后，从Firebase身份验证控制台添加新用户，你应该能够使用真实身份验证登录。
- en: Always make sure that you're using HTTPS when transmitting any kind of **personally
    identifiable information** (**PII**) or sensitive information (like passwords)
    over the Internet. Otherwise, your information will get logged on third-party
    servers or captured by bad actors.
  id: totrans-575
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总是要确保在互联网上传输任何类型的**个人身份信息**（**PII**）或敏感信息（如密码）时使用HTTPS。否则，你的信息可能会被第三方服务器记录或被恶意行为者捕获。
- en: 'Once again, be sure to update your unit tests before moving on:'
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次确保在继续之前更新你的单元测试：
- en: '[PRE99]'
  id: totrans-577
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Stop! Remove the `fake-jwt-sign` package from your project before deploying
    a real authentication method.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 停止！在部署真实身份验证方法之前，从你的项目中移除`fake-jwt-sign`包。
- en: Congratulations, your application is integrated with Firebase! Next, let's cover
    service factories, which can help you to switch the providers of your abstract
    classes dynamically.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，你的应用程序已经集成了Firebase！接下来，让我们来了解服务工厂，它可以帮助你动态地切换抽象类的提供者。
- en: Providing a service using a factory
  id: totrans-580
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用工厂提供服务
- en: You can dynamically choose providers during load time, so instead of having
    to change code to switch between authentication methods, you can parametrize environment
    variables, so different kinds of builds can have different authentication methods.
    This is especially useful when writing automated UI tests against your application,
    where real authentication can be difficult, if not impossible, to deal with.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在加载时动态选择提供者，因此，你不必更改代码来在认证方法之间切换，你可以参数化环境变量，这样不同的构建可以有不同的认证方法。这在编写针对你的应用程序的自动化UI测试时特别有用，在测试中，真实的认证可能很难处理，甚至不可能处理。
- en: First, we will create an `enum` in `environment.ts` to help define our options,
    and then we will use that `enum` to choose an auth provider during our application's
    bootstrap process.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在`environment.ts`中创建一个`enum`来帮助我们定义我们的选项，然后我们将使用该`enum`在我们的应用程序的引导过程中选择一个认证提供者。
- en: 'Let''s get started:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'Create a new `enum` called `AuthMode`:'
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`AuthMode`的新`enum`：
- en: '[PRE100]'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Add an `authMode` property in `environment.ts`:'
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`environment.ts`中添加一个`authMode`属性：
- en: '[PRE101]'
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Create an `authFactory` function in a new file under `auth/auth.factory.ts`:'
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`auth/auth.factory.ts`的新文件中创建一个`authFactory`函数：
- en: '[PRE102]'
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Note that the factory has to import any dependent service.
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，工厂必须导入任何依赖的服务。
- en: 'Update the `AuthService` provider in `app.module.ts` to use the factory instead:'
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app.module.ts`中更新`AuthService`提供者以使用工厂：
- en: '[PRE103]'
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Note that you can remove imports of `InMemoryAuthService` and `FirebaseAuthService`
    from `AppModule`.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以从`AppModule`中移除`InMemoryAuthService`和`FirebaseAuthService`的导入。
- en: With this configuration in place, whenever you build your application for local
    development, you will be using the in-memory auth service and production (or prod)
    builds will use the Firebase auth service.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置就绪后，无论何时构建你的应用程序用于本地开发，你都将使用内存中的认证服务，而生产（或prod）构建将使用Firebase认证服务。
- en: Summary
  id: totrans-595
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You should now be familiar with how to create high-quality auth experiences.
    In this chapter, we defined a User object that we can hydrate from or serialize
    to JSON objects, applying object-oriented class design and TypeScript operators
    for safe data handling.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该熟悉了如何创建高质量的认证体验。在本章中，我们定义了一个用户对象，我们可以从中填充或序列化为JSON对象，应用面向对象类设计和TypeScript运算符以安全地处理数据。
- en: We leveraged OOP design principals, using inheritance and abstract classes to
    implement a base auth service that demonstrates the Open/Closed principle.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用面向对象设计原则，使用继承和抽象类来实现一个基类认证服务，展示了开放/封闭原则。
- en: We covered the fundamentals of token-based authentication and JWTs so that you
    don't leak any critical user information. You learned that caching and HTTP interceptors
    are necessary so that users don't have to input their login information with every
    request. Following that, we implemented two distinct auth providers, one in-memory
    and one with Firebase.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了基于令牌的认证和JWTs的基础知识，这样你就不会泄露任何关键用户信息。你了解到缓存和HTTP拦截器是必要的，这样用户就不必在每次请求时输入他们的登录信息。在此之后，我们实现了两个不同的认证提供者，一个是内存中的，另一个是Firebase。
- en: We then designed a great conditional navigation experience that you can use
    in your own applications by copying the base elements to your project and implementing
    your own auth provider. We created a reusable UI service so that you can conveniently
    inject alerts into the flow-control logic of your application.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设计了一个很好的条件导航体验，你可以通过将基本元素复制到你的项目中并实现你自己的认证提供者来在你的应用程序中使用。我们创建了一个可重用的UI服务，这样你就可以方便地将警报注入到应用程序的流程控制逻辑中。
- en: Finally, we covered router guards to prevent users from stumbling onto screens
    they are not authorized to use, and we reaffirmed the point that the real security
    of your application should be implemented on the server side. You saw how you
    can use a factory to dynamically provide different auth providers for different
    environments.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们涵盖了路由守卫，以防止用户误入未经授权使用的屏幕，并重申了你的应用程序的真实安全性应该在实际服务器端实现。你看到了如何使用工厂为不同的环境动态提供不同的认证提供者。
- en: 'In the next chapter, we will shift gears a bit and learn about containerization
    using Docker. Docker allows powerful workflows that can greatly improve development
    experiences, while allowing you to implement your server configuration as code,
    putting a final nail in the coffin of the developer''s favorite excuse when their
    software breaks: "But it works on my machine!"'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-602
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Salted Password Hashing - Doing it Right, Defuse Security*, 2019, [https://crackstation.net/hashing-security.htm](https://crackstation.net/hashing-security.htm).'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Object-oriented programming*, [https://en.wikipedia.org/wiki/Object-oriented_programming](https://en.wikipedia.org/wiki/Object-oriented_programming).'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*TypeScript Classes*, [https://www.typescriptlang.org/docs/handbook/classes.html](https://www.typescriptlang.org/docs/handbook/classes.html).'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*TypeScript Basic Types*, [https://www.typescriptlang.org/docs/handbook/basic-types.html](https://www.typescriptlang.org/docs/handbook/basic-types.html).'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*TypeScript Advanced Types*, [https://www.typescriptlang.org/docs/handbook/advanced-types.html](https://www.typescriptlang.org/docs/handbook/advanced-types.html).'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*TypeScript 3.7 Features*, [https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html).'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Angular NgIf Directive*, [https://angular.io/api/common/NgIf](https://angular.io/api/common/NgIf).'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Authentication General Guidelines*, [https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Authentication_Cheat_Sheet.md](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Authentication_Cheat_Sheet.md).'
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How to secure your Firebase project even when your API key is publicly available*,
    paachu, 2019, [https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-available-a462a2a58843](https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-available-a462a2a58843).'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  id: totrans-612
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Answer the following questions as best as you can to ensure that you've understood
    the key concepts from this chapter without Googling. Do you need help answering
    the questions? See *Appendix D*, *Self-Assessment Answers* online at [https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf)
    or visit [https://expertlysimple.io/angular-self-assessment](https://expertlysimple.io/angular-self-assessment).
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: What's in-transit and at-rest security?
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between authentication and authorization?
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain inheritance and polymorphism.
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an abstract class?
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an abstract method?
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain how the `AuthService` adheres to the Open/Closed principle.
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does JWT verify your identity?
  id: totrans-620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between RxJS's `combineLatest` and `merge` operators?
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a router guard?
  id: totrans-622
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does a service factory allow you to do?
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务工厂允许你做什么？
