<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Our Second Project - The Budgeting App</h1>
            </header>

            <article>
                
<p>Staying within a monthly budget is something that I've found difficult to do in the past. For our second project, we will build an app that keeps track of our budget by letting us set a goal for how much we'd like to spend in a month, and then lets us enter expenses into the application and categorize them under simple labels. At any point, we can go and look at how we're doing for the month and look at our previous months' results.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Planning our second app, <kbd>Expenses</kbd></li>
<li>Installing a popular vector icon library for React Native</li>
<li>Building a series of helper methods that will be used throughout our app</li>
<li>Creating a modal that lets us enter our expenses</li>
<li>Rendering a list for the current month, showing the month's progress</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Getting started</h1>
            </header>

            <article>
                
<p>Like always, let's begin by initializing a new React Native project using the following statement in our command line:</p>
<pre>
    <strong>react-native init Expenses</strong>
</pre>
<p>While the React Native CLI is doing its work in scaffolding our project, we should plan out the functionality of the app.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">App planning</h1>
            </header>

            <article>
                
<p>Once this app is complete, we would like for it to function in the following ways:</p>
<ul>
<li>Upon launching the app, if a budget for the month has not yet been set, it should ask the user to input their monthly goal and save it in <kbd>AsyncStorage</kbd>.</li>
<li>Once a budget for the month has been set, the user should be shown a screen that contains a button to add their expenses for the month.</li>
<li>Upon tapping on that button, the user should be shown a modal that allows them to input details for their expenses: the name, amount, date the purchase was made on, and an icon to categorize the item. The modal should allow the user to either cancel or save the entry that they make.</li>
<li>If the expense is saved, it should then be rendered in a list on the main screen that contains the button to add further expenses.</li>
<li>This list should also prominently display the user's set budget for the month along a progress indicator showing how close they are to hitting their budget.</li>
<li>The app should also contain a second tab, where the user can view their previous months' histories.</li>
<li>Users should be able to add expenses to any month and delete any expenses as well.</li>
</ul>
<p>For the first part of this project, we'll tackle the top half of the list.</p>
<p>Let's start by installing the vector icon library as we'll be using it in this app.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Installing vector icons</h1>
            </header>

            <article>
                
<p>One of the most popular vector icon packs for React Native is <kbd>react-native-vector-icons</kbd>. It includes a plethora of icons from different sources, including FontAwesome and Google's Material icons pack.</p>
<p>Installing this vector icons pack takes a couple of steps, but we'll start by pulling it down:</p>
<pre>
    <strong>npm install react-native-vector-icons --save</strong>
</pre>
<p>This is now installed as a module, but we still need to link it to our project so that this app knows where to look for the files. This is because not every app we build will utilize all the native capabilities of the iOS and Android platforms. Including all the binaries to support every imaginable native capability will increase the size of our applications; instead, any components that rely on native iOS and Android code will have to be manually linked to our application, thus giving our application access to those pieces of code.</p>
<p>The simple way to link this vector icon library is with the following command line:</p>
<pre>
    <strong>react-native link</strong>
</pre>
<p>The preceding command will automatically link libraries with native dependencies to your project.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Folder structure</h1>
            </header>

            <article>
                
<p>The following structure includes components that we will wind up building in this very chapter:</p>
<pre>
|Expenses <br/>|__app <br/>|____components <br/>|______AddExpenses <br/>|______AddExpensesModal <br/>|______CurrentMonthExpenses <br/>|______EnterBudget <br/>|______ExpandableCell <br/>|______ExpenseRow <br/>|____utils <br/>|______dateMethods.js <br/>|______storageMethods.js <br/>|____App.js <br/>|____styles.js <br/>|__ios <br/>|__index.ios.js 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Utilities</h1>
            </header>

            <article>
                
<p>The <kbd>utils</kbd> folder stores helper methods that we will be using in our application. The <kbd>dateMethods</kbd> deals with the different methods that we will use to get different parts of the date, while <kbd>storageMethods</kbd> handles access to <kbd>AsyncStorage</kbd>.</p>
<p>Our first bullet point from app planning says that upon launching the app, if a budget for this month has not yet been set, it should ask the user to input their monthly goal and save it into <kbd>AsyncStorage</kbd>.</p>
<p>Based on the preceding intent, we want to do the following things:</p>
<ul>
<li>Grab the current month and year</li>
<li>Retrieve the object storing our expenses in <kbd>AsyncStorage</kbd> and check the month and year to check whether a budget has been set</li>
<li>If it hasn't, then prompt the user to enter a budget for the month and save it into <kbd>AsyncStorage</kbd></li>
</ul>
<p>Let's create some helper methods that deal with the dates.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Date methods</h1>
            </header>

            <article>
                
<p>These are the things that the <kbd>dateMethods.js</kbd> file should contain:</p>
<ul>
<li>An object that maps the number of the month to its name</li>
<li>Four methods get different parts of the date. Each should accept an optional date object or create a new instance of the <kbd>Date</kbd> object if one is not passed in the following ones:
<ul>
<li><kbd>getYear</kbd>: This grabs the year number and returns a stringified form of it</li>
<li><kbd>getMonth</kbd>: This grabs the month number and returns a stringified form of it</li>
<li><kbd>getDay</kbd>: This grabs the day number and returns a stringified form of it</li>
<li><kbd>getMonthString</kbd>: This returns the name of the month using the object created previously</li>
</ul>
</li>
</ul>
<p>This is how my <kbd>dateMethods</kbd> file looks after completing the preceding bullet points. This is an object mapping month numbers to the stringified name of the month:</p>
<pre>
// Expenses/app/utils/dateMethods.js<br/><br/>const monthNames = { <br/>  1: 'January', <br/>  2: 'February', <br/>  3: 'March', <br/>  4: 'April', <br/>  5: 'May', <br/>  6: 'June', <br/>  7: 'July', <br/>  8: 'August', <br/>  9: 'September', <br/>  10: 'October', <br/>  11: 'November', <br/>  12: 'December' <br/>} 
</pre>
<p>The next one grabs the current year and returns it as a string:</p>
<pre>
export const getYear = (date) =&gt; { <br/>  date = date || new Date(); <br/>  return date.getFullYear().toString(); <br/>}
</pre>
<p>This one gets the current month which is zero-indexed and returns which number it is:</p>
<pre>
export const getMonth = (date) =&gt; { <br/>  date = date || new Date(); <br/>  const zeroIndexedMonth = date.getMonth(); <br/>  return (zeroIndexedMonth + 1).toString(); <br/>}
</pre>
<p>The following one gets the day and returns it as a string:</p>
<pre>
export const getDay = (date) =&gt; { <br/>  date = date || new Date(); <br/>  return date.getDate().toString(); <br/>}
</pre>
<p>This one returns the name of the month, given its number:</p>
<pre>
export const getMonthString = (monthInt) =&gt; { <br/>  if (typeof monthInt === 'string') { <br/>    monthInt = parseInt(monthInt); <br/>  } <br/> <br/>  return monthNames[monthInt]; <br/>} 
</pre>
<p>Now, it is time to create some methods to access <kbd>AsyncStorage</kbd>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Storage methods</h1>
            </header>

            <article>
                
<p>The <kbd>listOfExpenses</kbd> we will store in our application will be a multi-layered object.</p>
<p class="NormalPACKT">Visually, we will build it to look like this:</p>
<pre>
listOfExpenses = { <br/>  2017: { <br/>    01: { <br/>      budget: 500, <br/>      expenses: [ <br/>        { <br/>          amount: '4', <br/>          category: 'Coffee', <br/>          date: 'Jan 12, 2017' <br/>          description: 'Latte @ Coffeeshop' <br/>        }, <br/>        { <br/>          amount: '1.50', <br/>          category: 'Books', <br/>          date: 'Jan 17, 2017' <br/>          description: 'Sunday Newspaper' <br/>        } <br/>      ] <br/>    } <br/>  } <br/>} 
</pre>
<p>The methods we want to create for storage involve the following things:</p>
<ul>
<li><kbd>getAsyncStorage</kbd>: This retrieves the list of expenses in <kbd>AsyncStorage</kbd></li>
<li><kbd>setAsyncStorage</kbd>: This accepts an object and saves it into <kbd>AsyncStorage</kbd> as the list of expenses</li>
<li><kbd>checkCurrentMonth</kbd>: This lets us accept a month and year as stringified numbers and finds out whether a budget has been set for that given month and year, returning <kbd>false</kbd> if it has not, and the budget, if it has been set</li>
<li><kbd>saveMonthlyBudget</kbd>: This accepts a month and year as stringified numbers and a budget as a number, then creates that <kbd>month</kbd> object and stores it in the right year in our list of expenses, saving it to <kbd>AsyncStorage</kbd> at the end</li>
<li><kbd>saveExpenseToMonth</kbd>: This accepts a month and year as stringified numbers and a single <kbd>expense</kbd> object, then saves that to the budget for that month and year</li>
<li><kbd>resetAsyncStorage</kbd>: This is a development-specific method that will erase the data in <kbd>AsyncStorage</kbd> so that we can clear our list whenever we need to</li>
<li><kbd>logAsyncStorage</kbd>: This is another development-specific method to log the object currently stored in <kbd>AsyncStorage</kbd> so that we can view it whenever needed</li>
</ul>
<p>Import the <kbd>AsyncStorage</kbd> API from React Native and the <kbd>dateMethods</kbd> utility file:</p>
<pre>
// Expenses/app/utils/storageMethods.js<br/><br/>import { AsyncStorage } from 'react-native'; <br/> <br/>import * as dateMethods from './dateMethods';
</pre>
<p>Grab the object in storage under the key <kbd>expenses</kbd> and return it:</p>
<pre>
 export const getAsyncStorage = async () =&gt; { <br/>  let response = await AsyncStorage.getItem('expenses'); <br/>  let parsedData = JSON.parse(response) || {}; <br/> <br/>  return parsedData; <br/>}
</pre>
<p>Override the <kbd>expenses</kbd> object in storage with the object passed in as an argument:</p>
<pre>
 export const setAsyncStorage = (expenses) =&gt; { <br/>  return AsyncStorage.setItem('expenses', JSON.stringify(expenses)); <br/>}
</pre>
<p>Grab the <kbd>month</kbd> and <kbd>year</kbd> from <kbd>dateMethods</kbd>, then grab the <kbd>expenses</kbd> object in storage. If that object does not exist or does not have any data for the given <kbd>year</kbd> and/or <kbd>month</kbd>, return <kbd>false</kbd>, otherwise return the <kbd>budget</kbd>:</p>
<pre>
export const checkCurrentMonthBudget = async () =&gt; {<br/>  let year = dateMethods.getYear();<br/>  let month = dateMethods.getMonth();<br/><br/>  let response = await getAsyncStorage();<br/><br/>  if (response === null || !response.hasOwnProperty(year) || <br/>  !response[year].hasOwnProperty(month)) {<br/>    return false;<br/>  }<br/><br/>  return response[year][month].budget;<br/>}
</pre>
<p>In <kbd>saveMonthlyBudget</kbd>, we grab the <kbd>expenses</kbd> object, then we check to see whether the result exists; this is so that we can seed <kbd>AsyncStorage</kbd> with a default empty object if we need to, which is important for a new user who hasn't entered data into the app before:</p>
<pre>
 export const saveMonthlyBudget = async (month, year, budget) =&gt; { <br/>  let response = await getAsyncStorage(); <br/> <br/>  if (!response.hasOwnProperty(year)) { <br/>    response[year] = {}; <br/>  } <br/> <br/>  if (!response[year].hasOwnProperty(month)) { <br/>    response[year][month] = { <br/>      budget: undefined, <br/>      expenses: [], <br/>      spent: 0 <br/>    } <br/>  } <br/> <br/>  response[year][month].budget = budget; <br/> <br/>  await setAsyncStorage(response); <br/> <br/>  return; <br/>} 
</pre>
<p>We also make checks along the way to see whether our <kbd>expenses</kbd> object has an object pertaining to the specific year passed to it, and then whether that <kbd>year</kbd> object has an object pointing to the specific <kbd>month</kbd> we're pointing to; if not, we create it. After setting up the <kbd>month</kbd> object with an entered <kbd>budget</kbd>, <kbd>expenses</kbd> array, and amount already <kbd>spent</kbd> (number defaulting to zero), we save it right back to <kbd>AsyncStorage</kbd>.</p>
<p>The following code calls <kbd>setAsyncStorage</kbd> and passes it an empty object, erasing the <kbd>expenses</kbd> object:</p>
<pre>
export const resetAsyncStorage = () =&gt; { <br/>  return setAsyncStorage({}); <br/>}
</pre>
<p>Grab the <kbd>expenses</kbd> object in storage and log it to the console:</p>
<pre>
export const logAsyncStorage = async () =&gt; { <br/>  let response = await getAsyncStorage(); <br/> <br/>  console.log('Logging Async Storage'); <br/>  console.table(response); <br/>}
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">App.js and index.ios.js</h1>
            </header>

            <article>
                
<p><kbd>App.js</kbd> will serve as the initial route for our app's navigation. It will handle the logic that decides whether to show the current month's expenses or a prompt to enter a budget for the month.</p>
<p>The root <kbd>index.ios.js</kbd> file will be modified in the same way as we structured it in the first project of this book, <kbd>Tasks</kbd>:</p>
<pre>
// Expenses/index.ios.js <br/><br/>import React, { Component } from 'react'; <br/>import { <br/>  AppRegistry, <br/>  NavigatorIOS, <br/>  StyleSheet <br/>} from 'react-native'; <br/> <br/>import App from './app/App'; <br/> <br/>export default class Expenses extends Component { <br/>  render() { <br/>    return ( <br/>      &lt;NavigatorIOS <br/>        initialRoute={{ <br/>          component: App, <br/>          title: 'Expenses' <br/>        }} <br/>        style={ styles.container } <br/>      /&gt; <br/>    ); <br/>  } <br/>} <br/> <br/>const styles = StyleSheet.create({ <br/>  container: { <br/>    flex: 1, <br/>  } <br/>}); <br/> <br/>AppRegistry.registerComponent('Expenses', () =&gt; Expenses); <br/> 
</pre>
<p>Now, let's create the <kbd>App.js</kbd> file and have it do the following things during its <kbd>componentDidMount</kbd> lifecycle:</p>
<ul>
<li>On load, we should use our <kbd>storageMethods</kbd> file to find out whether a budget has been set for the current month:
<ul>
<li>If the budget for the current month has been set, we should render it on the screen using a <kbd>Text</kbd> component for the user to see</li>
<li>If it has not been set, let's throw a basic alert stating the same for the user to see</li>
</ul>
</li>
</ul>
<p>This is how i built the <kbd>App</kbd> component:</p>
<pre>
// Expenses/app/App.js<br/><br/>import React, { Component } from 'react'; <br/><br/>import styles from './styles'; <br/> <br/>import { <br/>  Text, <br/>  View <br/>} from 'react-native'; <br/> <br/>import * as storageMethods from './utils/storageMethods'; <br/> <br/>export default class App extends Component { <br/>  constructor (props) { <br/>    super (); <br/> <br/>    this.state = { <br/>      budget: undefined <br/>    } <br/>  }
</pre>
<p>Check the current month’s budget and set it in state. If there is no budget, alert the user:</p>
<pre>
async componentWillMount () { <br/>    let response = await storageMethods.checkCurrentMonthBudget(); <br/> <br/>    if (response !== false) { <br/>      this.setState({ <br/>        budget: response <br/>      }); <br/> <br/>      return; <br/>    } <br/> <br/>    alert('You have not set a budget for this month!'); <br/>  } 
</pre>
<p>Render a <kbd>Text</kbd> element that states the current month’s budget, if set:</p>
<pre>
  render () { <br/>    return ( <br/>      &lt;View style={ styles.appContainer }&gt; <br/>        &lt;Text&gt; <br/>          Your budget is { this.state.budget || 'not set' }! <br/>        &lt;/Text&gt; <br/>      &lt;/View&gt; <br/>    ) <br/>  } <br/>} 
</pre>
<p>The <kbd>marginTop</kbd> property offsets the height of the navigation bar:</p>
<pre>
// Expenses/app/styles.js<br/><br/>import { Navigator, StyleSheet } from 'react-native';<br/><br/>const styles = StyleSheet.create({ <br/>  appContainer: { <br/>    flex: 1, <br/>    marginTop: Navigator.NavigationBar.Styles.General.TotalNavHeight<br/>  }<br/>}); <br/><br/>export default styles;
</pre>
<p>Next, let’s create a component that will let the user know their budget for the month.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">The EnterBudget component</h1>
            </header>

            <article>
                
<p>The component to enter a budget should do the following things:</p>
<ul>
<li>Prompt the user to enter their budget for the month with a numerical input</li>
<li>Include a button that lets them save the budget. When saved, we will do the following things:
<ul>
<li>Have the parent <kbd>App.js</kbd> component use <kbd>saveMonthlyBudget</kbd>, created in our <kbd>storageMethods</kbd> file, to save the entered budget</li>
<li>Update the parent <kbd>App.js</kbd> component to reflect the entered budget</li>
<li>Pop out of the <kbd>EnterBudget</kbd> component and go back to the <kbd>App.js</kbd> component</li>
</ul>
</li>
</ul>
<p>We should also modify the <kbd>App.js</kbd> component so that it does the following things:</p>
<ul>
<li>Pushes the <kbd>EnterBudget</kbd> component to the navigator in the event that a budget has not been set. This should replace the current call to alert the user that they have not yet set a budget. This component should not contain a back button so that the user is required to enter a budget for the month.</li>
<li>Passes the name of the current month in string form to the <kbd>EnterBudget</kbd> component.</li>
<li>Stores the current month and year in numerical form in its local state so that it can refer to them when required</li>
<li>Contains a method that updates itself with the new budget once the user saves a number in the <kbd>EnterBudget</kbd> component. This should be in the form of a prop passed into it.</li>
</ul>
<p>Like always, spend some time building out this component yourself. When you're finished, keep reading and check out the solution I came up with.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">EnterBudget component example</h1>
            </header>

            <article>
                
<p>Building and linking this component involved changing the <kbd>App.js</kbd> file. Let's take a look at that one first since it passes props down to the <kbd>EnterBudget</kbd> component:</p>
<pre>
// Expenses/app/App.js<br/><br/>... <br/>import EnterBudget from './components/EnterBudget'; <br/> <br/>export default class App extends Component { <br/>  ...
</pre>
<p>Set the <kbd>month</kbd> and <kbd>year</kbd> in state, then call <kbd>_updateBudget</kbd>:</p>
<pre>
  componentWillMount () { <br/>    this.setState({ <br/>      month: dateMethods.getMonth(), <br/>      year: dateMethods.getYear() <br/>    }); <br/> <br/>    this._updateBudget(); <br/>  }
</pre>
<p>Push <kbd>EnterBudget</kbd> to the navigator and pass it two props. Hide the navigation bar so that the user cannot leave without entering a budget for the month:</p>
<pre>
  ... <br/>  _renderEnterBudgetComponent () { <br/>    this.props.navigator.push({ <br/>      component: EnterBudget, <br/>      navigationBarHidden: true, <br/>      passProps: { <br/>        monthString: dateMethods.getMonthString( this.state.month), <br/>        saveAndUpdateBudget: (budget) =&gt; <br/>        this._saveAndUpdateBudget(budget) <br/>      } <br/>    }); <br/>  } 
</pre>
<p>Save the budget into storage. The argument is passed from the <kbd>EnterBudget</kbd> component:</p>
<pre>
  async _saveAndUpdateBudget (budget) { <br/>    await storageMethods.saveMonthlyBudget(this.state.month, <br/>    this.state.year, budget); <br/> <br/>    this._updateBudget(); <br/>  }
</pre>
<p>Previously found in <kbd>componentWillMount</kbd>, set the <kbd>budget</kbd> in state if it exists and render <kbd>EnterBudget</kbd> if it does not:</p>
<pre>
   async _updateBudget () { <br/>    let response = await storageMethods.checkCurrentMonthBudget(); <br/> <br/>    if (response !== false) { <br/>      this.setState({ <br/>        budget: response <br/>      }); <br/> <br/>      return; <br/>    } <br/> <br/>    this._renderEnterBudgetComponent(); <br/>  } <br/>} 
</pre>
<p>Next, let's take a look at the new <kbd>EnterBudget</kbd> component.</p>
<pre>
// Expenses/app/components/EnterBudget/index.js <br/><br/>import React, { Component, PropTypes } from 'react'; <br/> <br/>import { <br/>  Text, <br/>  TextInput, <br/>  Button, <br/>  View <br/>} from 'react-native'; <br/> <br/>import styles from './styles'; <br/> <br/>import * as dateMethods from '../../utils/dateMethods'; <br/> <br/>export default class EnterBudget extends Component { 
</pre>
<p>Explicitly define the <kbd>props</kbd> this component expects:</p>
<pre>
  static propTypes = { <br/>    monthString: PropTypes.string.isRequired, <br/>    saveAndUpdateBudget: PropTypes.func.isRequired <br/>  }
</pre>
<pre>
   constructor (props) { <br/>    super(props); <br/> <br/>    this.state = { <br/>      budget: undefined <br/>    } <br/>  } 
</pre>
<p>Store the value of the <kbd>TextInput</kbd> field in state. Prompt the user to enter their budget for the month with a numeric <kbd>TextInput</kbd>:</p>
<pre>
  render () { <br/>    let month = dateMethods.getMonthString(dateMethods.getMonth()); <br/> <br/>    return ( <br/>      &lt;View style={ styles.enterBudgetContainer }&gt; <br/>        &lt;Text style={ styles.enterBudgetHeader }&gt; <br/>          Enter Your { this.props.monthString } Budget <br/>        &lt;/Text&gt; <br/>        &lt;Text style={ styles.enterBudgetText }&gt; <br/>          What's your spending goal? <br/>        &lt;/Text&gt; <br/>        &lt;TextInput <br/>          style={ styles.textInput } <br/>          onChangeText={ (budget) =&gt; this._setBudgetValue(budget) } <br/>          value={ this.state.budget } <br/>          placeholder={ '0' } <br/>          keyboardType={ 'numeric' } <br/>        /&gt;
</pre>
<p>The <kbd>Button</kbd> calls <kbd>_saveAndUpdateBudget</kbd> on press and is disabled if <kbd>TextInput</kbd> is empty:</p>
<pre>
        &lt;View&gt; <br/>          &lt;Button <br/>            color={ '#3D4A53' } <br/>            disabled={ !this.state.budget } <br/>            onPress={ () =&gt; this._saveAndUpdateBudget() } <br/>            title={ 'Save Budget' } <br/>          /&gt; <br/>        &lt;/View&gt; <br/>      &lt;/View&gt; <br/>    ) <br/>  } 
</pre>
<p>The following code calls <kbd>saveAndUpdateBudget</kbd> from the <kbd>App</kbd> component and <kbd>pop</kbd> on the navigator:</p>
<pre>
  _saveAndUpdateBudget () { <br/>    this.props.saveAndUpdateBudget(this.state.budget); <br/>    this.props.navigator.pop(); <br/>  }
</pre>
<p>Finally, <kbd>_setBudgetValue</kbd> sets the value of the <kbd>TextInput</kbd>:</p>
<pre>
  _setBudgetValue (budget) { <br/>    this.setState({ <br/>      budget <br/>    }); <br/>  } <br/>} 
</pre>
<p>This component also received some styling shown as follows:</p>
<pre>
// Expenses/app/components/EnterBudget/styles.js <br/><br/>import { Navigator, StyleSheet } from 'react-native'; <br/> <br/>const styles = StyleSheet.create({
</pre>
<p>Like in the previous containers, we import <kbd>Navigator</kbd> so that we can offset the top margin by its <kbd>height</kbd>:</p>
<pre>
enterBudgetContainer: { <br/>    flex: 1, <br/>    marginTop: Navigator.NavigationBar.Styles.General.TotalNavHeight <br/>  }, 
</pre>
<p>Styling for the header, text, and input field in <kbd>EnterBudget</kbd> are as follows:</p>
<pre>
  enterBudgetHeader: { <br/>    color: '#3D4A53', <br/>    fontSize: 24, <br/>    margin: 10, <br/>    textAlign: 'center' <br/>  }, <br/>  enterBudgetText: { <br/>    color: '#3D4A53', <br/>    fontSize: 16, <br/>    margin: 10, <br/>    textAlign: 'center' <br/>  }, <br/>  textInput: { <br/>    height: 40, <br/>    borderColor: '#86B2CA', <br/>    borderWidth: 1, <br/>    color: '#3D4A53', <br/>    margin: 10, <br/>    padding: 10, <br/>    textAlign: 'center' <br/>  } <br/>}); <br/> <br/>export default styles; <br/> 
</pre>
<p>By the end of this section, you should have an <kbd>EnterBudget</kbd> component that looks like this:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1436 image-border" height="329" src="assets/image_03_001.png" width="197"/></div>
<p>Great job! In the next section, let’s style <kbd>App.js</kbd> and add a button to open a modal.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">The AddExpenses container and modal</h1>
            </header>

            <article>
                
<p>When planning this app, I wrote that once a budget for the month has been set, the user should be shown a screen that contains a button to add their expenses for the month.</p>
<p>The button's behavior was also detailed, and we said that upon tapping on that button, the user should be shown a modal that allows them to input details for their expenses--the name, amount, date the purchase was made on, and an icon to categorize the item. The modal should allow the user to either cancel or save the entry they make.</p>
<p>We can create one component to add expenses that will contain both the <kbd>Button</kbd> and <kbd>Modal</kbd>, with the <kbd>Modal</kbd> defaulting to a hidden state unless activated by the <kbd>Button</kbd>.</p>
<p>Let's start by creating a component, titled <kbd>AddExpenses</kbd>, which will start off by doing the following things:</p>
<ul>
<li>Accepting the <kbd>month</kbd> and <kbd>year</kbd> as props</li>
<li>Rendering a <kbd>Button</kbd> that, when pressed, will alert the user for now</li>
</ul>
<p>Additionally, we should render the <kbd>AddExpenses</kbd> component within <kbd>App.js</kbd>:</p>
<pre>
// Expenses/app/components/AddExpenses/index.js <br/><br/>import React, { Component, PropTypes } from 'react'; <br/> <br/>import { <br/>  Button, <br/>  View <br/>} from 'react-native'; <br/> <br/>export default class AddExpenses extends Component { <br/>  static propTypes = { <br/>    month: PropTypes.string.isRequired, <br/>    year: PropTypes.string.isRequired <br/>  }
</pre>
<p>The <kbd>Modal</kbd> we render will take advantage of these props. I also rendered a <kbd>Button</kbd> that will eventually launch this modal:</p>
<pre>
  constructor (props) { <br/>    super (props); <br/>  } <br/> <br/>  render () { <br/>    return ( <br/>      &lt;View&gt; <br/>        &lt;Button <br/>          color={ '#86B2CA' } <br/>          onPress={ () =&gt; alert('Add Expenses Button pressed!') } <br/>          title={ 'Add Expense' } <br/>        /&gt; <br/>      &lt;/View&gt; <br/>    ) <br/>  } <br/>} 
</pre>
<p>These are the changes to the <kbd>App</kbd> component:</p>
<pre>
// Expenses/app/App.js <br/><br/>... <br/>import AddExpenses from './components/AddExpenses'; <br/>... <br/>export default class App extends Component { <br/>  ... <br/>  render () { <br/>    return ( <br/>      &lt;View style={ styles.appContainer }&gt; 
</pre>
<p>Pass in the <kbd>month</kbd> and <kbd>year</kbd> to <kbd>AddExpenses</kbd>:</p>
<pre>
        &lt;AddExpenses <br/>          month={ this.state.month } <br/>          year={ this.state.year } <br/>        /&gt; <br/>      &lt;/View&gt; <br/>    ) <br/>  } <br/>  ... <br/>} 
</pre>
<p>At this point, you should have a button rendered on the screen:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1437 image-border" height="299" src="assets/image_03_002.png" width="165"/></div>
<p>Great work! Next, we will create a modal that opens when the button is pressed.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Looking at modals</h1>
            </header>

            <article>
                
<p>Modals let us present content over another view. In React Native, we can render one using the <kbd>Modal</kbd> tag. Any child elements within a <kbd>Modal</kbd> tag are rendered within it.</p>
<p>Modals have a couple of props that we can take advantage of. The ones listed as follows will be used in this project, though there are more available in the React Native documentation:</p>
<ul>
<li><kbd>animationType</kbd>: This controls how a modal animates when it appears for the user. The three options are slide (from bottom), fade, and none.</li>
<li><kbd>onRequestClose</kbd>: This is a callback that is fired when a modal is dismissed.</li>
<li><kbd>transparent</kbd>: This is a Boolean that determines modal transparency.</li>
<li><kbd>visible</kbd>: This is a Boolean to determine whether a modal is visible.</li>
</ul>
<p>Since this modal will encapsulate a large amount of logic, let's create a new <kbd>AddExpensesModal</kbd> component that will return this modal. It should do the following things:</p>
<ul>
<li>Contains a hidden <kbd>Modal</kbd> component that starts off hidden</li>
<li>Accept the <kbd>month</kbd> and <kbd>year</kbd> props from the <kbd>AddExpenses</kbd> component</li>
<li>Accept a <kbd>modalVisible</kbd> Boolean as a prop from <kbd>AddExpenses</kbd></li>
<li>Render a string with the current month and year</li>
</ul>
<p>We should also update the existing <kbd>AddExpenses</kbd> component to do the following things:</p>
<ul>
<li>Render the <kbd>AddExpensesModal</kbd> component when the <kbd>AddExpenses</kbd> button is pressed, passing the <kbd>month</kbd>, <kbd>year</kbd>, and <kbd>modalVisible</kbd> props</li>
<li>Modify the existing button to toggle the modal’s visibility</li>
</ul>
<p>Let's start by looking at <kbd>AddExpenses</kbd>:</p>
<pre>
// Expenses/app/components/AddExpenses/index.js<br/><br/>... <br/>import AddExpensesModal from '../AddExpensesModal'; <br/> <br/>export default class AddExpenses extends Component { <br/>  ... <br/>  constructor (props) { <br/>    super (props);
</pre>
<p>Track the <kbd>modalVisible</kbd> Boolean in state:</p>
<pre>
    this.state = { <br/>      modalVisible: false <br/>    } <br/>  }
</pre>
<p>Render <kbd>AddExpensesModal</kbd>, passing it a Boolean for visibility, the <kbd>month</kbd>, and <kbd>year</kbd>:</p>
<pre>
  render () { <br/>    return ( <br/>      &lt;View&gt; <br/>        &lt;AddExpensesModal <br/>          modalVisible={ this.state.modalVisible } <br/>          month={ this.props.month } <br/>          year={ this.props.year } <br/>        /&gt;
</pre>
<p>Modify the <kbd>Button</kbd> to call <kbd>_toggleModal</kbd> instead of <kbd>alert</kbd>:</p>
<pre>
        &lt;Button <br/>          color={ '#86B2CA' } <br/>          onPress={ () =&gt; this._toggleModal() } <br/>          title={ 'Add Expense' } <br/>        /&gt; <br/>      &lt;/View&gt; <br/>    ) <br/>  }
</pre>
<p>Flip the <kbd>modalVisible</kbd> Boolean in state:</p>
<pre>
  _toggleModal () { <br/>    this.setState({ <br/>      modalVisible: !this.state.modalVisible <br/>    }); <br/>  } <br/>} 
</pre>
<p>Here is how I built the <kbd>AddExpensesModal</kbd>:</p>
<pre>
// Expenses/app/components/AddExpensesModal/index.js <br/><br/>import React, { Component, PropTypes } from 'react'; <br/> <br/>import { <br/>  Modal, <br/>  Text, <br/>  View <br/>} from 'react-native'; <br/> <br/>import styles from './styles'; <br/> <br/>export default class AddExpensesModal extends Component {
</pre>
<p>Explicitly declare the expected <kbd>props</kbd> and their datatypes:</p>
<pre>
  static propTypes = { <br/>    modalVisible: PropTypes.bool.isRequired, <br/>    month: PropTypes.string.isRequired, <br/>    year: PropTypes.string.isRequired <br/>  }<br/><br/>  constructor (props) { <br/>    super (props); <br/>  }
</pre>
<p>Render a modal with a <kbd>slide</kbd> animation. Visibility is controlled by the <kbd>modalVisible</kbd> Boolean:</p>
<pre>
  render () { <br/>    return ( <br/>      &lt;Modal <br/>        animationType={ 'slide' } <br/>        transparent={ false } <br/>        visible={ this.props.modalVisible } <br/>      &gt;
</pre>
<p>Render a <kbd>View</kbd> with <kbd>Text</kbd> within the <kbd>Modal</kbd>:</p>
<pre>
        &lt;View style={ styles.modalContainer }&gt; <br/>          &lt;Text&gt; <br/>            This is a modal to enter your { this.props.month + ' ' + <br/>            this.props.year } budget. <br/>          &lt;/Text&gt; <br/>        &lt;/View&gt; <br/>      &lt;/Modal&gt;<br/>    )<br/>  }<br/>}
</pre>
<p>This is the styling for <kbd>AddExpensesModal</kbd>:</p>
<pre>
// Expenses/app/components/AddExpensesModal/styles.js <br/><br/>import { Navigator, StyleSheet } from 'react-native'; <br/> <br/>const styles = StyleSheet.create({ <br/>  modalContainer: { <br/>    flex: 1, <br/>    marginTop: Navigator.NavigationBar.Styles.General.TotalNavHeight <br/>  } <br/>}); <br/> <br/>export default styles; 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Header and TextInput fields</h1>
            </header>

            <article>
                
<p>You may note that we currently don't have a way to close this modal or add any data to create new expenses for our list. Let's change that by adding the following things:</p>
<ul>
<li>A header that prompts the user to add an expense</li>
<li>A normal <kbd>TextInput</kbd> field that prompts the user for the name of the expense</li>
<li>A numeric <kbd>TextInput</kbd> field, set to a numeric keyboard, that prompts the user for the cost of the expense</li>
</ul>
<p>Here are the changes I made to <kbd>AddExpensesModal</kbd>:</p>
<pre>
// Expenses/app/components/AddExpensesModal/index.js <br/><br/>... <br/>import { <br/>  ... <br/>  TextInput, <br/>  ... <br/>} from 'react-native'; <br/>... <br/>export default class AddExpensesModal extends Component { <br/>...
</pre>
<p>Store the <kbd>amount</kbd> and <kbd>description</kbd> values for the two <kbd>TextInput</kbd> fields:</p>
<pre>
  constructor (props) { <br/>    super (props); <br/> <br/>    this.state = { <br/>      amount: '', <br/>      description: '', <br/>    } <br/>  } 
</pre>
<p>The <kbd>render</kbd> method of <kbd>AddExpensesModal</kbd> wraps any components that the Modal displays as its children:</p>
<pre>
  render () { <br/>    return ( <br/>      &lt;Modal <br/>        animationType={ 'slide' } <br/>        transparent={ false } <br/>        visible={ this.props.modalVisible } <br/>      &gt; <br/>        &lt;View style={ styles.modalContainer }&gt; <br/>          &lt;Text style={ styles.headerText }&gt; <br/>            Add an Expense <br/>          &lt;/Text&gt; <br/>          &lt;View style={ styles.amountRow }&gt; <br/>            &lt;Text style={ styles.amountText }&gt; <br/>              Amount <br/>            &lt;/Text&gt;
</pre>
<p>Create the <kbd>TextInput</kbd> field specifically for numeric <kbd>amount</kbd> input:</p>
<pre>
            &lt;TextInput <br/>              keyboardType={ 'numeric' } <br/>              onChangeText={ (value) =&gt; this._changeAmount(value) } <br/>              placeholder={ '0' } <br/>              style={ styles.amountInput } <br/>              value={ this.state.amount } <br/>            /&gt;<br/>          &lt;/View&gt;
</pre>
<p>Create the <kbd>TextInput</kbd> field specifically for the description:</p>
<pre>
          &lt;Text style={ styles.descriptionText }&gt; <br/>            Description <br/>          &lt;/Text&gt; <br/>          &lt;TextInput <br/>            onChangeText={ (value) =&gt; this._changeDescription(value) } <br/>            placeholder={ 'Book on React Native development' } <br/>            style={ styles.descriptionInput } <br/>            value={ this.state.description } <br/>          /&gt;<br/>        &lt;/View&gt; <br/>      &lt;/Modal&gt; <br/>    ) <br/>  } 
</pre>
<p>These two methods set the <kbd>amount</kbd> and <kbd>description</kbd> values in state:</p>
<pre>
  _changeAmount(amount) { <br/>    this.setState({ <br/>      amount <br/>    }); <br/>  } <br/> <br/>  _changeDescription(description) { <br/>    this.setState({ <br/>      description <br/>    }); <br/>  } <br/>} 
</pre>
<p>New styling has also been added to this component:</p>
<pre>
// Expenses/app/components/AddExpensesModal/styles.js <br/><br/>... <br/>const styles = StyleSheet.create({
</pre>
<p>The three amount-related styles are for the row where the <kbd>expense</kbd> amount is entered.</p>
<pre>
  amountInput: { <br/>    borderColor: '#86B2CA', <br/>    borderRadius: 10, <br/>    borderWidth: 1, <br/>    color: '#3D4A53', <br/>    height: 40, <br/>    margin: 10, <br/>    padding: 10, <br/>    width: 200 <br/>  },
</pre>
<p>The <kbd>amountRow</kbd> has a <kbd>justifyContent</kbd> property of <kbd>space-between</kbd> to evenly space the <kbd>Text</kbd> and <kbd>TextInput</kbd> components:</p>
<pre>
  amountRow: { <br/>    flexDirection: 'row', <br/>    justifyContent: 'space-between' <br/>  }, <br/>  amountText: { <br/>    color: '#3D4A53', <br/>    margin: 10, <br/>    marginLeft: 20, <br/>    paddingTop: 10 <br/>  }, 
</pre>
<p>These styles deal with the <kbd>description</kbd> and <kbd>header</kbd> elements:</p>
<pre>
  descriptionInput: { <br/>    borderColor: '#86B2CA', <br/>    borderRadius: 10, <br/>    borderWidth: 1, <br/>    color: '#3D4A53', <br/>    height: 40, <br/>    margin: 10, <br/>    padding: 10 <br/>  }, <br/>  descriptionText: { <br/>    color: '#3D4A53', <br/>    marginBottom: 5, <br/>    marginLeft: 20, <br/>    marginRight: 10, <br/>    marginTop: 10 <br/>  }, <br/>  headerText: { <br/>    color: '#7D878D', <br/>    fontSize: 18, <br/>    fontWeight: 'bold', <br/>    marginBottom: 15, <br/>    textAlign: 'center' <br/>  }, <br/>  ... <br/>}); 
</pre>
<p>Your <kbd>AddExpensesModal</kbd> should resemble something like this now:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1438 image-border" height="337" src="assets/image_03_003.png" width="185"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">DatePickerIOS plus ExpandableCell</h1>
            </header>

            <article>
                
<p>In the next step, you should modify the <kbd>AddExpensesModal</kbd> component to contain the following things:</p>
<ul>
<li>A <kbd>DatePickerIOS</kbd> component that sets only the date--without time--the expense was made on. It should default to today's date if not specified:
<ul>
<li>You should import and wrap <kbd>DatePickerIOS</kbd> around the <kbd>ExpandableCell</kbd> component we built for <kbd>Tasks</kbd>.</li>
</ul>
</li>
<li>A line of text that explains the date on which the expense was made.</li>
</ul>
<p>This is how I added <kbd>ExpandableCell</kbd> to <kbd>AddExpensesModal</kbd>:</p>
<pre>
// Expenses/app/components/AddExpensesModal/index.js <br/><br/>... <br/>import { <br/>  DatePickerIOS, <br/>  ... <br/>} from 'react-native'; <br/> <br/>import moment from 'moment'; <br/>import ExpandableCell from '../ExpandableCell'; <br/>... <br/>export default class AddExpensesModal extends Component { <br/>  ... <br/>  constructor (props) { <br/>    super (props);
</pre>
<p>Two new properties are now saved in state: the current <kbd>date</kbd> and the <kbd>expanded</kbd> Boolean:</p>
<pre>
    this.state = { <br/>      ... <br/>      date: new Date(), <br/>      expanded: false <br/>    } <br/>  } 
</pre>
<p>There is no new code in the <kbd>ExpandableCell</kbd> module from <a href="ca59eac5-a24f-4ac1-8b42-f1c28d149d74.xhtml">Chapter 2</a>, <em>Advanced Functionality and Styling the To-Do List App</em>.</p>
<pre>
 render () { <br/>    const expandableCellTitle = 'Date: ' + moment(this.state.date).<br/>    format('ll') + ' (tap to change)'; <br/> <br/>    return ( <br/>      &lt;Modal <br/>        animationType={ 'slide' } <br/>        transparent={ false } <br/>        visible={ this.props.modalVisible } <br/>      &gt; <br/>        ... <br/>          &lt;View style={ [styles.expandableCellContainer,<br/>          { maxHeight: this.state.expanded ?<br/>          this.state.datePickerHeight : 40 }]}&gt;
</pre>
<p>Placement of the <kbd>ExpandableCell</kbd> component comes right after the <kbd>TextInput</kbd> for the expense's description:</p>
<pre>
            &lt;ExpandableCell <br/>              expanded={ this.state.expanded } <br/>              onPress={ () =&gt; this._onExpand() } <br/>              title={ expandableCellTitle }&gt;
</pre>
<p>The <kbd>DatePickerIOS</kbd> component’s <kbd>mode</kbd> is set to <kbd>date</kbd> so that time cannot be selected:</p>
<pre>
              &lt;DatePickerIOS <br/>                date={ this.state.date } <br/>                mode={ 'date' } <br/>                onDateChange={ (date) =&gt; this._onDateChange(date) } <br/>                onLayout={ (event) =&gt; this._getDatePickerHeight(event) <br/>                } <br/>              /&gt; <br/>            &lt;/ExpandableCell&gt; <br/>          &lt;/View&gt; <br/>        &lt;/View&gt; <br/>      &lt;/Modal&gt; <br/>    ) <br/>  } 
</pre>
<p>The logic to get the height of <kbd>DatePickerIOS</kbd> is unchanged from, <a href="ca59eac5-a24f-4ac1-8b42-f1c28d149d74.xhtml">Chapter 2</a>: <em>Advanced Functionality and Styling the To-Do List App</em>:</p>
<pre>
  ... <br/>  _getDatePickerHeight (event) { <br/>    this.setState({ <br/>      datePickerHeight: event.nativeEvent.layout.width <br/>    }); <br/>  }
</pre>
<p>Three new methods can be found in this component, all of which are reused from our earlier project, <kbd>Tasks</kbd>, handled by the <kbd>ExpandableCell</kbd> and its <kbd>DatePickerIOS</kbd> child.</p>
<pre>
  _onDateChange (date) { <br/>    this.setState({ <br/>      date <br/>    }); <br/>  } <br/> <br/>  _onExpand () { <br/>    this.setState({ <br/>      expanded: !this.state.expanded <br/>    }); <br/>  } <br/>} 
</pre>
<p>Styling for this component involves just one new property:</p>
<pre>
// Expenses/app/components/AddExpensesModal/styles.js <br/><br/>expandableCellContainer: { <br/>    flex: 1 <br/>}, 
</pre>
<p>By this point, your app will look like the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1439 image-border" height="340" src="assets/image_03_004.png" width="188"/></div>
<p>Great job with the updates! The <kbd>AddExpensesModal</kbd> will end up with a lot of fields for the user to interact with.</p>
<p>You may have noted that the keyboard does not dismiss itself when <kbd>ExpandableCell</kbd> is interacted with, which can lead to information that the user is unable to access.</p>
<p>It’s time to look at the <kbd>ScrollView</kbd> component to learn how to dismiss the keyboard.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">ScrollView</h1>
            </header>

            <article>
                
<p>By default, the <em>return</em> key on the software keyboard handles a dismiss action for our apps. However, a <em>return</em> key does not exist on a numeric keyboard. Instead, we can replace our top-level <kbd>View</kbd> with the <kbd>ScrollView</kbd> component.</p>
<p>The <kbd>ScrollView</kbd> component wraps around the rest of your component, providing scrolling capabilities.</p>
<p>An important thing to know is that <kbd>ScrollView</kbd> requires all its children to have a <kbd>height</kbd> property in its styling. If it does not have one, then the child element will not render.</p>
<p>Let's quickly replace the <kbd>View</kbd> that <kbd>AddExpensesModal</kbd> encapsulates around its <kbd>Modal</kbd> component with a <kbd>ScrollView</kbd>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">ScrollView example</h1>
            </header>

            <article>
                
<p>This is how I updated <kbd>AddExpensesModal</kbd> to include a <kbd>ScrollView</kbd>:</p>
<pre>
// Expenses/app/components/AddExpensesModal/index.js <br/><br/>... <br/>import { <br/>  ... <br/>  ScrollView, <br/>  ... <br/>} from 'react-native'; <br/>... <br/>export default class AddExpensesModal extends Component { <br/>  ...
</pre>
<p>Replace the modal's <kbd>View</kbd> with <kbd>ScrollView</kbd>. The <kbd>maxHeight</kbd> of the <kbd>View</kbd> inside is now <kbd>height</kbd>:</p>
<pre>
  render () { <br/>    ... <br/>    return ( <br/>      &lt;Modal <br/>        animationType={ 'slide' } <br/>        transparent={ false } <br/>        visible={ this.props.modalVisible } <br/>      &gt; <br/>        &lt;ScrollView style={ styles.modalContainer }&gt; <br/>          ... <br/>          &lt;View style={ [styles.expandableCellContainer, <br/>            { height: this.state.expanded ? <br/>            this.state.datePickerHeight : 40 }]}&gt; <br/>            ... <br/>          &lt;/View&gt; <br/>        &lt;/ScrollView&gt;<br/>      &lt;/Modal&gt; <br/>    ) <br/>  } 
</pre>
<p>The outer <kbd>View</kbd> container that was the direct child of the <kbd>Modal</kbd> component has been swapped out with a <kbd>ScrollView</kbd>.</p>
<p>The <kbd>maxHeight</kbd> property in the <kbd>View</kbd> that encapsulates <kbd>ExpandableCell</kbd> has been changed into a <kbd>height</kbd> property so that it renders in the <kbd>ScrollView</kbd>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Saving expenses</h1>
            </header>

            <article>
                
<p>The next step is to allow entries to be saved to the app. Let's modify <kbd>AddExpensesModal</kbd> again and add the following features; you will also need to add some methods into <kbd>storageMethods</kbd> as well as the <kbd>AddExpenses</kbd> component:</p>
<ul>
<li>A button to save the expense, with the following conditions:
<ul>
<li>It should only be enabled if all the fields of the modal are filled out.</li>
<li>When pressed, the expense name, amount, and date should be saved into <kbd>AsyncStorage</kbd>.</li>
<li>The date should be formatted with Moment the same way we formatted it for the <kbd>ExpandableCell</kbd> title.</li>
<li>When this logic finishes, the modal should be closed and the information entered should be cleared. The closing of the modal should be passed in as a prop from the parent <kbd>AddExpenses</kbd> component since it already has a method to toggle the modal:
<ul>
<li>A new helper method in <kbd>storageMethods</kbd> should be created to handle the logic of saving an expense into <kbd>AsyncStorage</kbd>.</li>
<li>Another helper method in <kbd>storageMethods</kbd> should be written to tally each expense for the month and set it to the <kbd>spent</kbd> property of that specific month. It should be fired when a new expense is added to the month's <kbd>expenses</kbd> array, and then modify that month's <kbd>spent</kbd> property with the tally before the expense is saved into <kbd>AsyncStorage</kbd>.</li>
<li>Another button to cancel the expense, closing the <kbd>AddExpensesModal</kbd> and clearing any information previously entered. It should also have access to the same method from <kbd>AddExpenses</kbd> to toggle the modal.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>As a reminder, earlier in the chapter, we visualized a single object in our list of expenses to be structured in the following way:</p>
<pre>
        { <br/>          amount: '4', <br/>          category: 'Coffee', <br/>          date: 'Jan 12, 2017' <br/>          description: 'Latte @ Coffeeshop' <br/>        }, 
</pre>
<div class="packt_tip">Do not worry about the <kbd>category</kbd> key for now; that will come in the next chapter.</div>
<p>The first thing I did was go to <kbd>storageMethods</kbd> and create two new methods: <kbd>getTotalSpentForMonth</kbd> and <kbd>saveItemToBudget</kbd>. The first function, <kbd>getTotalSpentForMonth</kbd>, takes in an array and iterates through it. It returns the total amount spent by converting the strings to numbers with <kbd>parseInt</kbd>:</p>
<pre>
// Expenses/app/utils/storageMethods.js <br/><br/>... <br/>const getTotalSpentForMonth = (array) =&gt; { <br/>  let total = 0; <br/> <br/>  array.forEach((elem) =&gt; { <br/>    total += parseInt(elem.amount) <br/>  }); <br/> <br/>  return total; <br/>} 
</pre>
<p>The second function, <kbd>saveItemToBudget</kbd>, is an asynchronous one and starts by taking in the <kbd>month</kbd>, <kbd>year</kbd>, and <kbd>expenseObject</kbd> as arguments:</p>
<pre>
export const saveItemToBudget = async (month, year, expenseObject) <br/>=&gt; { <br/>  let response = await getAsyncStorage(); <br/> <br/>  let newExpensesArray = [ <br/>    ...response[year][month].expenses, <br/>    expenseObject <br/>  ]; <br/> <br/>  let newTotal = getTotalSpentForMonth(newExpensesArray); <br/> <br/>  response[year][month].expenses = newExpensesArray; <br/>  response[year][month].spent = newTotal; <br/> <br/>  await setAsyncStorage(response); <br/> <br/>  return true; <br/>} <br/>... 
</pre>
<p>It grabs the <kbd>expenses</kbd> object stored in <kbd>AsyncStorage</kbd>, creates a new array with the array spread operator (<kbd>...</kbd>) to add the new <kbd>expenseObject</kbd> argument to it, and then calls <kbd>getTotalSpentForMonth</kbd> with the new array.</p>
<p>Afterwards, it assigns the new array to the <kbd>expenses</kbd> property for the month and the total is calculated as the new total amount spent. Finally, it saves it to <kbd>AsyncStorage</kbd>.</p>
<p>The next file I modified was <kbd>AddExpenses</kbd>:</p>
<pre>
// Expenses/app/components/AddExpenses/index.js <br/><br/>... <br/>export default class AddExpenses extends Component { <br/>  ... <br/>  render () { <br/>    return ( <br/>      &lt;View&gt; <br/>        &lt;AddExpensesModal <br/>          modalVisible={ this.state.modalVisible } <br/>          month={ this.props.month } <br/>          toggleModal={ () =&gt; this._toggleModal() } <br/>          year={ this.props.year } <br/>        /&gt; <br/>        ... <br/>      &lt;/View&gt; <br/>    ) <br/>  } <br/>  ... <br/>} 
</pre>
<p>In the preceding code, I'm passing <kbd>_toggleModal</kbd> into the <kbd>AddExpensesModal</kbd> component so that it can toggle the modal between its visible and invisible states.</p>
<pre>
// Expenses/app/components/AddExpensesModal/index.js <br/><br/>... <br/>import { <br/>  Button, <br/>  ... <br/>} from 'react-native'; <br/> <br/>... <br/>export default class AddExpensesModal extends Component { <br/>  static propTypes = { <br/>    ... <br/>    toggleModal: PropTypes.func.isRequired, <br/>  } <br/>  ... <br/>  render () { <br/>    ... <br/>    return ( <br/>      &lt;Modal <br/>        ... <br/>      &gt;
</pre>
<p>The two <kbd>Buttons</kbd> are rendered after the <kbd>View</kbd> that encapsulates <kbd>ExpandableCell</kbd>. The <span class="packt_screen">Save</span> button is disabled unless each field contains a value:</p>
<pre>
        &lt;ScrollView style={ styles.modalContainer }&gt; <br/>          ... <br/>          &lt;Button <br/>            color={ '#86B2CA' } <br/>            disabled={ !(this.state.amount &amp;&amp; this.state.description) } <br/>            onPress={ () =&gt; this._saveItemToBudget() } <br/>            title={ 'Save Expense' } <br/>          /&gt; <br/>          &lt;Button <br/>            color={ '#E85C58' } <br/>            onPress={ () =&gt; this._clearFieldsAndCloseModal() } <br/>            title={ 'Cancel' } <br/>          /&gt; <br/>        &lt;/ScrollView&gt; <br/>      &lt;/Modal&gt; <br/>    ) <br/>  } <br/>  ... 
</pre>
<p>The following code sets the <kbd>amount</kbd> and <kbd>description</kbd> values to empty strings, clearing them:</p>
<pre>
  _clearFieldsAndCloseModal () { <br/>    this.setState({ <br/>      amount: '', <br/>      description: '' <br/>    });
</pre>
<p>The following code creates an <kbd>expense</kbd> object and calls <kbd>saveItemToBudget</kbd> from <kbd>storageMethods</kbd>, passing it in. Then, it clears the <kbd>amount</kbd> and <kbd>description</kbd>:</p>
<pre>
  ... <br/>  async _saveItemToBudget () { <br/>    const expenseObject = { <br/>      amount: this.state.amount, <br/>      date: moment(this.state.date).format('ll'), <br/>      description: this.state.description <br/>    };<br/>    let month = this.state.date.getMonth() + 1;<br/>    let year = this.state.date.getFullYear();<br/>    await storageMethods.saveItemToBudget(month, year, <br/>    expenseObject); <br/> <br/>    this._clearFieldsAndCloseModal(); <br/>  } <br/>} 
</pre>
<p>By this point, your <kbd>AddExpensesModal</kbd> should be nearly complete:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1440 image-border" height="345" src="assets/image_03_005.png" width="201"/></div>
<p>Good job on your progress! Let's switch gears and begin to address the rendering of our month's expenses. We will revisit this component in the next chapter so that we can add the functionality of categorizing expenses by icons.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Displaying the current month's expenses</h1>
            </header>

            <article>
                
<p>The next feature we wrote about earlier in this chapter was that if the expense is saved, it should then be rendered in a list on the main screen that contains the button to add further expenses.</p>
<p>In this section, we will create that list. We should create a component called <kbd>CurrentMonthExpenses</kbd> and make modifications to the existing files to support it.</p>
<p>You should add a new function to <kbd>storageMethods</kbd> that accepts a month and year, returning the budget, list of expenses, and the amount spent for that month and year.</p>
<p>The <kbd>CurrentMonthExpenses</kbd> component should do the following things:</p>
<ul>
<li>Render a header that shows the current month's name and budget.</li>
<li>Display a <kbd>ListView</kbd> of the month's expenses, retrieved from <kbd>AsyncStorage</kbd>, with some styling and formatting. At the very least, it should include the description of the expense as well as the dollar amount.
<ul>
<li>The <kbd>ListView</kbd> being rendered should be its own component so that we can reuse it in the next chapter for the prior months.</li>
<li>The rows being rendered in the <kbd>ListView</kbd> should be written as its component as well.</li>
</ul>
</li>
</ul>
<p>Then, your <kbd>App.js</kbd> file should do the following things:</p>
<ul>
<li>Render <kbd>CurrentMonthExpenses</kbd> right before the <kbd>AddExpenses</kbd> component.</li>
<li>Load this list when the component is mounted.</li>
<li>Update <kbd>ListView</kbd> in <kbd>CurrentMonthExpenses</kbd> when a new expense has been added by <kbd>AddExpenses</kbd>.</li>
</ul>
<p>As a result, you may need to modify <kbd>AddExpenses</kbd> to do as follows:</p>
<ul>
<li>Accept a callback as a prop that will propagate up to <kbd>App.js</kbd> when the modal is toggled.</li>
</ul>
<p>When you have finished the preceding procedure, come back and check out the code I wrote.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">CurrentMonthExpenses example</h1>
            </header>

            <article>
                
<p>The first thing I did was add and export a function called <kbd>getMonthObject</kbd> into <kbd>storageMethods.js</kbd>:</p>
<pre>
// Expenses/app/utils/storageMethods.js <br/><br/>... <br/>export const getMonthObject = async (month, year) =&gt; { <br/>  let response = await getAsyncStorage(); <br/> <br/>  if (response[year] &amp;&amp; response[year][month]) { <br/>    return response[year][month]; <br/>  } <br/>} <br/>... 
</pre>
<p>The <kbd>getMonthObject</kbd> method grabs the <kbd>expenses</kbd> object from <kbd>AsyncStorage</kbd>, checks for the existence of the <kbd>year</kbd> and <kbd>month</kbd> object, then returns it if possible. Here is how I used that method within the new <kbd>currentMonthExpenses</kbd> component:</p>
<pre>
// Expenses/app/components/CurrentMonthExpenses/index.js <br/><br/>import React, { Component, PropTypes } from 'react'; <br/> <br/>import { <br/>  ListView, <br/>  Text, <br/>  View <br/>} from 'react-native'; <br/> <br/>import styles from './styles'; <br/>import * as dateMethods from '../../utils/dateMethods'; <br/>import * as storageMethods from '../../utils/storageMethods'; <br/> <br/>import ExpenseRow from '../ExpenseRow'; <br/> <br/>export default class CurrentMonthExpenses extends Component { <br/>  static propTypes = { <br/>    budget: PropTypes.string.isRequired, <br/>    expenses: PropTypes.array.isRequired, <br/>    month: PropTypes.string.isRequired, <br/>    spent: PropTypes.number.isRequired, <br/>    year: PropTypes.string.isRequired, <br/>  }
</pre>
<p>I start by setting up a <kbd>ListView.DataSource</kbd> instance in anticipation of the <kbd>ListView</kbd> being rendered:</p>
<pre>
  constructor (props) { <br/>    super (props); <br/> <br/>    this.state = { <br/>      ds: new ListView.DataSource({ <br/>        rowHasChanged: (r1, r2) =&gt; r1 !== r2 <br/>      }), <br/>    } <br/>  } 
</pre>
<p>The <kbd>render</kbd> method of <kbd>CurrentMonthExpenses</kbd> creates a header for our <kbd>month</kbd> and <kbd>budget</kbd>, then creates a <kbd>ListView</kbd>. This <kbd>ListView</kbd> is also using the <kbd>renderSeparator</kbd> prop, which renders a horizontal line to separate the items on the list.</p>
<pre>
  render () { <br/>    const dataSource = this.state.ds.cloneWithRows<br/>    (this.props.expenses || []);
</pre>
<p>Data pertaining to the <kbd>expenses</kbd> array and <kbd>budget</kbd> are obtained as props passed down to this component from its parent, <kbd>App.js</kbd>:</p>
<pre>
    return (<br/>      &lt;View style={ styles.currentMonthExpensesContainer }&gt; <br/>        &lt;View style={ styles.currentMonthExpensesHeader }&gt; <br/>          &lt;Text style={ styles.headerText }&gt; <br/>            Your { dateMethods.getMonthString(this.props.month)<br/>            + ' ' + this.props.year } budget: <br/>          &lt;/Text&gt; <br/>          &lt;Text style={ styles.subText }&gt; <br/>            { this.props.budget } <br/>          &lt;/Text&gt; <br/>        &lt;/View&gt; <br/>        &lt;ListView <br/>          automaticallyAdjustContentInsets={ false } <br/>          dataSource={ dataSource } <br/>          enableEmptySections={ true } <br/>          renderRow={ (rowData, sectionID, rowID) =&gt;<br/>            this._renderRowData(rowData, rowID) } <br/>          renderSeparator={ (sectionID, rowID) =&gt;<br/>            this._renderRowSeparator(sectionID, rowID) } <br/>        /&gt; <br/>      &lt;/View&gt; <br/>    ) <br/>  } 
</pre>
<p>The <kbd>_renderRowData</kbd> function renders a single expense row using the <kbd>ExpenseRow</kbd> component, which we will look at in the following section. Then, <kbd>_renderRowSeparator</kbd> returns a simple view that contains a style for the separator. Check this out here:</p>
<pre>
  _renderRowData (rowData, rowID) { <br/>    if (rowData) { <br/>      return ( <br/>        &lt;ExpenseRow <br/>          amount={ rowData.amount } <br/>          description={ rowData.description } <br/>        /&gt; <br/>      ) <br/>    } <br/>  } <br/> <br/>  _renderRowSeparator (sectionID, rowID) { <br/>    return ( <br/>      &lt;View <br/>        key={ rowID } <br/>        style={ styles.rowSeparator } <br/>      /&gt; <br/>    ) <br/>  } <br/>}; 
</pre>
<p>This is the styling for <kbd>CurrentMonthExpenses</kbd>:</p>
<pre>
// Expenses/app/components/CurrentMonthExpenses/styles.js <br/><br/>import { StyleSheet } from 'react-native'; <br/> <br/>const styles = StyleSheet.create({ <br/>  currentMonthExpensesContainer: { <br/>    flex: 1, <br/>  }, <br/>  currentMonthExpensesHeader: { <br/>    height: 80, <br/>  }, <br/>  headerText: { <br/>    color: '#7D878D', <br/>    fontSize: 24, <br/>    marginBottom: 10, <br/>    marginTop: 10, <br/>    textAlign: 'center' <br/>  }, <br/>  rowSeparator: { <br/>    backgroundColor: '#7D878D', <br/>    flex: 1, <br/>    height: StyleSheet.hairlineWidth, <br/>    marginLeft: 15, <br/>    marginRight: 15 <br/>  }, <br/>  subText: { <br/>    color: '#3D4A53', <br/>    fontSize: 18, <br/>    fontWeight: 'bold', <br/>    textAlign: 'center' <br/>  }, <br/>}); <br/> <br/>export default styles; 
</pre>
<p>Styling is standard for our component, though <kbd>rowSeparator</kbd> is a new one. The <kbd>height</kbd> for this component is set to the <kbd>hairlineWidth</kbd> property of the <kbd>StyleSheet</kbd>. This is how we render the thin line that separates each individual row in a <kbd>ListView</kbd>.</p>
<pre>
// Expenses/app/components/ExpenseRow/index.js <br/><br/>import React from 'react'; <br/> <br/>import { <br/>  Text, <br/>  View <br/>} from 'react-native'; <br/> <br/>import styles from './styles'; <br/> <br/>export default (props) =&gt; { <br/>  return ( <br/>    &lt;View style={ styles.expenseRowContainer }&gt; <br/>      &lt;Text style={ styles.descriptionText }&gt; <br/>        { props.description } <br/>      &lt;/Text&gt; <br/>      &lt;Text style={ styles.amountText }&gt; <br/>        { props.amount } <br/>      &lt;/Text&gt; <br/>    &lt;/View&gt; <br/>  ) <br/>} 
</pre>
<p>This syntax might look new to you, and it’s worth taking a moment to cover it. What you are seeing here is a <strong>stateless functional component</strong>. It <span>is</span> a function that takes in any number of props passed into it, and returns a component that can be used in React applications.</p>
<p>The reason <kbd>ExpenseRow</kbd> is being written as a stateless functional component is because we don’t intend on adding any heavy logic to it or using any React life cycle events.</p>
<p>There are two big changes to the <kbd>render</kbd> method of <kbd>App.js</kbd>: First, we are rendering <kbd>CurrentMonthExpenses</kbd> prior to <kbd>AddExpenses</kbd> and, second, we are passing a callback to <kbd>AddExpenses</kbd>, titled <kbd>updateCurrentMonthExpenses</kbd>, pointing to the similarly named <kbd>_updateCurrentMonthExpenses</kbd> method in this component. We will look at that one shortly:</p>
<pre>
// Expenses/app/App.js <br/><br/>... <br/>import CurrentMonthExpenses from './components/CurrentMonthExpenses'; <br/>... <br/>export default class App extends Component { <br/>  ... <br/>  render () { <br/>    return ( <br/>      &lt;View style={ styles.appContainer }&gt; <br/>        &lt;CurrentMonthExpenses <br/>          budget={ this.state.budget || '0' } <br/>          expenses={ this.state.expenses } <br/>          month={ this.state.month } <br/>          spent={ this.state.spent || 0 } <br/>          year={ this.state.year } <br/>        /&gt; <br/>        &lt;AddExpenses <br/>          month={ this.state.month } <br/>          updateCurrentMonthExpenses={ () =&gt; <br/>          this._updateCurrentMonthExpenses() } <br/>          year={ this.state.year } <br/>        /&gt; <br/>      &lt;/View&gt; <br/>    ) <br/>  } 
</pre>
<p>The main change to <kbd>_updateBudget</kbd> is that we are firing <kbd>_updateCurrentMonthExpenses</kbd> so that when the app is opened by the user, we can populate the list of expenses:</p>
<pre>
  ... <br/>  async _updateBudget () { <br/>    let response = await storageMethods.checkCurrentMonthBudget(); <br/> <br/>    if (response !== false) { <br/>      this.setState({ <br/>        budget: response <br/>      }); <br/> <br/>      this._updateCurrentMonthExpenses(); <br/>      return; <br/>    } <br/> <br/>    this._renderEnterBudgetComponent(); <br/>  } 
</pre>
<p>The following is the function that does the bulk of the legwork. As an asynchronous function, it starts using the <kbd>getMonthObject</kbd> function from <kbd>storageMethods</kbd> that we built earlier in this section and then checks to see whether it exists. If it does, then it will set the <kbd>budget</kbd>, <kbd>expenses</kbd> array, and <kbd>amount</kbd> spent to state. This in turn triggers a re-render, passing any changed values down to the <kbd>CurrentMonthExpenses</kbd> component.</p>
<pre>
  async _updateCurrentMonthExpenses () { <br/>    let responseObject = await <br/>    storageMethods.getMonthObject(this.state.month, this.state.year); <br/> <br/>    if (responseObject) { <br/>      this.setState({ <br/>        budget: responseObject.budget, <br/>        expenses: responseObject.expenses, <br/>        spent: responseObject.spent <br/>      }); <br/>    } <br/>  } <br/>} 
</pre>
<p>In the <kbd>AddExpense</kbd> component, the <kbd>_toggleModal</kbd> method now fires the <kbd>updateCurrentMonthExpenses</kbd> callback so that when the modal is toggled, the most up-to-date list of expenses is passed to the <kbd>CurrentMonthExpenses</kbd> component:</p>
<pre>
// Expenses/app/components/AddExpense/index.js <br/><br/>... <br/>export default class AddExpenses extends Component { <br/>  static propTypes = { <br/>    ... <br/>    updateCurrentMonthExpenses: PropTypes.func.isRequired <br/>  } <br/>  ... <br/>  _toggleModal (boolean) { <br/>    this.setState({ <br/>      modalVisible: !this.state.modalVisible <br/>    }); <br/>    this.props.updateCurrentMonthExpenses(); <br/>  } <br/>} 
</pre>
<p>Here is how the <kbd>CurrentExpenses</kbd> modal should now look:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1441 image-border" height="370" src="assets/image_03_006.png" width="220"/></div>
<p>Great job on your progress so far! This is just the beginning of how we will build this app, and we will do even more in the next chapter.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Summary</h1>
            </header>

            <article>
                
<p>In this chapter, we started building our budgeting app. We installed a popular vector icon library, discovered how to link that library to our project in Xcode, and then wrote a basic version of our app.</p>
<p class="NormalPACKT">This included a basic helper library that managed date methods and another to manage storage.</p>
<p>In the app, we created a prompt for the user to enter their budget for the month and ensured that it collected this data before letting them proceed to add in expenses. Then, we used a modal to show and hide the fields for a user to add a new expense into the app and updated the <kbd>ListView</kbd> component to reflect the newly added expense.</p>
<p>The next chapter will get more advanced. We will finally put that vector icon library to good use by letting the user categorize their expenses by icon, and then let them look at the past months' data by creating a second section of our app, which is controlled by a tab bar. Additionally, we will create a progress view to track the total amount already spent by the user for the month, so that they can track their spending better.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>