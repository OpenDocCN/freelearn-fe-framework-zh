<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;No Comments, Please!"><div class="titlepage" id="aid-12AK82"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. No Comments, Please!</h1></div></div></div><p>During the course of this chapter, we will create reusable components to enable commenting not only on projects, but also on any other entity within our application. We'll build our commenting system in a way that it will allow us to place it anywhere we'd like for our users to put comments. In order to provide our users with a feature to edit existing comments and also a seamless authoring experience, we'll create an editor UI component that could be used to make arbitrary content within our application editable.</p><p>Discussing security and proper user management in this chapter is still out of scope, but we're going to create a dummy user service that will help us simulate a logged-in user. This service will be used by the commenting system, and we'll refactor our existing component to make use of it too.</p><p>We'll cover the following topics in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Using <code class="literal">contenteditable</code> to create an in-place editor</li><li class="listitem">Using <code class="literal">@HostBinding</code> and <code class="literal">@HostListener</code> to bind component members to host element properties and events</li><li class="listitem">Communicating directly with view children using the <code class="literal">@ViewChild</code> annotation</li><li class="listitem">Performing DOM operations by injecting and using <code class="literal">ElementRef</code></li><li class="listitem">Creating a dummy user service and using the <code class="literal">@Injectable</code> annotation to serve it as a dependency injection provider</li><li class="listitem">Applying custom actions on component input changes, using the <code class="literal">OnChanges</code> life cycle hook</li><li class="listitem">Creating a simple pipe to format relative time intervals using the <code class="literal">Moment.js</code> library</li></ul></div><div class="section" title="One editor to rule them all"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/>One editor to rule them all</h1></div></div></div><p>Since we will be <a id="id176" class="indexterm"/>processing a lot of user input within our application, it's crucial to provide a nice authoring experience to our users. Within the commenting system we're about to create in this chapter, we need a way through which users could edit existing comments, as well as add new comments. We could use regular text area input and work with dialog boxes to edit comments, but this seems too old-fashioned for a modern user interface, which we're going to build, and does not really provide a great user experience. What we're looking for is a way to edit stuff in place. The commenting system will not only benefit from such an in-place editor, but it will also help us create the editor component in such a way that we can use it for any content within our application that we'd like to make editable.</p><p>In order to build our in-place editor, we're going to use the <code class="literal">contenteditable</code> API that will enable a user to modify the content within the HTML elements directly in the site document.</p><p>The following example illustrates how we can use the <code class="literal">contenteditable</code> attribute to make HTML elements editable:</p><div class="informalexample"><pre class="programlisting">&lt;h1 <span class="strong"><strong>contenteditable</strong></span>&gt;I'm an editable title&lt;/h1&gt;
&lt;p&gt;I can't be edited&lt;/p&gt;</pre></div><p>Run the preceding example on a blank HTML page and click on the <code class="literal">h1</code> text. You will see that the element has become editable and you can type to modify its content.</p><p>Getting notified about changes within editable elements is fairly easy. There's an input event emitted on every DOM element that is editable, and this will allow us to react to a change easily:</p><div class="informalexample"><pre class="programlisting">const h1 = document.querySelector('h1');
h1.addEventListener(<span class="strong"><strong>'input'</strong></span>,(event)=&gt;console.log(h1.<span class="strong"><strong>textContent</strong></span>);</pre></div><p>With this example, we have already created a naive implementation of an in-place editor where we're able to monitor changes applied by the user. Within this topic, we'll use this standard technology to build a reusable component that we can use wherever we want to make things editable.</p><div class="section" title="Creating an editor component"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec27"/>Creating an editor component</h2></div></div></div><p>First, let's <a id="id177" class="indexterm"/>create a new folder named <code class="literal">editor</code> within our <code class="literal">ui</code> folder. In this folder, we're going to create a new component file named <code class="literal">editor.js</code>:</p><div class="informalexample"><pre class="programlisting">import {Component, ViewChild, Input, Output, ViewEncapsulation, EventEmitter, HostBinding, HostListener} from '@angular/core';
import template from './editor.html!text';

@Component({
  selector: 'ngc-editor',
  host: {
    class: 'editor'
  },
  template,
  encapsulation: ViewEncapsulation.None
})
export class Editor {
  // Using view child reference with local view variable name
  @ViewChild('editableContentElement') editableContentElement;
  // Content that will be edited and displayed
  @Input() content;
  // Creating a host element class attribute binding from the 
  // editMode property
  @Input() @HostBinding('class.editor--edit-mode') editMode;
  @Input() showControls;
  @Output() editSaved = new EventEmitter();
  @Output() editableInput = new EventEmitter();

  // We need to make sure to reflect to our editable element if 
  // content gets updated from outside
  ngOnChanges() {
    if (this.editableContentElement &amp;&amp; this.content) {
      this.setEditableContent(this.content);
    }
  }

  ngAfterViewInit() {
    this.setEditableContent(this.content);
  }

  // This returns the content of our content editable
  getEditableContent() {
    return this.editableContentElement.nativeElement.textContent;
  }

  // This sets the content of our content editable
  setEditableContent(content) {
    this.editableContentElement.nativeElement.textContent = 
      content;
  }

  // This annotation will create a click event listener on the 
  // host element that will invoke the underlying method
  @HostListener('click')
  focusEditableContent() {
    if (this.editMode) {
      this.editableContentElement.nativeElement.focus();
    }
  }

  // Method that will be invoked if our editable element is 
  // changed
  onInput() {
    // Emit a editableInput event with the edited content
    this.editableInput.next(this.getEditableContent());
  }

  // On save we reflect the content of the editable element into 
  // the content field and emit an event
  save() {
    this.editSaved.next(this.getEditableContent());
    this.setEditableContent(this.content);
    // Setting editMode to false to switch the editor back to 
    // viewing mode
    this.editMode = false;
  }

  // Canceling the edit will not reflect the edited content and 
  // switch back to viewing mode
  cancel() {
    this.setEditableContent(this.content);
    this.editableInput.next(this.getEditableContent());
    this.editMode = false;
  }

  // The edit method will initialize the editable element and set 
  // the component into edit mode
  edit() {
    this.editMode = true;
  }
}</pre></div><p>Okay, that's quite a lot of new code. Let's dissect the different parts of the <code class="literal">Editor</code> component and go through each part step by step.</p><p>Within our <code class="literal">Editor</code> <a id="id178" class="indexterm"/>component, we'll need to interact with the native DOM element, which is editable. The easiest and also the safest method to do this is to use the <code class="literal">@ViewChild</code> decorator in order to retrieve an element with a local view reference:</p><div class="informalexample"><pre class="programlisting">@ViewChild('editableContentElement') editableContentElement;</pre></div><p>In the previous chapter, we learned about the <code class="literal">@ContentChildren</code> annotation, which helps us obtain a list of all the child components within content projection points. If we would like to do the same with regular view children, we need to use the equivalent <code class="literal">@ViewChildren</code> annotation. While <code class="literal">@ContentChildren</code> searches for components within content projection points, <code class="literal">@ViewChildren</code> hunts for the regular sub-tree of a component.</p><p>If we want to search the component sub-tree for one single component, we can use the <code class="literal">@ViewChild</code> annotation (please note that <code class="literal">@ViewChild</code> and <code class="literal">@ViewChidren</code> are different).</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Query annotation</p>
</th><th valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td valign="top">
<p><code class="literal">@ViewChildren</code>(selector)</p>
</td><td valign="top">
<p>Will query the current component's view for either directives or components and return an object of the type <code class="literal">QueryList</code>. If the view is dynamically updated, this list will be updated as well.</p>
</td></tr><tr><td valign="top">
<p><code class="literal">@ViewChild</code>(selector)</p>
</td><td valign="top">
<p>Will query for only the first matching component or directive and return an instance of it.</p>
</td></tr></tbody></table></div><div class="note" title="Note"><h3 class="title"><a id="note07"/>Note</h3><p>A selector can be either a directive or component type, or a string that contains the name of a local view variable. If a local view variable name is provided, Angular will search for the element containing the view variable reference.</p></div><p>If you need to communicate with view child components directly, using <code class="literal">@ViewChild</code> and <code class="literal">@ViewChildren</code> annotations should be your preferred way.</p><div class="note" title="Note"><h3 class="title"><a id="tip10"/>Tip</h3><p>Sometimes you <a id="id179" class="indexterm"/>need to run the initialization code on view children after your component is initialized. In such cases, you can use the <code class="literal">AfterViewInit</code> life cycle hook. While the view child properties of your component class will still be undefined within the constructor of your component, they will be populated and initialized after the <code class="literal">AfterViewInit</code> life cycle callback.</p></div><p>The <code class="literal">@ViewChild</code> and <code class="literal">@ViewChildren</code> decorators are great tools to interact with in your view directly. It doesn't really matter whether you'd like to interact with a DOM element or a component instance. Both use cases are nicely covered using this declarative API.</p><p>Let's move back to our <code class="literal">Editor</code> component code. The next thing we're going to look into are the component's input functions:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>@Input() content;</strong></span>
<span class="strong"><strong>@Input() @HostBinding('class.editor--edit-mode') editMode;</strong></span>
<span class="strong"><strong>@Input() showControls;</strong></span>
</pre></div><p>The <code class="literal">content</code> input property is the main interface for interacting with the component from outside. Using property bindings, we can have any preexisting text content set up in the editor component.</p><p>The <code class="literal">editMode</code> property is a Boolean value that controls whether the editor is in edit or display mode. Our editor component will depend on this flag to know whether content should be edited or not. This allows us to switch from read-only mode to edit mode and back interactively.</p><p>Though an input property, this <a id="id180" class="indexterm"/>flag can be controlled from outside the component. At the same time, it can also be used to create property binding of a host element. Specifically, we can use the flag to create a class attribute binding to add or remove the modifier class, <code class="literal">editor--edit-mode</code>. This class is used to control some differences in the visual appearance of the editor while in edit mode.</p><p>The last of the three input properties in our editor component, <code class="literal">showControls</code>, controls whether the editor should show the control functions. There are three controls that will be shown when this property evaluates to a true value:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Edit button</strong></span>: This will be shown when the component is in display mode, and it will switch the component to edit mode using the <code class="literal">editMode</code> flag.</li><li class="listitem"><span class="strong"><strong>Save button</strong></span>: This will be shown only if the component is in edit mode. This control will save the changes applied within the current edit mode and switch the component back to display mode.</li><li class="listitem"><span class="strong"><strong>Cancel button</strong></span>: This is the same as the save button, and this control is shown only when the component is in edit mode. If activated, the component will switch back to display mode, reverting any changes that you may have made.</li></ul></div><p>Besides our input properties, we also need some output properties to notify the outer world about the changes within our editor. The following piece of code helps us do this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>@Output() editSaved = new EventEmitter();</strong></span>
<span class="strong"><strong>@Output() editableInput = new EventEmitter();</strong></span>
</pre></div><p>The <code class="literal">editSaved</code> event will be emitted once the edited content is saved using the save button control. Also, it'll be better if an event is emitted upon every input change within our editable content element. For this, we used the <code class="literal">editableInput</code> output property.</p><p>Our editor component works in a simple way. If the component is in edit mode, it shows an element that can be edited. However, once the editor switches back to display mode, we see a different element that cannot be edited. The visibility is controlled with the modifier class set by the host element property binding to the <code class="literal">editMode</code> flag.</p><p>Angular has no control over the content within our editable element. We control this content manually by using native DOM operations. Let's look at how we did this. First of all, we needed to use delegates to access the element, since we're most likely going to change how we will read <a id="id181" class="indexterm"/>and write to and from the editable element. We used the following to do this:</p><div class="informalexample"><pre class="programlisting">getEditableContent() {
  return <span class="strong"><strong>this.editableContentElement.nativeElement.textContent;</strong></span>
   }

setEditableContent(content) {
  <span class="strong"><strong>this.editableContentElement.nativeElement.textContent</strong></span> = 
    content;
}</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip11"/>Tip</h3><p>Note that we used the <code class="literal">nativeElement</code> property on our <code class="literal">editableContentElement</code> field, previously set by the <code class="literal">@ViewChild</code> decorator.</p></div><p>Angular does not directly provide us with a DOM element reference but a wrapper object of the type <code class="literal">ElementRef</code>. It's basically a wrapper around the native DOM element, holding additional information that is relevant to Angular.</p><p>Using the <code class="literal">nativeElement</code> accessor, we can obtain a reference to the underlying DOM element.</p><div class="note" title="Note"><h3 class="title"><a id="note08"/>Note</h3><p>The <code class="literal">ElementRef</code> wrapper plays an important part in Angular's platform-agnostic architecture. It allows you to run Angular in different environments (for example, native mobile, web workers, or others). It's part of an abstraction layer between the components and their views.</p></div><p>We also needed a way to set the content of the editable element based on the input that we would receive from the content input property. We could use the life cycle hook <code class="literal">OnInit</code>, which will be called only after the input properties are checked upon component initialization. However, this life cycle hook fires only once after the initialization, and we needed a way that would have helped us react to subsequent input changes of the <code class="literal">content</code> property. Have a look at the following code snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ngOnChanges() {</strong></span>
<span class="strong"><strong>  if (this.editableContentElement &amp;&amp; this.content) {</strong></span>
<span class="strong"><strong>    this.setEditableContent(this.content);</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><p>The <code class="literal">OnChanges</code> life cycle hook is exactly what we needed here. With this, once a change in the content input property is detected (this also includes the first change after the initialization), we can reflect the changed content onto our editable element.</p><p>Now we have already implemented the reflection of the component content input property onto the editable field. But what about the opposite direction? We need to find a way to reflect the changes in our editable element onto our component <code class="literal">content</code> property. That's also closely related to the actions performed on the component using the available controls within edit <a id="id182" class="indexterm"/>mode, which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>In the save operation</strong></span>: Here, we reflect the edited content from the editable element back to the component's <code class="literal">content</code> property.</li><li class="listitem"><span class="strong"><strong>In the cancel operation</strong></span>: Here, we ignore what has been edited by the user within the editable element and set its content back to the value in the component's <code class="literal">content</code> property:</li></ul></div><p>Let's look at the code for those two operations:</p><div class="informalexample"><pre class="programlisting">save() {
<span class="strong"><strong>  this.editSaved.next(this.getEditableContent());</strong></span>
<span class="strong"><strong>  this.setEditableContent(this.content);</strong></span>
  this.editMode = false;
}

cancel() {
<span class="strong"><strong>  this.setEditableContent(this.content);</strong></span>
<span class="strong"><strong>  this.editableInput.next(this.getEditableContent());</strong></span>
  this.editMode = false;
}</pre></div><p>In addition to the highlighted code, which shows the reflection between the component's <code class="literal">content</code> property and the editable element, we emitted certain events that would help us notify the outside world about the changes. In both the operations, we set the <code class="literal">editMode</code> flag to <code class="literal">false</code> after completion. This ensures that our editor will switch to display mode after any one of the operations is completed.</p><p>The <code class="literal">edit</code> method will be called from the edit control button when the component is in display mode. The only thing it does is that it switches the component back to edit mode:</p><div class="informalexample"><pre class="programlisting">edit() {
<span class="strong"><strong>  this.editMode = true;</strong></span>
}</pre></div><p>Whatever we've discussed thus far in relation to the code is good enough for us to set up a fully functional component. However, the last part of the code, which we haven't discussed yet, relates to ensuring better accessibility of our editor. Since our editor component is a bit larger than the editable element, we also want to make sure that a click anywhere inside the editor component will cause the editable element to be focused. The following code makes this happen:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>@HostListener('click')</strong></span>
focusEditableContent() {
  if (this.editMode) {
<span class="strong"><strong>    this.editableContentElement.nativeElement.focus();</strong></span>
  }
}</pre></div><p>Using the <code class="literal">@HostListener</code> decorator, we registered an event binding on our component element that called the <code class="literal">focusEditableContent</code> method. Inside this method, we used the reference to the editable DOM element and triggered a focus.</p><p>Let's look at the <a id="id183" class="indexterm"/>template of our component that is located within the <code class="literal">editor.html</code> file in order to see how we could interact with the logic within our component:</p><div class="informalexample"><pre class="programlisting">&lt;div (input)="onInput($event)"
     class="editor__editable-content"
     contenteditable="true"
<span class="strong"><strong>     #editableContentElement</strong></span>&gt;&lt;/div&gt;
&lt;div class="editor__output"&gt;{{content}}&lt;/div&gt;
&lt;div <span class="strong"><strong>*ngIf="showControls &amp;&amp; !editMode"</strong></span> class="editor__controls"&gt;
  &lt;button <span class="strong"><strong>(click)="edit()"</strong></span> class="editor__icon-edit"&gt;&lt;/button&gt;
&lt;/div&gt;
&lt;div <span class="strong"><strong>*ngIf="showControls &amp;&amp; editMode"</strong></span> class="editor__controls"&gt;
  &lt;button <span class="strong"><strong>(click)="save()"</strong></span> class="editor__icon-save"&gt;&lt;/button&gt;
  &lt;button <span class="strong"><strong>(click)="cancel()"</strong></span> class="editor__icon-cancel"&gt;&lt;/button&gt;
&lt;/div&gt;</pre></div><p>The logic within the editor component template is quite straightforward. If you've been following the component code, you'll now be able to identify the different elements that compose this component's view.</p><p>The first element with the <code class="literal">editor__editable-content</code> class is our editable element that has the <code class="literal">contenteditable</code> attribute. The user will be able to type into this element when the editor is in edit mode. It's important to note that we've annotated it with a local view variable reference, <code class="literal">#editableContentElement</code>, which we're using in our view child queries.</p><p>The second element with the <code class="literal">editor__output</code> class is only to display the editor content and is only visible when the editor is in display mode. The visibility of both the elements is controlled using CSS, based on the <code class="literal">editor--edit-mode</code> modifier class, which, if you recall from the component class code, is set through host property binding based on the <code class="literal">editMode</code> property.</p><p>The three control buttons are shown using the <code class="literal">NgIf</code> directive conditionally. The <code class="literal">showControls</code> input property needs to be <code class="literal">true</code>, and depending on the <code class="literal">editMode</code> flag, the screen will either show the edit button or the save and the cancel button:</p><div class="mediaobject"><img src="../Images/image00316.jpeg" alt="Creating an editor component"/><div class="caption"><p>Screenshot of our editor component in action</p></div></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Recap"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec28"/>Recap</h2></div></div></div><p>Within this building block, we have created an in-place editor widget, which we can use to grab user input for any content within our application. It allows us to provide the user with contextual editing capabilities, which will result in a great user experience.</p><p>We have also learned about the <a id="id184" class="indexterm"/>following topics:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Using <code class="literal">contenteditable</code> HTML5 attribute to enable in-place editing.</li><li class="listitem">Using <code class="literal">@ViewChild</code> and <code class="literal">@ViewChildren</code> to query view child elements.</li><li class="listitem">Using the <code class="literal">ElementRef</code> dependency to perform native DOM operations.</li><li class="listitem">Implementing the logic, using the <code class="literal">OnChange</code> life cycle hook, to reflect data between Angular and the content that is not in immediate control of Angular.</li></ol><div style="height:10px; width: 1px"/></div></div></div></div>
<div class="section" title="Building a commenting system"><div class="titlepage" id="aid-1394Q2"><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Building a commenting system</h1></div></div></div><p>In the previous topic, we <a id="id185" class="indexterm"/>created an editor component that will support users in editing content within our application. Here, we're going to create a commenting system that will enable users to write comments in various areas of our application. The commenting system will use our editor component to make comments editable, and thereby help users create new comments:</p><div class="mediaobject"><img src="../Images/image00317.jpeg" alt="Building a commenting system"/><div class="caption"><p>An illustration of the component sub-tree of a commenting system</p></div></div><p style="clear:both; height: 1em;"> </p><p>The preceding diagram <a id="id186" class="indexterm"/>illustrates the architecture of the component tree within the commenting system that we are about to create.</p><p>The <code class="literal">Comments</code> component will be responsible for listing all the existing comments, as well as creating new comments.</p><p>Each comment itself is encapsulated into a <code class="literal">Comment</code> component. <code class="literal">Comment</code> components themselves use an editor that enables users to edit comments once they are created.</p><p>The <code class="literal">Editor</code> component, which we built in the previous topic, is used by the <code class="literal">Comment</code> component directly, to provide an input control for adding new comments. This allows us to reuse the functionality of our editor component to capture user input.</p><p>The <code class="literal">Editor</code> component emits an <code class="literal">editSaved</code> event once editable content is saved using the control buttons of the editor. In the <code class="literal">Comment</code> component, we will capture these events and propagate a new event upward to our <code class="literal">Comments</code> component. There, we will do the necessary updates but then again emit a new event to notify our parent about the change. In a composition of components, each component will react on change and delegate to the parent component if necessary.</p><div class="section" title="Building the comment component"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec29"/>Building the comment component</h2></div></div></div><p>Let's start <a id="id187" class="indexterm"/>building our commenting system by fleshing out the <code class="literal">Comment</code> component first. In addition to the comment itself, we'd like to display the user's profile who commented, and of course, the time of the comment.</p><p>To display the time, we will make use of relative time formatting, as this will give our users a better feel of time. Relative time formatting displays timestamps in the format "5 minutes ago" or "1 month ago", in contrast to absolute timestamps, such as "25.12.2015 18:00". Using the <code class="literal">Moment.js</code> library, we'll create a pipe that we can use within component <a id="id188" class="indexterm"/>templates to convert timestamps and dates into relative time intervals.</p><p>Let's create a new pipe within a new folder named <code class="literal">pipes</code>. The pipe needs to be created within a file named <code class="literal">from-now.js</code>, which is created under the <code class="literal">pipes</code> folder:</p><div class="informalexample"><pre class="programlisting">import {Pipe} from '@angular/core';
// We use the Moment.js library to convert dates to relative times
<span class="strong"><strong>import Moment from 'moment';</strong></span>

@Pipe({
  // Specifying the name to be used within templates
<span class="strong"><strong>  name: 'fromNow'</strong></span>
})
// Our pipe will transform dates and timestamps to relative times 
// using Moment.js
export class FromNowPipe {
  // The transform method will be called when the pipe is used 
  // within a template
  <span class="strong"><strong>transform(value) {</strong></span>
<span class="strong"><strong>    if (value &amp;&amp; (value instanceof Date || </strong></span>
<span class="strong"><strong>        typeof value === 'number')) {</strong></span>
<span class="strong"><strong>      return new Moment(value).fromNow();</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>This pipe can now be used within the templates of components to format timestamps and dates into relative time intervals.</p><p>Let's use this pipe and the <code class="literal">Editor</code> component we created in the previous topic to create our <code class="literal">Comment</code> component. Within a file named <code class="literal">comment.html</code>, which is located within a new <code class="literal">comment</code> folder in the <code class="literal">comments</code> folder, we'll create the template for our <code class="literal">Comment</code> component:</p><div class="informalexample"><pre class="programlisting">&lt;div class="comment__l-meta"&gt;
  &lt;div class="comment__user-picture"&gt;
    &lt;img <span class="strong"><strong>[attr.src]="user.pictureDataUri"</strong></span> src=""&gt;
  &lt;/div&gt;
  &lt;div class="comment__user-name"&gt;<span class="strong"><strong>{{user.name}}</strong></span>&lt;/div&gt;
  &lt;div class="comment__time"&gt;
<span class="strong"><strong>    {{time | fromNow}}</strong></span>
  &lt;/div&gt;
&lt;/div&gt;
&lt;div class="comment__l-main"&gt;
  &lt;div class="comment__message"&gt;
<span class="strong"><strong>    &lt;ngc-editor [content]="content"</strong></span>
<span class="strong"><strong>                [showControls]="true"</strong></span>
<span class="strong"><strong>                (editSaved)="onContentSaved($event)"&gt;</strong></span>
<span class="strong"><strong>    &lt;/ngc-editor&gt;</strong></span>
  &lt;/div&gt;
&lt;/div&gt;</pre></div><p>From the user object, we will get the user's profile image as well as the username. To display the time of the comment in a relative format, we'll use the <code class="literal">fromNow</code> pipe that we created earlier.</p><p>Finally, we will make use of the in-place editor component to display the content of the comment and make it editable at the same time. We will bind the comment content property to the <a id="id189" class="indexterm"/>content input property of the editor. At the same time, we will listen for the <code class="literal">editSaved</code> event of the editor and call the <code class="literal">onContentSaved</code> method on our comment component class. If you look at our component code again, you'll notice that we are re-emitting the event within the method so that the outside world is also notified about the change in the comment.</p><p>Let's take a look at the component class that we will create in a file named <code class="literal">comment.js</code>:</p><div class="informalexample"><pre class="programlisting">import {Component, Input, Output, ViewEncapsulation, EventEmitter} from '@angular/core';
<span class="strong"><strong>import {Editor} from '../../ui/editor/editor';</strong></span>
import template from './comment.html!text';
// We use our fromNow pipe that converts timestamps to relative 
// times
<span class="strong"><strong>import {FromNowPipe} from '../../pipes/from-now';</strong></span>

@Component({
  selector: 'ngc-comment',
  host: {
    class: 'comment'
  },
  template,
  encapsulation: ViewEncapsulation.None,
<span class="strong"><strong>  directives: [Editor],</strong></span>
<span class="strong"><strong>  pipes: [FromNowPipe]</strong></span>
})
export class Comment {
  // The time of the comment as a timestamp
  @Input() time;
  // The user object of the user who created the comment
  @Input() user;
  // The comment content
  @Input() content;
  // If a comment was edited this event will be emitted
<span class="strong"><strong>  @Output() commentEdited = new EventEmitter();</strong></span>

<span class="strong"><strong>  onContentSaved(content) {</strong></span>
<span class="strong"><strong>    this.commentEdited.next(content);</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>The component code is pretty straightforward. The only noticeable difference to other components we've created so far is the <code class="literal">pipes</code> property within the component's annotation. Here, we specify that we'd like to use the <code class="literal">FromNowPipe</code> class that we've just created. Pipes always need to be declared within the component; otherwise, they can't be used within the component's template.</p><p>As input, we <a id="id190" class="indexterm"/>expect a user object that is passed along with the <code class="literal">user</code> input property. The <code class="literal">content</code> input property should be filled with the actual comment as a string, while the <code class="literal">time</code> input property should be set to a timestamp that reflects the actual time of the comment.</p><p>We also have an output property called <code class="literal">commentEdited</code>, which we will use to notify the changes on the comment. The <code class="literal">onEditSaved</code> method will be called by the event binding on our <code class="literal">Editor</code> component, which will then emit an event using the <code class="literal">commentEdited</code> output property.</p></div><div class="section" title="Building the comments component"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec30"/>Building the comments component</h2></div></div></div><p>We now have <a id="id191" class="indexterm"/>all the components ready in order to finish building our commenting system. The last missing piece of the puzzle is the <code class="literal">Comments</code> component, which will list all the comments and provide an editor to create new comments.</p><p>First, let's take a look at the template of our <code class="literal">Comments</code> component that we will create in a file named <code class="literal">comments.html</code> within a folder named <code class="literal">comments</code>:</p><div class="informalexample"><pre class="programlisting">&lt;div class="comments__title"&gt;Add new comment&lt;/div&gt;
&lt;div class="comments__add-comment-section"&gt;
  &lt;div class="comments__add-comment-box"&gt;
<span class="strong"><strong>    &lt;ngc-editor [editMode]="true"</strong></span>
<span class="strong"><strong>                [showControls]= "false"&gt;&lt;/ngc-editor&gt;</strong></span>
  &lt;/div&gt;
  &lt;button <span class="strong"><strong>(click)="addNewComment()"</strong></span>
          class="button" &gt;Add comment&lt;/button&gt;
&lt;/div&gt;

&lt;div <span class="strong"><strong>*ngIf="comments?.length &gt; 0"</strong></span>&gt;
  &lt;div class="comments__title"&gt;All comments&lt;/div&gt;
  &lt;ul class="comments__list"&gt;
    &lt;li <span class="strong"><strong>*ngFor="let comment of comments"</strong></span>&gt;
      <span class="strong"><strong>&lt;ngc-comment [content]="comment.content"</strong></span>
<span class="strong"><strong>              [time]="comment.time"</strong></span>
<span class="strong"><strong>              [user]="comment.user"</strong></span>
<span class="strong"><strong>              (commentEdited)="onCommentEdited(comment, $event)"&gt;</strong></span>
<span class="strong"><strong>      &lt;/ngc-comment&gt;</strong></span>
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;</pre></div><p>You can see the direct usage of an <code class="literal">Editor</code> component within the component's template. We are using this in-place editor to provide an input component to create new comments. We could also use a text area here, but we've decided to reuse our <code class="literal">Editor</code> component. We will set the <code class="literal">editMode</code> property to true so it will be initialized in edit mode. We will also set the <code class="literal">showControls</code> input to <code class="literal">false</code> because we don't want the editor to become autonomous. We will only use its in-place editing capabilities, but control it from our <code class="literal">Comments</code> component.</p><p>To add a new <a id="id192" class="indexterm"/>comment, we will use a button that has a click event binding, which calls the <code class="literal">addNewComment</code> method on our component class.</p><p>Below the section where users can add new comments, we will create another section that will list all the existing comments. If no comments exist, we simply don't render the section. With the help of the <code class="literal">NgFor</code> directive, we could display all the existing comments and create a <code class="literal">Comment</code> component for each repetition. We will bind all the comment data properties to our <code class="literal">Comment</code> component and also add an event binding to handle updated comments.</p><p>Let's create the component class within a new file named <code class="literal">comments.js</code> in the <code class="literal">comments</code> folder:</p><div class="informalexample"><pre class="programlisting">import {Component, Inject, Input, Output, ViewEncapsulation, ViewChild, EventEmitter} from '@angular/core';
import template from './comments.html!text';
<span class="strong"><strong>import {Editor} from '../ui/editor/editor';</strong></span>
<span class="strong"><strong>import {Comment} from './comment/comment';</strong></span>
<span class="strong"><strong>import {UserService} from '../user/user-service/user-service';</strong></span>

@Component({
  selector: 'ngc-comments',
  host: {
    class: 'comments'
  },
  template,
  encapsulation: ViewEncapsulation.None,
<span class="strong"><strong>  directives: [Comment, Editor]</strong></span>
})
export class Comments {
  // A list of comment objects
<span class="strong"><strong>  @Input() comments;</strong></span>
  // Event when the list of comments have been updated
<span class="strong"><strong>  @Output() commentsUpdated = new EventEmitter();</strong></span>
  // We are using an editor for adding new comments and control it 
  // directly using a reference
<span class="strong"><strong>  @ViewChild(Editor) newCommentEditor;</strong></span>

  // We're using the user service to obtain the currently logged 
  // in user
  constructor(<span class="strong"><strong>@Inject(UserService) userService</strong></span>) {
    this.userService = userService;
  }

  // We use input change tracking to prevent dealing with 
  // undefined comment list
<span class="strong"><strong>  ngOnChanges(changes) {</strong></span>
<span class="strong"><strong>    if (changes.comments &amp;&amp; </strong></span>
<span class="strong"><strong>        changes.comments.currentValue === undefined) {</strong></span>
<span class="strong"><strong>      this.comments = [];</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>  }</strong></span>

  // Adding a new comment from the newCommentContent field that is 
  // bound to the editor content
  addNewComment() {
    const comments = this.comments.slice();
    comments.splice(0, 0, {
<span class="strong"><strong>      user: this.userService.currentUser,</strong></span>
      time: +new Date(),
<span class="strong"><strong>      content: this.newCommentEditor.getEditableContent()</strong></span>
    });
    // Emit event so the updated comment list can be persisted 
    // outside the component
<span class="strong"><strong>    this.commentsUpdated.next(comments);</strong></span>
    // We reset the content of the editor
<span class="strong"><strong>    this.newCommentEditor.setEditableContent('');</strong></span>
  }

  // This method deals with edited comments
  onCommentEdited(comment, content) {
    const comments = this.comments.slice();
    // If the comment was edited with e zero length content, we 
    // will delete the comment from the list
    if (content.length === 0) {
      comments.splice(comments.indexOf(comment), 1);
    } else {
      // Otherwise we're replacing the existing comment
      comments.splice(comments.indexOf(comment), 1, {
        user: comment.user,
        time: comment.time,
        content
      });
    }
    // Emit event so the updated comment list can be persisted 
    // outside the component
<span class="strong"><strong>    this.commentsUpdated.next(comments);</strong></span>
  }
}</pre></div><p>Let's go through <a id="id193" class="indexterm"/>individual code parts again and discuss what each of them does. First, we declared an input property named <code class="literal">comments</code> in our component class:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>@Input() comments;</strong></span>
</pre></div><p>The <code class="literal">comments</code> input property is a list of comment objects that contains all of the data associated with the comments. This includes the user who authored the comment and the timestamp, as well as the content of the comment.</p><p>We also need to be able to emit an event once a comment is added or an existing comment is modified. For this purpose, we used an output property named <code class="literal">commentsUpdates</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>@Output() commentsUpdated = new EventEmitter();</strong></span>
</pre></div><p>Once a new comment is added or an existing one is modified, we will emit an event from this output property with the updated list of comments.</p><p>The <code class="literal">Editor</code> component we're going to use to add new comments will not have its own control buttons. We will use the <code class="literal">showControls</code> input property to disable them. Instead, we will control the editor from our <code class="literal">Comments</code> component directly. Therefore, we need a way to communicate with the <code class="literal">Editor</code> component within our component class.</p><p>We used the <code class="literal">@ViewChild</code> decorator for this purpose again. However, this time, we did not reference a DOM element, which contains a local view variable reference. We directly passed our component type class to the decorator. Angular will search for any <code class="literal">Editor</code> components within the comments view and provide us with a reference to the instance of the editor. This is shown in the following line of code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>@ViewChild(Editor) newCommentEditor;</strong></span>
</pre></div><p>Since the <code class="literal">Comments</code> component only hosts one editor directly within the component template, we can use the <code class="literal">@ViewChild</code> annotation to obtain a reference to it. Using this reference, we can directly interact with the child component. This will allow us to control the editor directly from our <code class="literal">Comments</code> component.</p><p>Let's move on to the <a id="id194" class="indexterm"/>next part of the code, which is the <code class="literal">Comments</code> component constructor. The only thing we've done here is inject a user service that will provide us with a way to obtain information of the currently logged-in user. As of now, this functionality is only mocked, and we will receive information of a dummy user. We need this information in the <code class="literal">Comments</code> component, since we need to know which user has actually entered a new comment:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>constructor(@Inject(UserService) userService) {</strong></span>
<span class="strong"><strong>  this.userService = userService;</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><p>In the next part of the code, we controlled how we should react to the changes of the <code class="literal">comments</code> input property. Actually, we would never want the list of comments to remain undefined. It should be an empty list in case there are no comments, but the input property comments should never be undefined. We controlled this by using the <code class="literal">OnChange</code> life cycle hook and overriding our <code class="literal">comments</code> property if it was set to <code class="literal">undefined</code> from outside:</p><div class="informalexample"><pre class="programlisting">ngOnChanges(changes) {
  if (changes.comments &amp;&amp; 
          <span class="strong"><strong>changes.comments.currentValue === undefined</strong></span>) {
    <span class="strong"><strong>this.comments = [];</strong></span>
  }
}</pre></div><p>This small change makes the internal handling of our comment data much cleaner. We don't need additional checks when working for array transformation functions, and we can always treat the <code class="literal">comments</code> property as an array.</p><p>Since the <code class="literal">Comments</code> component is also responsible for handling the logic that deals with the process of adding new comments, we needed a method that could implement this requirement. In relation to this, we used some immutable practices we learned about in the previous chapter:</p><div class="informalexample"><pre class="programlisting">addNewComment() {
  const comments = this.comments.slice();
  comments.splice(0, 0, {
<span class="strong"><strong>    user: this.userService.currentUser,</strong></span>
    time: +new Date(),
<span class="strong"><strong>    content: this.newCommentEditor.getEditableContent()</strong></span>
  });
<span class="strong"><strong>  this.commentsUpdated.next(comments);</strong></span>
<span class="strong"><strong>  this.newCommentEditor.setEditableContent('');</strong></span>
}</pre></div><p>There are a few <a id="id195" class="indexterm"/>key aspects in this part of the code. This method will be called from our component view when the <code class="literal">Add comment</code> button is clicked. This is when the user will have already entered some text into the editor and a new comment will have been created.</p><p>First, we will use the user service that we injected within the constructor to obtain information related to the currently logged-in user. The content of the newly created comment will be obtained directly from the <code class="literal">Editor</code> component we set up using the <code class="literal">@ViewChild</code> annotation. And, the <code class="literal">getEditableContent</code> method will allow us to receive the content of the editable element within the in-place editor.</p><p>The next thing we wanted to do was to communicate an update of the comment list with the outside world. We used the <code class="literal">commentsUpdated</code> output property to emit an event with the updated comment list.</p><p>Finally, we wanted to clear the editor used to add new comments. As the in-place editor in the view of the <code class="literal">Comments</code> component is only used to add new comments, we can always clear it after a comment is added. This will give the user the impression that his comment has been moved from the editor into the list of comments. Then, once again, we can access the <code class="literal">Editor</code> component directly using our <code class="literal">newCommentEditor</code> property and call the <code class="literal">setEditableContent</code> method with an empty string to clear the editor. And this is what we've done here.</p><p>Our <code class="literal">Comments</code> component will hold the list of all the comments, and its view will create a <code class="literal">Comment</code> component for each comment in that list. Each <code class="literal">Comment</code> component will use an <code class="literal">Editor</code> component to provide in-place editing of its content. These editors work autonomously using their own controls, and they emit an event if the content is changed or altered in any way. To take care of this, we need to re-emit this event with the name <code class="literal">commentEdited</code> from the <code class="literal">Comment</code> component. Now we only need to catch this event within our <code class="literal">Comments</code> component in order to update the list of comments with the changes. This is illustrated in the following part of the code:</p><div class="informalexample"><pre class="programlisting">onCommentEdited(<span class="strong"><strong>comment, content</strong></span>) {
  const comments = this.comments.slice();
  if (content.length === 0) {
    comments.splice(<span class="strong"><strong>comments.indexOf(comment)</strong></span>, 1);
  } else {
    comments.splice(<span class="strong"><strong>comments.indexOf(comment)</strong></span>, 1, {
      user: comment.user,
      time: comment.time,
      <span class="strong"><strong>content</strong></span>
    });
  }
  <span class="strong"><strong>this.commentsUpdated.next(comments);</strong></span>
}</pre></div><p>This method will be called for each individual <code class="literal">Comment</code> component that is repeated using the <code class="literal">NgFor</code> directive. From the view, we pass a reference to the comment object concerned, as well as the edited content we would receive from the <code class="literal">Comment</code> component event.</p><p>The comment object will only be used to determine the position of the updated comment within the comment <a id="id196" class="indexterm"/>list. If the new comment content is empty, we will remove the comment from the list. Otherwise, we will just create a copy of the previous comment object, change the content with the new edited content, and replace the old comment object in the list with the copy.</p><p>Finally, since we wanted to communicate the change in the comment list, we emitted an event using the <code class="literal">commentUpdated</code> output property.</p><p>With this, we have completed our commenting system, and now it's time to make use of it. We already have an empty tab prepared for our project comments, and this is going to be the spot where we will add commenting capabilities using our commenting system.</p><p>First, let's amend our <code class="literal">Project</code> component template, <code class="literal">project/project.html</code>, to include the commenting system:</p><div class="informalexample"><pre class="programlisting">...
&lt;ngc-tabs&gt;
  &lt;ngc-tab name="Tasks"&gt;...&lt;/ngc-tab&gt;
  &lt;ngc-tab name="Comments"&gt;
<span class="strong"><strong>    &lt;ngc-comments [comments]="comments"</strong></span>
<span class="strong"><strong>                  (commentsUpdated)="updateComments($event)"&gt;</strong></span>
<span class="strong"><strong>    &lt;/ngc-comments&gt;</strong></span>
  &lt;/ngc-tab&gt;
  &lt;ngc-tab name="Activities"&gt;&lt;/ngc-tab&gt;
&lt;/ngc-tabs&gt;</pre></div><p>This is as easy as it gets. Since we are paying attention to a clean component architecture, the inclusion of our commenting system really works like a breeze. The only thing we now need to ensure is that we provide a property on our project with a list of comments. We also need a way to react to changes if comments are updated within our <code class="literal">Comments</code> component. For this purpose, we will create an <code class="literal">updateComments</code> method.</p><p>Let's look at the component class changes within the <code class="literal">project/project.js</code> file:</p><div class="informalexample"><pre class="programlisting">export class Project {
  ...
<span class="strong"><strong>  @Input() comments;</strong></span>
  ...
<span class="strong"><strong>    updateComments(comments) {</strong></span>
<span class="strong"><strong>      this.projectUpdated.next({</strong></span>
<span class="strong"><strong>        comments</strong></span>
<span class="strong"><strong>      });</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>Since we are already dealing with project updates in a general way and our <code class="literal">Project</code> component is emitting directly to our <code class="literal">App</code> component, where projects data will be persisted, the only thing <a id="id197" class="indexterm"/>we need to implement is an additional input property, as well as a method to handle comment updates:</p><div class="mediaobject"><img src="../Images/image00318.jpeg" alt="Building the comments component"/><div class="caption"><p>Screenshot of the commenting system integrated within our project component</p></div></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Recap"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec31"/>Recap</h2></div></div></div><p>Within this topic, we have successfully created a full-fledged commenting system that can be placed in various areas of our application to enable commenting. Users can interact with in-place editors to edit the content in comments, which gives them a great user experience.</p><p>While writing the code for our commenting system, we learned about the following topics:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Implementing a simple pipe using the <code class="literal">@Pipe</code> annotation and the <code class="literal">Moment.js</code> library to provide relative time formatting</li><li class="listitem">Using the <code class="literal">OnChanges</code> life cycle hook to prevent unwanted or invalid values within input properties</li><li class="listitem">Using <code class="literal">@ViewChild</code> to obtain a reference to the components within the component sub-tree in order to establish direct communication</li><li class="listitem">Reusing the <code class="literal">Editor</code> component as an input field replacement and as an autonomous in-place editor within the <code class="literal">Comment</code> component</li></ol><div style="height:10px; width: 1px"/></div></div></div>
<div class="section" title="Summary" id="aid-147LC1"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Summary</h1></div></div></div><p>In this chapter, we created a simple in-place editor that we can use for making content editable within our application. Going forward, we can use the <code class="literal">Editor</code> component wherever we want to make content editable for our users. They will not have to jump into nasty dialogs or separate configuration pages, but will be in a position to edit directly, as per their current context. This is a great tool for enhancing the user experience for our users.</p><p>Besides our shiny new <code class="literal">Editor</code> component, we created a whole commenting system that can be easily included in areas of our application where we'd like to provide commenting capabilities. We have now included the commenting system within our <code class="literal">Project</code> component, and users can now comment on projects by navigating to the <span class="strong"><strong>Comments</strong></span> tab on the project details.</p><p>In the next chapter, we'll use the component-based router of Angular to make our application navigable.</p></div></body></html>