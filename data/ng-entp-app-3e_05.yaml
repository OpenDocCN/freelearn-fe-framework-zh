- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Designing Authentication and Authorization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计认证和授权
- en: Designing a high-quality **authentication** and **authorization** system without
    frustrating the end user is a difficult problem to solve. Authentication is the
    act of verifying the identity of a user, and authorization specifies the privileges
    that a user must have to access a resource. Both processes, **auth** for short,
    must seamlessly work in tandem to address users’ needs with varying roles, needs,
    and job functions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个高质量且不会让最终用户感到沮丧的 **认证** 和 **授权** 系统是一个难以解决的问题。认证是验证用户身份的行为，授权指定用户必须拥有的访问资源的权限。这两个过程，简称
    **auth**，必须无缝协同工作，以满足具有不同角色、需求和职能的用户的需求。
- en: On today’s web, users have a high baseline level of expectations from any auth
    system they encounter through the browser, so this is an important part of your
    application to get right the first time. The user should always know what they
    can and can’t do in your application. If there are errors, failures, or mistakes,
    the user should be informed about why they occurred. As your application grows,
    it will be easy to miss how an error condition could be triggered. Your implementation
    should be easy to extend or maintain. Otherwise, this basic backbone of your application
    will require a lot of maintenance. In this chapter, we will walk through the challenges
    of creating a great auth UX and implementing a solid baseline experience.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的网络中，用户对任何通过浏览器遇到的认证系统都有很高的基线期望，因此这是您应用程序中一个重要的部分，需要第一次就做对。用户应该始终知道他们可以在您的应用程序中做什么以及不能做什么。如果有错误、失败或错误，用户应该被告知它们发生的原因。随着您的应用程序的增长，很容易错过错误条件可能被触发的机制。您的实现应该易于扩展或维护。否则，您应用程序的基本骨架将需要大量的维护。在本章中，我们将探讨创建出色的认证用户体验和实现坚实基础体验的挑战。
- en: In this chapter, we will implement a token-based auth scheme around the user
    entity defined in the last chapter. For a robust and maintainable implementation,
    we will deep dive into **Object-Oriented Programming** (**OOP**) with abstraction,
    inheritance, and factories, along with implementing a cache service, a UI service,
    and an in-memory fake auth service for testing and educational purposes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将围绕上一章定义的用户实体实现基于令牌的认证方案。为了实现健壮且易于维护的实现，我们将深入探讨面向对象编程（**OOP**），包括抽象、继承和工厂，同时实现一个缓存服务、一个
    UI 服务和一个内存中的模拟认证服务，用于测试和教育目的。
- en: 'In this chapter, we’re going to cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Designing an auth workflow
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计认证工作流程
- en: TypeScript operators for safe data handling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 的安全数据处理运算符
- en: Implementing data entities
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现数据实体
- en: Reusable services leveraging OOP concepts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用面向对象编程（OOP）概念的可重用服务
- en: Creating an auth service
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建认证服务
- en: A cache service using localStorage
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 localStorage 的缓存服务
- en: An in-memory auth service
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个内存中的认证服务
- en: Logout
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登出
- en: An HTTP interceptor
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 HTTP 拦截器
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The most up-to-date versions of the sample code for the book are on GitHub at
    the following linked repository. The repository contains the final and completed
    state of the code. You can verify your progress at the end of this chapter by
    looking for the end-of-chapter snapshot of code under the `projects` folder.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍的示例代码的最新版本可以在以下链接的 GitHub 仓库中找到。[https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)。该仓库包含代码的最终和完成状态。您可以在本章末尾通过查找
    `projects` 文件夹下的章节末尾代码快照来验证您的进度。
- en: 'For *Chapter 5*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *第五章*：
- en: Clone the repository [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆 [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
    仓库。
- en: Execute `npm install` on the root folder to install dependencies.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根目录下执行 `npm install` 以安装依赖项。
- en: 'The beginning state of the project is reflected at:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目的初始状态反映在：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The end state of the project is reflected at:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目的最终状态反映在：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the stage name to any `ng` command to act only on that stage:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将阶段名称添加到任何 `ng` 命令中，使其仅对该阶段生效：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that the `dist/stage8` folder at the root of the repository will contain
    the compiled result.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，存储库根目录下的 `dist/stage8` 文件夹将包含编译结果。
- en: Beware that the source code provided in the book and the version on GitHub are
    likely to be different. The ecosystem around these projects is ever-evolving.
    Between changes to how Angular CLI generates new code, bug fixes, new versions
    of libraries, and side-by-side implementations of multiple techniques, there’s
    a lot of variation that’s impossible to account for. If you find errors or have
    questions, please create an issue or submit a pull request on GitHub.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，书中提供的源代码和GitHub上的版本可能不同。围绕这些项目的生态系统一直在不断演变。由于Angular CLI生成新代码的方式的变化、错误修复、库的新版本以及多种技术的并行实现，存在许多难以预料的差异。如果您发现错误或有疑问，请创建一个GitHub上的问题或提交一个pull
    request。
- en: Let’s start by going over how a token-based auth workflow functions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先了解一下基于令牌的认证工作流程是如何工作的。
- en: Designing an auth workflow
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计认证工作流程
- en: A well-designed authentication workflow is stateless so that there’s no concept
    of an expiring session. Users can interact with your stateless REST APIs from
    as many devices and tabs as they wish, simultaneously or over time. A **JSON Web
    Token** (**JWT**) implements distributed claims-based authentication that can
    be digitally signed or information-protected and/or encrypted, using a **Message
    Authentication Code** (**MAC**). This means that once a user’s identity is authenticated
    (that is, a password challenge on a login form), they receive an encoded claim
    ticket or a token, which can then be used to make future requests to the system
    without having to reauthenticate the identity of the user.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个精心设计的认证工作流程是无状态的，因此没有会话过期的概念。用户可以从他们想要的任何设备和标签页中与您的无状态REST API交互，同时或分时进行。**JSON
    Web Token**（JWT）实现了基于声明的分布式认证，可以使用**消息认证码**（MAC）进行数字签名或信息保护以及/或加密。这意味着一旦用户的身份得到验证（即在登录表单上的密码挑战），他们就会收到一个编码的声明的票据或令牌，然后可以使用它来向系统发出未来的请求，而无需重新验证用户的身份。
- en: The server can independently verify the validity of this claim and process the
    requests without requiring prior knowledge of having interacted with this user.
    Thus, we don’t have to store session information regarding a user, making our
    solution stateless and easy to scale. Each token will expire after a predefined
    period, and due to their distributed nature, they can’t be remotely or individually
    revoked; however, we can bolster real-time security by interjecting custom account
    and user role status checks to ensure that the authenticated user is authorized
    to access server-side resources.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以独立验证这个声明的有效性，并处理请求，而无需事先知道是否与该用户交互过。因此，我们不需要存储有关用户的会话信息，这使得我们的解决方案是无状态的，易于扩展。每个令牌在预定义的期限后会过期，由于它们的分布式特性，它们不能远程或单独撤销；然而，我们可以通过插入自定义账户和用户角色状态检查来增强实时安全性，以确保认证用户有权访问服务器端资源。
- en: JWTs implement the **Internet Engineering Task Force** (**IETF**) industry standard
    RFC 7519, found at [https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: JWT实现了位于[https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)的**互联网工程任务组**（IETF）行业标准RFC
    7519。
- en: A good authorization workflow enables conditional navigation based on a user’s
    role, so users are automatically taken to the optimal landing screen; routes and
    UI elements that are not suitable for their roles should not be displayed, and
    if, by mistake, they try to access a restricted path, they should be prevented
    from doing so. You must remember that any client-side role-based navigation is
    merely a convenience and is not meant for security.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的授权工作流程允许根据用户的角色进行条件导航，这样用户就会被自动带到最佳的着陆页面；不适合他们角色的路由和UI元素不应显示，如果他们不小心尝试访问受限路径，应阻止他们这样做。您必须记住，任何客户端基于角色的导航仅仅是一种便利，并不用于安全。
- en: This means that every call made to the server should contain the necessary header
    information, with the secure token, so that the user can be reauthenticated by
    the server and their role independently verified. Only then will they be allowed
    to retrieve secured data. By its nature, client-side authentication can’t be trusted.
    All auth logic must be implemented server-side. Implementing password reset screens
    securely can be especially challenging, since they can be triggered within your
    web app or via a link embedded into an email/notification. When the modality of
    interaction increases, the attack surface grows with it. For this reason, I recommend
    building reset screens with server-side rendering so that both the user and the
    server can verify that the intended user is interacting with the system. If you’re
    implementing this client-side, you must ensure the server generates a time-limited,
    one-time-use-only token to pass alongside the new password so that you can be
    reasonably sure the request is legitimate. Next, let’s dive into how you can generate
    secure tokens.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每个发送到服务器的调用都应该包含必要的头信息，包括安全的令牌，以便服务器可以重新认证用户并独立验证其角色。只有在这种情况下，他们才能被允许检索受保护的数据。由于客户端认证的本质，它不能被信任。所有认证逻辑都必须在服务器端实现。安全地实现密码重置屏幕可能特别具有挑战性，因为它们可以在您的
    Web 应用程序内部触发或通过嵌入到电子邮件/通知中的链接触发。当交互模式增加时，攻击面也随之增长。因此，我建议使用服务器端渲染来构建重置屏幕，以便用户和服务器都可以验证预期的用户正在与系统交互。如果您在客户端实现此功能，您必须确保服务器生成一个时间有限的、一次性的令牌，以便与新的密码一起传递，这样您可以合理地确信请求是合法的。接下来，让我们深入了解如何生成安全的令牌。
- en: JWT life cycle
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JWT 生命周期
- en: 'JWTs complement a stateless REST API architecture with an encrypted token mechanism
    that allows convenient, distributed, and high-performance authentication and authorization
    of client requests. There are three main components of a token-based authentication
    scheme:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: JWTs 补充了无状态 REST API 架构，通过加密令牌机制，使得客户端请求的认证和授权变得方便、分布式且高性能。基于令牌的认证方案有三个主要组成部分：
- en: '**Client-side**: Captures login information and hides disallowed actions for
    a good UX.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：捕获登录信息并隐藏不允许的操作，以提供良好的用户体验。'
- en: '**Server-side**: Validates that every request is authenticated and has the
    proper authorization.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器端**：验证每个请求是否已认证并且具有适当的授权。'
- en: '**Auth service**: Generates and validates encrypted tokens and independently
    verifies the auth status of user requests from a data store.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证服务**：生成和验证加密令牌，并独立验证用户请求的认证状态，这些请求来自数据存储。'
- en: A secure system presumes that data sent/received between clients (applications
    and browsers), systems (servers and services), and databases are encrypted using
    **Transport Layer Security** (**TLS**), which is essentially a newer version of
    the **Secure Sockets Layer** (**SSL**). Your REST API must be hosted with a properly
    configured SSL certificate, serving all API calls over HTTPS so that user credentials
    are never exposed between the client and the server. Similarly, any database or
    third-party service call should happen over TLS. This ensures the security of
    the data in transit.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一个安全的系统假定客户端（应用程序和浏览器）、系统（服务器和服务）以及数据库之间发送/接收的数据都使用 **传输层安全性**（**TLS**）进行加密，这本质上是一个
    **安全套接字层**（**SSL**）的新版本。您的 REST API 必须使用正确配置的 SSL 证书托管，通过 HTTPS 提供所有 API 调用，以确保用户凭证在客户端和服务器之间不会被暴露。同样，任何数据库或第三方服务调用也应通过
    TLS 进行。这确保了传输中数据的安全性。
- en: At rest (when data is in a database), passwords should be stored using a secure
    one-way hashing algorithm with good salting practices.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在静止状态（数据存储在数据库中时），应使用安全的单向哈希算法和良好的盐值实践来存储密码。
- en: 'Did all the talk of hashing and salting make you think of breakfast? Unfortunately,
    they’re cryptography-related terms. If you want to learn more, check out this
    article: [https://crackstation.net/hashing-security.htm](https://crackstation.net/hashing-security.htm).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的哈希和盐值讨论让你想起了早餐吗？不幸的是，它们是密码学相关的术语。如果你想了解更多，可以查看这篇文章：[https://crackstation.net/hashing-security.htm](https://crackstation.net/hashing-security.htm)。
- en: Sensitive user information, such as **Personally Identifiable Information**
    (**PII**), should be encrypted at rest with a secure two-way encryption algorithm,
    unlike passwords. Passwords are hashed, so we verify that the user is providing
    the same password without the system knowing what the password is. With PII, we
    must be able to decrypt data to display it to the user. However, since the data
    is encrypted at rest, if the database is compromised, then the hacked data is
    worthless.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于敏感用户信息，如 **个人身份信息**（**PII**），应使用安全的双向加密算法在静止状态下加密，与密码不同。密码是经过散列的，因此我们验证用户提供的密码是否与系统所知的密码相同。对于
    PII，我们必须能够解密数据以将其显示给用户。然而，由于数据在静止状态下加密，如果数据库被破坏，那么被黑客窃取的数据将毫无价值。
- en: Following a layered approach to security is critical, as attackers will need
    to accomplish the unlikely feat of compromising all layers of your security simultaneously
    to cause meaningful harm to your business.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 采取分层的安全方法至关重要，因为攻击者需要完成同时破坏你安全所有层的不太可能的事情，以对你的业务造成实质性伤害。
- en: '**Fun fact**: When you hear about massive data breaches from major corporations,
    the root cause is a lack of proper implementation of in-transit or at-rest security.
    Sometimes, this is because it is too computationally expensive to continually
    encrypt/decrypt data, so engineers rely on being behind firewalls. In that case,
    once the outer perimeter is breached, as they say, the fox has access to the hen
    house.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**有趣的事实**：当你听到来自大型公司的重大数据泄露事件时，其根本原因往往是缺乏对传输中或静止状态安全性的适当实施。有时，这是因为持续加密/解密数据计算成本过高，因此工程师依赖于防火墙的保护。在这种情况下，一旦外围被突破，正如他们所说，狐狸就进入了鸡舍。'
- en: 'Consider the following sequence diagram, which highlights the life cycle of
    JWT-based authentication:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下序列图，它突出了基于 JWT 的认证生命周期：
- en: '![](img/B20960_05_01.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B20960_05_01.png)'
- en: 'Figure 5.1: The life cycle of JWT-based authentication'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：基于 JWT 的认证生命周期
- en: Initially, a user logs in by providing their username and password. Once validated,
    the user’s authentication status and role are encrypted in a JWT with an expiration
    date and time, and it is sent back to the browser.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，用户通过提供用户名和密码进行登录。一旦验证通过，用户的认证状态和角色将被加密在一个带有过期日期和时间的 JWT 中，并将其发送回浏览器。
- en: Our Angular (or any other) application can cache this token in local or session
    storage securely so that the user isn’t forced to log in with every request. This
    way, we don’t resort to insecure practices like storing user credentials in cookies
    to provide a good UX.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序（Angular 或其他）可以安全地将此令牌缓存到本地或会话存储中，这样用户就不必在每次请求时都强制登录。这样，我们就不必采取像在 cookies
    中存储用户凭据这样的不安全做法，以提供良好的用户体验。
- en: Our technical reviewer, Jurgen Van de Moere, points out that cookies don’t necessarily
    have to be insecure.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的技术审稿人 Jurgen Van de Moere 指出，cookies 并不一定是不可靠的。
- en: See [https://www.youtube.com/watch?v=9ZOpUtQ_4Uk](https://www.youtube.com/watch?v=9ZOpUtQ_4Uk)
    by Philippe De Ryck, explaining how cookies can be a valid mechanism to store
    a JWT token in specific cases.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 [https://www.youtube.com/watch?v=9ZOpUtQ_4Uk](https://www.youtube.com/watch?v=9ZOpUtQ_4Uk)
    由 Philippe De Ryck 撰写的视频，解释在特定情况下 cookies 可以是一个有效的机制来存储 JWT 令牌。
- en: 'You will get a better understanding of the JWT life cycle when you implement
    your own auth service later in this chapter. In the following sections, we will
    design a fully featured auth workflow around the **User** data entity as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在本章后面实现自己的认证服务时，你会更好地理解 JWT 生命周期。在接下来的几节中，我们将围绕 **用户** 数据实体设计一个功能齐全的认证工作流程，如下所示：
- en: '![](img/B20960_05_02.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B20960_05_02.png)'
- en: 'Figure 5.2: The User entity'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：用户实体
- en: The **User** entity described is slightly different from our initial entity
    model. The entity model reflects how data is stored in the database.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 描述的 **用户** 实体与我们最初的实体模型略有不同。实体模型反映了数据在数据库中的存储方式。
- en: The entity is a flattened (or simplified) representation of the user record.
    Even a flattened entity has complex objects, like a **name**, with properties
    like first, middle, and last. Furthermore, not all properties are required. Additionally,
    when interacting with auth systems and other APIs, we may receive incomplete,
    incorrect, or maliciously formed data, so our code must effectively deal with
    `null` and `undefined` variables.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 实体是用户记录的扁平化（或简化）表示。即使是一个扁平化的实体也包含复杂对象，如 **姓名**，具有首字母、中间名和姓氏等属性。此外，并非所有属性都是必需的。此外，在与认证系统和其他
    API 交互时，我们可能会收到不完整、错误或恶意构造的数据，因此我们的代码必须有效地处理 `null` 和 `undefined` 变量。
- en: Next, let’s see how we can leverage TypeScript operators to effectively deal
    with unexpected data.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何利用 TypeScript 运算符有效地处理意外数据。
- en: TypeScript operators for safe data handling
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript 的安全数据处理运算符
- en: JavaScript is a dynamically typed language. At runtime, the JavaScript engine
    executing our code, like Chrome’s V8, doesn’t know the type of variable we’re
    using. As a result, the engine must infer the type. We can have basic types like
    `boolean`, `number`, `array`, or `string`, or we can have a complex type, which
    is essentially a JSON object. In addition, variables can be `null` or `undefined`.
    In broad terms, `undefined` represents something that hasn’t been declared or
    initialized, and `null` represents the intentional absence of the value of a declared
    variable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种动态类型语言。在运行时，执行我们代码的 JavaScript 引擎，如 Chrome 的 V8，不知道我们使用的变量的类型。因此，引擎必须推断类型。我们可以有基本类型，如
    `boolean`、`number`、`array` 或 `string`，或者我们可以有复杂类型，这本质上是一个 JSON 对象。此外，变量可以是 `null`
    或 `undefined`。从广义上讲，`undefined` 表示尚未声明或初始化的某物，而 `null` 表示已声明变量值的故意缺失。
- en: In strongly typed languages, the concept of `undefined` doesn’t exist. Basic
    types have default values, like a `number` being a zero or a `string` being an
    empty string. However, complex types can be `null`. A `null` reference means the
    variable is defined, but there’s no value behind it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在强类型语言中，`undefined` 的概念不存在。基本类型有默认值，如 `number` 是零或 `string` 是空字符串。然而，复杂类型可以是
    `null`。`null` 引用意味着变量已定义，但后面没有值。
- en: The inventor of the `null` reference, Tony Hoare, called it his “billion-dollar
    mistake.”
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`null` 引用的发明者 Tony Hoare 称其为他的“十亿美元的错误”。'
- en: TypeScript brings the concepts of strongly typed languages to JavaScript, so
    it must bridge the gap between the two worlds. As a result, TypeScript defines
    types like `null`, `undefined`, `any`, and `never` to make sense of JavaScript’s
    type semantics. I’ve added links to relevant TypeScript documentation in the *Further
    reading* section for a deeper dive into TypeScript types.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 将强类型语言的观念引入 JavaScript，因此它必须在两个世界之间架起桥梁。因此，TypeScript 定义了 `null`、`undefined`、`any`
    和 `never` 等类型，以理解 JavaScript 的类型语义。我在 *进一步阅读* 部分添加了相关 TypeScript 文档的链接，以便更深入地了解
    TypeScript 类型。
- en: As the TypeScript documentation puts it, TypeScript treats `null` and `undefined`
    differently to match the JavaScript semantics. For example, the union type `string
    | null` is a different type than `string | undefined` and `string | undefined
    | null`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如 TypeScript 文档所述，TypeScript 将 `null` 和 `undefined` 区分开来，以匹配 JavaScript 的语义。例如，联合类型
    `string | null` 与 `string | undefined` 和 `string | undefined | null` 是不同的类型。
- en: 'There’s another nuance: checking to see whether a value equals `null` using
    `==` versus `===`. Using the double equals operator, checking that `foo != null`
    means that `foo` is defined and not `null`. However, using the triple-equals operator,
    `foo !== null` means that `foo` is not `null` but could be `undefined`. However,
    these two operators don’t consider the truthiness of the variable, which includes
    the case of an empty string.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个细微差别是：使用 `==` 和 `===` 来检查一个值是否等于 `null`。使用双等号运算符，检查 `foo != null` 表示 `foo`
    已定义且不是 `null`。然而，使用三等号运算符，`foo !== null` 表示 `foo` 不是 `null` 但可能是 `undefined`。然而，这两个运算符并没有考虑变量的真值，这包括空字符串的情况。
- en: These subtle differences have a great impact on how you write code, especially
    when using the strict TypeScript rules that are applied when you create your Angular
    application using the `--strict` option. It is important to remember that TypeScript
    is a compile-time tool and not a runtime tool. At runtime, we’re still dealing
    with the realities of a dynamically typed language. Just because we declared a
    type to be a string doesn’t mean that we will receive a string.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些细微差别对编写代码的方式有很大影响，尤其是在使用 `--strict` 选项创建 Angular 应用程序时应用严格的 TypeScript 规则。重要的是要记住，TypeScript
    是一个编译时工具，而不是运行时工具。在运行时，我们仍在处理动态类型语言的现实。仅仅因为我们声明了一个类型是字符串，并不意味着我们会收到一个字符串。
- en: Next, let’s see how we can deal with issues related to working with unexpected
    values.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何处理与处理意外值相关的问题。
- en: Null and undefined checking
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`null` 和 `undefined` 检查'
- en: When working with other libraries or dealing with information sent or received
    outside of your application, you must deal with the fact that the variable you
    receive might be `null` or `undefined`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当与其他库一起工作或处理来自应用程序外部发送或接收的信息时，你必须处理接收到的变量可能是 `null` 或 `undefined` 的现实。
- en: Outside of your application means dealing with user input, reading from a cookie
    or `localStorage`, URL parameters from the router, or an API call over HTTP, to
    name a few examples.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序之外意味着处理用户输入，从 cookie 或 `localStorage` 读取，从路由器获取 URL 参数，或通过 HTTP 进行 API
    调用，仅举几个例子。
- en: 'In our code, we mostly care about the truthiness of a variable. This means
    that a variable is defined, not null, and if it’s a basic type, it has a non-default
    value. Given a `string`, we can check whether the `string` is truthy with a simple
    `if` statement:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们主要关注变量的真值。这意味着变量已被定义，不为空，如果它是一个基本类型，它具有非默认值。给定一个 `string`，我们可以通过简单的
    `if` 语句来检查 `string` 是否为真值：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If `foo` is `null`, `undefined`, or an empty string, the variable will be considered
    `falsy`. For certain situations, we can use the conditional or ternary operator
    instead of `if-else`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `foo` 是 `null`、`undefined` 或一个空字符串，变量将被视为假值。对于某些情况，我们可以使用条件或三元运算符而不是 `if-else`。
- en: The conditional or ternary operator
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件或三元运算符
- en: 'The conditional or ternary operator has the `?:` syntax. On the left-hand side
    of the question mark, the operator takes a conditional statement. On the right-hand
    side, we provide the outcomes for true and false around the colon: `conditional
    ? true-outcome : false-outcome`. The conditional or ternary operator is a compact
    way to represent `if-else` conditions and can be very useful to increase the readability
    of your code base. This operator is not a replacement for an `if-else` block,
    but it is of great use when using the output of the `if-else` condition.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '条件或三元运算符具有 `?:` 语法。在问号的左侧，运算符接受一个条件表达式。在冒号的右侧，我们提供真值和假值的输出：`conditional ? true-outcome
    : false-outcome`。条件或三元运算符是表示 `if-else` 条件的紧凑方式，并且可以非常有助于提高代码库的可读性。这个运算符不是 `if-else`
    块的替代品，但在使用 `if-else` 条件的输出时非常有用。'
- en: 'Consider the following example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding `if-else` block can be rewritten as:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将前面的 `if-else` 块重写为：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this case, the conditional or ternary operator makes the code more compact
    and easier to understand. Another common scenario is returning a default value,
    where the variable is `falsy`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，条件或三元运算符使代码更加紧凑且易于理解。另一个常见场景是返回一个默认值，其中变量为假值。
- en: Next, we consider the null coalescing operator.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们考虑空合并运算符。
- en: The null coalescing operator
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空合并运算符
- en: The null coalescing operator is `||`. This operator saves us from repetition
    when the truthy result of the conditional is the same as the conditional itself.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 空合并运算符是 `||`。这个运算符在条件表达式的真值与条件表达式本身相同时，可以避免重复。
- en: 'Consider the example where if `foo` is defined, we would like to use the value
    of `foo`, but if it is `undefined`, we need a default value of `''bar''`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，如果 `foo` 被定义，我们希望使用 `foo` 的值，但如果它是 `undefined`，我们需要一个默认值 `'bar'`：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, `foo` is repeated twice. We can avoid the duplication by using
    the null coalescing operator:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`foo` 被重复了两次。我们可以通过使用空合并运算符来避免重复：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So, if `foo` is `undefined`, `null,` or an empty string, `bar` will be output.
    Otherwise, the value of `foo` will be used. But in some cases, we need only to
    use the default value if the value is `undefined` or `null`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果 `foo` 是 `undefined`、`null` 或一个空字符串，将输出 `bar`。否则，将使用 `foo` 的值。但在某些情况下，我们只需要在值是
    `undefined` 或 `null` 时使用默认值。
- en: Let’s have a look at the nullish coalescing operator next.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看空合并运算符。
- en: The nullish coalescing operator
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空合并运算符
- en: 'The nullish coalescing operator is `??`. This operator is like the null coalescing
    operator, with one crucial difference. Checking the truthiness of a variable is
    not enough when dealing with data received from an API or user input, where an
    empty string may be a valid value. As we covered earlier in this section, checking
    for `null` and `undefined` is not as straightforward as it seems. However, we
    know that by using the double equals operator, we can ensure that `foo` is defined
    and not null:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 空合并运算符是 `??`。这个运算符与空合并运算符类似，但有一个关键的区别。当处理来自 API 或用户输入的数据时，检查变量的真值可能不足以确定一个空字符串是否为有效值。正如我们在本节前面所讨论的，检查
    `null` 和 `undefined` 并不像看起来那么简单。然而，我们知道通过使用双等号运算符，我们可以确保 `foo` 被定义且不为空：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding case, if `foo` is an empty string or another value, we will
    get the value of the `foo` output. If it is `null` or `undefined`, we will get
    `''bar''`. A more compact way to do this is by using the nullish coalescing operator:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，如果`foo`是一个空字符串或另一个值，我们将得到`foo`输出的值。如果是`null`或`undefined`，我们将得到`'bar'`。通过使用空值合并运算符，我们可以以更紧凑的方式完成这项工作：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code will yield the same result as the previous example. However,
    when dealing with complex objects, we need to consider whether their properties
    are `null` or `undefined` as well. For this, we will consider the optional chaining
    operator.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将产生与上一个例子相同的结果。然而，当处理复杂对象时，我们需要考虑它们的属性是否是`null`或`undefined`。为此，我们将考虑使用可选链运算符。
- en: Optional chaining
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选链
- en: The optional chaining operator is `?`. It is like Angular’s safe navigation
    operator. Optional chaining ensures that a variable or property is defined and
    not `null` before attempting to access a child property or invoke a function.
    So the statement `foo?.bar?.callMe()` executes without throwing an error, even
    if `foo` or `bar` is `null` or `undefined`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可选链运算符是`?`。它类似于Angular的安全导航运算符。可选链确保在尝试访问子属性或调用函数之前，变量或属性已被定义且不是`null`。因此，`foo?.bar?.callMe()`这个语句在没有抛出错误的情况下执行，即使`foo`或`bar`是`null`或`undefined`。
- en: 'Consider the `user` entity, which has a `name` object with properties for `first`,
    `middle`, and `last`. Let’s see what it would take to safely provide a default
    value of an empty string for a middle name, using the nullish coalescing operator:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下`user`实体，它有一个`name`对象，包含`first`、`middle`和`last`属性。让我们看看如何使用空值合并运算符安全地为中间名提供一个空字符串的默认值：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, we need to check whether a parent object is `truthy` before
    accessing a child property. If `middle` is `null`, an empty string is output.
    Optional chaining makes this task simpler:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在访问子属性之前，我们需要检查父对象是否是`truthy`。如果`middle`是`null`，则输出一个空字符串。可选链使这项任务变得更简单：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using optional chaining and the nullish coalescing operator together, we can
    eliminate repetition and deliver robust code that can effectively deal with the
    realities of JavaScript’s dynamic runtime.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合使用可选链和空值合并运算符，我们可以消除重复，并交付出健壮的代码，能够有效地处理JavaScript动态运行时的现实。
- en: So, when designing your code, you must decide whether to introduce the concept
    of null to your logic or work with default values like empty strings. In the next
    section, as we implement the User entity, you will see how these choices play
    out. So far, we have only used interfaces to define the shape of our data. Next,
    let’s build the User entity, leveraging OOP concepts like classes, enums, and
    abstraction to implement it, along with an auth service.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在设计你的代码时，你必须决定是否在你的逻辑中引入null的概念，或者使用像空字符串这样的默认值。在下一节中，当我们实现用户实体时，你将看到这些选择是如何发挥作用的。到目前为止，我们只使用了接口来定义我们数据的形式。接下来，让我们构建用户实体，利用面向对象编程的概念，如类、枚举和抽象来实现它，以及一个认证服务。
- en: Let’s start simple and see how these patterns are implemented within the context
    of JavaScript classes and TypeScript fundamentals.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单开始，看看这些模式如何在JavaScript类和TypeScript基础知识的环境中实现。
- en: Implementing data entities and interfaces
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现数据实体和接口
- en: In this section, I will demonstrate how you can use classes in your own code
    design to define and encapsulate the behavior of your models, such as the `User`
    class. Later in this chapter, you will see examples of class inheritance with
    abstract base classes, which allows us to standardize our implementation and reuse
    base functionality in a clean and easy-to-maintain manner.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将演示你如何在你的代码设计中使用类来定义和封装你的模型的行为，例如`User`类。在本章的后面部分，你将看到使用抽象基类的类继承的例子，这允许我们标准化我们的实现，并以干净、易于维护的方式重用基本功能。
- en: I must point out that OOP has very useful patterns that can increase the quality
    of your code; however, if you overuse it, then you will start losing the benefits
    of the dynamic, flexible, and functional nature of JavaScript.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须指出，面向对象编程（OOP）具有非常实用的模式，这些模式可以提高你代码的质量；然而，如果你过度使用它，那么你将开始失去JavaScript动态、灵活和功能性的好处。
- en: Sometimes, all you need is a bunch of functions in a file, and you’ll see examples
    of that throughout the book.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你只需要一个文件中的几个函数，你会在整本书中看到这样的例子。
- en: A great way to demonstrate the value of classes would be to standardize the
    creation of a default `User` object. We need this because a `BehaviorSubject`
    object needs to be initialized with a default object. It is best to do this in
    one place, rather than copy and paste the same implementation in multiple places.
    It makes a lot of sense for the `User` object to own this functionality instead
    of an Angular service creating default `User` objects. So, let’s implement a `User`
    class to achieve this goal.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 展示类价值的一个好方法就是标准化创建默认`User`对象的过程。我们需要这样做，因为`BehaviorSubject`对象需要用默认对象初始化。最好在一个地方完成这个操作，而不是在多个地方复制粘贴相同的实现。让`User`对象拥有这个功能而不是由Angular服务创建默认`User`对象是非常有意义的。所以，让我们实现一个`User`类来实现这个目标。
- en: Classes, Interfaces, and Enums
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类、接口和枚举
- en: As mentioned, we have only worked with interfaces to represent data. We still
    want to continue using interfaces when passing data around various components
    and services. Interfaces are great for describing the kind of properties or functions
    an implementation has, but they suggest nothing about the behavior of these properties
    or functions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们只使用接口来表示数据。我们仍然希望在传递数据到各个组件和服务时继续使用接口。接口非常适合描述实现具有哪些属性或函数，但它们对这些属性或函数的行为没有任何暗示。
- en: With ES2015 (ES6), JavaScript gained native support for classes, which is a
    crucial concept of the OOP paradigm. Classes are actual implementations of behavior.
    As opposed to just having a collection of functions in a file, a class can properly
    encapsulate behavior. A class can then be instantiated as an object using the
    new keyword.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES2015（ES6）中，JavaScript获得了对类的原生支持，这是面向对象编程范式的一个关键概念。类是行为的实际实现。与文件中只包含函数集合相比，类可以正确地封装行为。然后可以使用new关键字将类实例化为对象。
- en: TypeScript takes the ES2015 (and beyond) implementation of classes and introduces
    necessary concepts like abstract classes, private, protected, and public properties,
    and interfaces to make it possible to implement OOP patterns.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript采用了ES2015（及以后）的类实现，并引入了必要的概念，如抽象类、私有、受保护和公共属性，以及接口，以便能够实现面向对象编程模式。
- en: We will begin by defining enums and interfaces for the data entities we need,
    utilizing the best two features of Typescript.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义所需数据实体的枚举和接口，利用TypeScript的两大最佳特性。
- en: 'Interfaces help us practice the Dependency Inversion Principle from SOLID design:
    depend on abstractions, not on concretions. This means between components or services,
    it is better to pass the interface of an object (an instantiated class) instead
    of the object itself. This is why every class we define will implement an interface.
    Further, interfaces are usually the first thing you can start coding in a new
    project, using them to implement your walking skeleton and API integrations.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接口帮助我们实践SOLID设计原则中的依赖倒置原则：依赖于抽象，而不是具体实现。这意味着在组件或服务之间，传递对象的接口（一个实例化的类）而不是对象本身会更好。这就是为什么我们定义的每个类都将实现一个接口。此外，接口通常是你在新项目中开始编码的第一件事，使用它们来实现你的原型和API集成。
- en: 'Enums help ensure another important rule: never use string literals. Enums
    are powerful and awesome.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举有助于确保另一个重要规则：永远不要使用字符串字面量。枚举功能强大且出色。
- en: 'Let’s jump in and define the interfaces and enums we need:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入并定义所需的接口和枚举：
- en: 'Define user roles as an `enum` at the location `src/app/auth/auth.enum.ts`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/app/auth/auth.enum.ts`位置定义用户角色为`enum`：
- en: '[PRE12]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Create a `user.ts` file under the `src/app/user/user` folder.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/app/user/user`文件夹下创建一个`user.ts`文件。
- en: 'Define a new interface named `IUser` in the `user.ts` file:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`user.ts`文件中定义一个名为`IUser`的新接口：
- en: '[PRE13]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that every complex property defined on the interface can also be represented
    as a `string`. In transit, all objects are converted to strings using `JSON.stringify()`.
    No type of information is included. We also leverage interfaces to represent `Class`
    objects in memory, which can have complex types. So, our interface properties
    must reflect both cases using union types. For example, the `role` can either
    be of type `Role` or `string`. Similarly, `dateOfBirth` can be a `Date` or a `string`.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，接口上定义的每个复杂属性也可以表示为`string`。在传输过程中，所有对象都使用`JSON.stringify()`转换为字符串。不包含任何类型信息。我们还利用接口在内存中表示`Class`对象，这些对象可以具有复杂类型。因此，我们的接口属性必须使用联合类型反映这两种情况。例如，`role`可以是`Role`类型或`string`。同样，`dateOfBirth`可以是`Date`或`string`。
- en: We define the `address` as an inline type because we don’t use the concept of
    an address outside of this class. In contrast, we define `IName` as its own interface
    because in *Chapter 8*, *Recipes – Reusability, Forms, and Caching*, we will implement
    a separate component for names. We also define a separate interface for phones
    because they are represented as an array. When developing a form, we need to be
    able to address individual array elements, like `IPhone`, in the template code.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将`address`定义为内联类型，因为我们在这个类之外不使用地址的概念。相比之下，我们将`IName`定义为其自己的接口，因为在第8章“食谱 -
    可重用性、表单和缓存”中，我们将实现一个单独的组件来处理名称。我们还定义了一个单独的接口来处理电话，因为它们被表示为数组。在开发表单时，我们需要能够在模板代码中引用数组的单个元素，例如`IPhone`。
- en: It is the norm to prepend interface names with a capital `I` so that they can
    be easily identified. Don’t worry; there are no compatibility issues with using
    the `IPhone` interface on Android phones!
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，在接口名称前加上大写的`I`，以便于识别。不用担心；在Android手机上使用`IPhone`接口没有兼容性问题！
- en: 'In `user.ts`, define the `IName` and `IPhone` interfaces, and implement the
    `PhoneType` enum:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`user.ts`中定义`IName`和`IPhone`接口，并实现`PhoneType`枚举：
- en: '[PRE14]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that in the `PhoneType` enum, we explicitly defined `string` values. By
    default, `enum` values are converted into strings as they’re typed, which can
    lead to issues with values stored in a database falling out of sync with how a
    developer chooses to spell a variable name. With explicit and all lowercase values,
    we reduce the risk of bugs.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在`PhoneType`枚举中，我们明确地定义了`string`值。默认情况下，`enum`值在键入时会转换为字符串，这可能导致数据库中存储的值与开发者选择拼写变量名的方式不同步，从而导致问题。通过明确和全部小写的值，我们降低了出现错误的风险。
- en: 'Next, define the `User` class, which implements the `IUser` interface:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义实现`IUser`接口的`User`类：
- en: '[PRE15]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that by defining all properties with default values in the constructors
    as `public` properties, we kill two birds with one stone; otherwise, we would
    need to define properties and initialize them separately. This way, we achieve
    a concise implementation.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，通过在构造函数中将所有属性定义为`public`属性并赋予默认值，我们一举两得；否则，我们需要分别定义属性并单独初始化它们。这样，我们实现了简洁的实现。
- en: Using a static `Build` function, we can quickly hydrate the object with data
    received from the server. We can also implement the `toJSON()` function to customize
    the serialization behavior of our object before sending the data to the server.
    But before that, let’s add a calculated property.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用静态的`Build`函数，我们可以快速用从服务器接收到的数据填充对象。我们还可以实现`toJSON()`函数来定制对象在发送到服务器前的序列化行为。但在那之前，让我们添加一个计算属性。
- en: We can use calculated properties in templates or toast messages to conveniently
    display values assembled from multiple parts. A great example is extracting a
    full name from the `name` object as a property in the `User` class.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以在模板或通知消息中使用计算属性方便地显示由多个部分组成的值。一个很好的例子是从`name`对象中提取全名作为`User`类中的一个属性。
- en: A calculated property for assembling a full name encapsulates the logic for
    combining a first, middle, and last name, so you don’t have to rewrite this logic
    in multiple places, adhering to the DRY principle!
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于组装全名的计算属性封装了组合首名、中名和姓氏的逻辑，这样你就不必在多个地方重写这个逻辑，遵循DRY原则！
- en: 'Implement a `fullName` property getter in the `User` class:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`User`类中实现`fullName`属性的getter：
- en: '[PRE16]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add `fullName` to `IUser` as an optional `readonly` property:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`fullName`添加到`IUser`中作为一个可选的`readonly`属性：
- en: '[PRE17]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can now use the `fullName` property through the `IUser` interface.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你现在可以通过`IUser`接口使用`fullName`属性。
- en: 'Implement the `toJSON` function:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现序列化函数：
- en: '[PRE18]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that when serializing the object, we delete the `_id` and `fullName` fields.
    These are values that we don’t want to be stored in the database. The `fullName`
    field is a calculated property, so it doesn’t need storage. The `_id` is normally
    passed as a parameter in a `GET` or a `PUT` call to locate the record. This avoids
    mistakes that may result in overwriting the `id` fields of existing objects.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在序列化对象时，我们删除了`_id`和`fullName`字段。这些是我们不希望存储在数据库中的值。`fullName`字段是一个计算属性，因此不需要存储。`_id`通常在`GET`或`PUT`调用中作为参数传递，以定位记录。这避免了可能导致的错误，这些错误可能会导致覆盖现有对象的`id`字段。
- en: Now that we have the `User data` entity implemented, let’s implement the auth
    service next.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了`User data`实体，接下来让我们实现认证服务。
- en: Reusable services leveraging OOP concepts
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用面向对象概念的可重用服务
- en: OOP is an imperative programming style compared to the reactive programming
    style that RxJS enables. Classes form the bedrock of OOP, whereas observables
    do the same for reactive programming using RxJS.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与RxJS所支持的响应式编程风格相比，OOP（面向对象编程）是一种命令式编程风格。类是OOP的基础，而使用RxJS的观察者（observables）在响应式编程中扮演着同样的角色。
- en: 'I encourage you to become familiar with OOP terminology. Please see the *Further
    reading* section for some useful resources. You should become familiar with:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你熟悉OOP术语。请参阅*进一步阅读*部分，了解一些有用的资源。你应该熟悉：
- en: Classes versus objects
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类与对象
- en: Composition (interfaces)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合（接口）
- en: Encapsulation (private, protected, and public properties, and property getters
    and setters)
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装（私有、受保护、公共属性，以及属性获取器和设置器）
- en: Polymorphism (inheritance, abstract classes, and method overriding)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态（继承、抽象类和方法重写）
- en: As you know, Angular uses OOP patterns to implement components and services.
    For example, interfaces implement life cycle hooks such as `OnInit`. We aim to
    design a flexible auth service that can implement multiple auth providers. In
    *Chapter 6*, *Implementing Role-Based Navigation*, we will implement an in-memory
    provider and a Google Firebase provider. In *Chapter 7*, *Working with REST and
    GraphQL APIs*, we will implement two custom providers to interact with our backend
    and see how **Role-based Access Control** (**RBAC**) is implemented.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，Angular使用OOP模式来实现组件和服务。例如，接口实现了生命周期钩子，如`OnInit`。我们的目标是设计一个灵活的认证服务，它可以实现多个认证提供者。在*第6章*，*实现基于角色的导航*中，我们将实现一个内存提供者和一个Google
    Firebase提供者。在*第7章*，*与REST和GraphQL API交互*中，我们将实现两个自定义提供者以与我们的后端交互，并了解**基于角色的访问控制**（**RBAC**）是如何实现的。
- en: By declaring an abstract base class, we can describe the common login and logout
    behavior of our application, so when we implement another auth provider, we don’t
    have to re-engineer our application.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过声明一个抽象基类，我们可以描述我们应用程序的常见登录和注销行为，因此当我们实现另一个认证提供者时，我们不需要重新设计我们的应用程序。
- en: In addition, we can declare abstract functions, which the implementors of our
    base class would have to implement, enforcing our design. Any class that implements
    the base class would also get the benefit of the code implemented in the base
    class, so we wouldn’t need to repeat the same logic in two different places.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以声明抽象函数，我们的基类的实现者必须实现这些函数，以强制我们的设计。任何实现基类的类都将获得基类中实现代码的好处，因此我们不需要在两个不同的地方重复相同的逻辑。
- en: 'The following class diagram reflects the architecture and inheritance hierarchy
    of our abstract `AuthService`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类图反映了我们抽象的`AuthService`的架构和继承层次结构：
- en: '![](img/B20960_05_03.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B20960_05_03.png)'
- en: 'Figure 5.3: The AuthService inheritance structure'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：AuthService继承结构
- en: '`AuthService` implements the interface `IAuthService`, as shown here:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthService`实现了`IAuthService`接口，如下所示：'
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The interface reflects the public properties that the service exposes. The service
    provides the authentication status as the `authStatus$` observable and the current
    user as `currentUser$`, and it provides three functions, `login`, `logout`, and
    `getToken`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接口反映了服务公开的属性。服务提供认证状态作为`authStatus$`观察者，当前用户作为`currentUser$`，并提供三个函数，`login`、`logout`和`getToken`。
- en: '`AuthService` requires caching functionality from another service called `CacheService`.
    Instead of using inheritance to incorporate cache functionality, we can inject
    it into the base class. Since `AuthService` is an abstract class, it can’t be
    used independently, so we will implement the three auth providers, `InMemoryAuthService`,
    `FirebaseAuthService`, and `CustomAuthService`, shown at the bottom of the preceding
    diagram.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthService`需要从另一个名为`CacheService`的服务中获取缓存功能。我们不是通过继承来整合缓存功能，而是将其注入到基类中。由于`AuthService`是一个抽象类，它不能独立使用，因此我们将实现三个认证提供者，即图示下方的`InMemoryAuthService`、`FirebaseAuthService`和`CustomAuthService`。'
- en: Composition is preferred over inheritance, so you must ensure you’re using inheritance
    correctly. Inheritance describes an is-a relationship and composition describes
    a has-a relationship. In this case, we’re using the correct mixture of inheritance
    and composition because `FirebaseAuthService` is an `AuthService`, and `AuthService`
    has a `CacheService`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 组合优于继承，因此你必须确保你正确地使用了继承。继承描述了一个is-a关系，而组合描述了一个has-a关系。在这种情况下，我们使用了正确的继承和组合的混合，因为`FirebaseAuthService`是`AuthService`，而`AuthService`有一个`CacheService`。
- en: Note that all three auth services implement all abstract functions. In addition,
    the `FirebaseAuthService` overrides the base `logout` function to implement its
    own behavior. All three classes inherit from the same abstract class and expose
    the same public interface. All three will execute the same auth workflow against
    different auth servers.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有三个认证服务都实现了所有抽象函数。此外，`FirebaseAuthService` 覆盖了基类的 `logout` 函数以实现其自己的行为。所有三个类都继承自同一个抽象类并公开相同的公共接口。所有三个都将执行相同的认证工作流程，针对不同的认证服务器。
- en: The in-memory auth service doesn’t communicate with a server. The service is
    for demonstration purposes only. It implements fake JWT encoding, so we can demonstrate
    how the JWT life cycle works.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 内存中的认证服务不与服务器通信。此服务仅用于演示目的。它实现了假的 JWT 编码，因此我们可以演示 JWT 生命周期的工作方式。
- en: Let’s start by creating the auth service.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建认证服务开始。
- en: Creating an auth service
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个认证服务
- en: 'We will start by creating the abstract auth service and the in-memory service:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建抽象的认证服务和内存中的服务：
- en: 'Add an auth service:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个认证服务：
- en: '[PRE20]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Rename `in-memory-auth.service.ts` to `auth.in-memory.service.ts` so that the
    different auth providers visually group together in File Explorer.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `in-memory-auth.service.ts` 重命名为 `auth.in-memory.service.ts`，以便在文件资源管理器中将不同的认证提供者视觉上分组在一起。
- en: Remove the `@Injectable()` decorator of `auth.service.ts` , but keep it on `auth.in-memory.service.ts`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除 `auth.service.ts` 中的 `@Injectable()` 装饰器，但保留在 `auth.in-memory.service.ts`
    上。
- en: 'Ensure that `authService` is provided in `app.module.ts` and that `InMemoryAuthService`
    is used and not the abstract class:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在 `app.module.ts` 中提供了 `authService`，并且使用 `InMemoryAuthService` 而不是抽象类：
- en: '[PRE21]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Creating a separate folder for the service organizes various components related
    to auth, such as the `enum` definition for the user role. Additionally, we will
    be able to add an `authService` fake to the same folder for automated testing.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为服务创建一个单独的文件夹，可以组织与认证相关的各种组件，例如用户角色的 `enum` 定义。此外，我们还将能够将 `authService` 模拟器添加到同一个文件夹中，以进行自动化测试。
- en: Implement an abstract auth service
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现一个抽象的认证服务
- en: Now, let’s build an abstract auth service that will orchestrate logins and logouts
    while encapsulating the logic of managing JWTs, auth status, and information regarding
    the current user. By leveraging the abstract class, we should be able to implement
    our own auth service against any auth provider without modifying the internal
    behavior of our application.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建一个抽象的认证服务，该服务将协调登录和注销，同时封装管理 JWT、认证状态和有关当前用户的信息的逻辑。通过利用抽象类，我们应该能够针对任何认证提供者实现自己的认证服务，而无需修改应用程序的内部行为。
- en: The abstract auth service that we will demonstrate enables rich and intricate
    workflows. It is a solution that you can drop into your applications without modifying
    the internal logic. As a result, it is a complicated solution.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要演示的抽象认证服务可以实现丰富和复杂的流程。这是一个可以无缝集成到您的应用程序中的解决方案，无需修改内部逻辑。因此，它是一个复杂的解决方案。
- en: 'This auth service will enable us to demonstrate logging in with an email and
    password, caching, and conditional navigation concepts based on authentication
    status and a user’s role:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此认证服务将使我们能够演示使用电子邮件和密码进行登录、缓存以及基于认证状态和用户角色的条件导航概念：
- en: 'Start by installing a JWT decoding library and, to fake authentication, a JWT
    encoding library:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先安装一个 JWT 解码库，以及为了模拟认证的 JWT 编码库：
- en: '[PRE22]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Implement an `IAuthStatus` interface to store decoded user information, a helper
    interface, and the secure by default `defaultAuthStatus`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个 `IAuthStatus` 接口以存储解码后的用户信息，一个辅助接口，以及默认安全的 `defaultAuthStatus`：
- en: '[PRE23]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`IAuthStatus` is an interface that represents the shape of a typical JWT that
    you may receive from your authentication service. It contains minimal information
    about the user and the user’s role. The auth status object can be attached to
    the header of every REST call to APIs to verify the user’s identity. The auth
    status can be optionally cached in `localStorage` to remember the user’s login
    state; otherwise, they would have to re-enter their password with every page refresh.'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`IAuthStatus` 是一个接口，它代表了从认证服务接收到的典型 JWT 的结构。它包含有关用户及其角色的最小信息。认证状态对象可以附加到每个
    API 调用的头部，以验证用户的身份。认证状态可以可选地缓存在 `localStorage` 中以记住用户的登录状态；否则，他们每次刷新页面时都需要重新输入密码。'
- en: In the preceding implementation, we assume the default role of `None`, as defined
    in the `Role` enum. By not giving any role to the user by default, we’re following
    a least-privileged access model. The user’s correct role will be set after they
    log in successfully with the information received from the auth API.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的实现中，我们假设默认角色为 `None`，如 `Role` 枚举中定义。通过默认不给用户分配任何角色，我们遵循最小权限访问模型。用户正确的角色将在他们使用从
    auth API 收到的信息成功登录后设置。
- en: 'Define the `IAuthService` interface in `auth.service.ts`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `auth.service.ts` 中定义 `IAuthService` 接口：
- en: '[PRE24]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Make `AuthService` an `abstract` class, as shown here:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `AuthService` 实现为 `abstract` 类，如下所示：
- en: '[PRE25]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Implement the interface, `IAuthService`, using VS Code’s quick-fix functionality:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 VS Code 的快速修复功能实现接口 `IAuthService`：
- en: '[PRE26]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Implement the `authStatus$` and `currentUser$` properties as `readonly` and
    initialize our data anchors with their default values:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `authStatus$` 和 `currentUser$` 属性实现为 `readonly` 并用它们的默认值初始化我们的数据锚点：
- en: '[PRE27]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that we removed the type definitions of the properties. Instead, we’re
    letting TypeScript infer the type from the initialization.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们移除了属性的类型定义。相反，我们让 TypeScript 从初始化中推断类型。
- en: You must always declare your data anchors as `readonly` so that you don’t accidentally
    overwrite the data stream by re-initializing a data anchor as a new `BehaviorSubject`.
    Doing so would render any prior subscribers orphaned, leading to memory leaks,
    which has many unintended consequences.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须始终将你的数据锚点声明为 `readonly`，这样你就不会意外地通过将数据锚点重新初始化为新的 `BehaviorSubject` 来覆盖数据流，这样做会使任何先前的订阅者成为孤儿，导致内存泄漏，这会有许多意想不到的后果。
- en: All implementors of `IAuthService` must be able to log the user in, transform
    the token we get back from the server so that we can read and store it, support
    access to the current user and the auth status, and provide a way to log the user
    out. We have successfully put in the functions for our public methods and implemented
    default values for our data anchors, creating hooks for the rest of our application.
    But so far, we have only defined what our service can do and not how it can do
    it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 所有实现 `IAuthService` 的实现者必须能够登录用户，转换从服务器返回的令牌，以便我们可以读取和存储它，支持访问当前用户和认证状态，并提供一种注销用户的方式。我们已经成功添加了公共方法的函数，并为我们的数据锚点实现了默认值，为我们的应用程序的其他部分创建了钩子。但到目前为止，我们只定义了我们的服务可以做什么，而没有定义它是如何做到的。
- en: As always, the devil is in the details, and the hard part is the “how.” Abstract
    functions can help us to complete the implementation of a workflow in a service
    within our application, while leaving the portions of the service that must implement
    external APIs undefined.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 总是细节决定成败，难点在于“如何”。抽象函数可以帮助我们在应用程序的服务中完成工作流程的实现，同时将必须实现外部 API 的服务部分留空。
- en: Abstract functions
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象函数
- en: Auth services that implement the abstract class should be able to support any
    kind of auth provider and any kind of token transformation while being able to
    modify behaviors, like user retrieval logic. We must be able to implement login,
    logout, token, and auth status management without implementing calls to specific
    services.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 实现抽象类的认证服务应该能够支持任何类型的认证提供者和任何类型的令牌转换，同时能够修改行为，如用户检索逻辑。我们必须能够实现登录、注销、令牌和认证状态管理，而不需要实现对特定服务的调用。
- en: By defining abstract functions, we can declare a series of methods that must
    implement a given set of inputs and outputs—a signature without an implementation.
    We can then use these abstract functions to orchestrate the implementation of
    our auth workflow.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义抽象函数，我们可以声明一系列必须实现一组给定输入和输出的方法——一个没有实现的签名。然后我们可以使用这些抽象函数来编排我们的认证工作流程的实现。
- en: The Open/Closed principle drives our design goal here. The `AuthService` will
    be open to extension through its ability to be extended to work with any kind
    of token-based auth provider, but it is closed to modification. Once we’re done
    implementing the `AuthService`, we won’t need to modify its code to add additional
    auth providers.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 开放/封闭原则推动了我们的设计目标。`AuthService` 将通过其能够扩展以与任何基于令牌的认证提供者一起工作的能力而开放，但它对修改是封闭的。一旦我们完成了
    `AuthService` 的实现，我们就不会需要修改其代码来添加额外的认证提供者。
- en: 'Now, we need to define the abstract functions that our auth providers must
    implement, as shown in *Figure 5.3* from earlier in the chapter:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要定义我们的认证提供者必须实现的抽象函数，如本章前面 *图 5.3* 所示：
- en: '`authProvider(email, password)`: `Observable<IServerAuthResponse>` can log
    us in via a provider and return a standardized `IServerAuthResponse`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`authProvider(email, password)`: `Observable<IServerAuthResponse>` 可以通过提供者登录并返回标准化的
    `IServerAuthResponse`'
- en: '`transformJwtToken(token)`: `IAuthStatus` can normalize the token a provider
    returns to the interface of `IAuthStatus`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transformJwtToken(token)`: `IAuthStatus` 可以将提供者返回的令牌标准化为 `IAuthStatus` 接口'
- en: '`getCurrentUser()`: `Observable<User>` can retrieve the user profile of the
    logged-in user'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCurrentUser()`: `Observable<User>` 可以检索已登录用户的用户资料'
- en: 'We can then use these functions in our `login`, `logout`, and `getToken` methods
    to implement the auth workflow:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在 `login`、`logout` 和 `getToken` 方法中使用这些函数来实现身份验证工作流程：
- en: 'Define the abstract methods that the derived classes should implement as protected
    properties so that they’re accessible in the derived class, but not publicly:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将派生类应该实现的抽象方法定义为受保护的属性，以便在派生类中可访问，但不是公开的：
- en: '[PRE28]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Leveraging these stubbed-out methods, we can now implement a login method to
    log a user in and retrieve the currently logged-in user, updating the `authStatus$`
    and `currentUser$` data streams.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 利用这些模拟的方法，我们现在可以实现一个登录方法来登录用户并检索当前登录用户，更新 `authStatus$` 和 `currentUser$` 数据流。
- en: 'Before we move on, implement a `transformError` function to handle errors of
    different types like `HttpErrorResponse` and `string`, providing them in an observable
    stream. In a new file named `common.ts` under `src/app/common`, create the `transformError`
    function:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们继续之前，实现一个 `transformError` 函数来处理不同类型的错误，如 `HttpErrorResponse` 和 `string`，并将它们提供在可观察的流中。在
    `src/app/common` 下的新文件 `common.ts` 中创建 `transformError` 函数：
- en: '[PRE29]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In `auth.service.ts`, implement the `login` method:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `auth.service.ts` 中实现 `login` 方法：
- en: '[PRE30]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `login` method encapsulates the correct order of operations by calling the
    `authProvider` with the `email` and `password` information, then decoding the
    received JWT, transforming it, and updating `authStatus$`. Then, `getCurrentUser()`
    is called only if `status.isAuthenticated` is `true`. Later, `currentUser$` is
    updated, and finally, we catch any errors using our custom `transformError` function.
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`login` 方法通过调用 `authProvider` 并传入 `email` 和 `password` 信息来封装正确的操作顺序，然后解码接收到的
    JWT，进行转换，并更新 `authStatus$`。接着，只有当 `status.isAuthenticated` 为 `true` 时，才会调用 `getCurrentUser()`。之后，更新
    `currentUser$`，最后，我们使用自定义的 `transformError` 函数来捕获任何错误。'
- en: We activate the observable stream by calling `subscribe` on it. In the case
    of an error, we call `logout()` to maintain the correct status of our application
    and bubble up errors to consumers of `login` by re-throwing the error, using `throwError`.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们通过在它上面调用 `subscribe` 来激活可观察的流。在出现错误的情况下，我们调用 `logout()` 以保持应用程序的正确状态，并通过使用
    `throwError` 重新抛出错误，将错误冒泡到 `login` 的消费者。
- en: Now, the corresponding `logout` function needs to be implemented. Logout is
    triggered by the **Logout** button from the application toolbar in the case of
    a failed login attempt, as shown earlier, or if an unauthorized access attempt
    is detected. We can detect unauthorized access attempts by using a router auth
    guard as the user navigates the application, which is a topic covered later in
    the chapter.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，需要实现相应的 `logout` 函数。在登录尝试失败的情况下，或者在检测到未经授权的访问尝试时，都会触发退出。我们可以通过使用路由器身份验证守卫来检测未经授权的访问尝试，当用户在应用程序中导航时，这是本章后面将要讨论的一个主题。
- en: 'Implement the `logout` method:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现退出方法：
- en: '[PRE31]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We log out by pushing out the `defaultAuthStatus` as the next value in the `authStatus$`
    stream. Note the use of `setTimeout`, which allows us to avoid timing issues when
    core elements of the application all change statuses at once.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 `authStatus$` 流中推送 `defaultAuthStatus` 作为下一个值来注销。注意 `setTimeout` 的使用，它允许我们在应用程序的核心元素同时更改状态时避免时序问题。
- en: Think about how the `login` method adheres to the Open/Closed principle. The
    method is open to extension through the abstract functions `authProvider`, `transformJwtToken`,
    and `getCurrentUser`. By implementing these functions in a derived class, we can
    externally supply different auth providers without modifying the `login` method.
    As a result, the implementation of the method remains closed to modification,
    thus adhering to the Open/Closed principle.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下 `login` 方法是如何遵循开放/封闭原则的。该方法通过抽象函数 `authProvider`、`transformJwtToken` 和
    `getCurrentUser` 对扩展开放。通过在派生类中实现这些函数，我们可以外部提供不同的身份验证提供者，而不需要修改 `login` 方法。因此，方法的实现保持对修改的封闭，从而遵循开放/封闭原则。
- en: The true value of creating abstract classes is the ability to encapsulate common
    functionality in an extensible way.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 创建抽象类真正的价值在于能够以可扩展的方式封装通用功能。
- en: You may ignore the `getToken` function for now, as we are not yet caching our
    JWT. Without caching, the user would have to log in with every page refresh. Let’s
    implement caching next.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 目前您可以忽略`getToken`函数，因为我们还没有缓存我们的JWT。没有缓存，用户每次刷新页面时都需要登录。让我们接下来实现缓存。
- en: A cache service using localStorage
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用localStorage的缓存服务
- en: We must be able to cache the authentication status of the logged-in user. As
    mentioned, otherwise, with every page refresh, the user must go through the login
    routine. We need to update `AuthService` so that it persists the auth status.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须能够缓存已登录用户的认证状态。如前所述，否则，每次刷新页面时，用户都必须通过登录流程。我们需要更新`AuthService`以持久化认证状态。
- en: 'There are three main ways to store data:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 存储数据主要有三种方式：
- en: '`cookie`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cookie`'
- en: '`localStorage`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localStorage`'
- en: '`sessionStorage`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sessionStorage`'
- en: Cookies, while they have their use cases, should not be used to store secure
    data because they can be sniffed or stolen by bad actors. In addition, cookies
    can store only 4 KB of data and can be set to expire.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然cookies有其用例，但不应该用来存储安全数据，因为它们可以被恶意行为者嗅探或窃取。此外，cookies只能存储4KB的数据，并且可以设置过期时间。
- en: '`localStorage` and `sessionStorage` are similar. They are protected and isolated
    browser-side stores that allow the storage of larger amounts of data for your
    application. Unlike cookies, you can’t set an expiration date-time on values stored
    in either store. Values stored in either store survive page reloads and restores,
    making them better candidates than cookies for caching information.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`localStorage`和`sessionStorage`相似。它们是受保护和隔离的浏览器端存储，允许为您的应用程序存储更多的数据。与cookies不同，您不能为存储在任一存储中的值设置过期日期和时间。存储在任一存储中的值在页面重新加载和恢复时仍然存在，这使得它们比cookies更适合缓存信息。'
- en: The major difference between `localStorage` and `sessionStorage` is how values
    are persisted across browser tabs. With `sessionStorage`, stored values are removed
    when the browser tab or window is closed. However, `localStorage` persists across
    reboots. In most cases, user logins are cached anywhere from minutes to a month
    or more, depending on your business, so relying on whether the user closes the
    browser window isn’t very useful. Through this process of elimination, I prefer
    `localStorage` because of its isolation and long-term storage capabilities.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`localStorage`和`sessionStorage`之间的主要区别在于值如何在浏览器标签页之间持久化。使用`sessionStorage`，存储的值在浏览器标签页或窗口关闭时被删除。然而，`localStorage`在重启后仍然存在。在大多数情况下，用户登录的缓存可以从几分钟到一个月或更长时间，具体取决于您的业务，因此依赖于用户是否关闭浏览器窗口并不是很有用。通过这个过程排除，我更喜欢`localStorage`，因为它具有隔离性和长期存储能力。'
- en: JWTs can be encrypted and include a timestamp for expiration. In theory, this
    counters the weaknesses of both cookies and `localStorage`. If implemented correctly,
    either option should be secure for use with JWTs, but `localStorage` is still
    preferred.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: JWT可以被加密并包含过期时间的戳。从理论上讲，这抵消了cookies和`localStorage`的弱点。如果正确实现，任一选项都应安全用于JWT，但`localStorage`仍然更受欢迎。
- en: 'Let’s start by implementing a caching service that can provide a centralized
    caching method for our application. We can then derive from this service to cache
    our authentication information:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先实现一个缓存服务，它可以为我们应用程序提供一个集中的缓存方法。然后我们可以从这个服务中派生出我们的认证信息缓存：
- en: 'Start by creating an abstract `cacheService` that encapsulates the method of
    caching:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个抽象的`cacheService`，它封装了缓存的方法：
- en: '[PRE32]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This cache service class can give caching capabilities to any service. While
    it creates a centralized caching method you can inject into another service, it
    is not meant to be a centralized value store. You should never use it to synchronize
    state, so we can avoid introducing side effects and coupling between services
    and components.
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个缓存服务类可以为任何服务提供缓存能力。虽然它创建了一个可以注入到另一个服务中的集中式缓存方法，但它并不是一个集中式值存储。您永远不应该用它来同步状态，这样我们就可以避免在服务和组件之间引入副作用和耦合。
- en: 'Update `AuthService` to inject the `CacheService`, which will enable us to
    implement caching of the JWT in the next section:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`AuthService`以注入`CacheService`，这将使我们能够在下一节中实现JWT的缓存：
- en: '[PRE33]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let’s go over an example of how to use the base class’s functionality by caching
    the value of the `authStatus` object:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来了解如何通过缓存`authStatus`对象的值来使用基类的功能：
- en: '[PRE34]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The technique demonstrated in the example leverages RxJS observable streams
    to update the cache whenever the value of `authStatus$` changes. You can use this
    pattern to persist any kind of data without cluttering your business logic with
    caching code. In this case, we wouldn’t need to update the `login` function to
    call `setItem` because it already calls `this.authStatus.next`, and we can just
    tap into the data stream. This helps with staying stateless and avoiding side
    effects, by decoupling functions from each other.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中展示的技术利用了RxJS的可观察流，在`authStatus$`的值发生变化时更新缓存。你可以使用这种模式持久化任何类型的数据，而不会让你的业务逻辑被缓存代码所杂乱。在这种情况下，我们不需要更新`login`函数来调用`setItem`，因为它已经调用了`this.authStatus.next`，我们只需接入数据流。这有助于保持无状态并避免副作用，通过解耦函数来实现。
- en: Note that we also initialize the `BehaviorSubject` using the `getItem` function.
    Using the nullish coalescing operator, we only use cached data if it is not `undefined`
    or `null`. Otherwise, we provide the default value.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还在初始化`BehaviorSubject`时使用了`getItem`函数。使用空值合并运算符，我们只有在缓存的数据不是`undefined`或`null`时才使用它。否则，我们提供默认值。
- en: You can implement your own custom cache expiration scheme in the `setItem` and
    `getItem` functions or leverage a service created by a third party.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`setItem`和`getItem`函数中实现自己的自定义缓存过期方案，或者利用第三方创建的服务。
- en: However, for an additional layer of security, we won’t cache the `authStatus`
    object. Instead, we will only cache the encoded JWT, which contains just enough
    information, so we can authenticate requests sent to the server.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了额外的安全层，我们不会缓存`authStatus`对象。相反，我们只会缓存编码后的JWT，它只包含足够的信息，以便我们可以验证发送到服务器的请求。
- en: In the Implementing JWT auth section of *Chapter 7*, *Working with REST and
    GraphQL APIs,* we discuss how you should encrypt and verify JWT token validity
    to avoid token-based exploits.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7章的“实现JWT身份验证”部分，我们在“与REST和GraphQL API一起工作”中讨论了您应该如何加密和验证JWT令牌的有效性，以避免基于令牌的攻击。
- en: It is important to understand how token-based authentication works to avoid
    revealing compromising secrets. Review the JWT life cycle earlier in this chapter
    to improve your understanding.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 理解基于令牌的认证工作方式对于避免泄露敏感信息至关重要。回顾本章早些时候的JWT生命周期，以加深你的理解。
- en: Next, let’s cache the token.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们缓存令牌。
- en: Caching the JWT
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存JWT
- en: 'Let’s update the authentication service so that it can cache the token:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新身份验证服务，使其能够缓存令牌：
- en: 'Update `AuthService` to be able to set, get, and clear the token, as shown
    here:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`AuthService`以能够设置、获取和清除令牌，如下所示：
- en: '[PRE35]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Call `clearToken` and `setToken` during `login`, and `clearToken` during `logout`,
    as shown here:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`login`期间调用`clearToken`和`setToken`，在`logout`期间调用`clearToken`，如下所示：
- en: '[PRE36]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Every subsequent request will contain the JWT in the request header. You should
    secure every API to check for and validate the token received. For example, if
    a user wants to access their profile, the `AuthService` will validate the token
    to check whether the user is authenticated or not; however, a further database
    call will still be required to check whether the user is also authorized to view
    the data. This ensures an independent confirmation of the user’s access to the
    system and prevents any abuse of an unexpired token.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 每个后续请求都将包含在请求头中的JWT。你应该确保每个API都检查并验证收到的令牌。例如，如果用户想要访问他们的个人资料，`AuthService`将验证令牌以检查用户是否经过身份验证；然而，还需要进一步的数据库调用来检查用户是否有权查看数据。这确保了对用户访问系统的独立确认，并防止了对未过期令牌的滥用。
- en: If an authenticated user makes a call to an API where they don’t have the proper
    authorization (say, if a clerk wants to get access to a list of all users), then
    the `AuthService` will return a `falsy` status, and the client will receive a
    `403 Forbidden` response, which will be displayed as an error message to the user.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个经过身份验证的用户调用了一个他们没有适当授权的API（比如说，如果一名职员想要获取所有用户的列表），那么`AuthService`将返回一个`falsy`状态，客户端将收到一个`403
    禁止`的响应，这将被显示为用户的一个错误消息。
- en: A user can make a request with an expired token; when this happens, a `401 Unauthorized`
    response is sent to the client. As a good UX practice, we should automatically
    prompt the user to log in again and let them resume their workflow without any
    data loss.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以使用过期的令牌进行请求；当这种情况发生时，会向客户端发送一个`401 未授权`的响应。作为一个好的用户体验实践，我们应该自动提示用户重新登录，并允许他们在不丢失任何数据的情况下继续他们的工作流程。
- en: In summary, true security is achieved with robust server-side implementation.
    Any client-side implementation is largely there to enable a good UX around good
    security practices.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，真正的安全性是通过强大的服务器端实现来实现的。任何客户端实现主要是为了在良好的安全实践周围提供良好的用户体验。
- en: An in-memory auth service
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存中的身份验证服务
- en: 'Now, let’s implement a concrete version of the auth service that we can use:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现一个具体版本的身份验证服务，我们可以使用它：
- en: 'Start by installing a JWT decoding library and, to fake authentication, a JWT
    encoding library:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先安装一个 JWT 解码库，以及为了模拟身份验证，一个 JWT 编码库：
- en: '[PRE37]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Extend the abstract `AuthService`:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展 `AuthService` 抽象类：
- en: '[PRE38]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Implement a fake `authProvider` function that simulates the authentication
    process, including creating a fake JWT on the fly:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个模拟的 `authProvider` 函数，模拟身份验证过程，包括动态创建一个模拟 JWT：
- en: '[PRE39]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `authProvider` implements what would otherwise be a server-side method right
    in the service, so we can conveniently experiment with the code while fine-tuning
    our auth workflow. The provider creates and signs a JWT with the temporary `fake-jwt-sign`
    library so that I can also demonstrate how to handle a properly formed JWT.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`authProvider` 在服务中实现了原本应该在服务器端实现的方法，这样我们就可以方便地在微调身份验证工作流程的同时实验代码。提供者使用临时的
    `fake-jwt-sign` 库创建并签名 JWT，这样我也可以演示如何处理一个正确形成的 JWT。'
- en: Do not ship your Angular application with the `fake-jwt-sign` dependency, since
    it is meant to be server-side code.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要将 `fake-jwt-sign` 依赖项打包到你的 Angular 应用程序中，因为它意味着是服务器端代码。
- en: 'In contrast, a real auth provider would include a `POST` call to a server.
    See the example code that follows:'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相比之下，一个真实的身份验证提供者将包括一个发送到服务器的 `POST` 调用。请参阅以下示例代码：
- en: '[PRE40]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It is pretty straightforward, since the hard work is done on the server side.
    This call can also be made to a third-party auth provider, which I cover in the
    Firebase authentication recipe later in this chapter.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这相当直接，因为困难的工作已经在服务器端完成。这个调用也可以发送给第三方身份验证提供者，我将在本章后面的 Firebase 身份验证食谱中介绍。
- en: Note that the API version, `v1`, in the URL path is defined at the service and
    not as part of the `baseUrl`. This is because each API can change versions independently.
    Login may remain `v1` for a long time, while other APIs may be upgraded to `v2`,
    `v3`, and so on.
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，URL 路径中的 API 版本 `v1` 是在服务中定义的，而不是作为 `baseUrl` 的一部分。这是因为每个 API 可以独立更改版本。登录可能长时间保持为
    `v1`，而其他 API 可能升级到 `v2`、`v3` 等等。
- en: 'Implementing `transformJwtToken` will be trivial because the login function
    provides us with a token that adheres to `IAuthStatus`:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `transformJwtToken` 将是微不足道的，因为登录函数为我们提供了一个符合 `IAuthStatus` 的令牌：
- en: '[PRE41]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, implement `getCurrentUser`, which should return some default user:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现 `getCurrentUser`，它应该返回一些默认用户：
- en: '[PRE42]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Next, provide a `defaultUser` as a private property to the class; what follows
    is one that I’ve created.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，将 `defaultUser` 作为私有属性提供给类；以下是我创建的一个示例。
- en: 'Add a private `defaultUser` property to the `InMemoryAuthService` class:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `InMemoryAuthService` 类中添加一个私有的 `defaultUser` 属性：
- en: '[PRE43]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Congratulations! You’ve implemented a concrete, but still fake, auth service.
    Now that you have the in-memory auth service in place, be sure to run your Angular
    application and ensure no errors are present.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经实现了一个具体但仍然模拟的身份验证服务。现在你已经有了一个内存中的身份验证服务，确保运行你的 Angular 应用程序并且没有错误出现。
- en: Let’s test our auth service by implementing a simple login and logout functionality
    accessible through the UI.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过实现一个简单的登录和注销功能来测试我们的身份验证服务，这些功能可以通过 UI 访问。
- en: Simple login
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单登录
- en: Before we implement a fully-featured `login` component, let’s wire up the pre-baked
    login behavior to the **Login as manager** button we have in the `HomeComponent`.
    We can test the behavior of our auth service before getting into the details of
    delivering a rich UI component.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现一个功能齐全的 `login` 组件之前，让我们将预制的登录行为连接到 `HomeComponent` 中的“登录为管理员”按钮。在我们深入了解交付丰富
    UI 组件的细节之前，我们可以测试我们的身份验证服务的功能。
- en: Our goal is to simulate logging in as a manager. To accomplish this, we need
    to hardcode an email address and a password to log in and, upon successful login,
    maintain the functionality of navigating to the `/manager` route.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是模拟登录为管理员。为了实现这一点，我们需要硬编码一个电子邮件地址和密码进行登录，并在登录成功后，保持导航到 `/manager` 路由的功能。
- en: Note that on GitHub, the code sample for this section resides in a file named
    `home.component.simple.ts` under the folder structure of `projects/stage8`. The
    alternate file exists for reference purposes only because the code from this section
    dramatically changes later in the chapter. Ignore the filename difference, as
    it will not impact your coding for this section.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在GitHub上，本节代码示例位于`projects/stage8`文件夹结构下的`home.component.simple.ts`文件中。另一个文件仅用于参考目的，因为本章后面的代码将对此部分进行重大更改。忽略文件名差异，因为它不会影响本节编码。
- en: 'Let’s implement a simple login mechanism:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个简单的登录机制：
- en: 'In the `HomeComponent`, implement a `login` function that uses the `AuthService`:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HomeComponent`中实现一个使用`AuthService`的`login`函数：
- en: '[PRE44]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Update the template to remove the `routerLink` and, instead, call the `login`
    function:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新模板以删除`routerLink`，而不是调用`login`函数：
- en: '[PRE45]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: On successful login, we need to navigate to the `/manager` route. We can verify
    that we’re successfully logged in by listening to the `authStatus$` and `currentUser$`
    observables exposed by the `AuthService`. If `authStatus$.isAuthenticated` is
    `true` and `currentUser$._id` is a non-empty string, we have a valid login. We
    can listen to both observables by using RxJS’s `combineLatest` operator. Given
    a valid login condition, we can then use the `filter` operator to reactively navigate
    to the `/manager` route.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在成功登录后，我们需要导航到`/manager`路由。我们可以通过监听`AuthService`公开的`authStatus$`和`currentUser$`可观察对象来验证我们是否成功登录。如果`authStatus$.isAuthenticated`为`true`且`currentUser$._id`是一个非空字符串，则表示有效的登录。我们可以通过使用RxJS的`combineLatest`运算符来监听这两个可观察对象。在有效的登录条件下，然后我们可以使用`filter`运算符来响应式地导航到`/manager`路由。
- en: 'Update the `login()` function to implement the login conditional, and upon
    success, navigate to the `/manager` route:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`login()`函数以实现登录条件，并在成功后导航到`/manager`路由：
- en: '[PRE46]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note that we subscribe to the `combineLatest` operator at the end, which is
    critical in activating the observable streams. Otherwise, our login action will
    remain dormant unless some other component subscribes to the stream. You only
    need to activate a stream once.
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们在最后订阅了`combineLatest`运算符，这在激活可观察流中是至关重要的。否则，除非其他组件订阅了流，我们的登录操作将保持休眠状态。你只需要激活一次流。
- en: Now, test out the new `login` functionality. Verify that the JWT is created
    and stored in `localStorage` using the **Chrome DevTools | Application** tab,
    as shown here:![](img/B20960_05_04.png)
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，测试新的`login`功能。验证JWT是否已创建并存储在`localStorage`中，如这里所示：![img/B20960_05_04.png]
- en: 'Figure 5.4: DevTools showing Application | Local Storage'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.4：DevTools显示应用程序 | 本地存储
- en: You can view **Local Storage** under the **Application** tab. Make sure that
    the URL of your application is highlighted. In *step 3*, you can see that we have
    a key named `jwt` with a valid-looking token.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在**应用程序**选项卡下查看**本地存储**。确保你的应用程序URL被突出显示。在*步骤 3*中，你可以看到我们有一个名为`jwt`的键，它包含一个看起来有效的令牌。
- en: Note *steps 4* and *5*, highlighting two warnings, which, respectively, advise
    us not to use the `InMemoryAuthService` and the `fake-jwt-sign` package in production
    code.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 注意*步骤 4*和*步骤 5*，突出显示两个警告，分别建议我们不要在生产代码中使用`InMemoryAuthService`和`fake-jwt-sign`包。
- en: Use breakpoints to debug and step through the code to get a more concrete understanding
    of how `HomeComponent`, `InMemoryAuthService`, and `AuthService` work together
    to log the user in.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 使用断点进行调试并逐步执行代码，以更具体地了解`HomeComponent`、`InMemoryAuthService`和`AuthService`如何协同工作以登录用户。
- en: When you refresh the page, note that you’re still logged in because we’re caching
    the token in local storage.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当你刷新页面时，请注意你仍然处于登录状态，因为我们正在本地存储中缓存令牌。
- en: Since we’re caching the login status, we must also implement a logout experience
    to complete the auth workflow.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在缓存登录状态，我们必须实现一个登出体验来完成认证工作流程。
- en: Logout
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登出
- en: 'The logout button on the application toolbar is already wired up to navigate
    to the `logout` component we created before. Let’s update this component so that
    it can log the user out when navigated to:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序工具栏上的登出按钮已经连接到我们之前创建的`logout`组件。让我们更新这个组件，以便在导航到时能够登出用户：
- en: 'Implement the `logout` component:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现登录组件：
- en: '[PRE47]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note that we explicitly clear the JWT by passing in `true` to the `logout` function.
    After we call `logout`, we navigate the user back to the home page.
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们通过将`true`传递给`logout`函数来显式清除JWT。在调用`logout`之后，我们将用户导航回主页。
- en: Test out the `logout` button.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试`logout`按钮。
- en: Verify that local storage is cleared after logout.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证在登出后本地存储已被清除。
- en: We have nailed a solid login and logout implementation. However, we’re not yet
    done with the fundamentals of our auth workflow.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了稳固的登录和注销功能。然而，我们还没有完成我们认证流程的基础。
- en: Next, we need to consider the expiration status of our JWT.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要考虑我们的 JWT 的过期状态。
- en: Resuming a JWT session
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恢复 JWT 会话
- en: It wouldn’t be a great UX if you had to log in to Gmail or Amazon every time
    you visited the site. This is why we cache the JWT, but it would be an equally
    bad UX to keep you logged in forever. A JWT has an expiration date policy, where
    the provider can select a few minutes or even months to allow your token to be
    valid, depending on security needs. The in-memory service creates tokens that
    expire in one hour, so if a user refreshes their browser window within that frame,
    we should honor the valid token and let the user continue using the application,
    without asking them to log back in.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你每次访问网站时都必须登录 Gmail 或 Amazon，那么用户体验将不会很好。这就是为什么我们缓存 JWT，但如果你永远保持登录状态，用户体验同样糟糕。JWT
    有一个过期日期策略，提供商可以选择几分钟甚至几个月来允许你的令牌有效，这取决于安全需求。内存服务创建的令牌在一小时内过期，所以如果用户在那一时间段内刷新浏览器窗口，我们应该尊重有效的令牌，并允许用户继续使用应用程序，而无需要求他们重新登录。
- en: On the flip side, if the token is expired, we should automatically navigate
    the user to the login screen for a smooth UX.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果令牌已过期，我们应该自动将用户导航到登录屏幕，以实现流畅的用户体验。
- en: 'Let’s get started:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'Update the `AuthService` class to implement a function named `hasExpiredToken`
    to check whether the token is expired, and a helper function named `getAuthStatusFromToken`
    to decode the token, as shown here:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `AuthService` 类以实现一个名为 `hasExpiredToken` 的函数来检查令牌是否过期，以及一个名为 `getAuthStatusFromToken`
    的辅助函数来解码令牌，如下所示：
- en: '[PRE48]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Keep your code DRY! Update the `login()` function to use `getAuthStatusFromToken()`
    instead.
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保持你的代码 DRY！将 `login()` 函数更新为使用 `getAuthStatusFromToken()`。
- en: 'Update the constructor of `AuthService` to check the status of the token:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `AuthService` 的构造函数以检查令牌的状态：
- en: '[PRE49]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If the token is expired, we log the user out and clear the token from `localStorage`.
    Otherwise, we decode the token and push the auth status to the data stream.
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果令牌已过期，我们注销用户并从 `localStorage` 中清除令牌。否则，我们解码令牌并将认证状态推送到数据流中。
- en: A corner case to consider here is to also trigger the reloading of the current
    user in the event of a resumption. We can do this by implementing a new pipe that
    reloads the current user if activated.
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里需要考虑的一个特殊情况是，在恢复会话时也要触发当前用户的重新加载。我们可以通过实现一个新的管道来实现这一点，如果激活，则重新加载当前用户。
- en: 'First, let’s refactor the existing user update logic in the `login()` function
    to a private property named `getAndUpdateUserIfAuthenticated` so that we can reuse
    it:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们将 `login()` 函数中现有的用户更新逻辑重构为一个名为 `getAndUpdateUserIfAuthenticated` 的私有属性，以便我们可以重用它：
- en: '[PRE50]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In `AuthService`, define an observable property named `resumeCurrentUser$`
    as a fork of `authStatus$`, and use the `getAndUpdateUserIfAuthenticated` logic:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AuthService` 中，定义一个名为 `resumeCurrentUser$` 的可观察属性，作为 `authStatus$` 的分支，并使用
    `getAndUpdateUserIfAuthenticated` 逻辑：
- en: '[PRE51]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Once `resumeCurrentUser$` is activated and `status.isAuthenticated` is `true`,
    then `this.getCurrentUser()` will be invoked and `currentUser$` will be updated.
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦 `resumeCurrentUser$` 被激活且 `status.isAuthenticated` 为 `true`，则 `this.getCurrentUser()`
    将被调用，并且 `currentUser$` 将被更新。
- en: 'Update the constructor of `AuthService` to activate the pipeline if the token
    has not expired:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `AuthService` 的构造函数，如果令牌未过期则激活管道：
- en: '[PRE52]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Using the preceding technique, we can retrieve the latest user profile data
    without dealing with caching issues.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的技术，我们可以检索最新的用户配置文件数据，而无需处理缓存问题。
- en: To experiment with token expiration, I recommend creating a faster-expiring
    token in `InMemoryAuthService`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 要实验令牌过期，我建议在 `InMemoryAuthService` 中创建一个更快过期的令牌。
- en: As demonstrated earlier in the caching section, it is possible to cache the
    user profile data using `this.cache.setItem` and the profile data from the cache
    on the first launch. This would provide a faster UX and cover cases where users
    may be offline. After the application launches, you could asynchronously fetch
    fresh user data and update `currentUser$` when new data comes in. You would need
    to add additional caching and tweak the `getCurrentUser()` logic to get such functionality
    working. Oh, and you would need a whole lot of testing! It takes a lot of testing
    to create a high-quality auth experience.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如缓存部分之前所演示的，可以使用`this.cache.setItem`和缓存中的配置文件数据在首次启动时缓存用户配置文件数据。这将提供更快的用户体验，并覆盖用户可能离线的情况。应用启动后，您可以异步获取新鲜的用户数据，并在新数据到来时更新`currentUser$`。您需要添加额外的缓存并调整`getCurrentUser()`逻辑以使此功能正常工作。哦，您还需要进行大量的测试！创建高质量的认证体验需要大量的测试。
- en: Congratulations! We’re done implementing a robust auth workflow! Next, we need
    to integrate auth with Angular’s HTTP client to attach the token to the HTTP header
    of every request.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们已经完成了健壮的认证工作流程的实现！接下来，我们需要将认证与Angular的HTTP客户端集成，以便将令牌附加到每个请求的HTTP头中。
- en: An HTTP interceptor
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个HTTP拦截器
- en: 'Implement an HTTP interceptor to inject the JWT into the header of every request
    sent to the API, and gracefully handle authentication failures by asking the user
    to log back in:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个HTTP拦截器，将JWT注入到发送到API的每个请求的头部中，并通过提示用户重新登录来优雅地处理认证失败：
- en: 'Create an `AuthHttpInterceptor` under `auth`:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`auth`下创建一个`AuthHttpInterceptor`：
- en: '[PRE53]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note that `AuthService` is leveraged to retrieve the token, and the `redirectUrl`
    is set for the `login` component after a `401` error.
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到`AuthService`被用来检索令牌，并且在`401`错误后为`login`组件设置了`redirectUrl`。
- en: Note the if statement `if (req.url.startsWith(baseUrl))` filters out any outgoing
    requests not made to our API. This way, we don’t leak our JWT token to external
    services.
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到if语句`if (req.url.startsWith(baseUrl))`过滤掉了所有不是发送到我们API的出站请求。这样，我们就不会将JWT令牌泄露给外部服务。
- en: 'Update `app.config.ts` to provide the interceptor:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`app.config.ts`以提供拦截器：
- en: '[PRE54]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Ensure that the interceptor adds the token to requests. To do this, open the
    **Chrome DevTools | Network** tab, log in, and then refresh the page:![](img/B20960_05_05.png)
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保拦截器将令牌添加到请求中。为此，打开**Chrome DevTools | 网络**标签，登录，然后刷新页面：![img/B20960_05_05.png](img/B20960_05_05.png)
- en: 'Figure 5.5: The request header for lemon.svg'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.5：lemon.svg的请求头
- en: In *step 4*, you can now observe the interceptor in action. The request for
    the `lemon.svg` file has the bearer token in the request header.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，您现在可以观察到拦截器的实际操作。对`lemon.svg`文件的请求在请求头中包含了承载令牌。
- en: Now that we have our auth mechanism implemented, let’s take advantage of all
    the supporting code we have written with dynamic UI components and a conditional
    navigation system, creating a role-based UX in the next chapter.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了认证机制，让我们利用我们编写的所有支持代码，包括动态UI组件和条件导航系统，在下一章中创建基于角色的用户体验。
- en: Summary
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You should now have a solid understanding of how JWT works, how to use TypeScript
    for safe data handling, and how to build extendable services. In this chapter,
    we defined a `User` object that we can hydrate from or serialize to JSON objects,
    applying object-oriented class design and TypeScript operators for safe data handling.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该对JWT的工作原理、如何使用TypeScript进行安全数据处理以及如何构建可扩展的服务有一个稳固的理解。在本章中，我们定义了一个`User`对象，我们可以从它中提取或将其序列化为JSON对象，应用面向对象类设计和TypeScript运算符进行安全数据处理。
- en: We leveraged OOP design principles, using inheritance and abstract classes to
    implement a base auth service that demonstrates the Open/Closed principle.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用面向对象设计原则，使用继承和抽象类来实现一个基本的认证服务，该服务演示了开放/封闭原则。
- en: We covered the fundamentals of token-based authentication and JWTs so that you
    don’t leak any critical user information. You learned that caching and HTTP interceptors
    are necessary so that users don’t have to input their login information with every
    request. Following that, we implemented an in-memory auth service that doesn’t
    require any external dependencies, which is great for testing.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们涵盖了基于令牌的认证和JWT的基础知识，这样您就不会泄露任何关键用户信息。您学习了缓存和HTTP拦截器是必要的，这样用户就不必在每次请求时输入他们的登录信息。在此之后，我们实现了一个内存中的认证服务，它不需要任何外部依赖，这对于测试来说非常好。
- en: Coming up, in *Chapter 6*, *Implementing Role Based Navigation*, we will build
    a dynamic UI with navigation and component states reacting to the auth status
    of the app, using router and auth guards, flex layout media queries, Material
    components, and a service factory. We will also implement a Firebase auth provider
    so that you can host your apps on Google Firebase. In *Chapter 7*, *Working with
    REST and GraphQL APIs*, we will bring it all together with two custom auth providers
    that can authenticate against LemonMart Server, using the Minimal MEAN stack.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 6 章 *实现基于角色的导航* 中，我们将构建一个动态 UI，使用路由和身份验证守卫，弹性布局媒体查询，Material 组件和服务工厂，以响应应用程序的身份验证状态。我们还将实现
    Firebase 身份验证提供者，以便您可以在 Google Firebase 上托管您的应用程序。在第 7 章 *与 REST 和 GraphQL API
    一起工作* 中，我们将使用两个自定义身份验证提供者将所有内容整合在一起，这些提供者可以针对 LemonMart 服务器进行身份验证，使用 Minimal MEAN
    堆栈。
- en: Further reading
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Salted Password Hashing - Doing it Right, Defuse Security*, 2019; [https://crackstation.net/hashing-security.htm](https://crackstation.net/hashing-security.htm).'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*盐值密码散列 - 正确的做法，Defuse 安全*，2019；[https://crackstation.net/hashing-security.htm](https://crackstation.net/hashing-security.htm).'
- en: '*Object-oriented programming*; [https://en.wikipedia.org/wiki/Object-oriented_programming](https://en.wikipedia.org/wiki/Object-oriented_programming).'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*面向对象编程*；[https://en.wikipedia.org/wiki/Object-oriented_programming](https://en.wikipedia.org/wiki/Object-oriented_programming).'
- en: '*TypeScript Classes*; [https://www.typescriptlang.org/docs/handbook/classes.html](https://www.typescriptlang.org/docs/handbook/classes.html).'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*TypeScript 类*；[https://www.typescriptlang.org/docs/handbook/classes.html](https://www.typescriptlang.org/docs/handbook/classes.html).'
- en: '*TypeScript Basic Types*; [https://www.typescriptlang.org/docs/handbook/basic-types.html](https://www.typescriptlang.org/docs/handbook/basic-types.html).'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*TypeScript 基本类型*；[https://www.typescriptlang.org/docs/handbook/basic-types.html](https://www.typescriptlang.org/docs/handbook/basic-types.html).'
- en: '*TypeScript Advanced Types*; [https://www.typescriptlang.org/docs/handbook/advanced-types.html](https://www.typescriptlang.org/docs/handbook/advanced-types.html).'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*TypeScript 高级类型*；[https://www.typescriptlang.org/docs/handbook/advanced-types.html](https://www.typescriptlang.org/docs/handbook/advanced-types.html).'
- en: '*TypeScript 3.7 Features*; [https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html).'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*TypeScript 3.7 特性*；[https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html).'
- en: '*Authentication General Guidelines*; [https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Authentication_Cheat_Sheet.md](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Authentication_Cheat_Sheet.md).'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*身份验证通用指南*；[https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Authentication_Cheat_Sheet.md](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Authentication_Cheat_Sheet.md).'
- en: '*How to secure your Firebase project even when your API key is publicly available*;
    paachu, 2019, [https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-available-a462a2a58843](https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-available-a462a2a58843).'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*即使您的 API 密钥公开可用，如何保护您的 Firebase 项目*；paachu，2019，[https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-available-a462a2a58843](https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-available-a462a2a58843).'
- en: Questions
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions as best as possible to ensure you’ve understood
    the key concepts from this chapter without googling anything. Do you know if you
    got all the answers right? Visit [https://angularforenterprise.com/self-assessment](https://angularforenterprise.com/self-assessment)
    for more:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地回答以下问题，以确保您已经理解了本章的关键概念，而无需进行任何谷歌搜索。你知道你是否答对了所有问题吗？访问 [https://angularforenterprise.com/self-assessment](https://angularforenterprise.com/self-assessment)
    获取更多信息：
- en: What’s in-transit and at-rest security?
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在传输中和静止状态下的安全性是什么？
- en: What’s the difference between authentication and authorization?
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 身份验证和授权之间的区别是什么？
- en: Explain inheritance and polymorphism.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释继承和多态。
- en: What is an abstract class?
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抽象类是什么？
- en: What is an abstract method?
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抽象方法是什么？
- en: Explain how the `AuthService` adheres to the Open/Closed principle.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释 `AuthService` 如何遵循开放/封闭原则。
- en: How does JWT verify your identity?
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JWT 如何验证您的身份？
- en: What is the difference between RxJS’s `combineLatest` and `merge` operators?
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RxJS 的 `combineLatest` 和 `merge` 操作符之间的区别是什么？
- en: What is a route guard?
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由守卫是什么？
- en: What does a service factory allow you to do?
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务工厂允许您做什么？
- en: Join our community on Discord
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/AngularEnterpise3e](Chapter_5.xhtml)'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/AngularEnterpise3e](Chapter_5.xhtml)'
- en: '![](img/QR_Code1116411172100421421.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code1116411172100421421.png)'
