- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Introducing Layered Architecture in React
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在React中引入分层架构
- en: As React applications grow in size and complexity, managing code efficiently
    becomes a challenge. The linear growth of features can lead to an exponential
    increase in complexity, making the code base difficult to understand, test, and
    maintain. Enter **Layered Architecture**, a design approach that’s not just confined
    to backend systems but is equally beneficial for client-side applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着React应用程序的大小和复杂性的增长，有效地管理代码成为一个挑战。功能的线性增长可能导致复杂性的指数级增加，使得代码库难以理解、测试和维护。进入**分层架构**，这是一种不仅限于后端系统，而且对客户端应用程序同样有益的设计方法。
- en: 'Structuring your React application in a layered manner solves several key problems:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以分层方式构建你的React应用程序可以解决几个关键问题：
- en: '**Separation of concerns**: Different layers handle different responsibilities,
    making the code base easier to navigate and understand'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离**：不同的层处理不同的责任，使得代码库更容易导航和理解'
- en: '**Reusability**: Business logic and data models become easily reusable across
    different parts of the application'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：业务逻辑和数据模型可以轻松地在应用程序的不同部分之间重用'
- en: '**Testability**: A layered architecture makes it simpler to write unit and
    integration tests, leading to a more robust application'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试性**：分层架构使得编写单元和集成测试更加简单，从而使得应用程序更加健壮'
- en: '**Maintainability**: As the application scales, making changes or adding features
    becomes significantly easier when following a layered structure'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：随着应用程序的扩展，遵循分层结构进行更改或添加功能变得显著更容易'
- en: In this chapter, we will explore the concept of layered architecture in the
    context of a React application, delving into the extraction of application concern
    layers, defining precise data models, and illustrating the use of strategy patterns.
    Through a step-by-step example, we’ll see how to practically implement these concepts
    and why they are indispensable for large-scale applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨在React应用程序的背景下分层架构的概念，深入探讨提取应用关注层、定义精确的数据模型以及展示策略模式的使用。通过逐步示例，我们将看到如何实际实现这些概念，以及为什么它们对于大规模应用程序是不可或缺的。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the evolution of a React application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解React应用程序的演变
- en: Enhancing the Code Oven application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提升Code Oven应用程序
- en: Implementing the ShoppingCart component
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现ShoppingCart组件
- en: Delving into layered architecture
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入研究分层架构
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: A GitHub repository has been created to host all the code we discuss in the
    book. For this chapter, you can find the recommended structure at [https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch11](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch11).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 已创建一个GitHub仓库来托管本书中讨论的所有代码。对于本章，你可以在[https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch11](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch11)找到推荐的结构。
- en: Understanding the evolution of a React application
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解React应用程序的演变
- en: Applications with different sizes require different strategies. For small or
    one-off projects, you might find that all logic is just written inside React components.
    You may see one or only a few components in total. The code looks pretty much
    like HTML, with only some variables or states used to make the page “dynamic,”
    but overall, the code is easy to understand and change.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 不同规模的应用程序需要不同的策略。对于小型或一次性项目，你可能会发现所有逻辑都只是写在React组件内部。你可能只会看到一到几个组件。代码看起来几乎像是HTML，只使用了一些变量或状态来使页面“动态”，但总体来说，代码易于理解和修改。
- en: As the application grows, and more and more code is added to the code base,
    without a proper way to organize it, the code base will soon get into an unmaintainable
    state. This means that even adding small features will be time-consuming as developers
    need more time to read the code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的增长，越来越多的代码被添加到代码库中，如果没有适当的方式来组织它们，代码库很快就会陷入不可维护的状态。这意味着即使添加小的功能也会变得耗时，因为开发者需要更多的时间来阅读代码。
- en: In this section, I’ll list several different ways we can structure our React
    application to make sure our code always remains in a healthy state, making it
    effortless to add new features and easy to extend or fix existing defects. We’ll
    start with a simple structure and gradually evolve it to handle scale problems.
    Let’s have a quick review of the steps to build frontend applications that scale.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将列出几种不同的方法，我们可以用这些方法来构建我们的React应用，以确保我们的代码始终保持健康状态，使得添加新功能变得轻而易举，并且易于扩展或修复现有缺陷。我们将从一个简单的结构开始，并逐步演进以处理规模问题。让我们快速回顾一下构建可扩展前端应用的步骤。
- en: Single-component applications
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单组件应用
- en: To start, let’s talk about the simplest possible approach to writing a React
    application – a single-component application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈编写React应用的最简单方法——单组件应用。
- en: "![Figure 11.1: Single-component applic\uFEFFation](img/B31103_11_01.jpg)"
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1：单组件应用](img/B31103_11_01.jpg)'
- en: 'Figure 11.1: Single-component application'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1：单组件应用
- en: The mono-component undertakes a variety of tasks, ranging from fetching data
    from a remote server, managing its internal state, and handling domain logic,
    to rendering. This approach may be suitable for small applications with a single
    form or for those looking to understand the process of transitioning their application
    from another framework to React.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 单组件承担了各种任务，从从远程服务器获取数据、管理其内部状态，到处理领域逻辑，再到渲染。这种方法可能适用于只有单个表单的小型应用，或者那些希望了解将应用从另一个框架迁移到React的过程。
- en: However, you’ll soon realize that consolidating everything into a single component
    can make the code difficult to understand and manage. Everything being housed
    in one component can quickly become overwhelming, particularly when dealing with
    logic such as iterating over item lists to create individual components. This
    complexity highlights the need to decompose the mono-component into smaller, responsibility-focused
    components.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你很快就会意识到将所有内容都整合到一个组件中会使代码难以理解和管理。所有内容都放在一个组件中会很快变得令人不知所措，尤其是在处理诸如遍历项目列表以创建单个组件的逻辑时。这种复杂性突显了将单组件分解为更小、职责明确的组件的需求。
- en: Multiple-component applications
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多组件应用
- en: Deciding to split the component into several components, with these structures
    reflecting what’s happening on the resulting HTML, is a good idea and it helps
    you to focus on one component at a time.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 决定将组件拆分为几个组件，这些结构反映了最终HTML上的情况，这是一个好主意，并且有助于你一次专注于一个组件。
- en: '![Figure 11.2: Multiple-component application](img/B31103_11_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2：多组件应用](img/B31103_11_02.jpg)'
- en: 'Figure 11.2: Multiple-component application'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.2：多组件应用](img/B31103_11_02.jpg)'
- en: Essentially, you’ll transition from a monolithic component to multiple components,
    each with a specific purpose. For example, one component may be dedicated to rendering
    a list, another to rendering a list item, and another solely for fetching data
    and passing data down to its children.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你将从一个单体组件过渡到多个组件，每个组件都有特定的目的。例如，一个组件可能专门用于渲染列表，另一个用于渲染列表项，还有一个仅用于获取数据并将其传递给子组件。
- en: It’s better to have clear responsibilities. However, as your application expands,
    responsibilities extend beyond the view layer to include tasks such as sending
    network requests, reshaping data for the view to consume, and collecting data
    to send back to the server. Additionally, there might be logic to transform data
    once it’s fetched. Housing this calculation logic within views doesn’t seem appropriate
    as it’s not directly related to user interfaces. Moreover, some components may
    become cluttered with excessive internal states.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有明确的职责会更好。然而，随着你的应用扩展，职责不仅限于视图层，还包括发送网络请求、为视图重塑数据以供消费、收集数据以发送回服务器等任务。此外，一旦数据被获取，可能还需要对数据进行转换的逻辑。将这种计算逻辑放在视图中似乎并不合适，因为它与用户界面没有直接关系。此外，一些组件可能会因为过多的内部状态而变得杂乱无章。
- en: State management with Hooks
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Hooks进行状态管理
- en: It’s a better idea to split this logic into separate places. Luckily, in React,
    you can define your own Hooks. This is a great way to share this state and the
    logic whenever state changes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将这种逻辑拆分到不同的地方会更好。幸运的是，在React中，你可以定义自己的Hooks。这是一种在状态变化时共享状态和逻辑的绝佳方式。
- en: '![Figure 11.3: State management with Hooks](img/B31103_11_03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图11.3：使用Hooks进行状态管理](img/B31103_11_03.jpg)'
- en: 'Figure 11.3: State management with Hooks'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：使用Hooks进行状态管理
- en: Now you have a bunch of elements extracted from components. You have a few pure
    presentational components, some reusable Hooks that make other components stateful,
    and some container components (for data fetching, for example).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经从组件中提取了一堆元素。你有一些纯展示组件，一些可复用的钩子，它们使其他组件具有状态，还有一些容器组件（例如用于数据获取）。
- en: At this stage, it’s common to find calculations scattered across views, Hooks,
    or various utility functions. The lack of structure can make further modifications
    quite challenging and prone to errors. For instance, if you’ve fetched some data
    for rendering, but the data schema differs in views, you’ll need to transform
    the data. However, the location for placing this transforming logic may not be
    clear.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可能会发现计算被分散在视图、钩子或各种实用函数中。缺乏结构可能会使进一步的修改变得非常具有挑战性，并且容易出错。例如，如果你已经获取了一些用于渲染的数据，但视图中的数据模式不同，你需要转换数据。然而，放置这种转换逻辑的位置可能并不明确。
- en: Extracting business models
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取商业模式
- en: So, you’ve started to become aware that extracting this logic into yet another
    place can bring you many benefits. For example, with that split, the logic can
    be cohesive and independent of any views. Then, you extract a few domain objects.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你已经开始意识到将这种逻辑提取到另一个地方可以带来许多好处。例如，通过这种分割，逻辑可以更加一致且独立于任何视图。然后，你提取了一些领域对象。
- en: 'These simple objects can handle data mapping (from one format to another),
    check nulls, and use fallback values as required. As the amount of these domain
    objects grows, you will find you need some inheritance or polymorphism to make
    things even cleaner. Thus you apply many design patterns you find helpful from
    other places to the frontend application:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的对象可以处理数据映射（从一个格式到另一个格式）、检查空值，并在需要时使用回退值。随着这些领域对象的增加，你会发现你需要一些继承或多态来使事情更加清晰。因此，你将应用从其他地方找到的许多有用的设计模式到前端应用中：
- en: '![Figure 11.4: Extracting business models](img/B31103_11_04.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图11.4：提取商业模式](img/B31103_11_04.jpg)'
- en: 'Figure 11.4: Extracting business models'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：提取商业模式
- en: Now, your code base has expanded with more elements, each having a clear boundary
    regarding their responsibilities. Hooks are employed for state management, while
    domain objects represent domain concepts, such as a user object encompassing an
    avatar, or a `PaymentMethod` object representing the details of a payment method.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的代码库已经通过更多元素扩展，每个元素都有关于其职责的明确边界。钩子用于状态管理，而领域对象代表领域概念，例如包含头像的用户对象，或代表支付方式详细信息的`PaymentMethod`对象。
- en: As we segregate different elements from the views, the code base scales accordingly.
    Eventually, it reaches a point where we need to structure the application to respond
    to changes more efficiently.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们从视图中分离出不同的元素，代码库相应地扩展。最终，我们会达到一个需要更高效地应对变化的点，这时我们需要对应用进行结构化。
- en: Layered frontend application
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分层前端应用
- en: As the application continues to evolve, certain patterns begin to emerge. You’ll
    notice a collection of objects that don’t belong to any user interface, and they
    remain indifferent to whether the underlying data originates from a remote service,
    local storage, or cache. Consequently, you’ll want to segregate them into distinct
    layers. We’ll need to introduce a better approach for these different parts of
    the application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用的持续发展，某些模式开始显现。你会注意到一些不属于任何用户界面的对象集合，它们对底层数据是否来自远程服务、本地存储或缓存保持中立。因此，你可能会希望将它们分离到不同的层。我们需要为应用的不同部分引入更好的方法。
- en: '![Figure 11.5: Layered frontend application](img/B31103_11_05.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图11.5：分层前端应用](img/B31103_11_05.jpg)'
- en: 'Figure 11.5: Layered frontend application'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5：分层前端应用
- en: As illustrated in *Figure 11**.5*, we can allocate different parts to separate
    folders, each distinctly and physically isolated from the others. This way, if
    there’s a need to modify models, you won’t need to navigate through the views
    folder, and vice versa.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图11.5*所示，我们可以将不同的部分分配到不同的文件夹中，每个文件夹都与其他文件夹明显且物理上隔离。这样，如果需要修改模型，你就不需要导航到视图文件夹，反之亦然。
- en: That was a high-level overview of the evolution process, and you should have
    a taste of how you should structure your code or at least what the direction should
    be. In larger-scale applications, you’ll likely encounter a variety of modules
    and functions, each tailored to different aspects of the app. This could include
    a request module for handling network requests, or adapters designed to interface
    with various data vendors, such as Google’s login API or payment gateway clients.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 那只是一个关于演变过程的高级概述，您应该对如何结构化您的代码或至少方向应该是什么有所了解。在更大规模的应用程序中，您可能会遇到各种模块和函数，每个都针对应用程序的不同方面进行了定制。这可能包括处理网络请求的请求模块，或者设计用于与各种数据供应商接口的适配器，例如谷歌的登录API或支付网关客户端。
- en: However, there will be many details, such as how to define a model, how to access
    a model from views or Hooks, and so on. You need to consider this before applying
    the theory to your application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，会有许多细节，例如如何定义一个模型，如何从视图或钩子中访问模型，等等。在将理论应用于您的应用程序之前，您需要考虑这些因素。
- en: Read more
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读更多
- en: 'You can find a detailed explanation of Presentation Domain Data Layering here:
    [https://martinfowler.com/bliki/PresentationDomainDataLayering.html](https://martinfowler.com/bliki/PresentationDomainDataLayering.html).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://martinfowler.com/bliki/PresentationDomainDataLayering.html](https://martinfowler.com/bliki/PresentationDomainDataLayering.html)找到关于表示域数据分层的高级概述。
- en: In the following sections, I’ll guide you through expanding the Code Oven application
    we introduced in [*Chapter 7*](B21103_07.xhtml#_idTextAnchor176), to showcase
    essential patterns and design principles for large frontend applications.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我将引导您扩展我们在[*第7章*](B21103_07.xhtml#_idTextAnchor176)中介绍的Code Oven应用程序，以展示大型前端应用程序的基本模式和设计原则。
- en: Enhancing the Code Oven application
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强 Code Oven 应用程序
- en: Recall that at the end of [*Chapter 7*](B21103_07.xhtml#_idTextAnchor176), we
    developed the basic structure of a pizza store application named Code Oven, leveraging
    test-driven development to establish a solid foundation for the app.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，到[*第7章*](B21103_07.xhtml#_idTextAnchor176)结束时，我们开发了一个名为Code Oven的披萨店应用程序的基本结构，利用测试驱动开发为应用程序建立坚实的基础。
- en: '![Figure 11.6: The Code Oven application](img/B31103_11_06.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图11.6：Code Oven应用程序](img/B31103_11_06.jpg)'
- en: 'Figure 11.6: The Code Oven application'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6：Code Oven应用程序
- en: Note
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that we employed the design mockup as a guide, not to implement all
    the details exhaustively. The primary goal remains to illustrate how to refactor
    the code while preserving its maintainability.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们使用设计草图作为指导，而不是详尽无遗地实现所有细节。主要目标仍然是说明如何在保持可维护性的同时重构代码。
- en: Although we didn’t delve much into feature implementation in that chapter, in
    this chapter, we’ll extend our setup further. We’ll explore how different architectural
    types can assist us in managing complexity.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在第7章中我们没有深入探讨功能实现，但在本章中，我们将进一步扩展我们的设置。我们将探讨不同架构类型如何帮助我们管理复杂性。
- en: 'As a refresher, by the end of [*Chapter 7*](B21103_07.xhtml#_idTextAnchor176),
    our structure looked like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 作为复习，到[*第7章*](B21103_07.xhtml#_idTextAnchor176)结束时，我们的结构看起来是这样的：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And we assumed the data to be in this shape:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设数据是这样的形状：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: While this setup allows consumers to browse what the restaurant offers, it would
    be significantly more useful if we enabled online ordering. However, one immediate
    issue is that the pizzas lack prices and descriptions, crucial for supporting
    online orders. Descriptions are also vital as they list the ingredients, informing
    consumers of what’s included.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种设置允许消费者浏览餐厅提供的菜品，但如果我们启用在线订购，这将更有用。然而，一个直接的问题是披萨缺少价格和描述，这对于支持在线订购至关重要。描述也很重要，因为它们列出了配料，告知消费者包含的内容。
- en: Saying that, it’s actually not practical to define menu data within the JavaScript
    code. Typically, we’d have a service hosting such data, providing more detailed
    information.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，在JavaScript代码中定义菜单数据实际上并不实用。通常，我们会有一个服务来托管此类数据，提供更详细的信息。
- en: 'To show this, suppose we have data hosted on the [https://api.code-oven.com/menus](https://api.code-oven.com/menus)
    remote service, defined as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这一点，假设我们有一个托管在[https://api.code-oven.com/menus](https://api.code-oven.com/menus)远程服务上的数据，定义如下：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To bridge the gap between our app and this data, we need to define a type for
    the remote data, like so:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了弥合我们的应用程序和这些数据之间的差距，我们需要为远程数据定义一个类型，如下所示：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, to integrate this remote menu data, we’ll utilize `useEffect` to fetch
    the data, and then display the items once fetched. We’ll make these changes within
    the `MenuList` component:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了集成这个远程菜单数据，我们将使用`useEffect`来获取数据，并在获取后显示项目。我们将在`MenuList`组件内进行这些更改：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the `MenuList` component fetches a list of menu items from an external
    API upon the initial render and displays this list. Each item comes with an `onAddMenuItem`
    function, passed as a prop to `MenuList`, with the item name as its argument.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`MenuList`组件在初始渲染时从外部API获取菜单项列表并显示此列表。每个项目都附带一个`onAddMenuItem`函数，作为属性传递给`MenuList`，其参数为项目名称。
- en: By mapping `RemoteMenuItem` to a string after fetching the data, we ensure our
    tests continue to pass.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在获取数据后将`RemoteMenuItem`映射到字符串，我们确保我们的测试继续通过。
- en: Now, we aim to reveal the price and display the ingredients from the data to
    the UI components. However, given the potentially long list of ingredients, we’ll
    only show the first three to avoid occupying too much screen space. Also, we want
    to use lowercase `category` and rename it to `type`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的目标是揭示价格并将数据中的成分显示到UI组件中。然而，鉴于成分列表可能很长，我们只显示前三个以避免占用过多的屏幕空间。此外，我们希望使用小写的`category`并将其重命名为`type`。
- en: 'Initially, we define a new type to better structure our data:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们定义一个新的类型以更好地结构化我们的数据：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, the `MenuItem` type includes the item’s `id`, `name`, `price`, `ingredients`,
    and `type` properties.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`MenuItem`类型包括项目的`id`、`name`、`price`、`ingredients`和`type`属性。
- en: 'Now, it’s time to update our `MenuList` component to use this new type:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候更新我们的`MenuList`组件以使用这种新类型：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the `MenuList` component, we’ve now made use of the `MenuItem` type in our
    `useState` Hook. The `fetchMenuItems` function, triggered within `useEffect`,
    reaches out to the API, fetches the menu items, and maps over them to transform
    the data into the desired `MenuItem` format. This transformation includes retaining
    only the first three items from the `ingredients` array for each item.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MenuList`组件中，我们现在已经使用了`MenuItem`类型在我们的`useState`钩子中。在`useEffect`中触发的`fetchMenuItems`函数调用API，获取菜单项，并将它们映射到以转换数据到所需的`MenuItem`格式。这种转换包括为每个项目保留`ingredients`数组中的前三个项目。
- en: Each `MenuItem` component is then rendered as a list item within the component.
    We display the item’s name, price, and iterate over the `ingredients` array to
    render each ingredient.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`MenuItem`组件随后在该组件内部渲染为一个列表项。我们显示项目的名称、价格，并遍历`ingredients`数组以渲染每个成分。
- en: 'While the code is functional, there’s a concern: we’ve intertwined network
    requests, data mapping, and rendering logic within a single component. It’s a
    sound practice to separate view-related code from non-view code, ensuring cleaner,
    more maintainable code.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码是功能性的，但存在一个担忧：我们在单个组件中交织了网络请求、数据映射和渲染逻辑。将视图相关的代码与非视图代码分离是一种良好的实践，可以确保代码更干净、更易于维护。
- en: Refactoring the MenuList through a custom Hook
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过自定义钩子重构MenuList
- en: We’re no strangers to using custom Hooks for data fetching – it’s a practice
    that enhances readability and organizes logic neatly. In our scenario, extracting
    the `menuItems` state and the fetching logic into a separate Hook will declutter
    the `MenuList` component.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不陌生于使用自定义钩子进行数据获取——这是一种增强可读性和整洁逻辑的实践。在我们的场景中，将`menuItems`状态和获取逻辑提取到单独的钩子中，将使`MenuList`组件变得简洁。
- en: 'So, let’s create a Hook named `useMenuItems`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们创建一个名为`useMenuItems`的钩子：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Within the `useMenuItems` Hook, we initialize the `menuItems` state with an
    empty array. When the Hook mounts, it triggers the `fetchMenuItems` function that
    fetches data from the specified URL. Following the fetch, a mapping operation
    is performed to convert each `RemoteMenuItem` object to a `MenuItem` object. The
    transformation details are omitted here, but it’s where we adapt the fetched data
    to the desired format. Subsequently, the transformed menu items are set to the
    `menuItems` state.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`useMenuItems`钩子内部，我们使用空数组初始化`menuItems`状态。当钩子挂载时，它触发`fetchMenuItems`函数，从指定的URL获取数据。在获取之后，执行映射操作将每个`RemoteMenuItem`对象转换为`MenuItem`对象。转换的细节在此省略，但这是我们适应获取数据到所需格式的位置。随后，转换后的菜单项被设置为`menuItems`状态。
- en: 'Now, in our `MenuList` component, we can simply call `useMenuItems` to obtain
    the `menuItems` array:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的`MenuList`组件中，我们可以简单地调用`useMenuItems`来获取`menuItems`数组：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This refactoring is quite beneficial, redirecting `MenuList` back to a streamlined
    state and reinstating its single responsibility. However, when we shift our focus
    to the `useMenuItems` Hook, particularly the data mapping segment, a few operations
    occur. It fetches data and trims off some unused fields such as `description`
    and `calories` from the remote data. It also encapsulates the logic to retain
    only the first three ingredients. Ideally, we’d like to centralize this transformation
    logic into a common location, ensuring a tidy and manageable code structure.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重构非常有益，将`MenuList`重新定向到一个简化的状态，并恢复其单一职责。然而，当我们把注意力转向`useMenuItems`钩子，特别是数据映射部分时，发生了一些操作。它从远程数据中获取数据，并删除了一些未使用的字段，如`description`和`calories`。它还封装了仅保留前三个配料的逻辑。理想情况下，我们希望将这种转换逻辑集中到一个公共位置，确保代码整洁且易于管理。
- en: Transitioning to a class-based model
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过渡到基于类模型
- en: As touched upon in [*Chapter 8*](B21103_08.xhtml#_idTextAnchor212), employing
    the `MenuItem` type definition into a class, hence centralizing all mapping logic
    within this class. This setup will serve as a dedicated hub for any future data
    shape alterations and related logic.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如在第[*第8章*](B21103_08.xhtml#_idTextAnchor212)中所述，将`MenuItem`类型定义应用于类中，从而将所有映射逻辑集中在这个类中。这种设置将作为一个专门的中心，用于处理任何未来的数据形状变更和相关逻辑。
- en: 'Transitioning `MenuItem` from a type to a class is straightforward. We require
    a constructor to accept `RemoteMenuItem` and some getter functions to access the
    data:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将`MenuItem`从类型转换为类是直接的。我们需要一个构造函数来接受`RemoteMenuItem`和一些获取函数来访问数据：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the `MenuItem` class, we define private `readonly` properties for `id`, `name`,
    `type`, `price`, and `ingredients`. The constructor initializes these properties
    using values from a `RemoteMenuItem` object passed to it. We then have getter
    methods for each property to provide read-only access to their values. Particularly,
    the `ingredients` getter returns only the first three items from the `ingredients`
    array.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MenuItem`类中，我们为`id`、`name`、`type`、`price`和`ingredients`定义了私有的`readonly`属性。构造函数使用传递给它的`RemoteMenuItem`对象中的值来初始化这些属性。然后我们有每个属性的获取方法，以提供对其值的只读访问。特别是，`ingredients`获取方法只返回`ingredients`数组中的前三个项目。
- en: Though, at a glance, this setup seems to have more code compared to a simple
    type definition, it effectively encapsulates the data and exposes it in a controlled
    manner. This aligns with the principles of immutability and encapsulation. The
    class structure’s beauty is its capability to house behaviors – in our case, the
    slicing logic for ingredients is tucked neatly within the class.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然乍一看，这种设置似乎比简单类型定义的代码更多，但它有效地封装了数据并以受控的方式暴露它。这与不可变性和封装的原则相一致。类结构的美丽之处在于它能够容纳行为——在我们的案例中，配料切片逻辑被整洁地封装在类中。
- en: 'With this new class in place, our `useMenuItems` Hook becomes more streamlined:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新类到位后，我们的`useMenuItems`钩子变得更加简洁：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, the `useMenuItems` Hook merely maps over the fetched menu items, creating
    a new instance of `MenuItem` for each, which significantly tidies up the transformation
    logic previously housed within the Hook.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`useMenuItems`钩子仅仅映射到获取的菜单项，为每个创建一个新的`MenuItem`实例，这显著清理了之前在钩子中存放的转换逻辑。
- en: The benefits of a class-based model
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于类模型的益处
- en: 'Transitioning to a class-based model from a simple type comes with a set of
    advantages that could serve our application well in the long run:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从简单类型过渡到基于类模型带来了一系列优势，这些优势可以从长远来看为我们的应用程序提供良好的服务：
- en: '**Encapsulation**: A class brings related properties and methods under one
    roof, thus promoting clear structure and organization. It also restricts direct
    data access, fostering better control and data integrity.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**：类将相关的属性和方法集中在一起，从而促进清晰的架构和组织。它还限制了直接的数据访问，促进了更好的控制和数据完整性。'
- en: '**Method behavior**: For complex behaviors or operations associated with a
    menu item, a class provides a structured platform to define these methods, whether
    they relate to data manipulation or other business logic.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法行为**：对于与菜单项相关联的复杂行为或操作，类提供了一个结构化的平台来定义这些方法，无论它们是关于数据处理还是其他业务逻辑。'
- en: '**Inheritance and polymorphism**: In the case of a hierarchy or polymorphic
    behavior among menu items, a class structure is indispensable. It allows different
    menu item types to inherit from a common base class, overriding or extending behavior
    as needed.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继承和多态**：在菜单项之间存在层次结构或多态行为的情况下，类结构是必不可少的。它允许不同的菜单项类型从公共基类继承，根据需要覆盖或扩展行为。'
- en: '**Consistent interface**: Classes ensure a consistent interface to the data,
    which is invaluable when multiple application parts interact with menu items.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致的界面**：类确保了对数据的统一接口，这在多个应用程序部分与菜单项交互时非常有价值。'
- en: '**Read-only properties**: Classes enable the definition of read-only properties,
    thereby controlling data mutation. This is a crucial aspect of maintaining data
    integrity and working with immutable data structures.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**只读属性**：类允许定义只读属性，从而控制数据突变。这是维护数据完整性和使用不可变数据结构的一个关键方面。'
- en: Now, as we transition into expanding our application’s functionality with a
    shopping cart, it’s crucial to approach this new section with the lessons learned
    from our data modeling exercise. This will ensure a structured and effective implementation,
    paving the way for a user-friendly online ordering experience.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着我们过渡到通过购物车扩展应用程序的功能，以从我们的数据建模练习中吸取的教训来处理这个新的部分至关重要。这将确保结构化和有效的实现，为用户友好的在线订购体验铺平道路。
- en: Implementing the ShoppingCart component
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现购物车组件
- en: As we venture into the implementation of the `ShoppingCart` component, we will
    aim to provide a seamless interface for users to review their selected items before
    proceeding to the checkout. Besides displaying the items, we also intend to reward
    our customers with some appealing discount policies.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实施`ShoppingCart`组件的过程中，我们的目标是提供一个无缝的界面，让用户在结账前查看他们所选的商品。除了显示商品外，我们还打算通过一些吸引人的折扣政策奖励我们的客户。
- en: 'In [*Chapter 7*](B21103_07.xhtml#_idTextAnchor176), we defined a rudimentary
    `ShoppingCart` component, as shown here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第七章*](B21103_07.xhtml#_idTextAnchor176)中，我们定义了一个基本的`ShoppingCart`组件，如下所示：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `ShoppingCart` component accepts a `cartItems` prop, which is an array of
    strings. It returns a `div` tag containing an ordered list (`<ol>`), where each
    item in the `cartItems` array is rendered as a list item (`<li>`). Below the list,
    a `cartItems` array is empty.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShoppingCart`组件接受一个`cartItems`属性，它是一个字符串数组。它返回一个包含有序列表（`<ol>`）的`div`标签，其中`cartItems`数组中的每个项目都被渲染为一个列表项（`<li>`）。在列表下方，`cartItems`数组为空。'
- en: 'However, to enhance the user experience, it’s crucial to display the price
    for each item and the total amount beneath the item list, yet above the **Place
    My Order** button. Here’s how we can augment our component to fulfill these requirements:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了增强用户体验，显示每个商品的价格和总价在项目列表下方、**提交订单**按钮上方至关重要。以下是我们可以如何增强我们的组件以满足这些要求：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `ShoppingCart` component is now equipped to accept a `cartItems` prop, which
    comprises an array of `MenuItem` objects (instead of a simple string). To compute
    the total price of items in the cart, we employ the `reduce` method. This method
    iterates over each item, accumulating their prices to present a total. The component
    then returns a JSX markup that renders a list of cart items, each displaying its
    name and price.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShoppingCart`组件现在可以接受一个`cartItems`属性，它包含一个`MenuItem`对象数组（而不是简单的字符串）。为了计算购物车中商品的总价，我们使用`reduce`方法。此方法遍历每个项目，累计其价格以显示总价。然后组件返回一个JSX标记，渲染购物车项目的列表，每个项目都显示其名称和价格。'
- en: This revamped `ShoppingCart` component not only enhances the clarity of the
    order for users but also lays down a foundation for introducing discount policies,
    which we can explore as we continue refining our application.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改进的`ShoppingCart`组件不仅增强了用户对订单的清晰度，还为引入折扣政策奠定了基础，我们可以在我们继续完善应用程序的过程中探索这些政策。
- en: Applying discounts to Items
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用折扣到商品
- en: Let’s assume we have different discount policies for different types of menu
    items. For instance, pizzas with more than three toppings receive a 10 percent
    discount, while large pasta dishes enjoy a 15 percent discount.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们对不同类型的菜单项有不同的折扣政策。例如，含有三个以上配料的披萨享有10%的折扣，而大型意面菜肴享有15%的折扣。
- en: 'To incorporate this, we initially attempt to extend the `MenuItem` class with
    a new field called `calculateDiscount`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们最初尝试通过一个名为`calculateDiscount`的新字段扩展`MenuItem`类：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: However, we encounter a problem – since pasta dishes don’t have toppings, this
    leads to a type error.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们遇到了一个问题——由于意面菜品没有配料，这导致了一个类型错误。
- en: 'To resolve this, we first extract an interface named `IMenuItem`, and then
    have `PizzaMenuItem` and `PastaMenuItem` classes implement this interface:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们首先提取了一个名为 `IMenuItem` 的接口，然后让 `PizzaMenuItem` 和 `PastaMenuItem` 类实现此接口：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we define an abstract class to implement the interface, allowing `PizzaMenuItem`
    and `PastaMenuItem` to extend the abstract class respectively:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个抽象类来实现接口，允许 `PizzaMenuItem` 和 `PastaMenuItem` 分别扩展这个抽象类：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the `AbstractMenuItem` class, we introduced a static `from` method. This
    method takes an `IMenuItem` instance and transforms it into a `RemoteMenuItem`
    instance, preserving the necessary fields for our application.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AbstractMenuItem` 类中，我们引入了一个静态的 `from` 方法。该方法接受一个 `IMenuItem` 实例，并将其转换为 `RemoteMenuItem`
    实例，保留了我们应用程序所需的所有字段。
- en: The `calculateDiscount` method is declared as an abstract method, requiring
    its child classes to implement the actual discount calculation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculateDiscount` 方法被声明为一个抽象方法，要求其子类实现实际的折扣计算。'
- en: Note
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: An **abstract class** serves as a base class for other classes and cannot be
    instantiated on its own. It’s a way to define a common interface and/or implementation
    for a set of derived classes. Abstract classes often contain abstract methods,
    which are declared without implementations, leaving it to derived classes to provide
    specific implementations. By doing so, abstract classes enable a common structure
    while ensuring that certain methods are implemented in derived classes, promoting
    a consistent behavior across all derived types. They are a key feature in object-oriented
    programming, supporting polymorphism and encapsulation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 **抽象类** 作为其他类的基类，不能单独实例化。它是一种定义一组派生类公共接口和/或实现的方式。抽象类通常包含抽象方法，这些方法声明时不包含实现，留由派生类提供具体的实现。通过这种方式，抽象类确保了公共结构，同时确保某些方法在派生类中得到实现，从而在所有派生类型之间促进了一致的行为。它们是面向对象编程中的关键特性，支持多态和封装。
- en: 'We need to override and put the actual `calculateDiscount` logic in sub-classes.
    For `PizzaMenuItem`, it simply extends `AbstractMenuItem` and implements `calculateDiscount`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在子类中重写并放置实际的 `calculateDiscount` 逻辑。对于 `PizzaMenuItem`，它简单地扩展了 `AbstractMenuItem`
    并实现了 `calculateDiscount`：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `PizzaMenuItem` class extends `AbstractMenuItem`, inheriting its properties
    and methods. It defines a private `readonly` property, `toppings`, to hold the
    number of toppings. In the constructor, it takes two arguments: `RemoteMenuItem`
    and `toppings` (which indicates the number of toppings). It calls the constructor
    of `AbstractMenuItem` with `item` using `super(item)` and initializes `this.toppings`
    with the passed-in `toppings` argument.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`PizzaMenuItem` 类继承自 `AbstractMenuItem`，继承了其属性和方法。它定义了一个私有的 `readonly` 属性 `toppings`，用于存储配料数量。在构造函数中，它接受两个参数：`RemoteMenuItem`
    和 `toppings`（表示配料数量）。它使用 `super(item)` 调用 `AbstractMenuItem` 的构造函数，并用传入的 `toppings`
    参数初始化 `this.toppings`。'
- en: The `calculateDiscount` method is implemented to return a 10% discount if the
    number of toppings is 3 or more. This method overrides the abstract `calculateDiscount`
    method from `AbstractMenuItem`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculateDiscount` 方法被实现为，如果配料数量为3个或更多，则返回10%的折扣。此方法覆盖了来自 `AbstractMenuItem`
    的抽象 `calculateDiscount` 方法。'
- en: 'Similarly, we can create a `PastaMenuItem` class like so:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以创建一个 `PastaMenuItem` 类，如下所示：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The relationship of these classes can be visualized as in *Figure 11**.7*:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类之间的关系可以如图 *11.7* 所示：
- en: '![Figure 11.7: Model classes](img/B31103_11_07.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图11.7：模型类](img/B31103_11_07.jpg)'
- en: 'Figure 11.7: Model classes'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7：模型类
- en: The `AbstractMenuItem` abstract class implements the `IMenuItem` interface and
    uses `RemoteMenuItem`. Both `PizzaItem` and `PastaItem` are extending `AbstractMenuItem`
    and have their own logic for calculating the discount.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractMenuItem` 抽象类实现了 `IMenuItem` 接口并使用 `RemoteMenuItem`。`PizzaItem` 和
    `PastaItem` 都扩展了 `AbstractMenuItem` 并有自己的折扣计算逻辑。'
- en: 'Next, in the `MenuList` component, when adding items to the shopping cart,
    we create instances of the right class based on the item type:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `MenuList` 组件中，当向购物车添加项目时，我们根据项目类型创建正确的类实例：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `handleAddMenuItem` function transforms the `IMenuItem` object item into
    a `RemoteMenuItem` object using the `AbstractMenuItem.from(item)` method. Following
    this, it checks the type property of the item to determine whether it’s a pizza
    or pasta. If it’s a pizza, a new `PizzaMenuItem` instance is created using `remoteItem`
    and the selected number of toppings, and this new item is added to the cart via
    the `onAddMenuItem` function. If the item is neither a pizza nor pasta, the original
    item is added to the cart directly through the `onAddMenuItem` function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleAddMenuItem` 函数使用 `AbstractMenuItem.from(item)` 方法将 `IMenuItem` 对象 `item`
    转换为 `RemoteMenuItem` 对象。随后，它检查 `item` 的类型属性以确定它是否是披萨还是意面。如果是披萨，则使用 `remoteItem`
    和选定的配料数量创建一个新的 `PizzaMenuItem` 实例，并通过 `onAddMenuItem` 函数将这个新项目添加到购物车中。如果项目既不是披萨也不是意面，则直接通过
    `onAddMenuItem` 函数将原始项目添加到购物车中。'
- en: 'Lastly, within the `ShoppingCart` component, we calculate the total discount
    value similarly to how we calculated the total price, and use it for rendering:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `ShoppingCart` 组件中，我们像计算总价一样计算总折扣值，并用于渲染：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `ShoppingCart` component calculates `totalPrice` by iterating over the `cartItems`
    array and summing up the price of each item. Similarly, it calculates `totalDiscount`
    by summing up the discounts for each item, obtained by calling the `calculateDiscount()`
    method on each item. In the returned JSX, it renders a list and displays `totalDiscount`
    and the final total price (which is `totalPrice` minus `totalDiscount`) below
    the list.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShoppingCart` 组件通过遍历 `cartItems` 数组并累加每个项目的价格来计算 `totalPrice`。同样，它通过调用每个项目的
    `calculateDiscount()` 方法来计算 `totalDiscount`，即累加每个项目的折扣。在返回的 JSX 中，它渲染一个列表，并显示
    `totalDiscount` 和最终的总价（即 `totalPrice` 减去 `totalDiscount`）。'
- en: 'At this juncture, the function operates effectively. Nonetheless, there are
    several factors to contemplate – the discount is currently specified on each product:
    for instance, pizza has its own discount rule while pasta has its own. What would
    be our approach if we need to implement a store-wide discount, such as a discount
    for a public holiday?'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，函数运行得非常有效。然而，还有几个因素需要考虑——折扣目前是针对每个产品指定的：例如，披萨有自己的折扣规则，而意面有自己的。如果我们需要实现全店折扣，比如公共假期的折扣，我们的方法会是什么？
- en: Exploring the Strategy pattern
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索策略模式
- en: Suppose it’s a bustling Friday night, and we wish to offer a special discount
    on all pizzas and drinks. However, we don’t intend to apply additional discounts
    on items already discounted — for instance, a pizza with four toppings should
    only receive this specific special discount.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 假设是繁忙的周五晚上，我们希望对所有披萨和饮料提供特别折扣。然而，我们不想对已经打折的项目应用额外的折扣——例如，四种配料的披萨只能获得这个特定的特别折扣。
- en: Handling such arbitrary discounts can be complex, necessitating a decoupling
    of the calculation logic from the item type. Moreover, we’d like the flexibility
    to remove these discounts after Friday or after a certain period.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这样的任意折扣可能很复杂，需要将计算逻辑从项目类型中解耦。此外，我们希望有灵活性在周五之后或一定时期后移除这些折扣。
- en: We can use a design pattern called the **Strategy pattern** to achieve flexibility
    here. The Strategy pattern is a behavioral design pattern that enables selecting
    an algorithm’s implementation at runtime. It encapsulates a family of algorithms
    and makes them interchangeable, allowing the client to choose the most suitable
    one without modifying the code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用名为 **策略模式** 的设计模式来实现这里的灵活性。策略模式是一种行为设计模式，它允许在运行时选择算法的实现。它封装了一组算法，并使它们可互换，允许客户端选择最合适的一个，而无需修改代码。
- en: 'We’ll extract the logic into a separate entity, defining a strategy interface
    as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提取逻辑到一个单独的实体中，定义一个策略接口如下：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This interface provides a blueprint for different discount strategies. For
    example, we could have a strategy with no discount:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口为不同的折扣策略提供了一个蓝图。例如，我们可以有一个没有折扣的策略：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `NoDiscountStrategy` class implements the `IDiscountStrategy` interface
    with a `calculate` method that takes a price as input and returns zero, meaning
    no discount is applied.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`NoDiscountStrategy` 类实现了 `IDiscountStrategy` 接口，并带有 `calculate` 方法，该方法接受一个价格作为输入并返回零，这意味着没有应用折扣。'
- en: 'And for `SpecialDiscountStrategy` component, a special discount strategy offering
    a 15% discount will be applied:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `SpecialDiscountStrategy` 组件，将应用一个提供 15% 折扣的特殊折扣策略：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To utilize these strategies, we need to slightly modify the `IMenuItem` interface:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用这些策略，我们需要稍微修改一下 `IMenuItem` 接口：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We added `discountStrategy` with type `IDiscountStrategy` in the `IMenuItem`
    interface. And because we moved the logic of calculating discount into strategy,
    we don’t need the `calculateDiscount` abstract method in `AbstractMenuItem` anymore
    and the class will no longer remain abstract, so we renamed it to `BaseMenuItem`
    instead. Instead, it will incorporate a setter for the discount strategy and implement
    the discount calculation:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `IMenuItem` 接口中添加了 `discountStrategy` 类型为 `IDiscountStrategy`。由于我们将计算折扣的逻辑移动到了策略中，我们不再需要在
    `AbstractMenuItem` 中使用 `calculateDiscount` 抽象方法，因此该类将不再保持抽象状态，所以我们将其重命名为 `BaseMenuItem`。相反，它将包含一个用于折扣策略的设置器并实现折扣计算：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `BaseMenuItem` class now implements the `IMenuItem` interface and encapsulates
    a discount strategy, initially set to `NoDiscountStrategy`. It defines a setter
    to update the discount strategy, and a `calculateDiscount` method, which delegates
    the discount calculation to the encapsulated discount strategy’s `calculate` method,
    passing the item’s price as an argument.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseMenuItem` 类现在实现了 `IMenuItem` 接口，并封装了一个折扣策略，最初设置为 `NoDiscountStrategy`。它定义了一个设置器来更新折扣策略，以及一个
    `calculateDiscount` 方法，该方法将折扣计算委托给封装的折扣策略的 `calculate` 方法，并将商品的价格作为参数传递。'
- en: '*Figure 11**.8* should now give you a much clearer idea of what the relationships
    are:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.8* 现在应该能让你更清楚地了解关系：'
- en: '![Figure 11.8: The class diagram of all the classes](img/B31103_11_08.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图11.8：所有类的类图](img/B31103_11_08.jpg)'
- en: 'Figure 11.8: The class diagram of all the classes'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8：所有类的类图
- en: As observed, `BaseMenuItem` implements the `IMenuItem` interface and utilizes
    `IDiscountStrategy`. There are multiple implementations of the `IDiscountStrategy`
    interface for specific discount algorithms, and several classes extend the `BaseMenuItem`
    class.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如观察所示，`BaseMenuItem` 实现了 `IMenuItem` 接口并使用 `IDiscountStrategy`。存在多个 `IDiscountStrategy`
    接口的实现，用于特定的折扣算法，并且有多个类扩展了 `BaseMenuItem` 类。
- en: Note that the `RemoteMenuItem` type is used by all the classes implementing
    the `IMenuItem` interface.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`RemoteMenuItem` 类型被所有实现 `IMenuItem` 接口的类使用。
- en: 'Now, when we need to apply a particular strategy, it can be done effortlessly,
    like so:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们需要应用特定的策略时，可以轻松完成，如下所示：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the `MenuList` component, the `handleAddMenuItem` function checks if today
    is Friday using the `isTodayFriday` function. If it is, it sets `discountStrategy`
    of the item to a new instance of `SpecialDiscountStrategy` before passing the
    item to the `onAddMenuItem` function, which is received as a prop. This way, a
    special discount is applied to the menu item on Fridays.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MenuList` 组件中，`handleAddMenuItem` 函数使用 `isTodayFriday` 函数检查今天是否是星期五。如果是，它在将项目传递给接收作为属性的
    `onAddMenuItem` 函数之前，将项目的 `discountStrategy` 设置为 `SpecialDiscountStrategy` 的新实例。这样，在星期五对菜单项应用特殊折扣。
- en: 'This setup grants us the desired flexibility. For instance, in the `handleAddMenuItem`
    function, depending on whether it’s Friday or the item is a pizza, we can easily
    switch the discount strategy:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置为我们提供了所需的灵活性。例如，在 `handleAddMenuItem` 函数中，根据是否是星期五或项目是披萨，我们可以轻松切换折扣策略：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this `handleAddMenuItem` function, depending on certain conditions, a different
    discount strategy is applied to the item before it’s passed to the `onAddMenuItem`
    function. Initially, it checks if today is Friday using `isTodayFriday()` and,
    if true, it assigns a new instance of `SpecialDiscountStrategy` to `item.discountStrategy`.
    However, if the item is of type `pizza`, irrespective of the day, it overwrites
    `item.discountStrategy` with a new instance of `PizzaDiscountStrategy`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `handleAddMenuItem` 函数中，根据某些条件，在将项目传递给 `onAddMenuItem` 函数之前，对项目应用不同的折扣策略。最初，它使用
    `isTodayFriday()` 检查今天是否是星期五，如果是，则将 `SpecialDiscountStrategy` 的新实例分配给 `item.discountStrategy`。然而，如果项目是
    `pizza` 类型，无论哪一天，它都会用 `PizzaDiscountStrategy` 的新实例覆盖 `item.discountStrategy`。
- en: This approach keeps our discount logic modular and easy to adjust, catering
    to different scenarios with minimal code modification. As we’re extracting new
    logic components – Hooks, data models, domain logic (discount strategies), and
    views – out of the application code, it’s evolving into a layered frontend application.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使我们的折扣逻辑模块化且易于调整，通过最小化代码修改来适应不同的场景。随着我们从应用程序代码中提取新的逻辑组件——钩子、数据模型、领域逻辑（折扣策略）和视图，它正在演变成一个分层的前端应用程序。
- en: Delving into layered architecture
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入分层架构
- en: Our application has transitioned wonderfully to a more robust state, with clear,
    understandable, and modifiable logic, which is now also more test-friendly.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用已经完美过渡到一个更健壮的状态，具有清晰、易懂且可修改的逻辑，现在也更加便于测试。
- en: 'A further refinement I envision is relocating the logic present in `ShoppingCart`
    to a custom Hook. We can do this like so:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我设想的一个进一步改进是将`ShoppingCart`中存在的逻辑移至自定义Hook。我们可以这样做：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `useShoppingCart` Hook accepts an array of `IMenuItem` objects and computes
    two values – `totalPrice` and `totalDiscount`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`useShoppingCart` Hook接受一个`IMenuItem`对象数组，并计算两个值——`totalPrice`和`totalDiscount`：'
- en: '`totalPrice` is calculated by reducing the items, summing up their `price`
    property'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`totalPrice`是通过减少项目数量，对它们的`price`属性进行求和来计算的'
- en: '`totalDiscount` is calculated by reducing the items, summing up the discount
    for each item obtained by calling `item.calculateDiscount()`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`totalDiscount`是通过减少项目数量，对每个项目通过调用`item.calculateDiscount()`获得的折扣进行求和来计算的'
- en: Both calculations are wrapped in `useMemo` to ensure they are only recomputed
    when the items array changes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个计算都被`useMemo`包装，以确保只有在项目数组发生变化时才会重新计算。
- en: 'With this modification, `ShoppingCart` becomes elegantly simplified and can
    easily utilize these values:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这次修改，`ShoppingCart`变得简洁优雅，可以轻松利用这些值：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: An alternative approach would be employing the context and `useReducer` Hook
    to manage all logic within context and Hooks, however, since we explored that
    in [*Chapter 8*](B21103_08.xhtml#_idTextAnchor212), I’ll leave further exploration
    to you (you can use both code examples provided in [*Chapter 8*](B21103_08.xhtml#_idTextAnchor212)
    and this chapter and try to use `context` and `useReducer` to simplify `ShoppingCart`).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法可能是使用context和`useReducer` Hook来管理上下文中和Hooks中的所有逻辑，然而，由于我们在[*第8章*](B21103_08.xhtml#_idTextAnchor212)中已经探讨了这一点，我将进一步的探索留给你们（你们可以使用[*第8章*](B21103_08.xhtml#_idTextAnchor212)中提供的代码示例以及本章，并尝试使用`context`和`useReducer`来简化`ShoppingCart`）。
- en: The layered structure of the application
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序的分层结构
- en: 'We’ve delved into organizing components and models into separate files; it’s
    equally vital to continue refining our project structure. Functions with distinct
    responsibilities should reside in different folders, streamlining navigation through
    the application and saving time. Our application now exhibits a fresh structural
    anatomy:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经深入探讨了将组件和模型组织到单独的文件中；继续改进我们的项目结构同样至关重要。具有不同职责的函数应该位于不同的文件夹中，这样可以简化应用程序的导航并节省时间。我们的应用程序现在展现出了新的结构解剖学：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: And that’s how the layers formed. Within the view layer, we have primarily pure
    TSX rendering straightforward tags. These views leverage Hooks for state and side
    effect management. Meanwhile, in the model layer, model objects encompass business
    logic, algorithms for toggling between different discount strategies, and data
    shape transformations, among other functionalities. This structure promotes separation
    of concerns, making the code organized, reusable, and easier to maintain.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这样形成了层。在视图层中，我们主要使用纯TSX渲染直接标签。这些视图利用Hooks进行状态和副作用管理。同时，在模型层中，模型对象包含业务逻辑、在不同折扣策略之间切换的算法和数据形状转换等功能。这种结构促进了关注点的分离，使得代码更加有序、可重用且易于维护。
- en: It’s important to note the one-directional link here; the upper layer accesses
    the lower layer, but not vice versa. TSX uses Hooks for state management, and
    Hooks employ models for calculations. However, we can’t use JSX or Hooks in the
    model layer. This layering technique facilitates change or replacement in the
    underlying layers without impacting the upper layers, promoting a clean and maintainable
    structure.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是这里的一个单向链接；上层访问下层，但反之则不然。TSX使用Hooks进行状态管理，Hooks使用模型进行计算。然而，我们无法在模型层中使用JSX或Hooks。这种分层技术使得在不影响上层的情况下，可以方便地更改或替换底层，促进了干净且易于维护的结构。
- en: In our Code Oven application, as illustrated in *Figure 11**.9*, the layout
    features a menu items list on the left and a shopping cart on the right. Within
    the shopping cart, each item displays detailed discount and price information
    on the page.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Code Oven应用程序中，如图*图11.9*所示，布局包括左侧的菜单项列表和右侧的购物车。在购物车中，每个项目在页面上显示详细的折扣和价格信息。
- en: "![Fig\uFEFFure 11.9: Final look and feel of the application](img/B31103_11_09.jpg)"
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图11.9：应用程序的最终外观和感觉](img/B31103_11_09.jpg)'
- en: 'Figure 11.9: Final look and feel of the application'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9：应用程序的最终外观和感觉
- en: Advantages of layered architecture
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分层架构的优势
- en: 'The layered architecture confers numerous benefits:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 分层架构带来了许多好处：
- en: '**Enhanced maintainability**: The division of a component into distinct segments
    facilitates easier identification and rectification of defects in specific code
    sections, thus minimizing time spent and reducing the likelihood of engendering
    new bugs during modifications.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强可维护性**：将组件划分为不同的部分，便于更容易地识别和纠正特定代码部分的缺陷，从而最小化花费的时间和减少在修改过程中产生新错误的可能性。'
- en: '**Increased modularity**: This architecture is inherently more modular, promoting
    code reuse and simplifying the addition of new features. Even within each layer,
    such as views, the code tends to be more composable.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加模块化**：这种架构本质上是更模块化的，促进了代码重用，简化了新功能的添加。即使在每个层，如视图层，代码也往往更易于组合。'
- en: '**Enhanced readability**: The logic within the code becomes significantly more
    understandable and navigable, an asset not only for the original developer but
    also for others who may interact with the code base. This clarity is central to
    effecting changes in the code.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强可读性**：代码中的逻辑变得更加易于理解和导航，这不仅对原始开发者有益，也对可能与之交互的其他人有益。这种清晰度对于在代码中实施变更至关重要。'
- en: '**Improved scalability**: The reduced complexity within each module renders
    the application more scalable, making it easier to introduce new features or alterations
    without impacting the entire system—a critical advantage for large, complex applications
    projected to evolve over time.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高可扩展性**：每个模块内的复杂性降低，使得应用程序更易于扩展，更容易引入新功能或变更，而不会影响整个系统——这对于预计会随时间演变的庞大、复杂的应用程序来说是一个关键优势。'
- en: '**Tech-stack migration**: Albeit unlikely in most projects, should the need
    arise, the view layer can be replaced without altering the underlying models and
    logic, thanks to the encapsulation of domain logic in pure JavaScript (or TypeScript)
    code, oblivious to the views’ existence.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术栈迁移**：尽管在大多数项目中不太可能，但如果需要，可以通过封装在纯JavaScript（或TypeScript）代码中的领域逻辑（对视图的存在无感知），在不改变底层模型和逻辑的情况下替换视图层。'
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we implemented layered architecture in our application, enhancing
    its maintainability, modularity, readability, scalability, and potential for tech-stack
    migration. By segregating logic, refining the `ShoppingCart` component through
    a custom Hook, and organizing the application into distinct layers, we’ve significantly
    bolstered the code’s structure and ease of management. This architectural approach
    not only streamlines the current code base but also lays a solid foundation for
    future expansions and refinements.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在应用程序中实现了分层架构，增强了其可维护性、模块化、可读性、可扩展性和技术栈迁移的潜力。通过分离逻辑，通过自定义钩子精炼`ShoppingCart`组件，并将应用程序组织成不同的层，我们显著增强了代码的结构和管理便捷性。这种架构方法不仅简化了当前的代码库，还为未来的扩展和改进奠定了坚实的基础。
- en: In the next chapter, we’ll look at the end-to-end journey of implementing an
    application from scratch, using the user acceptance test-driven development approach,
    doing refactoring, cleaning up along the way, and always keeping our code as clean
    as we can.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨从头开始实现应用程序的端到端旅程，使用用户验收测试驱动的开发方法，在过程中进行重构、清理，并始终努力保持我们的代码尽可能干净。
