- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Untangling Complex Flows in React Native Apps with XState
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 XState 解开 React Native 应用中的复杂流程
- en: 'In the previous chapter, we took a look at **MobX**—the second most popular
    state management library in the **React** ecosystem. MobX introduced some new
    concepts, such as using state values derived by the state manager. Other high-level
    concepts were similar to **Redux**—such as presenting state as plain **JavaScript**
    objects. We will now look at the first outlier on the React-state-management horizon:
    **XState**. XState treats the state not as an object, but as a finite machine.
    Don’t worry if you haven’t heard that term yet, as we’ll go over the topic of
    finite machines in the first section of this chapter.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了 **MobX**——React 生态系统中最受欢迎的状态管理库之一。MobX 引入了一些新概念，例如使用状态管理器派生的状态值。其他高级概念与
    **Redux** 相似——例如将状态表示为纯 **JavaScript** 对象。现在我们将关注 React 状态管理领域的第一个例外：**XState**。XState
    将状态视为一个有限机，而不是一个对象。如果你还没有听说过这个术语，不要担心，我们将在本章的第一节中介绍有限机的话题。
- en: 'We will start by looking at the theoretical side of XState’s basic idea: state
    machines. We will then talk about other high-level concepts of XState—state charts,
    actions, and the XState visualizer. When we’re comfortable with the theory, we’ll
    configure XState in the Funbook app, and then we will implement XState for managing
    liking images in the app.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探讨 XState 基本理念的理论方面：状态机。然后我们将讨论 XState 的其他高级概念——状态图、动作和 XState 可视化器。当我们对理论感到满意时，我们将在
    Funbook 应用中配置 XState，然后我们将实现 XState 以管理应用中的点赞图片。
- en: 'Here’s a complete list of what is covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下完整列表：
- en: What are finite state machines?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是有限状态机？
- en: What is XState—high-level concepts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XState 是什么——高级概念
- en: Configuring XState in the Funbook app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Funbook 应用中配置 XState
- en: Using XState for the `FavoritedImages` surface
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 XState 为 `FavoritedImages` 界面
- en: By the end of this chapter, you will be able to understand and use XState as
    the state management solution for your projects. You will understand what a state
    machine is and how it differs from state objects used in other state management
    libraries. I hope that you will also start seeing which solutions you prefer using.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够理解和使用 XState 作为你项目的状态管理解决方案。你将了解什么是状态机以及它与在其他状态管理库中使用的状态对象有何不同。我希望你也会开始看到你更喜欢使用的解决方案。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to follow along with this chapter, you will need some knowledge of
    JavaScript and **ReactJS**. If you have followed at least *Chapters 1* through
    *4* of this book, you should be able to go forward without any issues.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章的内容，你需要了解一些 JavaScript 和 **ReactJS** 的知识。如果你至少阅读了本书的 *第 1 章* 到 *第 4 章*，你应该能够无任何问题地继续前进。
- en: Feel free to use an IDE of your choice, as React Native does not need any specific
    functionality. Currently, the most popular IDEs for frontend developers are Microsoft’s
    VS Code, Atom, Sublime Text, and WebStorm.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 随意使用你选择的 IDE，因为 React Native 不需要任何特定功能。目前，前端开发者中最受欢迎的 IDE 是微软的 VS Code、Atom、Sublime
    Text 和 WebStorm。
- en: The code snippets provided in this chapter are here to illustrate what we should
    be doing with the code—they do not provide the whole picture. For a better experience
    of coding along, please open the GitHub repo in your IDE and look at the files
    in there. You can start with the files in either the folder named `example-app-full`
    or `chapter-7`. If you start with `example-app-full`, you will be responsible
    for implementing the solutions described in this chapter. If you choose to look
    at `chapter-7` you will see the entire solution implemented by me.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供的代码片段是为了说明我们应该如何使用代码——它们并不提供整个画面。为了更好地跟随编码，请在你的 IDE 中打开 GitHub 仓库并查看其中的文件。你可以从名为
    `example-app-full` 或 `chapter-7` 的文件夹中的文件开始。如果你从 `example-app-full` 开始，你将负责实现本章中描述的解决方案。如果你选择查看
    `chapter-7`，你将看到我实现的整个解决方案。
- en: 'If you get stuck or lost, you can check the code in the GitHub repo:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到困难或迷失方向，可以检查 GitHub 仓库中的代码：
- en: '[https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-7](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-7).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-7](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-7).'
- en: What are finite state machines?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是有限状态机？
- en: If I were to ask you, my dear reader, to guess what finite state machines are,
    you would probably say they are related to managing state in applications. After
    all, this whole book is on that topic!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我亲爱的读者要求你猜测有限状态机是什么，你可能会说它们与在应用程序中管理状态有关。毕竟，整本书都是关于这个主题的！
- en: 'Funny thing is, finite state machines have nothing to do with applications;
    they have nothing to do with React or even programming at all. A finite state
    machine is a mathematical model of computation. It’s an abstract concept that
    can be applied to real-life objects or problems, and it represents a machine that
    can be in exactly one of a finite number of states at any given time. The predefined
    states can be changed from one to another in response to some user input. Traffic
    lights are an example of a simple finite state machine: a traffic light can be
    green, red, or yellow at any time, and it should never display two colors at once.
    Another example of a simple state machine is an elevator. The default state of
    an elevator is to stand still with doors closed. When a user pushes the button
    summoning the elevator, the elevator transitions to a state of movement. When
    it reaches the right floor, it opens and closes the doors. The elevator then goes
    back to the default, idle state, waiting for the next user input.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，有限状态机与应用程序无关；它们与React或编程本身都无关。有限状态机是一种计算数学模型。它是一个抽象概念，可以应用于现实生活中的对象或问题，并且代表一个在任何给定时间可以处于有限多个状态之一的状态机。预定义的状态可以根据某些用户输入从一种状态改变到另一种状态。交通灯是一个简单的有限状态机示例：交通灯可以是绿色、红色或黄色，但任何时候都不应该显示两种颜色。另一个简单的状态机示例是电梯。电梯的默认状态是门关闭时静止不动。当用户按下召唤电梯的按钮时，电梯转换到运动状态。当它到达正确的楼层时，它会打开和关闭门。然后电梯回到默认的空闲状态，等待下一个用户输入。
- en: 'If you wish to find out more about this theoretical concept, you will find
    a link to a very thorough *Wikipedia* page on finite state machines in the *Further
    reading* section. As for this book, it’s time to find out why we are talking about
    this concept at all. Can you guess? I bet you can! Finite state machines are the
    basic concept of the state management library we’re analyzing in this chapter:
    XState.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望了解更多关于这个理论概念的信息，你将在“进一步阅读”部分找到一个关于有限状态机的非常详尽的*维基百科*页面链接。至于这本书，现在是时候找出我们为什么要讨论这个概念了。你能猜到吗？我敢打赌你能！有限状态机是我们在本章中分析的状态管理库的基本概念：XState。
- en: What is XState – high-level concepts
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是XState – 高级概念
- en: 'Now that we have a grasp on the theoretical concept of finite state machines,
    we can move on to talking about XState and its main concept: finite state machines!
    But this time, we’ll look at it in the world of programming global state in applications.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了有限状态机的理论概念，我们可以继续讨论XState及其主要概念：有限状态机！但这次，我们将从在应用程序中管理全局状态的角度来看待它。
- en: 'When using XState to manage global state in an application, we should think
    of our state as a finite state machine. This means abandoning the previous concept
    of representing state as a plain JavaScript object. With XState, a component—or
    a surface—is a machine that can be in one of multiple predefined states. Let’s
    consider the user login flow. Our entire app can be in one of two states: the
    user is logged in or the user is not logged in. We would also need a transition
    mechanism for the user to move from one of the states to the other. The same goes
    for images on the **Home** surface. Every image is either in the state of being
    “liked” or “not liked”. The user can change the current state of the image by
    clicking the heart icon below the image.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用XState来管理应用程序的全局状态时，我们应该把我们的状态视为一个有限状态机。这意味着放弃之前将状态表示为普通JavaScript对象的概念。在XState中，一个组件或一个界面是一个可以处于多个预定义状态之一的机器。让我们考虑用户登录流程。我们的整个应用程序可以处于两种状态之一：用户已登录或用户未登录。我们还需要一个转换机制，让用户可以从一个状态移动到另一个状态。对于**主页**界面上的图片也是如此。每张图片要么处于“喜欢”状态，要么处于“不喜欢”状态。用户可以通过点击图片下方的爱心图标来改变图片的当前状态。
- en: 'Besides finite state machines, there are two other important concepts used
    in XState: **statecharts** and the **actor model**. Statecharts are basically
    drawings that can be used to represent state machines. Here’s an example of a
    statechart representing the state and transitions of a light bulb:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了有限状态机之外，XState还使用了两个其他重要概念：**状态图**和**演员模型**。状态图基本上是可以用来表示状态机的绘图。以下是一个表示灯泡状态和转换的状态图示例：
- en: '![Figure 7.1 – Simple statechart drawing of a light switch ](img/Figure_7.01_B18396.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 简单状态图绘制灯开关](img/Figure_7.01_B18396.jpg)'
- en: Figure 7.1 – Simple statechart drawing of a light switch
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 简单状态图绘制灯开关
- en: 'The preceding diagram serves as a very simple state machine. When working on
    a mobile application, you may find yourself working on much more complicated state
    machines. Starting from something as trivial as a form, you can find yourself
    adding multiple states, such as enabled/disabled, valid/invalid, and clean/dirty,
    on multiple elements. Without statecharts, you would face a state explosion. As
    fun as it may sound, it’s not great to face in an app. Let’s take a look at the
    example of complex inputs drawn out with state transitions:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示是一个非常简单的状态机。当在移动应用上工作时，您可能会发现自己正在处理更复杂的状态机。从一个非常简单的事物，比如一个表单开始，您可能会在多个元素上添加多个状态，例如启用/禁用、有效/无效和清洁/脏。没有状态图，您将面临状态爆炸。虽然听起来很有趣，但在应用中面对这种情况并不好。让我们看看使用状态转换绘制出的复杂输入示例：
- en: '![Figure 7.2 – Complex state chart ](img/Figure_7.02_B18396.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 复杂状态图](img/Figure_7.02_B18396.jpg)'
- en: Figure 7.2 – Complex state chart
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 复杂状态图
- en: 'The user clicks on a valid input and enters the **Valid Enabled Unchanged**
    state. The app transitions automatically into an **Invalid Enabled Unchanged**
    state. When the user provides some input, the app will be in an **Invalid Enabled
    Changed** state. If the input provided by the user is valid, we will land in a
    **Valid Enabled Changed** state; if not, we will return to **Invalid Enabled Changed**.
    What if the user clicks something else in the form—let’s say, a radio box that
    disables the first input? We go into an **Invalid** (or **Valid**) **Disabled
    Changed** state. It’s rather hard to reason about this chart. This is the moment
    when statechart features come into play. Statecharts offer an implementation of
    parallel states, hierarchies, and guards. You can read more on those concepts
    in this document recommended in the XState documentation: [https://statecharts.dev/state-machine-state-explosion.html](https://statecharts.dev/state-machine-state-explosion.html).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 用户点击一个有效的输入并进入**有效启用未更改**状态。应用会自动过渡到**无效启用未更改**状态。当用户提供一些输入时，应用将处于**无效启用更改**状态。如果用户提供的输入有效，我们将进入**有效启用更改**状态；如果不有效，我们将返回到**无效启用更改**状态。如果用户在表单中点击其他内容——比如说，一个禁用第一个输入的单选框？我们将进入**无效**（或**有效**）**禁用更改**状态。对这个图表进行推理相当困难。这就是状态图特性发挥作用的时候。状态图提供了并行状态、层次结构和守卫的实现。您可以在XState文档中推荐的这篇文档中了解更多关于这些概念的信息：[https://statecharts.dev/state-machine-state-explosion.html](https://statecharts.dev/state-machine-state-explosion.html)。
- en: 'The last big idea behind XState is actor models. This is a mathematical model
    of computation, stating that everything is an “actor” and can do three things:
    receive messages, send messages, and do something with the received messages.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: XState背后的最后一个重要概念是演员模型。这是一个计算数学模型，表明一切都是一个“演员”，并且可以执行三件事情：接收消息、发送消息以及处理接收到的消息。
- en: 'I was very lucky to be able to ask XState’s author, *David Khourshid*, a few
    questions on the topic of his state management library. He told me he “*created
    XState for two reasons: to manage complex logic and to visualize complex logic.
    State machines and statecharts are visual formalisms that excel in representing
    even the most complex flows and logic in a visually clear way, and I wanted a
    simple way to use them in JavaScript applications."* He added that the high-level
    ideas of XState were heavily influenced by the **World Wide Web Consortium** (**W3C**)
    **State Chart XML** (**SCXML**) specification.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常幸运能够就XState库的主题向其作者*大卫·库尔希德*提出几个问题。他告诉我他“*创建XState有两个原因：管理和可视化复杂逻辑。状态机和状态图是视觉形式化工具，擅长以直观的方式表示甚至是最复杂的流程和逻辑，并且我希望在JavaScript应用中使用它们的方式简单。*”他还补充说，XState的高级理念受到了**万维网联盟**（**W3C**）**状态图XML**（**SCXML**）规范的强烈影响。
- en: Let’s take a quick detour to find out what SCXML is and what it means that it
    has a W3C specification. Depending on your experience in programming, you may
    have heard of the **Extensible Markup Language** (**XML**) file format and markup
    language. XML is used to store, transmit, and reconstruct data. XML files are
    easy to read when properly indented and formatted, as they simply describe data.
    SCXML is a cousin of XML. It’s an XML-based markup language used for providing
    a state-machine-based environment. The fact that it has a W3C specification means
    that it can be used for various internet-related programs with great confidence.
    You can find a link to the entire W3C specification in the *Further* *reading*
    section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速了解一下 SCXML 是什么，以及它为什么有一个 W3C 规范的含义。根据你在编程方面的经验，你可能已经听说过 **可扩展标记语言**（**XML**）的文件格式和标记语言。XML
    用于存储、传输和重建数据。当正确缩进和格式化时，XML 文件易于阅读，因为它们只是描述数据。SCXML 是 XML 的一个堂兄弟。它是一种基于 XML 的标记语言，用于提供基于状态机的环境。它有一个
    W3C 规范的事实意味着它可以有信心地用于各种与互联网相关的程序。你可以在 *进一步阅读* 部分找到整个 W3C 规范的链接。
- en: Going back to XState, not only has it been influenced by SCXML, but it is also
    fully compatible with it, which means you could write an SCXML document describing
    states, and it will work with an XState implementation in your React Native app.
    You can also write it in JavaScript. Whatever rocks your boat!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 XState，它不仅受到了 SCXML 的影响，而且与 SCXML 完全兼容，这意味着你可以编写一个描述状态的 SCXML 文档，并且它将与你的
    React Native 应用中的 XState 实现一起工作。你还可以用 JavaScript 编写它。无论什么让你感到兴奋！
- en: 'I asked David Khourshid about the future of his library. XState is an open
    source project, as with all the other state management libraries we talk about
    in this book. David said maintaining XState and working on XState-related tools
    is his full-time job. He is working on new and powerful collaborative editing
    tools for the XState visualizer. He said: “*the next major version of XState (version
    5) will have many more features, be more modular, and have “actors” as first-class
    citizens. Actors are entities that can send and receive messages, and state machines
    are just one of many behaviors that an actor can have. You can also represent
    actors as promises, observables, reducers, and more, which will allow developers
    to use XState’s API (and visual tools) for all of their logic, not just the* *state-machine-specific
    logic."*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我向 David Khourshid 询问了他库的未来。XState 是一个开源项目，就像我们在本书中讨论的所有其他状态管理库一样。David 说维护
    XState 和开发与 XState 相关的工具是他的全职工作。他正在为 XState 可视化器开发新的强大协作编辑工具。他说：“*XState 的下一个主要版本（版本
    5）将拥有更多功能，更加模块化，并将“演员”作为一等公民。演员是可以发送和接收消息的实体，状态机只是演员可以拥有的许多行为之一。你还可以将演员表示为承诺、可观察对象、reducer
    等，这将允许开发者使用 XState 的 API（和可视化工具）来处理所有逻辑，而不仅仅是* *状态机特定的逻辑。”*
- en: 'You may have noticed a mention of an XState visualizer in the previous paragraph.
    This tool is something that absolutely sets XState apart from other state management
    libraries. Thanks to this visualizer, you can see a graphical representation of
    states and transitions between states in your app. You can use it to plan a new
    app or debug an app that you are working on. You can find the visualizer at https://xstate.js.org/viz/.
    Here’s an example screenshot of what it looks like:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在前一段中注意到了对 XState 可视化器的提及。这个工具是使 XState 与其他状态管理库截然不同的东西。多亏了这个可视化器，你可以在应用中看到状态和状态之间转换的图形表示。你可以用它来规划新的应用或调试你正在工作的应用。你可以在
    https://xstate.js.org/viz/ 找到这个可视化器。以下是一个示例屏幕截图，展示了它的样子：
- en: '![Figure 7.3 – Screenshot of the XState visualizer ](img/Figure_7.03_B18396.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – XState 可视化器的屏幕截图](img/Figure_7.03_B18396.jpg)'
- en: Figure 7.3 – Screenshot of the XState visualizer
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – XState 可视化器的屏幕截图
- en: David said that the visualizer is one of the hardest things he has worked on.
    It’s always a work in progress, and it has gone through many iterations. Currently,
    it’s an “*SVG-based 'canvas' with HTML inside."* Even though it’s somewhat interactive
    right now—you can click on transitions and observe how the state changes—David
    said that “*making it interactive is yet another layer of difficulty, especially
    for drag-and-drop interactions and modifying the statechart."* Personally, I’m
    very excited about the new versions of the visualizer. It has helped me many times
    to plan the best possible state machine for the apps I worked on (that used XState).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 大卫说，可视化器是他工作过的最难的事情之一。它始终处于进行中，已经经历了多次迭代。目前，它是一个“*基于 SVG 的 '画布'，内部包含 HTML。"*
    尽管现在它有一定的交互性——你可以点击转换并观察状态如何变化——大卫说，“*使其交互式是另一个难度层，特别是对于拖放交互和修改状态图。"* 我个人对可视化器的最新版本非常兴奋。它已经多次帮助我规划我为应用（使用
    XState）设计的最佳状态机。
- en: In this section, we have talked about the main ideas behind XState. They are
    different from all the previous approaches we analyzed. The entire library is
    based on the mathematical concept of finite state machines. It also uses the theories
    behind statecharts and actor models, to make sure managing state in a complex
    app can be done effectively. Now, it’s time to see this library in action. Let’s
    move on to implementing XState in the Funbook app.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了 XState 背后的主要思想。它们与我们之前分析的所有方法都不同。整个库基于有限状态机的数学概念。它还使用了状态图和演员模型背后的理论，以确保在复杂应用中管理状态可以有效地进行。现在，是时候看看这个库的实际应用了。让我们继续在
    Funbook 应用中实现 XState。
- en: Configuring XState in the Funbook app
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Funbook 应用中配置 XState
- en: 'Let’s see what it takes to use XState in a real app. If you would like to follow
    along on your own, you can copy the `example-app-full` folder and use it as a
    starting point. If you prefer to look at the code related to this chapter, please
    look in the `chapter-7` folder: https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-7.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在真实应用中使用 XState 需要什么。如果你想亲自跟随，你可以复制 `example-app-full` 文件夹并将其用作起点。如果你想查看与本章相关的代码，请查看
    `chapter-7` 文件夹：https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-7。
- en: 'First things first—we need to add XState to the project. You can do so by running
    one of the two following commands:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先——我们需要将 XState 添加到项目中。你可以通过运行以下两个命令之一来实现：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'XState itself is an unopinionated library, much like MobX. This means it is
    not ready out-of-the-box to work with React. The XState documentation has a section
    called *Recipes* where you can read more on the implementation with React or other
    UI libraries, such as Vue or Svelte. As for us, we need to add the React-related
    dependency, `xstate-react`. Let’s do this by running one of the two following
    commands:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: XState 本身是一个无偏见的库，就像 MobX 一样。这意味着它不是直接与 React 一起工作的。XState 文档有一个名为 *Recipes*
    的部分，你可以在这里阅读有关使用 React 或其他 UI 库（如 Vue 或 Svelte）的实现。至于我们，我们需要添加与 React 相关的依赖项，`xstate-react`。让我们通过运行以下两个命令之一来实现：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we have the dependencies ready, let’s run the app to make sure everything
    is working as expected. If everything is OK, we can create our very first state
    machine. We will start with a simple example: user login flow. At a high level,
    there isn’t much logic involved in this flow. The user can be either logged in
    or out, and they transition from one state to the other and back:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了准备好的依赖项，让我们运行应用以确保一切按预期工作。如果一切正常，我们可以创建我们的第一个状态机。我们将从一个简单的例子开始：用户登录流程。在高层面上，这个流程中涉及的逻辑并不多。用户可以是登录或注销，他们从一个状态过渡到另一个状态，然后再返回：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Reading through the code is rather logical. We start by importing a `createMachine`
    function, which we call to create our `userFlowMachine` instance. In `userFlowMachine`,
    we start by defining the machine ID and the initial state. We then continue to
    define the two possible states of the app. The user in our app can be anonymous
    or authenticated. But how can the user transition from one state to the other?
    Let’s add this functionality to the state machine:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读代码相当逻辑。我们首先导入一个 `createMachine` 函数，然后调用它来创建我们的 `userFlowMachine` 实例。在 `userFlowMachine`
    中，我们首先定义机器 ID 和初始状态。然后我们继续定义应用的两个可能状态。在我们的应用中，用户可以是匿名或认证的。但用户如何从一种状态过渡到另一种状态呢？让我们将这个功能添加到状态机中：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Great! Now, the user can be in the `anonymous` state, from which they can transition
    using the `LOGIN` transition. At this moment, they will be in the `authenticated`
    state, from which they can transition using the `LOGOUT` transition. You could
    continue improving this example by adding some implementation details to the `LOGIN`
    and `LOGOUT` transitions, or maybe an error state. But I will stop talking about
    this particular state machine now and see how it should be used in a React app.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，用户可以处于 `anonymous` 状态，他们可以通过 `LOGIN` 转换来进入这个状态。在这个时候，他们将处于 `authenticated`
    状态，他们可以通过 `LOGOUT` 转换来退出这个状态。你可以继续改进这个例子，通过添加一些 `LOGIN` 和 `LOGOUT` 转换的实现细节，或者可能是一个错误状态。但我现在将停止讨论这个特定的状态机，看看它应该如何在
    React 应用中使用。
- en: 'Unsurprisingly, the XState docs recommend using React Context to manage global
    state with XState. Luckily for us, we have a good handle on React Context by now,
    right? So, let’s look at an example of React Context in the XState documentation:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，XState 文档建议使用 React Context 来管理 XState 的全局状态。幸运的是，我们现在对 React Context 已经有了很好的掌握，对吧？那么，让我们看看
    XState 文档中的一个 React Context 示例：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Hmm… what is this `useInterpret()` function? It’s imported from `xstate-react`,
    and it’s a special tool to make sure we don’t cause too many re-renders when using
    React Context. `useInterpret()` returns a service, which is a reference to the
    state machine. As per the XState documentation: “*this value never changes, so
    we don’t need to worry about* *wasted re-renders.*”'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯……这个 `useInterpret()` 函数是什么？它是从 `xstate-react` 导入的，是一个特殊的工具，用来确保在使用 React Context
    时不会引起过多的重新渲染。`useInterpret()` 返回一个服务，即状态机的引用。根据 XState 文档：“*这个值永远不会改变，所以我们不需要担心*
    *浪费的重新渲染*。”
- en: Knowing your tools
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 了解你的工具
- en: Every tool was created with an idea of how it should be used. You could take
    a hammer and use the wooden handle to hit a nail, but you have learned this is
    not how hammers work best. The same rule applies to JavaScript libraries. No one
    was born with the knowledge of JavaScript libraries and tooling. We all must read
    the documentation and learn our tools’ best practices.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每个工具都是基于如何使用它的想法而创造的。你可以拿一把锤子用木柄敲钉子，但你已经知道这不是锤子最好的使用方式。同样的规则也适用于 JavaScript
    库。没有人天生就知道 JavaScript 库和工具。我们都必须阅读文档并学习我们工具的最佳实践。
- en: 'We have a way to create context, so now, let’s go through XState’s instructions
    for using it. We will have to subscribe to the service of the global context we
    defined at the root of the app. Here’s what such a subscription would look like:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有创建上下文的方法，现在，让我们看看 XState 使用说明。我们将需要订阅在应用根目录中定义的全局上下文服务。这样的订阅看起来是这样的：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We have completed the basic setup for XState in a React Native app. There are
    many paths to be taken now: improving performance, dispatching events, or using
    state selectors. We will go over the necessary steps in the next section, where
    we will set up XState for the `LikedImages` surface and the modal responsible
    for adding liked images.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 React Native 应用中完成了 XState 的基本设置。现在有许多路径可以选择：提高性能、分发事件或使用状态选择器。我们将在下一节中介绍必要的步骤，我们将为
    `LikedImages` 表面和负责添加喜欢图片的模态设置 XState。
- en: Using XState for the FavoritedImages surface
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 XState 处理 FavoritedImages 表面
- en: 'In the previous section, we set up a basic machine that could be used to control
    the user flow in the app. Let’s add a new machine, for our real-world use case:
    liking images in a social media clone app.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们设置了一个基本的机器，可以用来控制应用中的用户流程。现在让我们添加一个新的机器，用于我们的实际应用场景：在一个社交媒体克隆应用中喜欢图片。
- en: 'We’ll start by creating a machine **minimum viable** **product** (**MVP**):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个**最小可行产品**（**MVP**）的机器：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s analyze this code from the top: we start by importing the `createMachine`
    function, which we use on the very first line of the `likeImagesMachine` function.
    We set the ID of the machine and the context. Bear in mind that XState context
    is different from React context. We’ve talked a lot about ReactJS context; we
    know it can be used to share state between components. XState context is a container
    for quantitative data (such as strings, arrays, or objects), which can potentially
    be infinite. The array of liked images is a great example of this sort of data,
    and that’s why we’ll be keeping this array in our machine’s context. For testing
    purposes, we will add a couple of images to this default array of `likedImages`
    in the context. All that’s left is defining states of our machine and setting
    the default state. Easy-peasy!'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从代码的顶部开始分析：我们首先导入`createMachine`函数，我们在`likeImagesMachine`函数的第一行使用它。我们设置机器的ID和上下文。记住，XState上下文与React上下文不同。我们谈论了很多关于ReactJS上下文的内容；我们知道它可以用于在组件之间共享状态。XState上下文是一个用于定量数据（如字符串、数组或对象）的容器，这些数据可能无限。喜欢的图片数组是这种数据的绝佳例子，这就是为什么我们将保持这个数组在我们的机器上下文中。为了测试目的，我们将向上下文中的默认`likedImages`数组添加一些图片。剩下的只是定义机器的状态和设置默认状态。简单易懂！
- en: 'We will start by creating and configuring a wrapper for the state, with the
    help of React’s context. Once everything is set up correctly with mock data, we
    will fetch real data from our backend. Having fetched data, we will write the
    last piece of code: managing liked images with XState.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建和配置一个用于状态的包装器，借助React的上下文。一旦使用模拟数据正确设置好一切，我们将从我们的后端获取真实数据。获取数据后，我们将编写最后一段代码：使用XState管理喜欢的图片。
- en: Configuring context and components
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置上下文和组件
- en: 'Now is the time to talk about the first type of context: React context. We
    set up a nifty context with the user flow in the previous section. We will add
    the liked images machine to this context:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候讨论第一种上下文类型了：React上下文。我们在上一节中设置了一个巧妙的使用用户流程的上下文。我们将在这个上下文中添加喜欢的图片机器：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is a good moment to improve the basic context we set up in the previous,
    more theoretical part of this chapter. We will do so by adding a new custom hook
    called `useXStateContext`. Using custom hooks with React context is a best practice
    that we covered in previous chapters. In the `GlobalStateProvider` function, we
    added `likedImagesMachine` through the `useInterpret` custom hook provided by
    the good people at XState. We merge the interpreted machines and pass them as
    the context value. The last piece of the context value is wrapping the component
    in context. We will have to keep the global state at the very root of the app
    so that both the `FavoritedImages` surface and `ImageDetailsModal` can reach it.
    Here’s what your `App.js` should roughly look like:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个很好的时机来改进我们在本章前一部分更理论性的部分中设置的基本上下文。我们将通过添加一个名为`useXStateContext`的新自定义钩子来实现这一点。在之前的章节中，我们讨论了使用自定义钩子和React上下文是最佳实践。在`GlobalStateProvider`函数中，我们通过XState提供的`useInterpret`自定义钩子添加了`likedImagesMachine`。我们将解释的机器合并并作为上下文值传递。上下文值的最后一部分是将组件包装在上下文中。我们必须将全局状态保持在应用的最顶层，以便`FavoritedImages`界面和`ImageDetailsModal`都能访问它。以下是你`App.js`的大致样子：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s use this brand-new machine, interpreted by React context and holding
    a few example images in its own context, in the `FavoritedImages` surface. The
    list of favorited images is rendered in the `ListOfFavorites` component, and this
    is the component we will be changing:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个全新的机器，由React上下文解释，并在其自己的上下文中持有一些示例图片，在`FavoritedImages`界面中使用。喜欢的图片列表在`ListOfFavorites`组件中渲染，这就是我们将要更改的组件：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We start by importing the custom `useXStateContext` hook we created to easily
    consume React context. The second thing we need to import is XState’s `useActor`
    hook. This is a React hook that subscribes to emitted changes from a given interpreted
    state machine, named by the XState author “an actor." If you go to the XState
    documentation, you will find there are other implementations of the `useActor`
    function, tailored for use with Svelte, Vue, and other libraries. This is because
    XState, much like MobX, is unopinionated when it comes to UI libraries.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入我们创建的用于轻松消费React上下文的自定义`useXStateContext`钩子。我们需要导入的第二件事是XState的`useActor`钩子。这是一个React钩子，它订阅来自给定解释状态机的发出的更改，由XState作者命名为“actor”。如果你访问XState文档，你将找到其他`useActor`函数的实现，这些实现针对Svelte、Vue和其他库进行了定制。这是因为XState，就像MobX一样，在UI库方面持中立态度。
- en: Finally, we need to use all those imported items in our component. We pull in
    data from React context, and we subscribe to changes through the `useActor` hook.
    We could use the state returned from the `useActor` hook directly. However, React
    Native’s `FlatList` needs to be informed of data changes very clearly to update.
    Therefore, I added a `useState` hook, including the `updateImageData` setter function,
    which will come in handy once we try to add images to this array dynamically.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在我们的组件中使用所有这些导入的项目。我们从React上下文中拉取数据，并通过`useActor`钩子订阅变化。我们可以直接使用`useActor`钩子返回的状态。然而，React
    Native的`FlatList`需要非常清楚地了解数据变化以便更新。因此，我添加了一个`useState`钩子，包括`updateImageData`设置函数，一旦我们尝试动态地向此数组添加图像，它将非常有用。
- en: 'Speaking of dynamically, it’s time to think about data fetching through XState.
    But before we go any further, make sure to run your app with the current changes
    and make sure you can see the example images from the `likeImagesMachine` function
    on the `FavoritedImages` surface. If you do encounter any errors, you can look
    at your terminal window, as many XState errors will be described there. They should
    also be visible on your phone simulator or physical device. Here’s an example
    error you may see in the console and in the simulator at the same time:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 说到动态性，是时候考虑通过XState进行数据获取了。但在我们继续之前，请确保使用当前更改运行您的应用程序，并确保您可以在“FavoritedImages”界面上看到`likeImagesMachine`函数的示例图像。如果您遇到任何错误，您可以查看您的终端窗口，因为许多XState错误都会在那里描述。它们也应该在您的手机模拟器或物理设备上可见。以下是在控制台和模拟器中同时可能看到的示例错误：
- en: '![Figure 7.4 – XState errors in the console and phone simulator ](img/Figure_7.04_B18396.jpg)![Figure
    7.4 – XState errors in the console and phone simulator ](img/Figure_7.05_B18396.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 控制台和手机模拟器中的XState错误](img/Figure_7.04_B18396.jpg)![图7.4 – 控制台和手机模拟器中的XState错误](img/Figure_7.05_B18396.jpg)'
- en: Figure 7.4 – XState errors in the console and phone simulator
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 控制台和手机模拟器中的XState错误
- en: Fetching image data
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取图像数据
- en: 'Fetching data isn’t always the strong suit of state management libraries. After
    all, it’s not their basic responsibility. In the case of XState, however, fetching
    comes very naturally as every Promise can be modeled as a state machine. At a
    high level, we need to kick off a function that will be in a default “loading”
    state. We’ll wait for something to happen with it—either resolve or reject—and
    go to the appropriate “resolved” or “rejected” states. Here’s how our image-fetching
    machine is shaping up:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 获取数据并不总是状态管理库的强项。毕竟，这并不是它们的基本职责。然而，在XState的情况下，获取数据却非常自然，因为每个Promise都可以被建模为一个状态机。从高层次来看，我们需要启动一个将处于默认的“加载”状态的功能。我们将等待它发生某些事情——要么解决要么拒绝——然后进入适当的“已解决”或“已拒绝”状态。以下是我们图像获取机器的构建过程：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'What you can see here is a very simple machine, prepared to describe the process
    of fetching data from an external source. We have three states: the initial state
    of `loading`, and `success` and `failure` states. You can see two actions in the
    `loading` state, which could be used to manage the fetching mechanism. There’s
    also a `retry` action in the `failure` state. We could use it in the app to let
    the users manually try to fetch data when an error occurs. As far as the basic
    setup is concerned, this is all good, but we need to see how to call a real endpoint.
    In order to do so, we will change the `loading` state:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您在这里看到的是一个非常简单的机器，准备描述从外部源获取数据的过程。我们有三个状态：初始的“加载”状态，以及“成功”和“失败”状态。您可以看到在“加载”状态中有两个动作，可以用来管理获取机制。在“失败”状态中还有一个“重试”动作。我们可以在应用程序中使用它，让用户在发生错误时手动尝试获取数据。就基本设置而言，这都很好，但我们需要了解如何调用实际的端点。为了做到这一点，我们将改变“加载”状态：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Instead of two actions that could be called manually, I added the `invoke`
    property to the `loading` state. This way, the images will be loaded automatically
    when the machine is spawned, without needing user interaction. The `invoke` property’s
    value is an object that contains the `id` and `src` properties of the function
    that is to be invoked. It is possible to invoke Promises, callbacks—which can
    send and receive events from the parent machine—observables—which can send events
    to the parent machine—and entire machines. We will stay on the simple side of
    things, and we will add an async `fetch` function to the source. You may also
    create a named function anywhere outside of the machine and invoke it through
    `src`. We are also using two optional values from the `invoke` property: `onDone`
    and `onError`. These two transitions come in handy when handling Promises. They
    act like any other XState transition—they include actions and the target state.
    Both actions include the `assign` keyword. `assign` is a function that updates
    the machine’s context. We use it here to pass the resulting fetched data to the
    context so that we can use it later in our app. Assigner functions have some caveats:
    they have to be pure, and they surrender to a strict order. If you want to read
    more about them, please check the links provided in the *Further* *reading* section.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了代替可能需要手动调用的两个动作，我在`loading`状态中添加了`invoke`属性。这样，当机器被创建时，图片将自动加载，无需用户交互。`invoke`属性的值是一个包含要调用的函数的`id`和`src`属性的对象。可以调用Promise、回调（可以发送和接收来自父机器的事件）——可以发送事件到父机器——以及整个机器。我们将保持简单，并在源中添加一个异步的`fetch`函数。你还可以在任何机器外部创建一个命名函数，并通过`src`调用它。我们还使用了`invoke`属性的两个可选值：`onDone`和`onError`。这两个转换在处理Promise时非常有用。它们像任何其他XState转换一样——包括动作和目标状态。两个动作都包含`assign`关键字。`assign`是一个更新机器上下文的函数。我们在这里使用它来将获取到的结果数据传递到上下文，以便我们可以在应用程序的后续操作中使用它。分配器函数有一些注意事项：它们必须是纯函数，并且必须遵循严格的顺序。如果你想了解更多关于它们的信息，请查看*进一步阅读*部分提供的链接。
- en: 'If everything works fine, you should be able to fetch images thanks to this
    function. But how do we use those images in the `likeImagesMachine` function?
    Remember that `invoke` property we just used for the Promise? We’ll use that same
    property on `likeImagesMachine` in the loading state, to invoke this fetching
    machine and pass the fetched data thanks to the `onDone` function:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该能够通过这个功能获取图片。但我们在`likeImagesMachine`函数中如何使用这些图片呢？记得我们刚才用过的`invoke`属性吗？我们将在`likeImagesMachine`的加载状态下使用相同的属性来调用这个获取机器，并通过`onDone`函数传递获取到的数据：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this code snippet, we’ve imported the `fetchImagesMachine` function and
    we invoke it in the loading state of the `likeImagesMachine` function. Let’s take
    a closer look at the assigner function we’re using to pass image data from `fetchImagesMachine`
    to this parent machine. It has an `onDone` function, which will be called when
    `fetchImagesMachine` reaches its final state. This function assigns data returned
    from the invoked machine to the `context` of `likeImagesMachine`, and the data
    is passed through `event`. You will notice we’re calling `event.data.images`.
    Where did that come from? This is something we need to add to `fetchImagesMachine`.
    So far, that machine only passed fetched data to its `context`, but we need to
    expose it so that the parent machine, `likeImagesMachine`, can access it. We already
    know the `onDone` event in the parent (`likeImagesMachine`) is called when the
    child (`fetchImagesMachine`) reaches its final state. The final state in our case
    is `success`. This is where we can add the `data` property:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们导入了`fetchImagesMachine`函数，并在`likeImagesMachine`函数的加载状态下调用它。让我们更仔细地看看我们用来从`fetchImagesMachine`传递图像数据到这个父机器的分配器函数。它有一个`onDone`函数，当`fetchImagesMachine`达到其最终状态时将被调用。这个函数将调用机器返回的数据分配给`likeImagesMachine`的`context`，并通过`event`传递数据。你会注意到我们正在调用`event.data.images`。这从哪里来的？这是我们需要在`fetchImagesMachine`中添加的东西。到目前为止，该机器只将其获取到的数据传递到其`context`，但我们需要将其公开，以便父机器`likeImagesMachine`可以访问它。我们已经知道在父机器（`likeImagesMachine`）中，当子机器（`fetchImagesMachine`）达到其最终状态时，会调用`onDone`事件。在我们的例子中，最终状态是`success`。这就是我们可以添加`data`属性的地方：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This block of code tells the `fetchImagesMachine` function to add a `data` object
    to its final state. This is the object that we access when we run `onDone` in
    the parent (`likeImagesMachine`). If everything went well, you should be able
    to see the entire array of fetched images in your app right now. This is a good
    moment to run the app on your device or emulator if you haven’t already.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码告诉 `fetchImagesMachine` 函数将其最终状态添加一个 `data` 对象。这是我们运行父级 `likeImagesMachine`
    中的 `onDone` 时访问的对象。如果一切顺利，你现在应该能在你的应用程序中看到获取到的所有图像数组。这是一个在设备或模拟器上运行应用程序的好时机，如果你还没有这样做的话。
- en: Managing the image in the image modal
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理图像模态中的图像
- en: We have ourselves a nice setup—we’re fetching images and feeding them to the
    app. Our app is rather static, though. We need a way to add new images to the
    liked images array. We would also like to check whether an image is liked so that
    we can display the proper icon in `ImageDetailsModal`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个很好的设置——我们在获取图像并将它们提供给应用程序。不过，我们的应用程序相当静态。我们需要一种方法来向喜欢的图像数组中添加新图像。我们还希望检查图像是否被点赞，以便在
    `ImageDetailsModal` 中显示适当的图标。
- en: 'If we want to know whether an image should be liked or unliked, we first need
    to know whether it’s liked. But even before we can know whether an image has been
    liked, we need to know all the data pertinent to that image. We will add a new
    item to the context of the `likeImagesMachine` machine—`currentImage`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想知道图像是否应该被点赞或取消点赞，我们首先需要知道它是否已被点赞。但即使在我们知道图像是否已被点赞之前，我们还需要知道与该图像相关的所有数据。我们将在
    `likeImagesMachine` 机器的上下文中添加一个新项目——`currentImage`：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is where we will store information on the currently viewed image. The
    context is initialized as `null`, and we need to add an action that will update
    this context value. We will add a new event called `MODAL_OPEN` to the `ready`
    state of `likeImagesMachine`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将存储当前查看图像信息的地方。上下文初始化为 `null`，我们需要添加一个将更新此上下文值的动作。我们将在 `likeImagesMachine`
    的 `ready` 状态中添加一个名为 `MODAL_OPEN` 的新事件：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will call the `MODAL_OPEN` action when `ImageDetailsModal` is opened, and
    `MODAL_CLOSE` when the modal is closed—pretty straightforward! You can see the
    code in action here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `ImageDetailsModal` 打开时，我们将调用 `MODAL_OPEN` 动作，当模态关闭时调用 `MODAL_CLOSE`——非常直接！您可以在以下链接中看到代码的实际应用：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We start by using a custom hook called `useXStateContext` in order to consume
    context values that we set up previously. Then, we use the `send` function from
    `likedImagesAppService`. Finally, I’ve added a `useEffect` hook calling the `MODAL_OPEN`
    action when the modal is rendered and `MODAL_CLOSE` as a cleanup function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用一个名为 `useXStateContext` 的自定义钩子来消费我们之前设置的上下文值。然后，我们使用来自 `likedImagesAppService`
    的 `send` 函数。最后，我添加了一个 `useEffect` 钩子，当模态渲染时调用 `MODAL_OPEN` 动作，并将 `MODAL_CLOSE`
    作为清理函数。
- en: 'Now that we have the current image saved in the machine context, we can check
    whether it’s liked or not. To do that, we will use yet another utility from XState:
    a custom hook called `useSelector`. **Selector** is a name that may sound familiar
    to you. In JavaScript, there are query selectors, Redux promotes using selector
    functions, and there are also CSS selectors. XState selectors are the closest
    ideologically to the ones in Redux. They are special functions that receive the
    current state and can return a value based on some conditions. Our current state
    is the array of images and the current image, and the condition is if the current
    image is in the image array. The code is illustrated in the following snippet:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将当前图像保存在机器上下文中，我们可以检查它是否受欢迎。为此，我们将使用来自 XState 的另一个实用工具：一个名为 `useSelector`
    的自定义钩子。**选择器**这个名称可能对你来说很熟悉。在 JavaScript 中，有查询选择器，Redux 推崇使用选择器函数，还有 CSS 选择器。XState
    选择器在意识形态上与 Redux 中的选择器最为接近。它们是特殊的函数，接收当前状态并根据某些条件返回一个值。我们的当前状态是图像数组以及当前图像，条件是当前图像是否在图像数组中。代码在下面的代码片段中展示：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As mentioned previously, this selector will receive the current state as the
    first argument. We start by checking that the images array is not `null`. We are
    running a `find` function on that array, and if it were `null` or `undefined`,
    this would cause the app to crash. Once we’re sure the images array exists, we
    can filter it by the current image. You can place this function anywhere you’d
    like (in the same file as the machine, in a file called `selectors` or `utilities`,
    and so on) and then import it into `ImageDetailsModal`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这个选择器将接收当前状态作为第一个参数。我们首先检查图片数组不是 `null`。我们在该数组上运行 `find` 函数，如果它是 `null`
    或 `undefined`，这会导致应用程序崩溃。一旦我们确定图片数组存在，我们就可以通过当前图片过滤它。你可以把这个函数放在任何你想放的地方（与机器相同的文件中，在名为
    `selectors` 或 `utilities` 的文件中，等等），然后将其导入到 `ImageDetailsModal`：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `isImageLiked` constant can be used in the component to check which icon
    should be displayed and which action (liking or unliking) should be called.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`isImageLiked` 常量可以在组件中使用，以检查应该显示哪个图标以及应该调用哪个动作（点赞或取消点赞）。'
- en: Liking images
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点赞图片
- en: 'Our state machines are aware of the array of images we have fetched and that
    we display on the `FavoritedImages` surface. They also become aware of the currently
    seen image through the `MODAL_OPEN` action. Now, we need to tell them what to
    do if someone presses the “like” button. Let’s add a new action to the `likeImagesMachine`
    function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的状态机了解我们已获取并显示在 `FavoritedImages` 表面上的图片数组。它们也通过 `MODAL_OPEN` 动作了解到当前查看的图片。现在，我们需要告诉它们如果有人按下“点赞”按钮应该怎么做。让我们向
    `likeImagesMachine` 函数添加一个新的动作：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We’re using the assigner function, which we’ve met before. Inside it, we’re
    concatenating the array containing only the current image to the full array of
    all images. This way, the newly added image will be at the top of the array and
    at the top of `FlatList`. Now that the action is ready, we can call it in the
    modal, like so:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用之前遇到过的分配器函数。在其内部，我们将只包含当前图片的数组连接到所有图片的完整数组。这样，新添加的图片就会位于数组的顶部，并在 `FlatList`
    的顶部。现在，动作已经准备好了，我们可以在模态中调用它，如下所示：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We’ve done quite a few changes—let’s test them in our app. If you followed along,
    you should be able to see that the fetched images load correctly on the `FavoritedImages`
    surface. The `ImageDetails` modal opens correctly as well, showing a full heart
    for images that are liked and an empty heart for images that are not liked (those
    on the `Feed` surface). We can even press the empty heart and it changes to be
    filled! The like action and the selector work as expected! Great!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经做了很多更改——让我们在我们的应用程序中测试它们。如果你一直跟着做，你应该能看到获取的图片在 `FavoritedImages` 表面上正确加载。`ImageDetails`
    模态也正确打开，显示已点赞图片的完整心形，未点赞图片（在 `Feed` 表面上）显示为空心形。我们甚至可以按下空心形，它会变成实心！点赞动作和选择器按预期工作！太棒了！
- en: 'Unfortunately, `FlatList` is a little more stubborn. As mentioned before, `FlatList`
    needs explicit data changes in order to re-render, and we need it to re-render
    if we want to see the new images added. We will have to “twist its hand” a little
    bit, by adding this `useEffect` hook:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，`FlatList` 有点固执。正如之前提到的，`FlatList` 需要显式的数据更改才能重新渲染，而如果我们想看到新添加的图片，我们就需要它重新渲染。我们不得不稍微“扭动它的手”，通过添加这个
    `useEffect` 钩子：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: And now, everything should work flawlessly! Time for a pat on the back! We’ve
    covered a lot of topics in this section. We have gone over a real-world implementation
    of setting up multiple state machines, invoking fetching functions, passing context
    values between machines, calling actions, and using selectors. With this knowledge,
    you should be able to configure any app to use XState as the state management
    library.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切应该都能完美工作！是时候给自己鼓掌了！在本节中，我们涵盖了大量的主题。我们讨论了多个状态机的实际应用，调用获取函数，在机器之间传递上下文值，调用动作和使用选择器。有了这些知识，你应该能够配置任何应用程序以使用
    XState 作为状态管理库。
- en: Summary
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'XState is the first state management library in this book to be fundamentally
    based on mathematical principles. We talked briefly about those principles, as
    understanding them is very useful for understanding XState. The most important
    concept is state machines. They are not new in the world of mathematics; they
    are quite novel, however, when it comes to how we think about global state in
    mobile apps. Once we had a grasp on the theory and we discovered the very useful
    XState visualizer, we were ready to do real work. We set up XState in the Funbook
    app, using best practices described in the XState documentation. We covered the
    topic of implementing XState as the global state solution for the use case of
    managing liked images. We looked at fetching data and changing data with XState.
    I hope you enjoyed it! Now, it’s time to continue our journey to the next outlier
    in the state management libraries world: **Jotai**.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: XState 是本书中第一个基于数学原理的基本状态管理库。我们简要地讨论了这些原理，因为理解它们对于理解 XState 非常有用。最重要的概念是状态机。在数学的世界里，它们并不新鲜；然而，当我们谈到移动应用中的全局状态时，它们却相当新颖。一旦我们掌握了理论，并发现了非常有用的
    XState 可视化工具，我们就准备好进行实际工作了。我们在 Funbook 应用中设置了 XState，使用了 XState 文档中描述的最佳实践。我们探讨了将
    XState 作为全局状态解决方案来管理点赞图片用例的实现。我们研究了使用 XState 获取数据和更改数据。我希望你们喜欢它！现在，是时候继续我们的旅程，探索状态管理库世界中的下一个异常值：**Jotai**。
- en: Further reading
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://brilliant.org/wiki/finite-state-machines/](https://brilliant.org/wiki/finite-state-machines/):
    Finite state machines.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://brilliant.org/wiki/finite-state-machines/](https://brilliant.org/wiki/finite-state-machines/):
    有限状态机。'
- en: 'https://www.w3.org/TR/scxml/: W3C SCXML specification.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'https://www.w3.org/TR/scxml/: W3C SCXML 规范。'
- en: 'https://xstate.js.org/docs/recipes/react.html#local-state: XState recipes.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'https://xstate.js.org/docs/recipes/react.html#local-state: XState 菜谱。'
- en: 'https://xstate.js.org/docs/guides/context.html#assign-action: Assigner action.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'https://xstate.js.org/docs/guides/context.html#assign-action: 分配动作。'
