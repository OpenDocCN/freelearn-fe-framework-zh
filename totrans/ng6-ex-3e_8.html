<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Some Practical Scenarios</h1>
                
            
            <article>
                
<p class="calibre3">With seven chapters under our belt, you should feel pretty good. What you have learned thus far is a direct consequence of the apps we have built in the last few chapters. We believe you should now have an adequate understanding of the framework, how it works, and what it supports. Armed with this knowledge, as soon as we start to build some decent-sized apps, there are some common problems/patterns that invariably surface, such as these:</p>
<ul class="calibre11">
<li class="calibre12">How do we authenticate the user and control his/her access (authorize)?</li>
<li class="calibre12">How do we make sure that the app is performing well enough?</li>
<li class="calibre12">My app requires localized content. What do I do?</li>
<li class="calibre12">What tools can I use to expedite app development?</li>
<li class="calibre12">I have an AngularJS app. How do I migrate it?</li>
</ul>
<p class="calibre3">And some more!</p>
<p class="calibre3">In this chapter, we will try to address such common scenarios and provide some working solutions and/or prescriptive guidance to handle such use cases.</p>
<p class="calibre3">The topics we will cover in this chapter include:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Angular seed projects</strong>: You will learn how some seed projects in Angular can help us when starting a new engagement.</li>
<li class="calibre12"><strong class="calibre1">Authenticating Angular applications</strong>: This is a common requirement. We look at how to support cookie- and token-based authentication in Angular.</li>
<li class="calibre12"><strong class="calibre1">Angular performance</strong>: A customary performance section is a must as we try to detail what makes Angular performant and things you can do to make your apps faster.</li>
<li class="calibre12"><strong class="calibre1">Migrating AngularJS apps to Angular</strong>: AngularJS and Angular are altogether different beasts. In this chapter, you will learn how to gradually migrate an AngularJS app to Angular.</li>
</ul>
<p class="calibre3">Let's start at the beginning!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Building a new app</h1>
                
            
            <article>
                
<p class="calibre3">Imagine a scenario here: we are building a new application and given the super awesomeness of the Angular framework, we have unanimously decided to use Angular. Great! What next? Next is the mundane process of setting up the project.</p>
<p class="calibre3">Although a mundane activity, it's still a critical part of any engagement. Setting up a new project typically involves:</p>
<ul class="calibre11">
<li class="calibre12">Creating a standard folder structure. This is at times influenced by the server framework (such as <em class="calibre2">RoR</em>, <em class="calibre2">ASP.Net</em>, <em class="calibre2">Node.js</em>, and others).</li>
<li class="calibre12">Adding standard assets to specific folders.</li>
<li class="calibre12">Setting up the build, which in the case that, we are developing an Angular-based web application, includes:
<ul class="calibre30">
<li class="calibre12">Compiling/transpiling content if using TypeScript</li>
<li class="calibre12">Configuring the Module loader</li>
<li class="calibre12">Dependency management in terms of framework and third-party components</li>
<li class="calibre12">Setting up unit/E2E testing</li>
</ul>
</li>
<li class="calibre12">Configuring builds for different environments such as dev, test, and production. Again, this is influenced by the server technology involved.</li>
<li class="calibre12">Code bundling and minification.</li>
</ul>
<p class="calibre3">There is a lot of stuff to do.</p>
<p class="calibre3">What if we can short-circuit the overall setup process? This <span class="calibre6">is</span><span class="calibre6"> </span><span class="calibre6">indeed possible; we just need a</span> <strong class="calibre5">seed project</strong> <span class="calibre6">or a</span> <strong class="calibre5">starter site</strong><span class="calibre6">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Seed projects</h1>
                
            
            <article>
                
<p class="calibre3">Angular CLI as a built and scaffolding tool is awesome! But, it is not the only option out there. There are a number of <em class="calibre17">seed projects/starter sites</em> that can get us up and running in no time. Some seed projects integrate the framework with a specific backend and some only dictate/provide Angular-specific content. Some come preconfigured with vendor-specific libraries/frameworks (such as <em class="calibre17">LESS</em>, <em class="calibre17">SASS</em>, <em class="calibre17">Bootstrap</em>, and others), whereas others just provide a plain vanilla setup.</p>
<p class="calibre3">Some of the notable seed projects worth exploring are as follows:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Angular Starter</strong> (<a href="http://bit.ly/ng-starter" class="calibre10">http://bit.ly/ng-starter</a>): This seed repo serves as an Angular starter for anyone looking to get up and running with Angular and TypeScript fast. It uses Webpack (module bundler) to build our files and assist with boilerplate. It's a complete build system with a substantial number of integrations.</li>
<li class="calibre12"><strong class="calibre1">Angular Seed</strong> (<a href="http://bit.ly/ng-starter-seed" class="calibre10">http://bit.ly/ng-starter-seed</a>): Another seed project similar to Angular Starter. This seed project uses gulp for build automation, and the module bundler system is not as advanced as Webpack.</li>
</ul>
<p class="calibre3">These projects along with Angular CLI provide a head start when building with Angular.</p>
<p class="calibre3">If the app is tied to a specific backend stack, we have two choices, which are as follows:</p>
<ul class="calibre11">
<li class="calibre12">Use one of these seed projects and integrate it with the backend manually.</li>
<li class="calibre12">Find a seed project/implementation that does it for us. There is a good chance you will find such seed projects.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Angular performance</h1>
                
            
            <article>
                
<p class="calibre3">Angular has been designed with performance in mind. Every part of the framework, starting from the framework footprint, initial load time, memory utilization, change detection plus data binding, and DOM rendering, has been tweaked or is being tweaked for better performance.</p>
<p class="calibre3">The next few sections are dedicated to understanding how performant Angular is and the tricks it uses to achieve some impressive performance gains.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Byte size</h1>
                
            
            <article>
                
<p class="calibre3"><em class="calibre17">The Byte size</em> of the framework is a good starting point for performance optimization. While the world is moving towards high-speed internet, a sizable population among us is on a slow connection and are using their mobile to connect to the web. We may not think too much about a few KB here or there, but it does matter!</p>
<p class="calibre3">While the byte size of Angular out of the box is bigger than AngularJS, there are techniques that can drastically reduce the size of an Angular bundle.</p>
<p class="calibre3">To start with, the standard techniques of <em class="calibre17">minification</em> and <em class="calibre17">gzipping</em> can reduce this gap substantially. And with Angular, we can do some nifty tricks with <em class="calibre17">module bundler/loaders</em> to reduce the Angular bundle size even more.</p>
<p class="calibre3"><strong class="calibre5">Tree shaking</strong> may be a quirky name for a process, but it literally does what it says! As we build apps using TypeScript (or ES2015), containing <em class="calibre17">modules</em> and <em class="calibre17">exports</em>, a module bundler such as <em class="calibre17">Rollup</em> (<span class="calibre6"><a href="http://rollupjs.org" class="calibre10">http://rollupjs.org</a></span>) can perform static code analysis on such code, determine what parts of the code are never used, and remove them before bundling the release bits. Such module bundlers, when added to the app's build process, can analyze the framework bit, any third-party library, and the app code to remove any dead code before creating bundles. <em class="calibre17">Tree shaking can result in enormous size reduction as you don't bundle framework bits that you don't use.</em></p>
<p class="calibre3">One of the biggest framework pieces that can be removed from the framework bundle is the <em class="calibre17">compiler</em>. Yes, you read right, it's the compiler!</p>
<div class="packt_infobox"><br class="calibre27"/>
For curious readers, the compiler is the single biggest framework piece, contributing roughly 50% in size to the Angular bundle (In Angular <em class="calibre31">v2.0.0</em>).</div>
<p class="calibre3">Using tree shaking together with <strong class="calibre5">Ahead-of-Time</strong> (<strong class="calibre5">AoT</strong>) compilation, we can just get rid of the Angular compiler (in the browser) altogether.</p>
<p class="calibre3">With AoT compilation, the view templates (HTML) are compiled beforehand on the server side. This compilation again is done as part of the app's build process where a server version of the Angular compiler (a node package) compiles every view in the application.</p>
<p class="calibre3">With all the templates compiled, there is no need to send the Angular compiler bits to the client side at all. Tree shaking can now just get rid of the compiler and create a far slimmer framework package. Angular CLI supports AoT compilation and can be used for production builds.</p>
<div class="packt_infobox">Read more about AoT in the framework documentation available at <a href="http://bit.ly/ngx-aot" class="calibre21">http://bit.ly/ngx-aot</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Initial load time and memory utilization</h1>
                
            
            <article>
                
<p class="calibre3">The initial load time for any web app with a full-fledged JavaScript framework is typically slow. This effect is more pronounced on mobile devices, where the JavaScript engine may not be as powerful as a desktop client. For a better user experience, it becomes imperative that the framework initial load time is optimized, especially for mobile devices.</p>
<p class="calibre3">Out of the box, <strong class="calibre5">Angular 2 was five times faster than AngularJS</strong> when it came to initial load time and re-rendering the view. These numbers are getting better as the Angular team evolves the framework.</p>
<p class="calibre3">Further, AoT compilation too can improve the initial load time of the application as a time-consuming activity (view compilation) is not required.</p>
<p class="calibre3">The same holds true for memory utilization. Angular fares better here too, and things will get even better with future releases.</p>
<p class="calibre3">If you are planning to switch to Angular, this is something that you should look forward to: a performant framework built for the future.</p>
<p class="calibre3">The next three performance improvements that we are going to talk about have been made possible because of a single architectural decision: <em class="calibre17">the creation of a separate renderer layer</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Angular rendering engine</h1>
                
            
            <article>
                
<p class="calibre3">The biggest disadvantage of AngularJS was that the framework was tied to the browser DOM. The directives, the binding, and the interpolations all worked against the DOM.</p>
<p class="calibre3">With Angular, the biggest architectural change that came in was a separate rendering layer. Now, an Angular app has two layers:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Application layer</strong>: This is the layer our code resides in. It uses an abstraction build over the renderer layer to interact with it. The Renderer class we saw in <a href="" class="calibre10">Chapter 6</a>, <em class="calibre2">Angular Directives in Depth</em>, is the interface that we use to interact with the rendering layer.</li>
<li class="calibre12"><strong class="calibre1">Rendering layer</strong>: This layer is responsible for translating requests from the application layer into rendered components, and reacting to user input and view updates.</li>
</ul>
<p class="calibre3">The default renderer implementation for the renderer is <kbd class="calibre13">DomRenderer</kbd>, which runs inside the browser. But there are other rendering abstractions too and we will discuss them in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Server-side rendering</h1>
                
            
            <article>
                
<p class="calibre3"><strong class="calibre5">Pre-rendering</strong> on the server side is yet another technique for improving the initial load time of an Angular app. This technique is really helpful on mobile devices, as it improves the perceived load time considerably.</p>
<p class="calibre3">Server-side rendering takes care of the initial page load before client-side rendering kicks in (and handles view rendering henceforth).</p>
<p class="calibre3">In such a scenario, when the user requests for a view/page, a piece of software on the server generates a fully materialized HTML page with data pre-bound to the view and sends it to the client along with a small script. The app view is therefore immediately rendered, ready for interaction. While the framework loads in the background, the small script that was sent along the first time captures all user inputs and makes them available to the framework, allowing it to replay the interactions once it is loaded.</p>
<p class="calibre3"><strong class="calibre5">Angular Universal</strong>, as it is touted, allows rendering and sharing of the view both on the server and the client side.</p>
<p class="calibre3">Server-side rendering is only made possible because of separation of the rendering layer described previously. The initial view is generated by a renderer implementation on the server, named <kbd class="calibre13">ServerDomRenderer</kbd>. There is a Node.js plugin (<span class="calibre6"><a href="http://bit.ly/ng-universal-node" class="calibre10">http://bit.ly/ng-universal-node</a></span>) that can be used in a number of node web frameworks such as <em class="calibre17">Express</em>, <em class="calibre17">Hapi</em>, <em class="calibre17">Sail</em>, and others.</p>
<div class="packt_infobox">Look at the Angular design docs for Angular Universal (<span class="packt_screen"><a href="http://bit.ly/ng-universal-design" class="calibre21">http://bit.ly/ng-universal-design</a></span>) and the embedded YouTube videos at the top of the design doc to learn more about server-side rendering.</div>
<p class="calibre3">Performance is not the only benefit with server-side rendering. As it turns out, search indexers too like pre-rendered HTML content. Server-side rendering is really useful in areas such as <strong class="calibre5">search engine optimization (SEO)</strong> and deep linking, which allows easy content sharing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Offloading work to a web worker</h1>
                
            
            <article>
                
<p class="calibre3">Offloading work to a <strong class="calibre5">web worker</strong> is a neat idea, again made possible due to the separation of the rendering layer from the application layer.</p>
<p class="calibre3"><em class="calibre17">Web workers</em> provide a mechanism for running scripts in background threads. These threads can execute work that does not involve the browser DOM. Be it a CPU-intensive task or a remote XHR invocation, all can be delegated to web workers.</p>
<p class="calibre3">In today's world, CPUs with multiple cores are the norm, but JavaScript execution is still single-threaded. There is a need for a standard/mechanism to utilize these idle cores for our apps. Web workers fit the bill perfectly, and since most modern browsers support them, we all should be writing code that utilizes web workers.</p>
<p class="calibre3">Sadly, that's not happening. Web workers are still not mainstream, and there are good reasons for that. Web workers impose a good number of restrictions on what is allowed and what is not. These limitations include:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">No direct access to DOM</strong>: Web workers cannot directly manipulate the DOM. In fact, web workers do not have access to multiple globals such as <em class="calibre2">window</em> and <em class="calibre2">document</em>, and others are not available on the web worker thread. This severely limits the number of use cases where a web worker can be utilized.</li>
<li class="calibre12"><strong class="calibre1">Browser support</strong>: Web workers are only available for modern/evergreen browsers (IE 10+).</li>
<li class="calibre12"><strong class="calibre1">Inter-process communication</strong>: Web workers do not share the memory with your main browser process, and hence need to communicate with the main thread (UI thread) only through <em class="calibre2">message passing</em> (serialized data). Adding to that, the message passing mechanism is asynchronous in nature, adding another layer of complexity to the communication model.</li>
</ul>
<p class="calibre3">Clearly, web workers are hard to use.</p>
<p class="calibre3">Angular tries to alleviate these limitations by integrating the web worker usage into the framework itself. It does that by running the complete application in the web worker thread, except the rendering part.</p>
<p class="calibre3">The framework takes care of the communication between the application code running inside the web worker and the renderer running inside the main UI thread. From a developer's perspective, there are no visible differences.</p>
<p class="calibre3">This is again made possible due to the separation of the renderer layer in Angular. The following diagram shows the layers that run on the app main thread and what runs inside the web worker:</p>
<div class="packt_figure"><img src="../images/00078.jpeg" class="calibre73"/></div>
<div class="packt_infobox"><br class="calibre27"/>
Go through this talk (<span class="packt_screen"><a href="http://bit.ly/yt-ng-web-worker" class="calibre21">http://bit.ly/yt-ng-web-worker</a></span>) from Jason Teplitz to learn about what web workers have to offer.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Performant mobile experience</h1>
                
            
            <article>
                
<p class="calibre3">Angular's rendering abstraction again opens up a host of integration avenues, especially on the mobile platform. Rather than running an app on a mobile browser, Angular renderers can be created that can tap the device's native UI capabilities.</p>
<p class="calibre3">Two notable projects in this domain are renderers for platforms:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">ReactNative</strong> (<span><a href="http://bit.ly/rnative" class="calibre10">http://bit.ly/rnative</a></span>): A renderer for ReactNative (<span><a href="http://bit.ly/ng-rnative" class="calibre10">http://bit.ly/ng-rnative</a></span>). It allows the writing of Angular apps using ReactNative's rendering capabilities.</li>
<li class="calibre12"><strong class="calibre1">NativeScript</strong> (<span><a href="https://www.nativescript.org/" class="calibre10">https://www.nativescript.org/</a></span>): Angular and NativeScript teams have collaborated to create a renderer for NativeScript (<span><a href="http://bit.ly/ng-native-script" class="calibre10">http://bit.ly/ng-native-script</a></span>).</li>
</ul>
<p class="calibre3">App platforms such as <em class="calibre17">ReactNative</em> and <em class="calibre17">NativeScript</em> already do a superb job of providing JavaScript-based APIs for the native mobile platforms (iOS and Android), allowing us to utilize a single code base with a familiar language. Angular renderers take things a step further. With Angular integration, a good amount of code can be shared across browsers and mobile devices. Things may only differ in terms of view templates and view-related services such as dialogs, popups, and others.</p>
<p class="calibre3">Look at the documentation for the respective renderers to understand how they work and the features they support.</p>
<p class="calibre3">Next up on the line, we have framework improvements in terms of <em class="calibre17">change detection</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Change detection improvements</h1>
                
            
            <article>
                
<p class="calibre3">One of the major performance improvements in Angular over AngularJS is in how <em class="calibre17">change detection</em> works in Angular. Out of the box, Angular change detection is insanely fast, and it can be tweaked even further for better results.</p>
<p class="calibre3">The next few sections talk about Angular change detection in depth. It's an important topic to understand when building anything at scale. It also helps us debug scenarios where it may seem that change detection is not working as advertised.</p>
<p class="calibre3">Let's start the discussion by understanding what change detection is and why it is important.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Change detection</h1>
                
            
            <article>
                
<p class="calibre3">Angular's <em class="calibre17">data binding engine</em> does a great job of binding the view with the model data (component data). These are live bindings where Angular keeps the view in sync with model changes. Any time the model changes, the binding engine re-renders parts of the view that are dependent on the model. To manage this view-model synchronization, Angular needs to know when the model changed and what changed exactly. This is what <strong class="calibre5">change detection</strong> is all about. During app execution, Angular frequently does what we call <strong class="calibre5">change detection runs</strong> to determine what changed.</p>
<div class="packt_infobox"><br class="calibre27"/>
If you are from AngularJS, a <em class="calibre31">change detection run</em> is roughly equivalent to <strong class="calibre26">digest cycles</strong>, except that in Angular there are <strong class="calibre26">no cycles</strong>.</div>
<p class="calibre3">While this problem of keeping the model and view in sync may sound simple, it's a tough nut to crack. Unlike the component tree, the interconnection between multiple models can be complex. Changes in one component model can trigger changes in multiple component models. Furthermore, these interconnections may have cycles. A single model property could be bound to multiple views. All these complex scenarios need to be managed using a robust change detection infrastructure.</p>
<p class="calibre3">In the next few sections, we explore how the Angular change detection infrastructure works, when change detection triggers, and how can we influence change detection behavior in Angular.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Change detection setup</h1>
                
            
            <article>
                
<p class="calibre3">It all starts with Angular setting up change detectors for every component rendered on the view. Since every Angular app is a hierarchy of components, these change detectors are also set up in the same hierarchy. The following diagram highlights the <strong class="calibre5">change detector hierarchy</strong> of the <em class="calibre17">Workout Builder</em> app at a point in time:</p>
<div class="packt_figure"><img class="image-border18" src="../images/00079.jpeg"/></div>
<p class="calibre3">A <em class="calibre17">change detector</em> attached to a component has the responsibility of detecting changes in the component. It does that by parsing the binding on the component's template HTML and setting up the necessary change detection watches.</p>
<p class="calibre3">Remember, the detector only sets up watches on model properties used in the template, not on all component properties.</p>
<p class="calibre3">Another important point worth highlighting here is that <em class="calibre17">change detection is set up one way, from model to view</em>. Angular does not have the concept of two-way data binding and hence the preceding figure is a directed tree without cycles. This also makes change detection more predictable. Interleaving model and view updates are disallowed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">When does change detection kick in?</h1>
                
            
            <article>
                
<p class="calibre3">Does Angular constantly check for changes in the model data? Considering the fact that the component properties we bind the view to do not inherit from any special class, Angular has no way of knowing which property changed. The only way out for Angular is to constantly query each data-bound property to know its current value and compare it against its old value for changes. Highly inefficient to say the least!</p>
<p class="calibre3">Angular does better than that, as change detection runs get executed only at specific times during app execution. Think carefully about any web application; what causes a view to update?</p>
<p class="calibre3">A view can get updated due to:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">User input/browser events</strong>: We click on a button, enter some text, or scroll the content. Each of these actions can update the view (and the underlying model).</li>
<li class="calibre12"><strong class="calibre1">Remote XHR requests</strong>: This is another common reason for view updates. Getting data from a remote server to show on the grid and getting user data to render a view are examples of this.</li>
<li class="calibre12"><strong class="calibre1">setTimeout and setInterval timers</strong>: As it turns out, we can use <kbd class="calibre13">setTimeout</kbd> and <kbd class="calibre13">setInterval</kbd> to execute some code asynchronously and at specific intervals. Such code can also update the model. For example, a <kbd class="calibre13">setInterval</kbd> timer may check for stock quotes at regular intervals and update the stock price on the UI.</li>
</ul>
<p class="calibre3">For obvious reasons, Angular change detection too kicks in only when any of these conditions occur.</p>
<p class="calibre3">The interesting part here is not when Angular's change detection kicks in but how Angular is able to intercept all <em class="calibre17">browser events</em>, <em class="calibre17">XHR requests</em>, and <kbd class="calibre13">setTimeout</kbd> and <kbd class="calibre13">setInterval</kbd> functions.</p>
<p class="calibre3">This feat in Angular is performed by a library called <kbd class="calibre13">zone.js</kbd>. As the documentation describes:</p>
<div class="packt_quote">"A Zone is an execution context that persists across async tasks."</div>
<p class="calibre3">One of the basic abilities of this library is that it can hook into a piece of code and trigger callbacks when code execution starts and when it ends. The code being monitored could be a sequence of calls that are both synchronous and asynchronous in nature. Consider this example, which highlights the usage:</p>
<pre class="calibre19">let zone = new NgZone({ enableLongStackTrace: false });     
let doWork = function () { 
  console.log('Working'); 
}; 
 
zone.onMicrotaskEmpty.subscribe((data:any) =&gt; { 
  console.log("Done!"); 
}); 
 
zone.run(() =&gt; { 
  doWork(); 
    setTimeout(() =&gt; { 
        console.log('Hard'); 
        doWork(); 
    }, 200); 
    doWork(); 
}); </pre>
<p class="calibre3">We wrap a piece of code inside a call to the <kbd class="calibre13">zone.run</kbd> call. This code calls the <kbd class="calibre13">doWork</kbd> function synchronously twice, interleaved with a <kbd class="calibre13">setTimeout</kbd> call that invokes the same function after a lapse of 200 milliseconds.</p>
<p class="calibre3">By wrapping this sequence inside <kbd class="calibre13">zone.run</kbd>, we can know when the call execution is complete. In zone terminology, these are <strong class="calibre5">turns</strong>. The code before <kbd class="calibre13">zone.run</kbd> sets up a subscriber that gets called when execution is complete, using the <kbd class="calibre13">zone.onMicrotaskEmpty</kbd> function:</p>
<p class="calibre3">If we execute the preceding code, the logs look as follows:</p>
<pre class="calibre19">Working  // sync call 
Working  // sync call 
<strong class="calibre1">Done!   // main execution complete </strong> 
Hard     // timeout callback 
Working  // async call 
<strong class="calibre1">Done!   // async execution complete</strong></pre>
<p class="calibre3">The <kbd class="calibre13">onMicrotaskEmpty</kbd> subscription is executed twice, once after the sequential execution completes (defined inside <kbd class="calibre13">run</kbd> callback) and one after the asynchronous <kbd class="calibre13">setTimeout</kbd> execution is complete.</p>
<p class="calibre3">Angular change detection uses the same technique to execute our code within zones. This code could be an <em class="calibre17">event handler</em>, which internally makes more synchronous and asynchronous calls before completing, or it could be a <kbd class="calibre13">setTimeout</kbd>/<kbd class="calibre13">setInterval</kbd> operation that may again require a UI update.</p>
<p class="calibre3">The Angular change detection framework subscribes to the <kbd class="calibre13">onMicrotaskEmpty</kbd> observable for the executing zone, and kicks in change detection whenever a turn is complete. The following diagram highlights what happens when code similar to the one just described is run on a button click:</p>
<div class="packt_figure"><img src="../images/00080.jpeg" class="calibre74"/></div>
<div class="packt_infobox">During the execution of the code block, if the zone library determines that the call is asynchronous in nature, it spawns a new micro task that has its own life cycle. It is the completion of these micro tasks that also triggers <kbd class="calibre24">onMicrotaskEmpty</kbd>.</div>
<p class="calibre3">If you want to know how the change detection trigger looks inside Angular, here is an excerpt from the Angular source code (simplified further):</p>
<pre class="calibre19">class ApplicationRef { 
 
  constructor(private zone: NgZone) { 
    this._zone.onMicrotaskEmpty.subscribe(<br class="title-page-name"/>        {next: () =&gt; { this._zone.run(() =&gt; { this.tick(); }); }}); 
  } 
 
  tick() { <br class="title-page-name"/>    this._views.forEach((view) =&gt; view.detectChanges());
  } 
} </pre>
<p class="calibre3">The <kbd class="calibre13">ApplicationRef</kbd> class tracks all the change detectors attached throughout the app and triggers a change detection cycle when the application-level zone object fires the <kbd class="calibre13">onMicrotaskEmpty</kbd> event. We will shortly touch upon what happens during this change detection.</p>
<p class="calibre3"><em class="calibre17">Zone.js</em> gets the ability to track execution context across any asynchronous call because it overrides the default browser API. The override, also termed <strong class="calibre5">monkey patching</strong>, overrides the <em class="calibre17">event subscription</em>, <em class="calibre17">XHR requests</em>, and <kbd class="calibre13">setTimeout</kbd>/<kbd class="calibre13">setInterval</kbd> API. In the example highlighted previously, the <kbd class="calibre13">setTimeout</kbd> we invoke is a monkey-patched version of the original browser API.</p>
<p class="calibre3">Now that we know how change detectors are set up and when this activity kicks in, we can look at how it works.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How does change detection work?</h1>
                
            
            <article>
                
<p class="calibre3">Once the change detectors are set up and the browser API is monkey-patched to trigger change detection, the real change detection kicks in. This is quite a simple process.</p>
<p class="calibre3">As soon as any of the asynchronous event callbacks are triggered (the execution of an event handler is also an async activity), Angular first executes the application code we attached to the callback. This code execution may result in some model updates. After the execution of the callback, Angular needs to respond to the changes by triggering a <em class="calibre17">change detection run</em>.</p>
<p class="calibre3">In a change detection run, starting from the top of the component tree, every change detector evaluates its respective component's template bindings to see if the value of the binding expression has changed.</p>
<p class="calibre3">There are some things that we need to highlight regarding this execution:</p>
<ul class="calibre11">
<li class="calibre12">Angular does a strict equality check (using <kbd class="calibre13">===</kbd>) to detect changes. Since it's not a deep comparison, for a binding that refers to an object, Angular will only update the view when the object reference changes.</li>
<li class="calibre12">The change detection flow is unidirectional (starting from root), from parent to child in a top-down fashion. The detectors on the parent component run before the child detectors.</li>
</ul>
<p class="calibre3">By default, the change detection algorithm navigates the complete tree, irrespective of where the change was triggered in the tree. This implies all binding is evaluated on every change detection run:</p>
<div class="packt_figure"><img class="image-border19" src="../images/00081.jpeg"/></div>
<div class="packt_infobox">A binding evaluation on every run may seem inefficient, but it is not. Angular employs some advance optimizations to make this check super fast. Still, if we want to tweak this behavior, we do have some switches that can reduce the number of checks performed. We will touch upon this topic soon.</div>
<ul class="calibre11">
<li class="calibre12">Change detectors only track properties that are part of template bindings, not the complete object/component properties.</li>
<li class="calibre12">To detect changes in the bound value, the change detectors need to track the previous value of the expression evaluated during the last change detection run. Clearly, some amount of bookkeeping is required for every template binding we use.</li>
</ul>
<p class="calibre3">The obvious next question would be what happens when a change is detected (by a change detector)?</p>
<p class="calibre3">Since all the hard work of setting up change detection and identifying changes has already been done, this step just involves updating the component state and synchronizing the component DOM.</p>
<p class="calibre3">There are a few more observations worth highlighting here:</p>
<ul class="calibre11">
<li class="calibre12">First and foremost, Angular separates the model update step from the DOM update. Consider this code snippet, which is invoked when someone clicks on a button:</li>
</ul>
<pre class="calibre19">        doWork() { 
           this.firstName="David"; 
           this.lastName="Ruiz"; 
        } </pre>
<p class="calibre36">Assuming that both <kbd class="calibre13">firstName</kbd> and <kbd class="calibre13">lastName</kbd> are bound to the component view, a change to <kbd class="calibre13">firstName</kbd> does not update the DOM binding immediately. Instead, Angular waits for the <kbd class="calibre13">doWork</kbd> function to complete before triggering a change detection run and DOM update.</p>
<ul class="calibre11">
<li class="calibre75">Secondly, a change detection run does not (and should not) update the model state. This avoids any cycles and cascading updates. A change detection run is only responsible for evaluating the bindings and updating the view. This also means that we should not update the model state during change detection. If we update the model during change detection, Angular throws an error.</li>
</ul>
<p class="calibre3">Let's see an example of this behavior:</p>
<ol class="calibre14">
<li value="1" class="calibre12">Open <kbd class="calibre13">start.component.html</kbd> from the 7 Minute Workout app and update the last <kbd class="calibre13">div</kbd> to:</li>
</ol>
<pre class="calibre19">            &lt;div class="col-sm-3"&gt; 
            Change detection done {{changeDetectionDone()}}
            &lt;/div&gt; </pre>
<ol start="2" class="calibre14">
<li value="2" class="calibre12">And, add a <kbd class="calibre13">changeDetectionDone</kbd> function to the component implementation (<kbd class="calibre13">start.component.ts</kbd>), which looks like:</li>
</ol>
<pre class="calibre19">            times: number = 0; 
            changeDetectionDone(): number { 
                this.times++; 
                return this.times; 
            } </pre>
<ol start="3" class="calibre14">
<li value="3" class="calibre12">Run the app, load the start page, and then look at the browser console. Angular has logged a number of errors that look like the following:</li>
</ol>
<pre class="calibre19">        EXCEPTION: Expression has changed after it was checked.
        Previous value: 'Change 
        detection done 1'. Current value: 'Change detection done 2' ... </pre>
<p class="calibre36">We are changing the state of the component when calling the <kbd class="calibre13">changeDetectionDone</kbd> function (inside an interpolation), and Angular throws an error because it does not expect the component state to update.</p>
<div class="packt_infobox">This change detection behavior is enabled only when <strong class="calibre26">production mode</strong> in Angular is disabled. <em class="calibre31">Production mode</em> can be enabled by calling the <kbd class="calibre24">enableProdMode()</kbd>  function before bootstrapping the application (in <kbd class="calibre24">bootstrap.ts</kbd>). When enabled, Angular behaves a bit differently. It turns off assertions and other checks within the framework. Production mode also affects the change detection behavior. In non-production mode, Angular traverses the component tree twice to detect changes. If on the second pass any binding expression has changed, it throws an error. In contrast, when in production mode, change detection tree traversal is done only once. The change detection error that we saw on the console will not show up if we enable production mode. This can lead to an inconsistency between the model and view state. Something we should be aware of! The bottom line is that we cannot alter the state of a component when change detection is in progress. A direct corollary: if we are using a function inside the binding expression, function executions should be stateless, without any side effects.</div>
<ul class="calibre11">
<li class="calibre12">Lastly, this change detection traversal from root to leaf node executes only once during the change detection run.</li>
</ul>
<div class="packt_infobox">A pleasant surprise for folks with an AngularJS background! <em class="calibre31">The digest cycle count in Angular is 1</em>. Angular developers will never face "the digest iterations exceeded exception!" A far more performant change detection system!</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Change detection performance</h1>
                
            
            <article>
                
<p class="calibre3">Let's talk about change detection performance. If you think checking the complete component tree every time for change is inefficient, you will be surprised to know how fast it is. Due to some optimization around how expressions are evaluated and compared, Angular can perform thousands of checks in a couple of milliseconds.</p>
<p class="calibre3">Under the hood, for every expression involved in the view binding, Angular generates a change detection function that specifically targets a particular binding. While it may seem counter intuitive at first, Angular does not have a common function for determining whether an expression has changed. Instead, it's like writing our own change detection function for every property that we bind to. This allows the JavaScript VM to optimize the code, resulting in improved performance.</p>
<div class="packt_infobox"><br class="calibre27"/>
Want to learn more about it? Check out this video by Victor Savkin: <span class="packt_screen"><a href="https://youtu.be/jvKGQSFQf10" class="calibre21">https://youtu.be/jvKGQSFQf10</a></span>.</div>
<p class="calibre3">In spite of all this optimization, there may still be cases where traversing the complete component tree may not be performant enough. This is especially true when we have to render a large dataset on the view, keeping the bindings intact. The good news is that the Angular change detection mechanism can be tweaked.</p>
<p class="calibre3">The reason Angular needs to do the complete tree walk is that model changes in one place may trigger model changes at other places. In other words, a model change may have a cascading effect, where interconnected model objects are also updated. Since Angular has no way to know what exactly changed, it checks the complete component tree and associated model.</p>
<p class="calibre3">If we can help Angular determine what parts of the application state are updated, Angular can be pretty smart about what part of the component tree it traverses to detect changes. We do this by storing the app data in some special data structures that help Angular decide what components need to be checked for changes.</p>
<p class="calibre3">There are three ways in which we can make Angular change detection smarter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using immutable data structures</h1>
                
            
            <article>
                
<p class="calibre3"><strong class="calibre5">Immutable objects/collections</strong> are objects that cannot be changed once created. Any property change results in a new object being created. This is what <kbd class="calibre13">immutable.js</kbd>, a popular library for immutable data structures, has to say:</p>
<div class="packt_quote">Immutable data cannot be changed once created, leading to much simpler application development, no defensive copying, and enabling advanced memoization and change detection techniques with simple logic.</div>
<p class="calibre3">Let's try to understand how immutable data structures help in the Angular context with an example.</p>
<p class="calibre3">Imagine we are building a set of components to collect employee information for a <strong class="calibre5">Human Resource</strong> (<strong class="calibre5">HR</strong>) software. The employee component view looks something like this:</p>
<pre class="calibre19">&lt;Employee&gt; 
    &lt;summary [model]="employee"&gt;&lt;/employee&gt; 
    &lt;personal [model]="employee.personal"&gt;&lt;/personal&gt; 
    &lt;professional [model]="employee.professional"&gt;&lt;/professional&gt; 
    &lt;address [model]="employee.home"&gt;&lt;/address&gt; 
    &lt;address [model]="employee.work"&gt;&lt;/address&gt; 
&lt;/Employee&gt; </pre>
<p class="calibre3">It has sections for taking personal, professional, and address information. The <kbd class="calibre13">summary</kbd> components provide a read-only view of the employee data being entered. Each of the components has a property called <kbd class="calibre13">model</kbd>, highlighting what part of employee data these components manipulate. Each of these components' summary, professional, personal, and address internally may have other child components. This is how the component tree looks:</p>
<div class="packt_figure"><img src="../images/00082.jpeg" class="calibre76"/></div>
<p class="calibre3">What happens when we update an employee's personal information? With standard objects (mutable), Angular cannot make any assumption about the shape of data and what has changed; hence, it does the complete tree walk.</p>
<p class="calibre3">How does immutability help here? When using an immutable data structure, any change to an object's properties results in a new object being created. For example, if we create an immutable object using a popular library, <kbd class="calibre13">Immutable.js</kbd>:</p>
<pre class="calibre19">personalInfo = Immutable.Map({ name: 'David', 'age': '40' }); </pre>
<p class="calibre3">Changes to either the <kbd class="calibre13">name</kbd> or <kbd class="calibre13">age</kbd> property of <kbd class="calibre13">personalInfo</kbd> create a new object:</p>
<pre class="calibre19">newPersonalInfo = personalInfo.set('name', 'Dan'); </pre>
<p class="calibre3">This immutability comes in handy if each of the employee model properties (<kbd class="calibre13">personal</kbd>, <kbd class="calibre13">professional</kbd>, <kbd class="calibre13">home</kbd>, and <kbd class="calibre13">work</kbd>) is immutable.</p>
<p class="calibre3">Take, for instance, the <kbd class="calibre13">PersonalInfo</kbd> component definition that binds to personal info data:</p>
<pre class="calibre19"> @Component({ 
  selector:'personal', 
  template: ` 
    &lt;h2&gt;{{model.name}}&lt;/h2&gt; 
    &lt;span&gt;{{model.age}}&lt;/span&gt;`, 
<strong class="calibre1">  changeDetection: ChangeDetectionStrategy.OnPush</strong> 
}) 
class PersonalInfo { 
  @Input() model; 
} </pre>
<p class="calibre3">Since the only thing <kbd class="calibre13">PersonalInfo</kbd> depends upon is the <kbd class="calibre13">model</kbd> property, and the <kbd class="calibre13">model</kbd> property binds to an immutable object, Angular only needs to do a check for changes if the <kbd class="calibre13">model</kbd> reference changes. Otherwise, the complete <kbd class="calibre13">PersonalInfo</kbd> component subtree can be skipped.</p>
<p class="calibre3">By setting the <kbd class="calibre13">PersonalInfo</kbd> component property <kbd class="calibre13">changeDetection</kbd> to <kbd class="calibre13">ChangeDetectionStrategy.OnPush</kbd>, we instruct Angular to trigger change detection only when the component's inputs change.</p>
<p class="calibre3">If we change the change detection strategy to <kbd class="calibre13">OnPush</kbd> for each of the Employee component children and update the employee's personal info, only the <kbd class="calibre13">PersonalInfo</kbd> component subtree is checked for changes:</p>
<div class="packt_figure"><img src="../images/00083.jpeg" class="calibre77"/></div>
<p class="calibre3">For a large component tree, such an optimization will improve the app/view performance many times over.</p>
<div class="packt_infobox">When set to <kbd class="calibre24">OnPush</kbd>, Angular triggers change detection only when the component's input property changes or there is an event raised inside the component or its children.</div>
<p class="calibre3">Developing applications using immutable data structures departs from the standard development paradigm where the application state is totally mutable. What we have highlighted in this section is how Angular takes advantage of immutable data structures to optimize the change detection process.</p>
<p class="calibre3"><em class="calibre17">Observables</em> are another kind of data structure that can help us optimize Angular change detection.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using Observables</h1>
                
            
            <article>
                
<p class="calibre3"><strong class="calibre5">Observables</strong> are data structures that trigger events when their internal state changes. The Angular <em class="calibre17">eventing infrastructure</em> extensively uses <em class="calibre17">Observables</em> to communicate the components' internal state to the outside world.</p>
<p class="calibre3">While we have used Observable output properties (the <kbd class="calibre13">EventEmitter</kbd> class) to raise events, <em class="calibre17">input </em><em class="calibre17">properties</em> too can take Observables. Such observable inputs can help Angular optimize change detection.</p>
<p class="calibre3">When using observables, the change detection switch still remains <kbd class="calibre13">ChangeDetectionStrategy.OnPush</kbd>. But this time, only if a component input triggers an event (as they are observables) will Angular perform the dirty check. When the input triggers an event, the complete component tree path, starting from the affected component to the root, is marked for verification.</p>
<p class="calibre3">When performing the view update, Angular will only sync the affected path and ignore the rest of the tree.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Manual change detection</h1>
                
            
            <article>
                
<p class="calibre3">We can actually disable change detection on a component completely and trigger manual change detection when required. To disable change detection, we just need to inject the component-specific change detector (the <kbd class="calibre13">ChangeDetectorRef</kbd> class instance) into the component and call the <kbd class="calibre13">detach</kbd> function:</p>
<pre class="calibre19">constructor(private ref: ChangeDetectorRef) { 
    ref.detach(); 
} </pre>
<p class="calibre3">Now, the onus is on us to inform Angular when the component should be checked for changes.</p>
<div class="packt_infobox">We can reattach the component to the change detection tree by using the <kbd class="calibre24">reattach</kbd> function on <kbd class="calibre24">ChangeDetectorRef.</kbd></div>
<p class="calibre3">We seldom need to disable the standard change detector setup, unless there are situations where standard change detection becomes an expensive affair.</p>
<p class="calibre3">Take, for example, a public chatroom app, which is receiving messages from thousands of people connected to it. If we constantly keep pulling the messages and refreshing the DOM, the app may become unresponsive. In such a scenario, we can disable change detection on parts of the chat app component tree and manually trigger change detection to update the UI at specific intervals.</p>
<p class="calibre3">While we have seen three ways to tweak change detection behavior, the good thing is that these are not exclusive. Parts of the component tree can use immutable data structures, parts can use Observables, parts can employ manual change detection, and the rest can still use the default change detection. And Angular will happily oblige!</p>
<p class="calibre3">Enough on change detection for now. We may never need it unless we are building some large views with a chatty UI. Such scenarios require us to squeeze every bit of performance out of the change detection system, and the system is ready for it.</p>
<p class="calibre3">Next, we will have a look at another common requirement that most apps invariably have: authenticating their users.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Handling authentication and authorization</h1>
                
            
            <article>
                
<p class="calibre3">Most, if not all, apps have a requirement to authenticate/authorize their users. We may argue that authentication and authorization are more of a server concern than a client one, and that is correct. Still, the client side needs to adapt and integrate with the authentication and authorization requirement imposed by the server.</p>
<p class="calibre3">In a typical app execution workflow, the app first loads some partial views then makes calls to pull data from the server, and finally binds data to its view. Clearly, <em class="calibre17">the views</em> and <em class="calibre17">the remote data API</em> are two assets that need to be secured.</p>
<p class="calibre3">To guard these resources, we need to understand how a typical application is secured on the server. There are primarily two broad approaches to securing any web applications: <em class="calibre17">cookie-based authentication</em> and <em class="calibre17">token-based authentication</em>. Each of them requires different handling on the client part. The next two sections describe how we can integrate with either of these approaches.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Cookie-based authentication</h1>
                
            
            <article>
                
<p class="calibre3">This authentication mechanism is the easiest to implement if the server stack supports it. It's non-intrusive and may require bare minimum changes to the Angular application. <strong class="calibre5">Cookie-based authentication</strong> involves setting the browser cookie to track the user authentication session. The following sequence diagram explains a typical cookie-based authentication workflow:</p>
<div class="packt_figure"><img class="image-border20" src="../images/00084.jpeg"/></div>
<p class="calibre3">Here is how a typical authentication workflow works:</p>
<ul class="calibre11">
<li class="calibre12">When trying to access a secured resource from the browser, if the user is not authenticated, the server sends an HTTP 401 Unauthorized status code. A user request is an unauthorized request if there is no cookie attached to the request or the cookie is expired/invalid.</li>
<li class="calibre12">This unauthorized response is intercepted by the server or, at times, by the client framework (Angular in our case) and it typically results in a 302 redirect (if intercepted by the server). The redirect location is the URL to the login page (the login page allows anonymous access).</li>
<li class="calibre12">The user then enters the username and password on the login page and does a POST to the login endpoint.</li>
<li class="calibre12">The server validates the credentials, sets a browser cookie, and redirects the user to the originally requested resource.</li>
<li class="calibre12">Henceforth, the authentication cookie is a part of every request (added by the browser automatically), and the server uses this cookie to confirm his identity and whether the user is authenticated.</li>
</ul>
<p class="calibre3">As we can see, with this approach, the Angular infrastructure is not involved, or the involvement is minimal. Even the login page can be a standard HTML page that just sends data to the login endpoint for authentication. If the user lands on the Angular app, it implicitly means that the user has been authenticated.</p>
<div class="packt_infobox">The cookie-based authentication flow may vary depending on the server framework, but the general pattern of setting a cookie and attaching a cookie with every subsequent request remains the same.</div>
<p class="calibre3">In a cookie-based application authentication, if the application wants to get the user context, a server endpoint (such as <kbd class="calibre13">/user/details</kbd>) is exposed that returns the logged in user's specific data. The client application can then implement a service such as <kbd class="calibre13">UserService</kbd> that loads and caches the user profile data.</p>
<p class="calibre3">The scenario described here assumes that the API server (the server that returns data) and the site where the application is hosted are in a single domain. That may not<span class="calibre6"> </span><span class="calibre6">always</span><span class="calibre6"> be the case. Even for</span> <em class="calibre17">Personal Trainer</em><span class="calibre6">, the data resides on the</span> <em class="calibre17">MongoLab</em> <span class="calibre6">servers and the application resides on a different server (even if it is local). And we already know that this is a cross-domain access and it comes with its own set of challenges.</span></p>
<p class="calibre3">In such a setup, even if the API server is able to authenticate the request and send a cookie back to the client, the client application still does not send the authentication cookie on a subsequent request.</p>
<p class="calibre3">To fix this, we need to set a variable, <kbd class="calibre13">withCredentials</kbd>, to <kbd class="calibre13">true</kbd> on each XHR request. This can be enabled at the global level by overriding <kbd class="calibre13">BaseRequestOptions</kbd> (the <kbd class="calibre13">withCredentials</kbd> property). The framework uses the <kbd class="calibre13">BaseRequestOptions</kbd> class to set the default values for every HTTP request.</p>
<p class="calibre3">This can also be enabled on a per-request level by passing in the <kbd class="calibre13">withCredentials:true</kbd> flag in each HTTP request method as the last parameter:</p>
<pre class="calibre19">this.httpService.get(url,{withCredentials:true}); </pre>
<p class="calibre3">The last parameter to every HTTP function, including <kbd class="calibre13">get</kbd>, <kbd class="calibre13">post</kbd>, and <kbd class="calibre13">put</kbd>, is an <span class="calibre6"><span class="calibre6">options</span></span> object. This allows us to override the options for the request being made.</p>
<p class="calibre3">Once this flag is enabled, the client browser will start attaching the authentication cookie for the cross-domain requests.</p>
<p class="calibre3">The server too needs to have <strong class="calibre5">cross-origin resource sharing</strong> (<strong class="calibre5">CORS</strong>) enabled and needs to respond in a specific manner for the request to succeed. It should set the <strong class="calibre5">access-control-allow-credentials</strong> header to true and the <strong class="calibre5">access-control-allow-origin</strong> header to the host site making the request.</p>
<div class="packt_infobox"><br class="calibre27"/>
Check out the MDN documentation (<span class="packt_screen"><a href="http://bit.ly/http-cors" class="calibre21">http://bit.ly/http-cors</a></span>) to learn about this scenario in detail.</div>
<p class="calibre3">Cookie-based authentication is definitely less work on the client side, but there are times when you have to revert to token-based access. This could be because:</p>
<ul class="calibre11">
<li class="calibre12">Cookies and cross-domain requests do not play nicely across browsers. Specifically, IE8 and IE9 do not support them.</li>
<li class="calibre12">The server may not support generating cookies, or the server only exposes token-based authentication.</li>
<li class="calibre12">Token-based solutions are easy to integrate with a native mobile application and desktop clients.</li>
<li class="calibre12">Tokens are not susceptible to cross-site request forgery (CSRF) attacks.</li>
</ul>
<div class="packt_infobox"><br class="calibre27"/>
To know more about CSRF, look at the CRSF Prevention cheat sheet at <span class="packt_screen"><a href="http://bit.ly/csrf-cs" class="calibre21">http://bit.ly/csrf-cs</a></span>.</div>
<p class="calibre3">The next section talks about supporting token-based authentication.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Token-based authentication</h1>
                
            
            <article>
                
<p class="calibre3"><strong class="calibre5">Token-based access</strong> is all about sending a token (typically in HTTP headers) with each request instead of a cookie. A simplified token-based workflow looks something like this:</p>
<div class="packt_figure"><img class="image-border21" src="../images/00085.jpeg"/></div>
<p class="calibre3">Many public APIs (such as <em class="calibre17">Facebook</em> and <em class="calibre17">Twitter</em>) use token-based authentication. The format of the token, where it goes, and how it is generated depends on the protocol used and the server implementation. Popular services that use token-based authentication implement the <strong class="calibre5">OAuth 2.0</strong> protocol for token generation and exchange.</p>
<p class="calibre3">In a typical token-based authentication setup, the views are available publicly but the API is secured. If the application tries to pull data through API calls without attaching the appropriate token to the outgoing request, the server returns an <em class="calibre17">HTTP 401 Unauthorized</em> status code.</p>
<p class="calibre3">Enabling token authentication is a good amount of work in Angular. It involves setting up a login page/component, guard conditions, authentication service, and authentication context shared across the application.  If you embark on this journey, make sure to look for Angular libraries/module that makes this integration easier. The <kbd class="calibre13">ngx-auth</kbd> <span class="calibre6">library</span><span class="calibre6"> </span><span class="calibre6">(<a href="http://bit.ly/ngx-auth" target="_blank" class="calibre10">http://bit.ly/ngx-auth</a>) can be a good starting point. </span></p>
<p class="calibre3">That's all about authentication, but what about authorization? Once the user context is established, we still need to make sure that the user is only able to access parts that he/she is allowed to. <em class="calibre17">Authorization</em> is still missing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Handling authorization</h1>
                
            
            <article>
                
<p class="calibre3">Like authentication, authorization support too needs to be implemented on both the server and client side, more so on the server than the client. Remember, anyone can hack into the JavaScript code and circumvent the complete authentication/authorization setup. So, always tighten your server infrastructure irrespective of whether the client has the necessary checks in place or not.</p>
<p class="calibre3">This still does not mean that we do not do any authorization checks on the client. For standard users, this is the first line of defense against unwarranted access.</p>
<p class="calibre3">When working on an authorization requirement for any application, there are three essential elements that are part of the setup:</p>
<ul class="calibre11">
<li class="calibre12">The resources that need to be secured/authorized</li>
<li class="calibre12">A list of roles and users that are part of these roles</li>
<li class="calibre12">A mapping between the resources and the roles that define who can access what</li>
</ul>
<p class="calibre3">From an Angular app perspective, the resources are the pages and, sometimes, sections of pages that need to be restricted to specific roles. If the user is in a specific role, depending upon the role-resource mapping, they get access to some pages; otherwise, they are denied access.</p>
<p class="calibre3">While authorization in an Angular application can be implemented in a number of ways, we will outline a generic implementation that can be further customized to suit your needs in the future.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding authorization support</h1>
                
            
            <article>
                
<p class="calibre3">To enable authorization, the first thing that we need to do is expose the logged in user data, including his/her roles, throughout the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Sharing user authentication context</h1>
                
            
            <article>
                
<p class="calibre3">User context can be shared using an Angular service, which can then be injected into components that require the authorization context. Look at this service interface:</p>
<pre class="calibre19">class SessionContext { 
  currentUser():User { ... }; 
  isUserInRole(roles:Array&lt;string&gt;):boolean { ...}; 
  isAuthenticated:boolean; 
} </pre>
<p class="calibre3">The <kbd class="calibre13">SessionContext</kbd> service tracks the user login session and provides details such as:</p>
<div class="calibre78">
<ul class="calibre11">
<li class="calibre12">The logged in user (<kbd class="calibre13">currentUser</kbd>)</li>
<li class="calibre12">Whether the user is authenticated (<kbd class="calibre13">isAuthenticated</kbd>)</li>
<li class="calibre12">The <kbd class="calibre13">isUserInRole</kbd> function, which returns <kbd class="calibre13">true</kbd> or <kbd class="calibre13">false</kbd> based on whether the user is part of any of the roles passed into the <kbd class="calibre13">roles</kbd> parameter</li>
</ul>
</div>
<p class="calibre3">With such a service in place, we can add authorization for routes, thereby restricting access to some routes to specific roles only.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Restricting routes</h1>
                
            
            <article>
                
<p class="calibre3">Like authentication, the <kbd class="calibre13">canActivate</kbd> guard check can also be used for authorization. Implement a class with the <kbd class="calibre13">CanActivate</kbd> interface and inject the <kbd class="calibre13">SessionContext</kbd> service into the constructor; then, check whether the user belongs to a specific role in the <kbd class="calibre13">canActivate</kbd> function using the <kbd class="calibre13">SessionContext</kbd> service. Check out the following code snippet:</p>
<pre class="calibre19">export class AuthGuard implements CanActivate { 
  constructor(private session:SessionContext) { } 
  canActivate() { 
    return this.session.isAuthenticated &amp;amp;&amp;amp;  
      session.isUserInRole(['Contributor', 'Admin']); 
  } 
} </pre>
<p class="calibre3">Only users with roles of <em class="calibre17">Contributor</em> and <em class="calibre17">Admin</em> now have access to routes that have this guard condition.</p>
<p class="calibre3">But what happens when a page has view elements that are rendered based on the user's role?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Conditionally rendering content based on roles</h1>
                
            
            <article>
                
<p class="calibre3">Conditionally rendering content is easy to implement. We just need to show/hide HTML elements based on the user role. We can build a <em class="calibre17">structural directive</em> such as <kbd class="calibre13">ng-if</kbd> that can verify that the user belongs to a role before rendering the content. The directive's usage looks like:</p>
<pre class="calibre19">&lt;div id='header'&gt; 
    &lt;div&gt; Welcome, {{userName}}&lt;/div&gt; 
    &lt;div&gt;&lt;a href='#/setting/my'&gt;Settings&lt;/a&gt;&lt;/div&gt; 
    <strong class="calibre1">&lt;div *a2beRolesAllowed='["admin"])'&gt;</strong> 
        &lt;a href='#/setting/site'&gt;Site Settings&lt;/a&gt; 
    &lt;/div&gt; 
&lt;/div&gt; </pre>
<p class="calibre3">The preceding code checks whether the user is in an admin role before rendering a <span class="calibre6">Site Setting</span> hyperlink.</p>
<p class="calibre3">The directive implementation mimics how <kbd class="calibre13">ng-if</kbd> works, except that our show/hide logic depends upon the <kbd class="calibre13">SessionContext</kbd> service. Here is a sample implementation for the <kbd class="calibre13">a2beRolesAllowed</kbd> directive:</p>
<pre class="calibre19">@Directive({ selector: '[a2beRolesAllowed]' }) 
export class RolesAllowedDirective { 
  private _prevCondition: boolean = null; 
  constructor(private _viewContainer: ViewContainerRef, 
    private _templateRef: TemplateRef, private SessionContext _session) { } 
 
  @Input() set a2beRolesAllowed(roles: Array&lt;string&gt;) { 
    if (this._session.isUserInRole(roles)) { 
      this._viewContainer 
        .createEmbeddedView(this._templateRef); 
    } 
    else { 
      this._viewContainer.clear(); 
    } 
  } 
} </pre>
<p class="calibre3">This is a trivial implementation that uses <kbd class="calibre13">SessionContext</kbd> and the roles passed as input (<kbd class="calibre13">a2beRolesAllowed</kbd>) to show/hide a fragment.</p>
<p class="calibre3">This brings us to the end of authentication and authorization implementation. The reference implementation walkthrough should help us build authentication and authorization into our apps. With this basic understanding in place, any setup can be tweaked to handle other custom authentication/authorization scenarios.</p>
<p class="calibre3">It's now time to address the elephant in the room: migrating from <em class="calibre17">AngularJS</em> to <em class="calibre17">Angular</em>. If you are starting afresh on Angular, you can very well skip the next section.</p>
<div class="packt_infobox"><br class="calibre27"/>
From the Angular's migration guide <em class="calibre31">"Angular is the name for the Angular of today and tomorrow. AngularJS is the name for all v1.x versions of Angular.</em>"</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Migrating AngularJS apps</h1>
                
            
            <article>
                
<p class="calibre3">If you have been working extensively on AngularJS, Angular poses some pertinent questions:</p>
<ul class="calibre11">
<li class="calibre12">Should I migrate my old AngularJS apps to the latest Angular version?</li>
<li class="calibre12">When should the migration happen?</li>
<li class="calibre12">Is the migration one-shot or can it be done in an incremental fashion?</li>
<li class="calibre12">What is the effort involved?</li>
<li class="calibre12">Can I do something today that helps with the migration in the future?</li>
<li class="calibre12">I am starting a new AngularJS app today. What should I do to make the migration seamless in the future?</li>
</ul>
<p class="calibre3">Every such query needs to be addressed to make sure the transition is as smooth as possible. No one likes surprises later in the game! In the coming sections, we will try to answer a number of such questions. As part of the learning, we will also walk you through migrating the AngularJS version of the <em class="calibre17">Trainer</em> app (developed for the first version of this book) to Angular. This will help everyone make some informed decisions on when and how to migrate to Angular.</p>
<p class="calibre3">"Should I migrate or not" is something that we will address first.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Should I migrate?</h1>
                
            
            <article>
                
<p class="calibre3">Just because Angular is here doesn't mean AngularJS is gone. AngularJS is still being developed, albeit not at the same pace as Angular. Google is still committed to supporting AngularJS for a good amount of time. The AngularJS team is working on version 1.7 currently and plan to release it before June 2018. After that, 1.7 will enter the <strong class="calibre5">Long Term Support</strong> (<strong class="calibre5">LTS</strong>) period, where the focus will only be on bug fixes.  We can learn more about it from their blog post at <a href="http://bit.ly/ng1-lte-support" class="calibre10">http://bit.ly/ng1-lte-support</a>.</p>
<p class="calibre3">Clearly, AngularJS will continue to be supported and hence should not be a major concern for migration. The move to Angular can be decided based on what Angular has to offer over its predecessor.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Advantages of Angular</h1>
                
            
            <article>
                
<p class="calibre3">Angular is designed for the future and overcomes a number of shortcomings in its predecessor. In this section, we emphasize what makes Angular a better framework than AngularJS.</p>
<p class="calibre3">Things you should be aware of while making a decision to move to Angular:</p>
<p class="calibre79"/>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Better behavioral encapsulation</strong>: Admittedly, while AngularJS <em class="calibre2">scopes</em> seem to be god sent when we started learning AngularJS, we have now realized how difficult it is to manage the hierarchical nature of scopes. Component-based development in Angular provides a better encapsulation in terms of the state of the application. A component manages its own state, takes input, and raises events; a clear demarcation of responsibilities that are easy to reason with!</li>
<li class="calibre12"><strong class="calibre1">Less of the framework in app code</strong>: You don't need special objects such as a <em class="calibre2">scope.</em> DI works with annotation (in TypeScript). You don't set up watches. All in all, when reading a component code, you will not find framework-level constructs in it.</li>
<li class="calibre12"><strong class="calibre1">Smaller framework API to explore</strong>: AngularJS had a host of directives that one had to be aware of. With Angular template syntax, directives related to browser events are gone. This reduces the number of directives that one needs to be aware of.</li>
<li class="calibre12"><strong class="calibre1">Performance</strong>: Angular is faster compared to its predecessor. A complete section of this book was dedicated to understanding what makes Angular a high-performance framework.</li>
<li class="calibre12"><strong class="calibre1">Mobile-friendly</strong>: Angular tries to optimize the user's mobile experience by utilizing technologies such as server-side rendering and web workers. Angular applications on mobile are more performant that those of its predecessor.</li>
<li class="calibre12"><strong class="calibre1">Cross-platform</strong>: Angular targets running on most devices and across platforms. You can use Angular to build applications for web and mobile. As we learned earlier, the separation of the rendering layer has open up a great number of possibilities in terms of where Angular can be utilized.</li>
</ul>
<p class="calibre3">In a true sense, Angular supersedes its predecessor, and in a perfect world, everyone should be working on a better framework/technology. But migration is never easy, especially in this case, where the two frameworks differ a lot. </p>
<p class="calibre3">What we recommend is even if you do not plan to migrate to Angular today, build your AngularJS apps in ways that allow easy migration to Angular in future.</p>
<p class="calibre3">The next section talks about the principles and practices to follow for AngularJS today, allowing easy migration in the future.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Developing AngularJS apps today for easy migration</h1>
                
            
            <article>
                
<p class="calibre3">The new Angular is a paradigm shift and the way we develop components in Angular is quite different from AngularJS. For easy migration, Angular too should embrace component-based development. This can be achieved if we follow some guidelines/principles while building AngularJS apps. The next few sections detail these guidelines.</p>
<div class="packt_tip">The advice listed here is highly recommended even if you do not plan to migrate to Angular. These recommendation bits will make AngularJS code more modular, organized, and testable.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">One component per file</h1>
                
            
            <article>
                
<p class="calibre3">This can be anything: an AngularJS <em class="calibre17">controller</em>, <em class="calibre17">directive</em>, <em class="calibre17">filter</em>, or <em class="calibre17">service</em>. One component per file allows better organization of code and easy migration, allowing us to clearly identify how much progress has been made.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Avoiding inline anonymous functions</h1>
                
            
            <article>
                
<p class="calibre3">Use named functions instead to declare controllers, directives, filters, and services. A declaration such as this:</p>
<pre class="calibre19">angular.module('7minWorkout') 
  .controller('WorkoutController',[...]) 
 
angular.module('app') 
.directive('remoteValidator', [...]) 
 
angular.module('7minWorkout') 
.filter('secondsToTime', function () { ... } 
 
angular.module('7minWorkout') 
.factory('workoutHistoryTracker', [...]) </pre>
<p class="calibre3">Should be converted to this:</p>
<pre class="calibre19">function WorkoutController($scope, ...) { ... } 
WorkoutController.$inject = ['$scope', ...]; 
 
function remoteValidator($parse) {...} 
remoteValidator.$inject=[$parse]; 
 
function secondsToTime() {...} 
 
function workoutHistoryTracker($rootScope, ...) { ...} 
workoutHistoryTracker.$inject = ['$rootScope',...]; </pre>
<p class="calibre3">The advantages of using named functions are ease of debugging and ease of migration to TypeScript. Using named functions also requires that the dependencies be registered using the <kbd class="calibre13">$inject</kbd> function property.</p>
<div class="packt_infobox"><kbd class="calibre24">$inject</kbd>-based dependency declaration safeguards against minification and adds to the readability of the functions.</div>
<p class="calibre3">To avoid exposing global name functions with this approach, it is advisable to wrap the function in an <strong class="calibre5">Immediately Invoked Function Expression</strong> (<strong class="calibre5">IIFE</strong>):</p>
<pre class="calibre19">(function() { 
    function WorkoutController($scope, ...) { ... } 
    WorkoutController.$inject = ['$scope', ...]; 
<br class="title-page-name"/>    angular 
        .module('7minWorkout') 
        .controller('WorkoutController', WorkoutController); 
 
})(); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Avoiding $scope!</h1>
                
            
            <article>
                
<p class="calibre3">Yes, you read it right; avoid the <kbd class="calibre13">$scope</kbd>/<kbd class="calibre13">$rootScope</kbd> object or using scopes directly!</p>
<p class="calibre3">The biggest problem with AngularJS scopes is their hierarchical nature. Accessing the parent scope from the child scope gives us tremendous flexibility, but it comes at a cost. This can unknowingly create unwarranted dependencies that make the app really hard to debug and, of course, migrate. In contrast, in Angular, a view is bound to its component implementation and cannot access data outside its boundary implicitly. Therefore, if you plan to migrate to Angular, <em class="calibre17">avoid scopes at all costs</em>.</p>
<p class="calibre3">There are a number of techniques that can be used to remove the <kbd class="calibre13">$scope</kbd> object dependency. The next few subsections elaborate on some techniques that can help us avoid AngularJS scopes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using controller as (controller aliasing) syntax everywhere</h1>
                
            
            <article>
                
<p class="calibre3">AngularJS 1.3+ has the <em class="calibre17">controller as</em> syntax for <em class="calibre17">controllers</em>, <em class="calibre17">directives</em>, and <em class="calibre17">routes</em>. <em class="calibre17">controller as</em> syntax allows AngularJS data binding expressions to work against a controller's instance properties instead of the current <em class="calibre17">scope</em>'s object properties. With the controller as paradigm in place, we never need to interact with the scope directly, and hence future migration becomes easy.</p>
<div class="packt_infobox"><br class="calibre27"/>
While controller aliasing gets rid of scope access, scopes are still there in AngularJS. The complete AngularJS data binding infrastructure depends upon scopes. Controller aliasing just puts an indirection between our code and scope access.</div>
<p class="calibre3">Consider the following syntax for <em class="calibre17">controller as</em> in views:</p>
<pre class="calibre19"><strong class="calibre1">&lt;div ng-controller="WorkoutListController as workoutList"&gt;</strong> 
   &lt;a ng-repeat="workout in workoutList.workouts"  href="#/workout/{{workout.name}}"&gt; 
&lt;/div&gt; </pre>
<p class="calibre3">And the corresponding controller implementation:</p>
<pre class="calibre19">function WorkoutListController($scope, ...) { 
  this.workouts=[]; 
} </pre>
<p class="calibre3"><kbd class="calibre13">WorkoutListController</kbd> as <kbd class="calibre13">workoutList</kbd> creates an alias <kbd class="calibre13">workoutList</kbd> for <kbd class="calibre13">WorkoutListController</kbd> on the current scope, hence allowing us to bind to the <kbd class="calibre13">workouts</kbd> property defined on the controller.</p>
<p class="calibre3">Route definition too allows controller aliasing using the <kbd class="calibre13">controllerAs</kbd> property in a <em class="calibre17">route definition object</em>:</p>
<pre class="calibre19">$routeProvider.when('/builder/workouts', { 
... 
   controller: 'WorkoutListController', 
<strong class="calibre1">   controllerAs: 'workoutList'</strong> 
 }); </pre>
<p class="calibre3">Finally, directives too can use <kbd class="calibre13">controllerAs</kbd>, and together with the <kbd class="calibre13">bindToController</kbd> property on the <em class="calibre17">directive definition object</em>, we can get rid of any direct scope access.</p>
<div class="packt_infobox">Look at the Angular documentation on controllers, routes, and directives to get a basic understanding of the controller as syntax. Also, look at the following posts for some more detailed samples on this topic: <span class="packt_screen"><a href="http://bit.ly/ng1-controller-as" class="calibre21">http://bit.ly/ng1-controller-as</a></span> and <span class="packt_screen"><a href="http://bit.ly/ng1-bind-to" class="calibre21">http://bit.ly/ng1-bind-to</a>.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Avoiding ng-controller</h1>
                
            
            <article>
                
<p class="calibre3">If scopes can be avoided, so can controllers!</p>
<p class="calibre3">This may again seem counterintuitive, but the approach has real benefits. What we ideally want to do is emulate component behavior in AngularJS. Since the closest thing to components in AngularJS is <em class="calibre17">element directives</em> (with <kbd class="calibre13">restrict='E'</kbd>), we should utilize <em class="calibre17">element directives</em> everywhere.</p>
<p class="calibre3">An AngularJS element directive with its own template and isolated scope can very well behave like an Angular component and only be dependent on its internal state for its view binding. We just don't need <kbd class="calibre13">ng-controller</kbd>.</p>
<p class="calibre3">Consider the use of <kbd class="calibre13">ng-controller</kbd> for audio tracking from the AngularJS version of the <em class="calibre17">Personal Trainer</em> app:</p>
<pre class="calibre19">&lt;div id="exercise-pane" class="col-sm-7"&gt; 
... 
  &lt;span ng-controller="WorkoutAudioController"&gt; 
    &lt;audio media-player="ticksAudio" loop autoplay src="content/tick10s.mp3"&gt;&lt;/audio&gt; 
    &lt;audio media-player="nextUpAudio"  src="content/nextup.mp3"&gt;&lt;/audio&gt; 
    ... 
  &lt;/span&gt;</pre>
<p class="calibre3">Instead of using <kbd class="calibre13">WorkoutAudioController</kbd>, an element directive can encapsulate the workout audio's view and behavior. Such a directive can then replace the complete <kbd class="calibre13">ng-controller</kbd> declaration and its view:</p>
<pre class="calibre19">&lt;div id="exercise-pane" class="col-sm-7"&gt; 
... 
&lt;workout-audio-component&gt;&lt;/workout-audio-component&gt; </pre>
<p class="calibre3">When replacing <kbd class="calibre13">ng-controller</kbd> with an element directive, the scope variables that the controller depends upon should be passed to the directive using the <kbd class="calibre13">bindToController</kbd> property on the <em class="calibre17">directive definition object—</em>something like this:</p>
<pre class="calibre19">bindToController: { 
   name: '=', 
   title: '&amp;amp;' 
} </pre>
<div class="packt_infobox"><br class="calibre27"/>
This topic has been extensively covered in these two blogs posts by Tero: <a href="http://bit.ly/ng2-no-controllers" class="calibre21">http://bit.ly/ng2-no-controllers</a> and <a href="http://bit.ly/ng2-refactor-to-component" class="calibre21">http://bit.ly/ng2-refactor-to-component</a>. Must-read posts with a wealth of information!</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Building using the AngularJS 1.5+ component API</h1>
                
            
            <article>
                
<p class="calibre3">AngularJS 1.5+ has a <strong class="calibre5">component API</strong> that allows us to create directives that can be easily migrated to Angular. The component API is preconfigured with sensible defaults, hence incorporating the best practices when it comes to building truly isolated and reusable directives.</p>
<p class="calibre3">Look at the component API at <span class="calibre6"><a href="http://bit.ly/ng1-dev-guide-components" class="calibre10">http://bit.ly/ng1-dev-guide-components</a></span> and this informative post by Tod Motto at <span class="calibre6"><a href="http://bit.ly/1MahwNs" class="calibre10">http://bit.ly/1MahwNs</a></span> to learn about the component API.</p>
<p class="calibre3">To reiterate what has been emphasized earlier, these steps are not just targeted towards easy Angular migration but also towards making AngularJS code better. Component-based UI development is a better paradigm than what we are used to with AngularJS.</p>
<div class="packt_tip">We highly recommend that you go through the AngularJS style guide (<a href="http://bit.ly/ng1-style-guide" class="calibre21">http://bit.ly/ng1-style-guide</a>). This guide contains a wealth of tips/patterns that allow us to build better AngularJS apps, and is in sync with the guidelines provided previously for easy Angular migration.</div>
<p class="calibre3">Finally, if we have decided to migrate, it's time to decide what to migrate.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What to migrate?</h1>
                
            
            <article>
                
<p class="calibre3">For an app in maintenance mode, where most of the development activity revolves around bug fixes and some enhancements, it would be prudent to stick to AngularJS. Remember the old saying <em class="calibre17">if it ain't broke, don't fix it</em>.</p>
<p class="calibre3">If the app is being actively developed and has a clear long-term roadmap, migrating to Angular is worth considering. As we dig deeper into the intricacies of migration, we will realize the time and effort involved in the process. While the Angular team has worked really hard to make this migration smooth, by no stretch of the imagination is this a trivial job. It is going to take a good amount of time and effort to perform the actual migration.</p>
<p class="calibre3">The silver lining here is that we do not need to migrate everything at once. We can work slowly towards migrating parts of the AngularJS code base to Angular. Both the frameworks can coexist and can depend on each other too. This also allows us to develop new parts of applications in Angular. How cool is that?</p>
<p class="calibre3">But again, this flexibility comes at a cost—the cost of bytes. As both frameworks are downloaded, the page bytes do increase, something that we should be aware of.</p>
<p class="calibre3">Also, while the coexistence of both the frameworks allows us to migrate without much disruption, we cannot make it a perpetual activity. Eventually, AngularJS has to go, and the sooner it does the better.</p>
<p class="calibre3">During migration, the best thing that can be done is to carve out new SPAs within the existing application. For example, we can build the Admin area of an app entirely using Angular, with a separate host page, but still share the common infrastructure of style sheets, images, and even AngularJS services if we refactor the code a bit. As we will learn later, migrating services to Angular is the easiest.</p>
<p class="calibre3">Breaking an application into multiple smaller ones introduces full-page refreshes, but this is a cleaner approach when it comes to migration.</p>
<p class="calibre3">Taking all of this into consideration, if we have decided to migrate and identified areas of migration, you need to do the prep work for migration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Preparing for Angular migration</h1>
                
            
            <article>
                
<p class="calibre3">Welcome to the big brave world of Angular migration! A successful migration strategy involves making sure that we do the groundwork beforehand, avoiding any late surprises.</p>
<p class="calibre3">As prep work, the first step is to analyze the application from a third-party library dependency perspective.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Identifying third-party dependencies</h1>
                
            
            <article>
                
<p class="calibre3">Any third-party library that an AngularJS app uses needs a migration strategy too. These could be either jQuery-based libraries or AngularJS libraries.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">jQuery libraries</h1>
                
            
            <article>
                
<p class="calibre3">jQuery libraries in AngularJS were consumed by creating a directive wrapper over them. We will have to migrate such directives to Angular.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">AngularJS libraries</h1>
                
            
            <article>
                
<p class="calibre3">Migrating AngularJS libraries is a bit of a tricky affair. AngularJS has a massive ecosystem, and Angular too has been around for some time and now has a healthy community. When migrating, each AngularJS library needs to be substituted with an Angular alternative.</p>
<p class="calibre3">If we do not find a perfect upgrade path for a specific library, we can either:</p>
<ul class="calibre11">
<li class="calibre12"><span>Customize a similar component/library available out there</span></li>
<li class="calibre12">Take the more radical approach of building our own library from the ground up in Angular</li>
</ul>
<p class="calibre3">Each of these choices has trade-offs in terms of time and complexity.</p>
<p class="calibre3">Another choice that needs to be made is the development language. Should we use TypeScript, ES2015, or plain old JavaScript (ES5)?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Choice of language</h1>
                
            
            <article>
                
<p class="calibre3">We would definitely recommend TypeScript. It's a super awesome language that integrates very well with Angular and vastly reduces the verbosity of Angular declarations. Also, given that it can coexist with JavaScript, it makes our lives easier. Even without Angular, TypeScript is one language that we should embrace for the web platform.</p>
<p class="calibre3">In the coming sections, we will migrate the AngularJS <em class="calibre17">Personal Trainer</em> app to Angular. The app is currently available on <em class="calibre17">GitHub</em> at <span class="calibre6"><a href="http://bit.ly/a1begit" class="calibre10">http://bit.ly/a1begit</a></span>. This app was part of the first version of this book, <em class="calibre17">AngularJS by Example</em>, and was built using JavaScript.</p>
<div class="packt_infobox">We are again going to follow the checkpoint-based approach for this migration. The checkpoints that we highlight during the migration have been implemented as GitHub branches. Since we will be interacting with a <em class="calibre31">Git</em> repository for v1 code and using <em class="calibre31">Node.js</em> tools for the build, please set up Git and Node.js on your development box before proceeding further.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Migrating AngularJS's Personal Trainer</h1>
                
            
            <article>
                
<p class="calibre3">Before we even begin the migration process, we need to set up the v1 <em class="calibre17">Personal Trainer</em> locally.</p>
<p class="calibre3">The code for the migrated app can be downloaded from the GitHub site at <a href="https://github.com/chandermani/angularjsbyexample" class="calibre10">https://github.com/chandermani/angularjsbyexample</a>. Since we migrate in chunks, we have created multiple checkpoints that map to <strong class="calibre5">GitHub branches</strong> dedicated to migration. Branches such as <kbd class="calibre13">ng6-checkpoint8.1</kbd>, <kbd class="calibre13">ng6-checkpoint8.2</kbd>, and so on highlight this progression. During the narration, we will highlight the branch for reference. These branches will contain the work done on the app up to that point in time.</p>
<div class="packt_infobox"><br class="calibre27"/>
The <em class="calibre31">7 Minute Workout</em> code is available inside the repository folder named <kbd class="calibre24">trainer</kbd>.</div>
<p class="calibre3">So, let's get started!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Setting up AngularJS's Personal Trainer locally</h1>
                
            
            <article>
                
<p class="calibre3">Follow these steps and you will be up and running in no time:</p>
<ol class="calibre14">
<li value="1" class="calibre12">From the command line, clone the v1 GitHub repository:</li>
</ol>
<pre class="calibre19">    <strong class="calibre1">git clone https://github.com/chandermani/angularjsbyexample.git</strong></pre>
<ol start="2" class="calibre14">
<li value="2" class="calibre12">Navigate to the new Git repo and check out the <kbd class="calibre13">ng6-base</kbd> branch to get started:</li>
</ol>
<pre class="calibre19">    <strong class="calibre1">cd angularjsbyexample</strong>
    <strong class="calibre1">git checkout ng6-base</strong></pre>
<ol start="3" class="calibre14">
<li value="3" class="calibre12">Since the app loads its workout data from <strong class="calibre1">MongoDB</strong> hosted in <strong class="calibre1">mLab </strong>(<span><a href="https://mlab.com/" class="calibre10">https://mlab.com/</a></span>), you need an mLab account to host workout-related data. Set up an mLab account by signing up with them. Once you have an mLab account, you need to retrieve your API key from mLab's management portal. Follow the instructions provided in the API documentation (<span><a href="http://bit.ly/mlab-docs" class="calibre10">http://bit.ly/mlab-docs</a></span>) to get your API key.</li>
</ol>
<ol start="4" class="calibre14">
<li value="4" class="calibre12">Once you have the API key, update this line in <kbd class="calibre13">app/js/config.js</kbd> with your API key:</li>
</ol>
<pre class="calibre19">   ApiKeyAppenderInterceptorProvider.setApiKey("&lt;<strong class="calibre1">yourapikey</strong>&gt;"); </pre>
<ol start="5" class="calibre14">
<li value="5" class="calibre12">And add some seed workout data into your mLab instance. The instructions to add the seed data into mLab are available in the source code file, <kbd class="calibre13">app/js/seed.js</kbd>.</li>
<li value="6" class="calibre12">Next, install the necessary <em class="calibre2">npm packages</em> required for v1 <em class="calibre2">Personal Trainer</em>:</li>
</ol>
<pre class="calibre19">    <strong class="calibre1">cd trainer/app</strong>
    <strong class="calibre1">npm install</strong></pre>
<ol start="7" class="calibre14">
<li value="7" class="calibre12">Install <kbd class="calibre13">http-server</kbd>; it will act as a development server for our v1 app:</li>
</ol>
<pre class="calibre18"><strong class="calibre1">npm i http-server -g</strong></pre>
<p class="calibre3">Verify that the setup is complete by starting the <kbd class="calibre13">http-server</kbd> from the <kbd class="calibre13">app</kbd> folder:</p>
<pre class="calibre19">    <strong class="calibre1">http-server -c-1</strong></pre>
<p class="calibre3">And open the browser location <kbd class="calibre13">http://localhost:8080</kbd>.</p>
<p class="calibre3">The v1 <em class="calibre17">Personal Trainer</em> start page should show up. Play around with the app to verify that the app is working fine. Now, the migration can begin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Identifying dependencies</h1>
                
            
            <article>
                
<p class="calibre3">The first step before we begin migrating v1 <em class="calibre17">Personal Trainer</em> is to identify the external libraries that we are using in the AngularJS version of Personal Trainer.</p>
<p class="calibre3">The external libraries that we are using in v1 are:</p>
<div class="calibre78">
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">angular-media-player</kbd></li>
<li class="calibre12"><kbd class="calibre13">angular-local-storage</kbd></li>
<li class="calibre12"><kbd class="calibre13">angular-translate</kbd></li>
<li class="calibre12"><kbd class="calibre13">angular-ui-bootstrap</kbd></li>
<li class="calibre12"><kbd class="calibre13">owl. carousel</kbd></li>
</ul>
</div>
<p class="calibre3">Libraries such as <kbd class="calibre13">angular-media-player</kbd> and <kbd class="calibre13">angular-local-storage</kbd> are easy to migrate/replace. We have already done this in earlier chapters of this book.</p>
<p class="calibre3">The <kbd class="calibre13">angular-translate</kbd> library can be replaced with <kbd class="calibre13">ngx-translate</kbd>, and as we will see in the coming sections, it is not a very challenging task.</p>
<p class="calibre3">We use <kbd class="calibre13">angular-ui-bootstrap</kbd> for <strong class="calibre5">modal dialogs</strong> in <em class="calibre17">Personal Trainer v1</em>. We replace it with <kbd class="calibre13">ngx-modialog</kbd> (<a href="http://bit.ly/ngx-modialog" class="calibre10">http://bit.ly/ngx-modialog</a>) as the only control we were using from <kbd class="calibre13">angular-ui-bootstrap</kbd> was the dialog control.</p>
<p class="calibre3">Now that we have sorted out the external dependencies, let's decide the language to use.</p>
<p class="calibre3">While the existing code base is JavaScript, we love TypeScript. Its type safety, its terse syntax, and how well it plays with Angular makes it our language of choice. Hence, it's going to be TypeScript all the way.</p>
<p class="calibre3">Another thing that tilts the decision in favor of TypeScript is that we do not need to migrate the existing code base to TypeScript. Anything we migrate/build new, we build it in TypeScript. Legacy code still remains in JavaScript.</p>
<p class="calibre3">Let's start. As a first migration task, we need to set up a module loader for our v1 Personal Trainer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Setting up the module loader</h1>
                
            
            <article>
                
<p class="calibre3">Since we are going to create a number of new Angular components spread across numerous small files, adding direct script reference is going to be tedious and error-prone. Angular CLI also is not of much help here as it cannot manage the existing codebase implemented in JavaScript.</p>
<p class="calibre3">We need a <strong class="calibre5">module loader</strong>. A module loader (<em class="calibre17">ES6 modules</em> and not Angular) can help us with:</p>
<ul class="calibre11">
<li class="calibre12">Creating isolated/reusable modules based on some common module formats</li>
<li class="calibre12">Managing the script loading order based on dependencies</li>
<li class="calibre12">Allowing bundling/packaging of a module and on-demand loading for dev/production deployments</li>
</ul>
<p class="calibre3">We use the <strong class="calibre5">SystemJS</strong> module loader for this migration.</p>
<p class="calibre3">Install SystemJS from the command line using:</p>
<pre class="calibre19"><strong class="calibre1">npm i systemjs --save</strong></pre>
<div class="packt_infobox"><br class="calibre27"/>
All the commands need to be executed from the <kbd class="calibre24">trainer/app</kbd> folder.</div>
<p class="calibre3">We open <kbd class="calibre13">index.html</kbd> and remove all the script references of our app scripts. All script references with the source as <kbd class="calibre13">src='js/*.*'</kbd> should be removed, except <kbd class="calibre13">angular-media-player.js</kbd> and <kbd class="calibre13">angular-local-storage.js</kbd>, as they are external libraries.</p>
<div class="packt_infobox"><br class="calibre27"/>
Note: We are not removing script references for third-party libraries, but only app files.</div>
<p class="calibre3">Add SystemJS configurations after all third-party script references:</p>
<pre class="calibre19">&lt;script src="js/vendor/angular-local-storage.js"&lt;/script&gt; 
<strong class="calibre1">&lt;script src="node_modules/systemjs/dist/system.src.js"&gt;</strong>
<strong class="calibre1">&lt;/script&gt;</strong>
<strong class="calibre1">&lt;script&gt;</strong>
<strong class="calibre1">  System.config({ packages: {'js': {defaultExtension: 'js'}}});</strong>
<strong class="calibre1">  System.import('js/app.js');</strong>
<strong class="calibre1">&lt;/script&gt;</strong></pre>
<p class="calibre3">Remove the <kbd class="calibre13">ng-app</kbd> attribute on the <kbd class="calibre13">body</kbd> tag, keeping the <kbd class="calibre13">ng-controller</kbd> declaration intact:</p>
<pre class="calibre19">&lt;body ng-controller="RootController"&gt;</pre>
<p class="calibre3">The <kbd class="calibre13">ng-app</kbd> way of bootstrapping has to go as we switch to the <kbd class="calibre13">angular.bootstrap</kbd> function for manual bootstrapping. Manual bootstrapping helps when we bring Angular into the mix.</p>
<p class="calibre3">The preceding <kbd class="calibre13">SystemJS.import</kbd> call loads the application by loading the first app module (JavaScript) defined in <kbd class="calibre13">js/app.js</kbd>. We are going to define this JavaScript module shortly.</p>
<p class="calibre3">Create a new file called <kbd class="calibre13">app.module.js</kbd> in the same folder as <kbd class="calibre13">app.js</kbd> and copy the complete contents of <kbd class="calibre13">app.js</kbd> into <kbd class="calibre13">app.module.js</kbd>.</p>
<div class="packt_infobox"><br class="calibre27"/>
Remember to get rid of the <kbd class="calibre24">use strict</kbd> statement. The TypeScript compiler does not like it.</div>
<p class="calibre3">All the app module definitions are now in <kbd class="calibre13">app.module.js</kbd>.</p>
<p class="calibre3">Next, clear <kbd class="calibre13">app.js</kbd> and add the following imports and bootstrap code:</p>
<pre class="calibre19"><strong class="calibre1">import  './app.module.js';</strong> 
import  './config.js'; 
import  './root.js'; 
import './shared/directives.js'; 
import './shared/model.js'; 
import './shared/services.js'; 
import './7MinWorkout/services.js'; 
import './7MinWorkout/directives.js'; 
import './7MinWorkout/filters.js'; 
import './7MinWorkout/workout.js'; 
import './7MinWorkout/workoutvideos.js'; 
import './WorkoutBuilder/services.js'; 
import './WorkoutBuilder/directives.js'; 
import './WorkoutBuilder/exercise.js'; 
import './WorkoutBuilder/workout.js'; <br class="title-page-name"/><br class="title-page-name"/>import * as angular from "angular";
 
angular.element(document).ready(function() { 
  angular.bootstrap(document.body, ['app'],  
{ strictDi: true }); 
});</pre>
<p class="calibre3">We have added <em class="calibre17">ES6 import statements</em> to <kbd class="calibre13">app.js</kbd>. These are the same scripts that were earlier referenced in <kbd class="calibre13">index.html</kbd>. SystemJS now loads these script files when loading <kbd class="calibre13">app.js</kbd>.</p>
<p class="calibre3">Moving all of the AngularJS module declarations into a new file, <kbd class="calibre13">app.module.js</kbd>, and importing it first into <kbd class="calibre13">app.js</kbd> makes sure that the AngularJS modules are defined before any of the <kbd class="calibre13">import</kbd> statements are executed.</p>
<div class="packt_tip">Do not confuse <em class="calibre31">ES6 modules</em> and <em class="calibre31">AngularJS modules</em> defined/accessed using <kbd class="calibre24">angular.module('name')</kbd>. These two are altogether different concepts.</div>
<p class="calibre3">The last few lines bootstrap the AngularJS application using the <kbd class="calibre13">angular.bootstrap</kbd> function.</p>
<p class="calibre3">Module loading is enabled now; let's enable TypeScript too.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Enabling TypeScript</h1>
                
            
            <article>
                
<p class="calibre3">To enable TypeScript, install the TypeScript compiler using <em class="calibre17">npm</em>:</p>
<pre class="calibre19"><strong class="calibre1">npm i typescript -g</strong></pre>
<p class="calibre3">Next, open <kbd class="calibre13">package.json</kbd> and add these lines inside the script configuration:</p>
<pre class="calibre19">"scripts": { 
    "test": "echo "Error: no test specified" &amp;amp;&amp;amp; exit 1" 
<strong class="calibre1">    "tsc": "tsc -p . -w"</strong>
  } </pre>
<div class="packt_infobox"><br class="calibre27"/>
The new script's properties that we just added provide a shortcut for commonly executed commands.</div>
<p class="calibre3">To enable IDE IntelliSense for JavaScript libraries, we need to install their type definitions. <strong class="calibre5">Type definitions</strong> or <strong class="calibre5">typings</strong> are files that define the public interface for a TypeScript/JavaScript library. These type definitions help IDEs provide <span class="calibre6">IntelliSense </span>around the library functions. Typings are available for most of the popular JavaScript libraries and for frameworks/libraries written in TypeScript.</p>
<p class="calibre3">Let's install typings for the libraries we use. From the command line, execute:</p>
<pre class="calibre19"><strong class="calibre1">npm install @types/angular @types/angular-route @types/angular-resource @types/angular-mocks  --save-dev</strong></pre>
<p class="calibre3">Next, copy <kbd class="calibre13">overrides.d.ts</kbd> from <kbd class="calibre13">checkpoint8.1</kbd> to the local <kbd class="calibre13">app</kbd> folder. This helps TypeScript compiler to handle the global <kbd class="calibre13">angular</kbd> object used in <kbd class="calibre13">app.js</kbd> and other places.</p>
<p class="calibre3">We now need to set up some configurations for the TypeScript compiler. Create a file called <kbd class="calibre13">tsconfig.json</kbd> (in the <kbd class="calibre13">trainer/app</kbd> folder) and copy the configuration from the <kbd class="calibre13">ng6-checkpoint8.1</kbd> repo branch (also available remotely at <span class="calibre6"><a href="http://bit.ly/ng2be-8-1-tsconfig" class="calibre10">http://bit.ly/ng6be-8-1-tsconfig</a></span>). Run the compiler using:</p>
<pre class="calibre19"><strong class="calibre1">npm run tsc</strong></pre>
<p class="calibre3">This should start the TypeScript compiler, and there should be no errors reported.</p>
<div class="packt_infobox"><br class="calibre27"/>
Keep this command running in a separate console window at all times during development. The compiler will continuously watch for changes to the TypeScript file and rebuild the code if changes are detected.</div>
<p class="calibre3">Change the extension of the <kbd class="calibre13">app.js</kbd> and <kbd class="calibre13">app.module.js</kbd> files to <kbd class="calibre13">app.ts</kbd> and <kbd class="calibre13">app.module.ts</kbd>. The TypeScript compiler detects these changes and compiles the TypeScript files. After compilation, the compiler produces two files for each TypeScript file. One is the compiled JavaScript file (such as <kbd class="calibre13">app.js</kbd>) and the other is a map file (<kbd class="calibre13">app.js.map</kbd>) for debugging purposes.</p>
<div class="packt_infobox"><br class="calibre27"/>
We have not set up an elaborate build for this exercise as our primary focus is on migration. For your own apps, the initial setup steps may vary depending upon how the build is already set up.</div>
<p class="calibre3">Before we test our new changes, <kbd class="calibre13">config.js</kbd> needs to be fixed because we have enabled strict DI check-in AngularJS through:</p>
<pre class="calibre19">  angular.bootstrap(document.body, ['app'],  <strong class="calibre1">{ strictDi: true });</strong></pre>
<p class="calibre3">Replace the <kbd class="calibre13">config.js</kbd> content with updated content available in <kbd class="calibre13">ng6-checkpoint8.1</kbd> or at <a href="http://bit.ly/ng2be-8-1-configjs" class="calibre10">http://bit.ly/ng6be-8-1-configjs</a> (and remember to set the API key again). The update fixes the <kbd class="calibre13">config</kbd> function and makes it minification-friendly. Time to test the app!</p>
<p class="calibre3">Make sure the TypeScript compiler is running in one console; run <kbd class="calibre13">http-server -c-1</kbd> in a new console window.</p>
<p class="calibre3">Navigate to <kbd class="calibre13">http://localhost:8080</kbd> the app start page should load.</p>
<p class="calibre3">Commit/save your local changes.</p>
<div class="packt_tip">If things work fine, you can even commit your local changes to your git repo. This will help you track what has changed over time as we migrate the app piece by piece. The implementation till this point is available in the <kbd class="calibre24">ng6-checkpoint8.1</kbd> GitHub branch. If you are facing problems, compare the <kbd class="calibre24">ng6-base</kbd> and <kbd class="calibre24">ng6-checkpoint8.1</kbd> branches to understand the changes made. Since the code is hosted in GitHub, we can use the <em class="calibre31">GitHub compare</em> interface to compare commits in a single branch. See the documentation on how to do it here: <span class="packt_screen"><a href="http://bit.ly/github-compare" class="calibre21">http://bit.ly/github-compare</a></span>. <span class="packt_screen">The </span>link at <span class="packt_screen"><a href="http://bit.ly/ng6be-compare-base-8-1" class="calibre21">http://bit.ly/ng6be-compare-base-8-1</a> </span><span class="packt_screen">shows a comparison between</span> <kbd class="calibre24">ng6-base</kbd> <span class="packt_screen">and</span> <kbd class="calibre24">ng6-checkpoint8.1</kbd><span class="packt_screen">. You can ignore the diff view for</span> <kbd class="calibre24">app.js</kbd> <span class="packt_screen">and</span> <kbd class="calibre24">app.module.js</kbd><span class="packt_screen">, generated as part of the TypeScript compilation.</span></div>
<p class="calibre3">Time to introduce Angular!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding Angular</h1>
                
            
            <article>
                
<p class="calibre3">We start by installing Angular and dependent <em class="calibre17">npm modules</em> for our app. We will update the <kbd class="calibre13">package.json</kbd> file with the necessary packages first.</p>
<p class="calibre3">Copy the updated package file from <span class="calibre6"><a href="http://bit.ly/ng6be-8-2-package-json" class="calibre10">http://bit.ly/ng6be-8-2-package-json</a></span> into your local installation.</p>
<p class="calibre3"><kbd class="calibre13">package.json</kbd> now references some new packages related to Angular. Install the referenced packages by calling:</p>
<pre class="calibre19"><strong class="calibre1">npm install</strong></pre>
<div class="packt_tip">If you are having trouble with installing packages with <kbd class="calibre24">npm install</kbd>, delete the <kbd class="calibre24">node_modules</kbd> folder and run <kbd class="calibre24">npm install</kbd> again.</div>
<p class="calibre3">Then, add a few library references that Angular is dependent upon (and are not loaded using SystemJS) in <kbd class="calibre13">index.html</kbd> before the <kbd class="calibre13">system.src.js</kbd> script reference (two in total):</p>
<pre class="calibre19"><strong class="calibre1">&lt;script src="/node_modules/core-js/client/shim.min.js"&gt;&lt;/script&gt;
</strong><strong class="calibre1">&lt;script src="/node_modules/zone.js/dist/zone.js"&gt;&lt;/script&gt;</strong><strong class="calibre1">
</strong>&lt;script src="/node_modules/systemjs/dist/system.src.js"&gt;&lt;/script&gt; </pre>
<p class="calibre3">As it stands now, the SystemJS configuration has been set up in the <kbd class="calibre13">index.html</kbd> file itself. Since Angular requires some decent amount of configuration, we are going to create a separate <em class="calibre17">SystemJS configuration file</em> instead, and reference that in <kbd class="calibre13">index.html</kbd>.</p>
<p class="calibre3">Add this script reference after the <kbd class="calibre13">system.src.js</kbd> reference:</p>
<pre class="calibre19">&lt;script src="systemjs.config.js"&gt;&lt;/script&gt; </pre>
<p class="calibre3">Now, clear the <kbd class="calibre13">script</kbd> section containing the call to the <kbd class="calibre13">System.config</kbd> function and replace it with the following:</p>
<pre class="calibre19">&lt;script&gt;System.import('app');&lt;/script&gt; </pre>
<p class="calibre3">Copy the <kbd class="calibre13">systemjs.config.js</kbd> from <a href="http://bit.ly/ng6be-8-2-system-js-config" class="calibre10">http://bit.ly/ng6be-8-2-system-js-config</a> and place it in the same folder as <kbd class="calibre13">package.json</kbd>.</p>
<p class="calibre3">Also, update <kbd class="calibre13">tsconfig.json</kbd> and add a new property called <kbd class="calibre13">moduleResolution</kbd> to <kbd class="calibre13">compilerOptions</kbd>:</p>
<pre class="calibre19">  "removeComments": false, 
<strong class="calibre1">  "moduleResolution": "node"</strong></pre>
<p class="calibre3">This instructs TypeScript to look for type definitions in the <kbd class="calibre13">node_modules</kbd> folder. Remember, Angular typings are bundled as part of the Angular library itself, and hence a separate type definition import is not required.</p>
<p class="calibre3">Now that the Angular-specific references have been added, we need to modify the existing bootstrap process to also load Angular.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The ngUpgrade Library</h1>
                
            
            <article>
                
<p class="calibre3">To support gradual migration from AngularJS to Angular, the Angular team has released a library, <kbd class="calibre13">ngUpgrade</kbd>. The library contains a set of services that allow AngularJS and Angular to be loaded in tandem and play well together. This library has services that can help:</p>
<ul class="calibre11">
<li class="calibre12">Bootstrap an app with both the AngularJS and Angular frameworks loaded. This is the first thing we are going to do.</li>
<li class="calibre12">Incorporate an Angular component in an AngularJS view.</li>
<li class="calibre12">Incorporate an AngularJS component in an Angular view, albeit with some limitations.</li>
<li class="calibre12">Share dependencies across the frameworks.</li>
</ul>
<p class="calibre3"><em class="calibre17">The primary tool in this library is</em> <kbd class="calibre13">UpgradeModule</kbd>. As the platform documentation summarizes:</p>
<div class="packt_quote">"This is a module that contains utilities for bootstrapping and managing hybrid applications that support both Angular and AngularJS code."</div>
<p class="calibre3">As we make progress with our migration efforts, the role of <kbd class="calibre13">UpgradeModule</kbd> becomes clearer.</p>
<p class="calibre3">Let's learn how to bootstrap the hybrid AngularJS and Angular app using <kbd class="calibre13">UpgradeModule</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Bootstrapping the hybrid app</h1>
                
            
            <article>
                
<p class="calibre3">To bootstrap a hybrid application, we must bootstrap both the Angular and AngularJS parts of the application. The sequence involves the process is as follows:</p>
<ol class="calibre14">
<li value="1" class="calibre12">Bootstrap the Angular app</li>
<li value="2" class="calibre12">Then, using<kbd class="calibre13">UpgradeModule</kbd>, bootstrap the AngularJS app</li>
</ol>
<p class="calibre3">Since Angular has just been added, we need to define the root app module for Angular.</p>
<p class="calibre3">Create a new file, <kbd class="calibre13">app-ng1.module.js</kbd>, and copy the complete content of <kbd class="calibre13">app.module.ts</kbd> to the new file. We will use the <kbd class="calibre13">app.module.ts</kbd> <span class="calibre6">file</span><span class="calibre6"> </span><span class="calibre6">to define an Angular module and hence the existing AngularJS module has been shifted to a new file.</span></p>
<p class="calibre3">Also, remember to update the <kbd class="calibre13">import</kbd> statement in <kbd class="calibre13">app.ts</kbd> in line with the changes:</p>
<pre class="calibre19">import  './app-ng1.module.js'; </pre>
<p class="calibre3">Let's now add the Angular root module definition to <kbd class="calibre13">app.module.ts</kbd>.</p>
<p class="calibre3">Replace the content of <kbd class="calibre13">app.module.ts</kbd> with the Angular module definition. Copy the new definition from <kbd class="calibre13">ng6-checkpoint8.2</kbd> (GitHub location: <a href="http://bit.ly/ng6be-8-2-app-module-ts" class="calibre10">http://bit.ly/ng6be-8-2-app-module-ts</a><span class="calibre6"/>).</p>
<p class="calibre3">The <kbd class="calibre13">AppModule</kbd> implementation defines a function, <kbd class="calibre13">ngDoBootstrap</kbd>:</p>
<pre class="calibre19">constructor(private upgrade: UpgradeModule) { }<br class="title-page-name"/>ngDoBootstrap() {<br class="title-page-name"/>    <strong class="calibre1">this.upgrade.bootstrap(document.documentElement, ['app']);</strong><br class="title-page-name"/>}</pre>
<p class="calibre3">The Angular framework invokes this function as part of the application bootstrap. This function internally uses the <kbd class="calibre13">bootstrap</kbd><span class="calibre6"> </span><span class="calibre6">function of</span><span class="calibre6"> </span><kbd class="calibre13">UpgradeModule</kbd><span class="calibre6"> </span><span class="calibre6">to bootstrap the AngularJS app. This function takes the same argument as the</span> <kbd class="calibre13">angular.bootstrap</kbd> <span class="calibre6">function takes.</span></p>
<p class="calibre3">While we have defined the root module for Angular, we still have not defined the entry point for the Angular application. Create a new file, <kbd class="calibre13">main.ts</kbd>, in the app folder and add the following code:</p>
<pre class="calibre19">import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';<br class="title-page-name"/>import { AppModule } from './app.module';<br class="title-page-name"/>import './app';<br class="title-page-name"/>platformBrowserDynamic().bootstrapModule(AppModule);</pre>
<p class="calibre3">This code, when executed, instructs the Angular framework to bootstrap the application with <kbd class="calibre13">AppModule</kbd>. The statement <kbd class="calibre13">import './app'</kbd> helps in loading all the script references in <kbd class="calibre13">app.ts</kbd>. Before proceeding, do remember to remove the AngularJS application bootstrapping code from <kbd class="calibre13">app.ts</kbd> (the complete <kbd class="calibre13">angular.element</kbd> block).</p>
<p class="calibre3">Refresh your app and make sure it works as before. Do watch out for errors in the TypeScript compiler console window or browser console log.</p>
<p class="calibre3">Congratulations! We now have a hybrid app up and running. Both frameworks are now working in tandem.</p>
<div class="packt_infobox">Look at the <kbd class="calibre24">ng6-checkpoint8.2</kbd> branch if you are facing issues upgrading to Angular. Again, you can also compare the git branches <kbd class="calibre24">ng6-checkpoint8.1</kbd> and <kbd class="calibre24">ng6- checkpoint8.2</kbd> to understand what has changed (<span class="packt_screen"><a href="http://bit.ly/ng6be-compare-8-1-8-2" class="calibre21">http://bit.ly/ng6be-compare-8-1-8-2</a></span>).</div>
<p class="calibre3">The migration process can start now. We can start by migrating a part of an AngularJS view/directive to Angular.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Injecting Angular components into AngularJS views</h1>
                
            
            <article>
                
<p class="calibre3">The most common migration pattern involves migrating lower-level AngularJS directives/views to Angular components. If we visualize the AngularJS HTML view structure as a tree of directives, we start at the leaf. We migrate parts of a directive/view to an Angular component and then embed the component inside the AngularJS view template. This Angular component is injected into the AngularJS view as an <em class="calibre17">element directive</em>.</p>
<div class="packt_infobox">The closest thing to <strong class="calibre26">Angular components</strong> that AngularJS has is <strong class="calibre26">element directives</strong>. During migration, we are either migrating element directives or controller-view pairs.</div>
<p class="calibre3">This is a bottom-up approach to migrating view/directives to Angular components. The following diagram highlights how the AngularJS view hierarchy gradually transforms into an Angular component tree:</p>
<div class="packt_figure"><img src="../images/00086.jpeg" class="calibre28"/></div>
<p class="calibre3">Let's migrate something small and get a feel for how things work. <kbd class="calibre13">ExerciseNavController</kbd> and its corresponding view fit the bill.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Migrating our first view to Angular component</h1>
                
            
            <article>
                
<p class="calibre3"><kbd class="calibre13">ExerciseNavController</kbd> is part of <em class="calibre17">Workout Builder</em> and is located inside <kbd class="calibre13">trainer/app/js/WorkoutBuilder/exercise.js</kbd>. The corresponding view is served from <kbd class="calibre13">trainer/app/partials/workoutbuilder/left-nav-exercises.html</kbd>.</p>
<p class="calibre3">The primary purpose of this controller-view pair is to show the list of available exercises when building a workout (available user path <kbd class="calibre13">http://localhost:8080/#/builder/workouts/new</kbd>):</p>
<div class="packt_figure"><img src="../images/00087.jpeg" class="calibre80"/></div>
<p class="calibre3">Clicking on any of these exercise names adds the exercise to the workout being constructed.</p>
<p class="calibre3">Let's start with creating a component for the preceding view.</p>
<div class="packt_infobox">Before starting on the new component, add a new <em class="calibre31">Workout Builder</em> module (<kbd class="calibre24">WorkoutBuilderModule</kbd>) to the application. Copy the module definition from <kbd class="calibre24">ng6-checkpoint8.3</kbd> in the <kbd class="calibre24">WorkoutBuilder</kbd> folder (GitHub location: <span class="packt_screen"><a href="http://bit.ly/ng6be-8-3-workout-builder-module-ts" class="calibre21">http://bit.ly/ng6be-8-3-workout-builder-module-ts</a></span>). Also, import the newly created module in <kbd class="calibre24">app.module.ts</kbd>.</div>
<p class="calibre3">Instead of inlining the complete code here, we suggest copying the <kbd class="calibre13">exercise-nav.component.ts</kbd> file from GitHub branch <kbd class="calibre13">ng6-checkpoint8.3</kbd> (<a href="http://bit.ly/ng6be-8-3-exercise-nav-component-ts" class="calibre10">http://bit.ly/ng6be-8-3-exercise-nav-component-ts</a><span class="calibre6"/>) and adding it to the <kbd class="calibre13">WorkoutBuilder</kbd> folder locally. The file has already<span class="calibre6"> been</span> referenced in <kbd class="calibre13">WorkoutBuilderModule</kbd>. We also add <kbd class="calibre13">ExerciseNavComponent</kbd> to <kbd class="calibre13">entryComponents</kbd> array as the component will be used from AngularJS module directly.</p>
<p class="calibre3">From an implementation standpoint, let's look at some relevant parts.</p>
<div class="packt_tip"><span class="packt_screen">Contrasting template syntax</span><strong class="calibre26"><br class="calibre27"/></strong> The Angular team has published an excellent reference (<span class="packt_screen"><a href="http://bit.ly/ng2-a1-a2-quickref" class="calibre21">http://bit.ly/ng2-a1-a2-quickref</a></span>) that details the common view syntaxes in AngularJS and their equivalents in Angular. Highly recommended when migrating an AngularJS app!</div>
<p class="calibre3">To start with, if you look at the <kbd class="calibre13">exercise-nav.component.ts</kbd> file, the component template is similar to <kbd class="calibre13">left-nav-exercises.html</kbd> used in AngularJS, except there is no <kbd class="calibre13">ng-controller</kbd> and the template bindings are Angular-based:</p>
<pre class="calibre19">template: `&lt;div id="left-nav-exercises"&gt; 
           &lt;h4&gt;Exercises&lt;/h4&gt; 
           &lt;div *ngFor="let exercise of exercises" class="row"&gt; 
           ... 
            
           &lt;/div&gt;` </pre>
<p class="calibre3">If we focus on the component implementation (<kbd class="calibre13">ExercisesNavComponent</kbd>), the first striking thing is the component's dependencies:</p>
<pre class="calibre19">constructor(  
@Inject('WorkoutService') private workoutService: any,  
@Inject('WorkoutBuilderService') private workoutBuilderService: any) </pre>
<p class="calibre3"><kbd class="calibre13">WorkoutService</kbd> and <kbd class="calibre13">WorkoutBuilderService</kbd> are AngularJS services injected into Angular components.</p>
<p class="calibre3">Nice! If that is your initial reaction, we can't blame you. The ease with which we can inject AngularJS service into Angular is pretty cool! But the story is still incomplete. There is no magic happening here. Angular cannot access AngularJS services unless it is told where to look. To help Angular, we need to create <em class="calibre17">factory provider</em> wrappers for the AngularJS service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Injecting AngularJS dependencies into Angular</h1>
                
            
            <article>
                
<p class="calibre3">When we allow an AngularJS service to be used in Angular, we are <em class="calibre17">upgrading</em> the service. The way it is done is by creating a <strong class="calibre5">factory provider wrapper</strong> over the existing AngularJS service and registering the wrapper with an Angular module or component.</p>
<p class="calibre3">Let's create wrappers for the two AngularJS services, <kbd class="calibre13">WorkoutService</kbd> and <kbd class="calibre13">WorkoutBuilderService</kbd>, that we have used in the last section.</p>
<p class="calibre3">A factory provider for an AngularJS service can be created using Angular's dependency injection API. Here is an example of a factory provider for <kbd class="calibre13">WorkoutService</kbd>:</p>
<pre class="calibre19">export function workoutServiceFactory(injector: any) {<br class="title-page-name"/> return injector.get('WorkoutService');<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>export const workoutServiceProvider = {<br class="title-page-name"/> provide: 'WorkoutService',<br class="title-page-name"/> useFactory: workoutServiceFactory,<br class="title-page-name"/> deps: ['$injector']<br class="title-page-name"/>};</pre>
<p class="calibre3">In this code, <kbd class="calibre13">$injector</kbd> is the AngularJS <em class="calibre17">injector service</em> and we are referencing the injector in the Angular execution context. The call to  <kbd class="calibre13">injector.get('WorkoutService');</kbd> in the previous factory function retrieves the service from AngularJS realm.</p>
<p class="calibre3">The provider created can then be registered with the app module:</p>
<pre class="calibre19">providers:[workoutServiceProvider]</pre>
<p class="calibre3">The shortcoming of this approach is that we have to define the factory function (<kbd class="calibre13">workoutServiceFactory</kbd>) and provider (<kbd class="calibre13">workoutServiceProvider</kbd>) for each service. That is too much code!</p>
<p class="calibre3">Instead, we can create a generic factory provider and factory function implementation, which can take any AngularJS service and register it with the same name (<em class="calibre17">string token</em>) in Angular. We have already done the hard work and created a new class, <kbd class="calibre13">UpgradeHelperService.</kbd> Download it from the codebase for <kbd class="calibre13">ng6-checkpoint8.3</kbd> (<a href="http://bit.ly/ng6be-upgrade-helper-service-ts" class="calibre10">http://bit.ly/ng6be-upgrade-helper-service-ts</a>).</p>
<p class="calibre3">The implementation exposes a function, <kbd class="calibre13">upgradeService</kbd>, which takes one argument, the name of the AngularJS service, and returns a factory provider instance. The factory provider implementation internally uses a <em class="calibre17">string token</em> to register the dependency. To create a factory provider for an AngularJS service, we just need to call:</p>
<pre class="calibre19">UpgradeHelperService.upgradeService('WorkoutService')</pre>
<p class="calibre3">Service dependencies at times have other dependencies, and hence it's better if we bring in all the service dependencies from AngularJS in one go. Register all the existing AngularJS dependencies as factory providers in <kbd class="calibre13">app.module.ts</kbd>:</p>
<pre class="calibre19">providers: [<br class="title-page-name"/>        UpgradeHelperService.upgradeService('ExercisePlan'),<br class="title-page-name"/>        UpgradeHelperService.upgradeService('WorkoutPlan'),<br class="title-page-name"/>        UpgradeHelperService.upgradeService('WorkoutService'),<br class="title-page-name"/>        UpgradeHelperService.upgradeService('WorkoutBuilderService'),<br class="title-page-name"/>        UpgradeHelperService.upgradeService('ExerciseBuilderService'),<br class="title-page-name"/>        UpgradeHelperService.upgradeService('ApiKeyAppenderInterceptor'),<br class="title-page-name"/>        UpgradeHelperService.upgradeService('appEvents'),<br class="title-page-name"/>        UpgradeHelperService.upgradeService('workoutHistoryTracker'),<br class="title-page-name"/>    ]</pre>
<p class="calibre3">Back to component integration! As the new  <kbd class="calibre13">ExercisesNavComponent</kbd> is rendered inside an AngularJS view, it needs to be registered as an <em class="calibre17">AngularJS directive</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Registering Angular components as directives</h1>
                
            
            <article>
                
<p class="calibre3"><kbd class="calibre13">ExercisesNavComponent</kbd> can be converted into an AngularJS directive using <kbd class="calibre13">ngUpgrade</kbd> library function <kbd class="calibre13">downgradeComponent.</kbd> As the function name suggests, we are downgrading an Angular component into an AngularJS element directive.</p>
<p class="calibre3">Open <kbd class="calibre13">app.ts</kbd> and add the highlighted lines:</p>
<pre class="calibre19"><strong class="calibre1">import {ExercisesNavComponent} from './WorkoutBuilder/exercise-nav-component' 
import { downgradeComponent } from '@angular/upgrade/static';</strong><br class="title-page-name"/>...<br class="title-page-name"/><strong class="calibre1">angular.module('WorkoutBuilder')</strong><br class="title-page-name"/>   <strong class="calibre1"> .directive('exerciseNav', downgradeComponent({ component: ExercisesNavComponent }) as angular.IDirectiveFactory);</strong></pre>
<p class="calibre3">The <kbd class="calibre13">downgradeComponent</kbd><span class="calibre6"> </span><span class="calibre6">function</span><span class="calibre6"> returns a</span> <em class="calibre17">factory function</em> <span class="calibre6">containing the</span> <em class="calibre17">directive definition object</em><span class="calibre6">. We register the component as an AngularJS directive,</span> <kbd class="calibre13">exerciseNav</kbd><span class="calibre6">.</span></p>
<div class="packt_infobox"><br class="calibre27"/>
Every Angular component is registered as an <em class="calibre31">element directive</em> when used in AngularJS.</div>
<p class="calibre3">The component implementation is complete. We now need to clean up the old code and inject the new directive into the view.</p>
<p class="calibre3">Delete the definition of <kbd class="calibre13">ExercisesNavController</kbd> from <kbd class="calibre13">exercise.js</kbd>.</p>
<p class="calibre3">Replace the content of <kbd class="calibre13">left-nav-exercises.html</kbd> (located in the <kbd class="calibre13">partials</kbd> folder) with:</p>
<pre class="calibre19">&lt;exercise-nav&gt;&lt;/exercise-nav&gt;</pre>
<p class="calibre3">And we are good to go.</p>
<p class="calibre3">Note that we do not get rid of <kbd class="calibre13">left-nav-exercises.html</kbd> as AngularJS still loads <kbd class="calibre13">left-nav-exercises.html</kbd> as part of the route transition, but the view inside is an Angular component.</p>
<p class="calibre3">Go ahead and try out the new implementation. Create a new workout and try to add exercises from the left nav. The functionality should work as before.</p>
<div class="packt_infobox">Look at <kbd class="calibre24">ng6-checkpoint8.3</kbd> in case you are facing issues upgrading to Angular. You can compare the git branches <kbd class="calibre24">ng6-checkpoint8.2</kbd> and <kbd class="calibre24">ng6-checkpoint8.3</kbd> to understand what has changed (<span class="packt_screen"><a href="http://bit.ly/ng6be-compare-8-2-8-3" class="calibre21">http://bit.ly/ng6be-compare-8-2-8-3</a></span>).</div>
<p class="calibre3">While we have only migrated a trivial component, this exercise highlights how easy it is to convert/downgrade an Angular component to the AngularJS directive and use it in an AngularJS view. The overall encapsulation of an Angular component makes this chore easy.</p>
<p class="calibre3">This downgraded component can even take an input from the parent scope using the familiar Angular property binding syntax:</p>
<pre class="calibre19">&lt;exercise-nav [exercises]='vm.exercises'&gt;&lt;/exercise-nav&gt; </pre>
<p class="calibre3">Add to that, the event raised by the component can be subscribed by the AngularJS container scope too:</p>
<pre class="calibre19">&lt;exercise-nav (onExerciseClicked)='vm.add(exercise)'&gt;&lt;/exercise-nav&gt; </pre>
<p class="calibre3">We now have an Angular component running inside AngularJS using services initially designed for AngularJS. A promising start to our migration journey!</p>
<p class="calibre3">Before we move any further, it's time to highlight how this collaboration works and the rules of engagement.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Rules of engagement</h1>
                
            
            <article>
                
<p class="calibre3">The migration story from AngularJS to Angular is only possible because these frameworks can coexist, and possibly share data. There are some touch points where the boundaries can be crossed. To have a better sense of how a hybrid application works and what is achievable in such a setup, we need to understand the areas of collaboration between the two frameworks.</p>
<p class="calibre3">There are three areas that need discussion:</p>
<ul class="calibre11">
<li class="calibre12">Template interleaving in the DOM</li>
<li class="calibre12">Dependency injection</li>
<li class="calibre12">Change detection</li>
</ul>
<p class="calibre3">Since Angular components and AngularJS directives can coexist in a DOM, the question we need to answer is who owns what parts of the DOM?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">AngularJS directives and Angular components</h1>
                
            
            <article>
                
<p class="calibre3">When it comes to ownership of a DOM element, the golden rule is:</p>
<p class="calibre3">Every DOM element is owned/managed by exactly one of the Angular frameworks.</p>
<p class="calibre3">Take our previous migration example. The view that is part of <kbd class="calibre13">ExercisesNavComponent</kbd> is managed by Angular, whereas the container view (<kbd class="calibre13">left-nav-exercises.html</kbd>) is managed by AngularJS.</p>
<p class="calibre3">Things get a bit tricky at the boundaries of these directives and components. Consider the declaration inside <kbd class="calibre13">left-nav-exercises.html</kbd>:</p>
<pre class="calibre19">&lt;exercise-nav&gt;&lt;/exercise-nav&gt; </pre>
<p class="calibre3">Who owns this? The short answer is AngularJS.</p>
<p class="calibre3">While this is an Angular component, the host element is owned by AngularJS. This means all AngularJS template syntax works:</p>
<pre class="calibre19">&lt;exercise-nav ng-if='showNav'&gt;&lt;/exercise-nav&gt; 
&lt;exercise-nav ng-repeat='item in items'&gt;&lt;/exercise-nav&gt; </pre>
<p class="calibre3">As these components and directives coexist in the same view, they often need to communicate. There are two ways to manage this communication:</p>
<ul class="calibre11">
<li class="calibre12">Using the templating capabilities of AngularJS and Angular:
<ul class="calibre30">
<li class="calibre12">An Angular component embedded inside an AngularJS view can take inputs from the parent scope using event and property binding</li>
<li class="calibre12">In a similar fashion, if a directive is injected into an Angular component view, it too can get inputs from the parent component and call the parent component function (through its isolated scope)</li>
</ul>
</li>
<li class="calibre12">Using shared services; we saw an example of this previously as we injected the <kbd class="calibre13">WorkoutService</kbd> and <kbd class="calibre13">WorkoutBuilderService</kbd> AngularJS services into <kbd class="calibre13">ExercisesNavComponent</kbd></li>
</ul>
<div class="packt_infobox">Injecting AngularJS directives into Angular is a bit tricky. To be able to inject an AngularJS directive into an Angular template, the directive needs to abide by some rules. We will talk about these rules in the coming sections.</div>
<p class="calibre3">Sharing functionality using services is far more flexible compared to sharing through view templates. Injecting services across framework boundaries requires us to register the service across both frameworks and let Angular take care of the rest. Let's learn how dependency injection works across boundaries.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Resource sharing and dependency injection</h1>
                
            
            <article>
                
<p class="calibre3">How dependencies are registered in a hybrid app is driven by how DI works in these two frameworks. For AngularJS, there is only one global injector, whereas Angular has a concept of hierarchical injectors. In a hybrid environment, the least common denominator is the global injector that both the frameworks support.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Sharing an AngularJS service</h1>
                
            
            <article>
                
<p class="calibre3">As we saw in the factory provider example earlier, AngularJS services can be registered with Angular by creating a wrapper factory provider.</p>
<p class="calibre3">Since dependency injection in AngularJS is string token-based, the corresponding providers too use string tokens to locate dependencies in Angular.</p>
<p class="calibre3">Looking back at the example of dependency registration share earlier, the dependency was registered with a help of a helper class:</p>
<pre class="calibre19">UpgradeHelperService.upgradeService('WorkoutService') </pre>
<p class="calibre3">And it was injected using the <kbd class="calibre13">Inject</kbd> decorator (with a string token):</p>
<pre class="calibre19">constructor(@Inject('WorkoutService') private workoutService: any...</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Sharing an Angular service</h1>
                
            
            <article>
                
<p class="calibre3">Services from Angular too can be injected into AngularJS. Since AngularJS only has a global injector, the dependency is registered at the global level. The <kbd class="calibre13">ngUpgrade</kbd> library has a <kbd class="calibre13">downgradeInjectable</kbd> <span class="calibre6">function</span><span class="calibre6"> </span><span class="calibre6">for this. The</span> <kbd class="calibre13">downgradeInjectable</kbd><span class="calibre6"> function creates a factory function than can be consumed by the AngularJS module's</span> <kbd class="calibre13">factory</kbd> <span class="calibre6">API:</span></p>
<pre class="calibre19">angular.module('app').factory('MyService',  
  downgradeInjectable(MyService)) </pre>
<p class="calibre3"><kbd class="calibre13">MyService</kbd> can now be injected across the AngularJS app, like any other service.</p>
<p class="calibre3">Look at the following diagram; it summarizes what we have discussed:</p>
<div class="packt_figure"><img src="../images/00088.jpeg" class="calibre81"/></div>
<p class="calibre3">One last topic of this discussion is change detection.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Change detection</h1>
                
            
            <article>
                
<p class="calibre3">In a hybrid application, change detection is managed by Angular. If we are used to calling <kbd class="calibre13">$scope.$apply()</kbd> in our code, we don't need to do it in a hybrid application.</p>
<p class="calibre3">We have already discussed how Angular change detection works. The Angular framework takes care of triggering AngularJS change detection by internally calling <kbd class="calibre13">$rootScope.$apply()</kbd> on standard triggering points.</p>
<p class="calibre3">Now that we understand the rules of engagement, it is easier to comprehend how things work, what's feasible, and what's not.</p>
<p class="calibre3">Let's set some bigger/meatier targets and migrate the start and finish pages of the v1 app.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Migrating the start and finish pages</h1>
                
            
            <article>
                
<p class="calibre3">The finish page migration is easy to do, and I suggest you do it yourself. Create a folder called <kbd class="calibre13">finish</kbd> inside the <kbd class="calibre13">js</kbd> folder, and create two files, <kbd class="calibre13">finish.component.ts</kbd> and  <kbd class="calibre13">finish.component.html</kbd>. Implement the component by looking at the existing implementation (or copy it from <kbd class="calibre13">ng6-checkpoint8.4</kbd>).</p>
<p class="calibre3">Add the component to the <kbd class="calibre13">declarations</kbd> and <kbd class="calibre13">entryComponents</kbd> array on  <kbd class="calibre13">AppModule</kbd> (<kbd class="calibre13">app.module.ts</kbd>). And then, fix the route for the finish to load the finish component.</p>
<p class="calibre3">Remember to also downgrade <kbd class="calibre13">FinishComponent</kbd> using the <kbd class="calibre13">downgradeComponent</kbd> function (check <kbd class="calibre13">app.ts</kbd>) and to fix the AngularJS <em class="calibre17">finish route</em> to use the new directive:</p>
<pre class="calibre19">$routeProvider.when('/finish', { template: '&lt;finish&gt;&lt;/finish&gt;' }); </pre>
<p class="calibre3">Lastly, remember to delete the finish HTML template from the <kbd class="calibre13">partials/workout</kbd> folder.</p>
<div class="packt_infobox">If you are stuck in migrating the finish page, compare the <kbd class="calibre24">ng6-checkpoint8.3</kbd> and <kbd class="calibre24">ng6-checkpoint8.4</kbd> git branches to understand what has changed in the <kbd class="calibre24">8.4</kbd> branch (<span class="packt_screen"><a href="http://bit.ly/ng2be-compare-8-3-8-4" class="calibre21">http://bit.ly/ng6be-compare-8-3-8-4</a></span>).</div>
<p class="calibre3">The finish page was easy, the start page is not! While the start page seems to be an easy target, there are some challenges that require some head-scratching.</p>
<p class="calibre3">Look at the start page template (<kbd class="calibre13">partials/workout/start.html</kbd>); the biggest issue with the start page is that it uses a third-party library, <em class="calibre17">angular-translate</em>, to localize the content of the page. Since we are migrating the complete page/view to Angular, we need a mechanism to handle these AngularJS library dependencies.</p>
<p class="calibre3"><em class="calibre17">angular-translate</em> comes with a <em class="calibre17">filter</em> (<em class="calibre17">pipe</em> in the Angular world) and a directive, both named <kbd class="calibre13">translate</kbd>. Their job is to translate string tokens into localized string literals.</p>
<p class="calibre3">If the <em class="calibre17">start</em> page becomes an Angular component, we need to convert the filter into an Angular pipe and, in some way, make the <kbd class="calibre13">translate</kbd> directive work in Angular.</p>
<p class="calibre3">We have at least these two choices to handle this migration scenario:</p>
<ul class="calibre11">
<li class="calibre12">Create a new filter, also upgrade the v1 <kbd class="calibre13">translate</kbd> directive using <kbd class="calibre13">UpgradeModule</kbd></li>
<li class="calibre12">Find a suitable replacement for <em class="calibre2">angular-translate</em> in the Angular world</li>
</ul>
<p class="calibre3">Although the first choice seems to be the easiest, it has some serious limitations. Angular imposes some stringent requirements around how a directive can be upgraded to Angular.</p>
<div class="packt_infobox"><br class="calibre27"/>
Upgrading an AngularJS directive does not mean the directive has been migrated. Angular instead allows us to use an AngularJS element directive as is inside Angular component views.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">AngularJS directive upgrade</h1>
                
            
            <article>
                
<p class="calibre3">At times, the parts of an application may be migrated in a top-down fashion; a higher-order view is converted into a component. In such a case, instead of migrating all the custom directives that are part of the AngularJS view, we just upgrade them to Angular components using some interfaces and functions defined in the  <kbd class="calibre13">UpgradeModule</kbd>. The following diagram illustrates this migration path:</p>
<div class="packt_figure"><img src="../images/00089.jpeg" class="calibre82"/></div>
<p class="calibre3">The Angular framework puts some restrictions on what can be upgraded to an Angular component. Here is an excerpt from the Angular migration guide.</p>
<p class="calibre3">To be Angular compatible, an AngularJS component directive should configure these attributes:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">restrict: 'E'</kbd>. Components are usually used as elements.</li>
<li class="calibre12"><kbd class="calibre13">scope: {}</kbd> - an isolate scope. In Angular, components are always isolated from their surroundings, and you should do this in AngularJS too.</li>
<li class="calibre12"><kbd class="calibre13">bindToController: {}</kbd>. Component inputs and outputs should be bound to the controller instead of using the <kbd class="calibre13">$scope</kbd>.</li>
<li class="calibre12"><kbd class="calibre13">controller and controllerAs</kbd>. Components have their own controllers.</li>
<li class="calibre12"><kbd class="calibre13">template or templateUrl</kbd>. Components have their own templates.</li>
</ul>
<p class="calibre3">Component directives may also use the following attributes:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">transclude: true/{}</kbd>, if the component needs to transclude content from elsewhere</li>
<li class="calibre12"><kbd class="calibre13">require</kbd>, if the component needs to communicate with some parent component's controller</li>
</ul>
<p class="calibre3">Component directives should not use the following attributes:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">compile</kbd>. This will not be supported in Angular.</li>
<li class="calibre12"><kbd class="calibre13">replace</kbd>: True. Angular never replaces a component element with the component template. This attribute is also deprecated in AngularJS.</li>
<li class="calibre12"><kbd class="calibre13">priority</kbd> and <kbd class="calibre13">terminal</kbd>. While AngularJS components may use these, they are not used in Angular and it is better not to write code that relies on them.</li>
</ul>
<p class="calibre3">The only AngularJS directives that can be upgraded to Angular are element directives, given that all other conditions are met.</p>
<p class="calibre3">With this sizeable laundry list, upgrading an AngularJS directive to Angular is difficult when compared to an Angular component downgrade. More often than not, we have to do an actual code migration of an AngularJS directive if the parent view has been migrated to Angular.</p>
<p class="calibre3">Looking at the <kbd class="calibre13">angular-translate</kbd> source code, we realize it uses the <kbd class="calibre13">$compile</kbd> service; therefore, the upgrade option is ruled out. We need to find an alternative library.</p>
<p class="calibre3">We do have an internationalization library for Angular, <kbd class="calibre13">ngx-translate</kbd> (<a href="http://www.ngx-translate.com/" class="calibre10">http://www.ngx-translate.com/</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Replacing angular-translate with ngx-translate</h1>
                
            
            <article>
                
<p class="calibre3"><em class="calibre17">ngx-translate</em> is an internationalization library that targets Angular. This library can replace v1 <em class="calibre17">angular-translate</em>.</p>
<p class="calibre3">Install the npm package for <kbd class="calibre13">ngx-translate</kbd> and <kbd class="calibre13">ngx-translate/http-loader</kbd>:</p>
<pre class="calibre19"><strong class="calibre1">npm install @ngx-translate/core --save<br class="title-page-name"/>npm install @ngx-translate/http-loader --save<br class="title-page-name"/></strong></pre>
<p class="calibre3">The <em class="calibre17">http-loader</em> loads the localization files from the server.</p>
<p class="calibre3">Update <kbd class="calibre13">systemjs.config.js</kbd> to include the <kbd class="calibre13"><em class="calibre2">ngx-translate</em></kbd> library. Add entries to the <kbd class="calibre13">map</kbd> property:</p>
<pre class="calibre19">var map = {... 
    '@ngx-translate/core':'npm:@ngx-translate/core/bundles/core.umd.js',<br class="title-page-name"/>    '@ngx-translate/http-loader':'npm:@ngx-translate/http-loader/bundles/http-loader.umd.js'<br class="title-page-name"/>}<strong class="calibre1"><br class="title-page-name"/></strong></pre>
<p class="calibre3">As described in the <kbd class="calibre13">ngx-translate</kbd> documentation, we need to configure the translate module and HTTP loader. Open <kbd class="calibre13">app.module.ts</kbd> and add the highlighted code:</p>
<pre class="calibre19"><strong class="calibre1">export function HttpLoaderFactory(http: HttpClient) {</strong><br class="title-page-name"/><strong class="calibre1">    return new TranslateHttpLoader(http,'/i18n/');</strong><br class="title-page-name"/><strong class="calibre1">}</strong><br class="title-page-name"/><br class="title-page-name"/>@NgModule({<br class="title-page-name"/>    imports: [...<br class="title-page-name"/>       <strong class="calibre1"> HttpClientModule,</strong><br class="title-page-name"/><strong class="calibre1">        FormsModule,</strong><br class="title-page-name"/><strong class="calibre1">        TranslateModule.forRoot({</strong><br class="title-page-name"/><strong class="calibre1">            loader: {</strong><br class="title-page-name"/><strong class="calibre1">                provide: TranslateLoader,</strong><br class="title-page-name"/><strong class="calibre1">                useFactory: HttpLoaderFactory,</strong><br class="title-page-name"/><strong class="calibre1">                deps: [HttpClient]</strong><br class="title-page-name"/><strong class="calibre1">            }</strong><br class="title-page-name"/><strong class="calibre1">        })</strong><br class="title-page-name"/>    ],...</pre>
<p class="calibre3">The preceding provider declaration sets up a loader that loads the translation files (<kbd class="calibre13">.json</kbd>) from the <kbd class="calibre13">i18n</kbd> folder. The <kbd class="calibre13">HttpClientModule</kbd> import is required for the translate library to load translations from the server. Remember to copy the translation files (<kbd class="calibre13">*.json</kbd>) from git branch <kbd class="calibre13">ng6-checkpoint8.4</kbd> (<a href="http://bit.ly/ng6be-8-4-i18n" class="calibre10">http://bit.ly/ng6be-8-4-i18n</a>).</p>
<p class="calibre3">Add these import statements to <kbd class="calibre13">app.module.ts</kbd> to keep the TypeScript compiler happy:</p>
<pre class="calibre19">import { HttpClient, HttpClientModule } from '@angular/common/http';<br class="title-page-name"/>import { TranslateModule, TranslateLoader, TranslateService } from '@ngx-translate/core';<br class="title-page-name"/>import { TranslateHttpLoader } from '@ngx-translate/http-loader';</pre>
<p class="calibre3">The <kbd class="calibre13">ngx-translate</kbd> library is now ready to be used. The first thing that we are going to do is set the default translation language as soon as the application bootstraps.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using ngDoBootstrap for initialization</h1>
                
            
            <article>
                
<p class="calibre3">With Angular, luckily the <kbd class="calibre13">AppModule</kbd> already defines a function, <kbd class="calibre13">ngDoBootstrap</kbd>, that the framework calls when bootstrapping an AngularJS application—a perfect place to do <kbd class="calibre13">ngx-translate</kbd> initialization. Update the <kbd class="calibre13">ngDoBootstrap</kbd> function in <kbd class="calibre13">app.module.ts</kbd> with the following code snippet:</p>
<pre class="calibre19">ngDoBootstrap() {<br class="title-page-name"/>        this.upgrade.bootstrap(document.documentElement, ['app']);<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">        var translateService = this.upgrade.injector.get(TranslateService);</strong><br class="title-page-name"/><strong class="calibre1">        // determine the current locale.</strong><br class="title-page-name"/><strong class="calibre1">        var userLang = navigator.language.split('-')[0];</strong><br class="title-page-name"/><strong class="calibre1">        userLang = /(fr|en)/gi.test(userLang) ? userLang : 'en';</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">        translateService.setDefaultLang('en');</strong><br class="title-page-name"/><strong class="calibre1">        translateService.use(userLang);
</strong>  }); </pre>
<p class="calibre3">The code tries to determine the current browser language and sets the current language for translations accordingly. Make note of how we get hold of <kbd class="calibre13">TranslateService</kbd>. The <kbd class="calibre13">UpgradeModule</kbd> object holds the reference to Angular's <em class="calibre17">root injector</em>, which in turn loads <kbd class="calibre13"><span>TranslateService</span></kbd><span class="calibre6"> from </span><kbd class="calibre13">ngx-translate</kbd><span class="calibre6">.</span></p>
<p class="calibre3">With the background work done for the start component, copy the start page implementation from the <kbd class="calibre13">ng6-checkpoint8.4</kbd> branch (<a href="http://bit.ly/ng6be-8-4-start" class="calibre10">http://bit.ly/ng6be-8-4-start</a>) into a new folder <kbd class="calibre13">app/js/start</kbd>.</p>
<p class="calibre3">Then, add the start component declaration to <kbd class="calibre13">app.module.ts</kbd>.</p>
<p class="calibre3">Like other components registered as an AngularJS directive before use, add this statement to <kbd class="calibre13">app.ts</kbd>:</p>
<pre class="calibre19">import {StartComponent} from './start/start-component'; 
angular.module('start').directive('start', upgradeAdapter.downgradeng6Component(StartComponent) as angular.IDirectiveFactory); </pre>
<p class="calibre3">The start template file now uses the <kbd class="calibre13">translate</kbd> pipe (the name of the pipe is the same as the AngularJS filter <kbd class="calibre13">translate</kbd>).</p>
<p class="calibre3">The start page also has three pipes, <kbd class="calibre13">search</kbd>, <kbd class="calibre13">orderBy</kbd>, and <kbd class="calibre13">secondsToTime</kbd>:</p>
<pre class="calibre19">&lt;a *ngFor="let workout of workouts|<strong class="calibre1">search</strong>:'name':searchContent|<strong class="calibre1">orderBy</strong>:'name'" ...&gt;<br class="title-page-name"/>...<br class="title-page-name"/>{{workout.totalWorkoutDuration()|<strong class="calibre1">secondsToTime</strong>}}</pre>
<p class="calibre3">Copy the implementation for these pipes together with the definition of the shared module (<kbd class="calibre13">shared.module.ts</kbd>) from <kbd class="calibre13">ng6-checkpoint8.4</kbd> (<a href="http://bit.ly/ng6be-8-4-shared" class="calibre10">http://bit.ly/ng6be-8-4-shared</a><span class="calibre6"/>) and add it to the <kbd class="calibre13">js/shared</kbd> folder locally. Also, remember to import the shared module (<kbd class="calibre13">shared.module.ts</kbd>) into the app module (<kbd class="calibre13">app.module.ts</kbd>). We will not dwell on any of the pipe implementation here, as we have done that already in earlier chapters.</p>
<p class="calibre3">Start and finish component implementation is complete. Let's integrate them into the app.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Integrating the start and finish pages</h1>
                
            
            <article>
                
<p class="calibre3">Start/finish views are loaded as part of route change, so we need to fix the route definition in <kbd class="calibre13">config.js</kbd>. Update the start and finish route definitions to:</p>
<pre class="calibre19">$routeProvider.when('/start',  <strong class="calibre1">{ template: '&lt;start&gt;&lt;/start&gt;' });</strong> 
$routeProvider.when('/finish',  <strong class="calibre1">{ template: '&lt;finish&gt;&lt;/finish&gt;' });</strong></pre>
<p class="calibre3">The route template HTML is a part of the AngularJS view. Since we have registered both <kbd class="calibre13">StartComponent</kbd> and <kbd class="calibre13">FinishComponent</kbd> as AngularJS directives, the route loads the correct components.</p>
<div class="packt_infobox"><br class="calibre27"/>
If you have already migrated the finish page, you do not need to redo the route setup for finish as described.</div>
<p class="calibre3">A few more fixes are pending before we can test the implementation.</p>
<p class="calibre3">Remember to copy the translation files <kbd class="calibre13">de.json</kbd> and <kbd class="calibre13">en.json</kbd> from the <kbd class="calibre13">ng6-checkpoint8.4</kbd> folder <kbd class="calibre13">i18n</kbd> (<span class="calibre6"><a href="http://bit.ly/ng6be-8-4-i18n" class="calibre10">http://bit.ly/ng6-8-4-i18n</a></span>). Now, we are ready to test what we have developed.</p>
<p class="calibre3">If not started, start the TypeScript compiler and HTTP-server, and then launch the browser. The start and finish pages should load just fine. But the translations do not work! Clicking on the language translation links on the top nav has no effect. Content always renders in English.</p>
<div class="packt_infobox">We now are at checkpoint <kbd class="calibre24">ng6-checkpoint8.4</kbd>. If you are stuck, compare the git branches <kbd class="calibre24">ng6-checkpoint8.3</kbd> and <kbd class="calibre24">ng6-checkpoint8.4</kbd> to understand what changed (<span class="packt_screen"><a href="http://bit.ly/ng6be-compare-8-3-8-4" class="calibre21">http://bit.ly/ng6be-compare-8-3-8-4</a></span>).</div>
<p class="calibre3">The translations still do not work because the top nav code (<kbd class="calibre13">root.js</kbd>) that enables translation is still using the older library. We need to get rid of angular-translate (the v1 library) altogether. Having two libraries doing the same work is not something we want, but removing it is also not that simple.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting rid of angular-translate</h1>
                
            
            <article>
                
<p class="calibre3">To get rid of the angular-translate (v1) library, we need to:</p>
<ul class="calibre11">
<li class="calibre12">Remove the angular-translate's directive/filter references from all AngularJS views</li>
<li class="calibre12">Get rid of any code that uses this library</li>
</ul>
<p class="calibre3">Getting rid of the v1 directive/filter altogether is a difficult task. No can we use the v2 <kbd class="calibre13">ngx-translate</kbd> pipe in the AngularJS view. Also, migrating every view using the v1 translate directive/filter to Angular at one shot is feasible. There has to be a better solution out there? And there is!</p>
<p class="calibre3">Why not write a new AngularJS filter that uses ngx-translate's translation service (<kbd class="calibre13">TranslateService</kbd>) for translations and then use the new filter everywhere? Problems solved!</p>
<p class="calibre3">Let's call this filter <kbd class="calibre13">ngxTranslate</kbd>. We replace all references to the <kbd class="calibre13">translate</kbd> filter in the v1 view with <kbd class="calibre13">ngxTranslate</kbd>. All v1 <kbd class="calibre13">translate</kbd> directive references too are replaced with an <kbd class="calibre13">ngxTranslate</kbd> filter.</p>
<p class="calibre3">Here is how the filter implementation looks:</p>
<pre class="calibre19">import { TranslateService } from '@ngx-translate/core'; 
 
export function ngxTranslate(ngxTranslateService: TranslateService) { 
   function translate(input) { 
    if (input &amp;amp;&amp;amp; ngxTranslateService.currentLang) { 
      return ngxTranslateService.instant(input); 
    } 
  } 
  translate['$stateful'] = true; 
  return translate; 
} 
 
ngxTranslate.$inject = ['TranslateService']; 
angular.module('app').filter("ngxTranslate", ngxTranslate); </pre>
<p class="calibre3">Create a file called <kbd class="calibre13">ngx-translate.filter.ts</kbd> in the <kbd class="calibre13">shared</kbd> folder and add the preceding implementation. The filter uses <kbd class="calibre13">TranslateService</kbd> to localized content. To make the service discoverable in AngularJS, it needs to be downgraded using the <kbd class="calibre13">ngUpgrade</kbd> module method <kbd class="calibre13">downgradeInjectable</kbd>. Open  <kbd class="calibre13">app.ts</kbd> and add the following lines:</p>
<pre class="calibre19"><strong class="calibre1">import './shared/ngx-translate.filter';</strong><br class="title-page-name"/>...<br class="title-page-name"/>import { downgradeComponent, <strong class="calibre1">downgradeInjectable</strong> } from '@angular/upgrade/static';<br class="title-page-name"/>...<br class="title-page-name"/><strong class="calibre1">import { TranslateService } from '@ngx-translate/core';<br class="title-page-name"/>...</strong><br class="title-page-name"/><strong class="calibre1">angular.module('app')</strong><br class="title-page-name"/><strong class="calibre1">    .factory('TranslateService', downgradeInjectable(TranslateService));</strong> </pre>
<p class="calibre3">This code registers <kbd class="calibre13">TranslateService</kbd> using a string token, <kbd class="calibre13">'TranslateService'</kbd>, in AngularJS. The first import statement also loads the new filter at runtime.</p>
<p class="calibre3">To test this implementation, there are a few more steps needed.</p>
<p class="calibre3">To start with, replace all references to <kbd class="calibre13">translate</kbd> (directive and filter) across the AngularJS view with <kbd class="calibre13">ngxTranslate</kbd>. There are references in these files: <kbd class="calibre13">description-panel.html</kbd>, <kbd class="calibre13">video-panel.html</kbd>, <kbd class="calibre13">workout.html</kbd> (in the folder <kbd class="calibre13">partials/workout</kbd>), and <kbd class="calibre13">index.html</kbd>. Replacing the filter in the interpolation is a simple exercise. For the <kbd class="calibre13">translate</kbd> directive, replace it with interpolation. For example, in <kbd class="calibre13">partials/workout/description-panel.html</kbd>, the line of code is as follows:</p>
<pre class="calibre19">&lt;h3 class="panel-title" translate&gt;RUNNER.STEPS&lt;/h3&gt; </pre>
<p class="calibre3">It then becomes the following:</p>
<pre class="calibre19">&lt;h3 class="panel-title"&gt;{{'RUNNER.STEPS'|ngxTranslate}}&lt;/h3&gt; </pre>
<p class="calibre3">Remember to quote the string token (<kbd class="calibre13">'RUNNER.STEPS'</kbd>) inside the interpolation.</p>
<p class="calibre3">Finally, copy the updated <kbd class="calibre13">root.js</kbd> from <a href="http://bit.ly/ng6be-8-5-root-js" class="calibre10">http://bit.ly/ng6be-8-5-root-js</a><span class="calibre6"/>. We have replaced all references to the <kbd class="calibre13">$translate</kbd> service with <kbd class="calibre13">TranslateService</kbd> and refactored the code to use the new service. <kbd class="calibre13">root.js</kbd> contains the implementation for the v1 <kbd class="calibre13">RootController</kbd>.</p>
<p class="calibre3">We are good to go now. Try out the new implementation; the app should load translation using the <em class="calibre17">ngx-translate</em> library.</p>
<p class="calibre3">We can now delete all references to <em class="calibre17">angular-translate</em>. There are references in <kbd class="calibre13">index.html</kbd>, <kbd class="calibre13">app-ng1.module.ts</kbd>, and <kbd class="calibre13">config.js</kbd>.</p>
<p class="calibre3">The migration of the start and finish pages is complete.</p>
<div class="packt_infobox">Compare the branches <kbd class="calibre24">ng6-checkpoint8.4</kbd> and <kbd class="calibre24">ng6-checkpoint8.5</kbd> to understand the new changes in <kbd class="calibre24">ng6-checkpoint8.5</kbd> (<span class="packt_screen"><a href="http://bit.ly/ng2be-compare-8-4-8-5" class="calibre21">http://bit.ly/ng6be-compare-8-4-8-5</a></span>).</div>
<p class="calibre3">We will stop here and direct you to the other GitHub branches pertaining to migration. All branches starting with <kbd class="calibre13">ng6-checkpoint*</kbd> are the migration branches. Try to migrate the pending views and compare them with the GitHub branch changes. Remember, a working version of the app has already been developed in Angular, and hence there is a good reference point. Look at the <kbd class="calibre13">README.md</kbd> file for each branch to know what part of the application was migrated to Angular.</p>
<p class="calibre3">Meanwhile, let's summarize our learnings from the migration that we did.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Learning</h1>
                
            
            <article>
                
<p class="calibre3">We hope this migration exercise has provided enough insight into the process. You can now gauge the complexity, the time, and the effort required to migrate elements from AngularJS to Angular. Let's highlight what we have learned as part of this process:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Migration is time-consuming</strong>: Migration is by no stretch of the imagination a trivial exercise. Each page/view presents its own challenges that we need to overcome. Some elements are easy to migrate and some are not. The best thing you can do today if you are developing in AngularJS would be to follow the advice from the <em class="calibre2">Developing AngularJS apps today for easy migration</em> section.</li>
<li class="calibre12"><strong class="calibre1">Migrate third-party libraries first</strong>: Migrating third-party libraries can be quite challenging. The reasons are manifold:
<ul class="calibre30">
<li class="calibre12">Such libraries are used across pages</li>
<li class="calibre12">They may not be upgradable to Angular (using <kbd class="calibre13">UpgradeAdapter</kbd>)</li>
<li class="calibre12">Migrating each view that uses such a library may not be feasible when the library is extensively used</li>
</ul>
</li>
</ul>
<p class="calibre36">It's better to identify all third-party dependencies in your app and find a suitable alternative for them in the Angular world. If possible, develop some <strong class="calibre5">proof of concept</strong> (<strong class="calibre5">POC</strong>) with the new library to understand how different the new library is from the existing implementation.</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Libraries with overlap may exist</strong>: While migrating, there could be scenarios where both AngularJS and Angular versions of a library coexist. Minimize this time period and migrate to the newer version as soon as possible.</li>
<li class="calibre12"><strong class="calibre1">It is easier to integrate Angular components into AngularJS than the other way round</strong>: While migrating, migrate the complete view to Angular. Due to the restriction imposed by Angular, it becomes very difficult to have a parent Angular component with embedded AngularJS element directives. With such limitations, a bottom-up approach to migrating works better than a top-down approach.</li>
</ul>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Anything non-UI-related is easy to migrate</strong>: For <em class="calibre2">Personal Trainer</em>, we migrate the services last as they can be easily migrated.</li>
<li class="calibre12"><strong class="calibre1">Feature parity better AngularJS and Angular</strong>: Angular may not have every feature that AngularJS supports. In such a case, we need workarounds to achieve the desired behavior.</li>
</ul>
<p class="calibre3">That completes our migration story. With this, it's time to conclude the chapter and summarize our lessons from it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre3">In this chapter, we gained some useful insight into a number of practical issues surrounding Angular development. These tips/guidelines can be extremely handy when building real-life applications using the framework.</p>
<p class="calibre3">We started the chapter by exploring the concept of <em class="calibre17">seed projects</em> and how these projects can get us up and running in no time. We looked at some popular seed projects that can serve as a base for any new Angular app development.</p>
<p class="calibre3">In spite of being a server-side concern, authentication and authorization do affect the client implementation. The section on authentication/authorization covered how to handle authentication in both cookie- and token-based setups.</p>
<p class="calibre3">We looked at the ever-so-important topic of performance, where you learned ways to optimize an Angular app's performance.</p>
<p class="calibre3">Finally, we migrated the v1 <em class="calibre17">Personal Trainer</em> to Angular. The gradual migration process taught us the intricacies of migration, the challenges faced, and the workaround done.</p>
<p class="calibre3">The book is coming to a close, but for everyone reading it, the journey has just begun. It's time to put theories into practice, hone our newly acquired skills, build something useful with Angular, and share it with the world. The more you invest in Angular, the more rewarding the framework is. Let's get started!</p>


            </article>

            
        </section>
    </body></html>