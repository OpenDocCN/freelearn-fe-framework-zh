<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Integration Testing with Appium</h1>
                
            
            <article>
                
<p class="mce-root">In the preceding chapter, we explored how to do unit testing, but unit testing doesn't allow you to test whether the button used in your app still actually runs a function, or what happens when the user swipes left. For that, we will need application testing or end-to-end testing. Well, let's start learning end-to-end testing; this is where testing can get complicated and fun.</p>
<p class="mce-root">In this chapter, we will cover the following topics:</p>
<ul class="calibre13">
<li class="calibre14">Appium testing framework</li>
<li class="calibre14">Writing MochaJS, ChaiJS, and ShouldJS tests</li>
<li class="calibre14">How to find and interact with elements on the screen</li>
<li class="calibre14">How to run the tests</li>
<li class="calibre14">Travis and GitHub integration</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Integration testing</h1>
                
            
            <article>
                
<p class="mce-root">There are several full application frameworks out there, but we will show you how to use Appium (<a href="http://appium.io" class="calibre3">http://appium.io</a>). Appium is an awesome open source application testing framework. Appium supports both iOS and Android, which makes it a perfect fit for doing all our on-device testing. You want to start creating tests to test your basic flow through your application, and even create more complicated tests that test alternate flows through your app.</p>
<p class="mce-root">Let's get it installed first; run the following command:</p>
<pre class="calibre22"><strong class="calibre1">npm install appium wd nativescript-dev-appium --save-dev</strong></pre>
<p class="mce-root">The preceding command installs Appium, the Appium communication driver <strong class="calibre1">WD</strong> (<a href="http://admc.io/wd/" class="calibre3">http://admc.io/wd/</a>), and the <strong class="calibre1">NativeScript driver</strong> (<a href="https://github.com/NativeScript/nativescript-dev-appium" class="calibre3">https://github.com/NativeScript/nativescript-dev-appium</a>). The WD driver is what communicates with Appium and the NativeScript driver. The <kbd class="calibre11">nativescript-dev-appium</kbd> is the driver that interacts with WD and your test code. In reality, the NativeScript driver is a very thin wrapper around the WD driver and just facilitates some configuration and then exposes the WD driver to your application. So interaction commands will be found in the WD documentation.</p>
<p class="mce-root">Application/Integration testing takes a bit more work, as you have to programmatically run it as a normal user would interact with your app. So, you have to do things, such as find the button element, then perform <kbd class="calibre11">button.tap()</kbd>. So, your tests might be a bit verbose, but this allows you to test any, and all, functionalities. The down side is that this is a lot more time-consuming to run and takes more maintenance work when you change screens. However, the payoff is that when you add code, it verifies that your app still runs properly on each screen automatically, and you can test it on multiple devices and resolutions, once again automatically.</p>
<p class="mce-root">After installation, you will have a brand new <kbd class="calibre11">e2e-tests</kbd> folder in your root folder of your application. This folder is where all your end-to-end test files will live. Now, one thing that you need to know is that the Appium NativeScript driver uses the MochaJS test framework (<a href="https://mochajs.org/" class="calibre3">https://mochajs.org/</a>). The Mocha testing framework is similar to the Jasmine framework, which we discussed in the preceding chapter. It uses the same <kbd class="calibre11">describe</kbd> and <kbd class="calibre11">it</kbd> functions for the start of the tests, just like Jasmine. In addition, it uses the Chai (<a href="http://chaijs.com/" class="calibre3">http://chaijs.com/</a>) and ShouldJS (<a href="https://github.com/shouldjs/should.js" class="calibre3">https://github.com/shouldjs/should.js</a>) testing frameworks that work hand in hand with the Mocha test framework and the WD driver.</p>
<p class="mce-root">Another thing to note is that all these are designed around pure JavaScript. You can get typings for Mocha, Should, and Chai, but for the NativeScript Appium driver or WD driver, typings don't exist. You can use TypeScript, but it is awkward, as commands are not just WD-based commands but chained through mocha. TypeScript gets easily confused as to what context you are in. So, mostly the Appium tests are <span>created</span> in pure JavaScript rather than in TypeScript. However, feel free to use TypeScript if you want; just make sure that you run <kbd class="calibre11">tsc</kbd> to build the <kbd class="calibre11">JS</kbd> files before you run the tests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Configuration</h1>
                
            
            <article>
                
<p class="mce-root">One more setup step that you will need to do is to create an <kbd class="calibre11">appium.capabilities.json</kbd> file in the root folder of your project. This is basically a configuration file that you can use to configure the emulator that you need to run any of your tests on. The file is documented on the Appium site but to get you up and running quickly you can use the paired-down file which we use as follows:</p>
<pre class="calibre22">{<br class="title-page-name"/> "android44": {<br class="title-page-name"/>   "browserName": "",<br class="title-page-name"/>   "appium-version": "1.6.5",<br class="title-page-name"/>   "platformName": "Android",<br class="title-page-name"/>   "platformVersion": "4.4",<br class="title-page-name"/>   "deviceName": "Android 44 Emulator",<br class="title-page-name"/>   "noReset": false,<br class="title-page-name"/>   "app": ""<br class="title-page-name"/> },<br class="title-page-name"/> <br class="title-page-name"/> "ios10phone": {<br class="title-page-name"/>   "browserName": "",<br class="title-page-name"/>   "appium-version": "1.6.5",<br class="title-page-name"/>   "platformName": "iOS",<br class="title-page-name"/>   "platformVersion": "10.0",<br class="title-page-name"/>   "deviceName": "iPhone 6 Simulator",<br class="title-page-name"/>   "app": ""<br class="title-page-name"/> }<br class="title-page-name"/>}</pre>
<p class="mce-root">We've simplified it and removed all other emulator entries to save space. However you give each emulator entry a key-- you tell Appium using <span>the key the</span> emulator configuration that you will be running. This example file shows two configurations. The first one is an Android 4.4 device, and the second one is an iOS simulator (iPhone 6 runs iOS 10). You can have as many configurations as you want in this file. When you run Appium, you can tell it which device you will target, using the <kbd class="calibre11">--runType=KEY</kbd> parameter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a test</h1>
                
            
            <article>
                
<p class="mce-root">Let's start our journey and create a new test file: <kbd class="calibre11">list.test.js</kbd>. This file will test our mix-list screen. The screen's HTML (<kbd class="calibre11">/app/modules/mixer/components/mix-list.component.html</kbd>) looks like this:</p>
<pre class="calibre22">&lt;ActionBar title="Compositions" class="action-bar"&gt;<br class="title-page-name"/>   &lt;ActionItem (tap)="add()" ios.position="right"&gt;<br class="title-page-name"/>     &lt;Button [text]="'fa-plus' | fonticon" class="fa action-item"&gt;&lt;/Button&gt;<br class="title-page-name"/>   &lt;/ActionItem&gt;<br class="title-page-name"/>&lt;/ActionBar&gt;<br class="title-page-name"/>&lt;ListView [items]="(mixer$ | async)?.compositions | orderBy: 'order'" class="list-group"&gt;<br class="title-page-name"/> &lt;ng-template let-composition="item"&gt;<br class="title-page-name"/>   &lt;GridLayout rows="auto" columns="100,*,auto" class="list-group-item"&gt;<br class="title-page-name"/>     &lt;Button [text]="'fa-pencil' | fonticon" (tap)="edit(composition)" row="0" col="0" class="fa"&gt;&lt;/Button&gt;<br class="title-page-name"/>     &lt;Label [text]="composition.name" (tap)="select(composition)" row="0" col="1" class="h2"&gt;&lt;/Label&gt;<br class="title-page-name"/>     &lt;Label [text]="composition.tracks.length" row="0" col="2" class="text-right"&gt;&lt;/Label&gt;<br class="title-page-name"/>   &lt;/GridLayout&gt;<br class="title-page-name"/> &lt;/ng-template&gt;<br class="title-page-name"/>&lt;/ListView&gt; </pre>
<p class="mce-root">We've included the code here so that you can see easily how we made the test with the details provided on the screen. </p>
<pre class="calibre22">// In JavaScript code, "use strict"; is highly recommended, <br class="title-page-name"/>// it enables JavaScript engine optimizations.<br class="title-page-name"/>"use strict";<br class="title-page-name"/><br class="title-page-name"/>// Load the Appium driver, this driver sets up our connection to Appium <br class="title-page-name"/>// and the emulator or device.<br class="title-page-name"/>const nsAppium = require("nativescript-dev-appium");</pre>
<p class="mce-root">We need to include the NativeScript Appium driver in our JavaScript test code; this is what is used to actually communicate and set up the Mocha, ShouldJS, WD, Appium, and Chia to be able to work properly. The following line alone is required for your usage:</p>
<pre class="calibre22">// Just like Jasmine, Mocha uses describe to start a testing group.<br class="title-page-name"/>describe("Simple example", function () {<br class="title-page-name"/><br class="title-page-name"/> // This is fairly important, you need to give the driver time to wait<br class="title-page-name"/> // so that your app has time to start up on the emulator/device.<br class="title-page-name"/> // This number might still be too small if you have a slow machine.<br class="title-page-name"/> this.timeout(100000);</pre>
<p class="mce-root">As the comments in the source code mention, it is critical that you give enough time to start up Appium and the application in your emulator. So, out personal default is <kbd class="calibre11">100,000</kbd>; you can play with this number, but this is the maximum amount of time it will wait before it will declare the tests a failure. Having a larger value means that you give your emulator and Appium more time to actually start running. Appium gives you its startup output quickly, but when it goes to actually initialize the test and driver, that process takes a lot of time. Once the test starts to run, it runs very fast:</p>
<pre class="calibre22"> // This holds the driver; that will be used to communicate with Appium &amp; Device.<br class="title-page-name"/> let driver;<br class="title-page-name"/><br class="title-page-name"/> // This is ran once before any tests are ran. (There is also a beforeEach)<br class="title-page-name"/> before(function () {<br class="title-page-name"/>    // VERY, VERY important line here; you NEED a driver to communicate to your device.<br class="title-page-name"/>    // No driver, no tests will work.<br class="title-page-name"/>    driver = nsAppium.createDriver();<br class="title-page-name"/> });</pre>
<p class="mce-root">It is also very important<span> to initialize and create the driver</span> before your tests are run. This driver is global throughout your tests. So, we will declare it globally in the <kbd class="calibre11">describe</kbd> function and then initialize it with the Mocha <kbd class="calibre11">before</kbd> function that runs before any tests are run:</p>
<pre class="calibre22">// This is ran once at the end of all the tests. (There is also a afterEach)<br class="title-page-name"/>after(function () {<br class="title-page-name"/><br class="title-page-name"/>  // Also important, the Appium system works off of promises<br class="title-page-name"/>  // so you return the promise from the after function<br class="title-page-name"/>  // NOTICE no ";", we are chaining to the next command.<br class="title-page-name"/>  return driver    <br class="title-page-name"/><br class="title-page-name"/>    // This tells the driver to quit....<br class="title-page-name"/>    .quit()<br class="title-page-name"/>    // And finally after it has quit we print it finished....<br class="title-page-name"/>    .finally(function () {<br class="title-page-name"/>       console.log("Driver quit successfully");<br class="title-page-name"/>    });<br class="title-page-name"/> });</pre>
<p class="mce-root">We also add a Mocha after function to shut down the driver when we are all done. It is very important to ensure that any time you are working with the driver that you properly return it. Almost every single test piece is actually a promise underneath it. If you forget to return the promise, the testing harness will get royally mixed up and may run tests out of order and even close the driver before the tests are completed. So, always return the promise:</p>
<pre class="calibre22">// Just like jasmine, we define a test here.<br class="title-page-name"/>it("should find the + button", function () {<br class="title-page-name"/><br class="title-page-name"/>  // Again, VERY important, you need to return the promise<br class="title-page-name"/>  <strong class="calibre1">return</strong> driver<br class="title-page-name"/><br class="title-page-name"/>  // This searches for an element by the Dom path; so you can find sub items.<br class="title-page-name"/> .elementByXPath("//" + nsAppium.getXPathElement('Button'))</pre>
<p class="mce-root">The <kbd class="calibre11">it</kbd> function is used just like we did in Jasmine--you are describing a test you plan on running so that you can find it if the test fails. Again, we return the promise chain; it is very important that you don't forget to do this. The driver variable is what gives us the different functionality when dealing with the emulators. So, the documentation for the functionality is in the WD repository, but I will give you a quick overview to get you going.</p>
<p class="mce-root"><kbd class="calibre11">.elementByXPath</kbd> and <kbd class="calibre11">.elementById</kbd> are really the only two functions that work well to properly find elements with NativeScript . However there is also a <kbd class="calibre11">.waitForElementByXPath</kbd> and <kbd class="calibre11">.waitForElementById</kbd> which both wait for the elements to show up. If you look at the documentation, you will observe a lot of <kbd class="calibre11">elementByXXX</kbd> commands, but Appium was designed for a browser, and NativeScript is not a browser. That is why, only some commands that have been emulated in the nativescript-dev-appium driver work to find elements in the NativeScript DOM.</p>
<p class="mce-root">So our test says find an element by XPath. XPath allows you to drill into your DOM and find components any level deep and also subcomponents of other components. So, if you do something like <kbd class="calibre11">/GridLayout/StackLayout/Label</kbd>, it will find a <kbd class="calibre11">Label</kbd> that is a child of a <kbd class="calibre11">StackLayout</kbd>, which is a child of a <kbd class="calibre11">GridLayout</kbd>. Using <kbd class="calibre11"><em class="calibre21">//</em></kbd> will mean that you can find that element at any level in the DOM. Finally the <kbd class="calibre11">nsAppium.getXPathElement</kbd> is a method which was added to the official NativeScript driver by Nathanael Anderson to allow us to make the XPath tests cross-platform. In all reality, what you are passing to the XPath function is the real native name of the object. For example, a button on Android is a <kbd class="calibre11">android.widget.Button</kbd> or it could be a <kbd class="calibre11">UIAButton</kbd> or a <kbd class="calibre11">XCUIElementTypeButton</kbd> <span>on iOS.</span> So because you don't want to hardcode <kbd class="calibre11">getByElementXPath("android.widget.Button")</kbd>, this helper function translates the NativeScript <kbd class="calibre11">Button</kbd> to the proper underlying OS element that NativeScript actually uses when it creates a button in NativeScript. If, in the future, you add a plugin that uses an element that the <kbd class="calibre11">getXPathElement</kbd> doesn't know about, you can still use the real name of the element for those tests:</p>
<pre class="calibre22">     // This element should eventually exist<br class="title-page-name"/>     .text().should.eventually.exist.equal('\uf067');<br class="title-page-name"/> });</pre>
<p class="mce-root"><kbd class="calibre11">.text()</kbd> is a function that Appium driver exposes to get the text value of the elements it finds. The <kbd class="calibre11">.should.eventually.exist.equal</kbd> is a Mocha and Should code. We are basically making sure that once this item is found, it actually matches the Unicode value of F067, which in Font-Awesome is the Plus character (fa-plus). Once it exists, we are happy--the test either succeeds or fails, depending on whether we break the screen or the screen continues to be the way we expect it. In addition, after the <kbd class="calibre11"><strong class="calibre1">.equal</strong></kbd>, we could have chained more commands, such as <kbd class="calibre11">.tap()</kbd>, to fire the button if we wanted.</p>
<p class="mce-root">Okay, let's look at the next test that runs:</p>
<pre class="calibre22">it("should have a Demo label", function () {<br class="title-page-name"/><br class="title-page-name"/>  // Again, VERY important, you need to return the promise<br class="title-page-name"/>  return driver<br class="title-page-name"/><br class="title-page-name"/>    // Find all Label elements, that has text of "Demo"<br class="title-page-name"/>   .elementByXPath("//" + nsAppium.getXPathElement("Label") + "[@text='Demo']")<br class="title-page-name"/><br class="title-page-name"/>   // This item should eventually exist<br class="title-page-name"/>   .should.eventually.exist<br class="title-page-name"/><br class="title-page-name"/>   // Tap it<br class="title-page-name"/>   .tap();<br class="title-page-name"/>});</pre>
<p class="mce-root">This test searches the screen to show the <kbd class="calibre11">Demo</kbd> ListView item. We are looking for a NativeScript Label (that is, <kbd class="calibre11">nsAppium.getXPathElement</kbd>) anywhere in the NativeScript DOM (that is, <kbd class="calibre11"><em class="calibre21">//</em></kbd>) that contains the text value of Demo in it. (that is, <kbd class="calibre11">[@text='Demo']</kbd>). This element should eventually exist, and once it does exist, it calls the <kbd class="calibre11">tap()</kbd> function. Now, if you look at the source code, you will see the following:</p>
<pre class="calibre22">&lt;Label [text]="composition.name" (tap)="select(composition)" row="0" col="1" class="h2"&gt;&lt;/Label&gt;</pre>
<p class="mce-root">So, it will run the select function when the <kbd class="calibre11">tap</kbd> is fired. The <kbd class="calibre11">select</kbd> function ends up ultimately loading the <kbd class="calibre11">/app/modules/player/components/track-list/track-list.component.html</kbd> file, which is used to display the composition of that mixer item on the screen.</p>
<div class="packt_infobox">All the tests are executed sequentially, and the state of the app is preserved from one test to another. This means that tests are not independent like we are used to when writing unit-tests.</div>
<p class="mce-root">The next test we will verify is that the <kbd class="calibre11">Demo</kbd> Label actually switches screens in the next test <span>after we tap on it</span>:</p>
<pre class="calibre22">it("Should change to another screen", function () {<br class="title-page-name"/><br class="title-page-name"/>   // As usual return the promise chain...<br class="title-page-name"/>   return driver<br class="title-page-name"/><br class="title-page-name"/>   // Find all Label elements, that has text of "Demo"<br class="title-page-name"/>   .waitForElementByXPath("//" + nsAppium.getXPathElement("Label") + "[@text='Drums']")<br class="title-page-name"/><br class="title-page-name"/>   // This item should eventually exist<br class="title-page-name"/>   .should.eventually.exist.text();<br class="title-page-name"/> });</pre>
<p class="mce-root">So, now that we are on a new screen, we will verify that the <kbd class="calibre11">ListView</kbd> contains a Label with the name of <kbd class="calibre11">Drums</kbd>. This test just verifies that the screen actually changed when we tapped on the <kbd class="calibre11">Demo</kbd> Label in the prior test. We could have verified the text value but really if it exists, we are good. So, let's look at the next test:</p>
<pre class="calibre22">it("Should change mute button", function () {<br class="title-page-name"/><br class="title-page-name"/>  // Again, returning the promise<br class="title-page-name"/>  return driver<br class="title-page-name"/><br class="title-page-name"/>  // Find all Label elements that contains the FA-Volume<br class="title-page-name"/>  .waitForElementByXPath("//" + nsAppium.getXPathElement("Label") + "[@text='\uf028']")<br class="title-page-name"/><br class="title-page-name"/>  // This item should eventually exist<br class="title-page-name"/>  .should.eventually.exist<br class="title-page-name"/><br class="title-page-name"/>  // It exists, so tap it...<br class="title-page-name"/>  .tap()<br class="title-page-name"/><br class="title-page-name"/>  // Make sure the text then becomes the muted volume symbol<br class="title-page-name"/>  .text().should.eventually.become("\uf026");<br class="title-page-name"/>});<br class="title-page-name"/><br class="title-page-name"/>// This closes the describe we opened at the top of this test set.<br class="title-page-name"/>});</pre>
<p class="mce-root">Our final example test shows chaining. We search the Label that has the volume control symbol. Then, once it exists, we tap on it. Then, we verify that the text actually became the volume off symbol. The <kbd class="calibre11">f028</kbd> is the Font Awesome Unicode value for <kbd class="calibre11">fa-volume-up</kbd>, and the <kbd class="calibre11">f026</kbd> is<span> the Font Awesome Unicode </span><span>value for</span> <kbd class="calibre11">fa-volume-off</kbd>.</p>
<p class="mce-root">So now that you have this really cool test, you want to launch your emulator. The emulator should be already running. You also should ensure that you have the latest version of the application on the device. Then, to run the test, simply type the following command:</p>
<pre class="calibre22"><strong class="calibre1">npm run appium --runType=android44</strong></pre>
<p class="mce-root">Ensure that you put in which run type configuration you are going to use, and you should see something like this after a few minutes:</p>
<div class="mce-root1"><img class="image-border48" src="../images/00058.jpeg"/></div>
<p class="mce-root">Remember that Appium end-to-end tests take a while to start, so if it looks like it is frozen for a while, don't panic and quit it. It may take 24 seconds for the first test, seconds for each additional test. The first test has all the time in it. It is normal for Appium to take a long time to start the driver and the application on the emulator. This delay normally occurs after you see the first couple of lines of text printed, as shown in the preceding screen, so, have some patience.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">More Appium testing</h1>
                
            
            <article>
                
<p class="mce-root">I wanted to include one more test (not used in this application) that I have written in the past for a different project since this will give you an idea of just how powerful Appium can be:</p>
<pre class="calibre22">it("should type in an element", function (done) {<br class="title-page-name"/>  driver<br class="title-page-name"/>  .elementByXPath('//' + nsAppium.getXPathElement("EditText") + "[@text='Enter your name']") <br class="title-page-name"/>  .sendKeys('Testing')<br class="title-page-name"/>  .text()<br class="title-page-name"/>  .then(function (v) {<br class="title-page-name"/>     if ('Testing' !== v) {<br class="title-page-name"/>        done(new Error("Value in name field does not match"));<br class="title-page-name"/>     } else {<br class="title-page-name"/>        done();<br class="title-page-name"/>     }<br class="title-page-name"/>   }, done);<br class="title-page-name"/> });<br class="title-page-name"/>});</pre>
<p class="mce-root">The first thing you might note is that I did not return the promise chain. That is because this example shows how to use the a<span>synchronous support of </span><kbd class="calibre11">it</kbd>. For an async support, you can use a promise or make the function coming into <kbd class="calibre11">it</kbd> have a <kbd class="calibre11">done</kbd> callback function. When Mocha detects a callback function in the <kbd class="calibre11">it</kbd>, it will run your <kbd class="calibre11">it</kbd> tests in the async mode and doesn't need the promise to let it know that it can resume with the next test. Sometimes, you may just want to maintain full control or you may be calling code that requires async callbacks.</p>
<p class="mce-root">This test looks for a <kbd class="calibre11">EditText</kbd> element that contains <kbd class="calibre11">Enter your name</kbd>. Then, it actually types <em class="calibre21">Testing</em> into it using the <kbd class="calibre11">sendKeys</kbd>. Next, it asks for the <kbd class="calibre11">text</kbd> out of the field and uses the <kbd class="calibre11">then</kbd> part of the promise to check the value against the hardcoded testing. When it is all finished, it calls the <kbd class="calibre11">done</kbd> function. If you pass the <kbd class="calibre11">done</kbd> function an <kbd class="calibre11">Error</kbd> object, then it knows that the test failed. So, you can see in the <kbd class="calibre11">if</kbd> statement that we passed a <kbd class="calibre11">new Error</kbd> and that we put the <kbd class="calibre11">done</kbd> function in the <kbd class="calibre11">catch</kbd> part of the <kbd class="calibre11">then</kbd> statement.</p>
<p class="mce-root">We have barely scratched the surface of what you can do with Appium, Should, Mocha, and Chia. You can control pretty much all aspects of the application as if you were manually doing each step. Initially, in your development, manually testing is a lot faster. However, as you start to build up end-to-end tests, each time you make changes, you can check whether the app still works properly, and you do not have to sit in front of multiple devices for any amount of time--you just start the tests and see the results later.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Automated testing</h1>
                
            
            <article>
                
<p class="mce-root">One more thing that you should note is that the more automated you make your testing, the more likely you are to use it and gain from its benefits. If you constantly have to manually run the test, you are likely to get annoyed and stop running them. So automating this is critical in our opinion. Since there are many books written on this subject we are just going to give you a couple of pointers that you can research and then move forward.</p>
<p class="mce-root">Most source control systems allow you to create hooks. With these hooks, you can create a commit hook so that on check-in of any new code, your testing frameworks will run. These hooks are normally pretty simple to create as they are simple scripts that just run each time a commit is made.</p>
<p class="mce-root">In addition, if you are using GitHub, there are sites such as Travis that you can tie into easily without having to do any hook changes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">GitHub and Travis integration</h1>
                
            
            <article>
                
<p class="mce-root">Here is how you can do some integration with GitHub and Travis; this will allow your NativeScript Testing framework, which we discussed in the preceding chapter, to automatically run your tests on each change or pull request. Create a new <kbd class="calibre11">.travis.yml</kbd> file in the very root of your GitHub repository. This file should look like this:</p>
<pre class="calibre22">language: android<br class="title-page-name"/><br class="title-page-name"/>jdk: oraclejdk8<br class="title-page-name"/><br class="title-page-name"/>android:<br class="title-page-name"/> components:<br class="title-page-name"/> - tools<br class="title-page-name"/> - platform-tools<br class="title-page-name"/> - build-tools-25.0.2<br class="title-page-name"/> - android-25<br class="title-page-name"/> - extra-android-m2repository<br class="title-page-name"/> - sys-img-armeabi-v7a-android-21<br class="title-page-name"/><br class="title-page-name"/>before_cache:<br class="title-page-name"/> - rm -f $HOME/.gradle/caches/modules-2/modules-2.lock<br class="title-page-name"/><br class="title-page-name"/>cache:<br class="title-page-name"/> directories:<br class="title-page-name"/> - .nvm<br class="title-page-name"/> - $HOME/.gradle/caches/<br class="title-page-name"/> - $HOME/.gradle/wrapper/<br class="title-page-name"/><br class="title-page-name"/>install:<br class="title-page-name"/> - nvm install node<br class="title-page-name"/> - npm install -g nativescript<br class="title-page-name"/> - tns usage-reporting disable<br class="title-page-name"/> - tns error-reporting disable<br class="title-page-name"/><br class="title-page-name"/>before_script:<br class="title-page-name"/> - echo no | android create avd --force -n test -t android-21 -b armeabi-v7a<br class="title-page-name"/> - emulator -avd test -no-audio -no-window &amp;<br class="title-page-name"/> - android-wait-for-emulator<br class="title-page-name"/><br class="title-page-name"/>script:<br class="title-page-name"/> - npm run travissetup<br class="title-page-name"/> - npm run travistest</pre>
<p class="mce-root">This basically configures Travis to start an Android emulator; it waits for the emulator to start and then runs the <kbd class="calibre11">npm</kbd> commands. You can learn what these <kbd class="calibre11">npm</kbd> commands do from your <kbd class="calibre11">package.json</kbd>.</p>
<p class="mce-root">So, in your root application, that is, the package.json file of your app, you want to add the following keys:</p>
<pre class="calibre22">"scripts": {<br class="title-page-name"/>   "travissetup": "npm i &amp;&amp; tns platform add android &amp;&amp; tns build android",<br class="title-page-name"/>   "travistest": "tns test android"<br class="title-page-name"/>}</pre>
<p class="mce-root">With these two changes, Travis will automatically test every single pull request to your repository, which then means that you can code, and Travis will continually do all your unit testing. </p>
<div class="packt_tip">In addition, you can change the preceding Travis configuration file to add Appium to be installed and run also just by doing the following:
<ul class="calibre39">
<li class="calibre38">Adding the Appium dependencies to your main <kbd class="calibre29">package.json</kbd> dependencies.</li>
<li class="calibre38">Adding to the root of your project a <kbd class="calibre29">appium.capabilities.json</kbd> that has a <kbd class="calibre29">travisAndroid</kbd> key.</li>
<li class="calibre38">Adding the <kbd class="calibre29">&amp;&amp; npm run appium --runType=travisAndroid</kbd> to your <kbd class="calibre29">travistest</kbd> key in the <kbd class="calibre29">package.json</kbd> file.</li>
</ul>
</div>
<p class="mce-root">GitHub already has the integration with Travis built-in, so it is simple to document and get it running. If you use Gitlabs, you can use the Gitlabs CI system to do testing. In addition, you can use the repository hooks to use a wide number of other continuous integration services that are available. Finally, you can also develop your own.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="mce-root">In this chapter, we covered how to install and run Appium, how to build complete end-to-end tests and how to use the testing frameworks to test your screens fully. In addition, we covered how important it is to automate the running of the unit testing and Appium, and one way you can do so is using Travis and GitHub.</p>
<p class="mce-root">Now hang on tight--we will make a quick turn and start discussing how to deploy and use Webpack to optimize your builds for release.</p>


            </article>

            
        </section>
    </body></html>