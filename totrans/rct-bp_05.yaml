- en: Chapter 5. Creating a Map App with HTML5 APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll cover a variety of HTML5 APIs with ReactJS, and we'll
    generate a map-based application that can run on your desktop browser as well
    as your mobile device.
  prefs: []
  type: TYPE_NORMAL
- en: 'In brief, these are the topics that we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of useful HTML5 APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The High Resolution Time API
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Vibration API
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Battery Status API
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Page Visibility API
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Geolocation API
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse geolocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static and interactive maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The state of HTML5 APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HTML5 specification has added a number of useful APIs that you may not have
    tried yet. The reason is likely to be a combination of lack of browser support
    and knowing that they exist. A lot of APIs have been introduced since the dawn
    of HTML5\. Some have reached stability; some are still up and coming; and sadly,
    some have fallen to the wayside and are about to be deprecated—like the highly
    promising getUserMedia API—or are not able to get enough traction to gain support
    on all browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the most interesting APIs available right now and how you
    can use them to create powerful web applications. We'll use several of these in
    the map application we will create later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The High Resolution Time API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your website loads too slowly, users will become frustrated and leave. Measuring
    the execution time and page load is therefore one of the most important aspects
    of user experience, but unfortunately, it's also one of the most difficult to
    troubleshoot.
  prefs: []
  type: TYPE_NORMAL
- en: For historical reasons, the most commonly used method of measuring page load
    is using the Date API to compare timestamps. This was the best tool available
    for a long time, but there are a number of problems with this approach.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript time is infamous for being inaccurate (for instance, some versions
    of Internet Explorer simply round down time representation if the results are
    less than a certain threshold, making it virtually impossible to retrieve correct
    measurements). The Date API can only be used once the code is running in the browser,
    which means that you cannot measure processes involving the server or network.
    It also introduces overhead and clutter in your code.
  prefs: []
  type: TYPE_NORMAL
- en: In short, you deserve a better tool, something that's native to the browser,
    provides fine precision, and doesn't clutter up your code base. Fortunately, all
    of this is already available to you in the form of the **High Resolution Time
    API**. It provides the current time in sub-millisecond resolution. Unlike the
    Date API, it is not subject to system clock skew or adjustments, and since it's
    native, no additional overhead is created.
  prefs: []
  type: TYPE_NORMAL
- en: The API exposes only one method, called `now()`. It returns a very accurate
    timestamp with a precision to a thousandth of a millisecond, allowing you to have
    accurate performance tests of your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s very easy to replace instances of your code where you use the Date API
    with the High Resolution Time API. For instance, the following code uses the Date
    API (and may log a positive or negative number, or zero):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar operation with `performance.now()` looks like the next segment and
    will not only be more accurate, but always positive as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As noted, the High Resolution Time API originally exposed only one method,
    but through the **User Timing API**, you can access a few more methods that let
    you measure performance without littering your code base with excess variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can fetch existing marks by type or name by calling either `performance.getEntriesByType(''measure'')`
    or `performance.getEntriesByType(''mark'')`. You can also get a list of all the
    entries by calling `performance.getEntries()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can easily get rid of any marks you've set up by calling `performance.clearMarks()`.
    Calling it with no value will clear all marks, but you can also remove single
    marks by calling `clearMarks()` with the mark you want to remove. The same goes
    for measures, using `performance.clearMeasure()`.
  prefs: []
  type: TYPE_NORMAL
- en: Using `performance.mark()` and `performance.measure()` is great for measuring
    the execution time of your code, but using them to measure page load is still
    rather clunky. To help troubleshoot page loads, a third API has been developed,
    which extends the High Resolution Time API even further. This is called the **Navigation
    Timing API** and provides measurements related to DNS lookup, TCP connection,
    redirects, DOM building, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: It works by recording the time when milestones in the page load process occur.
    There are many measured events given in milliseconds that can be accessed through
    the `PerformanceTiming` interface. You can easily use these records to calculate
    the many factors that surround page load time. For instance, you can measure the
    time taken for the page to be visible to the user by subtracting `timing.navigationStart`
    from `timing.loadEventEnd`, or measure how long the DNS lookup takes by subtracting
    `timing.domainLookupStart` from `timing.domainLookupEnd`.
  prefs: []
  type: TYPE_NORMAL
- en: The `performance.navigation` object also stores two attributes that can be used
    to find out whether a page load is triggered by a redirect, back/forward button,
    or normal URL load.
  prefs: []
  type: TYPE_NORMAL
- en: All of these methods combined enable you to find the bottlenecks in your application.
    We'll be using the API for debugging information and highlighting which parts
    of the app take the most time to load.
  prefs: []
  type: TYPE_NORMAL
- en: Browser support for these APIs vary. Both the **High Resolution Time API** and
    **Navigation Timing API** are supported by modern browsers, but the **Resource
    Timing API** is not supported by Safari or Safari Mobile, so you need to practice
    defensive coding in order to avoid `TypeErrors` preventing your page from working.
  prefs: []
  type: TYPE_NORMAL
- en: The Vibration API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Vibration API offers the ability to interact with the mobile device's built-in
    vibration hardware component. If the API is not supported, nothing will happen;
    therefore, it's safe to use on devices that do not support it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The API is activated by applying the `navigator.vibrate` method. It accepts
    either a single number to vibrate once or an array of values to alternately vibrate,
    pause, and then vibrate again. Passing a value of `0`, an empty array, or an array
    containing all zeros will cancel any currently ongoing vibration pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The API is targeted against mobile devices and has been around since 2012\.
    Android devices running Chrome or Firefox support the API, but there is no support
    for the API on Safari or on mobile, and it seems there never will be.
  prefs: []
  type: TYPE_NORMAL
- en: This is unfortunate because vibration has a number of valid use cases, for instance,
    to provide tactile feedback when the user interacts with buttons or form controls
    or to alert the user of a notification.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can, of course, also use it for fun, for instance, by playing a popular
    melody:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: A fun list of Vibration API tunes can be found at [https://gearside.com/custom-vibration-patterns-mobile-devices/](https://gearside.com/custom-vibration-patterns-mobile-devices/).
  prefs: []
  type: TYPE_NORMAL
- en: We'll be using the Vibration API in our map app to respond to button clicks.
  prefs: []
  type: TYPE_NORMAL
- en: The Battery Status API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Battery Status API lets you inspect the state of a device's battery and
    fire events about changes in battery level or status. This can be quite useful
    because we can use this information to disable battery-draining operations, and
    hold off on AJAX requests and other network-related traffic when the battery is
    running low.
  prefs: []
  type: TYPE_NORMAL
- en: The API exposes four methods and four events. The methods are `charging`, `chargingTime`,
    `dischargingTime`, and `level` and the events are `chargingchange`, `levelchange`,
    `chargingtimechange`, and `dischargingtimechange`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add event listeners to your `mount` method in order to respond to changes
    in battery status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s no need to add the event listeners if the browser doesn''t support
    the Battery API, so it''s a good idea to check that the `navigator` object contains
    `battery` before adding any event listeners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: These functions will fire anytime a change happens with your battery status.
  prefs: []
  type: TYPE_NORMAL
- en: The Battery API is supported by Firefox, Chrome, and the Android browser. Neither
    Safari nor IE support it.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use this in our map app to warn users about switching to static maps if
    the battery is running low.
  prefs: []
  type: TYPE_NORMAL
- en: The Page Visibility API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Page Visibility API lets us detect whether our page is visible or in focus,
    hidden, or not in focus (that is, either minimized or tabbed).
  prefs: []
  type: TYPE_NORMAL
- en: The API doesn't have any methods, but it exposes the `visibilitychange` event,
    which we can use to detect changes in the state of the page's visibility and two
    read-only properties, `hidden` and `visibilityState`. When a user minimizes the
    web page or moves to another tab, the API sends a `visibilitychange` event regarding
    the visibility of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can easily be added to your React component in the mount method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, you can monitor any changes in the page visibility in the `onVisibilityChange`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can use this to halt the execution of any network activity that isn't necessary
    when the user isn't actively using your page. You may also want to pause the execution
    if you're showing content, like an image carousel that shouldn't advance to the
    next slide unless the user is viewing the page, or if you're serving video or
    game content. When the user revisits your page, you can continue the execution
    seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: We won't be using this API in our map app, but we'll be sure to use it in [Chapter
    9](ch09.html "Chapter 9. Creating a Shared App"), *Creating a Shared App*, when
    we make a game that should pause when the player minimizes or tabs the window.
  prefs: []
  type: TYPE_NORMAL
- en: Browser support is excellent. The API is supported by all major browsers.
  prefs: []
  type: TYPE_NORMAL
- en: The Geolocation API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Geolocation API defines a high-level interface to locate information, such
    as latitude and longitude, which is linked to the device hosting it.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing where your user is located is a powerful tool and can be used to serve
    localized content, personalize ads or search results, and draw a map of your surroundings.
  prefs: []
  type: TYPE_NORMAL
- en: The API doesn't concern itself with the location source, so it is entirely up
    to the device as to where it gets its information. Common sources are GPS, location
    inferred from network signals, Wi-Fi, Bluetooth, MAC address, RFID, GSM cell ID,
    and so on; it includes manual user input as well. Because it can derive its information
    from so many sources, the API is usable from a number of devices, including cell
    phones and desktop computers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The API exposes three methods that belong to the `navigator.geolocation` object:
    `getCurrentPosition`, `watchPosition`, and `clearWatch`. Both `getCurrentPosition`
    and `watchPosition` perform the same task. The difference is that the first method
    performs a one-time request, while the latter continually monitors the device
    for changes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The coordinates contain these properties: `latitude`, `longitude`, `altitude`,
    `accuracy`, `altitudeAccuracy`, `heading`, and `speed`. Desktop browsers usually
    won''t report any values other than `latitude` and `longitude`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Retrieving a position returns an object with a timestamp and a set of coordinates.
    The timestamp lets you know when the location was detected, which can be useful
    if you need to know how fresh the data is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clearWatch` function can be called to stop monitoring if you''ve started
    `watchPosition`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This API will be central to our map application. In fact, we won't show the
    user any content unless we are able to get a current location. Browser support
    is fortunately excellent, since it's supported by all major applications.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our map app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the basic setup from the first chapter. As usual, we''ll
    be extending the scaffold with a few extra packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Most of these packages should be familiar to you. The ones we haven't used in
    the earlier chapters are `url`, `two utility functions from the` `lodash` library,
    and the leaflet `map` library. We'll use the `url` function for URL resolution
    and parsing. The `lodash` functions will come in handy when we need to compose
    a URL to the map service of our choice. Leaflet is an open source JavaScript library
    for interactive maps. We'll get back to it when we add an interactive map to our
    app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `devDependencies` section in `package.json` should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s open `public/index.html` and add some code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We'll need the Bootstrap CSS and the Leaflet CSS to display our maps properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also need to apply some styles, so open `public/app.css` and replace
    the content with the following style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first styles we add are a set of bouncing balls. These will be displayed
    while we're fetching content on the first load of the app, so it's important that
    they look good and that they convey to the user that something is happening. This
    set of code is provided by [http://tobiasahlin.com/spinkit/](http://tobiasahlin.com/spinkit/).
    On this site, you'll find a few more examples of simple loading spinners animated
    with hardware-accelerated CSS animations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create two different types of maps, one static and one interactive.
    We''re also going to set up zoom and exit buttons and make sure they look okay
    on smaller devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'These buttons let us zoom in and out when using static maps. They''re placed
    near the upper right-hand side of the screen, and they mimic the functionality
    of an interactive map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The media query makes some small alterations to the style to make sure the maps
    are visible and have a proper margin on small devices.
  prefs: []
  type: TYPE_NORMAL
- en: When you start your server now with `node server.js`, you should see a blank
    screen in your browser. We're ready to get on with our app.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up geolocation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll start by creating a service that fetches our reverse geolocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder called `service` in the source folder and call it `geo.js`.
    Add the following content to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We'll need the utilities we installed as part of the Bootstrap process. The
    `url utils` parameter will create a URL string for us based on a set of keys and
    properties. `Lodash pick` creates an object composed of the picked object properties,
    while `identity` returns the first argument provided to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also need to create a `config.json` file holding the parameters that
    we will use to construct the URL string, let''s take a look at the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We construct our request with a timeout. Superagent has a few other options
    you can set, such as accept headers, query parameters, and more, let''s take a
    look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a long-standing bug in Superagent where some errors (4xx and 5xx)
    aren''t set with the `err` object as documented, so we need to check both `err`
    and `res.error` in order to catch all the errors, let''s take a look at the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We will return our request through a `Promise` instance. `Promise` is an object
    that is used for deferred and asynchronous computations. It represents an operation
    that hasn't completed yet, but is expected to in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a file called `config.json` and place it in your source folder,
    and add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: OpenStreetMap is an openly licensed map of the world created by volunteers using
    local knowledge, GPS tracks, and donated sources. It is reported to have over
    2 million users who have collected data using manual survey, GPS devices, aerial
    photography, and other free sources.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be using the service to fetch reverse geolocation as well as use it in
    combination with Leaflet to create an interactive map in the later part of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make sure we can retrieve our current location and the reverse geolocation.
    Open `app.jsx` and replace the content with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to use all of these state variables in our app eventually, but
    the ones we''ll update and use now are `locationFetched`, `lon`, and `lat`. The
    state of the first variable will decide whether we''ll show a loading animation
    or a result from the geo lookups, let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We set up a marker before we call the function that fetches the current position
    and the reverse geolocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the one-time request from `navigator.geolocation` to fetch the user''s
    current position. We then store this in our component state. We also send a call
    to `fetchReverseGeo` with the coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be used to display an alert a little bit later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re done with fetching data, so let''s measure how long it took. We can
    fetch the time by using the `fetch_geo_time` keyword anytime we want, as it appears
    in the preceding code. Now, consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'After we receive the position, we store it in our component state, and for
    the browser and devices that have vibration support, we send off a short vibration
    to let the user know the app is ready to be used. Refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When we catch an error, we store the error message as part of our component
    state. We will either receive the error as an object with a message property or
    as a string, so we make sure that we check this before storing it. Moving on to
    the next part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the event that any of the third-party services we rely on are down or unavailable,
    we short circuit the app and display an error message, as shown in the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We present the SpinKit bouncing balls in this block. It is always shown before
    all necessary data is fully loaded, let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We let the user know that we got a set of coordinates and a real world address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This `if`-`else` block will either show a map of the world, static or interactive,
    depending on the user's choice; alternatively, it will display a set of buttons
    and the option to select a new location.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also have used routing to toggle between these choices. But this would
    mean setting up a map route, a home route, and so on. This is often a good idea,
    but it''s not always necessary, and this app shows how you can structure a simple
    app without the use of routing, let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We display the debug information from the High Resolution Time API here. We
    delegate each section into a function. This is called separation of concerns.
    The purpose is to encapsulate sections of code to increase modularity and simplify
    development. When reading the code, it''s much easier to understand that when
    the program asks for {this.debugDNSLookup()}, it returns some information about
    the DNS lookup time. If we inlined the function, it would be harder to understand
    the purpose of the code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In each of the debug functions, we check whether the performance object has
    support for the method we want to use. Most modern browsers support the High Resolution
    Time API, but support for the User Timing API is more spotty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The math operation converts the time in milliseconds into seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If an error occurs, for instance, if the SuperAgent request call fails, we
    display an error message instead of providing any content, let''s take a look
    at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll show a set of bouncing balls until we have a position and a location,
    let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything is good, we render the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: When you've added this code, you should see the app start with a set of bouncing
    balls. Then, after it has fetched your location, you should see your coordinates
    in longitude and latitude values as well as your real location address. Below
    this, you should see a few lines of debug information.
  prefs: []
  type: TYPE_NORMAL
- en: 'One note about the largesse of this component: When writing components or indeed
    any code, the need to refactor increases roughly in tandem with the time you spend
    writing it. This component is a prime example because it now contains a lot of
    different logic. It does geolocation, debugging, as well as rendering. It would
    be wise to split it up into several different components for separation of concerns,
    as talked about in the comment to the renderContent() method. Let''s take a look
    at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up geolocation](img/B04943_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The location should be quite accurate, and thanks to the comprehensive list
    of real-world addresses in OpenStreetMap, the translation to your current location
    should also be fairly close to where you are as well.
  prefs: []
  type: TYPE_NORMAL
- en: The debug information lets you know how much time it takes from when the app
    is loaded until the view is ready. When running on localhost, **DNS** and **connection
    lookup** are always loaded in 0 milliseconds, instantaneously. When you are running
    your app on an external server, these numbers will go up and reflect how much
    time it would take to lookup your server and connect to it.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you'll notice it doesn't take much time before
    the page is loaded and ready to be served. The really slow part of it is the amount
    of time you spend waiting for the app to fetch location data from reverse geolocation.
    As per the screenshot, it took approximately 1.5 seconds. This number will usually
    fluctuate between 1-10 seconds, and you won't be able to reduce it unless you
    find a way to cache the request.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know we are able to fetch the user position and address, let's create
    some maps.
  prefs: []
  type: TYPE_NORMAL
- en: Showing static maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A static map is simply an image snapshot of your chosen position. Using static
    maps has many benefits over interactive maps, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: No overhead. It's a plain image, so it's both fast and lightweight.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can pre-render and cache the map. This means less hits to the map provider
    and that you might get away with a smaller data plan.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static also means that you have complete control of the map. Using a third-party
    service often means surrendering some control to the service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a number of map providers that we can use to show maps of the world
    in addition to OpenStreetMap. Among those are Yahoo! Maps, Bing Maps, Google Maps,
    MapQuest, and more.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be setting up our app to connect to a few of these services, so you can
    compare and decide which one you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open `config.json` again and add a few more endpoints. Add this just
    before the closing bracket of the file (make sure to add a comma after `openstreetmap`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: For `Bing` and `mapQuest`, you need to set the `providerKey` key before you
    can use them. For Bing Maps, go to the **Bing Maps Dev Center** at [https://www.bingmapsportal.com/](https://www.bingmapsportal.com/),
    sign in, select **Keys** under **My Account**, and add an application to receive
    a key.
  prefs: []
  type: TYPE_NORMAL
- en: For mapQuest, go to [https://developer.mapquest.com/plan_purchase/steps/business_edition/business_edition_free](https://developer.mapquest.com/plan_purchase/steps/business_edition/business_edition_free)
    and create a free account. Create an application and retrieve your key.
  prefs: []
  type: TYPE_NORMAL
- en: For Google, go to [https://developers.google.com/maps/documentation/static-maps/get-api-key](https://developers.google.com/maps/documentation/static-maps/get-api-key)
    and register a free API key.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use the endpoints, we''ll need to set up a service and a factory.
    Create `source/service/map-factory.js` and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create `source/service/map-service.js` and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We'll send `param` in the name of the provider, and we'll fetch the configuration
    data based on this.
  prefs: []
  type: TYPE_NORMAL
- en: The map providers have different requirements for how you should join the size
    parameter, so we take the width and the height and join them based on the value
    in the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'All providers agree that latitude and longitude should be joined by a comma,
    so we set up a location variable in this format. Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This snippet will add any markers you''ve configured in `config.json`. We''ll
    only use this variable if there are any configured markers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll add the key and set the map type from the configuration. Bing calls
    the markers pushpin, so this variable is only used in Bing Maps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We'll set up two different URLs based on whether we're serving a Bing Map or
    a map from any other provider. Notice that we're using ES6 template strings to
    compose our URL. These are composed with backticks and use string substitution
    with the `${ }` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s a different method than the one we used in `source/service/geo.js`, and
    in truth, we could have gone with the same approach here. Finally, we pass along
    the `id` variable from `params` and the finished map URL to our return function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to create a view for the static maps. What we''ll do is create
    three buttons that will enable us to open a map for our current location with
    all three map providers. Your app should look something like the one in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing static maps](img/B04943_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a folder called `views` under the `source` folder, add a file called
    `static-map.jsx`, and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'As seen in the preceding code, we''ll allow zooming as long as it''s between
    1 and 18\. We''ll use the current height and width of the device to set up our
    map canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'These buttons will allow us to increase or decrease zoom, or exit back to the
    main menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You may wonder if there's any particular reason why we put this file in a `view`
    folder while the other files went into the `component` folder. There's not a programmatic
    reason for it. All files could be put into the component folder, and React wouldn't
    bat an eye. The purpose is to provide the programmer with a clue on how the data
    is meant to be structured, hopefully making it easier to understand when going
    back and editing the project.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to create a component called `static-map` that will take our map
    properties and serve along a valid image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder called `components`, add a new file called `static-map.jsx`,
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `location` object contains our map URL and all of the associated data that
    the `map-factory` parameter has produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This is all the plumbing we need to present our static maps. Let's open up `app.jsx`
    and add the code that will tie these files together.
  prefs: []
  type: TYPE_NORMAL
- en: 'In between the two rows in the `render` method, add a new row with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In our previous apps, we used routes to navigate back and forth, but this time,
    we're going to skip routes altogether and use these variables to show different
    states of our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re also going to need to add the two referenced functions, so add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of the file, add these two imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'And then finally, add the two functions referenced in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `goBack` method simply nulls the provider. This will toggle whether we see
    the buttons or a map in the main view render.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you open your app now, you''ll see three different buttons enabling you
    to open a map of your current location with either Google Maps, Bing Maps, or
    MapQuest. The picture will show the current location in Bing Maps, as in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing static maps](img/B04943_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Without some clever hardcoding, you can't open any location other than your
    own. Let's create an input box that lets you select a different location based
    on longitude and latitude and a select box that will conveniently set the location
    to any of a predefined number of world cities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these functions to `app.jsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'As seen in the preceding code, valid longitude values are between negative
    *180* and positive *180* degrees. We''ll fetch the current values passed to us
    from the `event` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Valid latitude values are between negative *90* and positive *90* degrees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever the user clicks on the **Fetch** button, we execute a new reverse
    geolocation search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the new geolocation search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Above the header with static maps in `render()`, add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This alert will only be shown if the user tries to fetch a set of invalid coordinates.
    It will automatically disappear after 2,500 milliseconds, let''s take a look at
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing static maps](img/B04943_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating an interactive map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interactive maps offer a level of interactivity that is often expected by users
    presented with a map on a website.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of benefits in displaying an interactive map instead of
    a plain image:'
  prefs: []
  type: TYPE_NORMAL
- en: You can set markers outside the current viewport. It's perfect when you want
    to display a small map, but provide information about locations that can be discovered
    by moving or zooming the map.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactive maps provide a playground for your users, making it more likely
    that they'll spend time at your site.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactive content generally makes the app feel better compared to static content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our interactive map, we'll be using a combination of `Leaflet` and `OpenStreetMap`.
    They're both open source and free resources, making them an excellent choice for
    our budding map app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file in `source/views` and call it `interactive-map.jsx`. Add
    the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The Leaflet package fetches image tiles from `openstreetmap.org` with `x`,
    `y`, and `zoom` parameters. Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This is the function we use when creating a map. We set the view with our chosen
    latitude, longitude, and zoom, and add a marker to the middle of the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'More markers can be added by passing a `location` object to the internal `setMarker`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'On mounting it, we create a map with the internal function `createMap`, unless
    we pass along an external function via `props`, such as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We use inline styles to set the height of the map to 200 pixels less than the
    height of the viewport:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll notify the user if we notice that the battery is running low on the
    device. To continually monitor the battery status, we''d need to set up an event
    listener described earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open `app.jsx` and add the following code snippet at the end of `renderButtons()`,
    just above the closing `<div />`, such as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, replace the code in `renderMapView()` with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the interactive-map view to the `import` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an interactive map](img/B04943_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You should now be able to load the app and click on the **Interactive Map**
    button and be presented with an interactive map of your location. You can pinch,
    move, and zoom the map, and it will work on a smartphone or a tablet as well as
    on your desktop browser.
  prefs: []
  type: TYPE_NORMAL
- en: You can extend this map with new markers and even different tiles. We've used
    OpenStreetMap throughout this app, but it's very easy to switch out. Take a look
    at [https://leaflet-extras.github.io/leaflet-providers/preview/](https://leaflet-extras.github.io/leaflet-providers/preview/)
    for an overview of what kind of tiles you can use.
  prefs: []
  type: TYPE_NORMAL
- en: There's also a wide array of plugins to choose from, and you'll find those at
    [http://leafletjs.com/plugins.html](http://leafletjs.com/plugins.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined the state of several useful HTML5 APIs. We then
    put them to good use when creating a map application that serves both static and
    interactive maps.
  prefs: []
  type: TYPE_NORMAL
- en: The static maps are set up to use a variety of different proprietary services,
    while the interactive map is set up to use the free and open maps service, OpenStreepMap,
    using a popular library called Leaflet.
  prefs: []
  type: TYPE_NORMAL
- en: You can extend the interactive map by adding markers for a set of queries. For
    instance, you could use a service such as Google Maps to fetch a list of restaurants
    (Sushi restaurants, for example), and add a fish marker to each location using
    the Leaflet library. The possibilities are endless.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The finished project can be viewed online at [https://reactjsblueprints-chapter5.herokuapp.com](https://reactjsblueprints-chapter5.herokuapp.com).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will create an application that requires the user to
    create an account and log in to take advantage of all the features of the app.
  prefs: []
  type: TYPE_NORMAL
