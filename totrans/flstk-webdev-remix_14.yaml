- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Real Time with Remix
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时与Remix
- en: The web platform offers standards and capabilities to send data in real time.
    With real-time technologies, we can implement chat features and multiplayer UIs
    for real-time collaboration and interactions. We have seen several apps with real-time
    features grow in popularity and redefine their product categories, such as Google
    Docs and Figma. In this chapter, we will learn about real-time UIs with Remix.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 网络平台提供了发送实时数据的标准和能力。通过实时技术，我们可以实现聊天功能和多人UI，以实现实时协作和交互。我们已经看到几个具有实时功能的App在受欢迎程度上增长，并重新定义了它们的产品类别，例如Google
    Docs和Figma。在本章中，我们将学习使用Remix的实时UI。
- en: 'This chapter is split into two sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为两个部分：
- en: Working with real-time technologies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与实时技术一起工作
- en: Building real-time UIs with Remix
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Remix构建实时UI
- en: First, we will compare real-time technologies and discuss the requirements for
    hosting providers and server environments. Next, we will outline implementations
    with Remix. Finally, we will implement a simple real-time UI in BeeRich by utilizing
    **Server-Sent** **Events** (**SSE**).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将比较实时技术并讨论托管提供商和服务器环境的要求。接下来，我们将概述使用Remix的实现。最后，我们将通过利用**服务器发送事件**（**SSE**）在BeeRich中实现一个简单的实时UI。
- en: After reading this chapter, you will understand the requirements for working
    with real-time technologies in Remix. You will also be able to name the differences
    between polling, SSE, and WebSocket. Finally, you will know how to work with SSE
    in Remix.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，您将了解在Remix中与实时技术一起工作的要求。您还将能够命名轮询、SSE和WebSocket之间的区别。最后，您将了解如何在Remix中使用SSE。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code for this chapter here: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/14-real-time-with-remix](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/14-real-time-with-remix).
    No additional setup is required for this chapter.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章的代码：[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/14-real-time-with-remix](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/14-real-time-with-remix)。本章不需要进行额外的设置。
- en: Working with real-time technologies
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与实时技术一起工作
- en: The web platform offers different protocols and standards for real-time communication.
    In this section, we will review different technologies and techniques and discuss
    the requirements for utilizing them with Remix. We will discuss polling, learn
    about SSE, and review the WebSocket API. First, let’s have a look at polling techniques.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 网络平台为实时通信提供了不同的协议和标准。在本节中，我们将回顾不同的技术和方法，并讨论使用Remix利用它们的要求。我们将讨论轮询，了解SSE，并回顾WebSocket
    API。首先，让我们看看轮询技术。
- en: Understanding polling
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解轮询
- en: Polling is a client-pull technique in which the client requests data from the
    server. Instead of relying on a server to push updates, polling utilizes intervals
    to check for the latest data from the server.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询是一种客户端拉取技术，其中客户端从服务器请求数据。而不是依赖服务器推送更新，轮询通过间隔来检查服务器上的最新数据。
- en: We can differentiate between short and long polling. Short polling sends requests
    in time-based intervals to the server. The server responds immediately, either
    with new data or indicating nothing has changed. With long polling, the server
    only responds once new data is available, keeping the request unanswered until
    then. The client sends a new request once the server responds or the request times
    out.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以区分短轮询和长轮询。短轮询在基于时间的间隔内向服务器发送请求。服务器立即响应，要么提供新数据，要么表示没有变化。长轮询中，服务器只有在有新数据可用时才响应，在此期间保持请求未回答。一旦服务器响应或请求超时，客户端就会发送新的请求。
- en: The advantage of polling is that it does not require the server environment
    and hosting provider to support WebSockets, HTTP/2, or long-running streaming
    responses. Polling can be a great compromise when working with server environments
    and hosting providers that do not support real-time protocols and standards. It
    is also simpler to implement and potentially a great tool for prototyping.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询的优势在于它不需要服务器环境和托管提供商支持WebSocket、HTTP/2或长时间运行的流式响应。当与不支持实时协议和标准的服务器环境和托管提供商一起工作时，轮询可以是一个很好的折衷方案。它也更容易实现，并且可能是一个很好的原型设计工具。
- en: The disadvantage of polling is its wasteful resource consumption and delayed
    real-time behavior. Short polling creates many unnecessary requests that yield
    no new data, while long polling forces the server to handle idle requests until
    new data is received. Short polling may also delay real-time updates based on
    the interval retry time.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询的缺点是资源消耗浪费和延迟的实时行为。短轮询会产生许多不必要的请求，而长轮询则迫使服务器处理空闲请求，直到接收到新数据。短轮询还可能基于间隔重试时间延迟实时更新。
- en: Next, let’s have a look at SSE.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 SSE。
- en: Understanding SSE
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 SSE
- en: SSE is an HTTP-based server push standard and part of the HTML5 spec. SSE requires
    both a client and a server. The client requests a connection using the `EventSource`
    API; the server implements an endpoint that returns a stream response with the
    `text/event-stream` media type.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: SSE 是一种基于 HTTP 的服务器推送标准，是 HTML5 规范的一部分。SSE 需要客户端和服务器。客户端使用 `EventSource` API
    请求连接；服务器实现一个端点，返回带有 `text/event-stream` 媒体类型的流式响应。
- en: The stream response creates a one-way communication line from the server to
    the client. This allows the server to send events to the client without the need
    for the client to use polling.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 流式响应从服务器到客户端创建了一条单向通信线路。这允许服务器向客户端发送事件，而无需客户端使用轮询。
- en: The advantage of SSE is reduced resource consumption. The client does not need
    to send unnecessary requests to the server. Instead, the server only sends events
    to the client once an update is available.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: SSE 的优势在于减少了资源消耗。客户端不需要向服务器发送不必要的请求。相反，服务器只在有更新可用时向客户端发送事件。
- en: The disadvantage of SSE is the long-running HTTP connection, which needs to
    be maintained by the server. Additionally, SSE only provides a one-way communication
    line. The client is not able to send messages to the server. Finally, HTTP/1 only
    allows servers to maintain six concurrent connections at a time. Luckily, most
    server environments support HTTP/2, but the HTTP/1 limitation may still be relevant,
    depending on your hosting provider.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: SSE 的缺点是长时间运行的 HTTP 连接，需要服务器维护。此外，SSE 只提供单向通信线路。客户端无法向服务器发送消息。最后，HTTP/1 只允许服务器同时维护六个并发连接。幸运的是，大多数服务器环境支持
    HTTP/2，但 HTTP/1 的限制可能仍然相关，具体取决于您的托管提供商。
- en: Understanding WebSocket
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 WebSocket
- en: WebSocket is a communication protocol that’s implemented through the web’s WebSocket
    API and creates a persistent two-way communication line. Unlike SSE and polling
    solutions, WebSocket operates directly on TCP rather than HTTP.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 是一种通过 Web 的 WebSocket API 实现的通信协议，它创建了一个持久的双向通信线路。与 SSE 和轮询解决方案不同，WebSocket
    直接在 TCP 上操作，而不是 HTTP。
- en: Once a WebSocket connection has been established, both parties (for example,
    the browser and the server) can send and receive messages simultaneously. Since
    the protocol operates on TCP, it can transfer not only UTF-8-encoded data but
    also binary data, making it a performant lower-level protocol.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了 WebSocket 连接，双方（例如，浏览器和服务器）可以同时发送和接收消息。由于该协议在 TCP 上运行，它可以传输不仅 UTF-8 编码的数据，还可以传输二进制数据，使其成为一种性能强大的低级协议。
- en: The advantage of WebSocket connections is their two-way communication channel
    and the increased performance from using TCP directly. However, WebSocket connections
    are not supported by all hosting providers and JavaScript runtimes as they require
    long-running servers. The WebSocket API is also the most complex to implement
    and utilize, requiring the setup of a WebSocket server.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 连接的优势在于其双向通信通道和直接使用 TCP 的性能提升。然而，WebSocket 连接并不被所有托管提供商和 JavaScript
    运行时支持，因为它们需要长时间运行的服务器。WebSocket API 也是最复杂实现和利用的，需要设置 WebSocket 服务器。
- en: All three techniques enable us to implement real-time capabilities. Polling
    lets us build multiplayer UIs, even if our server environment does not support
    streaming responses or setting up WebSocket servers. SSE provides a simpler way
    for the server to send events and data to the client. The WebSocket API is a lower-level
    protocol that allows us to create bi-directional communication channels capable
    of creating performant and scalable multiplayer UIs.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种技术使我们能够实现实时功能。轮询允许我们构建多人 UI，即使我们的服务器环境不支持流式响应或设置 WebSocket 服务器。SSE 为服务器向客户端发送事件和数据提供了一种更简单的方式。WebSocket
    API 是一种低级协议，允许我们创建双向通信通道，从而创建性能强大且可扩展的多人 UI。
- en: Now that you understand the differences between polling, SSE, and the WebSocket
    API, we can implement a real-time UI in BeeRich. In the next section, we will
    do just that.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了轮询、SSE 和 WebSocket API 之间的区别，我们可以在 BeeRich 中实现实时 UI。在下一节中，我们将这样做。
- en: Building real-time UIs with Remix
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Remix 构建实时 UI
- en: BeeRich uses Remix’s Express.js adapter and runs on a long-running server. As
    such, BeeRich can take advantage of polling, SSE, and the WebSocket API to implement
    real-time features.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: BeeRich 使用 Remix 的 Express.js 适配器，并在一个长时间运行的服务器上运行。因此，BeeRich 可以利用轮询、SSE 和 WebSocket
    API 来实现实时功能。
- en: 'Short polling is simple to set up. We can implement short polling in Remix
    by using Remix’s `useRevalidator` hook:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 短轮询设置简单。我们可以在 Remix 中通过使用 Remix 的 `useRevalidator` 钩子来实现短轮询：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `revalidate` function of the `useRevalidator` hook triggers a `loader` revalidation.
    This allows us to refetch all loader data, similar to how Remix refetches all
    loader data after executing an `action` function.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`useRevalidator` 钩子的 `revalidate` 函数会触发 `loader` 的重新验证。这允许我们重新获取所有 loader 数据，类似于
    Remix 在执行 `action` 函数后重新获取所有 loader 数据的方式。'
- en: Since the WebSocket protocol is TCP-based, we would need to create the WebSocket
    server and endpoint outside of our Remix application using the `server.js` file
    at the root of our project or using a different server environment altogether.
    This is doable but outside the scope of this book. Instead, we will review how
    to use SSE with Remix.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 WebSocket 协议是基于 TCP 的，我们需要在 Remix 应用程序之外使用项目根目录下的 `server.js` 文件或使用完全不同的服务器环境来创建
    WebSocket 服务器和端点。这是可行的，但超出了本书的范围。相反，我们将回顾如何使用 SSE 与 Remix 一起使用。
- en: Remix’s `loader` and `action` functions can create HTTP-based resource routes.
    We can implement an SSE endpoint on a long-running server environment by using
    a `loader` function to return a stream response with the `text/event-stream` media
    type.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 的 `loader` 和 `action` 函数可以创建基于 HTTP 的资源路由。我们可以在长时间运行的服务器环境中通过使用 `loader`
    函数返回带有 `text/event-stream` 媒体类型的流响应来实现 SSE 端点。
- en: 'We aim to inform all devices and open browser tabs that are logged in with
    the same user of expense and invoice data changes. We also want to revalidate
    the UI whenever such a change is detected. Let’s get started:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是通知所有使用相同用户登录的设备和打开的浏览器标签页，告知支出和发票数据的变化。我们还希望在检测到此类更改时重新验证 UI。让我们开始吧：
- en: First, create a new `server-sent-events` folder in `app/modules/`.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `app/modules/` 中创建一个新的 `server-sent-events` 文件夹。
- en: 'Next, create an `events.server.ts` file in the new folder and add the following
    code:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在新建的文件夹中创建一个 `events.server.ts` 文件，并添加以下代码：
- en: '[PRE1]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We use the `EventEmitter` API from Node.js and declare a globally accessible
    event emitter for our server environment. The `EventEmitter` object can be used
    to listen to and emit events. We will utilize the `emit` function in our `action`
    functions to communicate data changes to the server-sent event connection handler
    code.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 Node.js 的 `EventEmitter` API 并为我们的服务器环境声明一个全局可访问的事件发射器。`EventEmitter` 对象可用于监听和发出事件。我们将在
    `action` 函数中使用 `emit` 函数将数据更改通知给服务器发送事件连接处理代码。
- en: Note that the `EventEmitter` API has nothing to do with SSE but provides a neat
    way for event-based communication in our Node.js server environment.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`EventEmitter` API 与 SSE 没有关系，但它为我们的 Node.js 服务器环境提供了一种基于事件的通信的便捷方式。
- en: 'Now, implement an `eventStream` helper function in `events.server.ts`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `events.server.ts` 中实现一个 `eventStream` 辅助函数：
- en: '[PRE2]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, implement the endpoint responsible for delivering the event stream response.
    Create a new `/sse.tsx` route in the `/``routes` folder:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，实现负责提供事件流响应的端点。在 `/routes` 文件夹中创建一个新的 `/sse.tsx` 路由：
- en: '[PRE3]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, add the global `emitter` object to all expense and invoice `action` functions.
    Whenever an action succeeds, we want to emit the `server-change` event on the
    server and trigger a new event to all connected clients:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将全局 `emitter` 对象添加到所有支出和发票 `action` 函数中。每当操作成功时，我们希望在服务器上发出 `server-change`
    事件并触发对所有连接客户端的新事件：
- en: '[PRE4]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For instance, in the `action` function of the `dashboard.expenses._index.tsx`
    route module, add the event emitter call before returning the redirect. This ensures
    the event is only emitted after the action has succeeded and the database has
    been updated:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，在 `dashboard.expenses._index.tsx` 路由模块的 `action` 函数中，在返回重定向之前添加事件发射器调用。这确保了事件仅在操作成功且数据库已更新后发出：
- en: '[PRE5]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: import { emitter } from '~/modules/server-sent-events/events.server';
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: import { emitter } from '~/modules/server-sent-events/events.server';
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After adding the `emit` function call to the expense and invoice creation actions,
    add `emit` function calls to the `handleDelete`, `handleUpdate`, and `handleRemoveAttachment`
    functions in the `dashboard.expenses.$id._index.tsx` route module. Again, call
    `emit` after the data mutation has succeeded to avoid race conditions.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将`emit`函数调用添加到费用和发票创建操作之后，将`emit`函数调用添加到`dashboard.expenses.$id._index.tsx`路由模块中的`handleDelete`、`handleUpdate`和`handleRemoveAttachment`函数。再次强调，在数据修改成功后调用`emit`以避免竞争条件。
- en: Make sure you also apply the same changes to the invoice `action` functions.
    You can always review the final implementation in the solution folder of this
    chapter.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你也将相同的更改应用到发票的`action`函数中。你总是可以在本章的解决方案文件夹中查看最终的实现。
- en: 'Let’s turn our attention to the client environment. Add a new `event-source.tsx`
    file in the `app/modules/server-sent-events` folder and implement the event stream
    connection request:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们把注意力转向客户端环境。在`app/modules/server-sent-events`文件夹中添加一个新的`event-source.tsx`文件，并实现事件流连接请求：
- en: '[PRE7]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, import the new hook in the `dashboard.tsx` route module and call the
    hook in the route module component:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`dashboard.tsx`路由模块中导入新的钩子，并在路由模块组件中调用该钩子：
- en: '[PRE8]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the application locally by calling `npm run dev` in a terminal.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中通过调用`npm run dev`来本地运行应用程序。
- en: Test the implementation by opening BeeRich in two or more tabs. You can also
    run BeeRich in several browsers to investigate the real-time behavior. Log in
    as the same user and update and delete invoices and expenses. Do you see how the
    expense history grows with every change in real time? Can you see the UI update
    across the different windows and tabs?
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在两个或更多标签页中打开BeeRich来测试实现。你还可以在几个浏览器中运行BeeRich以调查实时行为。以相同用户身份登录并更新和删除发票和费用。你能看到费用历史记录随着每次实时变化而增长吗？你能看到不同窗口和标签页中的UI更新吗？
- en: 'Great work! Just like that, we can implement real-time UIs in Remix. However,
    the current implementation has one notable issue: the client that calls the `action`
    function revalidates its UI twice – one time using Remix’s built-in revalidation
    step and once after receiving the server-sent event. This puts an extra burden
    on the server and the user’s network bandwidth. Do you have an idea of how we
    could avoid the double revalidation?'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！就这样，我们可以在Remix中实现实时UI。然而，当前的实现有一个显著的问题：调用`action`函数的客户端会重新验证其UI两次——一次是使用Remix的内置重新验证步骤，另一次是在接收到服务器发送的事件后。这给服务器和用户的网络带宽带来了额外的负担。你有没有想法如何避免双重重新验证？
- en: 'Consider implementing this yourself to practice working with SSE in Remix!
    Maybe you can use a unique connection identifier to avoid the server-sent event
    revalidation in the browser tab that mutates the data. You could add the identifier
    to the server-sent event payload and compare it with a local version stored on
    the client. Alternatively, you could use Remix’s `shouldRevalidate` route module
    API to avoid Remix’s built-in revalidation after `action` function calls that
    trigger the server-sent events. Refer to the Remix documentation for more information
    about the `shouldRevalidate` function: [https://remix.run/docs/en/2/route/should-revalidate#shouldrevalidate](https://remix.run/docs/en/2/route/should-revalidate#shouldrevalidate).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑自己实现它以练习在Remix中使用SSE！也许你可以使用一个唯一的连接标识符来避免在修改数据的浏览器标签页中重新验证服务器发送的事件。你可以在服务器发送事件的有效负载中添加该标识符，并与客户端上存储的本地版本进行比较。或者，你可以使用Remix的`shouldRevalidate`路由模块API来避免在触发服务器发送事件的`action`函数调用后Remix内置的重新验证。有关`shouldRevalidate`函数的更多信息，请参阅Remix文档：[https://remix.run/docs/en/2/route/should-revalidate#shouldrevalidate](https://remix.run/docs/en/2/route/should-revalidate#shouldrevalidate)。
- en: In this section, you implemented an SSE endpoint in BeeRich to revalidate loader
    data whenever the user mutates data in an `action` function across different tabs,
    browsers, and devices.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你在BeeRich中实现了一个SSE端点，以便在用户在不同标签页、浏览器和设备上的`action`函数中修改数据时重新验证加载器数据。
- en: Summary
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about real-time technologies and techniques and
    how to use them in Remix.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了关于实时技术和技巧，以及如何在Remix中使用它们。
- en: First, we discussed polling, SSE, and the WebSocket API and compared their advantages
    and disadvantages. Polling is the easiest to set up. A simple polling implementation
    does not require changes on the server. SSE provides a one-way communication line
    using the HTTP protocol, while WebSocket connections use TCP and are bi-directional.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们讨论了轮询、SSE 和 WebSocket API，并比较了它们的优缺点。轮询最容易设置。简单的轮询实现不需要在服务器上进行更改。SSE 使用
    HTTP 协议提供单向通信线路，而 WebSocket 连接使用 TCP，是双向的。
- en: Second, you learned about server requirements for SSE and WebSocket. You now
    understand that SSE requires support for streaming responses, while WebSocket
    servers can only run on long-running servers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你了解了 SSE 和 WebSocket 的服务器要求。你现在明白 SSE 需要支持流式响应，而 WebSocket 服务器只能在长时间运行的服务器上运行。
- en: Finally, we implemented a real-time UI in BeeRich by utilizing SEE. We implemented
    a new endpoint and associated React hook using the `EventSource` API. Since Remix’s
    `loader` functions return HTTP `Response` objects, we can implement the server-sent
    event endpoint in Remix using a resource route.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在 BeeRich 中通过利用 SEE 实现了一个实时用户界面。我们使用 `EventSource` API 实现了一个新的端点和相关的 React
    钩子。由于 Remix 的 `loader` 函数返回 HTTP `Response` 对象，我们可以使用资源路由在 Remix 中实现服务器端发送事件端点。
- en: In the next chapter, we will learn more about session management and discuss
    advanced session management patterns with Remix.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多关于会话管理的内容，并讨论 Remix 的高级会话管理模式。
- en: Further reading
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can read more about SSE and WebSocket in the MDN Web Docs:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 MDN Web 文档中了解更多关于 SSE 和 WebSocket 的信息：
- en: '[https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)'
- en: '[https://developer.mozilla.org/en-US/docs/Web/API/Websockets_API](https://developer.mozilla.org/en-US/docs/Web/API/Websockets_API)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/Web/API/Websockets_API](https://developer.mozilla.org/en-US/docs/Web/API/Websockets_API)'
- en: 'Here is a great talk from Remix Conf 2023 about SSE by Alex Anderson: [https://www.youtube.com/watch?v=cAYHw_dP-Lc](https://www.youtube.com/watch?v=cAYHw_dP-Lc).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Remix Conf 2023 上关于 SSE 的一个精彩演讲，由 Alex Anderson 演讲：[https://www.youtube.com/watch?v=cAYHw_dP-Lc](https://www.youtube.com/watch?v=cAYHw_dP-Lc).
- en: 'Sergio Xalambrí wrote an article on how to set up Remix with socket.io to create
    a WebSocket connection: [https://sergiodxa.com/articles/use-remix-with-socket-io](https://sergiodxa.com/articles/use-remix-with-socket-io).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Sergio Xalambrí 撰写了一篇关于如何使用 socket.io 配置 Remix 来创建 WebSocket 连接的文章：[https://sergiodxa.com/articles/use-remix-with-socket-io](https://sergiodxa.com/articles/use-remix-with-socket-io).
