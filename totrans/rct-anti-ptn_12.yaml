- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing an End-To-End Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we delved into a variety of topics, including testing,
    **test-driven development** (**TDD**), design patterns, and design principles.
    These concepts are invaluable as they pave the way toward a more resilient and
    maintainable codebase. Now, I’d like to embark on a journey of constructing an
    application from the ground up, applying the knowledge we’ve acquired to tackle
    an end-to-end scenario.
  prefs: []
  type: TYPE_NORMAL
- en: The aim is to illustrate how we can dissect requirements into actionable tasks,
    and subsequently test and implement them. We’ll also explore how to stub network
    requests, thereby eliminating dependencies on remote systems during development,
    and how to confidently refactor code without fear of breaking existing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll venture into building a functional weather application from scratch, interfacing
    with a genuine weather API server to fetch and display a list of weather data.
    Along the way, we’ll implement accessibility features such as keyboard interactions,
    revisit the **Anti-Corruption Layer** (**ACL**) and single responsibility principle,
    and much more.
  prefs: []
  type: TYPE_NORMAL
- en: The overarching goal is to showcase the end-to-end process of crafting a functioning
    software solution, all while keeping the code in a maintainable, understandable,
    and extensible state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the requirements for the weather application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crafting our initial acceptance test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the City Search feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing an ACL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing an Add to Favorite feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching previous weather data when the application relaunches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A GitHub repository has been created to host all the code we’ll discuss in this
    book. For this chapter, you can find the recommended structure at [https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch12](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch12).
  prefs: []
  type: TYPE_NORMAL
- en: We need to complete a few more steps before we proceed. Please follow the next
    section to set up the necessary API keys.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the OpenWeatherMap API key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To utilize OpenWeatherMap, you’ll need to create an account at [https://openweathermap.org/](https://openweathermap.org/).
    Although various plans are available based on usage, the free plan suffices for
    our purposes. After registering, navigate to **My API keys** to find your API
    key, as displayed in *Figure 12**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1: The OpenWeatherMap API key](img/B31103_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: The OpenWeatherMap API key'
  prefs: []
  type: TYPE_NORMAL
- en: Keep a copy of this key handy as we’ll use it to make calls to the weather API
    so that we can fetch data.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the project’s code base
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you prefer to follow along with me, you will need to install a few packages
    before we start. However, if you want to see the final results, they’re already
    in the repository mentioned earlier. I recommend that you follow along to see
    how we evolve our application into the final state.
  prefs: []
  type: TYPE_NORMAL
- en: 'To kick things off, we’ll create a new React app using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands are used to set up a new React project with TypeScript and Cypress:'
  prefs: []
  type: TYPE_NORMAL
- en: '`npx create-react-app weather-app --template typescript`: This command utilizes
    `npx` to run the `create-react-app` utility, which scaffolds out a new React application
    in a directory named `weather-app`. The `--template typescript` option specifies
    that this project should be configured to use TypeScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yarn add cypress jest-fetch-mock -D`: This command installs Cypress, a testing
    framework, as a development dependency in the project, and `jest-fetch-mock`,
    for mocking the `fetch` function in jest tests. The `-D` flag indicates that this
    is a development dependency, meaning it’s not required for the production version
    of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yarn install`: This command installs all the dependencies listed in the `package.json`
    file of the project, ensuring that all the necessary libraries and tools are available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we can start the template application by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will launch the application on port 3000\. You can leave the application
    running on 3000 open and open another terminal window for running tests.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the requirements for the weather application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our envisioned weather application is designed to be a fully functional platform
    with the following capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Enables users to search for cities of interest, be it their hometown, current
    residence, or a future travel destination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows users to add cities to a favorite list, with the selection persisting
    locally for easy access during future visits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports the addition of multiple cities to the user’s list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensures the site is thoroughly navigable via keyboard, facilitating ease of
    access for all users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The result will resemble what’s illustrated in *Figure 12**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2: The weather application](img/B31103_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: The weather application'
  prefs: []
  type: TYPE_NORMAL
- en: While it’s not an overly complex application, it encompasses several intriguing
    elements. For instance, we’ll navigate through the hurdles of applying TDD in
    a UI application, testing Hooks, and making informed decisions on when to employ
    user acceptance tests versus lower-level tests.
  prefs: []
  type: TYPE_NORMAL
- en: We will commence with an initial acceptance test to ensure the application operates
    end-to-end, albeit it is merely verifying a single text element’s appearance.
  prefs: []
  type: TYPE_NORMAL
- en: Crafting our initial acceptance test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B21103_07.xhtml#_idTextAnchor176) familiarized us with the notion
    of starting with an acceptance test – a test that’s approached from an end user’s
    standpoint, as opposed to a developer’s perspective. Essentially, we aim for our
    test to validate aspects a user would perceive or interact with on the web page,
    rather than technicalities such as function calls or class initializations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the folder you created in the *Technical requirements* section (that
    is, `weather-app`), create a Cypress test within `cypress/e2e/weather.spec.cy.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet, we defined a test suite named `weather application`.
    It uses the describe function in the Cypress testing framework. This test case
    comprises two main actions: navigating to the local development server at http://localhost:3000/
    using `cy.visit`, and then checking the page to ensure it contains the `Weather
    Application` text using `cy.contains`. If `Weather Application` is found on the
    page, the test will pass; if not, it will fail.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing the test using `npx cypress run` will, as expected, yield an error
    on the console due to our yet unmodified app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This error reveals that it was anticipating the `Weather Application` text but
    didn’t locate it within the default 4-second timeout specified by Cypress. To
    rectify this, we’ll need to tweak `App.tsx` so that it includes this text.
  prefs: []
  type: TYPE_NORMAL
- en: 'After clearing the current content in `App.tsx` (generated by `create-react-app`),
    we’ll insert a simple `h1` tag to display the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code defines a functional component named `App` in React, which renders
    a `div` element containing an `h1` element with the `Weather Application` text.
    With this heading defined, our Cypress test will pass.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to the first meaningful feature – allowing users to search
    by a city name.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a City Search feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s commence the development of our first feature – City Search. Users will
    be able to enter a city name into a search box, which triggers a request to a
    remote server. Upon receiving the data, we’ll render it into a list for user selection.
    Throughout this chapter, we’ll utilize the OpenWeatherMap API for city searches
    as well as retrieving weather information.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the OpenWeatherMap API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenWeatherMap is a service that offers global weather data via an API, allowing
    users to access current, forecasted, and historical weather data for any location
    worldwide. It’s a popular choice among developers for embedding real-time weather
    updates into apps and websites.
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to use two APIs in our weather application – one for searching the
    city by name and another for getting the actual real-time weather. To use the
    API, you’ll need the API key you received when following the instructions in the
    *Technical* *requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can try sending the request to OpenWeatherMap either in your browser or
    with a command-line tool such as `curl` or http (from [https://httpie.io/](https://httpie.io/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This line utilizes the `http` command to send an HTTP request to the OpenWeatherMap
    API, specifically to its geocoding endpoint (`geo/1.0/direct`), looking up cities
    named `Melbourne`, with a limit of 5 results. The `appid` (as specified in the
    preceding URL) parameter is where you need to insert *your* OpenWeatherMap API
    key to authenticate the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the command fetches basic geocoding information about cities named Melbourne,
    which can later be used to get weather data for those locations. You will get
    the result in JSON format, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Be aware that the OpenWeatherMap free plan comes with a rate limit, restricting
    us to a maximum of 60 requests per minute and 1,000,000 requests per month. While
    these limits may seem high, the number of requests can accumulate quickly during
    development through testing and debugging. To conserve our request allowance,
    we’ll avoid making requests to the real server and instead stub these requests,
    returning predefined values. For a refresher on stubbing, refer to [*Chapter 5*](B21103_05.xhtml#_idTextAnchor124).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s save the resultant data into a text file named `search-results.json`,
    located under `cypress/fixtures/search-result.json`.
  prefs: []
  type: TYPE_NORMAL
- en: Stubbing the search results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the file in place, we can write a test for the `fixtures/search-result.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we created a test case called `''searches for a city''`. The test case
    does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it sets up an interception for a `GET` request that goes to the OpenWeatherMap
    API for city searches. Whenever a request matching the criteria is made, it responds
    with a 200 status code and the body content from a predefined `searchResults`
    file, essentially mocking the API response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it navigates to the application running on `http://localhost:3000/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, it simulates a user typing `Melbourne` into an input field with a `data-testid`
    value of `search-input` and pressing the *Enter* key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, it checks that a container with a `data-testid` value of `"search-results"`
    contains exactly five elements with a class of `search-result`, which are the
    search results that are returned from the stubbed API request. This verifies that
    the application correctly displays the search results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We’re in the red step in TDD (the first step, which indicates that a test is
    failing), so let’s go to our application code, `App.tsx`, to fix the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `App` function in this code sets up a simple weather application using React.
    It initializes the `query` and `searchResults` state variables to handle user
    input and display search results, respectively. The `handleKeyDown` and `handleChange`
    event handlers are set up to update the search query and trigger a city search
    when the user presses *Enter*. The `fetchCities` function sends a request to the
    OpenWeatherMap API, processes the response to extract the city names, and updates
    `searchResults`.
  prefs: []
  type: TYPE_NORMAL
- en: In the TSX part, an input field is provided for the user to type a city name,
    and a list displays the search results whenever there are any available.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tests are now passing with these changes, and we can launch our browser
    to access the application. As depicted in *Figure 12**.3*, our implementation
    now displays a drop-down list of cities upon conducting a search:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3: The search result dropdown](img/B31103_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: The search result dropdown'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I’ve incorporated some CSS to enhance the visual appeal. However, to maintain
    focus on the core content, the CSS has not been included here. For a complete
    understanding, you can refer to the repository mentioned in the *Technical requirements*
    section to see the full implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the search result list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we utilize city names for search queries, it’s common to encounter multiple
    matches in the search results. To refine this, we could enrich each item with
    additional details such as the state name, country name, or even coordinates to
    make the results more distinctive.
  prefs: []
  type: TYPE_NORMAL
- en: Following the TDD approach, we’ll start with a test. Although a Cypress test
    could be crafted, detailing such aspects is better suited for lower-level tests
    such as unit tests. Cypress tests are end-to-end, encompassing all the parts –
    pages, network (even with interceptors) – and from its standpoint, it perceives
    no components, just HTML, CSS, and JavaScript. This makes them more costly to
    run, extending the feedback loop compared to lower-level tests, which generally
    operate in an in-memory browser and focus on isolated areas.
  prefs: []
  type: TYPE_NORMAL
- en: For this enhancement, we’ll employ Jest tests, which are more lightweight, faster,
    and offer specificity in test case writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, we aim to test if an item displays the city name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we invoke the `render` method from the React Testing Library on a `SearchResultItem`
    component, passing a prop item with a `city` field. Then, we assert that the `Melbourne`
    text is present in the document.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we lack a `SearchResultItem` component ready for testing. However,
    a slight refactoring can help us extract one. Let’s create a `SearchResultItem.tsx`
    file and define the component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, integrate the component in `App.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this part of `App.tsx`, we map through `searchResults`, rendering `SearchResultItem`
    for each city, and passing the city data as a prop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s extend our tests to check for the city name, state, and country:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, to accommodate these new fields, we’ll tweak the type definition of `SearchResultItem`
    and render the passed props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define a `SearchResultItemProps` type to specify the shape of the item
    prop, ensuring it contains the `city`, `state`, and `country` fields. Our `SearchResultItem`
    component then renders these fields within a list item, each in a separate `span`
    element.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, now, the list item provides more details to help users distinguish
    between the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4: Enhanced city drop-down list](img/B31103_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.4: Enhanced city drop-down list'
  prefs: []
  type: TYPE_NORMAL
- en: Before we proceed to the next major feature, let’s tackle some housekeeping
    tasks. While we’ve been focused on delivering the feature, we haven’t given much
    attention to code quality so far, so let’s do that.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an ACL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within our application, the `SearchResultItem` component serves its purpose
    well. However, the challenge arises from the discrepancy between the data shape
    we require and the data shape we receive from the remote server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the server’s response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The server’s response includes many elements we don’t need. Moreover, we want
    to shield our `SearchResultItem` component from any future changes to the data
    shape from the server.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in [*Chapter 8*](B21103_08.xhtml#_idTextAnchor212), we can employ
    an ACL to address this issue. Using this, we aim to map the city name and state
    directly, but for the country, we want to display its full name to avoid any ambiguity
    in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, first, we must define a `RemoteSearchResultItem` type to represent
    the remote data shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we must change the `SearchResultItemProps` type to a class, enabling
    its initialization within the TypeScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This segment of code defines a class, `SearchResultItemType`, that accepts a
    `RemoteSearchResultItem` object in its `constructor` and initializes its properties
    accordingly. It also provides getter methods to access these properties, with
    a special handler for the country property to the map country code to its full
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, our `SearchResultItem` component can utilize this newly defined class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note how we use the `item.city` and `item.state` getter functions, just like
    a regular JavaScript object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in our Jest tests, we can verify the transformation logic straightforwardly,
    as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we create an instance of `SearchResultItemType` using a mock `RemoteSearchResultItem`
    object and verify that the transformation logic works as intended – the fields
    are correctly mapped and the country has its full name too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the tests confirm the expected behavior, we can apply this new class within
    our application code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This function fetches city data from the remote server, transforms the received
    data into instances of `SearchResultItemType`, and then updates the `searchResults`
    state.
  prefs: []
  type: TYPE_NORMAL
- en: With enriched details in the dropdown, users can identify their desired city.
    Having achieved this, we can proceed to allow users to add cities to their favorite
    list, paving the way to display weather information for these selected cities.
  prefs: []
  type: TYPE_NORMAL
- en: Given our Cypress feature tests, there’s a safeguard against inadvertently breaking
    functionality. Additionally, with the newly incorporated unit tests, any discrepancies
    between remote and local data shapes will be automatically detected. We are now
    well-positioned to embark on developing the next feature.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an Add to Favorite feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s investigate implementing our next feature: `''adds city to favorite list''`.
    Because this is a feature that is critical in the weather application, we want
    to make sure users can see the city being added and that the dropdown is closed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll start with another Cypress test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the test, we set up an intercept to mock a `GET` request to the OpenWeatherMap
    API and then visit the app running on localhost. From here, it simulates typing
    `Melbourne` into a search input and hitting *Enter*. After that, it clicks on
    the first search result and checks if the favorite cities list now contains one
    city. Finally, it verifies that the favorite cities list contains a city element
    with `Melbourne` and `20°C`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that there are a few things that need a bit more explanation in
    the last two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cy.get(selector)`: This Cypress command is used to query DOM elements on a
    page. It’s similar to `document.querySelector`. Here, it’s being used to select
    elements with specific text content inside a particular part of the DOM. Cypress
    supports not only the basic CSS selectors, such as class and ID selectors, but
    also advanced selectors such as `.city:contains("Melbourne")`, so we can use a
    selector for a more specific selection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.city:contains(text)`: This is a jQuery-style selector that Cypress supports.
    It allows you to select an element containing specific text. In this case, it’s
    being used to find elements within `[data-testid="favorite-cities"]` that have
    a class of `city` and contain `Melbourne` or `20°C`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.should(''exist'')`: This is a Cypress command that asserts that the selected
    elements should exist in the DOM. If the element does not exist, the test will
    fail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, to get the weather for the city, we need another API endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The API requires two parameters: the latitude and longitude.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, it returns the current weather in this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many fields in the response but we only need some of them for now.
    We can intercept the request and serve the response in the Cypress test, just
    like we did for the city search API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Transitioning to the implementation, we’ll weave an `onClick` event handler
    into `SearchResultItem`; upon clicking an item, an API call will be triggered,
    followed by the addition of a city to a list designated for rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s dive into the application code to interlace the data-fetching logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `onItemClick` function is triggered upon clicking a city item. It makes
    a network request to the OpenWeatherMap API using the item’s latitude and longitude,
    fetching the current weather data for the selected city. Then, it parses the response
    to JSON, extracts the city name and temperature from the parsed data, and updates
    the city state using the `setCity` function, which will cause the component to
    re-render and display the selected city’s name and current temperature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the `SearchResultItemType` parameter in the previous snippet. We’ll need
    to extend this type so that it encompasses latitude and longitude. We can achieve
    this by revisiting the ACL layer in the `SearchResultItemType` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have extended `SearchResultItemType` with two new fields, `latitude`
    and `longitude`, which will be used in the API query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, upon successfully retrieving the city data, it’s time for rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this block of code, the `onItemClick` function is assigned as the `onClick`
    event handler for each `SearchResultItem`. When a city is clicked, the `onItemClick`
    function is invoked, triggering a fetch request to retrieve the weather data for
    the selected city. Once the data is obtained, the `setCity` function updates the
    city state, which then triggers a re-render, displaying the selected city in the
    **Favorite** **Cities** section.
  prefs: []
  type: TYPE_NORMAL
- en: Now that all the tests have passed, it signifies that our implementation aligns
    with the expectations up to this point. However, before we proceed to the next
    enhancement, it’s essential to undertake some refactoring to ensure our code base
    remains robust and easily maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling the weather
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as we modeled the city search result, it’s necessary to model the weather
    for similar reasons – to isolate our implementation from the remote data shape,
    and to centralize data shape conversion, fallback logic, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several areas require refinement. We must do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure all the relevant data is typed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a data model for the weather to centralize all formatting logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize fallback values within the data model when certain data is unavailable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s begin with the remote data type, `RemoteCityWeather`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, we defined a type called `RemoteCityWeather` to reflect the remote data
    shape (and have also filtered out a few fields that we don’t use).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we must define a new type called `CityWeather` for our UI to use CityWeather:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This code defines a `CityWeather` class to model city weather data. It takes
    a `RemoteCityWeather` object as a constructor argument and initializes private
    fields from it – that is, `_name`, `_temp`, and `_main`. The class provides getter
    methods to access a city’s name, rounded temperature in degrees, formatted temperature
    string, and the weather description in lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: For the temperature’s `getter` method, if `_temp` is null or undefined, it returns
    a string, `-/-`. Otherwise, it proceeds to calculate the ceiling (rounding up
    to the nearest whole number) of `_temp` using `Math.ceil(this._temp)`, appends
    a degree symbol to it, and returns this formatted string. This way, the method
    provides a fallback value of `-/-` when `_temp` is not set while formatting the
    temperature value when `_temp` is set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in `App`, we can use the calculated logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `onItemClick` function is triggered when a city item is clicked. It makes
    a `fetch` request to the OpenWeatherMap API using the latitude and longitude of
    the clicked city item. Upon receiving the response, it converts the response into
    JSON, then creates a new `CityWeather` instance with the received data, and updates
    the city state using `setCity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, it closes the drop-down menu by setting the `setDropdownOpen`
    state to `false`. If we don’t close it off, the Cypress test will not be able
    to “see” the underlying weather information, which will cause the test to fail,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5: The Cypress test failed because the weather is covered](img/B31103_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.5: The Cypress test failed because the weather is covered'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we must render the selected city details correspondingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: For rendering the city part, if the city state is defined (that is, a city has
    been selected), it displays a `div` element with a class name of `city`. Inside
    this `div` element, we can see the city’s name and temperature using the `city.name`
    and `city.temperature` properties, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, with some additional styling, our application looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6: Adding a city to the favorite list](img/B31103_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.6: Adding a city to the favorite list'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve done an excellent job with data modeling and have set up a solid ACL to
    bolster our UI’s robustness and ease of maintenance. Nonetheless, upon examining
    the root `App` component, we’ll undoubtedly find areas that require improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the current implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our current `App` component has grown too lengthy for easy readability and
    feature additions, indicating a need for some refactoring to tidy things up. It
    doesn’t adhere well to the single responsibility principle as it takes on multiple
    responsibilities: handling network requests for city search and weather queries,
    managing the state of the dropdown’s open and closed status, and several event
    handlers.'
  prefs: []
  type: TYPE_NORMAL
- en: One approach to realigning with better design principles is to break the UI
    into smaller components. Another is utilizing custom Hooks for state management.
    Given that a significant portion of the logic here revolves around managing the
    state for the city search dropdown, it’s sensible to start by isolating this part.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by extracting all city search-related logic into a custom Hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `useSearchCity` Hook manages the city search functionality. It initializes
    states for query, search results, and dropdown open status using `useState`. The
    `fetchCities` function triggers a network request to fetch cities based on the
    query, processes the response to create `SearchResultItemType` instances, updates
    the search results state, and opens the drop-down list. Two functions, `openDropdownList`
    and `closeDropdownList`, are defined to toggle the dropdown’s open status. The
    Hook returns an object containing these functionalities, which can be used by
    components that import and invoke `useSearchCity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we extract a component, `SearchCityInput`, to handle all the search input-related
    work: to handle the *Enter* key for performing the search, open the drop-down
    list, and handle users clicking on each item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `SearchCityInput` component is responsible for rendering and managing the
    user input for searching cities, utilizing the `useSearchCity` Hook to access
    search-related functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: The `handleKeyDown` and `handleChange` functions are defined to handle user
    interactions, triggering a search upon pressing *Enter* and updating the query
    on input change, respectively. Then, the `handleItemClick` function is defined
    to handle the action when a search result item is clicked, which triggers the
    `onItemClick` prop function and closes the drop-down list.
  prefs: []
  type: TYPE_NORMAL
- en: In the `render` method, an input field is provided for the user to type the
    search query, and the drop-down list is conditionally rendered based on the `isDropdownOpen`
    state. If the dropdown is open and there are search results, a list of `SearchResultItem`
    components is rendered, each being passed the current item data and the `handleItemClick`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For all the logic of the weather for a city, we can extract another Hook, `useCityWeather`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `useFetchCityWeather` custom Hook is designed to manage the fetching and
    storing of weather data for a specified city. It maintains a state, `cityWeather`,
    to hold the weather data. The Hook provides a function, `fetchCityWeather`, which
    takes a `SearchResultItemType` object as an argument to get the `latitude` and
    `longitude` values for the API call.
  prefs: []
  type: TYPE_NORMAL
- en: Upon receiving the response, it processes the JSON data, creates a new `CityWeather`
    object from the `RemoteCityWeather` data, and updates the `cityWeather` state
    with it. The Hook returns the `cityWeather` state and the `fetchCityWeather` function
    for use in other components (`Weather`, for example).
  prefs: []
  type: TYPE_NORMAL
- en: 'We could extract a `Weather` component to accept `cityWeather` and render it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `Weather` component accepts a prop, `cityWeather`. If `cityWeather` is defined,
    the component renders a `div` element with the `city` class name, displaying the
    city’s name and temperature in degrees Celsius. If `cityWeather` is undefined,
    it returns `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the extracted Hook and component, our `App.tsx` is simplified into something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the `App` function, we’re utilizing the `useFetchCityWeather` custom Hook
    to obtain `cityWeather` and `fetchCityWeather` values. The `onItemClick` function
    is defined to call `fetchCityWeather` with an item of the `SearchResultItemType`
    type. In the rendering part, we can now simply use the component and functions
    we extracted.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open the project folder to examine the current folder structure, we will
    see that we have different elements defined in distinct modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now, after all that work, each module possesses a clearer boundary and defined
    responsibility. If you wish to delve into the search functionality, `SearchCityInput`
    is your starting point. For insights on the actual search execution, the `useSearchCity`
    Hook is where you’d look. Each level maintains its own abstraction and distinct
    responsibility, simplifying code comprehension and maintenance significantly.
  prefs: []
  type: TYPE_NORMAL
- en: Since our code is in a great state and is ready for us to add more features
    on top of it, we can look into enhancing the current feature.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling multiple cities in the favorite list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s examine a specific example to illustrate the ease with which we can
    expand the existing code with a simple feature upgrade. A user may have several
    cities they’re interested in, but at present, we can only display one city.
  prefs: []
  type: TYPE_NORMAL
- en: To allow multiple cities in the favorite list, which component should we modify
    to implement this change? Correct – the `useFetchCityWeather` Hook. To enable
    it so that it can manage a list of cities, we’ll need to display this list within
    `App`. There’s no need to delve into the city search-related files, indicating
    that this structure has halved the time we would spend sifting through files.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we’re performing TDD, let’s write a test for the Hook first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, let’s define some data we want to test against. We can initialize data
    with `weatherAPIResponse`, which contains a mock response from a weather API in
    JSON string format, and `searchResultItem`, which holds an instance of `SearchResultItemType`
    with location details for Melbourne, Australia.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the actual test case, we’ll need to use `fetchMock` from `jest-fetch-mock`;
    we installed it in the *Technical* *requirements* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code sets up a test suite for the `fetchCityWeather` function.
    Before each test, it resets any mocked fetch calls. The test case aims to verify
    that the function returns a list of cities. It mocks an API response using `fetchMock.mockResponseOnce`,
    then invokes the `useFetchCityWeather` custom Hook. The `fetchCityWeather` function
    is called within an `act` block to handle state updates. Finally, the test asserts
    that the returned list of cities contains one city, **Melbourne**.
  prefs: []
  type: TYPE_NORMAL
- en: This setup helps test the `fetchCityWeather` function in isolation, ensuring
    it behaves as expected when provided with a specific input and when receiving
    a specific API response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Correspondingly, we need to update the `useFetchCityWeather` Hook to enable
    multiple items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `useFetchCityWeather` Hook now maintains a state of an array of `CityWeather`
    objects called `cities`. We still send requests to the `OpenWeatherMap` API and
    then we make sure the new item is inserted at the start of the list when it’s
    fetched. It returns an object containing the `cities` array to the calling place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in `App`, we can iterate over `cities` to generate the `Weather` component
    for each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `cities` array is mapped over, and for each `CityWeather` object in the
    array, a `Weather` component is rendered. The key prop for each `Weather` component
    is set to the city’s name, and the `cityWeather` prop is set to the `CityWeather`
    object itself, which will display the weather information for each city in the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will be able to see something like this in the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7: Showing multiple cities in the favorite list](img/B31103_12_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.7: Showing multiple cities in the favorite list'
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into our next and final feature, it’s essential to make one more
    straightforward improvement to the existing code – ensuring adherence to the single
    responsibility principle.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the weather list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The functionality is operational and all tests have passed; the subsequent
    focus is on enhancing code quality. Keep the TDD approach in mind: tackle one
    task at a time and make incremental improvements. Then, we can extract a `WeatherList`
    component that renders the whole city list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `WeatherList` component receives a cities prop, which is an array of `CityWeather`
    objects. It iterates through this array using `map`, rendering a `Weather` component
    for each city.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the new `WeatherList` component in place, `App.tsx` will be simplified
    to something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Fantastic! Now that our application structure is clean and each component has
    a single responsibility, this is an opportune time to dive into implementing a
    new (and the last one) feature to enhance our weather application further.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching previous weather data when the application relaunches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the final feature in our weather application, we aim to retain the user’s
    selections so that upon their next visit to the application, instead of encountering
    an empty list, they see the cities they selected previously. This feature is likely
    to be highly utilized – users will only need to add a few cities initially, and
    afterward, they may merely open the application to have the weather for their
    cities loaded automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s start the feature with a user acceptance test using Cypress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `cy.window()` command accesses the global window object and sets a `favoriteItems`
    item in `localStorage` with the items array. Following that, `cy.intercept()`
    stubs the network request to the OpenWeatherMap API, using a fixture file called
    `melbourne.json` for the mock response. The `cy.visit()` command navigates to
    the application on `http://localhost:3000/`. Once on the page, the test checks
    for one city item in the favorite cities list, verifies the presence of a city
    item for `Melbourne`, and confirms it displays a temperature of `20°C`.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we set up one item in `localStorage` so that when the page loads,
    it can read `localStorage` and make a request to the remote server, just like
    what we do in `onItemClick`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll need to extract a data fetching function within `useFetchCityWeather`.
    Currently, the `fetchCityWeather` function is handling two tasks – fetching data
    and updating the cities’ state. To adhere to the single responsibility principle,
    we should create a new function solely for fetching data, leaving `fetchCityWeather`
    to handle updating the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `fetchCityWeatherData` function takes a `SearchResultItemType` object as
    an argument, constructs a URL with the latitude and longitude of the item, and
    sends a `fetch` request to the OpenWeatherMap API. Upon receiving the response,
    it converts the response into JSON, creates a new `CityWeather` object with the
    JSON data, and returns it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, `fetchCityWeather` can be updated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `useFetchCityWeather` Hook now contains a `fetchCityWeather` function that
    calls `fetchCityWeatherData` with a given `SearchResultItemType` item. When the
    promise resolves, it receives a `CityWeather` object and then updates the state
    cities by adding the new `CityWeather` object at the beginning of the existing
    cities array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the `App` component, we can use `useEffect` to hydrate the `localStorage`
    data and send requests for the actual weather data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, a `useEffect` Hook triggers a function named `hydrate`
    when the component mounts thanks to the empty dependency array, `[]`.
  prefs: []
  type: TYPE_NORMAL
- en: Inside `hydrate`, firstly, it retrieves a stringified array from `localStorage`
    under the `favoriteItems` key, parsing it back to a JavaScript array, or defaulting
    to an empty array if the key doesn’t exist. Then, it maps through this items array,
    creating a new instance of `SearchResultItemType` for each item, which it passes
    to the `fetchCityWeatherData` function. This function returns a promise, which
    is collected into an array of promises.
  prefs: []
  type: TYPE_NORMAL
- en: Using `Promise.all`, it waits for all these promises to resolve before updating
    the state with `setCities`, populating it with the fetched city weather data.
    Finally, `hydrate` is called within the `useEffect` to execute this logic upon
    component mounting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to save an item in `localStorage` when a user clicks an item, we need
    a bit more code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `onItemClick` function accepts an argument item of the `SearchResultItemType`
    type. Inside the function, `setTimeout` is utilized with a delay of `0` milliseconds,
    essentially deferring the execution of its contents until after the current call
    stack has cleared – so, the UI will not be blocked.
  prefs: []
  type: TYPE_NORMAL
- en: Within this deferred block, it retrieves a stringified array from `localStorage`
    under the `favoriteItems` key, parsing it back to a JavaScript array, or defaulting
    to an empty array if the key doesn’t exist. Then, it creates a new object, `newItem`,
    from the item argument, extracting and renaming some properties.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, it updates the `favoriteItems` key in `localStorage` with a
    stringified array containing `newItem` at the beginning, followed by the previously
    stored items.
  prefs: []
  type: TYPE_NORMAL
- en: Outside of `setTimeout`, it calls `fetchCityWeather` with the item argument,
    fetching weather data for the clicked city, and returns the result of this call
    from `onItemClick`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when we inspect `localStorage` in our browser, we will see that the objects
    are listed in JSON format and that the data will persist until users explicitly
    clean it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8: Using data from local storage](img/B31103_12_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.8: Using data from local storage'
  prefs: []
  type: TYPE_NORMAL
- en: Excellent job! Everything is now functioning well, and the code is in a robust
    shape that’s easy to build upon. Moreover, the project structure is intuitive,
    facilitating easy navigation and file location whenever we need to implement changes.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter was quite extensive and was packed with insightful information,
    serving as a great recapitulation of the knowledge you’ve acquired thus far. While
    it would be engaging to continue adding more features together, I believe now
    is an opportune time for you to dive in and apply the concepts and techniques
    you’ve gleaned from this book. I’ll entrust the enhancement task to you, confident
    that you’ll make commendable adjustments as you introduce more features.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we embarked on creating a weather application from scratch,
    adhering to the TDD methodology. We employed Cypress for user acceptance tests
    and Jest for unit tests, progressively building out the application’s features.
    Key practices such as modeling domain objects, stubbing network requests, and
    applying the single responsibility principle during refactoring were also explored.
  prefs: []
  type: TYPE_NORMAL
- en: While not exhaustive in covering all the techniques from previous chapters,
    this chapter underscored the importance of maintaining a disciplined pace during
    the development phase. It highlighted the value of being able to identify code
    “smells” and address them effectively, all while ensuring a solid test coverage
    to foster a robust and maintainable codebase. This chapter served as a practical
    synthesis, urging you to apply the acquired knowledge and techniques to enhance
    the application further.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming and concluding chapter, we’ll recap the anti-patterns we’ve
    explored, revisiting the design principles and practices we’ve examined, and also
    provide additional resources for further learning.
  prefs: []
  type: TYPE_NORMAL
