- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Assets and Metadata Handling
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资产和元数据管理
- en: So far, we’ve practiced routing, data loading and mutations, handling errors,
    and managing state and sessions in Remix. However, building for the web also involves
    managing static assets to ensure a smooth and efficient user experience.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经练习了在Remix中处理路由、数据加载和变更、错误处理以及状态和会话管理。然而，构建Web应用还涉及到管理静态资产，以确保用户体验的流畅和高效。
- en: 'In this chapter, we will learn how to manage static assets and meta tags in
    Remix. This chapter is split into three sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何在Remix中管理静态资产和元标签。本章分为三个部分：
- en: Using meta tags in Remix
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Remix中使用元标签
- en: Handling fonts, images, stylesheets, and other assets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理字体、图像、样式表和其他资产
- en: Exposing assets with loader functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加载函数暴露资产
- en: First, we will use Remix’s `meta` export to create dynamic meta tags based on
    loader data. Next, we will investigate how to expose static assets in Remix. We
    will create a `robots.txt` file, add a custom font, and experiment with nested
    stylesheets. After that, we will discuss managing images in Remix. Finally, we
    will see how we can create assets dynamically in `loader` functions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用Remix的`meta`导出功能，根据加载数据创建动态元标签。接下来，我们将研究如何在Remix中暴露静态资产。我们将创建一个`robots.txt`文件，添加自定义字体，并尝试嵌套样式表。之后，我们将讨论在Remix中管理图像。最后，我们将看到如何在`loader`函数中动态创建资产。
- en: After reading this chapter, you will understand how to work with meta tags in
    Remix. You will also know how to expose and access static assets and how to link
    external resources. Finally, you will know how to expose dynamic assets via `loader`
    functions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，您将了解如何在Remix中处理元标签。您还将知道如何暴露和访问静态资产以及如何链接外部资源。最后，您将了解如何通过`loader`函数暴露动态资产。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code for this chapter here: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/09-assets-and-meta-data-handling](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/09-assets-and-meta-data-handling).
    You can go ahead and use the end solution from the previous chapter. No additional
    setup steps are required for this chapter.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章的代码：[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/09-assets-and-meta-data-handling](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/09-assets-and-meta-data-handling)。您可以继续使用上一章的最终解决方案。本章不需要额外的设置步骤。
- en: Using meta tags in Remix
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Remix中使用元标签
- en: Meta tags are used to describe the content of an HTML document. They are important
    for **Search Engine Optimization** (**SEO**) and are used by web crawlers to understand
    the content of your site. Meta tags are also used to configure browser behavior,
    link previews, and the site’s appearance in the bookmark list and search results.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 元标签用于描述HTML文档的内容。它们对于**搜索引擎优化**（**SEO**）非常重要，并且被网络爬虫用来理解您网站的内容。元标签还用于配置浏览器行为、链接预览以及网站在书签列表和搜索结果中的外观。
- en: For example, the title, description, and image meta tags are used on link previews
    and search pages, like Google's search results. The title meta tag is also used
    together with the favicon to display the website in the bookmark list.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，标题、描述和图像元标签用于链接预览和搜索页面，如Google的搜索结果。标题元标签还与favicon一起使用，以在书签列表中显示网站。
- en: In this section, you will learn how to add meta tags to your Remix application.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何向您的Remix应用程序添加元标签。
- en: Declaring global meta tags
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明全局元标签
- en: 'An application usually exposes some global meta tags that must be included
    on every page. Since Remix allows us to manage the full HTML document in React,
    including the head, we can inline global meta tags in the root of our application:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序通常会在每个页面上包含一些全局元标签。由于Remix允许我们在React中管理完整的HTML文档，包括头部，我们可以在应用程序的根目录中内联全局元标签：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Review the `Document` component in `root.tsx`. Notice that we export two global
    meta tags to set the `charSet` attribute and `viewport` meta tag of the application.
    As always, you can find more information about browser APIs and the web platform
    in the MDN Web Docs:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 查看位于`root.tsx`中的`Document`组件。注意，我们导出了两个全局元标签来设置应用程序的`charSet`属性和`viewport`元标签。和往常一样，您可以在MDN
    Web Docs中找到有关浏览器API和Web平台的信息：
- en: 'The `viewport` meta tag: [https://developer.mozilla.org/en-US/docs/Web/HTML/Viewport_meta_tag](https://developer.mozilla.org/en-US/docs/Web/HTML/Viewport_meta_tag)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`viewport`元标签：[https://developer.mozilla.org/en-US/docs/Web/HTML/Viewport_meta_tag](https://developer.mozilla.org/en-US/docs/Web/HTML/Viewport_meta_tag)'
- en: 'The `charSet` attribute: [https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attributes)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`charSet`属性：[https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attributes)'
- en: Content-aware meta tags, such as `title` and `description`, must be set dynamically
    for every page. In Remix, we can use the `meta` export to inject meta tags into
    the head of our application. Let’s see how that works.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 内容感知元标签，如`title`和`description`，必须为每个页面动态设置。在Remix中，我们可以使用`meta`导出将元标签注入到我们应用程序的头部。让我们看看它是如何工作的。
- en: Exporting the meta function
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出元函数
- en: 'Every route module in Remix can export a `meta` function. Remix follows the
    route hierarchy to find the closest `meta` export and injects it into the head
    of the HTML document. Let’s jump into the code of our BeeRich application and
    investigate how the `meta` export is used to define meta tags:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Remix中的每个路由模块都可以导出一个`meta`函数。Remix遵循路由层次结构以找到最近的`meta`导出，并将其注入到HTML文档的头部。让我们跳入我们的BeeRich应用程序的代码，并调查如何使用`meta`导出定义元标签：
- en: 'Open the `app/root.tsx` file and look for the `meta` export:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app/root.tsx`文件并查找`meta`导出：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Run BeeRich locally with `npm` `run dev`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm` `run dev`命令在本地运行BeeRich。
- en: Open the app in a browser window by navigating to [http://localhost:3000/](http://localhost:3000/).
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到[http://localhost:3000/](http://localhost:3000/)在浏览器窗口中打开应用程序。
- en: 'Inspect the HTML by using the developer tools of your browser. The head element’s
    content should look as follows:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您浏览器的开发者工具检查HTML。头部元素的内容应如下所示：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add a description metadata object to the `meta` function’s return value in
    `root.tsx`:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`root.tsx`中的`meta`函数返回值中添加一个描述元数据对象：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Inspect the JSX of the `Document` component in `root.tsx`:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`root.tsx`中的`Document`组件的JSX：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next, let’s investigate how Remix manages nested `meta` exports.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们调查Remix如何管理嵌套的`meta`导出。
- en: Nesting meta exports
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套`meta`导出
- en: 'In this section, we’ll add some `meta` exports to nested route modules:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向嵌套路由模块添加一些`meta`导出：
- en: 'Open the `_layout.login.tsx` route module and add the following code:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`_layout.login.tsx`路由模块并添加以下代码：
- en: '[PRE5]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Open the login page by navigating to [http://localhost:3000/login](http://localhost:3000/login)
    and inspect the content of the head element.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到[http://localhost:3000/login](http://localhost:3000/login)打开登录页面并检查头部元素的内容。
- en: Note that the title and description defined in `root.tsx` are overridden by
    the nested `meta` export.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在`root.tsx`中定义的标题和描述被嵌套的`meta`导出覆盖。
- en: Use the meta export in nested route modules to override parent meta tags
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌套路由模块中使用`meta`导出来覆盖父级元标签
- en: The `meta` route module export lets us define meta tags at any level in the
    route hierarchy. Remix uses the closest `meta` function return values and adds
    them to the head of the document by using the `Meta` component. Nested `meta`
    exports replace parent `meta` exports.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`meta`路由模块导出允许我们在路由层次结构的任何级别定义元标签。Remix使用最近的`meta`函数返回值，并通过使用`Meta`组件将它们添加到文档的头部。嵌套`meta`导出替换父级`meta`导出。'
- en: Remix initially renders on the server. The rendered document includes all declared
    meta tags and ensures that crawlers can inspect all meta tags without the need
    to execute client-side JavaScript. This is great for SEO.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Remix最初在服务器上渲染。渲染的文档包括所有声明的元标签，并确保爬虫可以在不执行客户端JavaScript的情况下检查所有元标签。这对SEO非常有利。
- en: Often, the content of the meta tags depends on dynamic data. For example, you
    may want to use the title and summary of an article for the title and description
    meta tags. Let’s see how we can access loader data in `meta` functions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，元标签的内容取决于动态数据。例如，您可能希望使用文章的标题和摘要作为标题和描述元标签。让我们看看我们如何在`meta`函数中访问加载器数据。
- en: Using loader data in meta functions
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在元函数中使用加载器数据
- en: A `meta` function runs both on the client and the server. On initial render,
    the `meta` function is called during server-side rendering. For all subsequent
    client-side navigations, the `meta` function is executed on the client after the
    loader data has been fetched from the server. In both cases, Remix passes the
    route’s loader data and a hash map of all parent loader data to the `meta` function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`meta`函数在客户端和服务器上都会运行。在初始渲染时，`meta`函数在服务器端渲染期间被调用。对于所有后续的客户端导航，在从服务器获取加载器数据之后，`meta`函数在客户端执行。在这两种情况下，Remix都将路由的加载器数据和所有父级加载器数据的哈希映射传递给`meta`函数。'
- en: 'In this section, we will add the current user’s name to the title of the BeeRich
    dashboard and explore how we can take advantage of loader data in `meta` functions:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向 BeeRich 仪表板的标题中添加当前用户的姓名，并探讨我们如何在 `meta` 函数中利用加载器数据：
- en: Open the `dashboard.tsx` route module in your editor.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的编辑器中打开 `dashboard.tsx` 路由模块。
- en: Update the `loader` function in `dashboard.tsx` to return the current user's
    name.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `dashboard.tsx` 中的 `loader` 函数以返回当前用户的姓名。
- en: '[PRE6]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, add the following `meta` function export to the route module:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将以下 `meta` 函数导出添加到路由模块中：
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Great! Just like that, we can use dynamic data to create metatags. However,
    one question remains: Why do we use the `?` operator to check whether the (loader)
    `data` property is defined before accessing `username`?'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！就这样，我们可以使用动态数据来创建元标签。然而，一个问题仍然存在：为什么我们在访问 `username` 之前使用 `?` 操作符来检查（加载器）`data`
    属性是否已定义？
- en: Note that the `meta` function is also executed if an error occurs. This ensures
    our meta tags are added even when an error boundary is rendered. If we render
    an error boundary, then the loader data won’t be available. Conclusively, in `meta`,
    we must always check whether the `data` property is defined before accessing its
    properties.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果发生错误，`meta` 函数也会执行。这确保了即使在错误边界被渲染时，我们的元标签也会被添加。如果我们渲染错误边界，那么加载器数据将不可用。最终，在
    `meta` 中，我们必须始终在访问其属性之前检查 `data` 属性是否已定义。
- en: Meta functions run on the client, the server, and on error
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 元函数在客户端、服务器和错误上运行
- en: A `meta` function runs even if the route’s `loader` function throws an error.
    Hence, it is important to check whether the expected loader data exists before
    accessing it. Additionally, we must ensure that our `meta` functions can be safely
    executed on both the client and the server since they run in both environments.
    Any server-side logic must be executed in the `loader` functions (on the server),
    and any required data should be forwarded to the `meta` function via loader data.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 即使路由的 `loader` 函数抛出错误，`meta` 函数也会运行。因此，在访问它之前检查预期的加载器数据是否存在非常重要。此外，我们必须确保我们的
    `meta` 函数可以在客户端和服务器上安全执行，因为它们在两个环境中都会运行。任何服务器端逻辑都必须在 `loader` 函数（在服务器上）中执行，并且任何所需的数据都应该通过加载器数据转发到
    `meta` 函数。
- en: Web crawlers use meta tags to understand the content of your page. Remix’s declarative
    approach to managing meta tags in nested route modules ensures the co-location
    of meta tags and the related loader data. However, sometimes, we can avoid refetching
    data if that data has already been fetched in another active `loader`. Let’s see
    what that looks like.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 网络爬虫使用元标签来理解您页面的内容。Remix 对嵌套路由模块中元标签管理的声明式方法确保了元标签和相关加载器数据的同位放置。然而，有时我们可以避免重新获取数据，如果该数据已经在另一个活动的
    `loader` 中被获取。让我们看看那是什么样子。
- en: Using matches data in meta functions
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在元函数中使用匹配数据
- en: In Remix, `meta` functions are executed after all loaders have run. This means
    we have access to all currently active loader data. In this section, we’ll learn
    about Remix’s `matches` array and how to access the loader data of other routes
    in `meta`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Remix 中，`meta` 函数会在所有加载器运行之后执行。这意味着我们可以访问所有当前活动的加载器数据。在本节中，我们将了解 Remix 的 `matches`
    数组以及如何在 `meta` 中访问其他路由的加载器数据。
- en: 'Remember that we already fetch the user data in the `root.tsx` `loader` function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们已经在 `root.tsx` 的 `loader` 函数中获取了用户数据：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There is no need to refetch the user object in `dashboard.tsx` . We can optimize
    our code and access the user object from the root loader data. This way, we avoid
    querying the database again in the `dashboard.tsx` route module’s `loader` function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `dashboard.tsx` 中不需要重新获取用户对象。我们可以优化我们的代码，并从根加载器数据中访问用户对象。这样，我们就可以避免在 `dashboard.tsx`
    路由模块的 `loader` 函数中再次查询数据库：
- en: 'First, import the root `loader` function from `root.tsx` as a type import:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将 `root.tsx` 中的根 `loader` 函数作为类型导入导入：
- en: '[PRE9]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We import the `loader` function as a type import as we only use it for type
    inference. Note that we must rename the `loader` import to `rootLoader` to avoid
    a naming collision with the `dashboard.tsx` route module’s `loader` function.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将 `loader` 函数作为类型导入导入，因为我们只使用它进行类型推断。请注意，我们必须将 `loader` 导入重命名为 `rootLoader`
    以避免与 `dashboard.tsx` 路由模块的 `loader` 函数发生命名冲突。
- en: 'Next, update the meta function in `dashboard.tsx`, as follows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新 `dashboard.tsx` 中的元函数，如下所示：
- en: '[PRE10]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, we use the `matches` parameter to find the matching route with the `id`
    parameter of `root` and retrieve its (loader) data. The `matches` array contains
    a list of route objects that currently match the URL and are active on the page.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `matches` 参数来找到与 `root` 的 `id` 参数匹配的路由，并检索其（加载器）数据。`matches` 数组包含当前匹配
    URL 并在页面上处于活动状态的路线对象列表。
- en: Remix assigns every route module a unique identifier. These identifiers are
    based on the route module filenames, but the easiest way to identify a route module
    identifier is by logging the matches array during development.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Remix 为每个路由模块分配一个唯一的标识符。这些标识符基于路由模块的文件名，但最容易识别路由模块标识符的方法是在开发期间记录 `matches` 数组。
- en: Now that we’re using the loader data of another matching route, revert the changes
    to the `dashboard.tsx` route module’s `loader` function. Replace the `getUser`
    function call with `requireUserId`. This avoids a database query and optimizes
    our code. Finally, remove the `username` parameter that we added to the `loader`
    function return object.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们正在使用另一个匹配路由的加载器数据，将 `dashboard.tsx` 路由模块的 `loader` 函数中的更改恢复。将 `getUser`
    函数调用替换为 `requireUserId`。这样可以避免数据库查询并优化我们的代码。最后，从 `loader` 函数返回对象中移除我们添加的 `username`
    参数。
- en: In this section, you learned how to type and work with Remix’s `matches` array
    and how to access the loader data of other routes in the `meta` function. Next,
    let’s learn about handling static assets in Remix.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了如何输入和使用 Remix 的 `matches` 数组，以及如何在 `meta` 函数中访问其他路由的加载器数据。接下来，让我们学习如何在
    Remix 中处理静态资源。
- en: Handling fonts, images, stylesheets, and other assets
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理字体、图像、样式表和其他资源
- en: Fonts, images, and stylesheets are examples of static assets that need to be
    efficiently managed when building for the web. To ensure a fast user experience,
    it is necessary to optimize, minimize, and cache these assets. Proper management
    of static assets can significantly improve page load times and enhance the overall
    user experience. In this section, you will learn how to access and manage static
    assets in Remix. Let’s start by reviewing how to access a simple static file in
    Remix.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 字体、图像和样式表是需要在构建网站时高效管理的静态资源示例。为了确保快速的用户体验，有必要优化、最小化和缓存这些资源。适当管理静态资源可以显著提高页面加载时间并提升整体用户体验。在本节中，您将学习如何在
    Remix 中访问和管理静态资源。让我们首先回顾如何在 Remix 中访问一个简单的静态文件。
- en: Working with static assets
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理静态资源
- en: We can host static assets on our web server so that our client application can
    access them. As we learned previously, Remix is not a web server but an HTTP request
    handler. As such, Remix does not offer a built-in way to serve static assets.
    It’s the underlying web server’s responsibility to set up access for public assets.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的网络服务器上托管静态资源，以便我们的客户端应用程序可以访问它们。正如我们之前所学的，Remix 不是一个网络服务器，而是一个 HTTP
    请求处理器。因此，Remix 不提供内置的提供静态资产的方式。为公共资产设置访问权限是底层网络服务器的责任。
- en: 'Luckily, Remix’s starter templates follow the common pattern of offering a
    `public` folder to expose static assets over the web and come with the required
    boilerplate code to do so. For instance, BeeRich – which was bootstrapped via
    the `create-remix` CLI tool using the Express.js adapter – contains a bootstrapped
    `server.js` file that sets up Express.js to serve static assets:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Remix 的入门模板遵循了提供 `public` 文件夹以通过网络公开静态资源的常见模式，并附带执行此操作所需的样板代码。例如，BeeRich
    – 通过使用 Express.js 适配器的 `create-remix` CLI 工具进行引导 – 包含一个引导的 `server.js` 文件，该文件设置
    Express.js 以提供静态资源：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So far, the `public` folder of the BeeRich application contains a `favicon.ico`
    file, which serves as the favicon of our site. Let’s also add a `robots.txt` file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，BeeRich 应用程序的 `public` 文件夹包含一个 `favicon.ico` 文件，它作为我们网站的favicon。让我们也添加一个
    `robots.txt` 文件：
- en: 'Create a `robots.txt` file in the `/public` folder and add this content:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/public` 文件夹中创建一个 `robots.txt` 文件，并添加以下内容：
- en: '[PRE12]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Web crawlers request the `/robots.txt` file from your web server to find directives
    for which content to crawl on your site.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 网络爬虫会从您的网站服务器请求 `/robots.txt` 文件，以找到关于在您的网站上爬取哪些内容的指令。
- en: We specify that web crawlers are allowed to crawl the login, signup, and index
    pages of our application. However, since the dashboard is behind a login page,
    we prevent crawlers from attempting to crawl any of our dashboard pages.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们指定网络爬虫可以爬取我们应用程序的登录、注册和索引页面。然而，由于仪表板位于登录页面之后，我们阻止爬虫尝试爬取我们的任何仪表板页面。
- en: Now, run BeeRich with `npm` `run dev`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 `npm run dev` 运行 BeeRich。
- en: Visit [http://localhost:3000/robots.txt](http://localhost:3000/robots.txt) in
    your browser. You should now see the content of the `robots.txt` text file displayed
    in your browser.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中访问[http://localhost:3000/robots.txt](http://localhost:3000/robots.txt)。现在，您应该看到`robots.txt`文本文件的内容在您的浏览器中显示。
- en: We use the underlying web server to serve the static contents of our Remix app.
    Similarly, we can expose fonts, images, stylesheets, third-party scripts, and
    any other static assets by simply placing them as files in the `public` folder.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用底层Web服务器来提供Remix应用程序的静态内容。同样，我们可以通过将字体、图片、样式表、第三方脚本和其他静态资产作为文件放置在`public`文件夹中来公开它们。
- en: Note that some assets, such as images, should be optimized before you access
    them from the browser. Usually, images and other big assets are better off hosted
    and optimized in dedicated services such as CDNs and static file storage.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一些资源，如图片，在您从浏览器访问它们之前应该进行优化。通常，图片和其他大型资源最好托管并优化在CDN和静态文件存储等专用服务中。
- en: Third-party assets, such as third-party stylesheets and fonts, can also be referenced
    by using HTML link tags so that we don’t have to manage them ourselves in the
    `public` folder. Let’s learn about exposing link tags in Remix.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方资产，如第三方样式表和字体，也可以通过使用HTML链接标签来引用，这样我们就不必在`public`文件夹中自行管理它们。让我们学习如何在Remix中公开链接标签。
- en: Managing links in Remix
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Remix中管理链接
- en: HTML `link` elements are used to reference third-party resources such as stylesheets
    and fonts. In Remix, links can be declared via the `links` route module export.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: HTML `link`元素用于引用第三方资源，如样式表和字体。在Remix中，可以通过`links`路由模块导出声明链接。
- en: 'Remix offers a `Links` component to inject all `links` return values into the
    head of the HTML document. You may have already noticed the `Links` component
    previously when inspecting the `Document` component in `root.tsx`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Remix提供了一个`Links`组件，可以将所有`links`返回值注入到HTML文档的头部。您可能已经在检查`root.tsx`中的`Document`组件时注意到了`Links`组件：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'So far, we only have one `links` export in BeeRich in the `root.tsx` route
    module to link to our global Tailwind CSS stylesheet:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在`root.tsx`路由模块中只有一个是BeeRich的`links`导出，用于链接到我们的全局Tailwind CSS样式表：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s add a font from Google Fonts to practice working with the `links` export:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个来自Google Fonts的字体来练习使用`links`导出：
- en: 'Visit [https://fonts.google.com/specimen/Ubuntu](https://fonts.google.com/specimen/Ubuntu)
    to inspect the `links` function in `root.tsx`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[https://fonts.google.com/specimen/Ubuntu](https://fonts.google.com/specimen/Ubuntu)以检查`root.tsx`中的`links`函数：
- en: '[PRE15]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, update the `` `tailwind.config.ts` `` file in the project’s root to make
    **Ubuntu** the default sans serif font:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新项目根目录中的`tailwind.config.ts`文件，将**Ubuntu**设置为默认的无衬线字体：
- en: '[PRE16]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Open BeeRich in a browser window. The new font should now be applied to all
    text on the page.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器窗口中打开BeeRich。现在，新字体应该已经应用到页面上的所有文本。
- en: Open the developer tools to inspect the application’s network activity.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开开发者工具以检查应用程序的网络活动。
- en: 'Refresh the page to reset the displayed activities on the **Network** tab and
    review the displayed results:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新页面以重置**网络**标签上显示的活动并查看显示的结果：
- en: '![Figure 9.1 – Screenshot of the Network tab downloading a Google font](img/Figure_9.01_B17399.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 网络标签下载Google字体的截图](img/Figure_9.01_B17399.jpg)'
- en: Figure 9.1 – Screenshot of the Network tab downloading a Google font
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 网络标签下载Google字体的截图
- en: As visible in *Figure 9**.1*, the `links` export works as expected. We make
    a request for our global Tailwind CSS stylesheet and a request to [fonts.googleapis.com/css2](http://fonts.googleapis.com/css2).
    The request to [fonts.googleapis](http://fonts.googleapis) then triggers the download
    of the required font assets.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图9**.1*所示，`links`导出按预期工作。我们请求我们的全局Tailwind CSS样式表，并请求[fonts.googleapis.com/css2](http://fonts.googleapis.com/css2)。对[fonts.googleapis](http://fonts.googleapis)的请求随后触发了所需字体资产的下载。
- en: Just like that, the `links` export lets us declare external resources declaratively
    within our nested route hierarchy.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，`links`导出让我们能够在嵌套路由层次结构内声明性地声明外部资源。
- en: In BeeRich, we use one global Tailwind CSS stylesheet for our application. However,
    Remix’s `links` exports also work well when managing route-specific stylesheets.
    Let’s see how we can use the `links` export for modular stylesheets in Remix.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在BeeRich中，我们为我们的应用程序使用一个全局Tailwind CSS样式表。然而，Remix的`links`导出在管理特定路由的样式表时也表现良好。让我们看看我们如何可以在Remix中使用`links`导出进行模块化样式表。
- en: Styling in Remix
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Remix中的样式
- en: Remix supports any styling solution that exposes a stylesheet. This includes
    popular choices such as PostCSS, Tailwind CSS, and vanilla-extract. Once we have
    a path to a stylesheet, we can reference it with a `link` element.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Remix支持任何暴露样式表的样式解决方案。这包括流行的选择，如PostCSS、Tailwind CSS和vanilla-extract。一旦我们有了样式表的路径，我们就可以使用`link`元素来引用它。
- en: 'In BeeRich, we use Tailwind CSS. Tailwind outputs one global stylesheet, which
    we can reference in a global link tag for our application. Remix also provides
    built-in support for compiling the Tailwind CSS stylesheet. You can read more
    about Remix’s Tailwind CSS integration here: [https://remix.run/docs/en/2/styling/tailwind](https://remix.run/docs/en/2/styling/tailwind).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在BeeRich中，我们使用Tailwind CSS。Tailwind生成一个全局样式表，我们可以在应用的全球链接标签中引用它。Remix还提供了内置支持来编译Tailwind
    CSS样式表。您可以在[https://remix.run/docs/en/2/styling/tailwind](https://remix.run/docs/en/2/styling/tailwind)了解更多关于Remix与Tailwind
    CSS集成的信息。
- en: Additionally, Remix offers support for working with modular CSS solutions. Let’s
    review how that works.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Remix还提供了对模块化CSS解决方案的支持。让我们回顾一下它是如何工作的。
- en: Route-scoped stylesheets
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由范围样式表
- en: 'Let’s experiment with nested `links` exports by creating a scoped CSS stylesheet
    for our login page:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过为我们的登录页面创建一个范围CSS样式表来实验嵌套`links`导出：
- en: Create a stylesheet called `login.css` in `app/styles`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/styles`中创建一个名为`login.css`的样式表。
- en: 'Add the following content to the file:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到文件中：
- en: '[PRE17]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We use this global CSS rule as an example for some custom styling that we only
    want to apply to the login route. Other routes, such as the signup route, should
    be unaffected by this CSS.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用这个全局CSS规则作为示例，展示一些我们只想应用于登录路由的定制样式。其他路由，如注册路由，不应受此CSS的影响。
- en: 'Import the stylesheet in the `_layout.login.tsx` route module:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`_layout.login.tsx`路由模块中导入样式表：
- en: '[PRE18]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a new `links` export and add the content of the stylesheet import to
    it:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`links`导出，并将样式表导入的内容添加到其中：
- en: '[PRE19]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Visit the login route in a browser window and open the **Network** tab of the
    developer tools to inspect what’s going on ([http://localhost:3000/login](http://localhost:3000/login)).
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器窗口中访问登录路由，并打开开发者工具的**网络**标签来检查发生了什么（[http://localhost:3000/login](http://localhost:3000/login)）。
- en: Make sure you log out first before visiting the login route as you will be redirected
    away otherwise.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保您首先登出，然后再访问登录路由，否则您将被重定向到其他地方。
- en: '![Figure 9.2 – Loading a nested stylesheet for the login route](img/Figure_9.02_B17399.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 为登录路由加载嵌套样式表](img/Figure_9.02_B17399.jpg)'
- en: Figure 9.2 – Loading a nested stylesheet for the login route
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 为登录路由加载嵌套样式表
- en: Notice that the nested stylesheet loads in parallel with our global linked resources.
    Remix merges the return values of all `links` functions together and uses the
    `Links` component to inject the content into the head of the HTML document.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意嵌套样式表与我们的全局链接资源并行加载。Remix将所有`links`函数的返回值合并在一起，并使用`Links`组件将内容注入HTML文档的头部。
- en: Our login page now has the questionable appearance we wanted. But what happens
    if we navigate to another URL?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的登录页面现在有了我们想要的令人质疑的外观。但如果我们导航到另一个URL会发生什么呢？
- en: Click the **Sign up** button in the top-right corner to trigger a client-side
    transition away from the login route.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右上角的**注册**按钮以触发客户端从登录路由的过渡。
- en: Notice that the beige background color disappears.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意米色背景颜色消失了。
- en: For nested `links` exports, Remix unmounts all resources once we leave the associated
    route. This is particularly useful when working with nested stylesheets. Remix
    makes it easy to scope stylesheets to a specific nested route or subset of routes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于嵌套`links`导出，一旦我们离开相关的路由，Remix就会卸载所有资源。这在处理嵌套样式表时特别有用。Remix使得将样式表范围限定到特定的嵌套路由或路由子集变得容易。
- en: Since Remix knows of all `links` exports, it can also prefetch linked resources
    when using the `Link` export’s `prefetch` property, which we will review in the
    next section.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Remix知道所有的`links`导出，它还可以在使用`Link`导出的`prefetch`属性时预取链接资源，我们将在下一节中对其进行回顾。
- en: Prefetching linked resources
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预取链接资源
- en: 'Let’s investigate how Remix prefetches linked resources:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调查Remix如何预取链接资源：
- en: Open the `_layout.tsx` route module in your editor.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的编辑器中打开`_layout.tsx`路由模块。
- en: 'Add the `prefetch` property to all `NavLink` components rendered in the route’s
    component and set its value to `"intent"`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`prefetch`属性添加到路由组件中渲染的所有`NavLink`组件，并将其值设置为`"intent"`：
- en: '[PRE20]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, visit the signup page in your browser window ([http://localhost:3000/signup](http://localhost:3000/signup)).
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，请在您的浏览器窗口中访问注册页面 ([http://localhost:3000/signup](http://localhost:3000/signup))。
- en: Open the **Network** tab and clear any logged entries for better visibility.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **网络** 选项卡并清除任何已记录的条目以获得更好的可见性。
- en: 'Next, hover over or focus the **Log in** anchor tag in the navigation bar and
    inspect the **Network** tab:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将鼠标悬停在或聚焦于导航栏中的 **登录** 锚点标签上，并检查 **网络** 选项卡：
- en: '![Figure 9.3 – Prefetching linked resources](img/Figure_9.03_B17399.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 预取链接资源](img/Figure_9.03_B17399.jpg)'
- en: Figure 9.3 – Prefetching linked resources
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 预取链接资源
- en: Notice that Remix prefetches linked resources together with the loader data
    and the login route JavaScript module. Based on the request waterfall, we can
    tell that Remix first fetches the loader data and JavaScript modules before prefetching
    the linked resources.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Remix 会与加载器数据一起预取链接资源以及登录路由的 JavaScript 模块。根据请求瀑布图，我们可以看出 Remix 首先获取加载器数据和
    JavaScript 模块，然后再预取链接资源。
- en: Remix must first fetch the new route’s loader data and JavaScript bundle to
    know what links to fetch. Once this information has been fetched, Remix prefetches
    all linked resources in parallel.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 必须首先获取新路由的加载器数据和 JavaScript 包，以便知道要获取哪些链接。一旦获取了这些信息，Remix 就会并行预取所有链接资源。
- en: Remix allows us to declare meta tags and links in nested route modules. When
    using the `links` export, Remix enables us to prefetch linked resources together
    with the loader data and route’s JavaScript modules using the `prefetch` property.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 允许我们在嵌套路由模块中声明元标签和链接。当使用 `links` 导出时，Remix 通过 `prefetch` 属性使我们能够与加载器数据和路由的
    JavaScript 模块一起预取链接资源。
- en: Remix also unloads all external resources once the associated route has been
    unmounted during a transition. This ensures that scoped stylesheets and other
    resources do not affect other routes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换过程中，一旦卸载了相关路由，Remix 也会卸载所有外部资源。这确保了作用域样式表和其他资源不会影响其他路由。
- en: Next, let's go over some tips for working with images in Remix.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们回顾一下在 Remix 中处理图像的一些技巧。
- en: Working with images in Remix
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Remix 中处理图像
- en: Following best practices to deliver the most performant image to users is no
    simple task. We need to use web-friendly formats like webp, but also provide fallbacks
    for browsers that don't support them. On top of that, we have to offer different
    image sizes for various device screens. That's why using a specialized service
    for handling images is often a better choice than hosting them on your own web
    server.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循最佳实践以向用户提供性能最优异的图像并非易事。我们需要使用 webp 等网络友好格式，但同时也需要为不支持它们的浏览器提供回退方案。除此之外，我们还需要为各种设备屏幕提供不同大小的图像。这就是为什么使用专门的服务来处理图像通常比在您自己的
    Web 服务器上托管它们更好。
- en: Remix doesn't have built-in tools or features specifically for handling images,
    unlike some other frameworks. You can put images in the public folder just like
    any other static files. But since images need to be optimized, it's often best
    to use a dedicated service to manage and deliver them.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他一些框架不同，Remix 没有内置专门用于处理图像的工具或功能。您可以像其他任何静态文件一样将图像放在公共文件夹中。但由于图像需要优化，通常最好使用专门的服务来管理和交付它们。
- en: While image optimization is not the focus of this book, it’s still an important
    consideration. To help you get started with image optimization in Remix, we recommend
    checking out the open source `unpic-img` project. `unpic-img` provides a minimal
    React component that can be set up with several popular CDNs. Check out the project
    on GitHub at [https://github.com/ascorbic/unpic-img](https://github.com/ascorbic/unpic-img)
    to get started.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然图像优化不是本书的重点，但它仍然是一个重要的考虑因素。为了帮助您在 Remix 中开始图像优化，我们建议查看开源的 `unpic-img` 项目。`unpic-img`
    提供了一个可以与几个流行的 CDN 配置的最小 React 组件。要开始，请访问 GitHub 上的项目 [https://github.com/ascorbic/unpic-img](https://github.com/ascorbic/unpic-img)。
- en: In this section, you learned how to expose static assets in Remix and how to
    work with link elements. You practiced using the `links` function to declare external
    resources. We also experimented with nested stylesheets and discussed the importance
    of image optimization.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了如何在 Remix 中公开静态资产以及如何处理链接元素。您练习了使用 `links` 函数声明外部资源。我们还尝试了嵌套样式表，并讨论了图像优化的重要性。
- en: Remix also provides a way to serve assets via `loader` functions in resource
    routes. In the next section, we will use our `robots.txt` file as an example of
    how to use resource routes and `loader` functions to expose static assets.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Remix还提供了一种通过资源路由中的`loader`函数提供资产的方法。在下一节中，我们将使用我们的`robots.txt`文件作为如何使用资源路由和`loader`函数来公开静态资产的示例。
- en: Exposing assets with loader functions
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用加载器函数公开资产
- en: 'Earlier in this chapter, we created a `robots.txt` file and exposed it by placing
    it into the `public` folder. However, we can also use `loader` functions in resource
    routes to expose assets. This is particularly useful when we want to dynamically
    create these assets on the fly or manage user access. To get started, follow these
    steps:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，我们创建了一个`robots.txt`文件，并通过将其放入`public`文件夹来公开它。然而，我们也可以在资源路由中使用`loader`函数来公开资产。这在我们需要即时动态创建这些资产或管理用户访问时特别有用。要开始，请按照以下步骤操作：
- en: Delete the existing `robots.txt` file from the public folder as it will override
    our API route otherwise.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从公共文件夹中删除现有的`robots.txt`文件，否则它将覆盖我们的API路由。
- en: Create a new `robots[.txt].tsx` file in the routes folder.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在路由文件夹中创建一个新的`robots[.txt].tsx`文件。
- en: The square brackets let us escape parts of the route name. Instead of creating
    a `.txt` file, we create a `.tsx` file but ensure that the route matches the `robots.txt`
    path.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 方括号使我们能够避开路由名称的一部分。我们不是创建一个`.txt`文件，而是创建一个`.tsx`文件，但确保路由与`robots.txt`路径匹配。
- en: 'Add the following content to the newly created resource route:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到新创建的资源路由中：
- en: '[PRE21]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Remix lets us return any kind of HTTP response in `loader` functions. Any route
    without a route component becomes a resource route that can receive HTTP GET requests.
    The `loader` function in `robots[.txt].tsx` responds to incoming GET requests
    to `/robots.txt` and returns a text file with the specified text content.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Remix允许我们在`loader`函数中返回任何类型的HTTP响应。任何没有路由组件的路由都成为可以接收HTTP GET请求的资源路由。`robots[.txt].tsx`中的`loader`函数响应对`/robots.txt`的传入GET请求，并返回具有指定文本内容的文本文件。
- en: Resource routes and the `Response` API are powerful tools that let us generate
    PDFs, images, text content, or JSON data on the fly. The bracket annotation (for
    example, `[.txt]`) is used to escape parts of the route name.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 资源路由和`Response` API是强大的工具，允许我们即时生成PDF、图像、文本内容或JSON数据。括号注释（例如，`[.txt]`）用于避开路由名称的一部分。
- en: Using `loader` functions to generate assets allows us to run dynamic computations
    on incoming requests. For example, we can authenticate user sessions or dynamically
    generate the asset. Our `robots.txt` file is currently static and does not require
    additional computations. In this case, it is sufficient to store the file in the
    `public` folder.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`loader`函数生成资产允许我们在传入的请求上运行动态计算。例如，我们可以验证用户会话或动态生成资产。我们的`robots.txt`文件目前是静态的，不需要额外的计算。在这种情况下，将文件存储在`public`文件夹中就足够了。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to handle static assets and meta tags in Remix.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何在Remix中处理静态资产和元标签。
- en: First, we introduced you to the `meta` route module export. You learned that
    Remix injects the `meta` function’s return value into the head of the HTML element
    by using the `Meta` component. Remix will always use the closest `meta` function
    export and ignore all other `meta` function exports higher up in the route hierarchy.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们向您介绍了`meta`路由模块导出。您了解到Remix通过使用`Meta`组件将`meta`函数的返回值注入HTML元素的头中。Remix将始终使用路由层次结构中最接近的`meta`函数导出，并忽略所有其他更高层次的路由中的`meta`函数导出。
- en: You also learned that Remix runs `meta` functions both on the client and server.
    Remix passes the `meta` function, a `data` property that can be used to access
    the route’s loader data. After following this chapter, you should understand that
    the `data` property of the `meta` function can potentially be undefined if a `loader`
    function throws an error. Hence, it is important to only conditionally access
    loader data in `meta` functions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您还了解到Remix在客户端和服务器上都会运行`meta`函数。Remix传递`meta`函数，一个可以用来访问路由加载器数据的`data`属性。在跟随本章之后，您应该理解如果`loader`函数抛出错误，`meta`函数的`data`属性可能未定义。因此，在`meta`函数中仅条件性地访问加载器数据是很重要的。
- en: You also practiced typing the `matches` parameter and learned how to access
    other matching route data in the `meta` function.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您还练习了输入`matches`参数，并学习了如何在`meta`函数中访问其他匹配的路由数据。
- en: Next, you learned about handling static assets. You now understand that static
    assets are served by the underlying web server and not by Remix directly. Remix’s
    starter templates set up a `public` folder and the necessary server code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你学习了如何处理静态资源。现在你明白静态资源是由底层网络服务器提供的，而不是由 Remix 直接提供。Remix 的启动模板设置了一个 `public`
    文件夹和必要的服务器代码。
- en: You also learned about the `links` route module export. You now know that Remix
    prefetches linked resources when using the prefetch property on `Link` and `NavLink`
    components. You also practiced creating route-scoped CSS stylesheets by declaring
    nested `links` exports.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你还了解到了 `links` 路由模块导出。现在你知道，当在 `Link` 和 `NavLink` 组件上使用预取属性时，Remix 会预取链接资源。你还练习了通过声明嵌套的
    `links` 导出创建路由作用域的 CSS 样式表。
- en: After reading this chapter, you know the importance of image optimization and
    where you can get started. You understand that images must be optimized before
    being served. You also know that CDNs and other services can be used to handle
    image optimization for us.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读这一章后，你了解了图像优化的重要性以及你可以从哪里开始。你明白在提供之前必须对图像进行优化。你还知道可以使用 CDN 和其他服务来为我们处理图像优化。
- en: Finally, you learned that you can use resource routes to serve static assets.
    We used the square bracket notation to escape sections of a route name (for example,
    `[.txt]`). With that, we created a resource route that matches the `/robots.txt`
    path and implemented a `loader` function that returns a text file response.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你了解到你可以使用资源路由来提供静态资源。我们使用了方括号符号来转义路由名称的部分（例如，`[.txt]`）。有了这个，我们创建了一个匹配 `/robots.txt`
    路径的资源路由，并实现了一个返回文本文件响应的 `loader` 函数。
- en: In the next chapter, we will add file-uploading capabilities to BeeRich and
    use a resource route to manage user access to user files. This will conclude part
    two of this book and enable us to kick off advanced topics in part three.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向 BeeRich 添加文件上传功能，并使用资源路由来管理用户对用户文件的访问。这将结束本书的第二部分，并使我们能够启动第三部分的高级主题。
- en: Further reading
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can find more information about meta tags in the MDN Web Docs: [https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 MDN Web Docs 中找到更多关于元标签的信息：[https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta)。
- en: 'You can learn more about Remix’s route module meta export in the Remix documentation:
    [https://remix.run/docs/en/2.0.0/route/meta](https://remix.run/docs/en/2.0.0/route/meta).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Remix 文档中了解更多关于 Remix 的路由模块元导出的信息：[https://remix.run/docs/en/2.0.0/route/meta](https://remix.run/docs/en/2.0.0/route/meta)。
- en: 'You can read more about `robots.txt` files in the Google documentation: [https://developers.google.com/search/docs/crawling-indexing/robots/intro](https://developers.google.com/search/docs/crawling-indexing/robots/intro).'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Google 文档中了解更多关于 `robots.txt` 文件的信息：[https://developers.google.com/search/docs/crawling-indexing/robots/intro](https://developers.google.com/search/docs/crawling-indexing/robots/intro)。
- en: 'Review the MDN Web Docs if you want to learn more about link tags: [https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于链接标签的信息，请查看 MDN Web Docs：[https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link)。
- en: 'You can find more information about handling styling in Remix in the Remix
    documentation: [https://remix.run/docs/en/2/styling/css](https://remix.run/docs/en/2/styling/css).'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Remix 文档中找到更多关于在 Remix 中处理样式的信息：[https://remix.run/docs/en/2/styling/css](https://remix.run/docs/en/2/styling/css)。
- en: 'You can learn more about working with resource routes in the Remix documentation:
    [https://remix.run/docs/en/2/guides/resource-routes](https://remix.run/docs/en/2/guides/resource-routes).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Remix 文档中了解更多关于使用资源路由的信息：[https://remix.run/docs/en/2/guides/resource-routes](https://remix.run/docs/en/2/guides/resource-routes)。
