- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Optimization Techniques for Angular Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today’s digital age, users expect applications to be fast and responsive.
    A slight delay can lead to decreased user satisfaction and can even impact business
    metrics. By understanding and implementing performance optimization techniques,
    you ensure that your applications meet user expectations, leading to better user
    engagement, higher retention rates, and positive user feedback. So, as we delve
    deeper into the world of Angular and PrimeNG, it’s essential to ensure our applications
    are not just functional and aesthetically pleasing but also perform at their peak.
    This chapter is dedicated to equipping you with the tools and techniques to optimize
    the performance of Angular applications that utilize PrimeNG components.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, you’ll delve into the core concepts of performance
    optimization. We’ll unravel some popular techniques, such as lazy loading, `trackBy`
    via `*ngFor`, pure pipes, bundle optimization, and more. As we progress, you’ll
    be introduced to the subtle nuances of change detection strategies, gaining a
    comprehensive understanding of their profound implications on performance. To
    round off, we’ll immerse you in hands-on sessions with Angular’s built-in performance
    tools. These tools stand out as true game-changers that are adept at pinpointing
    and rectifying performance bottlenecks.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Angular performance optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with performance profiling and analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing lazy loading and deferring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with change detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing data binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with code and bundle optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter contains various working code samples on Angular optimization.
    You can find the related source code in the `chapter-10` folder in this book’s
    GitHub repository: [https://github.com/PacktPublishing/Next-Level-UI-Development-with-PrimeNG/tree/main/apps/chapter-10](https://github.com/PacktPublishing/Next-Level-UI-Development-with-PrimeNG/tree/main/apps/chapter-10).'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Angular performance optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every developer dreams of building applications that are both feature-rich and
    blazing fast. But as we add more features and complexity to our Angular applications,
    we might inadvertently introduce performance bottlenecks. That’s where **Angular
    performance optimization** comes into play. Let’s dive deep into understanding
    this crucial aspect of Angular development.
  prefs: []
  type: TYPE_NORMAL
- en: What is Angular performance optimization?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Angular performance optimization** refers to the practice of improving the
    performance and responsiveness of Angular applications by applying various techniques,
    strategies, and best practices. It involves identifying and addressing performance
    bottlenecks, reducing unnecessary computations, optimizing rendering processes,
    and minimizing load times. By optimizing the performance of Angular applications,
    we can enhance user satisfaction, minimize user exits, and improve overall application
    success.'
  prefs: []
  type: TYPE_NORMAL
- en: Major performance issues in Angular applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular is a powerful framework, but like any tool, it’s not immune to performance
    issues. Some of the common culprits are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Slow initial load time**: When an Angular application has a large code base,
    loading all the required resources can be time-consuming. Slow initial load times
    can significantly impact user perception and engagement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Excessive change detection**: Angular’s default change detection mechanism
    can be computationally expensive, especially in large applications with frequent
    updates. Inefficient change detection can lead to unnecessary rendering and performance
    degradation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory leaks**: These can occur when components or services are not destroyed
    properly, particularly in cases where you overlook unsubscribing from an observable,
    leading to increased memory usage over time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complex computations**: Running complex algorithms or computations, especially
    in real-time scenarios such as animations, can slow down the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inadequate lazy loading**: Loading all components and modules upfront, even
    if they are not immediately required, can result in increased initial load times.
    A lack of proper lazy loading techniques can impact the application’s performance
    negatively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Popular optimization techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To address these performance issues and optimize the performance of Angular
    applications, developers employ various techniques and strategies. Here are some
    popular optimization options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance profiling and analysis**: Angular provides built-in performance
    tools and techniques that allow us to profile and analyze the performance of our
    applications. Tools such as Angular DevTools help identify performance bottlenecks
    and provide insights for optimization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lazy loading and deferring**: They are techniques that load modules or components
    on-demand, rather than upfront. By implementing lazy loading and deferring in
    our Angular applications, we can reduce the initial load time and improve overall
    performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Default` strategy and the `OnPush` strategy. By choosing the appropriate change
    detection strategy based on the application’s requirements, we can minimize unnecessary
    change detection and improve performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trackBy` function usage, helps minimize unnecessary updates and improve rendering
    performance. Optimized data binding ensures that only the necessary components
    are updated when changes occur.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code and bundle optimization**: Minifying and bundling JavaScript and CSS
    files, tree shaking, and code splitting are techniques that are used to optimize
    the size and loading speed of Angular applications. These optimizations reduce
    network requests and improve overall performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand Angular performance optimization and its significance,
    in the following sections, we will explore these techniques in detail. We will
    start with performance profiling and analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing performance profiling and analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Performance profiling** is similar to a health checkup for your application.
    It involves monitoring the application’s operations, understanding where it spends
    most of its time, and identifying potential bottlenecks. **Analysis**, on the
    other hand, is the subsequent step where this data is interpreted, issues are
    pinpointed, and strategies for performance enhancement are devised.'
  prefs: []
  type: TYPE_NORMAL
- en: When is performance profiling and analysis used?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The need for performance profiling and analysis arises in the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: Parts of an application seem slower than expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s a desire to ensure that new implementations don’t degrade performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Large-scale applications need to optimize resource-intensive operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal is to offer users a seamless experience, characterized by swift load
    times and fluid interactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does performance profiling and analysis work in Angular?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Performance profiling captures data about an application’s behavior during runtime.
    For Angular developers, a game-changer in this space is the **Angular DevTools**
    extension ([https://angular.io/guide/devtools](https://angular.io/guide/devtools)).
    This browser extension, tailored for Angular applications, offers insights into
    component tree structures and change detection cycles and even provides a dedicated
    performance profiling feature. It’s an indispensable tool that complements the
    browser’s native developer tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'To utilize the Angular DevTools extension for performance profiling, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the Angular DevTools extension in your preferred web browser. The extension
    is available for Chrome and Firefox and can be installed from the respective browser’s
    extension marketplace. In this section, I will use the Chrome browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Chrome DevTools by right-clicking on an element of your Angular application
    and selecting **Inspect** (or by using the *Ctrl* + *Shift* + *I* keyboard shortcut).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Chrome DevTools, click on the **Angular** tab to switch to the Angular
    DevTools view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.1 – The Angular DevTools tab](img/B18805_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – The Angular DevTools tab
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the Angular DevTools, you can enable the performance profiling feature
    by clicking on the red circle to collect performance data related to rendering,
    change detection, and other Angular-specific activities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Angular DevTools profiling](img/B18805_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Angular DevTools profiling
  prefs: []
  type: TYPE_NORMAL
- en: With performance profiling enabled, interact with your Angular application and
    perform typical user actions. The Angular DevTools extension will collect performance
    data in real time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use Angular DevTools to inspect various performance metrics and identify areas
    of concern. For example, you can analyze the time spent on rendering individual
    components, the number of change detection cycles, or the duration of network
    requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Based on the collected performance data, identify components, directives, or
    services that contribute to performance bottlenecks. Look for areas where rendering
    or change detection takes a significant amount of time or where unnecessary data
    fetching occurs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once performance bottlenecks have been identified, make targeted optimizations
    to the code, component structure, or data fetching mechanisms. This may involve
    optimizing change detection strategies, implementing memoization techniques, or
    introducing pagination or caching for data fetching.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After applying optimizations, reanalyze the performance of your Angular application
    using the Angular DevTools. Validate that the optimizations have improved the
    identified performance bottlenecks and have not introduced new issues. Iterate
    on the optimization process if further improvements are necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By following these steps and utilizing the Angular DevTools extension, you can
    gain valuable insights into Angular applications’ performance characteristics.
    This enables you to make informed optimizations and improve the overall performance
    of the applications.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It’s easy to fall into the trap of over-optimization. Always weigh the benefits
    of optimization against the effort and complexity introduced. For example, if
    the component in question is relatively simple and the performance gains from
    implementing advanced optimization techniques are negligible or difficult to measure,
    it might be more practical to stick with the default change detection strategy
    provided by Angular. This ensures a balance between optimization and development
    effort, avoiding unnecessary complexity and potential trade-offs in code maintainability
    and readability.
  prefs: []
  type: TYPE_NORMAL
- en: Performance profiling and analysis serve as the magnifying glass, revealing
    the intricate details of our application’s behavior and efficiency. In the next
    section, we’ll delve into the realm of lazy loading, a technique that promises
    to further enhance our application’s responsiveness and speed.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing lazy loading and deferring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lazy loading** and **deferring** are design patterns in which content is
    loaded only when it’s needed or requested, rather than loading everything upfront.
    This approach optimizes resource allocation and improves performance. Here is
    a detailed explanation of these concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lazy loading**: Lazy loading is a design pattern in which content, such as
    Angular routes, components, or services, is loaded dynamically and on-demand,
    rather than everything being uploaded upfront. By implementing lazy loading, unnecessary
    resources are not loaded initially, resulting in a smaller initial bundle size
    and improved application startup times. This approach is particularly useful in
    large-scale applications, where loading all resources upfront can lead to performance
    degradation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deferring**: Deferring is a design pattern that involves delaying the loading
    or execution of certain resources, such as scripts or assets, until they are needed.
    In the context of web development, deferring typically refers to deferring the
    loading of JavaScript files or other resources that are not essential for the
    initial rendering and functionality of a web page. By deferring the loading of
    non-critical resources, the web page can be rendered and displayed more quickly,
    improving the perceived performance and overall user experience. This technique
    is often employed to prioritize and optimize the loading of critical resources,
    allowing the page to be usable as soon as possible while non-essential resources
    are loaded in the background.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When are lazy loading and deferring used?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lazy loading and deferring are especially beneficial in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Large applications**: For applications with numerous features and components,
    loading everything at once can be resource-intensive. Lazy loading ensures that
    only the necessary components are loaded, improving the initial load time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User roles and permissions**: In applications where different users have
    different roles and permissions, lazy loading can be used to load components based
    on user roles, ensuring that users only download the features they have access
    to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network efficiency**: For users with slower internet connections, downloading
    a large application can be time-consuming. Lazy loading can help by reducing the
    initial download size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feature-rich platforms**: In platforms where certain features are used less
    frequently than others, it makes sense to defer those lesser-used features to
    improve the initial load time of the platform, resulting in faster rendering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example of lazy loading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine an eCommerce platform built using Angular. This platform has various
    routes such as **Home**, **Product Listings**, **Product Details**, **Cart**,
    and **User Profile**. In a traditional loading approach, when a user visits the
    site, they would download all these routes/components upfront, even if they’re
    just browsing the **Home** page. For example, without lazy loading, the routing
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, the routing name is associated with a component. When the user
    navigates to the `home` page, `HomeComponent` will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Page without lazy loading](img/B18805_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Page without lazy loading
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice that when the application is loaded, it loads all the necessary
    scripts from the beginning. As you can see, the main bundle size is **820 kB**
    and is loaded in **1.40 s**. When you navigate to other routes, their scripts
    are already ready-loaded. This could lead to unnecessary data consumption and
    a delay in page rendering, especially if the user never visits certain sections,
    such as **Cart** or **User Profile**, during their session. Let’s see how lazy
    loading can improve the current implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'With lazy loading, the application can be structured to load the routes more
    intelligently:'
  prefs: []
  type: TYPE_NORMAL
- en: Initially, only the **Home** page is loaded when a user visits the site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a user decides to view a product, the **Products** page is loaded on the
    fly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user wants to check their shopping cart, the **Cart** page is loaded
    just in time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If they decide to view or edit their profile, the **User Profile** page is then
    loaded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s a basic example of how lazy loading can be implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the `loadComponent` property is utilized to define
    functions that will load the respective component, but only when the routes are
    activated. This ensures that users only download the parts of the application
    they are actively engaging with, leading to faster load times and more efficient
    use of resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Page with lazy loading](img/B18805_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Page with lazy loading
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the website only loads `main.js` and `HomeComponent` for the
    first navigation. You’ll observe a significant enhancement as the main bundle
    size has decreased from `CartComponent` if you navigate to the cart route, which
    is initiated from `app.routes.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: Example of PrimeNG deferring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PrimeNG’s **Defer** directive is a tool that’s designed to delay the loading
    of content until it enters the viewport. In essence, it’s a form of lazy loading,
    but for various types of content. By deferring the initialization of content until
    it’s needed, we can significantly improve the initial load time of a page.
  prefs: []
  type: TYPE_NORMAL
- en: Take the eCommerce site as an example. The site lists hundreds of products on
    its `Defer`, we can optimize this.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, first, ensure you’ve imported `DeferModule` from PrimeNG:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s see how a PrimeNG `Defer` can be set up to display the product list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break this down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<div pDefer>`: The purpose of the `pDefer` directive is to defer the rendering
    of its contents until later in the rendering cycle. This directive must be followed
    by an `ng-template` element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<p-card *ngFor="let product of products">`: This element utilizes the `*ngFor`
    directive to iterate over an array of `products`, rendering one `<p-card>` for
    each product in the array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the implementation, the content of the product list will not appear until
    it becomes visible in the scroll.
  prefs: []
  type: TYPE_NORMAL
- en: 'PrimeNG `Defer` is also beneficial when you want to fetch product data from
    an API after the product list is in the viewport, which will greatly enhance the
    performance of your application. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<div pDefer (onLoad)="loadAnotherProducts()">`: This `<div>` element is using
    the `pDefer` directive, which defers the loading products and rendering of its
    contents until the element is in the viewport.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loadAnotherProducts() { ... }`: This method is executed when the `(onLoad)`
    event is triggered. Inside the method, it calls `this.productService.loadProducts()`
    to load the products and assign the result to the `anotherProducts` property in
    the component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are working with `Table`, `Tree`, or a long list of items, you can implement
    `Virtual Scroller` or `Pagination` to help enhance performance and increase user
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Harnessing the power of lazy loading and deferring can significantly enhance
    the performance of our applications, ensuring that users only load what they need
    when they need it. In the next section, we’ll delve into another crucial aspect
    of Angular performance: understanding and managing change detection.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with change detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Change detection** is the process by which Angular determines if components
    need to be updated in response to data changes. Whenever the data-bound properties
    of a component change, Angular checks if the view needs to be updated to reflect
    those changes. This process is automatic, but it’s essential to understand its
    workings to optimize performance.'
  prefs: []
  type: TYPE_NORMAL
- en: How does change detection work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The change detection process in Angular follows a unidirectional flow. It starts
    from the root component and traverses down the component tree, checking for changes
    in each component. Here’s a brief overview of how change detection works in Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Initialization**: During component initialization, Angular sets up the component’s
    change detector and initializes the component’s properties and bindings.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Default` strategy triggers change detection for a component whenever any of
    its input properties change or when an event binding is fired. Take the following
    component tree as an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![  Figure 10.5 – Change detection – the default strategy](img/B18805_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Change detection – the default strategy
  prefs: []
  type: TYPE_NORMAL
- en: When an event occurs on the `ProductList` component, the change detection process
    initiates, propagating from the root level (`AppComponent`) through all of its
    descendant components.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the `OnPush` strategy triggers change detection only when
    an input property changes or when the component receives an event from its template
    or a component in its view hierarchy. In the same scenario previously illustrated
    in *Figure 10.5*, introducing the `OnPush` change detection strategy to the `ProductListDefer`
    component alters the behavior of the change detection process:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![  Figure 10.6 – Change detection – the OnPush strategy](img/B18805_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Change detection – the OnPush strategy
  prefs: []
  type: TYPE_NORMAL
- en: Now, when an event occurs on the `ProductList` component, change detection is
    limited to the hierarchy from `AppComponent` to `Products` and down to `ProductList`.
    Notably, there is no change detection on the `ProductListDefer` component because
    no new reference is passed to the `ProductListDefer` component.
  prefs: []
  type: TYPE_NORMAL
- en: '**Change detection cycle**: Angular’s change detection system follows a cyclic
    process. In each cycle, the change detection process is performed for all components
    in the component tree. It involves the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Change detection check**: Angular checks the component’s properties, bindings,
    and other inputs to detect changes. It compares the current values with the values
    that were stored during the previous change detection cycle.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Update view**: If a change is detected, Angular updates the component’s view
    by updating the DOM elements associated with the changed properties or bindings.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Propagation**: If the component’s view is updated, Angular propagates the
    changes to the child components in the component tree, triggering their change
    detection process recursively.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ChangeDetectorRef` class provides a set of functions to interact with the
    change detection mechanism:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`markForCheck()`: This function marks the component and its ancestors as needing
    checking during the next change detection cycle. Even if the component is not
    directly involved in the change, marking it for check ensures that its view will
    be updated.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`detach()`: This function detaches the component’s change detector from the
    change detector tree. This means that the component will be skipped during the
    change detection process until it is reattached.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`detectChanges()`: Invoking `detectChanges()` triggers a change detection cycle
    for the component and its descendants. This is particularly useful when you want
    to manually check for changes in response to specific events.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reattach()`: This function reverses the effect of `detach()`. It reattaches
    the component’s change detector to the change detector tree, allowing it to participate
    in subsequent change detection cycles.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the pivotal elements in Angular’s change detection mechanism is `zone.js`.
    This library plays a crucial role by “monkey-patching” most asynchronous operations
    in a browser, such as user interactions, HTTP requests, and timers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '**Monkey patching** is a technique that allows for the modification, extension,
    or even suppression of the default behavior of a code segment, all without requiring
    any direct changes to its source code.'
  prefs: []
  type: TYPE_NORMAL
- en: When these operations are completed, `zone.js` notifies Angular to run change
    detection. Essentially, it acts as a watchdog, keeping an eye on all asynchronous
    tasks. Once any of these tasks are complete, `zone.js` informs Angular to check
    components and update the view if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, when a user clicks a button, `zone.js` detects this interaction
    and tells Angular that something might have changed. Angular then runs the change
    detection process, checking if there are any actual changes to update in the view.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For third-party scripts, one of the techniques that can help improve the performance
    of your application is to load the script and run the logic outside of Angular
    NgZone ([https://angular.io/api/core/NgZone#runoutsideangular](https://angular.io/api/core/NgZone#runoutsideangular)).
  prefs: []
  type: TYPE_NORMAL
- en: How change detection strategies affect performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The default change detection strategy is thorough but can be inefficient for
    large applications or complex component trees. Every minor data change triggers
    a check across all components, which can lead to lag or janky animations, especially
    on slower devices.
  prefs: []
  type: TYPE_NORMAL
- en: One way to improve performance is to utilize the `OnPush` strategy, in which
    we’re telling Angular to be more selective about when it checks for changes. This
    can lead to a noticeable performance boost as Angular will skip checking components
    that we know haven’t changed. However, it also means we need to be more mindful
    of when and how data changes to ensure our views remain up to date.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we have two lists that display a list of products using PrimeNG
    components. By default, Angular checks for changes in this component and all its
    children every time something happens in our application. However, if our product
    lists don’t change frequently, this can be overkill and lead to performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look into the details of the default change detection strategy. Here
    is the sample code for the **Products** page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet is an example of an Angular component called `ProductsComponent`.
    Let’s break down the code and explain its functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<input type="text" pInputText (keyup)="filterProduct()" ... />`: This defines
    a PrimeNG input field that executes the `filterProduct()` method whenever a key
    is released in the input field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<primengbook-product-list [products]="..." />`: This represents a custom component
    called `primengbook-product-list` and binds the `filteredProducts` or `anotherProducts`
    property of the component to the `products` input property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is an example of a standalone component utilizing the default change detection
    strategy, which is set to `Default` by default. Let’s observe how the application
    behaves in this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – A page using the default change detection strategy](img/B18805_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – A page using the default change detection strategy
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, after we type the keyword for filtering products, it rerenders
    the two lists of products and the total time spent for the entire app is 4.4 ms,
    even though we only do the search on one product list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ideal situation is that when you search, it will only touch one product
    list. To optimize the code so that it follows this, we can set the change detection
    strategy to `OnPush` in `ProductListComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With this setup, Angular will only check the one `ProductListComponent` for
    changes when its input properties change. This means that Angular won’t waste
    cycles checking unrelated components. Let’s see how the application performs this
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – The page with the default change detection strategy](img/B18805_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – The page with the default change detection strategy
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice that when we search, our application only rerenders one product
    list, which reduced the time spent from 4.4 ms to 1.1 ms in total. This is a significant
    improvement if your application is complex.
  prefs: []
  type: TYPE_NORMAL
- en: Potential pitfalls of OnPush
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While `OnPush` is powerful, it’s not without its quirks. One common issue you
    may run into is that changes made inside the component (such as user interactions)
    won’t trigger change detection. This can lead to situations where the UI doesn’t
    update, even though the data has changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another challenge is when working with objects and arrays. If you modify an
    object or array that’s an input property, but the reference remains the same,
    Angular won’t detect the change. This is where libraries such as `immutable.js`
    or Angular Signals come into play:'
  prefs: []
  type: TYPE_NORMAL
- en: '`List`, `Map`, and `Set` that, by design, cannot be modified after creation.
    This immutability ensures that any change to data results in a new object reference,
    making it more efficient for Angular to detect differences. Furthermore, `Immutable.js`
    encourages the use of pure functions when modifying data, creating new instances
    of data structures while preserving the original data. Angular can then efficiently
    identify changes by comparing object references.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update` also enforces an immutable approach, which is a usual practice when
    working with `OnPush` change detection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I highly recommend using Signals when it’s ready for production to optimize
    the rendering updates since it is a built-in solution from Angular instead of
    a third-party library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the realm of Angular, understanding change detection strategies is pivotal
    for ensuring our applications run efficiently. Next, let’s delve into another
    crucial aspect of Angular performance: optimizing data binding to further enhance
    our app’s responsiveness and speed.'
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing data binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At its core, **data binding** in Angular is about keeping your view and component
    data in sync. It’s the magic that allows a change in your component data to reflect
    instantly in your view and vice versa. However, not all data changes are equal.
    Some are frequent and minor, while others are rare but significant. Optimized
    data binding is about being selective, updating the view only when truly necessary,
    and doing so in the most efficient manner.
  prefs: []
  type: TYPE_NORMAL
- en: When is optimized data binding used?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Optimized data binding techniques are typically employed in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Large datasets**: When working with large datasets, updating the entire view
    whenever a small portion of the data changes can be inefficient. Optimized data
    binding techniques help identify and update only the relevant portions of the
    view, minimizing unnecessary updates and improving performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Frequent updates**: In applications where data changes frequently, traditional
    data binding approaches can lead to excessive re-rendering and unnecessary DOM
    manipulations. Optimized data binding techniques help optimize data change detection
    and update processes to reduce overhead and improve responsiveness.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complex computation**: In some cases, data binding involves computationally
    expensive operations, such as sorting or filtering large arrays. Optimized data
    binding techniques can optimize these operations by selectively updating only
    the affected parts of the view, rather than re-rendering the entire dataset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A few optimized data binding techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Optimizing data binding in Angular revolves around a few key strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*ngFor` to loop through items, by default, Angular checks each item in the
    list to detect changes. By using a `trackBy` function, you can instruct Angular
    to track items based on their unique IDs, reducing unnecessary checks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pure pipes**: Pipes transform data in your template. A pure pipe only re-evaluates
    when the input changes, making it more efficient than its impure counterparts.
    It’s crucial to bear in mind that making external requests within pipes can cause
    performance issues and should be avoided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnPush` change detection strategy, Angular only triggers change detection
    for a component when its input properties change or when an event is raised within
    the component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Immutable data structures**: Using immutable data structures can improve
    data binding performance. Immutable objects are not modified directly; instead,
    they create new instances when changes occur. This allows Angular to detect changes
    more efficiently and optimize rendering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will explore examples of the `trackBy` function
    and pure pipes.
  prefs: []
  type: TYPE_NORMAL
- en: Optimized data binding example – the trackBy function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine an eCommerce platform displaying a list of products. Each product has
    a name, price, and rating. With thousands of products, any change in the product
    list, such as a price update, could potentially trigger a massive view update.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `trackBy` function, we can ensure that only the affected product
    gets updated in the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `trackBy` function ensures that Angular only updates the
    view for products with actual change based on product id value.
  prefs: []
  type: TYPE_NORMAL
- en: 'PrimeNG also seamlessly supports the `trackBy` function. Since version 16.x,
    PrimeNG provides the `trackBy` property, where you can pass `trackBy` function
    to the data binding in the `DataView`, `OrderList`, `PickList`, and `Tree` components.
    Here’s an example of how to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As demonstrated in the `DataView` component, you can assign the `trackByProductId`
    function to the `trackBy` property. This configuration ensures that the view is
    only updated when the product ID value changes.
  prefs: []
  type: TYPE_NORMAL
- en: Optimized data binding example – pure pipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose you have an Angular application that displays a list of products. Each
    product has properties such as name, price, and quantity. The application also
    allows the user to calculate the product’s pricing using a calculation based on
    the existing product quantity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without using pure pipes, you might have a component template that looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `calculateTotal` function is called for each product to
    calculate the total price based on the existing product quantity. Consider the
    scenario where the `calculateTotal` function is a custom function that performs
    a complex calculation. Let’s look at the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Calculating the total price from the template](img/B18805_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – Calculating the total price from the template
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, without any optimization, every time a change is made to the
    product or the page, the `calculateTotal` function would be called for all products,
    even if only a single product’s quantity has changed. This leads to unnecessary
    executions, even if only a single product’s quantity has changed, resulting in
    20 executions, as indicated in the console log. This can lead to redundant recalculations
    and harm performance, particularly when working with extensive datasets.
  prefs: []
  type: TYPE_NORMAL
- en: 'To optimize the performance using pure pipes, you can create a custom pure
    `pipe` called `TotalPipe` that calculates the total price for a given product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `TotalPipe` has been declared as a pure pipe by setting the
    `pure` property to `true` in the `@Pipe` decorator. This ensures that the pipe
    will only recalculate its output when the quantity value changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can use `TotalPipe` in your component template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'By using `TotalPipe`, the calculation of the total price is now delegated to
    the pipe. If a change is made to the quantity of a product, only the affected
    product’s total price will be recalculated; the other products will remain unaffected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Calculating the total price from the pipe](img/B18805_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – Calculating the total price from the pipe
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, when there is a change in the quality or product, it only affects
    one product instead of there being 20 changes (*Figure 10**.9*), as in the previous
    approach. This optimization significantly improves performance, especially when
    dealing with large datasets or complex calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In conclusion, optimizing data binding in web applications is essential for
    improving performance and reducing unnecessary re-rendering. By following best
    practices, you can minimize the impact of data binding on application performance.
    Now, let’s transition to the next topic: code and bundle optimization.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with code and bundle optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Code and bundle optimization** refers to the process of optimizing the code
    base and the resulting bundles in a web application to enhance its performance
    and efficiency. It involves analyzing, restructuring, and minimizing code to eliminate
    redundancies, reduce file sizes, and improve execution speed.'
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing both the code and bundle size is essential for delivering faster-loading
    web applications, reducing bandwidth usage, and enhancing the overall user experience.
    It helps ensure that the application loads quickly, responds promptly to user
    interactions, and performs efficiently across a range of devices and network conditions.
  prefs: []
  type: TYPE_NORMAL
- en: When is code and bundle optimization used?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Optimization isn’t just a one-time task; it’s an ongoing process. As soon as
    our application starts to grow, or when we notice performance issues, it’s time
    to consider optimization. It’s especially crucial for the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: Large applications with extensive code bases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apps that rely on several third-party libraries or frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications targeting regions with slower internet connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Projects aiming for faster load times and improved user experience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing Source Map Explorer for bundle optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most effective tools for understanding the composition of your application’s
    bundles is **Source Map Explorer**. It provides a visual representation of the
    different parts of your bundle, making it easier to identify large chunks of code
    or unnecessary libraries that might be affecting your app’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before diving into its usage, let’s set up Source Map Explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add Source Map Explorer to your project by using `npm` or `yarn`. Run
    the following command in your project directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To generate source maps during the build process, you need to adjust the Angular
    build configuration. In your `angular.json` file, locate the `sourceMap` option
    within your application’s build configurations and set it to `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the tool installed and the configuration adjusted, you’re ready to analyze
    your bundles:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to create a production build of your Angular application with
    source maps. Use the following command to do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After building, navigate to the `dist` folder (or wherever your build artifacts
    are located). You’ll find several `.js` and `.js.map` files. To analyze a specific
    bundle, use Source Map Explorer, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Source Map Explorer will present a visual treemap of your bundle. Each section
    represents a portion of your code or an imported library. The size and position
    of each section correlate with its size in the bundle. Hovering over a section
    will display more detailed information. Here is an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Visual map of the bundle](img/B18805_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – Visual map of the bundle
  prefs: []
  type: TYPE_NORMAL
- en: The treemap’s visual representation makes it easier to spot large libraries
    or chunks of code. If you see a library that you don’t recognize or seems disproportionately
    large, it might be worth investigating further. You can research the unfamiliar
    library, analyze its dependencies, review its usage in your code base, and seek
    community feedback to understand its purpose and impact on performance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While source maps are invaluable for development and analysis, they can expose
    your application’s code structure. Always ensure that source maps are not served
    in a production environment unless you want to debug on production.
  prefs: []
  type: TYPE_NORMAL
- en: In the web development world, optimizing your code and bundles is essential
    to achieving the best application performance. Through tools and techniques such
    as Source Map Explorer, we’ve learned how to dissect and refine our application
    bundles for peak efficiency. As we wrap up this chapter, let’s take a moment to
    reflect on the key takeaways.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we delved deep into the world of performance and optimization.
    We embarked on a journey to understand the intricacies of Angular performance,
    from the foundational concepts of lazy loading to the advanced techniques of code
    and bundle optimization.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you’re equipped with the knowledge of how to optimize Angular
    applications, especially those utilizing PrimeNG components. We’ve seen firsthand
    the transformative power of efficient change detection strategies, the nuances
    of optimized data binding, and the importance of analyzing and refining our application
    bundles. These techniques are not just theoretical; they have practical implications
    that can drastically improve the user experience of your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Why is this so crucial? In the fast-paced digital age, every millisecond counts.
    Users expect seamless, lightning-fast applications, and even the slightest delay
    can impact user retention and satisfaction. By implementing the strategies we’ve
    discussed, you’re not just enhancing your application’s performance; you’re also
    ensuring that your users have the best experience possible.
  prefs: []
  type: TYPE_NORMAL
- en: As we transition to the next chapter, we’ll shift our focus to building reusable
    components that can be easily integrated and adapted across various parts of our
    applications. This will empower you to write code that’s not only efficient but
    also modular and maintainable. So, gear up for another exciting journey where
    we’ll delve into the best practices and techniques for crafting versatile Angular
    components.
  prefs: []
  type: TYPE_NORMAL
