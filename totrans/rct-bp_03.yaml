- en: Chapter 3. Responsive Web Development with ReactJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A few years ago, building web apps was relatively easy. Your web apps were viewed
    on desktops and laptops with roughly the same screen sizes and could create a
    lightweight mobile version to serve the few mobile users who visited your site.
    Today the tables have turned and mobile devices are just as important, often even
    more so than desktops and laptops. The screen sizes today can vary from a 4" smartphone
    to a 9" tablet and any size in between.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll be looking at the practice of building a web app suitable
    to work on any device, regardless of size or whether the app will be viewed on
    a desktop or mobile browser. The goal is to create an app environment that moulds
    itself to the user's setup and provides a gratifying experience for everyone.
  prefs: []
  type: TYPE_NORMAL
- en: 'The term "**responsive development**" is an umbrella term covering a range
    of design techniques such as **adaptive**, **fluid**, **liquid**, or **elastic**
    layouts, and **hybrid** or **mobile** development. It can be broken into two main
    components: a flexible layout and flexible media content.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cover everything you need to create a responsive app in ReactJS in these
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a flexible layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the right framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a responsive app with Bootstrap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a flexible grid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a responsive menu and navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating responsive wells
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating responsive panels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating responsive alerts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedding media and video content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating responsive buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating dynamic progress bars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating fluid carousels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with fluid images and the picture element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating responsive form fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using glyph- and font-awesome icons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a responsive landing page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a flexible layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flexible layouts change in width based on the size of a user's viewport. Viewport
    is a generic term for the viewable area of the user's device. It's preferred over
    terms such as a window or browser size because not all devices use Windows. You
    may design the layout to use a percentage of the user's width or not assign any
    width at all and have the layout fill up the viewport regardless of how big or
    small it is.
  prefs: []
  type: TYPE_NORMAL
- en: Before we talk about all the advantages of a **flexible** layout, let's briefly
    look at its counterpart, the **fixed width** layout.
  prefs: []
  type: TYPE_NORMAL
- en: Fixed width means setting the overall width of a page to a predetermined pixel
    value and then designing the app elements with this constraint in mind. Before
    the explosive proliferation of web-enabled mobile devices, this was the primary
    design technique for developing web applications.
  prefs: []
  type: TYPE_NORMAL
- en: A fixed width design has certain benefits. The main benefit is that it gives
    designers complete control of the look. Basically, the user sees what the designer
    designs. It's also easier to structure, and working with fixed width elements,
    such as images and forms, is less of a hassle.
  prefs: []
  type: TYPE_NORMAL
- en: The obvious drawback with this type of design is that you end up with a rigid
    layout that doesn't change based on any variation in the user environment. You
    will often end with excessive white space for devices with large viewports, upsetting
    certain design principles, or a design that is too wide for devices with small
    viewports.
  prefs: []
  type: TYPE_NORMAL
- en: Going with a fixed width design may be appropriate for some use cases, but as
    it depends on your decision to guess which layout constraints work best for most
    users of your app, you're likely to exclude a potentially huge group of users
    from using your app.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, a responsive app should generally be designed with a flexible
    layout in order to remain usable for every user of your app.
  prefs: []
  type: TYPE_NORMAL
- en: An *adaptive* app generally refers to an app that is easily modifiable when
    a change occurs, while *responsive* means to react quickly to changes. The terms
    are interchangeable, and when we use the term "responsive", it's usually inferred
    that it should also be adaptive. *Elastic* and *fluid* roughly mean the same and
    usually describe a percentage-based design that molds to changes in browser or
    viewport size.
  prefs: []
  type: TYPE_NORMAL
- en: '*Mobile* development, on the other hand, means creating a separate version
    of your app that is meant to run exclusively on cell phone browsers. This is occasionally
    a good approach, but it comes with several tradeoffs, such as maintaining a separate
    code base, relying on browser sniffing to send users to the mobile version, and
    problems with **search engine optimization** (**SEO**), since you have to maintain
    separate URLs for the mobile and the desktop version.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Hybrid apps* refer to mobile apps that are developed in such a manner that
    they can be hosted inside a native application that utilizes a mobile platform''s
    **WebView**. You can think of WebView as an exclusive, full-screen browser for
    your app that is hooked inside the mobile platform''s native environment. The
    benefit of this approach is that you can use standard development practices for
    the Web, and in addition, you can gain access to native capabilities that are
    often restricted to access from inside the mobile browsers. Another benefit is
    that you can publish your app on native app stores.'
  prefs: []
  type: TYPE_NORMAL
- en: Developing native apps with ReactJS is an attractive proposition, and with the
    React Native project, it's also a viable option. With React Native, you can use
    everything that you've learned about ReactJS and apply it to develop apps that
    can run on Apple and Android devices and that can be published on Apple's App
    Store and Google Play.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it's certainly possible to set up a flexible layout on your own, using
    a responsive framework makes a lot of sense. For reasons such as you'll save a
    lot of time using a framework that's already been battle tested and maintained
    for many years by a team of skilled designers. You can also take advantage of
    the fact that a widely used responsive framework has a lot of helpful resources
    on the Web. The drawback is that you will need to learn how the framework expects
    you to lay out your pages, and that sometimes, you may not entirely agree on the
    design decisions that the frameworks imposes on you.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these considerations in mind, let''s take a look at some of the major
    frameworks that are available for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bootstrap**: The undisputed leader of the pack is Bootstrap. It''s massively
    popular and there are tons of resources and extensions available. The tie-in with
    the React-Bootstrap project also makes this a very obvious choice when developing
    web apps in ReactJS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zurb Foundation**: Foundation is the second biggest player after Bootstrap
    and a natural choice if you decide that Bootstrap is not for you. It''s a mature
    framework that offers a lot of complexity for very little effort.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pure**: Pure by Yahoo! is a lightweight and modular framework. It''s perfect
    if you''re concerned about the byte size of other frameworks (this one checks
    in at around 4 KB, while Bootstrap checks in around 150 KB and Foundation at 350
    KB).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Material Design**: Material Design by Google is a very strong contender.
    It brings a lot of fresh ideas to the table and is an exciting alternative to
    Bootstrap and Foundation. There''s also a ReactJS implementation called **Material
    UI** that brings together Material Design and ReactJS, which makes this an attractive
    alternative to Bootstrap and React-Bootstrap. Material Design is highly opinionated
    in how the UX elements it provides should behave and interact, while Bootstrap
    and the others give you more freedom on how you set up your interactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's obviously not easy to choose one framework that's right for every project.
    Another choice that we did not mention previously was doing it alone, that is,
    creating the grid and the flexible layout all on your own. It's absolutely a doable
    strategy, but it comes with certain drawbacks.
  prefs: []
  type: TYPE_NORMAL
- en: The major drawback is that you won't benefit from many years of tweaking and
    testing. Even though most modern browsers are quite capable, your code will often
    be run on a myriad of browsers and devices. It's very likely that your users will
    run into issues that you don't know about because you simply don't have the same
    hardware setup.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, you have to decide whether you want to design apps or you desire
    to create a new flexible CSS framework. That choice should make it clear why in
    this chapter we have chosen a particular framework to focus on, and that framework
    is Bootstrap.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap is without doubt the most mature and popular of the preceding frameworks
    and has excellent support in the community. The web landscape is still evolving
    at a fast pace, and you can be confident that Bootstrap will evolve with it.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your app with Bootstrap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've already looked at an implementation of Bootstrap and React-Bootstrap in
    the previous chapter, but we only skimmed the surface as to what you can do. Let's
    take a closer look at what React-Bootstrap can provide us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start this project by making a copy of the scaffolding from [Chapter 1](ch01.html
    "Chapter 1. Diving Headfirst into ReactJS"), *Diving Headfirst into ReactJS*,
    and then add React-Bootstrap to your project. Open a terminal, go to the root
    of your project, and replace your `dependencies` or your `devDependencies` (whichever
    you prefer) with the following list, then issue an `npm install` command from
    your command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, you''ll need to either download the Bootstrap CSS or use a CDN
    to include it in your `index.html` file. Then, add the following to the `<head>`
    section of `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Creating a flexible grid
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At the heart of CSS frameworks such as Bootstrap lies the concept of the **grid**.
    The Grid is a structure that allows you to stack content horizontally and vertically
    in a consistent manner. It provides a predictable layout scaffolding that is easy
    to visualize when you code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Grids are made up of two main components: rows and columns. Within each row,
    you can add a number of columns, from one to as many as 12, depending on the framework.
    Some frameworks, such as Bootstrap, also add a container that you can wrap around
    the rows and columns.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a grid is ideal for a responsive design. You can effortlessly craft websites
    that look great on both large desktop browsers as well as small mobile browsers.
  prefs: []
  type: TYPE_NORMAL
- en: It's all down to how you structure your columns. For instance, you can set up
    a column to be of full width when the browser width is less than or equal to 320
    pixels (a typical mobile browser width), and one-third width when the browser
    width is greater than a given pixel size. The method you employ when toggling
    classes on browser dimension is called **media queries**. All grid frameworks
    come with built-in classes for toggling sizes based on media queries; you will
    rarely need to write your own media queries.
  prefs: []
  type: TYPE_NORMAL
- en: The grid system in Bootstrap utilizes 12 columns and can optionally be set to
    be fluid by initializing it with `<Grid fluid={true}>`. It defaults to nonfluid,
    but it's worth noting that both settings return a responsive grid. The main difference
    is that a fluid grid has 100% width all the time and continually readjusts at
    every width change. A nonfluid grid is controlled by media queries and changes
    widths when the width of the viewport crosses certain thresholds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Grid columns can be differentiated with these properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**xs**: This is for extra small devices such as phones (<768 px)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sm**: This is for small devices such as tablets (≥768 px)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**md**: This is for medium devices such as desktops (≥992 px)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**lg**: This is for large devices such as desktops (≥1200 px)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also use `push` and `offset` in combination with the preceding properties,
    so, for instance, you can use `xsOffset` to offset a column visible on extra small
    devices, and so on. The difference between `offset` and `push` is that `offset`
    will force other columns to move, while `push` will overlap other columns.
  prefs: []
  type: TYPE_NORMAL
- en: Sizes bubble upwards. If you define an `xs` property but no `sm`, `md`, or `lg`
    properties, all columns will use the `xs` settings. If you define `xs` and `sm`
    properties, extra small viewports will use the `xs` property, while all other
    viewports will use the `sm` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a practical example. Create a file in your `source/examples`
    folder (create the folder if it doesn''t exist), call it `grid.jsx`, and add the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In our scripts, we only import what we currently need. In this example, we need
    `Grid`, `Row`, and `Col`, so we'll name these and make sure that they're imported
    and available under those names.
  prefs: []
  type: TYPE_NORMAL
- en: While it would be more convenient to import all the components without naming
    each one specifically, being specific with your imports makes it easier to understand
    what you require in the file you're working on. It will also potentially result
    in a smaller footprint when bundling your JavaScript code for deployment because
    the bundler can remove all components that are available but never used. Note
    that this is not true for current versions of **Browserify** or **Webpack** (which
    we'll talk about in [Chapter 6](ch06.html "Chapter 6. Advanced React"), *Advanced
    React*), but is in the pipeline, at least for Webpack.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you''re importing a single component from a larger library, import it
    with this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will import just the desired component while ignoring the rest of the library.
    If you do this consistently, your bundle size will decrease.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This row will show different column sizes for extra small devices and small
    to large devices:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that sizes bubble upwards, but not downwards.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This row shows two columns that change drastically depending on the viewport.
    On smart phones, the columns are of equal width. On small viewports, the left-hand
    side column covers one third of the row and the right-hand side column covers
    the rest. On medium viewports, the left-hand side column is suddenly the dominant
    column, but on very large viewports, the left-hand side column is again reduced
    to a much smaller proportion.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is obviously a contrived setting meant to demonstrate the capabilities
    of the grid. This would be a very strange setting for a live app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Both columns start with an offset here. This will create a column of empty
    space at the beginning of each column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`Push` moves the column to the right, but doesn''t force the other column to
    move, so it will overlap the next column. This means that the offset in the second
    column will be overlapped by the contents of the first column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to view this example, open `app.jsx` and replace the content with
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll create a lot of components in this chapter, and they can all be added
    to `app.jsx` by adding an `import` statement in the head of your code. ReactJS
    requires you to capitalize your components when you import them. The name you
    give to the import can then be used in your render code by adding the name in
    brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating a grid, it can be very beneficial to make it visible while you''re
    setting it up. You can add this to `app.css` to make it appear in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This styling will make it easy to view and debug the columns that we're adding.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap's grid system is very versatile and makes it easy to structure your
    page just the way you want it. The grid you've made in this example is visible
    and fluid on all devices you throw at it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a flexible grid](img/B04943_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a responsive menu and navigation bar
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This was extensively covered in [Chapter 2](ch02.html "Chapter 2. Creating a
    Web Shop"), *Creating a Web Shop*, so we'll just set up a basic menu here and
    refer to the previous chapter for details on how to connect to a router and set
    up links that work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file in your `source/examples` folder, call it `navbar.jsx`, and add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding `Navbar.Collapse` automatically makes this a mobile-friendly navigation
    bar that replaces the menu items with a **Hamburger** button when the viewport
    is less than 768 pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can set the following properties on the main `Navbar` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`defaultExpanded`: This will expand `Navbar` on small devices if it is set
    to `true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expanded`: This sets the `Navbar` component expanded on runtime (requires
    `onToggle`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fixedBottom`: This will fix the `Navbar` component at the bottom of the viewport'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fixedTop`: This will fix the `Navbar` component at the top of the viewport'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`staticTop`: This will float `Navbar` along with the page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fluid`: This works in the same way as the fluid setting in the grid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inverse`: This inverses the colors in `Navbar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onToggle`: This is a function that you can run when `Navbar` is toggled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentClass`: This is used to add your own classes to `Navbar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating responsive wells
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A well is an inset that can be used for good effect. It's an easy, but effective
    way of emphasizing content. It's also very simple to set up in Bootstrap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new file in `source/examples`, name it `wells.jsx`, and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can set the following properties on the `Wells` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bsSize`: A well can be either *small* or *large*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Creating responsive wells](img/B04943_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating responsive panels
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A panel is like a well, but with more information and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: It can have a heading and it can be collapsible, so it's a good candidate for
    presenting information, containing forms, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a basic panel. Add a new file in `source/components`, name it
    `panels.jsx`, and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This panel is closed by default and controlled by the component''s state variable,
    `open`. When you click on the button, it executes the internal `setState` function.
    The state simply reverses the Boolean value of the `open` variable using the rather
    clever `not` operator. When we use it, we say that we want the opposite of the
    current value, which is either `true` or `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a bit more that we can do with the panel component, but let''s briefly
    look at which other properties we can set on `Panel` first:'
  prefs: []
  type: TYPE_NORMAL
- en: '`header (string)`: Add this to the `Panel` initializer and pass a value to
    give the header some content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`footer (string)`: This is the same as the header but creates the information
    block at the bottom instead of at the top.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bsStyle (string)`: This makes the content meaningful by adding a context class.
    You can choose between all the common Bootstrap context names: `primary`, `success`,
    `danger`, `info`, `warning`, as well as `default`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expanded (boolean)`: This can either be `true` or `false`. This needs to be
    coupled with `collapsible`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaultExpanded (boolean)`: This too can be `true` or `false`. This does not
    override the `expanded` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will often want to display more than one panel and group them together.
    This can be achieved by adding a component called `PanelGroup`.
  prefs: []
  type: TYPE_NORMAL
- en: '`PanelGroups` is a wrapper that you set around all the panels you want to group.
    The code looks like this if you want to group two panels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is a controlled `PanelGroup` instance. This means that only one panel will
    be open at any time, and this is signified by adding the `activeKey` attribute
    to the `PanelGroup` initializer. When you click on the panels in the group, the
    function in the `onSelect()` method is called, and it updates the active panel
    state, which then tells ReactJS to open the active panel and close the inactive
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create an uncontrolled `PanelGroup` instance by simply dropping
    the `activeKey` and `onSelect` attributes from the `PanelGroup` initializer and
    the `expanded` attribute from the `Panel` initializers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The main difference between them is that with the controlled groups, one panel
    will be toggled open every time, but with uncontrolled groups, the user can close
    all panels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if all you want are uncontrolled panel groups, you can ditch the `PanelGroup`
    component and import the `Accordion` component instead. `<Accordion />` is an
    alias for `<PanelGroup accordion />`. It doesn''t really save you much code, but
    may be easier to remember. The code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![Creating responsive panels](img/B04943_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating responsive alerts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Much like panels, alerts are padded information blocks with a few added features,
    and they're good for displaying timely information to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at what you can do with alerts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `examples/alerts.jsx` and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is our flag to keep the alert visible. When this is set to `false`, the
    alert is hidden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, there are two attributes to be noted. The first is `isDismissable`, which
    renders a button that allows the user to dismiss the alert. This attribute is
    optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second is `onDismiss`, which is a function that is called when the user
    clicks on the **Dismiss** button. In this case, the `alertVisible` flag is set
    to 0, and the `render` function now returns `null` instead of an `Alert` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The **Action** button isn''t set up to do anything, so clicking on it is fruitless
    at this time. The **Hide** button receives a function that will set the `alertVisible`
    flag to 0 and hide the `Alert` box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Responsively embedded media and video content
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Embedding YouTube videos can be a worthwhile addition to your site, so let's
    create a custom component to handle this.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this module, we need another dependency, so go ahead and open a terminal,
    navigate to the root folder, and execute this `install` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `classnames` component allows you to dynamically define classes that are
    to be included with simple `true` and `false` comparisons, and it is easier to
    use and understand than relying on string concatenation and `if...else` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder called `components` and a file in that folder called `media.jsx`,
    and then, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We will require one property: the YouTube source. The others are optional.
    If widescreen is not provided, the component will show the video in the 4:3 aspect
    ratio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This snippet returns an `iframe` or `embed` element based on the type of media
    being passed. The responsive classes are based on the ones provided by Bootstrap
    and will scale the media to any viewport automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `app.jsx` and add this import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Then, add `< Media src="img/x7cQ3mrcKaY"/>` to the `render()` method (or any
    other video you want to display). You can also add the `wideScreen` optional attribute
    to show the video in a 16 x 9 size and `allowFullScreen` if you want to allow
    the user to view the video in full screen. You can also pass `height` and `width`
    parameters in order to make it consistent with your layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, this component is not just for videos, but any type of media content.
    For instance, try replacing the code in `app.jsx` with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will show a grid with two columns, one with an SVG and the other with a
    video from YouTube.
  prefs: []
  type: TYPE_NORMAL
- en: Creating responsive buttons
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Buttons are ubiquitous on any web app. They're responsible for a lot of user
    interaction that you'll do in your apps, so it's worth knowing the many types
    of buttons available to you.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the options available to you are extra-small, small, and large buttons,
    full-width buttons, the active and disabled state, grouping, dropup and dropdown,
    and the loading state. Let's look at the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `examples/buttons.jsx` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute `setLoading`, we set the `isLoading` state to `true`, and then,
    we set a timer that reverts the state to `false` after 2 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`ButtonToolbar` along with `ButtonGroup` are the two components that you can
    use for grouping buttons. The main difference between them is that `ButtonToolbar`
    will preserve the spacing between multiple inline buttons or button groups, whereas
    `ButtonGroup` will not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The styles provide visual weight and identify the primary action of the button.
    The final style, `link`, makes the button look like a normal link but maintains
    the button''s behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding `block` turns it into a full-width button. The `bsSize` attribute is
    available for all the buttons and can be `xsmall`, `small`, or `large`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To set the button''s active state, simply add the `active` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the `disabled` attribute makes the button look unclickable by fading
    it to 50% of the original opacity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This button receives a `click` action and hands it over to the `setLoading`
    function, as shown in the preceding code. As long as the `isLoading` state is
    set to `false`, it will have a `disabled` attribute and show the text **Loading…**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This segment shows how you can combine `ButtonToolbar` and `ButtonGroup` to
    maintain two or more sets of visually grouped buttons. Another striking effect
    you can add to `ButtonGroup` is the `vertical` attribute, which will show the
    button stacked on top of each other instead of side by side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Our final set of buttons shows us the various ways in which you can add drop-down
    and split-button effects. This preceding code is the simplest set of drop-down
    buttons that you can show, and all you need to do is wrap them inside the `DropdownButton`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This next set adds the `noCaret` attribute to illustrate how you can create
    a drop-down button without any visual clue that it will display a set of buttons
    when you click on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You can turn the dropdown into a dropup instead by adding the `dropup` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can create a split button effect by wrapping the buttons inside
    the `SplitButton` component instead of the `DropdownButton` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating responsive buttons](img/B04943_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating dynamic progress bars
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Progress bars can be used to show users the state of a process and how much
    is left to process until it's finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `examples/progressbars.jsx` and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In this component, we want to create an interval for progress bars. We create
    a variable to hold the interval because we want to be able to access it later
    in the `unmount` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We create an interval when we mount the component, telling it to execute our
    `tick` method every 500 milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tick()` method updates our internal `progress` variable by adding `1`
    to it if it''s less than `100` or resetting to `0` if it isn''t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: All of the progress bars will now update and display an ever-increasing progress
    until it completely fills up and then resets to `empty` when it does.
  prefs: []
  type: TYPE_NORMAL
- en: If you apply the `active` attribute, the progress bar will be animated. You
    can also furnish it with stripes by adding the `striped` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add your own custom label or use one of the following to interpolate
    the current value:'
  prefs: []
  type: TYPE_NORMAL
- en: '`%(percent)s%`: This adds a percentage value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%(bsStyle)s`: This shows the current style'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%(now)s`: This shows the current value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%(max)s`: This shows the max value (couple this by setting `max={x}`, where
    *x* is any number)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%(min)s`: This shows the minx value (couple this by setting `min={x}`, where
    *x* is any number)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s possible to nest several progress bars on top of each other by wrapping
    them inside `ProgressBar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Creating fluid carousels
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A carousel is a component that is used for cycling through elements, such as
    a slideshow. The functionality is quite complex, but can be achieved with very
    little code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at it. Create a new file called `examples/carousels.jsx`
    and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The direction can be either `prev` or `next`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The first carousel that we create is uncontrolled. That is, it animates itself
    automatically, but can be manually triggered by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The second carousel is controlled and won't be animated until the user clicks
    on the left-hand side or the right-hand side arrow. When the user clicks on one
    of the arrows, the `handleSelect` function receives the desired direction and
    animates the carousel.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the carousel uses the left and right arrow icons from the included
    `Glyphicon` set. You can specify your own arrows using the `nextIcon` and `prevIcon`
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '![Creating fluid carousels](img/B04943_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Working with fluid images and the picture element
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The topic of responsive images is a subject fraught with difficulty. On one
    hand, there's the issue of simply scaling and presenting the images in a responsive
    manner. On the other, you'll often want to download smaller images for small devices
    and hire images for desktops.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how you can set up the responsive code first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `examples/images.jsx` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll start by defining `Grid` and then create a set of three columns (2 if
    on small mobile devices). In the columns, we add three images with three available
    attributes: `portrait`, `circle`, and `rounded`.'
  prefs: []
  type: TYPE_NORMAL
- en: This will scale well to any viewport.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create another row, this time, using a component called `Thumbnail`
    rather than `Image`. This component makes it easy for us to add any kind of HTML
    data that goes along with your image, such as a headline, a description, and an
    action button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To show this component in your app, open `app.jsx` and add this import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Then, add `<Images />` to the `render()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with fluid images and the picture element](img/B04943_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Reducing your footprint
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When serving small devices, it's a good idea to limit the amount of data they
    need to download in order to view the contents of your app. After all, if your
    target audience is users with mobile phones, it's probably not a good idea to
    serve them with high-resolution images that may take several seconds to download.
  prefs: []
  type: TYPE_NORMAL
- en: There's no universal solution to this problem yet, but there are several decent
    ways of tackling it. Let's look at a few ways you can go about solving this problem.
  prefs: []
  type: TYPE_NORMAL
- en: One option is to look at the device your user is using to view your app. This
    is called **sniffing** and usually means identifying metrics such as the user
    agent and viewport size in order to serve different images for desktops and mobile
    phones. The problem with this solution is that it's not very reliable. User agents
    can be faked, and a small viewport size doesn't automatically translate into a
    user surfing your app on a small device.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is media queries (which we'll discuss in more depth a little
    bit later). This works well for static elements, such as images that you can place
    in your menus, toolbars, and other fixed content, but not so for dynamic elements.
  prefs: []
  type: TYPE_NORMAL
- en: One decent solution that's recently come into play is the use of a new element
    called `<picture>`. This element lets you use the concept of media queries dynamically
    and load different images based on the requirements that you specify.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how this works in HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This block will download and show a large image if the browser viewport is at
    least 750 px; it will show a medium image if the viewport is at least 375 px,
    and a small image if neither conditions are met. This element scales gracefully,
    so if the user has a browser that doesn't support this element, it will show the
    image named in the `<img>` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The media query here is relatively simple. You can get pretty creative with
    your queries and `include` attributes, such as the orientation and pixel ratio.
    Here''s a media query that matches smart phones in the portrait mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This one matches tables with retina displays in the portrait mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Creating a Reactified picture element
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We want to work within the confines of ReactJS, so we don't want segments such
    as the previous one where we break out of the mould and use plain HTML instead
    of a ReactJS component for our pictures. However, since it doesn't exist, we need
    to create one.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this module, we need another dependency, so go ahead and execute the following
    command in your terminal (if you haven''t done so already):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a new file in your `components` folder and call it `picture.jsx`.
    Let''s start using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We'll start by adding a set of `property` types and their default values. Note
    that two of the values, `imgSet` and `defaultImage`, are defined as shapes. That's
    because we want to define the `property` types inside the objects and instruct
    ReactJS to let us know if we forget some values or pass the wrong value type.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also require a few values that are specific to Bootstrap, and you''ll probably
    recognize them from the preceding `Image` examples. Since we''re creating our
    own image component, we want to be able to add attributes such as `rounded` and
    `portrait`, and this is how we make sure we do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use the `ClassNames` component to add the correct Bootstrap classes
    if we pass along the attributes we mentioned previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'For every element in `imgSet`, we add a `source` item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add the default image along with the `width` and `height` attributes.
    If you don''t specify the width and height, it will be set to `auto`. It''s usually
    a good idea to set the width and height because that makes it easier for the browser
    to lay out the page initially and prevents it from jumping in case the document
    is served before the images are completely downloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use the new component in `examples/images.jsx`. Open the file and add
    this import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Immediately after the import line, add these variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add this code just before `</Grid>` in the `render()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: When you reload the app in the browser, you'll see a rounded image in your browser,
    and depending on your viewport size, you'll either see an image with the dimensions
    500 x 300, 200 x 500, 250 x 150, or 100 x 100\. Resize the browser and play around
    with the settings to see how it works in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Creating responsive form fields
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Forms are tricky because you'll often need to verify the input and present some
    feedback in case the user does something you didn't expect. We'll look at both
    the issues here, creating responsive forms and presenting feedback to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, call it `examples/formfields.jsx`, and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'When this function is executed, it gets the e-mail string from the state and
    then uses a rather complicated `regex` query to check whether the e-mail is written
    in the correct format. It''s hardly foolproof, but it''s good enough. If the e-mail
    is deemed valid, the function returns `''success''`. If not, it either returns
    `''error''` or `''warning''`, both providing visual clues to the user that the
    e-mail is not entered correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple validator function checks whether the password has a number and
    an uppercase letter. If it does and the length is five characters or more, it
    will return `''success''`. If not, it will return `''error''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'These two functions fetch the input values via `this.refs` and stores them
    as state variables. Go back to [Chapter 1](ch01.html "Chapter 1. Diving Headfirst
    into ReactJS"), *Diving Headfirst into ReactJS*, if you want to learn more about
    refs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This function returns `true` if both validator functions return the `''success''`
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The second input field has several interesting attributes. It has an `onChange`
    attribute, which makes sure to call a function whenever new input is entered into
    the field. It has a `ref` attribute so that it''s possible to find it later via
    `this.refs`. Finally it has a `bsStyle` attribute that can receive `null`, `''success''`,
    `''warning''`, or `''error''`. It will turn the border green on `''success''`,
    yellow on `''warning''`, and red on `''error''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'This button is disabled as long as the validator functions don''t return `''success''`.
    When they do, the user is allowed to proceed and push the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'To show this component in your app, open `app.jsx` and add this import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Then, add `<Formfields />` to the `render()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Formfields` component we''ve created here can be extended with more input
    fields and more validators. Let''s briefly look at the different input types that
    you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Select**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: These two select fields let the user select from a list one at a time or several
    items at once by adding the `multiple` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '**File**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The text in `help` will be displayed underneath the file upload box. You can
    add an `onChange` handler to immediately upload files.
  prefs: []
  type: TYPE_NORMAL
- en: '**Checkbox**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Since ReactJS will render everything literally, you need to either explicitly
    control the checked status of your checkboxes or leave it out completely. In the
    preceding snippet, we control the checked status by setting the state of `CheckBoxOne`
    in `handleCheckboxChange`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that if you provide the `checked` attribute, you must provide an `onChange`
    handler; otherwise, ReactJS will throw a warning in your console. If you want
    to provide a checked value to a checkbox without controlling it, use the `defaultChecked`
    attribute instead.
  prefs: []
  type: TYPE_NORMAL
- en: '**Radio**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Within a form, only one radio button can be checked. As with checkboxes, you
    can control the checked status by adding a `checked` attribute and an `onChange`
    handler or use `defaultChecked` if you want to precheck a radio button.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding snippet, we used `bind` instead of `refs` to pass the value
    along to the function. In JavaScript, `bind()` produces a new that will have `this`
    set to the first parameter passed to `bind()`. We're not interested in this; however,
    because that's just the synthetic mouse click event, we'll set `this` to `null`
    and fix another argument to the bind using `partial function application`. Simply
    put, we'll provide the radio button name to `handleRadioChange`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `handleRadioChange()` function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The reason we're doing it this way is that it's difficult to know which radio
    button reference you need in order to fetch unless you create a unique `onChange`
    handler for each radio button. This is not uncommon though, and either way is
    fine.
  prefs: []
  type: TYPE_NORMAL
- en: '**Textarea**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Text areas are input fields where you can enter longer paragraphs of text. You
    can add an `onChange` handler if you need to apply functions when text is entered.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating responsive form fields](img/B04943_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using Glyphicons and font-awesome icons
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Glyphicons** is a set of about 200 glyphs provided with Bootstrap. We added
    them to our `index.html` file in the beginning of the chapter, when we fetched
    Bootstrap from a CDN, so they''re already included and ready to be used in your
    app.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use Glyphicons anywhere you would use a text string because they're
    provided as a font set rather than a set of images.
  prefs: []
  type: TYPE_NORMAL
- en: 'You add them to your code by importing them with this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: You can add a glyph in your code by writing `<Glyphicon glyph="cloud"/>` to
    add a cloud or `<Glyphicon glyph="envelope"/>` to add an envelope.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily add glyphs to input elements using one of the sets of special
    attributes: `addonBefore`, `addonAfter`, `buttonBefore`, or `buttonAfter`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if you want to add a dollar or a euro sign before an input field
    that takes money as an input parameter, use a code block like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The complete set of glyphs and how they look is available in the code distributed
    with this book. It's in the `examples` folder and the file is called `glyphicons.jsx`.
    If you import this file and add it to `app.jsx`, the entire set will be displayed
    in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap also provides another set of icons in **font awesome**. We included
    this library in the beginning of the chapter in addition to Glyphicons. Before
    you build your app, it's useful to decide between either font-awesome or Glyphicons
    icons so that you have one less library for your users to download.
  prefs: []
  type: TYPE_NORMAL
- en: 'Font-awesome library doesn''t have a component equivalent to Glyphicons, so
    let''s make one. Create a file called `fontawesome` in your `components` folder
    and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code should be very familiar. What it does is it takes a single
    property called `icon` and returns a font-awesome icon element. It doesn't verify
    that the icon exists, so you need to familiarize yourself with more than 500 icons
    in the set in advance.
  prefs: []
  type: TYPE_NORMAL
- en: To use this component, import it by adding `import FontAwesome from './components/fontawesome.jsx';`
    in `app.jsx`, and then in your render code, add `<FontAwesome icon="facebook"/>`
    to display a Facebook icon. You can use this component in the same manner as you
    would use the Glyphicon component, including the preceding input element example.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a responsive landing page
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When developing responsive web apps, there comes a point when you need to differentiate
    between small and large devices in your code. Let's put together a landing page
    and demonstrate how you can use the size of the viewport in your code to present
    your app content.
  prefs: []
  type: TYPE_NORMAL
- en: 'This app will be entirely contained in `app.jsx`. Remove the existing code
    in `app.jsx` (or rename it to `example.jsx` if you want to keep a copy of what
    you''ve done), and remove all code in `app.css` as well. Add the following to
    `app.jsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be relying on the `FontAwesome` component that we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll store the viewport height and width as state variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The state variables will initially be set to 320 x 480, but as soon as the
    app mounts, we''ll calculate the real values. First, we''ll add an event listener
    that will execute a function anytime the viewport changes. Second, we''ll run
    the function for the first time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The viewport calculation will use the most appropriate value and store it as
    the component''s state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll create two `render` functions for the form on the landing page. Note
    that we set all CSS inline inside double curly braces, and that the width will
    automatically be half of the viewport width:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The main difference between the small and the large form is that the large form
    uses input groups to show the input field and the **Submit** button on the same
    horizontal line. The small form puts the button under the input field.
  prefs: []
  type: TYPE_NORMAL
- en: 'We added an `onClick` handler to our form, so let''s proceed by adding this
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: We won't actually process the click event beyond logging the value, but the
    function shows you how to grab the value from the form based on the event that
    occurs when the user clicks on the **Submit** button.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll the functions for the social icons.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The social icons use the images from the `font-awesome` library. The font size
    is set to 32 pixels in order to show large, crisp buttons that are easy to hit
    with your fingers on smart phones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple snippet toggles the rendering of small and large forms and hides
    the social icons whenever the viewport height is less than 320 pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The margin top will be set to a dynamic pixel value that equals 1/20 of the
    viewport height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we add the `socialIcons` variable. It will either be a ReactJS
    element or `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: We reused some of the components from this chapter in this simple app and added
    a few new techniques. You could get the same result using media queries and CSS,
    but you would write more code and split the logic between JavaScript and CSS.
    It may look strange to write style code inline, but one of the main benefits of
    this approach is that it enables you to write very advanced styling rules in the
    same programming language as the rest of your app.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've covered the aspects around creating a responsive web
    app that will work on any device. We looked at some of the different frameworks
    that are available for ReactJS, and we took a deep dive into using react-bootstrap
    for our purposes. In most cases, we could get by with using the components from
    React-Bootstrap, but in certain cases, such as pictures and media, we also made
    our own components.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we combined a few of the components we made earlier along with some
    new techniques, such as programmatic inline styling and event listeners to tackle
    viewport resizing, and made a simple, responsive landing page.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be working on a real-time search app. We'll be covering
    the concept of data stores and efficient querying and provide a smooth, responsive
    experience for users. Turn the page to get working.
  prefs: []
  type: TYPE_NORMAL
