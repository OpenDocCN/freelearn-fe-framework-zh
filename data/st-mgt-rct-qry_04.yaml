- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Fetching Data with React Query
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Query获取数据
- en: React Query allows you to fetch, cache, and handle your server state by leveraging
    one of its custom hooks called `useQuery`. For your data to be cached, React Query
    has a concept called a query key. In combination with the query keys and a couple
    of strict defaults, React Query takes your server state management to the next
    level.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: React Query通过利用其自定义钩子之一`useQuery`，允许你获取、缓存和处理你的服务器状态。为了你的数据能够被缓存，React Query有一个称为查询键的概念。结合查询键和一些严格的默认值，React
    Query将你的服务器状态管理提升到新的水平。
- en: In this chapter, you will be introduced to the `useQuery` hook and understand
    how React Query allows you to fetch and cache your data. During this process,
    you will get to know all the defaults that are used in all of your queries. You
    will also be introduced to some options you can use to make your `useQuery` experience
    even better.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解`useQuery`钩子，并理解React Query是如何让你获取和缓存数据的。在这个过程中，你将了解所有查询中使用的默认值。你还将了解一些可以用来使你的`useQuery`体验更好的选项。
- en: After becoming familiar with `useQuery`, you can start using it to refetch your
    queries in certain scenarios. You will also be able to leverage some extra properties
    of `useQuery` to fetch queries that depend on each other.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在熟悉了`useQuery`之后，你就可以开始在特定场景下使用它来重新获取你的查询。你还可以利用`useQuery`的一些额外属性来获取相互依赖的查询。
- en: At the end of this chapter, we’ll review a code file to review what we learned
    in this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将回顾一个代码文件，以回顾本章所学的内容。
- en: 'In this chapter, we’ll be covering the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is `useQuery` and how does it work?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useQuery`是什么以及它是如何工作的？'
- en: Refetching data with `useQuery`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`useQuery`重新获取数据
- en: Fetching dependent queries with `useQuery`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`useQuery`获取依赖查询
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_4](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_4).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在GitHub上找到：[https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_4](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_4)。
- en: What is useQuery and how does it work?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`useQuery`是什么以及它是如何工作的？'
- en: As you learned in the previous chapter, a query is a request you send to an
    asynchronous source to fetch data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在上一章所学，查询是你向异步源发送的请求以获取数据。
- en: 'In the React Query documentation, queries are also defined in the following
    way:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在React Query文档中，查询也被定义为以下方式：
- en: A query is a declarative dependency on an asynchronous source of data that is
    tied to a unique key.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 查询是对异步数据源的声明性依赖，它与一个唯一键相关联。
- en: ([https://tanstack.com/query/v4/docs/guides/queries](https://tanstack.com/query/v4/docs/guides/queries))
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ([https://tanstack.com/query/v4/docs/guides/queries](https://tanstack.com/query/v4/docs/guides/queries))
- en: With that concept under your belt, you are now ready to understand how React
    Query leverages its custom hook, called `useQuery`, to enable you to subscribe
    to a query.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了这个概念之后，你现在就可以理解React Query是如何利用其自定义钩子`useQuery`来让你订阅查询的。
- en: 'To use the `useQuery` custom hook, you have to import it like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`useQuery`自定义钩子，你必须像这样导入它：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the `useQuery` syntax:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`useQuery`的语法：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, the `useQuery` hook only needs two parameters for it to work:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`useQuery`钩子只需要两个参数即可工作：
- en: '**A query key**: A unique key used to identify your query'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询键**：用于标识你的查询的唯一键'
- en: '**A query function**: A function that returns a promise'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询函数**：一个返回Promise的函数'
- en: What is a query key?
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是查询键？
- en: The query key is a unique value used by React Query to identify your queries.
    It is also by using the query key that React Query caches your data in `QueryCache`.
    The query key also allows you to manually interact with the query cache.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 查询键是React Query用来标识你的查询的唯一值。它还通过使用查询键，React Query在`QueryCache`中缓存你的数据。查询键还允许你手动与查询缓存进行交互。
- en: The query key needs to be an array that can contain just one string or a bunch
    of other values, such as objects. All that matters is that the values inside this
    query key array are serializable.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 查询键需要是一个数组，它可以包含一个字符串或一系列其他值，如对象。重要的是，这个查询键数组中的值必须是可序列化的。
- en: Before React Query v4, the query key didn’t necessarily need to be an array.
    It could just be a single string because React Query would convert it internally
    into an array. So, don’t find it weird if you find some examples online that don’t
    use an array as a query key.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在React Query v4之前，查询键不一定需要是一个数组。它可以是单个字符串，因为React Query会将其内部转换为数组。所以，如果您在网上找到一些不使用数组作为查询键的示例，请不要觉得奇怪。
- en: 'Here are some valid examples of query keys:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些有效的查询键示例：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, so long as it is an array, the query key will be valid.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，只要是一个数组，查询键就是有效的。
- en: As good practice and to make your query key more distinct and easier to identify
    while reading through multiple `useQuery` hooks, you should add all the dependencies
    of your query as part of the query key. Think of it as the same model of the dependency
    array you have on your `useEffect` hook. This is helpful for reading purposes
    as well as because the query key also allows React Query to refetch queries automatically
    when a dependency of the query changes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 作为良好的实践，为了使您的查询键在阅读多个`useQuery`钩子时更加独特和易于识别，您应该将查询的所有依赖项作为查询键的一部分添加。将其视为与您的`useEffect`钩子上的依赖项数组相同的模型。这对于阅读目的很有帮助，因为查询键还允许React
    Query在查询的依赖项发生变化时自动重新获取查询。
- en: One thing to keep in mind is that the query key is hashed deterministically.
    This means that the order of the items inside the array matters.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一点是查询键是确定性散列的。这意味着数组内部项的顺序很重要。
- en: 'Here are some queries whose query keys, when hashed deterministically, are
    the same query:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些查询，当它们的查询键被确定性散列时，它们是同一个查询：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All these examples are the same query – the order of the array in the query
    key is kept the same throughout the three examples.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些示例都是同一个查询——在三个示例中，查询键中数组的顺序保持不变。
- en: Now, you might be wondering how is that possible, considering that the inside
    of the object page and filters changed place every time, and in the last example,
    there was a third property called `random`. This is true, but they are still inside
    an object and that object doesn’t change its position inside the query key array.
    Also, the `random` property is undefined, so when hashing the object, it is excluded.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可能想知道这是如何可能的，考虑到对象内部的面页和过滤器每次都会改变位置，在最后一个示例中还有一个名为`random`的第三个属性。这是真的，但它们仍然在对象内部，而这个对象在查询键数组内部的位置没有改变。此外，`random`属性是未定义的，所以在散列对象时，它被排除。
- en: 'Now, let’s look at some queries whose query keys, when hashed deterministically,
    are not the same query:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一些查询，当它们的查询键被确定性散列时，它们不是同一个查询：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'All these examples represent different queries because when the query key is
    hashed deterministically, these examples end up being completely different queries.
    You might be wondering why the first example is not the same as the last one.
    Shouldn’t the `undefined` value disappear as it did from the `{ queryKey: [''users'',
    10, { page, random: undefined, filters }] })` object?'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '所有这些示例都代表不同的查询，因为当查询键是确定性散列时，这些示例最终会变成完全不同的查询。您可能想知道为什么第一个示例与最后一个示例不同。不应该像从`{
    queryKey: [''users'', 10, { page, random: undefined, filters }] })`对象中消失的那样，`undefined`值消失吗？'
- en: No, because in this scenario, it’s not inside an object, and the order matters.
    When it’s hashed, this undefined value will be transformed into a null value inside
    the hashed key.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 不，因为在当前场景中，它不在一个对象内部，并且顺序很重要。当它被散列时，这个未定义的值将在散列键内部被转换为一个null值。
- en: Now that you are familiar with query keys, you can learn more about query functions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经熟悉了查询键，您可以了解更多关于查询函数的内容。
- en: What is a query function?
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询函数是什么？
- en: A query function is a function that returns a promise. This returned promise
    will either resolve and return the data or throw an error.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 查询函数是一个返回promise的函数。这个返回的promise将解析并返回数据，或者抛出一个错误。
- en: As the query function just needs to return a promise, it makes React Query even
    more powerful because the query function can support any client capable of performing
    asynchronous data fetching. This means that both **REST** and **GraphQL** are
    supported, so you can have both options at the same time if you wish.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因为查询函数只需要返回一个promise，这使得React Query变得更加强大，因为查询函数可以支持任何能够执行异步数据获取的客户端。这意味着**REST**和**GraphQL**都得到了支持，所以如果您愿意，您可以同时拥有这两种选项。
- en: 'Now, let’s look at an example of a query function that uses GraphQL and another
    that uses REST:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个使用GraphQL的查询函数示例，以及一个使用REST的查询函数示例：
- en: GraphQL
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding snippet, we can see an example of using React Query with GraphQL.
    This is what we are doing:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以看到一个使用React Query和GraphQL的例子。这是我们正在做的事情：
- en: We start by creating our GraphQL query and assigning it to our `customQuery`
    variable.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建我们的GraphQL查询，并将其分配给我们的`customQuery`变量。
- en: Then, we create the `fetchGQL` function, which will be our query function.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建`fetchGQL`函数，它将成为我们的查询函数。
- en: In our `useQuery` hook, we pass the respective query key to the hook and our
    `fetchGQL` function as the query function.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`useQuery`钩子中，我们将相应的查询键传递给钩子，并将我们的`fetchGQL`函数作为查询函数。
- en: 'Now, let’s see how to do this using REST:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用REST来完成这个操作：
- en: REST
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: REST
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding snippet, we can see an example of using React Query with REST.
    This is what we are doing:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以看到一个使用React Query和REST的例子。这是我们正在做的事情：
- en: We start by creating the `fetchData` function, which will be our query function.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建`fetchData`函数，它将成为我们的查询函数。
- en: In our `useQuery` hook, we pass the respective query key to the hook and our
    `fetchData` function as the query function.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`useQuery`钩子中，我们将相应的查询键传递给钩子，并将我们的`fetchData`函数作为查询函数。
- en: These examples make React Query shine even more because so long as you have
    a client that can perform asynchronous data fetching, the client can be used in
    your query function. As mentioned previously, just so that React Query can handle
    your error scenarios properly, one thing that we need to check when using these
    clients is if they automatically throw an error when your request fails. If they
    do not throw an error, you must throw the error yourself.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子让React Query更加闪耀，因为只要你有能够执行异步数据获取的客户端，你就可以在查询函数中使用这个客户端。如前所述，为了确保React Query能够正确处理你的错误场景，在使用这些客户端时，我们需要检查的一件事是，当你的请求失败时，它们是否会自动抛出错误。如果它们不会抛出错误，你必须自己抛出错误。
- en: 'This is how you can do this in a query function that uses `fetch`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在使用`fetch`的查询函数中这样做的方法：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding snippet, after performing a request using `fetch`, we check
    if our response is valid. If it is not, we throw an error. If everything is OK,
    we return the response data.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，使用`fetch`执行请求后，我们检查我们的响应是否有效。如果不是，我们抛出一个错误。如果一切正常，我们返回响应数据。
- en: One thing that will eventually pass through your mind as you keep creating queries
    and building your query functions is that it would be helpful to pass your query
    key to your query function. After all, if query keys represent the dependencies
    of your query, then it makes sense that you might need them in your query function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当你持续创建查询和构建查询函数时，最终会想到的一点是，将查询键传递给查询函数会很有帮助。毕竟，如果查询键代表查询的依赖项，那么在查询函数中可能需要它们是有意义的。
- en: 'You can do this, and there are two patterns to do so:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样操作，有两种模式可以这样做：
- en: '**Inline function**'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内联函数**'
- en: '**QueryFunctionContext**'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询函数上下文**'
- en: Inline function
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内联函数
- en: When you don’t have many parameters in your query key that need to be passed
    to your query function, you can leverage this pattern. By writing an inline function,
    you can provide access to the variables in the current scope and pass them to
    your query function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的查询键中不需要传递许多参数到查询函数时，你可以利用这个模式。通过编写内联函数，你可以提供对当前作用域中变量的访问，并将它们传递到查询函数。
- en: 'Here is an example of this pattern:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个模式的一个例子：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding snippet, we start by creating a `fetchData` function that will
    receive a parameter called `someVariable`. This parameter is then used to complement
    the URL used to fetch the data. When we get to our `useQuery` declaration, since
    we need our `someVariable` variable to be used as a dependency of our query, we
    include it in the query key. Finally, in the query function, we create an inline
    function that will call `fetchData` with our `someVariable` value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们首先创建一个名为`fetchData`的函数，它将接收一个名为`someVariable`的参数。这个参数随后被用来补充用于获取数据的URL。当我们到达`useQuery`声明时，由于我们需要将`someVariable`变量用作查询的依赖项，所以我们将其包含在查询键中。最后，在查询函数中，我们创建一个内联函数，该函数将调用`fetchData`并传递我们的`someVariable`值。
- en: As you can see, this pattern is great whenever we don’t have many parameters.
    Now, think about the use case where your query key ended up with 12 parameters,
    and all of them were needed inside of the query function. It’s not a bad practice,
    but it will impact your code readability a bit. To avoid these cases, you can
    resort to the `QueryFunctionContext` object.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当我们没有很多参数时，这种模式非常出色。现在，考虑一下这种情况：你的查询键最终有 12 个参数，并且它们都在查询函数内部被需要。这并不是一个坏习惯，但它会稍微影响你的代码可读性。为了避免这些情况，你可以求助于
    `QueryFunctionContext` 对象。
- en: QueryFunctionContext
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: QueryFunctionContext
- en: Every time the query function is called, React Query will take care of automatically
    passing your query key to the query function as the `QueryFunctionContext` object.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用查询函数时，React Query 会自动将你的查询键作为 `QueryFunctionContext` 对象传递给查询函数。
- en: 'Here is an example of using the `QueryFunctionContext` pattern:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用 `QueryFunctionContext` 模式的一个例子：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding snippet, we start by creating our `fetchData` function. This
    function will be receiving `QueryFunctionContext` as a parameter, so from this
    object, we can immediately destructure `queryKey`. As you know from the *What
    is a query key?* section, the query key is an array, so the order in which we
    passed the parameters we need in our function to our query key matters. In this
    example, we need the `someVariable` variable, which was passed as the second element
    of our array, so we destructure our array to get the second element. We then use
    `someVariable` to complement the URL used to fetch the data. When we get to our
    `useQuery` declaration, since we need our `someVariable` variable to be used as
    a dependency of our query, we include it in the query key. As it is included in
    the query key, it will automatically be sent to our query function.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们首先创建我们的 `fetchData` 函数。这个函数将接收 `QueryFunctionContext` 作为参数，因此从这个对象中，我们可以立即解构
    `queryKey`。正如你在 *什么是查询键？* 部分所知，查询键是一个数组，因此我们传递给函数的参数的顺序对我们传递给查询键的参数顺序很重要。在这个例子中，我们需要
    `someVariable` 变量，它是作为我们数组的第二个元素传递的，因此我们解构我们的数组以获取第二个元素。然后我们使用 `someVariable`
    来补充用于获取数据的 URL。当我们到达 `useQuery` 声明时，由于我们需要将 `someVariable` 变量用作查询的依赖项，我们将其包含在查询键中。由于它包含在查询键中，它将自动发送到我们的查询函数。
- en: This pattern reduces the need to create an inline function and enforces the
    need to add all the dependencies of your query to the query key. The one downside
    this pattern might have is that with so many parameters, you will have to remember
    the order you added them to the query key to use them in the query function. One
    way to fix this issue is by sending an object with all the parameters you need
    in your query function. This way, you remove the need to remember the order of
    the elements of your array.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式减少了创建内联函数的需求，并强制要求将你的查询的所有依赖项添加到查询键中。这种模式可能的一个缺点是，当有这么多参数时，你将不得不记住它们在查询键中添加的顺序，以便在查询函数中使用它们。解决这个问题的方法之一是发送一个包含你查询函数中所需的所有参数的对象。这样，你就无需记住数组元素的顺序。
- en: 'This is how you can do this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你可以这样做的方式：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By passing an object as your query key, the object will be sent as the `QueryFunctionContext`
    object to your query function.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将一个对象作为你的查询键传递，该对象将被作为 `QueryFunctionContext` 对象发送到你的查询函数。
- en: 'Then, in your function, you only need to do this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在你的函数中，你只需要这样做：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding snippet, we destructure our `queryKey` from our `QueryFunctionContext`
    object. Then, since our object will be in the first position of the query key,
    we can destructure the value we need from our object there.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们从 `QueryFunctionContext` 对象中解构我们的 `queryKey`。然后，由于我们的对象将是查询键的第一个位置，我们可以从那里解构我们需要的值。
- en: Now that you understand the two required options of every `useQuery` hook, we
    can start looking at what it returns.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了每个 `useQuery` 钩子所需的两个选项，我们可以开始查看它返回的内容。
- en: What does useQuery return?
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useQuery 返回什么？
- en: When using the `useQuery` hook, it returns a couple of values. To access these
    values, you can just assign the return of the hook to a variable or destructure
    the values from the return of the hook.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `useQuery` 钩子时，它返回几个值。要访问这些值，你只需将钩子的返回值分配给一个变量或从钩子的返回值中解构值即可。
- en: 'You can do this in the following way:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样做：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this snippet, we can see the two different ways to access the return values
    of the `useQuery` hook.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们可以看到访问 `useQuery` 钩子返回值的两种不同方式。
- en: 'In this section, we’ll review the following returns of the `useQuery` hook:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾 `useQuery` 钩子的以下返回值：
- en: '`data`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`'
- en: '`error`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`'
- en: '`status`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`'
- en: '`fetchStatus`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetchStatus`'
- en: data
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`data`'
- en: This variable is the last successfully resolved data returned from your query
    function.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量是查询函数返回的最后成功解析的数据。
- en: 'This is how you can use the `data` variable:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你可以使用`data`变量的方式：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this snippet, we do the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们做了以下操作：
- en: We destructure our `data` variable from our `useQuery` hook.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`useQuery`钩子中解构`data`变量。
- en: On our return, we check if we already have data from our query. When we do,
    we render it.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的返回中，我们检查是否已经从我们的查询中获取了数据。当我们这样做时，我们将渲染它。
- en: 'When the query executes initially, this data will be undefined. Once it finishes
    executing and the query function successfully resolves your data, we will have
    access to the data. If, for some reason, our query function promise rejects, then
    we can use the next variable: `error`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当查询最初执行时，这些数据将是未定义的。一旦它执行完成并且查询函数成功解析了你的数据，我们就能访问这些数据。如果由于某种原因，我们的查询函数的promise被拒绝，那么我们可以使用下一个变量：`error`。
- en: error
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`error`'
- en: The `error` variable lets you access the error object returned from your query
    function after failing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`error`变量让你能够访问查询函数失败后返回的错误对象。'
- en: 'This is how you can use the `error` variable:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你可以使用`error`变量的方式：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding snippet, we do the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们做了以下操作：
- en: We destructure our `error` variable from our `useQuery` hook.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`useQuery`钩子中解构`error`变量。
- en: On our return, we check if we have any errors. If we do, we render the `error`
    message.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的返回中，我们检查是否有任何错误。如果有，我们渲染`error`信息。
- en: When the query executes initially, the `error` value will be null. If, for some
    reason, the query function rejects and throws an error, then this error will be
    assigned to our `error` variable.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当查询最初执行时，`error`值将是null。如果由于某种原因，查询函数拒绝并抛出错误，那么这个错误将被分配给我们的`error`变量。
- en: In both the `data` and `error` examples, we checked if they were defined so
    that we could let our application users know the current status of our query.
    To make this easier and help you craft a better user experience for your application,
    the `status` variable was added.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在`data`和`error`的示例中，我们都检查了它们是否已定义，这样我们就可以让我们的应用程序用户知道我们查询的当前状态。为了使这更容易，并帮助你为应用程序创建更好的用户体验，添加了`status`变量。
- en: status
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`status`'
- en: When performing a query, the query can go through several states. These states
    help you give more feedback to your user. For you to know what the current state
    of your query is, the `status` variable was created.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行查询时，查询可以经过几个状态。这些状态帮助你向用户提供更多的反馈。为了让你知道查询的当前状态，创建了`status`变量。
- en: 'Here are the states that the `status` variable can have:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`status`变量可能具有的状态：
- en: '`loading`: No query attempt has finished and there is still no cached data
    yet.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loading`：没有查询尝试完成，并且还没有缓存的数据。'
- en: '`error`: There was an error while performing a query. Whenever this is the
    status, the `error` property will receive the error returned from the query function.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`：在执行查询时出现了错误。每当这是状态时，`error`属性将接收查询函数返回的错误。'
- en: '`success`: Your query was successful and it has returned data. Whenever this
    is the status, the `data` property will receive the successful data from the query
    function.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`success`：你的查询成功并且返回了数据。每当这是状态时，`data`属性将接收查询函数的成功数据。'
- en: 'This is how you can use the `status` variable:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你可以使用`status`变量的方式：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding snippet, we are leveraging the `status` variable to create
    a better user experience for our users. This is what we are doing:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们正在利用`status`变量为我们的用户提供更好的用户体验。这是我们在做的事情：
- en: We start by destructuring the `status` variable from the `useQuery` hook.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先从`useQuery`钩子中解构`status`变量。
- en: We check if `status` is loading. This means that we still don’t have any data
    and our query has finished. If this is the case, we render a loading indicator.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查`status`是否为加载状态。这意味着我们还没有任何数据，并且我们的查询已经完成。如果情况如此，我们将渲染一个加载指示器。
- en: If our `status` is not loading, we check if there was any error during our query.
    If our `status` equals `error`, then we need to destructure our `error` variable
    and display the error message.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们的`status`不是加载状态，我们检查查询过程中是否出现了任何错误。如果我们的`status`等于`error`，那么我们需要解构我们的`error`变量并显示错误信息。
- en: Finally, if our `status` is also not an error, then we can safely assume that
    our `status` equals success; therefore, we should have our `data` variable with
    the data our query function returned and we can display it to our user.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果我们的`status`也不是错误状态，那么我们可以安全地假设我们的`status`等于成功；因此，我们应该有查询函数返回的数据的`data`变量，并且我们可以将其显示给用户。
- en: 'Now, you know how to use the `status` variable. For convenience, React Query
    also introduced some Boolean variants to help us identify each state. They are
    as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经知道了如何使用`status`变量。为了方便，React Query还引入了一些布尔变体来帮助我们识别每个状态。它们如下所示：
- en: '`isLoading`: Your `status` variable is in the loading state'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isLoading`：你的`status`变量处于加载状态'
- en: '`isError`: Your `status` variable is in the error state'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isError`：你的`status`变量处于错误状态'
- en: '`isSuccess`: Your `status` variable is in the success state'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isSuccess`：你的`status`变量处于成功状态'
- en: 'Let’s rewrite our previous snippet leveraging our `status` Boolean variants:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写我们之前的代码片段，利用我们的`status`布尔变体：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, the code is similar. All we had to do was replace our `status`
    variable with `isLoading` and `isError` in the destructuring and then use the
    `isLoading` and `isError` variables in the respective status check.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码是相似的。我们只需要在我们的解构中将`status`变量替换为`isLoading`和`isError`，然后在相应的状态检查中使用`isLoading`和`isError`变量。
- en: Now, the `status` variable gives you information about your query data. However,
    this is not the only status variable that React Query has. In the next section,
    you will be introduced to `fetchStatus`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`status`变量为你提供了关于你的查询数据的信息。然而，这并不是React Query拥有的唯一状态变量。在下一节中，你将介绍`fetchStatus`。
- en: fetchStatus
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: fetchStatus
- en: With React Query v3, they found that there was an issue when handling scenarios
    where the user would go offline. If the user triggered a query but for some reason
    lost connection during the request, the `status` variable would stay pending in
    the loading state until the user got the connection back and the query was automatically
    retried.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在React Query v3中，他们发现当处理用户可能离线的情况时存在一个问题。如果用户触发了查询，但在请求过程中由于某种原因失去了连接，`status`变量将保持在加载状态，直到用户重新获得连接并且查询自动重试。
- en: To deal with this type of issue, in React Query v4, they introduced a new property
    called `networkMode`. This property can have three states, but by default, it
    will use the online one. The good thing is that this mode enables you to use the
    `fetchStatus` variable.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这类问题，在React Query v4中，他们引入了一个新的属性，称为`networkMode`。这个属性可以有三种状态，但默认情况下将使用在线状态。好事是这种模式允许你使用`fetchStatus`变量。
- en: The `fetchStatus` variable gives you information about your query function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchStatus`变量为你提供了关于你的查询函数的信息。'
- en: 'Here are the states this variable can have:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个变量可能具有的状态：
- en: '`fetching`: Your query function is currently executing. This means that it’s
    currently fetching.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetching`：你的查询函数目前正在执行。这意味着它目前正在获取数据。'
- en: '`paused`: Your query wanted to fetch but due to a lost connection, it has now
    stopped executing. This means that it’s currently paused.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paused`：你的查询想要获取数据，但由于失去了连接，它现在已经停止执行。这意味着它目前处于暂停状态。'
- en: '`idle`: The query is not doing anything at the moment. This means that it’s
    currently idle.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`idle`：查询目前没有任何操作。这意味着它目前处于空闲状态。'
- en: 'Now, let’s learn how to use the `fetchStatus` variable:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何使用`fetchStatus`变量：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding snippet, we are leveraging the `fetchStatus` variable to create
    a better user experience for our users. This is what we are doing:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们正在利用`fetchStatus`变量为我们的用户提供更好的用户体验。我们正在做的是：
- en: We start by destructuring the `fetchStatus` variable from the return of our
    `useQuery` hook.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先从`useQuery`钩子的返回值中解构出`fetchStatus`变量。
- en: We then check if the current state of our `fetchStatus` is paused. If this is
    `true`, then right now, there is no network connection, so we let our user know.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接着检查我们的`fetchStatus`当前状态是否为暂停。如果是`true`，那么现在没有网络连接，因此我们让我们的用户知道。
- en: If the previous `If check` is `false`, then we can validate if the current state
    of our `fetchStatus` is fetching. If the previous `If check` is `true`, then right
    now, the query function is running, so we let our user know.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果之前的`If检查`是`false`，那么我们可以验证我们的`fetchStatus`当前状态是否为获取。如果之前的`If检查`是`true`，那么现在查询函数正在运行，因此我们让我们的用户知道。
- en: If we are not fetching, then we can assume our query function’s `fetchStatus`
    is idle; therefore, it has already finished fetching, so we should have the returned
    data.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们不是在获取数据，那么我们可以假设我们的查询函数的`fetchStatus`是空闲的；因此，它已经完成了获取，所以我们应该有返回的数据。
- en: 'Now, you know how to use the `fetchStatus` variable. Just like for the `status`
    variable, React Query also introduced some Boolean variants to help identify two
    of these statuses. They are as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经知道了如何使用`fetchStatus`变量。就像`status`变量一样，React Query也引入了一些布尔变体来帮助我们识别这两种状态。它们如下所示：
- en: '`isFetching`: Your `fetchStatus` variable is in the fetching state'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isFetching`：您的 `fetchStatus` 变量处于获取状态'
- en: '`isPaused`: Your `fetchStatus` variable is in the paused state'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isPaused`：您的 `fetchStatus` 变量处于暂停状态'
- en: 'Let’s rewrite our previous snippet leveraging our `fetchStatus` Boolean variants:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用我们的 `fetchStatus` 布尔变体重写之前的片段：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see from the snippet, the code is quite similar. All we had to do
    was replace our `fetchStatus` variable with `isFetching` and `isPaused` in the
    destructuring and then use these `isFetching` and `isPaused` variables in the
    respective `fetchStatus` check.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从片段中看到的，代码相当相似。我们只需将我们的 `fetchStatus` 变量替换为解构中的 `isFetching` 和 `isPaused`，然后在相应的
    `fetchStatus` 检查中使用这些 `isFetching` 和 `isPaused` 变量。
- en: Now that we are aware of the values our `useQuery` hook returns, let’s see how
    we can customize the same hook with the use of some options.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了 `useQuery` 钩子返回的值，让我们看看我们如何使用一些选项来定制相同的钩子。
- en: Commonly used options explained
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常用选项解释
- en: When using the `useQuery` hook, more options can be passed into it than the
    query key and query function. These options help you craft a better developer
    experience, as well as a better user experience.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `useQuery` 钩子时，可以传递比查询键和查询函数更多的选项。这些选项帮助您创建更好的开发者体验，以及更好的用户体验。
- en: In this section, we’ll look at some options that are more common and very important
    for you to be aware of.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些更常见且非常重要的选项，您需要了解。
- en: 'Here are the options we’ll cover:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们要介绍的一些选项：
- en: '`staleTime`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`staleTime`'
- en: '`cacheTime`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cacheTime`'
- en: '`retry`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retry`'
- en: '`retryDelay`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retryDelay`'
- en: '`enabled`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`启用`'
- en: '`onSuccess`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSuccess`'
- en: '`onError`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError`'
- en: staleTime
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`staleTime`'
- en: The `staleTime` option is the duration in milliseconds until query data is no
    longer considered *fresh*. When the set time elapses, a query is called *stale*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`staleTime` 选项是查询数据不再被认为是 *新鲜* 的毫秒数。当设置的时间过去后，查询会被称为 *过时*。'
- en: While the query is *fresh*, it will be pulled from the cache without triggering
    a new request to update the cache. When the query is marked as *stale*, data will
    still be pulled from the cache but an automatic refetch of the query can be triggered.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当查询处于 *新鲜* 状态时，它将从缓存中拉取，而不会触发更新缓存的新请求。当查询被标记为 *过时* 时，数据仍然会从缓存中拉取，但可以触发查询的自动重新获取。
- en: By default, all queries use `staleTime` set to `0`. This means that all cached
    data will be considered *stale* by default.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有查询都使用设置为 `0` 的 `staleTime`。这意味着所有缓存数据默认都会被认为是 *过时* 的。
- en: 'This is how we can configure `staleTime`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何配置 `staleTime` 的方法：
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this snippet, we define that the query data of this hook will be considered
    *fresh* for one minute.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们定义这个钩子的查询数据在一分钟内被认为是 *新鲜* 的。
- en: cacheTime
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`cacheTime`'
- en: The `cacheTime` option is the duration in milliseconds that the data in your
    cache that is inactive remains in memory. Once this time passes, the data will
    be garbage collected.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`cacheTime` 选项是缓存中不活跃数据在内存中保持的时间（以毫秒为单位）。一旦这个时间过去，数据将被垃圾回收。'
- en: By default, queries are marked as inactive when they have no active instance
    of a `useQuery` hook. When this happens, this query data will be held in the cache
    for 5 minutes. After these 5 minutes, this data will be garbage collected.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当没有 `useQuery` 钩子的活动实例时，查询会被标记为不活跃。当这种情况发生时，这个查询数据将保留在缓存中5分钟。在这5分钟后，这些数据将被垃圾回收。
- en: 'This is how to use the `cacheTime` option:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何使用 `cacheTime` 选项：
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the snippet, we define that after our query is inactive for 1 minute, the
    data will be garbage collected.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段中，我们定义了在查询不活跃1分钟后，数据将被垃圾回收。
- en: retry
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重试
- en: The `retry` option is a value that indicates whether your query will retry or
    not when it fails. When `true`, it will retry until it succeeds. When `false`,
    it won’t retry.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`retry` 选项是一个值，表示查询失败时是否会重试。当 `true` 时，它会重试直到成功。当 `false` 时，它不会重试。'
- en: This property can also be a number. When it is a number, the query will retry
    that specified number of times.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性也可以是一个数字。当它是一个数字时，查询将重试指定次数。
- en: By default, all queries that are failing will be retried three times.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有失败的查询都会重试三次。
- en: 'This is how to use the `retry` option:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何使用 `retry` 选项：
- en: '[PRE21]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this snippet, we set the `retry` option as `false`. This means that when
    failing to fetch a query, this hook won’t retry to fetch the data.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们将 `retry` 选项设置为 `false`。这意味着当查询失败时，这个钩子不会尝试重新获取数据。
- en: 'We can also configure the `retry` option this way:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以这样配置 `retry` 选项：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this snippet, we set the `retry` option with the number `1`. This means that
    if this hook fails to fetch a query, then it will only retry the request once.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们将数字 `1` 设置为 `retry` 选项。这意味着如果这个钩子无法获取查询，它将只重试请求一次。
- en: retryDelay
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: retryDelay
- en: '`retryDelay` option is the delay to apply before the next retry attempt in
    milliseconds.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`retryDelay` 选项是在下一次重试尝试之前应用的延迟时间（以毫秒为单位）。'
- en: By default, React Query uses an exponential backoff delay algorithm to define
    the retry timing between retries.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，React Query使用指数退避延迟算法来定义重试之间的时间间隔。
- en: 'This is how to use the `retryDelay` option:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 `retryDelay` 选项的方法：
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the snippet, we define a linear backoff function as our `retryDelay` option.
    Every time there is a retry, this function receives the attempt number and multiplies
    it by `2000`. This means that the time between every retry will be 2 seconds longer.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们定义了一个线性退避函数作为我们的 `retryDelay` 选项。每次重试时，这个函数都会接收到尝试次数并将其乘以 `2000`。这意味着每次重试之间的时间间隔将增加2秒。
- en: enabled
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: enabled
- en: The `enabled` option is a Boolean value that indicates when your query can run
    or not.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`enabled` 选项是一个布尔值，表示您的查询何时可以运行或不能运行。'
- en: By default, this value is `true`, so all queries are enabled.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此值是 `true`，因此所有查询都被启用。
- en: 'This is how we can use the `enabled` option:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 `enabled` 选项的方法：
- en: '[PRE24]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this snippet, we assign the return of the expression evaluation to the `enabled`
    option. This means that whenever the length of `arrayVariable` is greater than
    0, this query will execute.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们将表达式评估的返回值分配给 `enabled` 选项。这意味着只要 `arrayVariable` 的长度大于0，这个查询就会执行。
- en: onSuccess
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: onSuccess
- en: The `onSuccess` option is a function that will be triggered when your query
    is successful while fetching.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`onSuccess` 选项是一个函数，当您的查询在获取过程中成功时将被触发。'
- en: 'This is how we can use the `onSuccess` option:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 `onSuccess` 选项的方法：
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this snippet, we pass an arrow function to our `onSuccess` option. When our
    query fetches successfully, this function will be called with our `data`. We then
    use this `data` to log to our `console`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们将一个箭头函数传递给我们的 `onSuccess` 选项。当我们的查询成功获取数据时，这个函数将使用我们的 `data` 作为参数被调用。然后我们使用这个
    `data` 来在我们的 `console` 中进行日志记录。
- en: onError
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: onError
- en: The `onError` option is a function that will be triggered when your query fails
    while fetching.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的查询在获取过程中失败时，`onError` 选项是一个将被触发的函数。
- en: 'This is how we can use the `onError` option:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 `onError` 选项的方法：
- en: '[PRE26]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this snippet, we pass an arrow function to our `onError` option. When the
    query fails, this function will be called with the `thrown` error. We then log
    the error in our `console`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们将一个箭头函数传递给我们的 `onError` 选项。当查询失败时，这个函数将使用 `thrown` 错误作为参数被调用。然后我们在我们的
    `console` 中记录错误。
- en: As you can see, the `useQuery` hook supports a lot of options and the ones that
    were presented were only the tip of the iceberg. In the upcoming sections and
    chapters, you’ll be introduced to more, so prepare yourself!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`useQuery` 钩子支持很多选项，而之前展示的只是冰山一角。在接下来的章节中，您将了解到更多，所以请做好准备！
- en: You are now familiar with the `useQuery` hook and should be able to use it to
    start fetching your server state data. Now, let’s see some patterns and ways we
    can use this hook to deal with some common server state challenges.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在熟悉了 `useQuery` 钩子，应该能够使用它来开始获取您的服务器状态数据。现在，让我们看看一些模式和方式，我们可以使用这个钩子来处理一些常见的服务器状态挑战。
- en: Refetching data with useQuery
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 useQuery 重新获取数据
- en: Refetching is an important part of managing our server state. Sometimes, you
    need your data to be updated because your data has become stale or just because
    you haven’t interacted with your page in a while.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 重新获取数据是管理我们的服务器状态的一个重要部分。有时，您需要更新数据，因为数据已经过时，或者是因为您已经有一段时间没有与页面交互了。
- en: Manually or automatically, React Query supports and allows you to refetch your
    data.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 无论手动还是自动，React Query都支持并允许您重新获取数据。
- en: In this section, we’ll see how it works and what automatic and manual ways you
    can leverage to refetch your data.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解它是如何工作的，以及您可以利用哪些自动和手动方式来重新获取数据。
- en: Automatic refetching
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动重新获取
- en: React Query has baked in a couple of options to make your life easier and keep
    your server state fresh. To do this, it automatically takes care of data refetching
    in certain cases.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: React Query内置了一些选项，以使您的生命更轻松并保持服务器状态新鲜。为此，它会在某些情况下自动处理数据重新获取。
- en: Let’s look at the things that allow React Query to perform data refetching automatically.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看允许React Query自动执行数据重新获取的事物。
- en: Query keys
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询键
- en: Query keys are used to identify your query.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 查询键用于标识您的查询。
- en: When talking about query keys previously, I mentioned several times that we
    should include all of our query function dependencies as part of our query key.
    Why did I say that?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前讨论查询键时，我多次提到我们应该将所有查询函数的依赖项作为查询键的一部分包括在内。为什么我会这么说？
- en: Because whenever some of those dependencies change, so will your query key,
    and when your query key changes, your query with be automatically refetched.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 因为当这些依赖项中的任何一个发生变化时，你的查询键也会发生变化，当你的查询键发生变化时，你的查询将自动重新获取。
- en: 'Let’s look at the following example:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE27]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding snippet, we define a `useQuery` hook that has `someVariable`
    as part of its query key. This query will be fetched on the initial render like
    usual, but when we click on our button, the `someVariable` value will change.
    The query key will also change, which will trigger a query refetch for you to
    get your new data.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了一个`useQuery`钩子，其中`someVariable`是其查询键的一部分。这个查询将像往常一样在初始渲染时获取，但当我们点击我们的按钮时，`someVariable`的值将改变。查询键也会改变，这将触发查询重新获取以获取你的新数据。
- en: Refetching options
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新获取选项
- en: There are a couple of options I did not share in the *Commonly used options
    explained* section. This is because they are enabled by default, and it is often
    better to leave them on unless they don’t suit your use case.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在“常用选项解释”部分中，我没有分享的一些选项。这是因为它们默认启用，通常最好保留它们，除非它们不适合你的用例。
- en: 'Here are the options related to data refetching that `useQuery` has enabled
    by default:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`useQuery`默认启用的与数据重新获取相关的选项：
- en: '`refetchOnWindowFocus`: Whenever you focus on your current window, this option
    triggers a refetch. For example, if you change tabs when you return to your application,
    React Query will trigger a refetch of your data.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`refetchOnWindowFocus`：每当你的当前窗口获得焦点时，此选项会触发重新获取。例如，当你返回到你的应用程序并更改标签页时，React
    Query将触发数据的重新获取。'
- en: '`refetchOnMount`: Whenever your hook mounts, this option triggers a refetch.
    For example, when a new component that uses your hook mounts, React Query will
    trigger a refetch of your data.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`refetchOnMount`：每当你的钩子挂载时，此选项会触发重新获取。例如，当一个新的使用你的钩子的组件挂载时，React Query将触发数据的重新获取。'
- en: '`refetchOnReconnect`: Whenever you lose your internet connection, this option
    will trigger a refetch.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`refetchOnReconnect`：每当你的互联网连接丢失时，此选项将触发重新获取。'
- en: One thing that is important to note is that these options will only refetch
    your data by default if your data is marked as stale. This refetching of data
    even if its stale can be configured since all these options, excluding the Boolean
    value, also support receiving a string with a value of `always`. When the value
    of these options is `always`, it will always retrigger a refetch, even if the
    data is not stale.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点很重要，即默认情况下，这些选项只会重新获取你的数据，如果你的数据被标记为过时。即使数据已过时，这种数据重新获取也可以配置，因为所有这些选项（除布尔值外）也支持接收一个值为`always`的字符串。当这些选项的值为`always`时，它将始终重新触发重新获取，即使数据没有过时。
- en: 'This is how to configure them:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何配置它们的：
- en: '[PRE28]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding snippet, we are doing the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们正在做以下操作：
- en: For the `refetchOnMount` option, we always want our hook to refetch our data
    whenever any component using it mounts, even if the cached data is not stale
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`refetchOnMount`选项，我们总是希望我们的钩子在任何使用它的组件挂载时重新获取我们的数据，即使缓存的数据没有过时
- en: For `refetchOnReconnect`, we want our hook to refetch our data whenever we regain
    connection after being offline, but only if our data is stale
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`refetchOnReconnect`，我们希望我们的钩子在我们离线后重新获得连接时重新获取我们的数据，但只有当我们的数据已过时
- en: For `refetchOnWindowFocus`, we never want our hook to refetch our data on window
    focus
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`refetchOnWindowFocus`，我们绝不想在窗口聚焦时让我们的钩子重新获取数据
- en: Now, one thing that might cross your mind is if there is any way to force our
    hook to refetch our data every couple of seconds, even if our data is not stale.
    Well, even if you didn’t think about it, React Query allows you to do it.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能想到的一个问题是是否有任何方法可以强制我们的钩子每隔几秒钟重新获取我们的数据，即使数据没有过时。好吧，即使你没有想过，React Query也允许你这样做。
- en: React Query adds another refetch-related option called `refetchInterval`. This
    option allows you to specify a frequency in milliseconds for your query to refetch
    data.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: React Query添加了另一个与重新获取相关的选项，称为`refetchInterval`。此选项允许你指定查询重新获取数据的频率（以毫秒为单位）。
- en: 'This is how we can use it:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何使用它的：
- en: '[PRE29]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this snippet, we configure our hook to always refetch every 2 seconds. We
    also add another option called `refetchIntervalInBackground` with `true` as its
    value. This option will allow your query to keep refetching, even if your window
    or tab is in the background.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们配置我们的钩子以每2秒自动重新获取一次。我们还添加了一个名为`refetchIntervalInBackground`的选项，其值为`true`。此选项将允许您的查询即使在窗口或标签页处于后台时也能继续重新获取。
- en: This wraps up automatic refetching. Now, let’s see how we can trigger manual
    refetches in our code.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这总结了自动重新获取。现在，让我们看看我们如何在代码中触发手动重新获取。
- en: Manual refetching
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动重新获取
- en: There are two ways to manually trigger a query refetch. You could use `QueryClient`
    or get the `refetch` function from the hook.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种手动触发查询重新获取的方式。您可以使用`QueryClient`或从钩子中获取`refetch`函数。
- en: Using QueryClient
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用QueryClient
- en: As you may recall from the previous chapter, `QueryClient` allows you to have
    an interface between the developer and the query cache. This allows you to leverage
    `QueryClient` to force a data refetch when needed.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能从上一章回忆起的，`QueryClient`允许您在开发者和查询缓存之间建立接口。这允许您利用`QueryClient`在需要时强制数据重新获取。
- en: 'This is how you can trigger a data refetch using `QueryClient`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您可以使用`QueryClient`触发数据重新获取的方式：
- en: '[PRE30]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the preceding snippet, we are doing the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们正在执行以下操作：
- en: Using the `useQueryClient` hook to get access to our `QueryClient`.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`useQueryClient`钩子来获取对`QueryClient`的访问权限。
- en: Using `QueryClient`, we are calling one of the functions it exposes, called
    `refetchQueries`. This function allows you to trigger a refetch of all the queries
    that match the given query key. In this snippet, we are triggering a request for
    all queries that have the `["api"]` query key.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`QueryClient`，我们调用它公开的一个函数，称为`refetchQueries`。此函数允许您触发与给定查询键匹配的所有查询的重新获取。在这个片段中，我们正在触发具有`["api"]`查询键的所有查询的请求。
- en: Using the refetch function
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用重新获取函数
- en: Every `useQuery` hook exposes a `refetch` function for convenience. This function
    will allow you to trigger a refetch for just that query.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`useQuery`钩子都公开一个`refetch`函数以方便使用。此函数将允许您仅触发该查询的重新获取。
- en: 'This is how you can do it:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您可以这样做的：
- en: '[PRE31]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this snippet, we are destructuring the `refetch` function from our `useQuery`
    hook. Then, we can call that function whenever we want to force that query to
    refetch.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们从`useQuery`钩子中解构了`refetch`函数。然后，我们可以在任何时候调用该函数，以强制该查询重新获取。
- en: Now that you know how React Query enables you to manually and automatically
    refetch your data, let’s see how we can create queries that depend on other queries.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道了React Query如何使您能够手动和自动重新获取数据，让我们看看我们如何创建依赖于其他查询的查询。
- en: Fetching dependent queries with useQuery
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`useQuery`获取依赖查询
- en: Sometimes, during our development process, we need to have values that are returned
    from one query that we can use in another query or have a query execution depend
    on a previous query. When this happens, we need to have what is called a dependent
    query.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在开发过程中，我们需要使用一个查询返回的值，这些值可以在另一个查询中使用，或者使查询执行依赖于之前的查询。当这种情况发生时，我们需要有一个称为依赖查询的东西。
- en: React Query allows you to make a query depend on others via the `enabled` option.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: React Query允许您通过`enabled`选项使一个查询依赖于其他查询。
- en: 'This is how you can do it:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您可以这样做的：
- en: '[PRE32]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding snippet, we are doing the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们正在执行以下操作：
- en: We are creating a query that will have `["api"]` as the query key and the `fetchData`
    function as the query function.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在创建一个查询，其查询键为`["api"]`，查询函数为`fetchData`函数。
- en: Next, we are creating a Boolean variable called `canThisDependentQueryFetch`
    that will check if our previous query has the data we need. This Boolean variable
    will help us decide if our next query can fetch.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为`canThisDependentQueryFetch`的布尔变量，该变量将检查我们的上一个查询是否有我们所需的数据。这个布尔变量将帮助我们决定我们的下一个查询是否可以获取。
- en: Then, we are creating our second query with `["dependentAPI", firstQueryData?.hello]`
    as the query key, the `fetchDependentData` function as the query function, and
    our `canThisDependentQueryFetch` as our `Boolean` variable for the `enabled` option.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建第二个查询，其查询键为`["dependentAPI", firstQueryData?.hello]`，查询函数为`fetchDependentData`函数，以及我们的`canThisDependentQueryFetch`作为`enabled`选项的`Boolean`变量。
- en: When the previous query finishes fetching the data, the `canThisDependentQueryFetch`
    Boolean will be set to `true` and enable this dependent query to run.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当之前的查询完成数据获取后，`canThisDependentQueryFetch`布尔值将被设置为`true`，并启用此依赖查询的运行。
- en: As you can see, you only need the `enabled` option to make a query depend on
    another one. Now, before wrapping up this chapter, let’s put all your earned knowledge
    into practice.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您只需要`enabled`选项就可以使一个查询依赖于另一个查询。现在，在结束这一章之前，让我们将我们所学到的所有知识付诸实践。
- en: Putting it all into practice
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容付诸实践
- en: At this point, you should be able to start handling some use cases for data
    fetching using the `useQuery` hook.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该能够开始处理一些使用`useQuery`钩子的数据获取用例。
- en: In this section, we will look at a file with three components called `ComponentA`,
    `ComponentB`, and `ComponentC` that are doing some data fetching. We will use
    this file to review the concepts we have learned about and see if we fully understood
    how `useQuery` works.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看一个包含三个组件的文件，这些组件分别称为`ComponentA`、`ComponentB`和`ComponentC`，它们正在执行一些数据获取操作。我们将使用这个文件来回顾我们已经学到的概念，并查看我们是否完全理解了`useQuery`的工作方式。
- en: 'Let’s start with the beginning of the file:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从文件的开始部分开始：
- en: '[PRE33]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is what we are doing in the preceding snippet:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们正在做以下操作：
- en: We import our `useQuery` and `useQueryClient` custom hooks from the React Query
    package to use in our components that will be defined in the next few snippets.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从React Query包中导入我们的`useQuery`和`useQueryClient`自定义钩子，以便在定义在接下来的几个代码片段中的组件中使用。
- en: 'We create a `fetchData` function that will receive our `QueryFunctionContext`.
    We then destructure our `queryKey` from it. Inside this function, we do the following:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个`fetchData`函数，该函数将接收我们的`QueryFunctionContext`。然后我们从其中解构出`queryKey`。在这个函数内部，我们执行以下操作：
- en: We will be using an object as our query key in these examples so that we know
    that the first position of the array will have our query key properties, so we
    destructure our `apiName` from it.
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些示例中，我们将使用一个对象作为查询键，这样我们就可以知道数组的第一个位置将包含我们的查询键属性，因此我们从其中解构出`apiName`。
- en: We use `fetch` to trigger a `GET` request to our URL and use `apiName` to help
    define the route.
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`fetch`触发对URL的`GET`请求，并使用`apiName`来帮助定义路由。
- en: Because we are using `fetch` and not `axios`, we need to manually handle the
    scenario where our request failed. If our response is not OK, then we need to
    throw an error so that `useQuery` will be able to handle error scenarios.
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们使用的是`fetch`而不是`axios`，所以我们需要手动处理请求失败的情况。如果我们的响应不是OK，那么我们需要抛出一个错误，以便`useQuery`能够处理错误场景。
- en: If our response is valid, then we can return our response data.
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们的响应是有效的，那么我们可以返回我们的响应数据。
- en: We then create two API constant values called `apiA` and `apiB` that define
    the route our components will use.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建了两个API常量值，分别称为`apiA`和`apiB`，它们定义了组件将使用的路由。
- en: 'Now, let’s continue with our file and look at our first component, called `ComponentA`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续我们的文件，并查看我们的第一个组件，称为`ComponentA`：
- en: '[PRE34]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let’s review `ComponentA`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下`ComponentA`：
- en: 'We start by creating our query by using the `useQuery` hook:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先通过使用`useQuery`钩子来创建我们的查询：
- en: This query is identified with an object as the query key. This object has `api`
    as the `queryIdentifier` property and `apiA` as the `apiName` property.
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个查询使用一个对象作为查询键。这个对象有`api`作为`queryIdentifier`属性和`apiA`作为`apiName`属性。
- en: This query has the `fetchData` function as the query function.
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个查询的查询函数是`fetchData`函数。
- en: By using the `retry` option, we also specify that if this query fails to fetch,
    then the hook will only retry the request one time.
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`retry`选项，我们还指定如果这个查询在获取数据时失败，那么钩子将只重试请求一次。
- en: We also destructure `data`, `isLoading`, `isError`, and `isFetching` from the
    hook.
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还从钩子中解构出`data`、`isLoading`、`isError`和`isFetching`。
- en: If no query attempt has finished and there is still no cached data, we want
    to render to the user that we are loading data. We use `isLoading` with an `If`
    check to do this.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有查询尝试完成，并且仍然没有缓存的数据，我们希望向用户显示我们正在加载数据。我们使用`isLoading`和`If`检查来实现这一点。
- en: If there was an error, we want to display it. We use `isError` to check if there
    was any error. If so, we render that error.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有错误，我们希望显示它。我们使用`isError`来检查是否有任何错误。如果有，我们渲染那个错误。
- en: 'If our query is not loading or has an error, then we can assume it was successful.
    We then render a `div` with the following:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们的查询没有加载或出现错误，那么我们可以假设它是成功的。然后我们渲染一个包含以下内容的`div`：
- en: A `p tag` that will check if our hook `isFetching`. If it is fetching, it will
    display `Fetching Component A`. If not, it will display the fetched data.
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`p tag`将检查我们的钩子`isFetching`。如果正在获取，它将显示`Fetching Component A`。如果不正在获取，它将显示获取到的数据。
- en: Our `ComponentB`.
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的`ComponentB`。
- en: 'Now, let’s look at `ComponentB`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`ComponentB`：
- en: '[PRE35]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is what we are doing in `ComponentB`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们`ComponentB`中正在做的事情：
- en: 'We start by creating our query by using the `useQuery` hook:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先通过使用`useQuery`钩子创建我们的查询：
- en: This query is identified with an object as the query key. This object has `api`
    as the `queryIdentifier` property and `apiB` as the `apiName` property.
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此查询通过一个对象作为查询键进行标识。此对象具有`api`作为`queryIdentifier`属性和`apiB`作为`apiName`属性。
- en: This query has the `fetchData` function as the query function.
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此查询具有`fetchData`函数作为查询函数。
- en: We use the `onSuccess` option and pass it a function that will receive our `data`
    and log it on our `console`, as well as an indication that this component has
    fetched the data.
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`onSuccess`选项并传递一个函数，该函数将接收我们的`data`并在我们的`console`上记录它，以及指示此组件已获取数据。
- en: We also destructure `data` from the hook.
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还从钩子中解构`data`。
- en: 'We then return a `div` to be rendered with the following:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们返回一个`div`以进行渲染，如下所示：
- en: Our `hello` property from our fetched data. One thing that you might see is
    that we used the `?.` operator. We leverage optional chaining here to make sure
    there is no error, and we only render our `hello` property when our data is defined.
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从获取的数据中获取的`hello`属性。你可能看到的一件事是我们使用了`?.`运算符。我们利用可选链来确保没有错误，并且只有当我们的数据定义时，我们才渲染`hello`属性。
- en: Our `ComponentC`. This component will receive our `ComponentB` data as its `parentData`
    prop.
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的`ComponentC`。此组件将接收我们的`ComponentB`数据作为其`parentData`属性。
- en: 'Let’s wrap up our file review by looking at `ComponentC`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看`ComponentC`来总结我们的文件审查：
- en: '[PRE36]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'So, this is what is happening in `ComponentC`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是`ComponentC`中正在发生的事情：
- en: 'We start by creating our query by using the `useQuery` hook:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先通过使用`useQuery`钩子创建我们的查询：
- en: This query is identified with an object as the query key. This object has `api`
    as the `queryIdentifier` property and `apiA` as the `apiName` property.
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此查询通过一个对象作为查询键进行标识。此对象具有`api`作为`queryIdentifier`属性和`apiA`作为`apiName`属性。
- en: This query has the `fetchData` function as the query function.
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此查询具有`fetchData`函数作为查询函数。
- en: We use the `enabled` option to make this query depend on `parentData`; therefore,
    this query will only run after the query in `ComponentB` finishes and resolves
    data.
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`enabled`选项使此查询依赖于`parentData`；因此，此查询只有在`ComponentB`中的查询完成并解析数据后才会运行。
- en: We destructure `data` and `isFetching` from the hook.
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从钩子中解构`data`和`isFetching`。
- en: We use the `useQueryClient` hook to get access to our `QueryClient`.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`useQueryClient`钩子来获取对`QueryClient`的访问权限。
- en: 'Finally, we return a `div` that will be rendered with the following:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们返回一个将渲染以下内容的`div`：
- en: A `p tag` that will check if our hook `isFetching`. If it is fetching, it displays
    `Fetching Component C`. If not, it displays the fetched data.
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`p`标签，将检查我们的钩子`isFetching`。如果正在获取，则显示`Fetching Component C`。如果不，则显示获取的数据。
- en: A button that, when clicked, will use `queryClient` to refetch the query whose
    query key has `api` as the `queryIdentifier` property and `apiA` as the `apiName`
    property. This means that on this button click, both `useQuery` in `ComponentA`
    and `useQuery` in `ComponentC` will refetch some data.
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个按钮，当点击时，将使用`queryClient`重新获取查询键具有`api`作为`queryIdentifier`属性和`apiA`作为`apiName`属性的查询。这意味着在此按钮点击时，`ComponentA`和`ComponentC`中的`useQuery`都将重新获取一些数据。
- en: Also, in the preceding snippet, we do a default export of our `ComponentA`,
    so it is the entry point in this file.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在前面的代码片段中，我们默认导出我们的`ComponentA`，因此它是此文件的入口点。
- en: 'Now that we’ve seen the code file, let’s review the life cycle of the hooks
    and understand what is happening in the background:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了代码文件，让我们回顾钩子的生命周期并了解后台发生了什么：
- en: 'When `ComponentA` renders, the following occurs:'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`ComponentA`渲染时，以下情况会发生：
- en: 'An instance of `useQuery` with the `[{ queryIdentifier: "api", apiName: apiA
    }]` query key mounts:'
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '一个具有`[{ queryIdentifier: "api", apiName: apiA }]`查询键的`useQuery`实例挂载：'
- en: Since this is the first mount, there is no cache nor previous requests, so our
    query will start fetching our data, and its `status` will be loading. Also, our
    query function will receive our query key as part of `QueryFunctionContext`.
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于这是第一次挂载，没有缓存也没有之前的请求，因此我们的查询将开始获取我们的数据，其`status`将为加载状态。此外，我们的查询函数将作为`QueryFunctionContext`的一部分接收我们的查询键。
- en: 'When our data fetching succeeds, the data will be cached under the `[{ queryIdentifier:
    "api", apiName: apiA }]` query key.'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '当我们的数据获取成功时，数据将根据`[{ queryIdentifier: "api", apiName: apiA }]`查询键进行缓存。'
- en: Since we are assuming the default `staleTime`, which is `0`, the hook will mark
    its data as stale.
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们假设默认的`staleTime`，其值为`0`，钩子将标记其数据为过时。
- en: 'When `ComponentA` renders `ComponentB`, the following occurs:'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`ComponentA`渲染`ComponentB`时，以下情况会发生：
- en: 'An instance of `useQuery` with the `[{ queryIdentifier: "api", apiName: apiB
    }]` query key mounts:'
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '具有查询键`[{ queryIdentifier: "api", apiName: apiB }]`的`useQuery`实例挂载：'
- en: Since this is the first mount, there is no cache nor previous requests, so our
    query will start fetching our data, and its `status` will be loading. Also, our
    query function will receive our query key as part of `QueryFunctionContext`.
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于这是第一次挂载，没有缓存也没有之前的请求，因此我们的查询将开始获取数据，其`状态`将是加载中。此外，我们的查询函数将作为`QueryFunctionContext`的一部分接收我们的查询键。
- en: 'When our data fetching succeeds, the data will be cached under the `[{ queryIdentifier:
    "api", apiName: apiB }]` query key and the hook will call the `onSuccess` function.'
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '当我们的数据获取成功时，数据将根据`[{ queryIdentifier: "api", apiName: apiB }]`查询键进行缓存，并且钩子将调用`onSuccess`函数。'
- en: Since we are assuming the default `staleTime`, which is `0`, the hook will mark
    its data as stale.
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们假设默认的`staleTime`，即`0`，钩子将标记其数据为过时。
- en: 'When `ComponentB` renders `ComponentC`, the following occurs:'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`ComponentB`渲染`ComponentC`时，以下情况发生：
- en: 'An instance of `useQuery` with the `[{ queryIdentifier: "api", apiName: apiA
    }]` query key mounts:'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '具有查询键`[{ queryIdentifier: "api", apiName: apiA }]`的`useQuery`实例挂载：'
- en: As this hook has the same query key as the hook in `ComponentA`, the hook will
    already have cached data under it, so the data is immediately accessible.
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于此钩子与`ComponentA`中的钩子具有相同的查询键，钩子下已经缓存了数据，因此数据可以立即访问。
- en: Since this query was marked as stale after the previous fetch, this hook needs
    to refetch it, but it needs to wait for the query to be enabled first since this
    query depends on us having the data of `ComponentB` first.
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于此查询在之前的获取后标记为过时，此钩子需要重新获取它，但它需要等待查询首先启用，因为此查询依赖于我们首先拥有`ComponentB`的数据。
- en: Once it’s been enabled, the query will trigger a refetch. This makes `isFetching`
    on both `ComponentA` and `ComponentC` to be `true`.
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦启用，查询将触发重新获取。这使得`ComponentA`和`ComponentC`上的`isFetching`都变为`true`。
- en: 'Once the fetch request succeeds, the data will be cached under the `[{ queryIdentifier:
    "api", apiName: apiA }]` query key, and the query is marked as stale again.'
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '一旦获取请求成功，数据将根据`[{ queryIdentifier: "api", apiName: apiA }]`查询键进行缓存，并且查询再次标记为过时。'
- en: 'Now, considering it is the parent component, let’s picture a scenario where
    `ComponentA` unmounts:'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，考虑到它是父组件，让我们设想一个场景，其中`ComponentA`卸载：
- en: 'Since there is no longer any instance of the query with the `[{ queryIdentifier:
    "api", apiName: apiA }]` query key active, the default cache timeout of 5 minutes
    is set'
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '由于不再有任何具有`[{ queryIdentifier: "api", apiName: apiA }]`查询键的活动查询实例，默认的缓存超时设置为5分钟。'
- en: Once 5 minutes pass, the data under this query is deleted and garbage collected
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦过去5分钟，此查询下的数据将被删除并回收。
- en: 'Since there is no longer any instance of the query with the `[{ queryIdentifier:
    "api", apiName: apiB }]` query key active, the default cache timeout of 5 minutes
    is set'
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '由于不再有任何具有`[{ queryIdentifier: "api", apiName: apiB }]`查询键的活动查询实例，默认的缓存超时设置为5分钟。'
- en: Once 5 minutes pass, the data under this query is deleted and garbage collected
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦过去5分钟，此查询下的数据将被删除并回收。
- en: 'If you managed to keep track of this previous process and the life cycle of
    your queries during their usage, then congratulations: you understand how `useQuery`
    works!'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够跟踪此前的过程以及查询在它们使用过程中的生命周期，那么恭喜你：你理解了`useQuery`是如何工作的！
- en: Summary
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the `useQuery` custom hook and how it allows
    you to fetch and cache your data by using its required options, called query key
    and query function. You learned how to define your query key and how your query
    function allows you to use any data-fetching client such as GraphQL or REST, so
    long it returns a promise or throws an error.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了`useQuery`自定义钩子以及它是如何通过使用其必需的选项（称为查询键和查询函数）来获取和缓存数据的。你学习了如何定义查询键以及你的查询函数如何允许你使用任何数据获取客户端，如GraphQL或REST，只要它返回一个承诺或抛出一个错误。
- en: You also learned about some of the things that the `useQuery` hook returns,
    such as the query’s `data` and `error`. For you to craft a better user experience,
    you were also introduced to `status` and `fetchStatus`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 你还了解了一些`useQuery`钩子返回的内容，例如查询的`data`和`error`。为了构建更好的用户体验，你还介绍了`status`和`fetchStatus`。
- en: 'For you to customize your developer experience and take it to the next level,
    you learned about some commonly used options you can use to customize your `useQuery`
    hook and make it behave as you want it to. For your convenience, here are the
    compiled defaults to be aware of:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你自定义开发者体验并将其提升到下一个层次，你了解了一些常用的选项，你可以使用这些选项来自定义你的`useQuery`钩子，使其按你的意愿运行。为了你的方便，以下是一些需要注意的编译默认值：
- en: '`staleTime`: 0'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`staleTime`: 0'
- en: '`cacheTime`: 5 * 60 * 1,000 (5 minutes)'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cacheTime`: 5 * 60 * 1,000 (5 minutes)'
- en: '`retry`: 3'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retry`: 3'
- en: '`retryDelay`: Exponential backoff delay algorithm'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retryDelay`: 指数退避延迟算法'
- en: '`enabled`: True'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enabled`: True'
- en: Before wrapping up, you learned about some patterns for dealing with server
    state challenges such as refetching and dependent queries.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束之前，你了解了一些处理服务器状态挑战（如重新获取和依赖查询）的模式。
- en: Finally, you put everything you learned into practice and reviewed an example
    that showed you how to leverage all this knowledge and how the `useQuery` hook
    works internally when you do.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将所学的一切付诸实践，并回顾了一个示例，展示了如何利用所有这些知识，以及当你这样做时`useQuery`钩子是如何在内部工作的。
- en: In [*Chapter 5*](B18501_05.xhtml#_idTextAnchor140), *More Data-Fetching Challenges*,
    you will continue to learn how you can use the `useQuery` hook to solve some more
    common server state challenges, such as data prefetching, paginated requests,
    and infinite queries. You will also put the DevTools to use to help you debug
    your queries.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第五章*](B18501_05.xhtml#_idTextAnchor140)《更多数据获取挑战》中，你将继续学习如何使用`useQuery`钩子来解决一些更常见的服务器状态挑战，例如数据预取、分页请求和无限制查询。你还将使用开发者工具来帮助你调试查询。
