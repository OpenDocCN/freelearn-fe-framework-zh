<html><head></head><body>
		<div id="_idContainer006">
			<h1 id="_idParaDest-13"><em class="italic"><a id="_idTextAnchor012"/><span class="koboSpan" id="kobo.1.1">Chapter 1</span></em><span class="koboSpan" id="kobo.2.1">: What Is Micro State Management with React Hooks?</span></h1>
			<p><strong class="bold"><span class="koboSpan" id="kobo.3.1">State management</span></strong><span class="koboSpan" id="kobo.4.1"> is one of the most important topics in developing React apps. </span><span class="koboSpan" id="kobo.4.2">Traditionally, state management</span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.5.1"> in React was something monolithic, providing a general framework for state management, and with developers creating purpose-specific solutions within the framework. </span></p>
			<p><span class="koboSpan" id="kobo.6.1">The situation changed after </span><strong class="bold"><span class="koboSpan" id="kobo.7.1">React hooks</span></strong><span class="koboSpan" id="kobo.8.1"> landed. </span><span class="koboSpan" id="kobo.8.2">We now have primitive hooks for state management that are reusable and can be used as building blocks to create richer functionalities. </span><span class="koboSpan" id="kobo.8.3">This allows us to make state management lightweight or, in other words, micro. </span><strong class="bold"><span class="koboSpan" id="kobo.9.1">Micro state management</span></strong><span class="koboSpan" id="kobo.10.1"> is more purpose-oriented and used with specific coding patterns, whereas</span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.11.1"> monolithic state management is more general.</span></p>
			<p><span class="koboSpan" id="kobo.12.1">In this book, we will explore various patterns of state management with React hooks. </span><span class="koboSpan" id="kobo.12.2">Our focus is on global states, in which multiple components can share a state. </span><span class="koboSpan" id="kobo.12.3">React hooks already provide good functionality for local states—that is, states within a single component or a small tree of components. </span><strong class="bold"><span class="koboSpan" id="kobo.13.1">Global states</span></strong><span class="koboSpan" id="kobo.14.1"> are a hard topic in React because React hooks</span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.15.1"> are missing the capability to directly provide global states; it's instead left to the community and ecosystem to deal with them. </span><span class="koboSpan" id="kobo.15.2">We will also explore some existing libraries for micro state management, each of which has different purposes and patterns; in this book, we will discuss Zustand, Jotai, Valtio, and React Tracked.</span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.16.1">Important Note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.17.1">This book focuses on a global state and doesn't discuss "general" state management, which is a separate topic. </span><span class="koboSpan" id="kobo.17.2">One of the most popular state</span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.18.1"> management libraries is Redux (</span><a href="https://redux.js.org"><span class="koboSpan" id="kobo.19.1">https://redux.js.org</span></a><span class="koboSpan" id="kobo.20.1">), which uses a one-way data model for state management. </span><span class="koboSpan" id="kobo.20.2">Another popular library is XState (</span><a href="https://xstate.js.org"><span class="koboSpan" id="kobo.21.1">https://xstate.js.org</span></a><span class="koboSpan" id="kobo.22.1">), which</span><a id="_idIndexMarker004"/><span class="koboSpan" id="kobo.23.1"> is an implementation of statecharts, a visual representation of complex states. </span><span class="koboSpan" id="kobo.23.2">Both provide sophisticated methods to manage states, which are out of the scope of this book. </span><span class="koboSpan" id="kobo.23.3">On the other hand, such libraries also have a capability for a global state. </span><span class="koboSpan" id="kobo.23.4">For example, React Redux (</span><a href="https://react-redux.js.org"><span class="koboSpan" id="kobo.24.1">https://react-redux.js.org</span></a><span class="koboSpan" id="kobo.25.1">) is a library to bind React and Redux</span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.26.1"> for a global state, which is in the scope of this book. </span><span class="koboSpan" id="kobo.26.2">To keep the focus of the book only on a global state, we don't specifically discuss React Redux, which is tied to Redux. </span></p>
			<p><span class="koboSpan" id="kobo.27.1">In this chapter, we will define what micro state management is, discuss how React hooks allow micro state management, and why global states are challenging. </span><span class="koboSpan" id="kobo.27.2">We will also recap the basic usage of two hooks for state management and compare their similarity and differences.</span></p>
			<p><span class="koboSpan" id="kobo.28.1">In this chapter, we will cover the following topics: </span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.29.1">Understanding micro state management </span></li>
				<li><span class="koboSpan" id="kobo.30.1">Working with hooks </span></li>
				<li><span class="koboSpan" id="kobo.31.1">Exploring global states </span></li>
				<li><span class="koboSpan" id="kobo.32.1">Working with </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">useState</span></strong> </li>
				<li><span class="koboSpan" id="kobo.34.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.35.1">useReducer </span></strong></li>
				<li><span class="koboSpan" id="kobo.36.1">Exploring the similarities and differences between </span><strong class="source-inline"><span class="koboSpan" id="kobo.37.1">useState</span></strong><span class="koboSpan" id="kobo.38.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.39.1">useReducer</span></strong></li>
			</ul>
			<h1 id="_idParaDest-14"><a id="_idTextAnchor013"/><span class="koboSpan" id="kobo.40.1">Technical requirements</span></h1>
			<p><span class="koboSpan" id="kobo.41.1">To run code snippets, you need a React environment—for example, Create React App (</span><a href="https://create-react-app.dev"><span class="koboSpan" id="kobo.42.1">https://create-react-app.dev</span></a><span class="koboSpan" id="kobo.43.1">) or CodeSandbox (</span><a href="https://codesandbox.io"><span class="koboSpan" id="kobo.44.1">https://codesandbox.io</span></a><span class="koboSpan" id="kobo.45.1">).</span></p>
			<p><span class="koboSpan" id="kobo.46.1">You are expected to have basic knowledge of React and React hooks. </span><span class="koboSpan" id="kobo.46.2">More precisely, you should already be familiar with the official React documentation, which you can find here: </span><a href="https://reactjs.org/docs/getting-started.html"><span class="koboSpan" id="kobo.47.1">https://reactjs.org/docs/getting-started.html</span></a><span class="koboSpan" id="kobo.48.1">.</span></p>
			<p><span class="koboSpan" id="kobo.49.1">We don't use class components and it's not necessary to learn them unless you need to learn some existing code with class components.</span></p>
			<p><span class="koboSpan" id="kobo.50.1">The code in this chapter is available on GitHub at </span><a href="https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_01"><span class="koboSpan" id="kobo.51.1">https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_01</span></a><span class="koboSpan" id="kobo.52.1">.</span></p>
			<h1 id="_idParaDest-15"><a id="_idTextAnchor014"/><span class="koboSpan" id="kobo.53.1">Understanding micro state management</span></h1>
			<p><span class="koboSpan" id="kobo.54.1">What is </span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.55.1">micro state management? </span><span class="koboSpan" id="kobo.55.2">There is no officially established definition yet; however, let's try defining one here.</span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.56.1">Important Note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.57.1">This definition may not reflect community standards in the future.</span></p>
			<p><strong class="bold"><span class="koboSpan" id="kobo.58.1">State</span></strong><span class="koboSpan" id="kobo.59.1">, in React, is any data that represents the </span><strong class="bold"><span class="koboSpan" id="kobo.60.1">user interface</span></strong><span class="koboSpan" id="kobo.61.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.62.1">UI</span></strong><span class="koboSpan" id="kobo.63.1">). </span><span class="koboSpan" id="kobo.63.2">States can change over time, and React takes care</span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.64.1"> of components to render with the state.</span></p>
			<p><span class="koboSpan" id="kobo.65.1">Before we had React hooks, using monolithic state libraries was a popular pattern. </span><span class="koboSpan" id="kobo.65.2">A single state covers many purposes for better developer experience, but sometimes it was overkill because the monolithic state libraries can contain unused functionalities. </span><span class="koboSpan" id="kobo.65.3">With hooks, we have a new way to create states. </span><span class="koboSpan" id="kobo.65.4">This allows us to have different solutions for each specific purpose that you need. </span><span class="koboSpan" id="kobo.65.5">Here are some examples of this:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.66.1">Form state should be treated separately from a global state, which is not possible with a single-state solution. </span></li>
				<li><span class="koboSpan" id="kobo.67.1">Server cache state has some unique characteristics, such as refetching, which is a different feature from other states. </span></li>
				<li><span class="koboSpan" id="kobo.68.1">Navigation state has a special requirement that the original state resides on the browser end and, again, a single-state solution doesn't fit.</span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.69.1">Fixing these issues is one of the goals of React hooks. </span><span class="koboSpan" id="kobo.69.2">The trend with React hooks is to handle various states with special solutions for them. </span><span class="koboSpan" id="kobo.69.3">There are many hook-based libraries to solve things such as form state, server cache state, and so on.</span></p>
			<p><span class="koboSpan" id="kobo.70.1">There's still a need for general state management, as we will need to deal with states that are not covered by purpose-oriented solutions. </span><span class="koboSpan" id="kobo.70.2">The proportion of work left for general state management varies on apps. </span><span class="koboSpan" id="kobo.70.3">For example, an app that mainly deals with server states would require only one or a few small global states. </span><span class="koboSpan" id="kobo.70.4">On the other hand, a rich graphical app would require many large global states compared to server states required in the app. </span></p>
			<p><span class="koboSpan" id="kobo.71.1">Hence, solutions for general state management should be lightweight, and developers can choose one based</span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.72.1"> on their requirements. </span><span class="koboSpan" id="kobo.72.2">This is what we call micro state management. </span><span class="koboSpan" id="kobo.72.3">To define this concept, it's lightweight state management in React, where each solution has several different features, and developers can choose one from possible solutions depending on app requirements.</span></p>
			<p><span class="koboSpan" id="kobo.73.1">Micro state management</span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.74.1"> can have several requirements, to fulfill developers' various needs. </span><span class="koboSpan" id="kobo.74.2">There are base state management requirements, to do things such as these:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.75.1">Read state</span></li>
				<li><span class="koboSpan" id="kobo.76.1">Update state</span></li>
				<li><span class="koboSpan" id="kobo.77.1">Render with state</span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.78.1">But there may be additional requirements to do other things, such as these:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.79.1">Optimize re-renders</span></li>
				<li><span class="koboSpan" id="kobo.80.1">Interact with other systems</span></li>
				<li><span class="koboSpan" id="kobo.81.1">Async support</span></li>
				<li><span class="koboSpan" id="kobo.82.1">Derived state</span></li>
				<li><span class="koboSpan" id="kobo.83.1">Simple syntax; and so on</span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.84.1">However, we don't need all features, and some of them may conflict. </span><span class="koboSpan" id="kobo.84.2">Hence, a micro state management solution cannot be a single solution either. </span><span class="koboSpan" id="kobo.84.3">There are multiple solutions for different requirements.</span></p>
			<p><span class="koboSpan" id="kobo.85.1">Another aspect to mention regarding micro state management and its library is its learning curve. </span><span class="koboSpan" id="kobo.85.2">Ease of learning is important for general state management too, but as the use cases covered by micro state management can be smaller, it should be easier to learn. </span><span class="koboSpan" id="kobo.85.3">An easier learning curve</span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.86.1"> will result in a better developer experience and more productivity.</span></p>
			<p><span class="koboSpan" id="kobo.87.1">In this section, we discussed what micro state management is. </span><span class="koboSpan" id="kobo.87.2">Coming up, we will see an overview of some hooks that handle states.</span></p>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/><span class="koboSpan" id="kobo.88.1">Working with hooks</span></h1>
			<p><span class="koboSpan" id="kobo.89.1">React hooks are essential for micro statement management. </span><span class="koboSpan" id="kobo.89.2">React hooks include some primitive hooks</span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.90.1"> to implement state management solutions, such as the following:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.91.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">useState</span></strong><span class="koboSpan" id="kobo.93.1"> hook is a basic function to create</span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.94.1"> a local state. </span><span class="koboSpan" id="kobo.94.2">Thanks to React hooks' composability, we can create a custom hook that can add various features based on </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">useState</span></strong><span class="koboSpan" id="kobo.96.1">. </span></li>
				<li><span class="koboSpan" id="kobo.97.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">useReducer</span></strong><span class="koboSpan" id="kobo.99.1"> hook can create a local state</span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.100.1"> too and is often used as a replacement for </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">useState</span></strong><span class="koboSpan" id="kobo.102.1">. </span><span class="koboSpan" id="kobo.102.2">We will revisit these hooks to learn about the similarities and differences between </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">useState</span></strong><span class="koboSpan" id="kobo.104.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">useReducer</span></strong><span class="koboSpan" id="kobo.106.1"> later in this chapter.</span></li>
				<li><span class="koboSpan" id="kobo.107.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">useEffect</span></strong><span class="koboSpan" id="kobo.109.1"> hook allows us to run logic outside</span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.110.1"> the React render process. </span><span class="koboSpan" id="kobo.110.2">It's especially important to develop a state management library for a global state because it allows us to implement features that work with the React component lifecycle.</span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.111.1">The reason why React hooks are novel is that they allow you to extract logic out of UI components. </span><span class="koboSpan" id="kobo.111.2">For example, the following is a counter example of the simple usage of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">useState</span></strong><span class="koboSpan" id="kobo.113.1"> hook:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.114.1">const Component = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.115.1">  const [count, setCount] = useState(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.116.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.117.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.118.1">      {count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.119.1">      &lt;button onClick={() =&gt; setCount((c) =&gt; c + 1)}&gt;+1</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.120.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.121.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.122.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.123.1">};</span></p>
			<p><span class="koboSpan" id="kobo.124.1">Now, let's see how we can extract logic. </span><span class="koboSpan" id="kobo.124.2">Using the same</span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.125.1"> counter example, we will create a custom hook named </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">useCount</span></strong><span class="koboSpan" id="kobo.127.1">, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.128.1">const useCount = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.129.1">  const [count, setCount] = useState(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.130.1">  return [count, setCount];</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.131.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.132.1">const Component = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.133.1">  const [count, setCount] = useCount();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.134.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.135.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.136.1">      {count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.137.1">      &lt;button onClick={() =&gt; setCount((c) =&gt; c + 1)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.138.1">        +1</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.139.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.140.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.141.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.142.1">};</span></p>
			<p><span class="koboSpan" id="kobo.143.1">It doesn't change a lot, and some of you may think this is overcomplicated. </span><span class="koboSpan" id="kobo.143.2">However, there are two points to note, as follows:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.144.1">We now have a clearer name—</span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">useCount</span></strong><span class="koboSpan" id="kobo.146.1">.</span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">Component</span></strong><span class="koboSpan" id="kobo.148.1"> is independent of the implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">useCount</span></strong><span class="koboSpan" id="kobo.150.1">.</span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.151.1">The first point is very important for programming in general. </span><span class="koboSpan" id="kobo.151.2">If we name the custom hook properly, the code is more readable. </span><span class="koboSpan" id="kobo.151.3">Instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">useCount</span></strong><span class="koboSpan" id="kobo.153.1">, you could name it </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">useScore</span></strong><span class="koboSpan" id="kobo.155.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">usePercentage</span></strong><span class="koboSpan" id="kobo.157.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">usePrice</span></strong><span class="koboSpan" id="kobo.159.1">. </span><span class="koboSpan" id="kobo.159.2">Even though they have the same implementations, if the name is different, we consider it a different hook. </span><span class="koboSpan" id="kobo.159.3">Naming things is very important.</span></p>
			<p><span class="koboSpan" id="kobo.160.1">The second point is also important when it comes to micro state management libraries. </span><span class="koboSpan" id="kobo.160.2">As </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">useCount</span></strong><span class="koboSpan" id="kobo.162.1"> is extracted from </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">Component</span></strong><span class="koboSpan" id="kobo.164.1">, we can add functionality without breaking the component.</span></p>
			<p><span class="koboSpan" id="kobo.165.1">For example, we want</span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.166.1"> to output a debug message on the console when the count is changed. </span><span class="koboSpan" id="kobo.166.2">To do so, we would execute the following code:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.167.1">const useCount = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.168.1">  const [count, setCount] = useState(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.169.1">  useEffect(() =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.170.1">    console.log('count is changed to', count);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.171.1">  }, [count]);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.172.1">  return [count, setCount];</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.173.1">};</span></p>
			<p><span class="koboSpan" id="kobo.174.1">By just changing </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">useCount</span></strong><span class="koboSpan" id="kobo.176.1">, we can add a feature of showing a debug message. </span><span class="koboSpan" id="kobo.176.2">We do not need to change the component. </span><span class="koboSpan" id="kobo.176.3">This is the benefit of extracting logic</span><a id="_idTextAnchor016"/><span class="koboSpan" id="kobo.177.1"> as custom hooks.</span></p>
			<p><span class="koboSpan" id="kobo.178.1">We could also add a new rule. </span><span class="koboSpan" id="kobo.178.2">Suppose we don't want to allow the count to change arbitrarily, but only by increments of one. </span><span class="koboSpan" id="kobo.178.3">The following custom hook does the job:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.179.1">const useCount = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.180.1">  const [count, setCount] = useState(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.181.1">  const inc = () =&gt; setCount((c) =&gt; c + 1);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.182.1">  return [count, inc];</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.183.1">};</span></p>
			<p><span class="koboSpan" id="kobo.184.1">This opens up the entire ecosystem to provide custom hooks for various purposes. </span><span class="koboSpan" id="kobo.184.2">They can be a wrapper to add a tiny functionality or a huge hook that has a larger job.</span></p>
			<p><span class="koboSpan" id="kobo.185.1">You will find</span><a id="_idIndexMarker017"/><span class="koboSpan" id="kobo.186.1"> many custom hooks</span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.187.1"> publicly available on </span><strong class="bold"><span class="koboSpan" id="kobo.188.1">Node Package Manager</span></strong><span class="koboSpan" id="kobo.189.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.190.1">npm</span></strong><span class="koboSpan" id="kobo.191.1">) (</span><a href="https://www.npmjs.com/search?q=react%20hooks"><span class="koboSpan" id="kobo.192.1">https://www.npmjs.com/search?q=react%20hooks</span></a><span class="koboSpan" id="kobo.193.1">) or GitHub (</span><a href="https://github.com/search?q=react+hooks&amp;type=repositories"><span class="koboSpan" id="kobo.194.1">https://github.com/search?q=react+hooks&amp;type=repositories</span></a><span class="koboSpan" id="kobo.195.1">).</span></p>
			<p><span class="koboSpan" id="kobo.196.1">We should also discuss a little about suspense and concurrent rendering, as React hooks are designed and developed to work with these modes.</span></p>
			<h2 id="_idParaDest-17"><a id="_idTextAnchor017"/><span class="koboSpan" id="kobo.197.1">Suspense for Data Fetching and Concurrent Rendering</span></h2>
			<p><span class="koboSpan" id="kobo.198.1">Suspense for Data Fetching and Concurrent Rendering are not yet released by React, but it's important to mention them briefly.</span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.199.1">Important Note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.200.1">Suspense for Data Fetching and Concurrent Rendering may have different names when they are officially released, but these are the names at the time of writing.</span></p>
			<p><strong class="bold"><span class="koboSpan" id="kobo.201.1">Suspense for Data Fetching</span></strong><span class="koboSpan" id="kobo.202.1"> is a mechanism that basically allows</span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.203.1"> you to code your components without worrying about </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">async</span></strong><span class="koboSpan" id="kobo.205.1">.</span></p>
			<p><strong class="bold"><span class="koboSpan" id="kobo.206.1">Concurrent Rendering</span></strong><span class="koboSpan" id="kobo.207.1"> is a mechanism to split the render</span><a id="_idIndexMarker020"/><span class="koboSpan" id="kobo.208.1"> process into chunks to avoid blocking the </span><strong class="bold"><span class="koboSpan" id="kobo.209.1">central processing unit</span></strong><span class="koboSpan" id="kobo.210.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.211.1">CPU</span></strong><span class="koboSpan" id="kobo.212.1">) for long periods of time.</span></p>
			<p><span class="koboSpan" id="kobo.213.1">React hooks are designed to work with these mechanisms; however, you need to avoid misusing them.</span></p>
			<p><span class="koboSpan" id="kobo.214.1">For example, one rule is that you should not mutate an existing </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">state</span></strong><span class="koboSpan" id="kobo.216.1"> object or </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">ref</span></strong><span class="koboSpan" id="kobo.218.1"> object. </span><span class="koboSpan" id="kobo.218.2">Doing so may lead to unexpected behavior such as not triggering re-renders, triggering too many re-renders, and triggering partial re-renders (meaning some components re-render while others don't when they should).</span></p>
			<p><span class="koboSpan" id="kobo.219.1">Hook functions and component functions can be invoked multiple times. </span><span class="koboSpan" id="kobo.219.2">Hence, another rule is those functions have to be "pure" enough so that they behave consistently, even if they are invoked several times.</span></p>
			<p><span class="koboSpan" id="kobo.220.1">These are the two major rules people often violate. </span><span class="koboSpan" id="kobo.220.2">This is a hard problem in practice, because even if your code violates those rules, it may just work in Non-Concurrent Rendering. </span><span class="koboSpan" id="kobo.220.3">Hence, people wouldn't notice the misuse. </span><span class="koboSpan" id="kobo.220.4">Even in Concurrent Rendering, it may work to some extent without problems, and people would only see problems occasionally. </span><span class="koboSpan" id="kobo.220.5">This makes it especially difficult for beginners who are using React for the first time.</span></p>
			<p><span class="koboSpan" id="kobo.221.1">Unless you are familiar with these concepts, it's better to use well-designed and battle-tested (micro) state management libraries for future/newer versions of React.</span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.222.1">Important Note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.223.1">As of writing, Concurrent Rendering</span><a id="_idIndexMarker021"/><span class="koboSpan" id="kobo.224.1"> is described in the </span><em class="italic"><span class="koboSpan" id="kobo.225.1">React 18 Working Group</span></em><span class="koboSpan" id="kobo.226.1">, which you can read about here: </span><a href="https://github.com/reactwg/react-18/discussions"><span class="koboSpan" id="kobo.227.1">https://github.com/reactwg/react-18/discussions</span></a><span class="koboSpan" id="kobo.228.1">.</span></p>
			<p><span class="koboSpan" id="kobo.229.1">In this section, we revisited basic React hooks and got some understanding of the concepts. </span><span class="koboSpan" id="kobo.229.2">Coming up, we start exploring global states, which are the main topic in this book.</span></p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/><span class="koboSpan" id="kobo.230.1">Exploring global states</span></h1>
			<p><span class="koboSpan" id="kobo.231.1">React provides primitive hooks</span><a id="_idIndexMarker022"/><span class="koboSpan" id="kobo.232.1"> such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">useState</span></strong><span class="koboSpan" id="kobo.234.1"> for states that are defined in a component and consumed within</span><a id="_idIndexMarker023"/><span class="koboSpan" id="kobo.235.1"> the component tree. </span><span class="koboSpan" id="kobo.235.2">These are often called local states. </span></p>
			<p><span class="koboSpan" id="kobo.236.1">The following example uses a local state:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.237.1">const Component = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.238.1">  const [state, setState] = useState();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.239.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.240.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.241.1">      {JSON.stringify(state)}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.242.1">      &lt;Child state={state} setState={setState} /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.243.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.244.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.245.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.246.1">const Child = ({ state, setState }) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.247.1">  const setFoo = () =&gt; setState(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.248.1">    (prev) =&gt; ({ ...prev, foo: 'foo' })</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.249.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.250.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.251.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.252.1">      {JSON.stringify(state)}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.253.1">      &lt;button onClick={setFoo}&gt;Set Foo&lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.254.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.255.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.256.1">};</span></p>
			<p><span class="koboSpan" id="kobo.257.1">On the other hand, a global state</span><a id="_idIndexMarker024"/><span class="koboSpan" id="kobo.258.1"> is a state that is consumed in multiple components, often far apart in an app. </span><span class="koboSpan" id="kobo.258.2">A global state doesn't have to be a singleton, and we may call a global state a shared state instead, to clarify that it's not a singleton.</span></p>
			<p><span class="koboSpan" id="kobo.259.1">The following code snippet provides an example of what a React component would look like with a global state: </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.260.1">const Component1 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.261.1">  const [state, setState] = useGlobalState();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.262.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.263.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.264.1">      {JSON.stringify(state)}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.265.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.266.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.267.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.268.1">const Component2 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.269.1">  const [state, setState] = useGlobalState();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.270.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.271.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.272.1">      {JSON.stringify(state)}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.273.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.274.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.275.1">};</span></p>
			<p><span class="koboSpan" id="kobo.276.1">As we haven't yet defined </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">useGlobalState</span></strong><span class="koboSpan" id="kobo.278.1">, it won't work. </span><span class="koboSpan" id="kobo.278.2">In this case, we want </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">Component1</span></strong><span class="koboSpan" id="kobo.280.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">Component2</span></strong><span class="koboSpan" id="kobo.282.1"> to have the same state.</span></p>
			<p><span class="koboSpan" id="kobo.283.1">Implementing global states</span><a id="_idIndexMarker025"/><span class="koboSpan" id="kobo.284.1"> in React is not a trivial task. </span><span class="koboSpan" id="kobo.284.2">This is mostly because React is based on the component model. </span><span class="koboSpan" id="kobo.284.3">In the component model, locality is important, meaning a component should be isolated and should be reusable.</span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.285.1">Notes about the Component Model</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.286.1">A component</span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.287.1"> is a reusable piece of a unit, like a function. </span><span class="koboSpan" id="kobo.287.2">If you define a component, it can be used many times. </span><span class="koboSpan" id="kobo.287.3">This is only possible if a component definition is self-contained. </span><span class="koboSpan" id="kobo.287.4">If a component depends on something outside, it may not be reusable because its behavior can be inconsistent. </span><span class="koboSpan" id="kobo.287.5">Technically, a component itself should not depend on a global state.</span></p>
			<p><span class="koboSpan" id="kobo.288.1">React doesn't provide a direct solution for a global state, and it seems up to the developers and the community. </span><span class="koboSpan" id="kobo.288.2">Many solutions have been proposed, and each has its pros and cons. </span><span class="koboSpan" id="kobo.288.3">The goal of this book is to show typical solutions and discuss these pros and cons, which we will do in the following chapters: </span></p>
			<ul>
				<li><a href="B17780_03_Final_VK_ePub.xhtml#_idTextAnchor049"><em class="italic"><span class="koboSpan" id="kobo.289.1">Chapter 3</span></em></a><span class="koboSpan" id="kobo.290.1">, </span><em class="italic"><span class="koboSpan" id="kobo.291.1">Sharing Component State with Context</span></em></li>
				<li><a href="B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066"><em class="italic"><span class="koboSpan" id="kobo.292.1">Chapter 4</span></em></a><span class="koboSpan" id="kobo.293.1">, </span><em class="italic"><span class="koboSpan" id="kobo.294.1">Sharing Module State with Subscription</span></em></li>
				<li><a href="B17780_05_Final_VK_ePub.xhtml#_idTextAnchor073"><em class="italic"><span class="koboSpan" id="kobo.295.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.296.1">, </span><em class="italic"><span class="koboSpan" id="kobo.297.1">Sharing Component State with Context and Subscription</span></em></li>
			</ul>
			<p><span class="koboSpan" id="kobo.298.1">In this section, we learned what a global state with React hooks would look like. </span><span class="koboSpan" id="kobo.298.2">Coming up, we will learn some basics of </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">useState</span></strong><span class="koboSpan" id="kobo.300.1"> to prepare the discussion in the following chapters.</span></p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor019"/><span class="koboSpan" id="kobo.301.1">Working with useState</span></h1>
			<p><span class="koboSpan" id="kobo.302.1">In this section, we will learn how to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">useState</span></strong><span class="koboSpan" id="kobo.304.1">, from basic usage to advanced usage. </span><span class="koboSpan" id="kobo.304.2">We start</span><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.305.1"> with the simplest form, which is updating with the state with a new value, then updating with a function, which is a very powerful feature, and finally, we will discuss lazy initialization.</span></p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor020"/><span class="koboSpan" id="kobo.306.1">Updating the state value with a value</span></h2>
			<p><span class="koboSpan" id="kobo.307.1">One way to update</span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.308.1"> the state value with </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">useState</span></strong><span class="koboSpan" id="kobo.310.1"> is by providing</span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.311.1"> a new value. </span><span class="koboSpan" id="kobo.311.2">You can pass a new value to the function returned by </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">useState</span></strong><span class="koboSpan" id="kobo.313.1"> that will eventually replace the state value</span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.314.1"> with the new value. </span></p>
			<p><span class="koboSpan" id="kobo.315.1">Here is a counter example showing updating with a value:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.316.1">const Component = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.317.1">  const [count, setCount] = useState(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.318.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.319.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.320.1">      {count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.321.1">      &lt;button onClick={() =&gt; setCount(1)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.322.1">        Set Count to 1</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.323.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.324.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.325.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.326.1">};</span></p>
			<p><span class="koboSpan" id="kobo.327.1">You pass a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">1</span></strong><span class="koboSpan" id="kobo.329.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">setCount</span></strong><span class="koboSpan" id="kobo.331.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">onClick</span></strong><span class="koboSpan" id="kobo.333.1"> handler. </span><span class="koboSpan" id="kobo.333.2">If you click the button, it will trigger </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">Component</span></strong><span class="koboSpan" id="kobo.335.1"> to re-render with </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">count=1</span></strong><span class="koboSpan" id="kobo.337.1">.</span></p>
			<p><span class="koboSpan" id="kobo.338.1">What would happen if you clicked the button again? </span><span class="koboSpan" id="kobo.338.2">It will invoke </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">setCount(1)</span></strong><span class="koboSpan" id="kobo.340.1"> again, but as it is the same value, it "bails out" and the component won't re-render. </span><strong class="bold"><span class="koboSpan" id="kobo.341.1">Bailout</span></strong><span class="koboSpan" id="kobo.342.1"> is a technical term in React</span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.343.1"> and basically means avoiding triggering re-renders.</span></p>
			<p><span class="koboSpan" id="kobo.344.1">Let's look at another example here:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.345.1">const Component = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.346.1">  const [state, setState] = useState({ count: 0 });</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.347.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.348.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.349.1">      {state.count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.350.1">      &lt;button onClick={() =&gt; setState({ count: 1 })}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.351.1">        Set Count to 1</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.352.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.353.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.354.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.355.1">};</span></p>
			<p><span class="koboSpan" id="kobo.356.1">This behaves exactly the same as the previous example for the first click; however, if you click the button again, the component</span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.357.1"> will re-render. </span><span class="koboSpan" id="kobo.357.2">You don't see any difference</span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.358.1"> on screen because the count hasn't changed. </span><span class="koboSpan" id="kobo.358.2">This happens</span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.359.1"> because the second click creates a new object, </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">{ count: 1 }</span></strong><span class="koboSpan" id="kobo.361.1">, and it's different from the previous object.</span></p>
			<p><span class="koboSpan" id="kobo.362.1">Now, this leads to the following bad practice:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.363.1">const Component = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.364.1">  const [state, setState] = useState({ count: 0 });</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.365.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.366.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.367.1">      {state.count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.368.1">      &lt;button</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.369.1">        onClick={() =&gt; { state.count = 1; setState(state); }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.370.1">      &gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.371.1">        Set Count to 1</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.372.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.373.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.374.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.375.1">};</span></p>
			<p><span class="koboSpan" id="kobo.376.1">This doesn't work as expected. </span><span class="koboSpan" id="kobo.376.2">Even if you click the button, it won't re-render. </span><span class="koboSpan" id="kobo.376.3">This is because the state object is referentially</span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.377.1"> unchanged, and it bails out, meaning</span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.378.1"> this alone doesn't trigger the re-render.</span></p>
			<p><span class="koboSpan" id="kobo.379.1">Finally, there's an interesting usage</span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.380.1"> of value update, which we can see here:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.381.1">const Component = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.382.1">  const [count, setCount] = useState(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.383.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.384.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.385.1">      {count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.386.1">      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.387.1">        Set Count to {count + 1}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.388.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.389.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.390.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.391.1">};</span></p>
			<p><span class="koboSpan" id="kobo.392.1">Clicking the button will increment the count; however, if you click the button twice quickly enough, it will increment by just one number. </span><span class="koboSpan" id="kobo.392.2">This is sometimes desirable as it matches with the button title, but sometimes it's not if you expect to count how many times the button is actually clicked. </span><span class="koboSpan" id="kobo.392.3">That requires a function update.</span></p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor021"/><span class="koboSpan" id="kobo.393.1">Updating the state value with a function</span></h2>
			<p><span class="koboSpan" id="kobo.394.1">Another</span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.395.1"> way to update</span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.396.1"> the state with </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">useState</span></strong><span class="koboSpan" id="kobo.398.1"> is called a</span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.399.1"> function update.</span></p>
			<p><span class="koboSpan" id="kobo.400.1">Here is a counter example</span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.401.1"> showing updating with a function:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.402.1">const Component = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.403.1">  const [count, setCount] = useState(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.404.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.405.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.406.1">      {count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.407.1">      &lt;button onClick={() =&gt; setCount((c) =&gt; c + 1)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.408.1">        Increment Count</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.409.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.410.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.411.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.412.1">};</span></p>
			<p><span class="koboSpan" id="kobo.413.1">This actually counts how many times the button is clicked, because </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">(c) =&gt; c + 1</span></strong><span class="koboSpan" id="kobo.415.1"> is invoked sequentially. </span><span class="koboSpan" id="kobo.415.2">As we saw in the previous section, value update has the same use case as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">Set Count to {count + 1}</span></strong><span class="koboSpan" id="kobo.417.1"> feature. </span><span class="koboSpan" id="kobo.417.2">In most use cases, function updates work better if the update is based on the previous value. </span><span class="koboSpan" id="kobo.417.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">Set Count to {count + 1}</span></strong><span class="koboSpan" id="kobo.419.1"> feature actually means that it doesn't depend on the previous value but depends on the displayed value.</span></p>
			<p><span class="koboSpan" id="kobo.420.1">Bailout is also possible with function updates. </span><span class="koboSpan" id="kobo.420.2">Here's an example to demonstrate this:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.421.1">const Component = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.422.1">  const [count, setCount] = useState(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.423.1">  useEffect(() =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.424.1">    const id = setInterval(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.425.1">      () =&gt; setCount((c) =&gt; c + 1),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.426.1">      1000,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.427.1">    );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.428.1">    return () =&gt; clearInterval(id);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.429.1">  }, []);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.430.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.431.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.432.1">      {count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.433.1">      &lt;button</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.434.1">        onClick={() =&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.435.1">          setCount((c) =&gt; c % 2 === 0 ? </span><span class="koboSpan" id="kobo.435.2">c : c + 1)}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.436.1">      &gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.437.1">        Increment Count if it makes the result even</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.438.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.439.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.440.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.441.1">};</span></p>
			<p><span class="koboSpan" id="kobo.442.1">If the update function returns</span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.443.1"> the exact same state as the previous</span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.444.1"> state, it will bail out, and this component</span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.445.1"> won't re-render. </span><span class="koboSpan" id="kobo.445.2">For example, if you invoke </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">setCount((c) =&gt; c)</span></strong><span class="koboSpan" id="kobo.447.1">, it will never re-render.</span></p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor022"/><span class="koboSpan" id="kobo.448.1">Lazy initialization</span></h2>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">useState</span></strong><span class="koboSpan" id="kobo.450.1"> can receive a function</span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.451.1"> for initialization that will be evaluated</span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.452.1"> only in the first render. </span><span class="koboSpan" id="kobo.452.2">We can do something like this:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.453.1">const init = () =&gt; 0;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.454.1">const Component = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.455.1">  const [count, setCount] = useState(init);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.456.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.457.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.458.1">      {count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.459.1">      &lt;button onClick={() =&gt; setCount((c) =&gt; c + 1)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.460.1">        Increment Count</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.461.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.462.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.463.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.464.1">};</span></p>
			<p><span class="koboSpan" id="kobo.465.1">The use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">init</span></strong><span class="koboSpan" id="kobo.467.1"> in this example is not very effective because returning </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">0</span></strong><span class="koboSpan" id="kobo.469.1"> doesn't require much computation, but the point is that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">init</span></strong><span class="koboSpan" id="kobo.471.1"> function can include heavy computation and is only invoked to get the initial state. </span><span class="koboSpan" id="kobo.471.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">init</span></strong><span class="koboSpan" id="kobo.473.1"> function is evaluated lazily, not evaluated before</span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.474.1"> calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">useState</span></strong><span class="koboSpan" id="kobo.476.1">; in other words, it's invoked just</span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.477.1"> once on </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">mount</span></strong><span class="koboSpan" id="kobo.479.1">.</span></p>
			<p><span class="koboSpan" id="kobo.480.1">We have now learned how to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">useState</span></strong><span class="koboSpan" id="kobo.482.1">; next up is </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">useReducer</span></strong><span class="koboSpan" id="kobo.484.1">.</span></p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor023"/><span class="koboSpan" id="kobo.485.1">Using useReducer</span></h1>
			<p><span class="koboSpan" id="kobo.486.1">In this section, we will</span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.487.1"> learn how to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">useReducer</span></strong><span class="koboSpan" id="kobo.489.1">. </span><span class="koboSpan" id="kobo.489.2">We will learn about its typical usage, how to bail out, its usage with primitive values, and lazy initialization.</span></p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor024"/><span class="koboSpan" id="kobo.490.1">Typical usage</span></h2>
			<p><span class="koboSpan" id="kobo.491.1">A reducer is helpful</span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.492.1"> for complex states. </span><span class="koboSpan" id="kobo.492.2">Here's a simple example a with two-property object:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.493.1">const reducer = (state, action) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.494.1">  switch (action.type) {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.495.1">    case 'INCREMENT':</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.496.1">      return { ...state, count: state.count + 1 };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.497.1">    case 'SET_TEXT':</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.498.1">      return { ...state, text: action.text };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.499.1">    default:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.500.1">      throw new Error('unknown action type');</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.501.1">  }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.502.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.503.1">const Component = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.504.1">  const [state, dispatch] = useReducer(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.505.1">    reducer,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.506.1">    { count: 0, text: 'hi' },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.507.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.508.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.509.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.510.1">      {state.count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.511.1">      &lt;button</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.512.1">        onClick={() =&gt; dispatch({ type: 'INCREMENT' })}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.513.1">      &gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.514.1">        Increment count</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.515.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.516.1">      &lt;input</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.517.1">        value={state.text}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.518.1">        onChange={(e) =&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.519.1">          dispatch({ type: 'SET_TEXT', text: e.target.value })}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.520.1">      /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.521.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.522.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.523.1">};</span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">useReducer</span></strong><span class="koboSpan" id="kobo.525.1"> allows us to define a reducer function in advance by taking the defined reducer function and initial state in parameters. </span><span class="koboSpan" id="kobo.525.2">The benefit of defining a reducer function outside the hook is being able to separate code and testability. </span><span class="koboSpan" id="kobo.525.3">Because the reducer function</span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.526.1"> is a pure function, it's easier to test its behavior.</span></p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor025"/><span class="koboSpan" id="kobo.527.1">Bailout</span></h2>
			<p><span class="koboSpan" id="kobo.528.1">As well as </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">useState</span></strong><span class="koboSpan" id="kobo.530.1">, bailout works</span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.531.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">useReducer</span></strong><span class="koboSpan" id="kobo.533.1"> too. </span><span class="koboSpan" id="kobo.533.2">Using the previous example, let's modify the reducer so that it will bail out if </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">action.text</span></strong><span class="koboSpan" id="kobo.535.1"> is empty, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.536.1">const reducer = (state, action) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.537.1">  switch (action.type) {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.538.1">    case 'INCREMENT':</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.539.1">      return { ...state, count: state.count + 1 };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.540.1">    case 'SET_TEXT':</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.541.1">      if (!action.text) {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.542.1">        // bail out</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.543.1">        return state</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.544.1">      }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.545.1">      return { ...state, text: action.text };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.546.1">    default:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.547.1">      throw new Error('unknown action type');</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.548.1">  }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.549.1">};</span></p>
			<p><span class="koboSpan" id="kobo.550.1">Notice that returning </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">state</span></strong><span class="koboSpan" id="kobo.552.1"> itself is important. </span><span class="koboSpan" id="kobo.552.2">If you return </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">{ ...state, text: action.text || state.text }</span></strong><span class="koboSpan" id="kobo.554.1"> instead, it won't bail</span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.555.1"> out because it's creating a new object.</span></p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor026"/><span class="koboSpan" id="kobo.556.1">Primitive value</span></h2>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">useReducer</span></strong><span class="koboSpan" id="kobo.558.1"> works for non-object values, which are primitive values such as numbers and strings. </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">useReducer</span></strong><span class="koboSpan" id="kobo.560.1"> with primitive values</span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.561.1"> is still useful as we can define complex reducer logic outside it.</span></p>
			<p><span class="koboSpan" id="kobo.562.1">Here is a reducer example with a single number:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.563.1">const reducer = (count, delta) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.564.1">  if (delta &lt; 0) {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.565.1">    throw new Error('delta cannot be negative');</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.566.1">  }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.567.1">  if (delta &gt; 10) {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.568.1">    // too big, just ignore</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.569.1">    return count</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.570.1">  }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.571.1">  if (count &lt; 100) {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.572.1">    // add bonus</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.573.1">    return count + delta + 10</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.574.1">  }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.575.1">  return count + delta</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.576.1">}</span></p>
			<p><span class="koboSpan" id="kobo.577.1">Notice that the action (= </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">delta</span></strong><span class="koboSpan" id="kobo.579.1">) doesn't have to have an object either. </span><span class="koboSpan" id="kobo.579.2">In this reducer example, the state value is a number—a primitive value—but the logic is a little more complex, with more conditions</span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.580.1"> than just adding numbers.</span></p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor027"/><span class="koboSpan" id="kobo.581.1">Lazy initialization (init)</span></h2>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">useReducer</span></strong><span class="koboSpan" id="kobo.583.1"> requires two parameters. </span><span class="koboSpan" id="kobo.583.2">The first is a reducer function and the second is an initial state. </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">useReducer</span></strong><span class="koboSpan" id="kobo.585.1"> accepts</span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.586.1"> an optional third parameter, which is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">init</span></strong><span class="koboSpan" id="kobo.588.1">, for lazy initialization.</span></p>
			<p><span class="koboSpan" id="kobo.589.1">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">useReducer</span></strong><span class="koboSpan" id="kobo.591.1"> can be used like this:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.592.1">const init = (count) =&gt; ({ count, text: 'hi' });</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.593.1">const reducer = (state, action) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.594.1">  switch (action.type) {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.595.1">    case 'INCREMENT':</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.596.1">      return { ...state, count: state.count + 1 };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.597.1">    case 'SET_TEXT':</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.598.1">      return { ...state, text: action.text };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.599.1">    default:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.600.1">      throw new Error('unknown action type');</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.601.1">  }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.602.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.603.1">const Component = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.604.1">  const [state, dispatch] = useReducer(reducer, 0, init);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.605.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.606.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.607.1">      {state.count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.608.1">      &lt;button</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.609.1">        onClick={() =&gt; dispatch({ type: 'INCREMENT' })}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.610.1">      &gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.611.1">        Increment count</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.612.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.613.1">      &lt;input</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.614.1">        value={state.text}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.615.1">        onChange={(e) =&gt; dispatch({ </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.616.1">          type: 'SET_TEXT', </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.617.1">          text: e.target.value,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.618.1">        })}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.619.1">      /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.620.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.621.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.622.1">};</span></p>
			<p><span class="koboSpan" id="kobo.623.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">init</span></strong><span class="koboSpan" id="kobo.625.1"> function is invoked just once on </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">mount</span></strong><span class="koboSpan" id="kobo.627.1">, so it can include heavy computation. </span><span class="koboSpan" id="kobo.627.2">Unlike </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">useState</span></strong><span class="koboSpan" id="kobo.629.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">init</span></strong><span class="koboSpan" id="kobo.631.1"> function takes a second argument—</span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">initialArg</span></strong><span class="koboSpan" id="kobo.633.1">—in </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">useReducer</span></strong><span class="koboSpan" id="kobo.635.1">, which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">0</span></strong><span class="koboSpan" id="kobo.637.1"> in the </span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.638.1">previous example.</span></p>
			<p><span class="koboSpan" id="kobo.639.1">Now we have looked at </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">useState</span></strong><span class="koboSpan" id="kobo.641.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">useReducer</span></strong><span class="koboSpan" id="kobo.643.1"> separately, it's time to compare them.</span></p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor028"/><span class="koboSpan" id="kobo.644.1">Exploring the similarities and differences between useState and useReducer</span></h1>
			<p><span class="koboSpan" id="kobo.645.1">In this </span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.646.1">section, we demonstrate some similarities and </span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.647.1">differences between </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">useState</span></strong><span class="koboSpan" id="kobo.649.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">useReducer</span></strong><span class="koboSpan" id="kobo.651.1">.</span></p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.652.1">Implementing useState with useReducer</span></h2>
			<p><span class="koboSpan" id="kobo.653.1">Implementing </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">useState</span></strong><span class="koboSpan" id="kobo.655.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">useReducer</span></strong><span class="koboSpan" id="kobo.657.1"> instead is 100% possible. </span><span class="koboSpan" id="kobo.657.2">Actually, it's known</span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.658.1"> that </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">useState</span></strong><span class="koboSpan" id="kobo.660.1"> is implemented</span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.661.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">useReducer</span></strong><span class="koboSpan" id="kobo.663.1"> inside React. </span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.664.1">Important Note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.665.1">This may not hold in the future as </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">useState</span></strong><span class="koboSpan" id="kobo.667.1"> could be implemented more efficiently.</span></p>
			<p><span class="koboSpan" id="kobo.668.1">The following example shows how to implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">useState</span></strong><span class="koboSpan" id="kobo.670.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">useReducer</span></strong><span class="koboSpan" id="kobo.672.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.673.1">const useState = (initialState) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.674.1">  const [state, dispatch] = useReducer(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.675.1">    (prev, action) =&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.676.1">      typeof action === 'function' ? </span><span class="koboSpan" id="kobo.676.2">action(prev) : action,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.677.1">    initialState</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.678.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.679.1">  return [state, dispatch];</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.680.1">};</span></p>
			<p><span class="koboSpan" id="kobo.681.1">This can then be simplified and improved upon, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.682.1">const reducer = (prev, action) =&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.683.1">  typeof action === 'function' ? </span><span class="koboSpan" id="kobo.683.2">action(prev): prev;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.684.1">const useState = (initialState) =&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.685.1">  useReducer(reducer, initialState);</span></p>
			<p><span class="koboSpan" id="kobo.686.1">Here, we proved that what you can do with </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">useState</span></strong><span class="koboSpan" id="kobo.688.1"> can be done with </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">useReducer</span></strong><span class="koboSpan" id="kobo.690.1">. </span><span class="koboSpan" id="kobo.690.2">So, wherever you have </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">useState</span></strong><span class="koboSpan" id="kobo.692.1">, you can just replace it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">useReducer</span></strong><span class="koboSpan" id="kobo.694.1">.</span></p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.695.1">Implementing useReducer with useState</span></h2>
			<p><span class="koboSpan" id="kobo.696.1">Now, let's explore if the opposite</span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.697.1"> is possible—can we replace</span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.698.1"> all instances of </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">useReducer</span></strong><span class="koboSpan" id="kobo.700.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">useState</span></strong><span class="koboSpan" id="kobo.702.1">? </span><span class="koboSpan" id="kobo.702.2">Surprisingly, it's almost true. </span><span class="koboSpan" id="kobo.702.3">"Almost" means there are subtle differences. </span><span class="koboSpan" id="kobo.702.4">But in general, people expect </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">useReducer</span></strong><span class="koboSpan" id="kobo.704.1"> to be more flexible than </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">useState</span></strong><span class="koboSpan" id="kobo.706.1">, so let's see if </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">useState</span></strong><span class="koboSpan" id="kobo.708.1"> is flexible enough in reality.</span></p>
			<p><span class="koboSpan" id="kobo.709.1">The following example illustrates how to implement the basic capability of </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">useReducer</span></strong><span class="koboSpan" id="kobo.711.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">useState</span></strong><span class="koboSpan" id="kobo.713.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.714.1">const useReducer = (reducer, initialState) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.715.1">  const [state, setState] = useState(initialState);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.716.1">  const dispatch = (action) =&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.717.1">    setState(prev =&gt; reducer(prev, action));</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.718.1">  return [state, dispatch];</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.719.1">};</span></p>
			<p><span class="koboSpan" id="kobo.720.1">In addition to this basic capability, we can implement lazy initialization too. </span><span class="koboSpan" id="kobo.720.2">Let's also use </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">useCallback</span></strong><span class="koboSpan" id="kobo.722.1"> to have a stable dispatch function, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.723.1">const useReducer = (reducer, initialArg, init) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.724.1">  const [state, setState] = useState(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.725.1">    init ? </span><span class="koboSpan" id="kobo.725.2">() =&gt; init(initialArg) : initialArg,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.726.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.727.1">  const dispatch = useCallback(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.728.1">    (action) =&gt; setState(prev =&gt; reducer(prev, action)),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.729.1">    [reducer]</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.730.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.731.1">  return [state, dispatch];</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.732.1">};</span></p>
			<p><span class="koboSpan" id="kobo.733.1">This implementation works almost perfectly as a replacement for </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">useReducer</span></strong><span class="koboSpan" id="kobo.735.1">. </span><span class="koboSpan" id="kobo.735.2">Your use case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">useReducer</span></strong><span class="koboSpan" id="kobo.737.1"> is very likely handled by this implementation.</span></p>
			<p><span class="koboSpan" id="kobo.738.1">However, we have two</span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.739.1"> subtle differences. </span><span class="koboSpan" id="kobo.739.2">As they</span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.740.1"> are subtle, we don't usually consider them in too much detail. </span><span class="koboSpan" id="kobo.740.2">Let's learn about them in the following two subsections to get a deeper understanding.</span></p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor031"/><span class="koboSpan" id="kobo.741.1">Using the init function</span></h2>
			<p><span class="koboSpan" id="kobo.742.1">One difference</span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.743.1"> is that we can define </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">reducer</span></strong><span class="koboSpan" id="kobo.745.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">init</span></strong><span class="koboSpan" id="kobo.747.1"> outside hooks or components. </span><span class="koboSpan" id="kobo.747.2">This is only possible with </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">useReducer</span></strong><span class="koboSpan" id="kobo.749.1"> and not with </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">useState</span></strong><span class="koboSpan" id="kobo.751.1">.</span></p>
			<p><span class="koboSpan" id="kobo.752.1">Here is a simple count example:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.753.1">const init = (count) =&gt; ({ count });</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.754.1">const reducer = (prev, delta) =&gt; prev + delta;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.755.1">const ComponentWithUseReducer = ({ initialCount }) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.756.1">  const [state, dispatch] = useReducer(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.757.1">    reducer,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.758.1">    initialCount,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.759.1">    init</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.760.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.761.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.762.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.763.1">      {state}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.764.1">      &lt;button onClick={() =&gt; dispatch(1)}&gt;+1&lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.765.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.766.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.767.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.768.1">const ComponentWithUseState = ({ initialCount }) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.769.1">  const [state, setState] = useState(() =&gt; </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.770.1">    init(initialCount));</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.771.1">  const dispatch = (delta) =&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.772.1">    setState((prev) =&gt; reducer(prev, delta));</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.773.1">  return [state, dispatch];</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.774.1">};</span></p>
			<p><span class="koboSpan" id="kobo.775.1">As you can see in </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">ComponentWithUseState</span></strong><span class="koboSpan" id="kobo.777.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">useState</span></strong><span class="koboSpan" id="kobo.779.1"> requires two inline functions, whereas </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">ComponentWithUseReducer</span></strong><span class="koboSpan" id="kobo.781.1"> has no inline functions. </span><span class="koboSpan" id="kobo.781.2">This is a trivial thing, but some interpreters</span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.782.1"> or compilers can optimize better without inline functions.</span></p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor032"/><span class="koboSpan" id="kobo.783.1">Using inline reducers</span></h2>
			<p><span class="koboSpan" id="kobo.784.1">The inline reducer function</span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.785.1"> can depend on outside variables. </span><span class="koboSpan" id="kobo.785.2">This is only possible with </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">useReducer</span></strong><span class="koboSpan" id="kobo.787.1"> and not with </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">useState</span></strong><span class="koboSpan" id="kobo.789.1">. </span><span class="koboSpan" id="kobo.789.2">This is a special capability of </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">useReducer</span></strong><span class="koboSpan" id="kobo.791.1">.</span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.792.1">Important Note </span></p>
			<p class="callout"><span class="koboSpan" id="kobo.793.1">This capability is not usually used and not recommended unless it's really necessary.</span></p>
			<p><span class="koboSpan" id="kobo.794.1">Hence, the following code is technically possible:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.795.1">const useScore = (bonus) =&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.796.1">  useReducer((prev, delta) =&gt; prev + delta + bonus, 0);</span></p>
			<p><span class="koboSpan" id="kobo.797.1">This works correctly even when </span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">bonus</span></strong><span class="koboSpan" id="kobo.799.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">delta</span></strong><span class="koboSpan" id="kobo.801.1"> are both updated. </span></p>
			<p><span class="koboSpan" id="kobo.802.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">useState</span></strong><span class="koboSpan" id="kobo.804.1"> emulation, this doesn't work correctly. </span><span class="koboSpan" id="kobo.804.2">It would use an old </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">bonus</span></strong><span class="koboSpan" id="kobo.806.1"> value in a previous render. </span><span class="koboSpan" id="kobo.806.2">This is because </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">useReducer</span></strong><span class="koboSpan" id="kobo.808.1"> invokes the reducer function in the render phase.</span></p>
			<p><span class="koboSpan" id="kobo.809.1">As noted, this is not typically used, so overall, if we ignore this special behavior, we can say </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">useReducer</span></strong><span class="koboSpan" id="kobo.811.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">useState</span></strong><span class="koboSpan" id="kobo.813.1"> are basically the same and interchangeable. </span><span class="koboSpan" id="kobo.813.2">You could just pick </span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.814.1">either one, based on your preference or your programming style.</span></p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor033"/><span class="koboSpan" id="kobo.815.1">Summary</span></h1>
			<p><span class="koboSpan" id="kobo.816.1">In this chapter, we discussed state management and defined micro state management, in which React hooks play an important role. </span><span class="koboSpan" id="kobo.816.2">To prepare for the following chapters, we learned about some React hooks that are used for state management solutions, including </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">useState</span></strong><span class="koboSpan" id="kobo.818.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.819.1">useReducer</span></strong><span class="koboSpan" id="kobo.820.1">, while also looking at their similarities and differences.</span></p>
			<p><span class="koboSpan" id="kobo.821.1">In the next chapter, we learn more about a global state. </span><span class="koboSpan" id="kobo.821.2">For this purpose, we will discuss a local state and when a local state works, and we will then look at when a global state is required.</span></p>
		</div>
	</body></html>