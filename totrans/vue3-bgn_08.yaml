- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing Your App with Vitest and Cypress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No matter how much experience you have under your belt in writing code, testing
    your app is a must to produce a high-quality code base. There are different testing
    tools out there, but in this book, we are going to learn Vitest for unit tests
    and Cypress for end-to-end testing.
  prefs: []
  type: TYPE_NORMAL
- en: Testing is a large topic, and in this chapter, we will learn the basics of both
    testing methodologies, leaving out advanced techniques for future reading and
    training that you will encounter in the course of your career.
  prefs: []
  type: TYPE_NORMAL
- en: First, we are going to learn the different testing methods and how they each
    contribute to producing quality software. We will then introduce unit tests by
    learning how to use Vitest and Vue Test Utils to test individual components in
    our application. Then, we will move our focus away from the individual components
    and concentrate on our application, by introducing **E2E** (**end-to-end**) tests
    with Cypress. We will then write an E2E test to cover a small user journey before
    moving on to the last section, which will be used to introduce advanced topics
    such as mocking and spies.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter consists of the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing pyramids
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing with Vitest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E2E tests with Cypress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing advanced testing techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have gained a basic understanding of testing
    in general. You will be able to set up both Vitest and Cypress on your future
    projects and know how to write basic tests in both unit tests and E2E tests. Finally,
    you will also be exposed to future testing techniques that you may encounter in
    your career.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the branch is called `CH08`. To pull this branch, run the
    following command or use your GUI of choice to support you in this operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The branch includes all the files updated from the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners).
  prefs: []
  type: TYPE_NORMAL
- en: The testing pyramids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clean code, coding standards, and peer reviews are essential parts of a good
    application, but they are not the only ones. In fact, a good and reliable application
    is not only the source of good development but also the result of a good level
    of testing coverage available within the application.
  prefs: []
  type: TYPE_NORMAL
- en: Testing covers a very large spectrum. Some companies do very minimal tests,
    letting their end users be the actual testers by shipping them new code to look
    for bugs and errors, while others invest time and budgets in developing comprehensive
    sets of tests and adding them to their processes.
  prefs: []
  type: TYPE_NORMAL
- en: Even if companies invest different amounts of time in testing, all developers
    can at least agree that increased testing can, on average, result in fewer bugs
    being shipped to the user and a more flexible application.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple levels of testing can be developed for an application, and they are
    divided into layers that together form a pyramid (hence the name *testing pyramid*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: The testing pyramid](img/B21130_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: The testing pyramid'
  prefs: []
  type: TYPE_NORMAL
- en: The bottom of the pyramid is where **unit tests** are found. Unit tests look
    at a single unit, which is usually a component or a helper file. These tests are
    very fast to run and, therefore, are usually produced in large quantities. Then,
    we have **integration tests**, which are where different parts of the system are
    connected to ensure that all parts work together. An integration test could test
    that the method successfully adds an entry to a database, by integrating the code
    and the database together, hence the name *integration test*. These tests take
    longer to run and require a bigger architecture, so they are expected to be used
    less than unit tests. Moving up in the pyramid, we find E2E tests. E2E testing
    encapsulates both manual tests, that are run by a quality assurance team, and
    automatic E2E tests that makes use of tools such as Cypress or Playwright. which
    are run manually by a quality assurance team, and automatic E2E tests are run
    by a tool such as Cypress or Playwright. An individual E2E test spans a full user
    journey and, due to its large scope, you will just require a few tests needed
    to cover your full application.
  prefs: []
  type: TYPE_NORMAL
- en: For the scope of this book, we are going to cover unit tests and E2E tests.
    Integration tests will not be covered because their usefulness is gradually decreasing,
    due to the advancement of E2E tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference in the test types is not only defined by the different bugs
    that they can catch but also by their “development cost” and “speed to run.” Let’s
    see how different tests perform in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: A comparison between the different test types](img/B21130_08_02_BW.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: A comparison between the different test types'
  prefs: []
  type: TYPE_NORMAL
- en: If an application only did E2E tests, it would catch bugs too late in development,
    slowing down the development process. Conversely, if an application only did unit
    tests, it would not pick up bugs and inconsistencies produced by different parts
    of the system working together, due to the fact that Unit Tests focus on a single
    unit and therefore cannot ensure that different part of the application work as
    expected.
  prefs: []
  type: TYPE_NORMAL
- en: Tests also exhibit differences in costs. A test cost is measured in the amount
    of time and effort that it takes to write the test, as well as its “speed to run,”
    which refers to the amount of time a single test takes.
  prefs: []
  type: TYPE_NORMAL
- en: In an ideal world, all aspects of tests would be performed as part of your development
    process. But this is far from the truth. I have worked on many projects in my
    career, and I can count just a handful of businesses that really took ownership
    of their tests, implementing the whole pyramid. Unfortunately, for many businesses,
    tests are seen as an overhead (i.e, a cost that does not directly produce revenue).
  prefs: []
  type: TYPE_NORMAL
- en: Before moving forward to the next chapter and starting to develop our first
    test, it is important to try and define what makes tests worthwhile. We have already
    discussed the ability of tests to catch bugs early before they reach your clients.
    But this is not the only benefit; in fact, when asked by upper management why
    they should invest in tests, I usually prove my point by introducing the topic
    of “Increased flexibility and the reduced risk of change.”
  prefs: []
  type: TYPE_NORMAL
- en: Increased flexibility and the reduced risk of change
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working on a big migration, the first task is ensuring that all E2E tests
    are set. Likewise, when developing a redesign, unit tests on the components are
    a must-have. A well-tested application does not only experience a lower level
    of bugs reaching the client but is also more flexible with updates. Knowing that
    you can easily test the major features of your application and quickly be informed
    if something has regressed or broken is a key aspect of agile development, setting
    your application for success and making it less risky to make changes to the code
    base.
  prefs: []
  type: TYPE_NORMAL
- en: I hope this is enough to convince you to understand the importance of testing.
    It is now time to move forward and learn how to write tests within our application.
    Tests can be quite tricky to implement on existing applications, and they also
    have a higher initial learning curve before you get started, but the payback of
    this investment is invaluable for your career and your code quality.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how Vitest can be set up and implemented to test some components of
    our Companion App.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing with Vitest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vitest is one of the main unit test frameworks in the JavaScript ecosystem,
    and it has a syntax very similar to Jest. Most of the knowledge you will gain
    in this chapter is transferrable to other testing frameworks, as they all follow
    a very similar structure.
  prefs: []
  type: TYPE_NORMAL
- en: Vitest is already set up in our application, but we will cover the basic steps
    required to add it to your new or existing applications.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Vitest in your application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step required is the package for **Vitest** and **Vue Test Utils**,
    which are, respectively, the test runner and the Vue components testing framework.
    We can achieve this by opening the terminal and running the following command
    in the root folder of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the packages are installed, we just need to add a script to the `package.json`
    file so that we can simply run it in the future:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The command string used is arbitrary, but it is common practice to name it `"test:unit"`.
    This will allow us later to also define `"test:e2e"` and clearly define the two
    different test procedures.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run Vitest, we can just run the newly created script in our terminal with
    `npm run test:unit.` The result should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3: A terminal screenshot of the test results](img/B21130_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: A terminal screenshot of the test results'
  prefs: []
  type: TYPE_NORMAL
- en: The console terminal should show an error message, `theButton.vue`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our first unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that everything is set, it is time to start and write our first test using
    our base button component.
  prefs: []
  type: TYPE_NORMAL
- en: A unit test has a very important goal – test a single unit of your application.
    In a framework such as Vue.js, a unit is defined as a component, a composable,
    or a store file.
  prefs: []
  type: TYPE_NORMAL
- en: When testing a unit of logic, you should focus on its functionality and not
    its static content, such as text.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a text-focused test that just compare text values, such as headings
    and buttons, will not only provide any benefits to our application, but will also
    be hard to maintain , due to its flakiness (produced by the fact that the tests
    will have to change every time we change the copy of our component).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before creating our test file, let’s open `TheButton.vue` and see what part
    of this component could be tested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Our component is a standard button and, as such, includes all the basic functionality
    that we would expect from one. A few test scenarios for this component could be
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking that the component renders successfully, ensuring that there are no
    mistakes in the component structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking that the default styles load by default
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking that the theme props work to change the theme
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three initial tests are great for us to get started on this topic. As
    I said before, tests can have quite a steep learning curve, so it is good to start
    small and slowly build on that knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: It is now time to create our test files. Test files are named in the nameOfFileTested.spec.js
    format, so in our case, it would be TheButton.spec.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a test file in any folder we want, but it is good practice to
    decide a standard for the project and consistently follow it. In our case, we
    are going to create this file in the `__tests__` folder. The full path of the
    file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we start discussing the test structure, we need to import a few modules
    that will allow us to create the test. We are going to import the `expect`, `describe`,
    and `it``mount` method from `@vue/test-utils`, and finally, the component itself.
    The `import` statement at the top of our test should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that our imports are set, it is time to start to learn how to structure
    a test. The structure of tests follows a callback approach, where each method
    has a callback to another method, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Even if this approach, also referred to as callback hell, is usually a sign
    of bad practice in JS, it is the best way to provide structure for your tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write a well-structured unit test, we can use the Given, When, and Then
    syntax that answers the following three questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What are we testing (Given)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the scenario (When)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the expected outcome (Then)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can then use `Given`, `When`, and `Then` to create our own test cases by
    creating a simple sentence. So, in the case of our button, the sentence could
    be as follows: “Given `TheButton.vue`, when *it is mounted*, then it *should*
    *render properly*.”'
  prefs: []
  type: TYPE_NORMAL
- en: With the preceding sentence. we can now go and write our first unit test.
  prefs: []
  type: TYPE_NORMAL
- en: Write your test in words first
  prefs: []
  type: TYPE_NORMAL
- en: It is beneficial to break down your tests by writing them in sentences first.
    Being able to write down all the tests by just defining a single sentence for
    each test will help you define better tests and ensure that you cover your components
    fully. Reading and comparing a couple of sentences is simpler than doing the same
    after the tests are written.
  prefs: []
  type: TYPE_NORMAL
- en: 'To structure our tests, we will make use of the `describe` and `it` methods
    provided by Vitest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'A test uses the `describe` method to define the aforementioned Given and When
    syntax, and the `it` method to define the actual test (`Then`). A test can have
    multiple nested descriptions. Test names are very important because they are used
    by a testing framework in error messages, triggered when a test fails. Having
    a very well-structured name will help you save time if something breaks and your
    test fails. Let’s try to run our empty test for the first time and see what the
    output is. To run our tests, we need to open the terminal, access the `project`
    folder, and run the following **npm** command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4: The terminal output of Vitest](img/B21130_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: The terminal output of Vitest'
  prefs: []
  type: TYPE_NORMAL
- en: The test results follow the same nested structure that we defined in our test.
    The words used within the `describe` and `it` methods form a readable word. If
    an error is triggered locally or in any deployment environment, the log will display
    the file name, followed by the different words we used to declare our test. In
    our case it would be *TheButton.vue when mounted* *renders properly.*
  prefs: []
  type: TYPE_NORMAL
- en: Vitest is fast – very fast
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we mentioned that unit tests are fast, but we have
    not mentioned that among all unit test frameworks, Vitest is the fastest of all
    unit test frameworks. Its speed is to be attributed to the Vite server on which
    Vitest is built.
  prefs: []
  type: TYPE_NORMAL
- en: Our first test has not tested anything yet, as it has an empty body. Let’s go
    back and see how we can test our component. To complete this task, we will use
    the `mount` method offered by Vue Test Utils and the `expect` method, used to
    tell the Unit Test engine what we want to test.
  prefs: []
  type: TYPE_NORMAL
- en: The `mount` method is used to initialize a component by rendering it within
    the test framework, while `expect` is used to define our test cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In every test, we start by setting out our component and any state that this
    may require. In our case, we just need to mount it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will assert that our component rendered successfully by checking whether
    it includes a `button` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `expect` method accepts the value being tested as its argument and is then
    chained to the test performed on the given value. Vitest comes with a huge list
    of assertions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we wanted to create a test that checks if two number are equals,
    we would do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The full test file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: So, to recap, we learned that tests follow a very structured approach. They
    require us to define what we are testing, and the scenario and assertion that
    we are considering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add another test that would create the following test sentence: “Given
    `TheButton.vue`, when *it is mounted*, then it *defaults to the* *light theme*.”'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the first two parts of the sentence, `Given` and `When`
    are the same, so this means that we can reuse the existing code blocks and just
    add another test.
  prefs: []
  type: TYPE_NORMAL
- en: To check whether the correct theme is applied, we will check whether the CSS
    class `light` has been applied to the component.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As shown by the highlighted text in the preceding code block, adding extra tests
    that follow the same setup is quite simple. To complete the new test, we used
    `mount` again to initialize a version of our component. We then used `wrapper.classes()`
    to extract all the classes of the component and asserted this to contain `light`
    using `expect().toContain().`
  prefs: []
  type: TYPE_NORMAL
- en: Due to the fact that both of the tests have the same When, we were able to reuse
    the describe method `describe('when mounted'..)`. Doing so will help us break
    up tests logically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tests are automatically updated, so when the file is saved, our terminal
    should output the new result with two passing tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5: The Vitest test results showing two passing tests](img/B21130_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: The Vitest test results showing two passing tests'
  prefs: []
  type: TYPE_NORMAL
- en: Your turn
  prefs: []
  type: TYPE_NORMAL
- en: Write the last unit test to complete the testing of `TheButton.vue`. The last
    test should test that the component renders the dark theme when the correct properties
    are passed. Research Vue Test Utils and the Vitest documentation to learn how
    to define properties when mounting a component. Next chapter branch will include
    the test for you, so that you can check if your test was written correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests are a big topic, and this was just a very simple introduction to
    give you some necessary initial information. Each project will create tests that
    are slightly different, either because of the project structure, the breakdown
    of components, or even the naming convention used. For this reason, the best way
    to truly learn how to write tests is to practice.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move forward, I want to share one more tip to ensure you test your
    code correctly. In fact, it is common when writing unit tests to make them too
    dependent on the inside of a component. A unit test is expected to test what a
    single unit of code would **output** when given a specific **input**. What this
    means is that you should be able to test a component without the need to open
    the file, just by knowing the properties it accepts and the UI/events that it
    emits. When writing your unit tests, always focus on the input and output, and
    leave the implementation details out of your test.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we introduced unit tests and discussed how to use Vitest to
    test our component. We learned the syntax required to write a unit test and introduced
    Vue Test Utils to help us work with our Vue component. Then, we covered the importance
    of the test name and how this follows the Given, When, and Then methodology.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will ascend the pyramid and learn to write E2E tests.
    We will be able to reuse some of the knowledge we learned in this section and
    continue to learn how to make our code more reliable.
  prefs: []
  type: TYPE_NORMAL
- en: E2E tests with Cypress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is time to move our testing focus from a micro level, offered by unit tests,
    to a macro level, provided by E2E tests. If unit tests focus on a single state
    of a single component, E2E will help us test a complete user journey.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned previously, we will be able to use some of the knowledge that
    we learned in the previous section, since E2E tests follow a similar structure
    to the ones we learned about in Vitest.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s break down this section into three different parts. First, we are going
    to learn how to install **Cypress** in your application. Then, we will learn the
    basic structure of an E2E test file and its placement within a project. Lastly,
    we will end the section by writing an E2E test for our application.
  prefs: []
  type: TYPE_NORMAL
- en: The most used E2E tools within the JS industry are Cypress and Playwright. Cypress
    has been around for quite a few years, and it currently holds a very large section
    of the market. Playwright is a little newer, but it is gaining a lot of market
    share due to its integration with IDEs and extensive browser emulation.
  prefs: []
  type: TYPE_NORMAL
- en: Just like unit tests, the syntax of the different players on the market is very
    similar, so most of the features and syntax that you learn in one could be used
    in another one if you later decide to switch.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by installing Cypress into your project.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Cypress into your project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Today’s JS ecosystem offers us tools with amazing user experiences that offer
    very simple installation processes, and Cypress is one of those.
  prefs: []
  type: TYPE_NORMAL
- en: Our Companion App already includes a set of tests, and they are installed by
    the Vue project initialization that we introduced in [*Chapter 3*](B21130_03.xhtml#_idTextAnchor039).
    However, it is helpful to learn how to add Cypress to your new or existing project.
    Due to the fact that Cypress is already part of the Companion App, you would have
    to follow the following steps in a new folder.
  prefs: []
  type: TYPE_NORMAL
- en: The official documentation provided at [cypress.io](http://cypress.io) offers
    two installation methods, a **direct download** and an **npm installation**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to follow the installation using the `npm` package manager. To
    initialize this, access the root folder of your project in your preferred terminal
    and type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to run Cypress. This can be achieved with the following `npx`
    command (note that the command is `npx` and not `npm`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: After a few seconds, you should be presented with a welcome screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6: Cypress’s opening dashboard](img/B21130_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: Cypress’s opening dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: Cypress can be set up for E2E and component testing. The wizard in *Figure 8**.6*
    marks our test as **Not Configured**. Let’s begin the configuration of the E2E
    testing by clicking on the left block. Doing so will generate a set of example
    files that we will need to run our first test.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7: The Cypress wizard test file creation](img/B21130_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: The Cypress wizard test file creation'
  prefs: []
  type: TYPE_NORMAL
- en: The wizard has created four files. The first is the main configuration file
    that is hosted in the root of our project under the name `cypress.config.js`,
    which includes all the settings related to Cypress. The second and third are example
    files for support that are used to create reusable commands; commands are for
    more advanced users and are not covered in this book. The last file is a fixture
    example JSON, accessible at `cypress/fixtures/example.json`. Fixture files are
    used to save reusable information, such as text input or an API response.
  prefs: []
  type: TYPE_NORMAL
- en: If we continue our journey within the installation wizard, we will be presented
    with the browser selector screen. This screen will be displayed every time you
    run Cypress and allows you to select which browser you want to use.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8: Cypress’s Choose a browser screen](img/B21130_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: Cypress’s Choose a browser screen'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s open the test runner by clicking on Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9: The first instance of Cypress’s chrome test runner](img/B21130_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.9: The first instance of Cypress’s chrome test runner'
  prefs: []
  type: TYPE_NORMAL
- en: Since we chose Chrome as our test runner, we will start in a new Chrome window.
    This runner will offer us the ability to create example tests or generate a test
    template.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to stop at this point in the installation wizard; it is time to
    return to our Companion App and continue our journey there to learn more about
    E2E tests and Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and reading the example tests
  prefs: []
  type: TYPE_NORMAL
- en: The tests provided by the “scaffold example specs” are very extensive and well-written.
    These sample tests provide you with an amazing insight into what E2E tests can
    achieve. Spend a few minutes installing and reading through these tests before
    moving on to the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the E2E tests’ file format and file location
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we learned how to install Cypress into our projects.
    In this section, we will learn the file location and format of these E2E test
    files before moving on to create our first test. Remember that we are now working
    within our Companion App, so you should go and open it with your IDE of choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The location of our E2E tests is defined within the Cypress configuration file.
    As we learned from the previous section, this is located at the root of our application
    and is called `cypress.config.js`. This file includes a couple of settings, one
    of which is called `specPattern`. This configuration setting informs Cypress where
    to find the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This pattern expects the E2E files to be located within the `cypress/e2e` folder
    and for the filename to end with a combination of `cy,spec` and `js, jsx, ts`
    `and tsx`.
  prefs: []
  type: TYPE_NORMAL
- en: So, a test file could be called `mytest.spec.ts` or `mytest.cy.js`, and if it
    is within the `cypress/e2e` folder, the Cypress test runner will be able to see
    and utilize it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go and create our first test, called `homepage`. Because I want to distinguish
    between unit tests and E2E tests, I will end this file with `cy.js` (the unit
    tests end in `spec.js`). The full location of the new file would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now that the file has been created, it is time to learn how to structure these
    files. As I previously mentioned, there are some similarities between E2E and
    unit tests’ structures. In fact, both tests follow the same syntax, with a structure
    based on callbacks and methods called `describe` and `it`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Test scaffold should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the code structure is noticeable, like the one offered by Vitest,
    with the only difference being that, in this case, we do not need to import the
    `describe` and `it` methods, as they are automatically imported for us.
  prefs: []
  type: TYPE_NORMAL
- en: Another small difference is the name of the test. When we defined a name in
    a unit test, it was a very important part of the test, with the well-defined `Given`,
    `When`, and `Then` methodology. In E2E tests, names are a little less important,
    mainly because these tests can have a large scope, such as a full check of the
    home page, and providing a single sentence to define what we are testing is not
    always possible.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move forward, we are going to try and run E2E tests in our application
    and learn the steps required to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we used `npx cypress open` to start Cypress. This
    can still be used, but our `package.json` has a couple of scripts ready for us
    to use that come with extra configurations, simplifying our development experience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The application offers two scripts, `"test:e2e"` and `"test:e2e:dev"`. The first
    is used to run E2E on a preview build, while the second is used to run the test
    on a development build with **hot reload**. This will allow us to make modifications
    to our application while the E2E test runner is ready to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to run the development E2E test environment by running the following command
    in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The result of this command should be the Cypress dashboard that we saw before.
    Just like before, you should click on **E2E tests** and choose **Chrome** as the
    browser to run our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result should be a Chrome browser, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10: The Cypress test dashboard in Chrome](img/B21130_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.10: The Cypress test dashboard in Chrome'
  prefs: []
  type: TYPE_NORMAL
- en: Browse around
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing the chapter, you should spend a couple of minutes to familiarize
    yourself with the test runner. Knowing what it has to offer and how it works will
    be very beneficial for what you learn in the future and your usage of E2E tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run our test, click on the test name, `homepage.cy.js`. This will load the
    Cypress test runner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11: The Cypress test runner](img/B21130_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.11: The Cypress test runner'
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the test runner is not very useful, as the only test we have is empty.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’s time to move on to the next section, where we will write our first
    test in Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first E2E test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: E2E tests are usually referred to as a **journey**. The name is derived from
    the fact that it encapsulates a specific user’s journey. These could be the steps
    required to complete a **contact us** form, or the ones required to buy a product.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the size of our current application, the journey will be quite small,
    but it can still be useful to ensure we build a stable application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our test will complete the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying the app title
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring that posts are loaded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking whether a post that has no comments, show the correct empty message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking whether a post that has comments displays them correctly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'E2E tests are written sequentially, in the same way that you would complete
    the same journey manually. So, we are going to start our test by accessing the
    site on the main page. This is done by using the `cy.visit` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When using the `visit` command, you can pass any relative URL. In our scenario,
    we will just pass a forward slash, as we are going to visit the home page.
  prefs: []
  type: TYPE_NORMAL
- en: A base URL preset
  prefs: []
  type: TYPE_NORMAL
- en: Note that we were able to visit the home page by using a single forward slash
    because we have set a `baseUrl` preset within `cypress.config.js`. Without the
    `baseUrl` setting, you would have had to insert the full URL within the `cy.visit`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to check for the presence of the title `Companion App`.
    This is achieved using two new methods, `get` and `should`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `get` method is just like `document.querySelector` and allows you to select
    a given element on a page. The `should` method allows you to set an expectation
    – that is, what defines a test as a pass or a fail. The `should` method accepts
    a parameter that is the logic by which we test our selector. These parameters
    are called **chainers** and have hundreds of different possibilities. The best
    way to learn all the available **chainers** is to either access the documentation
    ([https://docs.cypress.io/guides/references/assertions](https://docs.cypress.io/guides/references/assertions))
    or use the IntelliSense IDE.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12: An IntelliSense pop-up of chainers](img/B21130_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.12: An IntelliSense pop-up of chainers'
  prefs: []
  type: TYPE_NORMAL
- en: A list of chainers is displayed automatically within your IDE while you write
    your test expectation.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you use the documentation or the IDE, as shown in *Figure 8**.12*, all
    that really matters is that you familiarize yourself with these different chainers
    and understand what you can and cannot use.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, we just passed a single argument when calling the
    `should` method, but it can also accept two arguments. The second argument is
    used to pass a value when the condition defined in the first argument requires
    one. For example, we could be comparing the number of elements on screen with
    a variable, comparing two strings, or ensuring that the value returned by the
    API matches a specific object. In our current test, we just check that `<H1>`
    exists, but we are not really checking whether it is the correct heading, so we
    could change our implementation to use two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When using `contain.text`, we compare the `innerText` string of the element
    we selected with an arbitrary value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step of our E2E test will be to ensure that the posts load successfully,
    by using the `get` method to fetch the element and the `have.length` chainer to
    ensure that the result value is what we expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When the application loads correctly, it will load five posts, and to check
    this in our test, we select all the elements that have a class of `SocialPost`
    and compare their lengths, using the `should('have.length',` `value)` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will need to test the comment component. We will achieve this by clicking
    the `SocialPost.vue` component, we would find out that the best way to find the
    button is to use a large selector, `.SocialPost .interactions button`. This selector
    is not an optimal solution, not only because it is very verbose, but also because
    it is too dependent on the structure of the component and, therefore, very fragile.
    To avoid using complex selection, we can add an E2E attribute. This is usually
    defined by adding a `data-cy` attribute to an element and using it for testing
    purposes (`cy` in the data stands for cypress).
  prefs: []
  type: TYPE_NORMAL
- en: Adding a data attribute to your code will make your test more robust, avoiding
    the creation of flaky tests associated with changes in CSS classes and HTML element
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before continuing with our test, let’s open `SocialPost.vue` and add the required
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`data-cy` is just a simple data attribute, but it is industry-standard and
    is used by many developers to provide a direct selector for E2E tests. We are
    now able to update our test to use the newly declared `showCommentButton` attributeto
    select our button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Since we have five posts on the page but just want to click on the first one,
    we will use a helper method called `first` that is used to retrieve just the first
    element returned by `get()`. Then, we end the chain by calling a `click` method
    to emulate a mouse click on the button. The result should be the comment component
    loaded.
  prefs: []
  type: TYPE_NORMAL
- en: If you check the browser window displaying our test runner, you should be able
    to see the `comment` component loaded in the first element.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13: A Cypress test showing the Companion App with the comments loaded](img/B21130_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.13: A Cypress test showing the Companion App with the comments loaded'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to use the knowledge we learned in the last section to test
    the correct rendering of posts with comments. As shown in *Figure 8**.13*, the
    first post has no comments. To better increase our coverage, we should also find
    a post with comments. A post with a comment is found in the last post (number
    5), so we can use that to ensure that the comments are correctly displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on what we have learned, we should be able to write a test that looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The code displays three commands. The first checks the content of the social
    post comment component. We are using the main class, `.SocialPostComments`, to
    select the component and the `contain.text` command. This command checks the `innerText`
    string of that selector and compares it with a string that is passed as an argument.
    In our case, we passed `There are no comments for this post!`. Then, we clicked
    the last post by replicating the command we previously used and replaced `first()`
    with `last()`. Lastly, we again replicated the command we recently used to check
    the content of the string, and we checked the opposite by adding the word `not`
    in front of the chainer. It is common when creating E2E tests to have commands
    that test something (e.g., a string or a number), and then a command that tests
    that that assertion does not happen again. Because of this recurring scenario,
    the E2E framework provides you the ability to add the word `not` in front of the
    chainer to check for the opposite. So, if this `should('contain.text', 'hello')`
    checks whether the element includes the word `hello`, then `should('not.contain.text',
    'hello')` checks for the opposite – that is, to make sure that the element selected
    does not contain the word `hello`.
  prefs: []
  type: TYPE_NORMAL
- en: This is the end of our E2E journey. In the next section, we are going to introduce
    advanced techniques that have not yet been covered in this chapter but may turn
    out to be very useful for your future testing experience.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing advanced testing techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this closing section, we will introduce a couple of extra topics that are
    part of testing but have not been covered in this chapter. As I mentioned at the
    start of this chapter, testing is a very large subject, and this was just a quick
    introduction to ensure that you will know how to get started and create simple
    tests. However, it is by no means a complete guide, and further learning is required.
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this section is to explain a few aspects of testing that you may
    find in your future experience when creating E2E testing or unit testing. Some
    of this applies to both E2E and unit testing, while others are unique to a single
    testing methodology.
  prefs: []
  type: TYPE_NORMAL
- en: Testing is a very interesting subject because what you learn about it is driven
    entirely by which you work. So, some people may have to learn how to write tests
    that heavily rely on external APIs and therefore focus on implementing stubs and
    mocks, while other developers may work on application that rely heavily on state
    management and may have to learn the ins and out of testing components that use
    state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s dive in and share a few words on these three topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Mocking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shallowMount`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start with mocking.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mocking is a method used in both unit tests and E2E tests. The definition of
    mocking is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: “Mocking is a process used in testing to isolate and focus on the code being
    tested and not on the behavior or state of external dependencies, by emulating
    a method or object.”
  prefs: []
  type: TYPE_NORMAL
- en: There are some cases, when writing a test, where you may want to avoid the use
    of real services (methods or objects). For example, you may want to avoid creating
    an order at every test run or having to use a paid API to fetch some dummy data.
    Another example would be mocking native APIs like fetch and IntersectionObserver.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid these external dependencies, we can create a fake method or object
    that emulates the real third-party app or service. This is called **mocking**.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking is an essential technique used to ensure that your tests are scoped
    and do not rely on external factors.
  prefs: []
  type: TYPE_NORMAL
- en: Spying
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Spies** are very similar to mocking; in fact, they give you the ability to
    analyze the use of a specific method. This information can then be used in testing
    expectations – for example, being able to assert that a method was called *X*
    number of times. The main difference from mocking is that spies do not actually
    change the original method and just listen to its usage.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spying** is very useful to ensure the correct execution of an application,
    without interfering with the actual methods. Adding a spy is very similar to using
    a proxy, where all requests for a spied method would first pass through the test
    framework.'
  prefs: []
  type: TYPE_NORMAL
- en: You may need to spy on an action in a store to ensure that it is called during
    the execution of your test, spy on a log method to ensure that the correct values
    are passed to it, or keep an eye on a global method within the window object.
  prefs: []
  type: TYPE_NORMAL
- en: While mocking is done to prevent us from using external services, spying is
    more aimed at providing us with a tool to make the correct assumption and assertion
    within a test.
  prefs: []
  type: TYPE_NORMAL
- en: Just like mocking, we can spy on methods and modules using tools provided by
    testing frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: shallowMount (unit tests only)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This last feature is available only in unit testing and, more precisely, to
    test components. In the *Unit testing with Vitest section*, we used the `mount`
    method to create an instance of our component, but there is another method available,
    called `shallowMount`, and in this section, we will explain the main difference
    between them.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is all about speed, and it is essential when writing a unit test
    to always choose the faster approach that uses fewer resources and completes the
    test quicker. One of these economies can come from how we initialize our components.
  prefs: []
  type: TYPE_NORMAL
- en: When using `mount`, Vue Test Utils renders the component and any other component
    included in it. So, running mount on `app.vue` would render the complete application
    within it. Because a unit test is expected to be focused on a specific unit, you
    may need to render only the component you are testing and not its children.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we can use `shallowMount`.
  prefs: []
  type: TYPE_NORMAL
- en: '`shallowMount` will render the component but then **stub** the children component
    by just rendering placeholder HTML. Doing so will reduce the resources needed
    by the test and make it more performant.'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing which one to use is due to your preferences and the overall architecture
    of your app. I personally prefer to use `mount` for most of the components, ensuring
    that they load correctly even with their dependencies, and I rely on `shallowMount`
    for complex components with several children.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the testing pyramid, covering the importance
    of tests and the different testing practices available within software development.
    We then moved on to unit tests and learned how to test our application using Vitest
    and Vue Test Utils. We then moved up to the testing pyramid and introduced E2E
    testing with Cypress. We created a small test that covered a simple user journey
    and learned a couple of techniques to select and test our application. Lastly,
    we closed the chapter with the introduction of future testing features that are
    part of the testing ecosystem and could be useful for future learning.
  prefs: []
  type: TYPE_NORMAL
- en: Your turn
  prefs: []
  type: TYPE_NORMAL
- en: Spend a couple of hours trying and testing more components to learn more about
    unit tests and expand the user journey of our E2E tests. Make sure to read the
    official documentation that includes all the available commands for both testing
    frameworks and is the best resource to find what you need.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to introduce two advanced techniques called
    `slot` and `Refs`.
  prefs: []
  type: TYPE_NORMAL
