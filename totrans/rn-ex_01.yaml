- en: First Project - Creating a Basic To-Do List App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having set up our environment for React Native development in the preface,
    let''s start developing the application. Throughout this book, I''ll refer to
    this application by the project name I began with--`Tasks`. In this chapter, we
    will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Planning the features that a to-do list app should have
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic project architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing `StyleSheet`, the React Native component for working with styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of Flexbox, a layout mode inspired by CSS for styling in React Native
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Become acquainted with ES6, the new JavaScript syntax we will be writing our
    code in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the building blocks of `Tasks` with `TextInput`, `ListView`, `AsyncStorage`,
    `Input`, state, and props
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about the iOS Simulator's Developer menu, which can help us during
    the writing of our app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing a new project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the React Native SDK already installed, initializing a new React Native
    project is as simple as using the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let the React Native command line interface do its work for a few moments, then
    open the directory titled `Tasks` once it is completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'From there, running your app in iOS Simulator is as easy as typing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will start a process to build and compile your React Native app, launch
    the iOS Simulator, import your app to the Simulator, and start it. Whenever you
    make a change to the app, you will be able to reload and see those changes immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Feature planning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before writing any code, I'd like to take the time to plan out what I want to
    accomplish in my project and scope out a **minimum viable product** (**MVP**)
    to aim for prior to building out any advanced functionalities. This helps with
    the prioritization of what key components of our app are necessary to have a functioning
    prototype so that we can have something up and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'For me, the MVP is a fantastic way to quantify my ideas into something I can
    interact with and use to validate any assumptions I have, or catch any edge cases,
    while spending the minimum amount of time necessary on coming to those conclusions.
    Here''s how I approach feature planning:'
  prefs: []
  type: TYPE_NORMAL
- en: What does the product I'm building do?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ideally, what are some of the highlighting features that make this application
    stand out?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which of the features on the preceding list are necessary to have a working
    product? Once you know the necessary features, cut out everything that doesn't
    give you the bare-bones functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give some thought to its design, but don't stress on every single detail just
    yet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With these intentions in mind, here''s what I''ve come up with:'
  prefs: []
  type: TYPE_NORMAL
- en: This is an application that will let me create and track a list of tasks that
    I have. These can be as small as a shopping list or as big as long-term goals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I'd like to set a reminder for each unique task so that I can get to each one in
    an orderly fashion. Ideally, the items on the list can be grouped into categories.
    Category grouping could perhaps be simplified by something like icons. This way,
    I can also sort and filter my list by icons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only things that are necessary from the beginning are that I can use a text
    input field to type a task, have it rendered onto a list of items, and mark them
    off as they are completed; everything else is secondary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we''ve got a clearer picture of our app, let''s break down some actionable
    steps we can take to make it a reality:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's *generate a list of default items*. These don't have to be manually entered
    as we just want to see our list populated in the app itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, your users should be able to *input their own tasks* using a text
    field and the native keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, I'd like to *make that list scrollable* in case my list of tasks spans
    past an entire vertical screen's height.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we should *let items be marked as complete* with some sort of visual indicator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's it! These are the four goals we currently have. As I previously mentioned,
    everything else is secondary for the time being. For now, we just want to get
    an MVP up and running, and then we will tweak it to our hearts' content later.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move ahead and start thinking about architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Project architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next important thing I'd like to tackle is architecture; this is about how
    our React Native app will be laid out. While the projects we build for this book
    are meant to be done individually, I firmly believe that it is important to always
    write and architect code in a manner that expects the next person to look at it
    to be an axe-murderer with a short temper. The idea here is to make it simple
    for anyone to look at your application's structure and be able to follow along.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at how the React Native CLI scaffolds our project;
    comments on each relevant file are noted to the right-hand side of the double
    slashes (`//`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `Android` and `iOS` folders will go several layers deep, but this is all
    part of its scaffolding and something we will not need to concern ourselves with
    at this point.
  prefs: []
  type: TYPE_NORMAL
- en: Based on this layout, we see that the entry point for the iOS version of our
    app is `index.ios.js` and that a specific `iOS` folder (and `Android` for that
    matter) is generated.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than using these platform-specific folders to store components that are
    only applicable to one platform, I'd like to propose a folder named `app` alongside
    these which will encapsulate all the logic that we write.
  prefs: []
  type: TYPE_NORMAL
- en: Within this `app` folder, we'll have subfolders that contain our components
    and assets. With components, I'd like to keep its style sheet coupled alongside
    the JS logic within its own folder.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, component folders should never be nested--it ends up being way
    too confusing to follow and search for something. Instead, I prefer to use a naming
    convention that makes it immediately obvious what one component's relation to
    its parent/child/sibling happens to be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how my proposed structure will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: From just a quick observation, you might be able to infer that `TasksList` is
    the component that deals with our list of tasks shown on the screen. `TasksListCell`
    will be each individual row of that list, and `TasksListInput` will deal with
    the keyboard input field.
  prefs: []
  type: TYPE_NORMAL
- en: This is very bare-bones and there are optimizations that we can make. For example,
    we can think about things such as platform-specific extensions for iOS and Android,
    as well as building in further architecture for Redux; but for the purpose of
    this specific app, we will just start with the basics.
  prefs: []
  type: TYPE_NORMAL
- en: StyleSheet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Native's core visual components accept a prop called `style` and the names
    and values more or less match up with CSS's naming conventions, with one major
    exception--kebab-case is swapped out for camelCase, similar to how things are
    named in JavaScript. For example, a CSS property of `background-color` will translate
    to `backgroundColor` in React Native.
  prefs: []
  type: TYPE_NORMAL
- en: For readability and reuse, it's beneficial to break off inline styling into
    its own `styles` object by defining all of our styles into a `styles` object using
    React Native's `StyleSheet` component to create a style object and reference it
    within our component's `render` method.
  prefs: []
  type: TYPE_NORMAL
- en: Taking it a step further, with larger applications, it's best to separate the
    style sheet into its own JavaScript file for readability's sake. Let's take a
    look at how each of these compare, using a very annotated version of the Hello
    World sample that's generated for us. These samples will contain only the code
    necessary to make my point.
  prefs: []
  type: TYPE_NORMAL
- en: Inline styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An inline style is one that is defined within the markup of your code. Check
    this sample out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you can see how inline style can create a very convoluted
    and confusing mess, especially when there are several style properties that we
    want to apply to each component. It's not practical for us to write our styles
    like this in a large-scale application, so let's break apart the styles into a
    `StyleSheet` object.
  prefs: []
  type: TYPE_NORMAL
- en: With StyleSheet, within the same file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is how a component accesses a `StyleSheet` created in the same file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is much better. We're moving our styles into an object we can reference
    without having to rewrite the same inline styles over and over. However, the problem
    we face is an extraordinarily long file with a lot of application logic, where
    a future maintainer might have to scroll through lines and lines of code to get
    to the styles. We can take it one step further and separate the styles into their
    own module.
  prefs: []
  type: TYPE_NORMAL
- en: StyleSheet as an imported module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In your component, you can import your styles, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can define them in a separate file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is much better. By encapsulating our style logic into its own file, we
    are separating our concerns and making it easier for everyone to read it.
  prefs: []
  type: TYPE_NORMAL
- en: Flexbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing you might have noted in our `StyleSheet` is a property called `flex`.
    This pertains to Flexbox, a CSS layout system that provides consistency in your
    layout across different screen sizes. Flexbox in React Native works similar to
    its CSS specification, with only a couple of differences. The most important differences
    to be noted are that the default `flex` direction has been flipped to `column`
    on React Native, as opposed to `row` on the Web, aligning items, by default, to
    the `stretch` property for React Native instead of `flex-start` in the browser,
    and the `flex` parameter only supports a single number as its value in React Native.
  prefs: []
  type: TYPE_NORMAL
- en: We will pick up a lot on Flexbox as we go through these projects; we'll start
    by taking a look at just the basics.
  prefs: []
  type: TYPE_NORMAL
- en: flex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `flex` property of your layout works a bit differently from how it operates
    in CSS. In React Native, it accepts a single digit number. If its number is a
    positive number (meaning greater than 0), the component that has this property
    will become flexible.
  prefs: []
  type: TYPE_NORMAL
- en: flexDirection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Your layout also accepts a property called `flexDirection`. There are four
    options for this: `row`, `row-reverse`, `column`, and `column-reverse`. These
    options dictate the direction that the children of your flex container will be
    laid out in.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing in ES6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**ECMAScript version 6** (**ES6**) is the latest specification of the JavaScript
    language. It is also referred to as ES2016\. It brings new features and syntax
    to JavaScript, and they are the ones you should be familiar with to be successful
    in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, `require` statements are now `import` statements. They are used to
    `import` functions, object, and so on from an external module or script. In the
    past, to include React in a file, we would write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Using ES6 `import` statements, we can rewrite it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The importing of `Component` around a curly brace is called destructuring assignment.
    It's an assignment syntax that lets us extract specific data from an array or
    object into a variable. With `Component` imported through destructuring assignment,
    we can simply call `Component` in our code; it's automatically declared as a variable
    with the exact same name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we''re replacing `var` with two different statements: `let` and `const`.
    The first statement, `let`, declares a block-scoped variable whose value can be
    mutated. The second statement, `const`, declares another block-scoped variable
    whose value cannot change through reassignment nor redeclaration.'
  prefs: []
  type: TYPE_NORMAL
- en: In the prior syntax, exporting modules used to be done using `module.exports`.
    In ES6, this is done using the `export default` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Building the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Going back to our list from a few pages back, this is the first thing I''d
    like to do with the app:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's generate a list of default items. These don't have to be manually entered;
    we just want to see our list populated in the app itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ListView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While looking at the documentation for React Native's components, you may note
    a component named `ListView`. This is a core component that is meant to display
    vertically scrolling lists of data.
  prefs: []
  type: TYPE_NORMAL
- en: Here's how `ListView` works. We will create a data source, fill it up with an
    array of data blobs, create a `ListView` component with that array as its data
    source, and pass it some JSX in its `renderRow` callback, which will take the
    data and render a row for each blob within the data source.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a high level, here is how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at what''s going on. In the `constructor` of our component, we
    create an instance of `ListViewDataSource`. The constructor for a new `ListViewDataSource`
    accepts, as a parameter, an argument that can contain any of these four:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getRowData(dataBlob`, `sectionID`, `rowID)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getSectionHeaderData(dataBlob`, `sectionID)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rowHasChanged(previousRowData`, `nextRowData)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sectionHeaderHasChanged(previousSectionData`, `nextSectionData)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getRowData` is a function that gets the data required to render the row.
    You can customize the function however you like as you pass it in to the constructor
    of `ListViewDataSource`, but `ListViewDataSource` will provide a default if you
    don't specify.
  prefs: []
  type: TYPE_NORMAL
- en: The `getSectionHeaderData` is a function that accepts a blob of data and a section
    ID and returns just the data needed to render a section header. Like `getRowData`,
    it provides a default if not specified.
  prefs: []
  type: TYPE_NORMAL
- en: The `rowHasChanged` is a function that serves as a performance optimization
    designed to only re-render any rows that have their source data changed. Unlike
    `getRowData` and `getSectionHeaderData`, you will need to pass your own version
    of `rowHasChanged`. The preceding example, which takes in the current and previous
    values of the row and returns a Boolean to show if it has changed, is the most
    common implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The `sectionHeaderHasChanged` is an optional function that compares the section
    headers' contents to determine whether they need to be re-rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in our `TasksView` constructor, our state receives a property of `dataSource`
    whose value is equal to calling `cloneWithRows` on the `ListViewDataSource` instance
    we created earlier. `cloneWithRows` takes in two parameters: a `dataBlob` and
    `rowIdentities`. The `dataBlob` is any arbitrary blob of data passed to it, and
    `rowIdentities` represents a two-dimensional array of row identifiers. The `rowIdentities`
    is an optional parameter--it isn''t included in the preceding sample code. Our
    sample code passes a hardcoded blob of data--two strings: `''row 1''` and `''row
    2''`.'
  prefs: []
  type: TYPE_NORMAL
- en: It's also important to mention right now that the data within our `dataSource`
    is immutable. If we want to change it later, we'll have to extract the information
    out of the `dataSource`, mutate it, and then replace the data within the `dataSource`.
  prefs: []
  type: TYPE_NORMAL
- en: The `ListView` component itself, which is rendered in our `TasksList`, can accept
    a number of different properties. The most important one, which we're using in
    our example, is `renderRow`.
  prefs: []
  type: TYPE_NORMAL
- en: The `renderRow` function takes data from the `dataSource` of your `ListView`
    and returns a component to render for each row of data in your `dataSource`. In
    our preceding example, `renderRow` takes each string inside our `dataSource` and
    renders it in a `Text` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the preceding code, here is how `TasksList` will render. Because we have
    not yet styled it, you will see that the iOS Status Bar overlaps the first row:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_01_001-1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Great! There''s not much to see, but we accomplished something: we created
    a `ListView` component, passed it some data, and got that data to be rendered
    on our screen. Let''s take a step back and create this component in our application
    properly.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the TasksList component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Going back to the proposed file structure from earlier, your project should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Screen-Shot-2017-01-03-at-11.03.09-PM.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's start by writing our first component--the `TasksList` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we will need to do is import our dependency on React:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll import just the building blocks we need from the React Native
    (`react-native`) library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s write the component. The syntax for creating a new component in
    ES6 is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'From here, let''s give it a constructor function to fire during its creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Our constructor sets up a `dataSource` property in the `TasksList` state as
    equal to an array of hardcoded strings. Again, our first goal is to simply render
    a list on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we''ll utilize the `render` method of the `TasksList` component to
    do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Consolidated, the code should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Great! That should do it. However, we need to link this component over to our
    application's entry point. Let's hop over to `index.ios.js` and make some changes.
  prefs: []
  type: TYPE_NORMAL
- en: Linking TasksList to index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our iOS app's entry point is `index.ios.js` and everything that it renders starts
    from here. Right now, if you launch iOS Simulator using the `react-native run-ios`
    command, you will see the same Hello World sample application that we were acquainted
    with in the preface.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need to do right now is link the `TasksList` component we just built
    to the `index` and remove all the unnecessary JSX automatically generated for
    us. Let''s go ahead and clear nearly everything in the `render` method of our
    `Tasks` component, except the top layer `View` container. When you''re done, it
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll want to insert `TasksList` within that `View` container. However, before
    we do that, we have to give the `index` file access to that component. Let''s
    do so using an `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: While this `import` statement just points to the folder that our `TasksList`
    component is in, React Native intelligently looks for a file named `index` and
    assigns it what we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that `TasksList` is readily available for us to use, let''s include it
    in the `render` method for `Tasks`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don''t have an iOS Simulator running anymore, let''s get it back up
    and running using the `react-native run-ios` command from before. Once things
    are loaded, this is what you should see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_01_003-1.png)'
  prefs: []
  type: TYPE_IMG
- en: This is awesome! Once it's loaded, let's open up the iOS Simulator Developer
    menu by pressing *Command* + *D* on your keyboard and search for an option that
    will help us save some time during the creation of our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of this section, your `index.ios.js` file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code renders the `TasksList` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The iOS Simulator Developer menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you open the Developer menu, you''ll see the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_01_004-1.png)'
  prefs: []
  type: TYPE_IMG
- en: I would like to go through some of the options available in this menu, which
    will help you make the development of your applications a lot smoother. Some of
    the options are not covered here, but are available for you to read about in the
    React Native documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will cover the options for reloading:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reload: This reloads your application code. Similar to using *Command* + *R*
    on the keyboard, the Reload option takes you to the beginning of your application
    flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enable Live Reload: Turning Live Reload on will result in your application
    automatically performing a reload action whenever your code has changed while
    you save a file in your project. Live Reload is great because you can enable it
    once and have your app show you its latest changes whenever you save your file.
    It''s important to know that both Reload and Enable Live Reload perform a *full*
    reload of your application, including resetting your application state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enable Hot Reloading: Hot Reloading is a new feature introduced in React Native
    in March 2016\. If you''ve worked with React on the Web, this term might be familiar
    to you. The idea of a Hot Reload is to keep your app running and to inject new
    code at runtime, which prevents you from losing your application state like with
    a Reload (or, by extension, Enable Live Reload).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the bottlenecks of building a feature with Live Reload turned on is when
    you work on a feature several layers deep and rely on your application's state
    to properly note changes to it. This adds several seconds to the feedback loop
    of writing and reloading your application. A Hot Reload solves this issue, letting
    your feedback loop be reduced to less than a second or two.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Something to be aware of with Hot Reloading is that, in its current iteration,
    it's not perfect. The React Native documentation notes that, in some instances,
    you will need to use a regular Reload to reset your app when Hot Reloading fails.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It's equally important to know that if you ever add new assets to your application
    or modify native Objective-C/Swift or Java/C++ code, your application will need
    to be fully rebuilt before the changes will take effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next set of options have to do with debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Debug JS Remotely: Enabling this will open up Chrome on your machine and take
    you to a Chrome tab that will allow you to use Chrome Developer Tools to debug
    your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Show Inspector: Similar to inspecting an element on the Web, you can use the
    Inspector in React Native development to inspect any element of your application
    and have it open up parts of your code and the source code that affect that element.
    You can also view the performance of each specific element this way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Developer menu, we will enable Hot Reloading. It will give us the
    quickest feedback loop on the code we're writing, allowing us to move efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've got Hot Reloading enabled and a basic list of tasks rendering
    to the screen, it's time to think about an input--we'll come back to styling later.
  prefs: []
  type: TYPE_NORMAL
- en: TextInput
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second goal for building out an MVP was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Our users should be able to input their own tasks using a text field and the
    native keyboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To successfully create this input, we have to break down the problem into some
    necessary requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to have an input field that will spring up our keyboard to type with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The keyboard should hide itself when we tap outside of it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we successfully add a task, it needs to be added to `dataSource` in `TasksList`,
    which is stored in its state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of tasks needs to be stored locally in the application so that a state
    reset doesn't delete the entire list of tasks we've created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There''re also a couple of forks in the road we should address:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens when the user hits return on the keyboard? Does that automatically
    create a task? Alternatively, do we implement and support a line break?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Is there a dedicated *Add this task* button?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the successful act of adding a task cause the keyboard to go away, requiring
    the user to tap on the input field again? Alternatively, do we allow the user
    to keep adding tasks until they tap outside the keyboard?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How many characters do we support? How long is too long for a task? What kind
    of feedback is presented to the user of our software if they exceed that limit?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a lot to take in, so let's take it one step at a time! I will propose
    that we ignore the big decisions for now and have the simple act of having an
    input on the screen, and then having that input be added to our list of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Since input should be saved to state and then rendered in the `ListView`, it
    makes sense for the input component to be a sibling of the `ListView`, allowing
    them to share the same state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Architecturally, this is how the `TasksList` component will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: React Native has a `TextInput` component in its API that fulfills our need for
    a keyboard input. Its code is customizable and will allow us to take input and
    add it to our list of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `TextInput` component can accept a multitude of props. I have listed the
    ones we will use here, but the documentation for React Native will provide much
    more depth:'
  prefs: []
  type: TYPE_NORMAL
- en: '`autoCorrect`: This is a Boolean that turns autocorrection on and off. It is
    set to `true` by default'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onChangeText`: This is a callback that is fired when the input field''s text
    changes. The value of the component is passed as an argument to the callback'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onSubmitEditing`: This is a callback that is fired when a single-line input''s
    submit button is pressed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`returnKeyType`: This sets the title of the return key to one of many different
    strings; `done`, `go`, `next`, `search`, and `send` are the five that work across
    both the platforms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can break down the task at hand into a couple of bite-sized steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Update container styling in `index.ios.js` so that its contents take up the
    entire screen and not just the center
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a `TextInput` component to our `TasksList` component's `render` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a submit handler for the `TextInput` component that will take the value
    of the text field and add it to `ListView`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clear the contents of the `TextInput` once submitted, leaving a blank field
    for the next task to be added
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take some time to try and add this first feature into our app! In the next section,
    I will share some screenshots of my results and break down the code I wrote for
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a screen to show how my input looks at this stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_01_005-1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It meets the four basic requirements listed in the preceding section: the contents
    aren''t centered on the screen, a `TextInput` component is rendered at the top,
    the submit handler takes the value of the `TextInput` component and adds it to
    the `ListView`, and the contents of the `TextInput` are emptied once that happens.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the code to see how I tackled it--yours may be different!:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the updated styling for `TasksList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: What I did here was remove the `justifyContent` and `alignItems` properties
    of the container so that items weren't constrained to just the center of the display.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on to the `TasksList` component, I made a couple of major changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor now saves three things to state: our local instance of `ListView.DataSource`,
    an empty string to keep track of the value of `TextInput`, and an array to store
    the list of tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `render` function creates a reference to a `dataSource` that we will use
    for our `ListView` component, cloning the `listOfTasks` array stored in state.
    Once again, the `ListView` just presents plain text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TextInput` component has a couple of options. It binds the `value` of
    its input field to the `text` value of our state, changing it repeatedly as the
    field is edited. On submitting it by pressing the *done* key on the keyboard,
    it fires a callback called `_addTask`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'It renders a `ListView` component with the `_renderRowData` method being responsible
    for returning each individual row of the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: I like to start the name of methods that I personally create in a React component
    with an underscore so that I can visually distinguish them from the default life
    cycle methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `_addTask` method uses the array spread operator introduced in ES6 to create
    a new array and copy over an existing array''s values, adding the newest task
    to the list at the end. Then, we assign it to the `listOfTasks` property in state.
    Remember that we have to treat our component state as an immutable object and
    simply pushing to it will be an anti-pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we call `_changeTextInputValue` so that the `TextInput` box is emptied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: For now, just returning the name of the to-do list item is fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'When setting the `listOfTasks` property in the `_addTask` method and the `text`
    property in `_changeTextInputValue`, I''m using a new notation feature of ES6,
    called shorthand property names, to assign a value to a key with the same name
    as the value. This is the same as if I were to write as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Moving on, you might note that, as you refresh the application, you lose your
    state! This is impractical for a to-do list app, since we should never expect
    the user to re-enter the same list whenever they re-open the app. What we want
    is to store this list of tasks locally in the device so that we can access it
    whenever needed. This is where `AsyncStorage` comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: AsyncStorage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `AsyncStorage` component is a simple key-value store that is globally available
    to your React Native application. It's persistent, meaning that data within `AsyncStorage`
    will continue to exist through quitting or restarting the application or your
    phone. If you've worked with HTML `LocalStorage` and `SessionStorage`, `AsyncStorage`
    will seem familiar. It's powerful for light usage, but Facebook recommends that
    you use an abstraction layer on top of `AsyncStorage` for anything more than that.
  prefs: []
  type: TYPE_NORMAL
- en: As the name implies, `AsyncStorage` is asynchronous. If you haven't yet been
    introduced to asynchronous JavaScript, this means the methods of this storage
    system can run concurrently with the rest of your code. The methods of `AsyncStorage`
    return a `Promise`--an object that represents an operation that hasn't yet completed,
    but is expected to in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the methods in `AsyncStorage` can accept a callback function as an argument,
    and will fire that callback once the `Promise` is fulfilled. This means that we
    can write our `TasksList` component to work around these promises, saving and
    retrieving our array of tasks when needed.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing about `AsyncStorage` though--it's a simple key-value store.
    It expects a string for both its key and value, which means that we'll need to
    transform the data we send using `JSON.stringify` to turn the array into a string
    when sending it into storage and `JSON.parse` to transform it back into an array
    when retrieving it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Play with `AsyncStorage` and update your `TasksList` component to support it.
    Here are some goals you''ll want to have with `AsyncStorage`:'
  prefs: []
  type: TYPE_NORMAL
- en: Once `TasksList` is loaded, we want to see whether any tasks exist locally in
    storage. If they do, present this list to the user. If they don't, start off with
    an empty array for storage. Data should always persist through a restart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a task is entered, we should update the list of tasks, save the updated
    list into `AsyncStorage`, and then update the `ListView` component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the code I ended up writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Import the `AsyncStorage` API from the React Native SDK.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Call the `_updateList` method during the `componentDidMount` life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Update `_addTask` to use the `async` and `await` keywords as well as `AsyncStorage`.
    Refer to the following for details on using `async` and `await`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: What we are doing with `AsyncStorage` in `_updateTask` is grabbing the value
    locally stored using the `listOfTasks` key. From here, we parse the result, transforming
    the string back into an array. Then, we check to see whether the array exists
    and set it to an empty array if it returns `null`. Finally, we set the state of
    our component by updating `listOfTasks` and firing `_changeTextInputValue` to
    reset `TextInput` value.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example also uses the new `async` and `await` keywords that are
    part of the ES7 specification proposal and readily available to use with React
    Native.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Async and Await keywords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Normally, to deal with an asynchronous function, we would chain some promises
    to it in order to grab our data. We can write `_updateList`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this can become quite complicated. Instead, we will use the `async`
    and `await` keywords to create a simpler solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `async` keyword in front of `_updateList` declares it as an asynchronous
    function. It automatically returns promises for us and can take advantage of the
    `await` keyword to tell the JS interpreter to temporarily exit the asynchronous
    function and resume running when the asynchronous call is completed. This is great
    for us because we can express our intent in a sequential order in a single function
    and still receive the exact same results that we would enjoy with a promise.
  prefs: []
  type: TYPE_NORMAL
- en: Custom RenderRow component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final thing on our list to have a usable minimum viable product is to allow
    each task to be marked as complete. This is where we'll create the `TasksListCell`
    component and render that in our `renderRow` function of `ListView` instead of
    just the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goals for this component should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Accept text from the parent component as a prop, rendering it in `TasksListCell`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update `listOfTasks` to take in an array of objects rather than an array of
    strings, allowing each object to track the name of the task and whether or not
    it's completed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide some sort of visual indicator when a task is tapped, marking it as complete
    both visually and within the task's `data` object, so this persists through application
    reloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom RenderRow example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at how I created this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, tasks are now represented as objects within the array. This allows
    us to add properties to each task, such as its completed state, and leaves room
    for future additions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_renderRowData` method is also updated to render a new `TasksListCell`
    component. Four `props` are shared to `TasksListCell`: the task''s completed state,
    its row identifier (provided by `renderRow`), a callback to alter the task''s
    completed state, and the details of that task itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how that `TasksListCell` component was written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Use `PropTypes` to explicitly declare the data this component expects to be
    given. Read on for an explanation on prop validation in React.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Use a ternary operator to calculate styling for a task if it is completed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The preceding component provides a `TouchableHighlight` for each task on the
    list, giving us visual opacity feedback when an item is tapped on. It also fires
    the `_completeTask` method of `TasksListCell`, which subsequently calls the `onPress`
    prop that was passed to it and makes a visual change to the style of the cell,
    marking it *completed* with a *line through* the horizontal center of the task.
  prefs: []
  type: TYPE_NORMAL
- en: Prop validation in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By declaring a propTypes object for a component, I can specify the expected
    props and their types for a given component. This is helpful for future maintainers
    of our code and provides helpful warnings when props are incorrectly entered or
    missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To take advantage of prop validation, first import the `PropTypes` module from
    React:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in our component, we give it a static property of `propTypes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `foo` and `baz` are the required props for the `Example`
    component. `foo` is expected to be a string, while `baz` is expected to be a number.
    `bar`, on the other hand, is expected to be a function but is not a required prop.
  prefs: []
  type: TYPE_NORMAL
- en: Moving beyond MVP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a very bare-bones MVP completed, the next goal is to add some
    features to the application so that it's fully-fledged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what I wrote earlier regarding some nice-to-have features:'
  prefs: []
  type: TYPE_NORMAL
- en: I'd like to set a reminder for each unique task so that I can get to each one in
    an orderly fashion. Ideally, the items on the list can be grouped into categories.
    Category grouping could perhaps be simplified by something like icons. This way,
    I can also sort and filter my list by icons.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the features, we should tweak the styling of the application
    so that it looks better. In my sample code, the app's components conflict with
    the iOS's status bar and the rows aren't formatted at all. We should give the
    app its own identity.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will dive deeper into our MVP and transform it into a fully-featured
    and styled application. We'll also look at things we would do differently if the
    app were written for Android instead.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you started out strong by planning a minimum viable product
    version of a to-do list app, complete with adding tasks to the list and marking
    them as completed. Then, you learned about basic styling in React Native with
    Flexbox and became acquainted with new syntax and functionalities of the ES6 specification.
    You also discovered the iOS simulator debugging menu, which is a helpful tool
    for writing apps.
  prefs: []
  type: TYPE_NORMAL
- en: Afterward, you created a `ListView` component to render an array of items, and
    then implemented a `TextInput` component to save user input and render that into
    the `Listview`. Then, you used `AsyncStorage` to persist the data added to the
    app by the user, utilizing the new `async` and `await` keywords to write clean
    asynchronous functions. Finally, you implemented a `TouchableHighlight` cell that
    marks tasks as completed.
  prefs: []
  type: TYPE_NORMAL
