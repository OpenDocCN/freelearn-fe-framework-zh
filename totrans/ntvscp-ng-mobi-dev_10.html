<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">@ngrx/store + @ngrx/effects for State Management</h1>
                
            
            <article>
                
<p class="mce-root">Managing state in any app can become troubling as the app scales over time. We want to have full confidence over the predictability of our app's behavior and getting a hang of its state is key to gaining that confidence.</p>
<p class="mce-root">State can be broadly defined as the particular condition that someone or something is in at a specific time. With regard to our app, the state can encompass whether our player is playing or not, whether the recorder is recording or not, and whether the track list UI is in mixing mode or not.</p>
<p class="mce-root">Storing state in a single spot allows you to know exactly what the state of the app is at any given moment. Without a single store, you usually wind up with state buried throughout different components and services, which often leads to two or more different versions of state as features are built out. This unwieldy growth of state becomes even more troublesome as different features need to interact with each other, which may or may not necessarily depend on each other.</p>
<p class="mce-root">In this chapter, we will cover the following topics:</p>
<ul class="calibre13">
<li class="calibre14">Understanding what Redux is</li>
<li class="calibre14">Understanding what ngrx is and how it relates to Redux</li>
<li class="calibre14">Defining state for an app</li>
<li class="calibre14">Integrating @ngrx/store to manage state</li>
<li class="calibre14">Understanding what @ngrx/effects are</li>
<li class="calibre14">Integrating side effects to aid our state management</li>
<li class="calibre14">Going from <em class="calibre21">inactive to reactive</em> with our code base (Mike Ryan/Brandon Roberts<sup class="calibre40">TM</sup>)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Understanding Redux and integrating @ngrx/store</h1>
                
            
            <article>
                
<p class="mce-root">Redux is an open source library that defines itself as a predictable state container for JavaScript apps. The concepts are not exactly new, but the details were developed by Dan Abramov in 2015 who was influenced by Facebook's Flux and the functional programming language, Elm. It quickly gained popularity among the React community as it was used throughout Facebook.</p>
<p class="mce-root">We don't want to redefine what Redux is, so we will quote directly from the Redux repo (<a href="https://github.com/reactjs/redux" class="calibre3">https://github.com/reactjs/redux</a>):</p>
<div class="packt_quote">
<p class="calibre41">The whole state of your app is stored in an object tree inside a single <em class="calibre21">store</em>.<br class="title-page-name"/>
The only way to change the state tree is to emit an <em class="calibre21">action</em>, an object describing what happened.<br class="title-page-name"/>
To specify how the actions transform the state tree, you write pure <em class="calibre21">reducers</em>.</p>
<p class="calibre41">That's it!</p>
</div>
<p class="mce-root">The concept is fairly simple and quite brilliant. You emit actions (which are simple string typed objects with a payload representing the data to be passed along) against the system, which wind up hitting a reducer (a pure function) to define how state is transformed by these actions.</p>
<p class="mce-root">It's important not to confuse transform with mutate. One of the fundamental concepts of Redux is that all state is <strong class="calibre1">immutable</strong>; hence, each reducer is a <strong class="calibre1">pure</strong> function.</p>
<div class="packt_infobox">A pure function always returns the same results given the same parameters. Its execution does not depend on the state of the system as a whole [<a href="https://en.wikipedia.org/wiki/Pure_function" class="calibre35">https://en.wikipedia.org/wiki/Pure_function</a>].</div>
<p class="mce-root">So, although a reducer transforms state, it does not mutate it.</p>
<p class="mce-root">In depth, engineering studies have been done on change detection systems and how object equality/reference checks are superior in speed when compared to object comparison checks on deeply nested properties. We won't go into detail for the reasons for this, but immutability of your app's data flow has significant impact on how you can fine-tune its performance, especially with regard to Angular.</p>
<p class="mce-root">Along with performance enhancements, the concepts of Redux further enhance decoupling across your entire code base, leading to the reduction of various dependencies spread throughout. With the power of actions describing the various interactions our app entails, we no longer need to inject explicit service dependencies to execute its APIs. Instead, we can simply emit actions and the principles of Redux will work for us to propagate and handle the necessary functionality our app demands, all the while maintaining a single and dependable source of truth.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What is @ngrx/store?</h1>
                
            
            <article>
                
<p class="mce-root">Early in the rewrite of Angular (from 1.x to 2.x+), a core team member turned developer advocate at Google, Rob Wormald, developed <strong class="calibre1">ngrx/store</strong> as an "<span><em class="calibre21">RxJS powered state management [system] for Angular applications, inspired by Redux."</em> The key point in that phrase is the term "<strong class="calibre1">RxJS"</strong>. Hence the name <strong class="calibre1">ngrx</strong> derives its name from joining "<strong class="calibre1">ng"</strong> for A<strong class="calibre1">ng</strong>ular with "<strong class="calibre1">rx"</strong> from <strong class="calibre1">Rx</strong>JS. The open source library quickly gained highly-talented contributors such as Mike Ryan, Brian Troncone, and Brandon Roberts and took off to become an extremely intelligent and powerful state management system for modern Angular applications.</span></p>
<p class="mce-root">Although it is heavily inspired by Redux and utilizes the same concepts, it is uniquely different in making RxJS a first-class citizen in how the system is wired. It brings <strong class="calibre1">Observables</strong> full circle throughout all the concepts of Redux, enabling truly <strong class="calibre1">reactive</strong> user interfaces and apps.</p>
<p class="mce-root">If all these concepts are new to you, Brian Troncone's thorough post will definitely help you gain more understanding as we won't be able to cover every detail of ngrx here. Please see this post:</p>
<ul class="calibre13">
<li class="calibre14"><a href="https://gist.github.com/btroncone/a6e4347326749f938510" class="calibre3">https://gist.github.com/btroncone/a6e4347326749f938510</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Designing the state model</h1>
                
            
            <article>
                
<p class="mce-root">Before integrating ngrx, it's good to first think about the various aspects of state throughout your app in addition to which module they might pertain to. With our app, here's a reasonable starter list (<em class="calibre21">not meant to be complete or thorough at this point</em>):</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre11">CoreModule</kbd>:
<ul class="calibre28">
<li class="calibre14"><kbd class="calibre11">user: any;</kbd> user-related state:
<ul class="calibre28">
<li class="calibre14"><kbd class="calibre11">recentUsername: string</kbd>; most recently used successful username</li>
<li class="calibre14"><kbd class="calibre11">current: any</kbd>; authenticated user (if there is one)</li>
</ul>
</li>
</ul>
</li>
<li class="calibre14"><kbd class="calibre11">MixerModule</kbd>:
<ul class="calibre28">
<li class="calibre14"><kbd class="calibre11">mixer: any</kbd>: mixer-related state
<ul class="calibre28">
<li class="calibre14"><kbd class="calibre11">compositions: Array&lt;IComposition&gt;</kbd>; list of user-saved compositions</li>
<li class="calibre14"><kbd class="calibre11">activeComposition: CompositionModel</kbd>; the active composition</li>
</ul>
</li>
</ul>
</li>
<li class="calibre14"><kbd class="calibre11">PlayerModule</kbd>:
<ul class="calibre28">
<li class="calibre14"><kbd class="calibre11">player: any</kbd>; various aspects of player state.
<ul class="calibre28">
<li class="calibre14"><kbd class="calibre11">playing: boolean</kbd>; whether audio is playing or not.</li>
<li class="calibre14"><kbd class="calibre11">duration: number</kbd>; total duration of playback.</li>
<li class="calibre14"><kbd class="calibre11">completed: boolean</kbd>; whether playback reached the end and is completed. This will help determine the difference between when the user stops playback or when it autostops due to the player reaching the end.</li>
<li class="calibre14"><kbd class="calibre11">seeking: boolean</kbd>; whether playback seeking is in progress.</li>
</ul>
</li>
</ul>
</li>
<li class="calibre14"><kbd class="calibre11">RecorderModule</kbd>:
<ul class="calibre28">
<li class="calibre14"><kbd class="calibre11">recorder: RecordState</kbd>; recording state represented simply by an enum</li>
</ul>
</li>
</ul>
<p class="mce-root">No module in particular, just state we want to observe:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre11">ui: any</kbd>; user interface state
<ul class="calibre28">
<li class="calibre14"><kbd class="calibre11">trackListViewType: string</kbd>; the currently active view toggle for track listing</li>
</ul>
</li>
</ul>
<p class="mce-root">The key point here is not to worry about getting this exactly right the first time. It's hard to know the precise state model when you first build an app, and it will most likely change a bit over time and that's okay.</p>
<p class="mce-root">State for our app is better known at this time because we have already built a working app, so this is a tad bit easier. Typically, mapping this out before you build an app is more difficult; however, again, don't worry about getting it right the first time! You can easily refactor and tweak it over time.</p>
<p class="mce-root">Let's take this state and work it into our app with ngrx.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Installing and integrating @ngrx/store</h1>
                
            
            <article>
                
<p class="mce-root">We want to <span>first </span>install <kbd class="calibre11">@ngrx/store</kbd>:</p>
<pre class="calibre22"><strong class="calibre1">npm i @ngrx/store --save</strong></pre>
<p class="mce-root">We can now provide the single store to our app via the <kbd class="calibre11">StoreModule</kbd>. We define these initial slices of state in our <kbd class="calibre11">CoreModule</kbd>, which will be available when the app boots, while each lazy loaded feature module adds its own state and reducers later when needed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Providing the initial app state excluding any lazily loaded module state</h1>
                
            
            <article>
                
<p class="mce-root">We want to start by defining the initial app state, excluding any lazily loaded feature module state. Since our <kbd class="calibre11">CoreModule</kbd> provides <kbd class="calibre11">AuthService</kbd>, which deals with handling our user, we will consider the <strong class="calibre1">user</strong> slice a fundamental key to our app's initial state.</p>
<p class="mce-root">In particular, let's begin by defining the shape of our user state.<br class="title-page-name"/>
Create <kbd class="calibre11">app/modules/core/states/user.state.ts</kbd>:</p>
<pre class="calibre22">export interface IUserState {<br class="title-page-name"/>  recentUsername?: string;<br class="title-page-name"/>  current?: any;<br class="title-page-name"/>  loginCanceled?: boolean;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>export const userInitialState: IUserState = {};</pre>
<p class="mce-root">Our user state is very simple. It contains a <kbd class="calibre11">recentUsername</kbd> representing a string of the most recently successfully authenticated username (useful if the user were to log out and return to log in later). Then, we have <strong class="calibre1">current</strong>, which will represent a user object if authenticated, or null if not. We also include a <kbd class="calibre11">loginCanceled</kbd> boolean since we surmise it may be useful for analyzing user interaction if we were to start reporting state as analytics data.</p>
<div class="packt_infobox">
<p class="calibre42">Any data points around authentication can be critical to understanding our app's user base. For example, it might be insightful to learn whether or not requiring authentication to record was causing more canceled logins than signups, which may have a direct affect on user retention.</p>
</div>
<p class="mce-root">To be consistent with our approach throughout this book, also create <kbd class="calibre11">app/modules/core/states/index.ts</kbd>:</p>
<pre class="calibre22">export * from './user.state';</pre>
<p class="mce-root">Now, let's create our user actions; create <kbd class="calibre11">app/modules/core/actions/user.action.ts</kbd>:</p>
<pre class="calibre22">import { Action } from '@ngrx/store';<br class="title-page-name"/>import { IUserState } from '../states';<br class="title-page-name"/><br class="title-page-name"/>export namespace 

UserActions {<br class="title-page-name"/>  const CATEGORY: string = 'User';<br class="title-page-name"/><br class="title-page-name"/>  export interface IUserActions {<br class="title-page-name"/>    INIT: 

string;<br class="title-page-name"/>    LOGIN: string;<br class="title-page-name"/>    LOGIN_SUCCESS: string;<br class="title-page-name"/>    LOGIN_CANCELED: string;<br class="title-page-name"/>    LOGOUT: 

string;<br class="title-page-name"/>    UPDATED: string;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  export const ActionTypes: IUserActions = {<br class="title-page-name"/>    INIT:           

`${CATEGORY} Init`,<br class="title-page-name"/>    LOGIN:          `${CATEGORY} Login`,<br class="title-page-name"/>    LOGIN_SUCCESS:  `${CATEGORY} Login Success`,<br class="title-page-name"/>    LOGIN_CANCELED: `${CATEGORY} Login Canceled`,<br class="title-page-name"/>    LOGOUT:         `${CATEGORY} Logout`,<br class="title-page-name"/>    UPDATED:        

`${CATEGORY} Updated`<br class="title-page-name"/>  };<br class="title-page-name"/><br class="title-page-name"/>  export class InitAction implements Action {<br class="title-page-name"/>    type = 

ActionTypes.INIT;<br class="title-page-name"/>    payload = null;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  export class LoginAction implements Action {<br class="title-page-name"/>    type 

= ActionTypes.LOGIN;<br class="title-page-name"/>    constructor(public payload: { msg: string; usernameAttempt?: string}) { }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  export class LoginSuccessAction implements Action {<br class="title-page-name"/>    type = ActionTypes.LOGIN_SUCCESS;<br class="title-page-name"/>    constructor

(public payload: any /*user object*/) { }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  export class LoginCanceledAction implements Action {<br class="title-page-name"/>  

  type = ActionTypes.LOGIN_CANCELED;<br class="title-page-name"/>    constructor(public payload?: string /*last attempted username*/) { }<br class="title-page-name"/>  

}<br class="title-page-name"/><br class="title-page-name"/>  export class LogoutAction implements Action {<br class="title-page-name"/>    type = ActionTypes.LOGOUT;<br class="title-page-name"/>    payload = 

null;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  export class UpdatedAction implements Action {<br class="title-page-name"/>    type = ActionTypes.UPDATED;<br class="title-page-name"/>    

constructor(public payload: IUserState) { }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  export type Actions =<br class="title-page-name"/>    InitAction<br class="title-page-name"/>    | 

LoginAction<br class="title-page-name"/>    | LoginSuccessAction<br class="title-page-name"/>    | LoginCanceledAction<br class="title-page-name"/>    | LogoutAction<br class="title-page-name"/>    | 

UpdatedAction;<br class="title-page-name"/>}</pre>
<p class="mce-root">Then, follow up with our standard; create <kbd class="calibre11">app/modules/core/actions/index.ts</kbd>:</p>
<pre class="calibre22">export * from './user.action';</pre>
<p class="mce-root">Okay now, what's going on with those actions?! Here's what we've defined:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre11">INIT</kbd>: To initialize the user right when the app launches. In other words, this action will be used to check persistence and restore a user object onto the app's state at launch time.</li>
<li class="calibre14"><kbd class="calibre11">LOGIN</kbd>: Begin the login sequence. In our app, this will show the login dialog.</li>
<li class="calibre14"><kbd class="calibre11">LOGIN_SUCCESS</kbd>: Since login is asynchronous, this action will dispatch once login is complete.</li>
<li class="calibre14"><kbd class="calibre11">LOGIN_CANCELED</kbd>: If the user cancels login.</li>
<li class="calibre14"><kbd class="calibre11">LOGOUT</kbd>: When user logs out.</li>
<li class="calibre14"><kbd class="calibre11">UPDATED</kbd>: We will use this as a simple action to update our user state. This will generally not be dispatched directly, but will be used in the reducer we'll create in a moment.</li>
</ul>
<p class="mce-root">The formalities you see here provide a consistent and strongly-typed structure. By utilizing a namespace, we are able to uniquely identify this set of actions with a name, <kbd class="calibre11">UserActions</kbd>. This allows the interior naming to remain the same across many other namespaced actions we will create for the lazy loaded modules state, providing a great standard to work with. The <kbd class="calibre11">CATEGORY</kbd> is necessary because every action must be unique, not just in this set of actions but across the entire app. The interfaces help provide good intelligence when using our actions, in addition to type safety. The various action classes help ensure that all actions dispatched are new instances and provide a powerful way to strongly type our action payloads. This also makes our code easy to refactor down the line. The last utility in our structure is the union type at the bottom, which helps our reducer determine the applicable actions it should be concerned with.</p>
<p class="mce-root">Speaking of that reducer, let's create it now: <kbd class="calibre11">app/modules/core/reducers/user.reducer.ts</kbd>:</p>
<pre class="calibre22">import { IUserState, userInitialState } from '../states/user.state';<br class="title-page-name"/>import { UserActions } from 

'../actions/user.action';<br class="title-page-name"/><br class="title-page-name"/>export function userReducer(<br class="title-page-name"/>  state: IUserState = userInitialState,<br class="title-page-name"/>  

action: UserActions.Actions<br class="title-page-name"/>): IUserState {<br class="title-page-name"/>  switch (action.type) {<br class="title-page-name"/>    case 

UserActions.ActionTypes.UPDATED:<br class="title-page-name"/>      return Object.assign({}, state, action.payload);<br class="title-page-name"/>    default:<br class="title-page-name"/>      

return state;<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">The reducer is incredibly simple. As mentioned, it is a pure function that takes in the existing state along with an action and returns a new state (as a new Object unless it's the default starting case). This maintains immutability and keeps things quite elegant. The <kbd class="calibre11">UPDATED</kbd> action will always be the last in any action chain to fire off and ultimately change the user state. In this case, we'll keep things simple and allow our <kbd class="calibre11">UPDATED</kbd> action to be the only action that actually changes the user state. The other actions will set up a chain, whereby they end up dispatching <kbd class="calibre11">UPDATED</kbd> if they need the user state to change. You could certainly set up more cases here based on our actions to change the state; however, in our app, this will be the only action that ultimately changes the user state.</p>
<p class="mce-root"><em class="calibre21">Action chain?</em> What on earth do we mean by an <em class="calibre21">Action chain</em>?! You may be wondering how we wire these actions to interplay with each other if needed?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Installing and integrating @ngrx/effects</h1>
                
            
            <article>
                
<p class="mce-root">Without redefining, let's look at the description of @ngrx/effects straight from the repo (<a href="https://github.com/ngrx/effects" class="calibre3">https://github.com/ngrx/effects</a>):</p>
<div class="packt_infobox">In <kbd class="calibre29">@ngrx/effects</kbd>, effects are the sources of actions. You use the <kbd class="calibre29">@Effect()</kbd> decorator to hint which observables on a service are action sources, and <kbd class="calibre29">@ngrx/effects</kbd> automatically merges your action streams, letting you subscribe them to store.<br class="calibre24"/>
<br class="calibre24"/>
To help you compose new action sources, <kbd class="calibre29">@ngrx/effects</kbd> exports an action observable service that emits every action dispatched in your application.</div>
<p class="mce-root">In other words, we can chain our actions together with effects to provide powerful data flow composition throughout our app. They allow us to insert behavior that should take place between when an action is dispatched and before the state is ultimately changed. The most common use case is to handle HTTP requests and/or other asynchronous operations; however, they have many useful applications.</p>
<p class="mce-root">To use, let's first install <kbd class="calibre11">@ngrx/effects</kbd>:</p>
<pre class="calibre22"><strong class="calibre1">npm i @ngrx/effects --save</strong></pre>
<p class="mce-root">Now let's take a look at what our user actions look like in an effect chain.</p>
<div class="packt_infobox">Real quickly, though, to remain consistent with our naming structure, let's rename <kbd class="calibre29">auth.service.ts</kbd> to <kbd class="calibre29">user.service.ts</kbd>. It helps when we have a naming standard that is consistent across the board.</div>
<p class="mce-root">Now, create <kbd class="calibre11">app/modules/core/effects/user.effect.ts</kbd>:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { Injectable } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>// libs<br class="title-page-name"/>import { Store, Action } from 

'@ngrx/store';<br class="title-page-name"/>import { Effect, Actions } from '@ngrx/effects';<br class="title-page-name"/>import { Observable } from 

'rxjs/Observable';<br class="title-page-name"/><br class="title-page-name"/>// module<br class="title-page-name"/>import { LogService } from '../../core/services/log.service';<br class="title-page-name"/>import { 

DatabaseService } from '../services/database.service';<br class="title-page-name"/>import { UserService } from '../services/user.service';<br class="title-page-name"/>import { UserActions } from '../actions/user.action';<br class="title-page-name"/><br class="title-page-name"/>@Injectable()<br class="title-page-name"/>export class UserEffects {<br class="title-page-name"/><br class="title-page-name"/>  @Effect() init$: Observable&lt;Action&gt; = this.actions$<br class="title-page-name"/>    .ofType(UserActions.ActionTypes.INIT)<br class="title-page-name"/>    .startWith(new UserActions.InitAction())<br class="title-page-name"/>    .map(action =&gt; {<br class="title-page-name"/>      const current = 

this.databaseService<br class="title-page-name"/>        .getItem(DatabaseService.KEYS.currentUser);<br class="title-page-name"/>      const recentUsername = 

this.databaseService<br class="title-page-name"/>        .getItem(DatabaseService.KEYS.recentUsername);<br class="title-page-name"/>      this.log.debug(`Current user: 

`, current || 'Unauthenticated');<br class="title-page-name"/>        return new UserActions.UpdatedAction({ current, recentUsername });<br class="title-page-name"/>    

});<br class="title-page-name"/><br class="title-page-name"/>  @Effect() login$: Observable&lt;Action&gt; = this.actions$<br class="title-page-name"/>    .ofType

(UserActions.ActionTypes.LOGIN)<br class="title-page-name"/>    .withLatestFrom(this.store)<br class="title-page-name"/>    .switchMap(([action, state]) =&gt; {<br class="title-page-name"/>    

  const current = state.user.current;<br class="title-page-name"/>      if (current) {<br class="title-page-name"/>        // user already logged in, just fire 

updated<br class="title-page-name"/>        return Observable.of(<br class="title-page-name"/>          new UserActions.UpdatedAction({ current })<br class="title-page-name"/>        );<br class="title-page-name"/>  

    } else {<br class="title-page-name"/>        this._loginPromptMsg = action.payload.msg;<br class="title-page-name"/>        const usernameAttempt =<br class="title-page-name"/>          

action.payload.usernameAttempt<br class="title-page-name"/>          || state.user.recentUsername;<br class="title-page-name"/><br class="title-page-name"/>        return 

Observable.fromPromise(<br class="title-page-name"/>          this.userService.promptLogin(this._loginPromptMsg, <br class="title-page-name"/>          usernameAttempt)

<br class="title-page-name"/>        )<br class="title-page-name"/>        .map(user =&gt; (new UserActions.LoginSuccessAction(user)))<br class="title-page-name"/>        .catch

(usernameAttempt =&gt; Observable.of(<br class="title-page-name"/>          new UserActions.LoginCanceledAction(usernameAttempt)<br class="title-page-name"/>        

));<br class="title-page-name"/>      }<br class="title-page-name"/>    });<br class="title-page-name"/><br class="title-page-name"/>  @Effect() loginSuccess$: Observable&lt;Action&gt; = this.actions$<br class="title-page-name"/>    

.ofType(UserActions.ActionTypes.LOGIN_SUCCESS)<br class="title-page-name"/>    .map((action) =&gt; {<br class="title-page-name"/>      const user = action.payload;<br class="title-page-name"/> 

     const recentUsername = user.username;<br class="title-page-name"/>      this.databaseService<br class="title-page-name"/>        .setItem

(DatabaseService.KEYS.currentUser, user);<br class="title-page-name"/>      this.databaseService<br class="title-page-name"/>        .setItem

(DatabaseService.KEYS.recentUsername, recentUsername);<br class="title-page-name"/>      this._loginPromptMsg = null; // clear, no longer 

needed<br class="title-page-name"/>      return (new UserActions.UpdatedAction({<br class="title-page-name"/>        current: user,<br class="title-page-name"/>        recentUsername,<br class="title-page-name"/>    

    loginCanceled: false<br class="title-page-name"/>      }));<br class="title-page-name"/>    });<br class="title-page-name"/><br class="title-page-name"/>  @Effect() loginCancel$ = this.actions$<br class="title-page-name"/>    

.ofType(UserActions.ActionTypes.LOGIN_CANCELED)<br class="title-page-name"/>    .map(action =&gt; {<br class="title-page-name"/>      const usernameAttempt = 

action.payload;<br class="title-page-name"/>      if (usernameAttempt) {<br class="title-page-name"/>        // reinitiate sequence, login failed, retry<br class="title-page-name"/>        

return new UserActions.LoginAction({<br class="title-page-name"/>          msg: this._loginPromptMsg,<br class="title-page-name"/>          usernameAttempt<br class="title-page-name"/>        

});<br class="title-page-name"/>      } else {<br class="title-page-name"/>        return new UserActions.UpdatedAction({<br class="title-page-name"/>          loginCanceled: true<br class="title-page-name"/>        

});<br class="title-page-name"/>      }<br class="title-page-name"/>    });<br class="title-page-name"/><br class="title-page-name"/>  @Effect() logout$: Observable&lt;Action&gt; = this.actions$<br class="title-page-name"/>    

.ofType(UserActions.ActionTypes.LOGOUT)<br class="title-page-name"/>    .map(action =&gt; {<br class="title-page-name"/>      this.databaseService<br class="title-page-name"/>        

.removeItem(DatabaseService.KEYS.currentUser);<br class="title-page-name"/>      return new UserActions.UpdatedAction({<br class="title-page-name"/>        current: 

null<br class="title-page-name"/>      });<br class="title-page-name"/>    });<br class="title-page-name"/><br class="title-page-name"/>  private _loginPromptMsg: string;<br class="title-page-name"/><br class="title-page-name"/>  constructor(<br class="title-page-name"/>    private 

store: Store&lt;any&gt;,<br class="title-page-name"/>    private actions$: Actions,<br class="title-page-name"/>    private log: LogService,<br class="title-page-name"/>    private 

databaseService: DatabaseService,<br class="title-page-name"/>    private userService: UserService<br class="title-page-name"/>  ) { }<br class="title-page-name"/>}</pre>
<p class="mce-root">We have clarified the intent of our data flow concerning our <kbd class="calibre11">UserService</kbd> and delegated the responsibility to this effect chain. This allows us to compose our data flow in a clear and consistent manner with a great deal of flexibility and power. For instance, our <kbd class="calibre11">InitAction</kbd> chain now allows us to automatically initialize the user via the following:</p>
<pre class="calibre22">.startWith(new UserActions.InitAction())</pre>
<p class="mce-root">Earlier, we were calling a private method--<kbd class="calibre11">this._init()</kbd>--inside the service constructor; however, we no longer need explicit calls like that as effects are run and queued up once the module is bootstrapped. The <kbd class="calibre11">.startWith</kbd> operator will cause the observable to fire off one single time (at the point of module creation), allowing the init sequence to be executed at a particularly opportune time, when our app is initializing. Our initialization sequence is the same as we were previously handling in the service; however, this time we're taking into consideration our new <kbd class="calibre11">recentUsername</kbd> persisted value (if one exists). We then end the init sequence with a <kbd class="calibre11">UserActions.UpdatedAction</kbd>:</p>
<pre class="calibre22">new UserActions.UpdatedAction({ current, recentUsername })</pre>
<p class="mce-root">Note that there's no effect chain wired to <kbd class="calibre11">UserActions.ActionTypes.UPDATED</kbd>. This is because there are no side effects that should occur by the time that <kbd class="calibre11">Action</kbd> occurs. Since there are no more side effects, the observable sequence ends up in the reducer that has a <kbd class="calibre11">switch</kbd> statement to handle it:</p>
<pre class="calibre22">export function userReducer(<br class="title-page-name"/>  state: IUserState = userInitialState,<br class="title-page-name"/>  action: UserActions.Actions<br class="title-page-name"/>): 

IUserState {<br class="title-page-name"/>  switch (action.type) {<br class="title-page-name"/>    case <strong class="calibre1">UserActions.ActionTypes.UPDATED</strong>:<br class="title-page-name"/>      

return Object.assign({}, state, action.payload);<br class="title-page-name"/>    default:<br class="title-page-name"/>      return state;<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">This takes the payload (which is typed as the shape of the user state, <kbd class="calibre11">IUserState</kbd>) and overwrites the values in the existing state to return a brand new user state. Importantly, <kbd class="calibre11">Object.assign</kbd> allows any existing values in the source object to not be overridden unless explicitly defined by the incoming payload. This allows only new incoming payload values to be reflected on our state, while still maintaining the existing values.</p>
<p class="mce-root">The rest of our <kbd class="calibre11">UserEffect</kbd> chain is fairly self-explanatory. P<span>rimarily, i</span>t's handling much of what the service was previously handling, with the exception of prompting the login dialog, which the effect chain is utilizing the service method to do. However, it's worth mentioning that we can go so far as to completely remove this service as the contents of the <kbd class="calibre11">promptLogin</kbd> method can easily be carried out directly in our effect now.</p>
<div class="packt_tip">When deciding if you should handle more logic in your effect or a designated service, it really comes down to personal preference and/or scalability. If you have rather lengthy service logic and more than a couple of methods to handle logic while working with effects, creating a designated service will help greatly. You can scale more functionality into the service without diluting the clarity of your effects chain.</div>
<p class="mce-root">Lastly, unit testing will be easier with a designated service with more logic. In this case, our logic is fairly simple; however, we'll leave the <kbd class="calibre11">UserService</kbd> for example purposes as well as best practice.</p>
<p class="mce-root">Speaking of, let's take a look at how simplified our <kbd class="calibre11">UserService</kbd> looks now<br class="title-page-name"/>
in <kbd class="calibre11">app/modules/core/services/user.service.ts</kbd>:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { Injectable } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>// app<br class="title-page-name"/>import { DialogService } from 

'./dialog.service';<br class="title-page-name"/><br class="title-page-name"/>@Injectable()<br class="title-page-name"/>export class UserService {<br class="title-page-name"/> <br class="title-page-name"/>  constructor(<br class="title-page-name"/>    

private dialogService: DialogService<br class="title-page-name"/>  ) { } <br class="title-page-name"/><br class="title-page-name"/>  public promptLogin(msg: string, username: string = ''): 

Promise&lt;any&gt; {<br class="title-page-name"/>    return new Promise((resolve, reject) =&gt; {<br class="title-page-name"/>      this.dialogService.login(msg, 

username, '').then((input) =&gt; {<br class="title-page-name"/>        if (input.result) { // result will be false when canceled<br class="title-page-name"/>          if 

(input.userName &amp;&amp; input.userName.indexOf('@') &gt; -1) {<br class="title-page-name"/>            if (input.password) {<br class="title-page-name"/>          

    resolve({<br class="title-page-name"/>                username: input.userName,<br class="title-page-name"/>                password: input.password<br class="title-page-name"/>            

  });<br class="title-page-name"/>            } else {<br class="title-page-name"/>              this.dialogService.alert('You must provide a password.')<br class="title-page-name"/>           

     .then(reject.bind(this, input.userName));<br class="title-page-name"/>            }<br class="title-page-name"/>          } else {<br class="title-page-name"/>            // reject, 

passing userName back to try again<br class="title-page-name"/>            this.dialogService.alert('You must provide a valid email <br class="title-page-name"/>         

   address.')<br class="title-page-name"/>              .then(reject.bind(this, input.userName));<br class="title-page-name"/>          }<br class="title-page-name"/>        } else {<br class="title-page-name"/>     

     // user chose cancel<br class="title-page-name"/>          reject(false);<br class="title-page-name"/>        }<br class="title-page-name"/>      });<br class="title-page-name"/>    });<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">It's much cleaner now. Okay, so how do we let our app know about all this new goodness?</p>
<p class="mce-root">First, let's follow one of our standards by adding an index to our entire core module; add <kbd class="calibre11">app/modules/core/index.ts</kbd>:</p>
<pre class="calibre22">export * from './actions';<br class="title-page-name"/>export * from './effects';<br class="title-page-name"/>export * from './reducers';<br class="title-page-name"/>export * from 

'./services';<br class="title-page-name"/>export * from './states';<br class="title-page-name"/>export * from './core.module';</pre>
<p class="mce-root">We simply export all the goodies our core module now provides, including the module itself.</p>
<p class="mce-root">Then, open <kbd class="calibre11">app/modules/core/core.module.ts</kbd> to finish our wiring:</p>
<pre class="calibre22">// nativescript<br class="title-page-name"/>import { NativeScriptModule } from 'nativescript-angular/nativescript.module'; <br class="title-page-name"/>import { 

NativeScriptFormsModule } from 'nativescript-angular/forms'; <br class="title-page-name"/>import { NativeScriptHttpModule } from 'nativescript-

angular/http'; <br class="title-page-name"/><br class="title-page-name"/>// angular<br class="title-page-name"/>import { NgModule, Optional, SkipSelf } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">// libs</strong><br class="title-page-name"/><strong class="calibre1">import { StoreModule } from '@ngrx/store';</strong><br class="title-page-name"/><strong class="calibre1">import { 

EffectsModule } from '@ngrx/effects';</strong><br class="title-page-name"/><br class="title-page-name"/>// app<br class="title-page-name"/><strong class="calibre1">import { UserEffects } from 

'./effects';</strong><br class="title-page-name"/><strong class="calibre1">import { userReducer } from './reducers';</strong><br class="title-page-name"/>import { PROVIDERS } from 

'./services';<br class="title-page-name"/>import { PROVIDERS as MIXER_PROVIDERS } from '../mixer/services';<br class="title-page-name"/>import { PROVIDERS as 

PLAYER_PROVIDERS } from '../player/services';<br class="title-page-name"/><br class="title-page-name"/>const MODULES: any[] = [<br class="title-page-name"/>  NativeScriptModule,<br class="title-page-name"/>  

NativeScriptFormsModule,<br class="title-page-name"/>  NativeScriptHttpModule<br class="title-page-name"/>];<br class="title-page-name"/><br class="title-page-name"/>@NgModule({<br class="title-page-name"/>  imports: [<br class="title-page-name"/>    

...MODULES,<br class="title-page-name"/>    // define core app state<br class="title-page-name"/>    <strong class="calibre1">StoreModule.forRoot({</strong><br class="title-page-name"/><strong class="calibre1">      user: 

userReducer</strong><br class="title-page-name"/><strong class="calibre1">    }),</strong><br class="title-page-name"/>    // register core effects<br class="title-page-name"/>    

<strong class="calibre1">EffectsModule.forRoot([<br class="title-page-name"/>      UserEffects<br class="title-page-name"/>    ]),</strong> <br class="title-page-name"/>  ],<br class="title-page-name"/>  providers: [<br class="title-page-name"/>    

...PROVIDERS,<br class="title-page-name"/>    ...MIXER_PROVIDERS,<br class="title-page-name"/>    ...PLAYER_PROVIDERS<br class="title-page-name"/>  ],<br class="title-page-name"/>  exports: [<br class="title-page-name"/>    ...MODULES<br class="title-page-name"/>  ]<br class="title-page-name"/>})<br class="title-page-name"/>export class CoreModule {<br class="title-page-name"/>  constructor (@Optional() @SkipSelf() parentModule: CoreModule) 

{<br class="title-page-name"/>    if (parentModule) {<br class="title-page-name"/>      throw new Error(<br class="title-page-name"/>        'CoreModule is already loaded. Import it in the 

AppModule only');<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">Here we ensure that we define our <kbd class="calibre11">user</kbd> state key to use the <kbd class="calibre11">userReducer</kbd> and register it with <kbd class="calibre11">StoreModule</kbd>. We then call <kbd class="calibre11">EffectsModule.forRoot()</kbd>, with a collection of singleton effect providers to register like our <kbd class="calibre11">UserEffects</kbd>.</p>
<p class="mce-root">Now, let's take a look at how this improves the rest of the code base since we were undoubtedly injecting the <kbd class="calibre11">UserService</kbd> (previously named <kbd class="calibre11">AuthService</kbd>) in a couple of places.</p>
<p class="mce-root">We were previously injecting <kbd class="calibre11">AuthService</kbd> in <kbd class="calibre11">AppComponent</kbd> to ensure that Angular's dependency injection constructed it early on when the app was bootstrapped, creating the necessary singleton our app needed. However, with <kbd class="calibre11">UserEffects</kbd> automatically running now on bootstrap, which in turn injects (now renamed) <kbd class="calibre11">UserService</kbd>, we no longer need this rather silly necessity anymore, so, we can update <kbd class="calibre11">AppComponent</kbd> as follows:</p>
<pre class="calibre22">@Component({<br class="title-page-name"/>  moduleId: module.id,<br class="title-page-name"/>  selector: 'my-app',<br class="title-page-name"/>  templateUrl: 'app.component.html',<br class="title-page-name"/>})<br class="title-page-name"/>export class AppComponent {<br class="title-page-name"/><br class="title-page-name"/>  constructor() { // we removed AuthService (UserService) here  </pre>
<p class="mce-root">In one swoop, our code base is now getting smarter and slimmer. Let's keep going to see other benefits of our ngrx integration.</p>
<p class="mce-root">Open <kbd class="calibre11">app/auth-guard.service.ts</kbd>, and we can now make the following simplifications:</p>
<pre class="calibre22">import { Injectable } from '@angular/core';<br class="title-page-name"/>import { Route, CanActivate, CanLoad } from 

'@angular/router';<br class="title-page-name"/><br class="title-page-name"/>// libs<br class="title-page-name"/><strong class="calibre1">import { Store } from '@ngrx/store';</strong><br class="title-page-name"/><strong class="calibre1">import { Subscription } from 'rxjs/Subscription';</strong><br class="title-page-name"/><br class="title-page-name"/>// app<br class="title-page-name"/><strong class="calibre1">import { IUserState, 

UserActions } from '../modules/core';</strong><br class="title-page-name"/><br class="title-page-name"/>@Injectable()<br class="title-page-name"/>export class AuthGuard implements 

CanActivate, CanLoad {<br class="title-page-name"/><br class="title-page-name"/>  <strong class="calibre1">private _sub: Subscription;</strong><br class="title-page-name"/><br class="title-page-name"/>  constructor(<strong class="calibre1">private 

store: Store&lt;any&gt;</strong>) { }<br class="title-page-name"/><br class="title-page-name"/>  canActivate(): Promise&lt;boolean&gt; {<br class="title-page-name"/>    return new Promise

((resolve, reject) =&gt; {<br class="title-page-name"/>      <strong class="calibre1">this.store.dispatch(</strong><br class="title-page-name"/><strong class="calibre1">        new 

UserActions.LoginAction({ msg: 'Authenticate to record.' })</strong><br class="title-page-name"/><strong class="calibre1">      );</strong><br class="title-page-name"/><strong class="calibre1">      

this._sub = this.store.select(s =&gt; s.user).subscribe((state: <br class="title-page-name"/>      IUserState) =&gt; {</strong><br class="title-page-name"/><strong class="calibre1">      

  if (state.current) {</strong><br class="title-page-name"/><strong class="calibre1">          this._reset();</strong><br class="title-page-name"/><strong class="calibre1">          resolve

(true);</strong><br class="title-page-name"/><strong class="calibre1">        } else if (state.loginCanceled) {</strong><br class="title-page-name"/><strong class="calibre1">          this._reset

();</strong><br class="title-page-name"/><strong class="calibre1">          resolve(false);</strong><br class="title-page-name"/><strong class="calibre1">        }</strong><br class="title-page-name"/><strong class="calibre1">      

});</strong><br class="title-page-name"/>    });<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  canLoad(route: Route): Promise&lt;boolean&gt; {<br class="title-page-name"/>    // reuse same 

logic to activate<br class="title-page-name"/>    return this.canActivate();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  <strong class="calibre1">private _reset() {</strong><br class="title-page-name"/><strong class="calibre1">    if (this._sub) this._sub.unsubscribe();</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/>}</pre>
<p class="mce-root">When activating the <kbd class="calibre11">/record</kbd> route, we dispatch the <kbd class="calibre11">LoginAction</kbd> every time since we require an authenticated user to use the recording features. Our login effects chain properly handles if the user is already authenticated, so all we need to do is set up our state subscription to react accordingly.</p>
<p class="mce-root">Ngrx is flexible, and how you set up your actions and effects chains is purely up to you.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Providing lazily loaded feature module state</h1>
                
            
            <article>
                
<p class="mce-root">We can now build out the scalable ngrx structure into our various feature modules, which will provide state. Starting with <kbd class="calibre11">MixerModule</kbd>, let's modify <kbd class="calibre11">app/modules/mixer/mixer.module.ts</kbd> with the following:</p>
<pre class="calibre22">...<br class="title-page-name"/>// libs<br class="title-page-name"/><strong class="calibre1">import { StoreModule } from '@ngrx/store';</strong><br class="title-page-name"/>...<br class="title-page-name"/><br class="title-page-name"/>@NgModule({<br class="title-page-name"/>  imports: [<br class="title-page-name"/>    PlayerModule,<br class="title-page-name"/>    SharedModule,<br class="title-page-name"/>    

NativeScriptRouterModule.forChild(routes),<br class="title-page-name"/>    <strong class="calibre1">StoreModule.forFeature('mixerModule', {</strong><br class="title-page-name"/><strong class="calibre1">  

    mixer: {}     // TODO: add reducer when ready</strong><br class="title-page-name"/><strong class="calibre1">    })</strong><br class="title-page-name"/>  ],<br class="title-page-name"/>  ...<br class="title-page-name"/>})<br class="title-page-name"/>export class MixerModule { }</pre>
<p class="mce-root">Here, we are defining what the <kbd class="calibre11">MixerModule</kbd> <span>state </span>will provide. Now, let's define its shape; create<br class="title-page-name"/>
<kbd class="calibre11">app/modules/mixer/states/mixer.state.ts</kbd>:</p>
<pre class="calibre22">import { IComposition } from '../../shared/models';<br class="title-page-name"/><br class="title-page-name"/>export interface IMixerState {<br class="title-page-name"/>  compositions?: 

Array&lt;IComposition&gt;;<br class="title-page-name"/>  activeComposition?: any;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>export const mixerInitialState: IMixerState = 

{<br class="title-page-name"/>  compositions: []<br class="title-page-name"/>};</pre>
<p class="mce-root">To be consistent with our approach throughout this book, also create <kbd class="calibre11">app/modules/mixer/states/index.ts</kbd>:</p>
<pre class="calibre22">export * from './mixer.state';</pre>
<p class="mce-root">Now, let's create our mixer actions; create <kbd class="calibre11">app/modules/mixer/actions/mixer.action.ts</kbd>:</p>
<pre class="calibre22">import { ViewContainerRef } from '@angular/core';<br class="title-page-name"/>import { Action } from '@ngrx/store';<br class="title-page-name"/>import { 

IMixerState } from '../states';<br class="title-page-name"/>import { IComposition, CompositionModel, TrackModel } from '../../shared/models';<br class="title-page-name"/><br class="title-page-name"/>export namespace MixerActions {<br class="title-page-name"/>  const CATEGORY: string = 'Mixer';<br class="title-page-name"/><br class="title-page-name"/>  export interface 

IMixerActions {<br class="title-page-name"/>    INIT: string;<br class="title-page-name"/>    ADD: string;<br class="title-page-name"/>    EDIT: string;<br class="title-page-name"/>    SAVE: string;<br class="title-page-name"/>    CANCEL: 

string;<br class="title-page-name"/>    SELECT: string;<br class="title-page-name"/>    OPEN_RECORD: string;<br class="title-page-name"/>    UPDATE: string;<br class="title-page-name"/>    UPDATED: string;<br class="title-page-name"/>  }

<br class="title-page-name"/><br class="title-page-name"/>  export const ActionTypes: IMixerActions = {<br class="title-page-name"/>    INIT: `${CATEGORY} Init`,<br class="title-page-name"/>    ADD: `${CATEGORY} 

Add`,<br class="title-page-name"/>    EDIT: `${CATEGORY} Edit`,<br class="title-page-name"/>    SAVE: `${CATEGORY} Save`,<br class="title-page-name"/>    CANCEL: `${CATEGORY} Cancel`,<br class="title-page-name"/>    

SELECT: `${CATEGORY} Select`,<br class="title-page-name"/>    OPEN_RECORD: `${CATEGORY} Open Record`,<br class="title-page-name"/>    UPDATE: `${CATEGORY} Update`,<br class="title-page-name"/> 

   UPDATED: `${CATEGORY} Updated`,<br class="title-page-name"/>  };<br class="title-page-name"/><br class="title-page-name"/>  export class InitAction implements Action {<br class="title-page-name"/>    type = 

ActionTypes.INIT;<br class="title-page-name"/>    payload = null;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  export class AddAction implements Action {<br class="title-page-name"/>    type = 

ActionTypes.ADD;<br class="title-page-name"/>    payload = null;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  export class EditAction implements Action {<br class="title-page-name"/>    type = 

ActionTypes.EDIT;<br class="title-page-name"/>    constructor(public payload: CompositionModel) { }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  export class SaveAction 

implements Action {<br class="title-page-name"/>    type = ActionTypes.SAVE;<br class="title-page-name"/>    constructor(public payload?: Array&lt;CompositionModel&gt;) 

{ }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  export class CancelAction implements Action {<br class="title-page-name"/>    type = ActionTypes.CANCEL;<br class="title-page-name"/>    

payload = null;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  export class SelectAction implements Action {<br class="title-page-name"/>    type = ActionTypes.SELECT;<br class="title-page-name"/>    constructor(public payload: CompositionModel) { }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  export class OpenRecordAction implements 

Action {<br class="title-page-name"/>    type = ActionTypes.OPEN_RECORD;<br class="title-page-name"/>    constructor(public payload?: { <br class="title-page-name"/>      vcRef: 

ViewContainerRef, track?: TrackModel <br class="title-page-name"/>    }) { }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  export class UpdateAction implements Action 

{<br class="title-page-name"/>    type = ActionTypes.UPDATE;<br class="title-page-name"/>    constructor(public payload: CompositionModel) { }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  

export class UpdatedAction implements Action {<br class="title-page-name"/>    type = ActionTypes.UPDATED;<br class="title-page-name"/>    constructor(public payload: 

IMixerState) { }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  export type Actions =<br class="title-page-name"/>    InitAction<br class="title-page-name"/>    | AddAction<br class="title-page-name"/>    | 

EditAction<br class="title-page-name"/>    | SaveAction<br class="title-page-name"/>    | CancelAction<br class="title-page-name"/>    | SelectAction<br class="title-page-name"/>    | OpenRecordAction<br class="title-page-name"/>    | 

UpdateAction<br class="title-page-name"/>    | UpdatedAction;<br class="title-page-name"/>}</pre>
<p class="mce-root">Similar to our UserActions, we will also use an <kbd class="calibre11">INIT</kbd> action to autoinitialize this state with user-saved compositions (or our sample demo composition to start). Here's a quick rundown:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre11">INIT</kbd>: To initialize the mixer right when the app launches. Just as we did with <kbd class="calibre11">UserActions</kbd>, this action will be used to check persistence and restore any user-saved compositions onto the mixer state at launch time.</li>
<li class="calibre14"><kbd class="calibre11">ADD</kbd>: Show the add new composition dialog.</li>
<li class="calibre14"><kbd class="calibre11">EDIT</kbd>: Edit a composition's name by prompting a dialog.</li>
<li class="calibre14"><kbd class="calibre11">SAVE</kbd>: Save compositions.</li>
<li class="calibre14"><kbd class="calibre11">CANCEL</kbd>: General action to cancel out of any effect chain.</li>
<li class="calibre14"><kbd class="calibre11">SELECT</kbd>: Select a composition. We will use this action to drive the Angular router to the main selected composition view.</li>
<li class="calibre14"><kbd class="calibre11">OPEN_RECORD</kbd>: Handle the preparation of opening the recording view, including checking for authentication, pausing playback if playing, and opening in modal or routing to it.</li>
<li class="calibre14"><kbd class="calibre11">UPDATE</kbd>: Initiate an update to a composition.</li>
<li class="calibre14"><kbd class="calibre11">UPDATED</kbd>: This will generally not be dispatched directly, but used at the end of an effect sequence that the reducer will pick up to finally change the mixer state.</li>
</ul>
<p class="mce-root">Now, we can create the reducer that is similar to our user reducer:</p>
<pre class="calibre22">import { IMixerState, mixerInitialState } from '../states';<br class="title-page-name"/>import { MixerActions } from '../actions';<br class="title-page-name"/><br class="title-page-name"/>export function mixerReducer(<br class="title-page-name"/>  state: IMixerState = mixerInitialState,<br class="title-page-name"/>  action: MixerActions.Actions<br class="title-page-name"/>): 

IMixerState {<br class="title-page-name"/>  switch (action.type) {<br class="title-page-name"/>    case MixerActions.ActionTypes.UPDATED:<br class="title-page-name"/>      return 

Object.assign({}, state, action.payload);<br class="title-page-name"/>    default:<br class="title-page-name"/>      return state;<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">After this, let's create our <kbd class="calibre11">MixerEffects</kbd> at <kbd class="calibre11">app/modules/mixer/effects/mixer.effect.ts</kbd>:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { Injectable, ViewContainerRef } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>// nativescript<br class="title-page-name"/>import { RouterExtensions } from 'nativescript-angular/router';<br class="title-page-name"/><br class="title-page-name"/>// libs<br class="title-page-name"/>import { Store, Action } from 

'@ngrx/store';<br class="title-page-name"/>import { Effect, Actions } from '@ngrx/effects';<br class="title-page-name"/>import { Observable } from 

'rxjs/Observable';<br class="title-page-name"/><br class="title-page-name"/>// module<br class="title-page-name"/>import { CompositionModel } from '../../shared/models';<br class="title-page-name"/>import { 

PlayerActions } from '../../player/actions';<br class="title-page-name"/>import { RecordComponent } from 

'../../recorder/components/record.component';<br class="title-page-name"/>import { MixerService } from '../services/mixer.service';<br class="title-page-name"/>import { 

MixerActions } from '../actions';<br class="title-page-name"/><br class="title-page-name"/>@Injectable()<br class="title-page-name"/>export class MixerEffects {<br class="title-page-name"/><br class="title-page-name"/>  @Effect() 

init$: Observable&lt;Action&gt; = this.actions$<br class="title-page-name"/>    .ofType(MixerActions.ActionTypes.INIT)<br class="title-page-name"/>    .startWith(new 

MixerActions.InitAction())<br class="title-page-name"/>    .map(action =&gt;<br class="title-page-name"/>      new MixerActions.UpdatedAction({<br class="title-page-name"/>        

compositions: this.mixerService.hydrate(<br class="title-page-name"/>          this.mixerService.savedCompositions()<br class="title-page-name"/>          || 

this.mixerService.demoComposition())<br class="title-page-name"/>      })<br class="title-page-name"/>    );<br class="title-page-name"/><br class="title-page-name"/>  @Effect() add$: Observable&lt;Action&gt; = 

this.actions$<br class="title-page-name"/>    .ofType(MixerActions.ActionTypes.ADD)<br class="title-page-name"/>    .withLatestFrom(this.store)<br class="title-page-name"/>    .switchMap

(([action, state]) =&gt;<br class="title-page-name"/>      Observable.fromPromise(this.mixerService.add())<br class="title-page-name"/>        .map(value =&gt; {<br class="title-page-name"/>   

       if (value.result) {<br class="title-page-name"/>            let compositions = [...state.mixerModule.mixer.compositions];<br class="title-page-name"/>            

let composition = new CompositionModel({<br class="title-page-name"/>              id: compositions.length + 1,<br class="title-page-name"/>              name: 

value.text,<br class="title-page-name"/>              order: compositions.length // next one in line<br class="title-page-name"/>            });<br class="title-page-name"/>            

compositions.push(composition);<br class="title-page-name"/>            // persist changes<br class="title-page-name"/>            return new MixerActions.SaveAction

(compositions);<br class="title-page-name"/>          } else {<br class="title-page-name"/>            return new MixerActions.CancelAction();<br class="title-page-name"/>          }<br class="title-page-name"/>     

   })<br class="title-page-name"/>    );<br class="title-page-name"/><br class="title-page-name"/>  @Effect() edit$: Observable&lt;Action&gt; = this.actions$<br class="title-page-name"/>    .ofType

(MixerActions.ActionTypes.EDIT)<br class="title-page-name"/>    .withLatestFrom(this.store)<br class="title-page-name"/>    .switchMap(([action, state]) =&gt; {<br class="title-page-name"/>    

  const composition = action.payload;<br class="title-page-name"/>      return Observable.fromPromise(this.mixerService.edit(composition.name))<br class="title-page-name"/>        .map(value =&gt; {<br class="title-page-name"/>          if (value.result) {<br class="title-page-name"/>            let compositions = 

[...state.mixerModule.mixer.compositions];<br class="title-page-name"/>            for (let i = 0; i &lt; compositions.length; i++) {<br class="title-page-name"/>        

      if (compositions[i].id === composition.id) {<br class="title-page-name"/>                compositions[i].name = value.text;<br class="title-page-name"/>            

    break;<br class="title-page-name"/>              }<br class="title-page-name"/>            }<br class="title-page-name"/>            // persist changes<br class="title-page-name"/>            return new 

MixerActions.SaveAction(compositions);<br class="title-page-name"/>          } else {<br class="title-page-name"/>            return new MixerActions.CancelAction();<br class="title-page-name"/>          }<br class="title-page-name"/>        })<br class="title-page-name"/>      });<br class="title-page-name"/><br class="title-page-name"/>  @Effect() update$: Observable&lt;Action&gt; = this.actions

$<br class="title-page-name"/>    .ofType(MixerActions.ActionTypes.UPDATE)<br class="title-page-name"/>    .withLatestFrom(this.store)<br class="title-page-name"/>    .map(([action, state]) 

=&gt; {<br class="title-page-name"/>      let compositions = [...state.mixerModule.mixer.compositions];<br class="title-page-name"/>      const composition = 

action.payload;<br class="title-page-name"/>      for (let i = 0; i &lt; compositions.length; i++) {<br class="title-page-name"/>        if (compositions[i].id === 

composition.id) {<br class="title-page-name"/>          compositions[i] = composition;<br class="title-page-name"/>          break;<br class="title-page-name"/>        }<br class="title-page-name"/>      }<br class="title-page-name"/>     

 // persist changes<br class="title-page-name"/>      return new MixerActions.SaveAction(compositions);<br class="title-page-name"/>    });<br class="title-page-name"/><br class="title-page-name"/>  @Effect() 

select$: Observable&lt;Action&gt; = this.actions$<br class="title-page-name"/>    .ofType(MixerActions.ActionTypes.SELECT)<br class="title-page-name"/>    .map(action 

=&gt; {<br class="title-page-name"/>      this.router.navigate(['/mixer', action.payload.id]);<br class="title-page-name"/>      return new MixerActions.UpdatedAction

({<br class="title-page-name"/>        activeComposition: action.payload<br class="title-page-name"/>      });<br class="title-page-name"/>    });<br class="title-page-name"/><br class="title-page-name"/>  @Effect({ dispatch: false }) 

openRecord$: Observable&lt;Action&gt; = this.actions$<br class="title-page-name"/>    .ofType(MixerActions.ActionTypes.OPEN_RECORD)<br class="title-page-name"/>    

.withLatestFrom(this.store)<br class="title-page-name"/>    // always pause/reset playback before handling<br class="title-page-name"/>    .do(action =&gt; new 

PlayerActions.PauseAction(0))<br class="title-page-name"/>    .map(([action, state]) =&gt; {<br class="title-page-name"/>      if 

(state.mixerModule.mixer.activeComposition &amp;&amp;<br class="title-page-name"/>        state.mixerModule.mixer.activeComposition.tracks.length) 

{<br class="title-page-name"/>        // show record modal but check authentication<br class="title-page-name"/>        if (state.user.current) {<br class="title-page-name"/>          if 

(action.payload.track) {<br class="title-page-name"/>            // rerecording<br class="title-page-name"/>            this.dialogService<br class="title-page-name"/>              .confirm

(<br class="title-page-name"/>                'Are you sure you want to re-record this track?'<br class="title-page-name"/>              ).then((ok) =&gt; {<br class="title-page-name"/>        

        if (ok) <br class="title-page-name"/>                  this._showRecordModal(<br class="title-page-name"/>                    action.payload.vcRef, <br class="title-page-name"/>        

            action.payload.track<br class="title-page-name"/>                  );<br class="title-page-name"/>              });<br class="title-page-name"/>          } else {<br class="title-page-name"/>            

this._showRecordModal(action.payload.vcRef);<br class="title-page-name"/>          }<br class="title-page-name"/>        } else {<br class="title-page-name"/>          this.store.dispatch(<br class="title-page-name"/>            new UserActions.LoginToRecordAction(action.payload));<br class="title-page-name"/>        }<br class="title-page-name"/>      } else {<br class="title-page-name"/>        // 

navigate to it<br class="title-page-name"/>        this.router.navigate(['/record']);<br class="title-page-name"/>      }<br class="title-page-name"/>      return action;<br class="title-page-name"/>    });<br class="title-page-name"/><br class="title-page-name"/>  @Effect() save$: Observable&lt;Action&gt; = this.actions$<br class="title-page-name"/>    .ofType(MixerActions.ActionTypes.SAVE)<br class="title-page-name"/>    

.withLatestFrom(this.store)<br class="title-page-name"/>    .map(([action, state]) =&gt; {<br class="title-page-name"/>      const compositions = action.payload || <br class="title-page-name"/>                           state.mixerModule.mixer.compositions;<br class="title-page-name"/>      // persist<br class="title-page-name"/>      this.mixerService.save

(compositions);<br class="title-page-name"/>      return new MixerActions.UpdatedAction({ compositions });<br class="title-page-name"/>    });<br class="title-page-name"/><br class="title-page-name"/>  constructor

(<br class="title-page-name"/>    private store: Store&lt;any&gt;,<br class="title-page-name"/>    private actions$: Actions,<br class="title-page-name"/>    private router: 

RouterExtensions,<br class="title-page-name"/>    private dialogService: DialogService,<br class="title-page-name"/>    private mixerService: MixerService<br class="title-page-name"/>  ) { }

<br class="title-page-name"/><br class="title-page-name"/>  private _showRecordModal(vcRef: ViewContainerRef, track?: TrackModel) {<br class="title-page-name"/>    let context: any = { 

isModal: true };<br class="title-page-name"/>    if (track) {<br class="title-page-name"/>      // re-recording track<br class="title-page-name"/>      context.track = track;<br class="title-page-name"/>    }<br class="title-page-name"/>  

  this.dialogService.openModal(<br class="title-page-name"/>      RecordComponent,<br class="title-page-name"/>      vcRef,<br class="title-page-name"/>      context,<br class="title-page-name"/>      

'./modules/recorder/recorder.module#RecorderModule'<br class="title-page-name"/>    );<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">Probably, the most interesting effect is the<strong class="calibre1"> </strong><kbd class="calibre11">openRecord$</kbd> chain. We use <kbd class="calibre11">@Effect({ dispatch: false })</kbd> to indicate that it should not dispatch any actions at the end as we are using it to execute work directly, such as checking whether the user is authenticated or if <kbd class="calibre11">activeComposition</kbd> contains tracks to conditionally open record view in a modal or as a route. We make use of another operator:</p>
<pre class="calibre22">.do(action =&gt; new PlayerActions.PauseAction(0))</pre>
<p class="mce-root">This allows us to insert an arbitrary action without affecting the sequence of events. In this case, we ensure that playback is always paused when the user attempts to open a record view (since they can attempt to open the record view while playback is playing). We are presenting a few more advanced usage options with this chain, just to show what is possible. We are also stepping ahead a bit since we have not shown the creation of <kbd class="calibre11">PlayerActions</kbd> yet; however, we will just be presenting a couple of highlights in this chapter.</p>
<p class="mce-root">With this effect chain, we can simplify our <kbd class="calibre11">MixerService</kbd> with the following:</p>
<pre class="calibre22">...<br class="title-page-name"/>@Injectable()<br class="title-page-name"/>export class MixerService {<br class="title-page-name"/>  ...<br class="title-page-name"/>  public add() {<br class="title-page-name"/>    <strong class="calibre1">return 

this.dialogService.prompt('Composition name:');</strong><br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public edit(name: string) {<br class="title-page-name"/>    

<strong class="calibre1">return this.dialogService.prompt('Edit name:', name);</strong><br class="title-page-name"/>  }<br class="title-page-name"/>  ...</pre>
<p class="mce-root">We've simplified the service logic, leaving most of the result handling work inside the effects chain. You might decide to leave the service with more logic and keep the effects chain simpler; however, we have designed this setup as an example to show more alternate setups with how flexible ngrx is.</p>
<p class="mce-root">To finish up our lazy loaded state handling, ensure that these effects are run; when <kbd class="calibre11">MixerModule</kbd> loads, we can make these adjustments to the module:</p>
<pre class="calibre22">...<br class="title-page-name"/>// libs<br class="title-page-name"/>import { StoreModule } from '@ngrx/store';<br class="title-page-name"/><strong class="calibre1">import { EffectsModule } from 

'@ngrx/effects';</strong><br class="title-page-name"/>...<br class="title-page-name"/><strong class="calibre1">import { MixerEffects } from './effects';</strong><br class="title-page-name"/><strong class="calibre1">import 

{ mixerReducer } from './reducers';</strong><br class="title-page-name"/><br class="title-page-name"/>@NgModule({<br class="title-page-name"/>  imports: [<br class="title-page-name"/>    PlayerModule,<br class="title-page-name"/>    

SharedModule,<br class="title-page-name"/>    NativeScriptRouterModule.forChild(routes),<br class="title-page-name"/>    // mixer state<br class="title-page-name"/>    StoreModule.forFeature

('mixerModule', {<br class="title-page-name"/>      mixer: <strong class="calibre1">mixerReducer</strong><br class="title-page-name"/>    }),<br class="title-page-name"/>    // mixer effects<br class="title-page-name"/>    

<strong class="calibre1">EffectsModule.forFeature([<br class="title-page-name"/>      MixerEffects<br class="title-page-name"/>    ])</strong><br class="title-page-name"/>  ],<br class="title-page-name"/>  ...<br class="title-page-name"/>})<br class="title-page-name"/>export 

class MixerModule { }</pre>
<p class="mce-root">Now, let's look at how this improves our component handling, starting with <kbd class="calibre11">app/modules/mixer/components/mixer.component.ts</kbd>:</p>
<pre class="calibre22">...<br class="title-page-name"/>export class MixerComponent implements OnInit, OnDestroy {<br class="title-page-name"/>  ...<br class="title-page-name"/>  constructor(<strong class="calibre1"><br class="title-page-name"/>    

private store: Store&lt;any&gt;,<br class="title-page-name"/>    private vcRef: ViewContainerRef<br class="title-page-name"/></strong>  ) { }<br class="title-page-name"/><br class="title-page-name"/>  ngOnInit() 

{<br class="title-page-name"/>    <strong class="calibre1">this._sub = this.store.select(s =&gt; s.mixerModule.mixer)</strong><br class="title-page-name"/><strong class="calibre1">      .subscribe

((state: IMixerState) =&gt; {</strong><br class="title-page-name"/><strong class="calibre1">        this.composition = state.activeComposition;</strong><br class="title-page-name"/><strong class="calibre1">      });</strong><br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public record(track?: TrackModel) {<br class="title-page-name"/>    

<strong class="calibre1">this.store.dispatch(new MixerActions.OpenRecordAction({</strong><br class="title-page-name"/><strong class="calibre1">      vcRef: this.vcRef,</strong><br class="title-page-name"/><strong class="calibre1">      track</strong><br class="title-page-name"/><strong class="calibre1">    }));</strong><br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  <strong class="calibre1">ngOnDestroy() {</strong><br class="title-page-name"/><strong class="calibre1">    this._sub.unsubscribe();</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/>}</pre>
<p class="mce-root">This time, inside <kbd class="calibre11">ngOnInit</kbd>, we just set up the component to be reactive to our mixer's state by setting the composition to the <kbd class="calibre11">activeComposition</kbd>. This is guaranteed to always be whichever composition the user has currently selected and is working on. We dispatch our <kbd class="calibre11">OpenRecordAction</kbd> inside the <kbd class="calibre11">record</kbd> method, passing along the proper <kbd class="calibre11">ViewContainerRef</kbd> and a track if the user is rerecording.</p>
<p class="mce-root">Next up is the simplification of <kbd class="calibre11">app/modules/mixer/components/mix-list.component.ts</kbd>:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { Component } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>// libs<br class="title-page-name"/><strong class="calibre1">import { Store } from 

'@ngrx/store';</strong><br class="title-page-name"/><strong class="calibre1">import { Observable } from 'rxjs/Observable';</strong><br class="title-page-name"/><br class="title-page-name"/>// app<br class="title-page-name"/><strong class="calibre1">import { MixerActions } from '../actions';</strong><br class="title-page-name"/><strong class="calibre1">import { IMixerState } from '../states';</strong><br class="title-page-name"/><br class="title-page-name"/>@Component({<br class="title-page-name"/>  moduleId: module.id,<br class="title-page-name"/>  selector: 'mix-list',
  templateUrl: 'mix-list.component.html'<br class="title-page-name"/>})<br class="title-page-name"/>export class MixListComponent {<br class="title-page-name"/>  <strong class="calibre1">public mixer$: Observable&lt;IMixerState&gt;;</strong><br class="title-page-name"/><br class="title-page-name"/>  constructor(private store: Store&lt;any&gt;) {<br class="title-page-name"/>    <strong class="calibre1">this.mixer$ = store.select(s =&gt; s.mixerModule.mixer);</strong><br class="title-page-name"/>  } <br class="title-page-name"/> <br class="title-page-name"/>  public add() {<br class="title-page-name"/>    <strong class="calibre1">this.store.dispatch(new MixerActions.AddAction());</strong><br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public edit(composition) {<br class="title-page-name"/>    <strong class="calibre1">this.store.dispatch(new MixerActions.EditAction(composition));</strong><br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public select(composition) {<br class="title-page-name"/>    <strong class="calibre1">this.store.dispatch(new MixerActions.SelectAction(composition));</strong><br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">We have removed the <kbd class="calibre11">MixerService</kbd> injection and made it reactive by setting up a state Observable--<kbd class="calibre11">mixer$</kbd>--and integrated our <kbd class="calibre11">MixerActions</kbd>. This lightens up the component, making it easier to test and maintain since it no longer has an explicit dependency on the <kbd class="calibre11">MixerService</kbd>, which was previously being used for view bindings as well. If we take a look at the view, we can now utilize Angular's async pipe to gain access to the user-saved compositions via the state:</p>
<pre class="calibre22">&lt;ActionBar title="Compositions" class="action-bar"&gt;<br class="title-page-name"/>  &lt;ActionItem (tap)="add()" 

ios.position="right"&gt;<br class="title-page-name"/>    &lt;Button text="New" class="action-item"&gt;&lt;/Button&gt;<br class="title-page-name"/>  

&lt;/ActionItem&gt;<br class="title-page-name"/>&lt;/ActionBar&gt;<br class="title-page-name"/>&lt;ListView [items]="<strong class="calibre1">(mixer$ | async)?.compositions</strong> | 

orderBy: 'order'" class="list-group"&gt;<br class="title-page-name"/>  &lt;ng-template let-composition="item"&gt;<br class="title-page-name"/>    &lt;GridLayout 

rows="auto" columns="100,*,auto" class="list-group-item"&gt;<br class="title-page-name"/>      &lt;Button text="Edit" (tap)="edit(composition)" 

row="0" col="0"&gt;&lt;/Button&gt;<br class="title-page-name"/>      &lt;Label [text]="composition.name" (tap)="select(composition)" row="0" 

col="1" class="h2"&gt;&lt;/Label&gt;<br class="title-page-name"/>      &lt;Label [text]="composition.tracks.length" row="0" col="2" class="text-

right"&gt;&lt;/Label&gt;<br class="title-page-name"/>    &lt;/GridLayout&gt;<br class="title-page-name"/>  &lt;/ng-template&gt;<br class="title-page-name"/>&lt;/ListView&gt;</pre>
<div class="packt_infobox">From the official documentation: Angular's async pipe subscribes to an Observable or Promise and returns the latest value it has emitted. When a new value is emitted, the async pipe marks the component to be checked for changes. When the component gets destroyed, the async pipe unsubscribes automatically to avoid potential memory leaks.</div>
<p class="mce-root">This is truly remarkable and incredibly handy, allowing us to create reactive components that're highly maintainable and flexible.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Inspect the code! Exploring more on your own</h1>
                
            
            <article>
                
<p class="mce-root">Since a lot of what we saw earlier are the exact same principles applied to the rest of our code base, instead of increasing the size of this book further, we invite you to explore the rest of the ngrx integration in the same chapter branch on the accompanying code repository to this book.</p>
<p class="mce-root">Looking through the actual code, running it, and even stepping through it will hopefully give you a solid understanding of how ngrx fits into your app and the many advantages it can bring.</p>
<p class="mce-root">The community is lucky to have members like Rob Wormald, Mike Ryan, Brian Troncone, Brandon Roberts, and more, who have helped make ngrx so nice to use, so a <strong class="calibre1">huge thank you to all the contributors</strong>!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="mce-root">Hopefully, you are starting to see a pattern of simplification and clarity to the data flow while integrating ngrx. It has helped reduce code, while improving data flow by providing consistent effect chains to various actions, which may need to occur anywhere (from lazy loaded modules or not). By reducing the overhead of managing explicit injected dependencies throughout and instead relying on Store and Actions to initiate the appropriate work, we are increasing the maintainability and scalability of our app. On top of all that, it is paving a pathway to effective testability, which we will cover in <a href="part0136.html#41MCG0-289fe2426d594f99a90e4363b2c9c34d" class="calibre3">Chapter 12</a>, <em class="calibre21">Unit Testing</em>.</p>
<p class="mce-root">This chapter highlighted the additional advantages when combining NativeScript with Angular by opening up integration potential with rich libraries such as ngrx to improve our app's architecture and data flow.</p>
<p class="mce-root">It's been a long time coming, and we couldn't be more excited about <a href="part0131.html#3STPM0-289fe2426d594f99a90e4363b2c9c34d" class="calibre3">Chapter 11</a>, <em class="calibre21">Polish with SASS</em>, coming up next. Finally, we are ready to polish our app to give it that special spark!</p>


            </article>

            
        </section>
    </body></html>