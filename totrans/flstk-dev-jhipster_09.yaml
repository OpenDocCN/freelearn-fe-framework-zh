- en: Building Microservices with JHipster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it's time to build a full-fledged microservices stack. So far, we have
    generated, developed, and deployed a monolithic application using JHipster, and
    in the previous chapter, we saw the benefits offered by a microservice stack.
    In this chapter, we will look at how to build microservices with JHipster.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by converting our monolithic store application into a microservice
    gateway application. Next, we will add a new functionality to our e-commerce shop
    as a separate microservice application. We will then see how these applications
    communicate with each other and work as a single application for our end users.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate a Gateway application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run through the generated code
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: See a brief introduction to JWT
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generate a microservice application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoice service
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Notification service
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Application architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We built an online e-commerce shop using JHipster in [Chapter 3](3c863445-9d8d-4cd3-b14e-5331593913e3.xhtml),
    *Building Monolithic Web Applications* with JHipster. It was built as a monolith
    since the scope was small and it was an easier choice to start with. Let's say
    that our e-commerce store has grown tremendously in terms of users and scope,
    resulting in a more demanding situation. The team is finding it difficult to roll
    out features faster with the monolithic architecture, and would like to have more
    control over individual parts of the application.
  prefs: []
  type: TYPE_NORMAL
- en: One of the solutions to this problem would be to adopt a microservice architecture.
    The application was created using JHipster; the option to move to microservices
    is much easier to accomplish. JHipster follows the **proxy microservice pattern**
    in which there is an aggregator/proxy in front of the services, which acts as
    the gateway for the end users. In much simpler terms, JHipster creates a gateway
    (which handles all the user requests) and the individual services that talk via
    the gateway to the users.
  prefs: []
  type: TYPE_NORMAL
- en: This said, we need to have a gateway service, along with one or a few microservice
    applications that can run alone.
  prefs: []
  type: TYPE_NORMAL
- en: Our customers are facing some issues regarding invoicing, since it is taking
    longer for the system to respond. Customers are also complaining that they are
    not receiving notifications so they can track their orders. To solve this, we
    will remove the invoice service from our monolithic application and make it a
    separate service, and then create a separate **Notification Service** that will
    take care of the notifications. For the former, we will stick with the same SQL
    database. For the latter, we will use the NoSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the application architecture that we are going to generate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a4c466f-edc1-453a-9658-6cc03e7fe770.png)'
  prefs: []
  type: TYPE_IMG
- en: Gateway application generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start by converting the monolithic application that we have generated
    into a microservice gateway application.
  prefs: []
  type: TYPE_NORMAL
- en: Even though microservices are made up of different services inside, for end
    users it should be a single, unified product. There are a lot of services that
    are designed to work in a lot of different ways, but there should be a single
    entry point for users. Thus, we need a gateway application, since they form the
    frontend of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Segregate the internal contracts and services from external users. We may have
    application-level internal services that we shouldn't expose to external users,
    so these can be masked away. This also adds another level of security to the application.
  prefs: []
  type: TYPE_NORMAL
- en: Easier to mock services for testing help validate the services independently
    in integration testing.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a monolithic application to a microservice gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already have our monolithic application generated, as well as our entities.
    As a part of monolithic application generation, we have already selected some
    options via JHipster CLI. We will stick to the same options (the database, authentication
    type, package name, i18n, and so on) when we generate the microservice gateway
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: We will see how the customizations that we applied in the monolithic
    app can be applied to the gateway later.'
  prefs: []
  type: TYPE_NORMAL
- en: It's coding time now, so let's start building a gateway application using JHipster
    CLI.
  prefs: []
  type: TYPE_NORMAL
- en: The first step here is to convert the monolithic app into a microservice gateway
    application with almost the same configuration that we used when we created a
    monolithic application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move to the Terminal (Command Prompt, if you are using Windows) now,
    and start by navigating to the folder where we created the monolithic application.
    Once you''re in the folder, create a new Git branch so that we can do a clean
    merge back to master once we are done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the `.yo-rc.json` file in your favorite text editor or IDE and change
    the following value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c58dc656-48af-47ab-8020-75c30440f768.png)'
  prefs: []
  type: TYPE_IMG
- en: In order to make the monolith into a microservice gateway application, we can
    just change the preceding values in the `.yo-rc.json` file. We have added the
    service discovery type to Eureka since for monolithic applications, it is not
    mandatory to have service discovery.
  prefs: []
  type: TYPE_NORMAL
- en: Also, obviously, the next change is to change the application type from monolith
    to gateway.
  prefs: []
  type: TYPE_NORMAL
- en: Application generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s run the `jhipster` command to generate the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e157b3a8-ae89-494b-bae6-9ab95f4d9f7a.png)'
  prefs: []
  type: TYPE_IMG
- en: JHipster then asks whether you want to overwrite the conflicting files or use
    your existing ones, as well as a few other options. Users can use any one of the
    desired options.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, we will choose option `a`. It will overwrite all of the other files,
    including the highlighted file.
  prefs: []
  type: TYPE_NORMAL
- en: This prompt is extremely useful if you have a lot of custom code written on
    your application. You can choose the appropriate option to get the desired result.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a386280-9640-4fd0-84c8-8487b2d4bb17.png)'
  prefs: []
  type: TYPE_IMG
- en: This will overwrite all the customizations we did in our monolithic application.
    We can easily bring them back into this branch by cherry picking the required
    changes from our master branch using GIT. You can follow a similar approach to
    the one we saw in [Chapter 5](63e6ed92-1616-40b7-86b8-1b3332fcbfb7.xhtml), *Customization
    and Further Development*, for that. Once all changes are applied, we can merge
    this branch back into the master. You will have to do the same for entity files
    as well in [Chapter 10](28229d3b-052f-436e-9dc9-322727b9be4a.xhtml), *Working
    with Microservices*.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a new Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you do not want to convert the existing monolith and want to start fresh,
    then follow these steps.
  prefs: []
  type: TYPE_NORMAL
- en: In the Terminal, navigate to the `e-commerce-app` folder and create a new folder
    called `app-gateway`,  change the directory to `app-gateway`, and run the `jhipster` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, obviously, the first question is, Which *type* of application would we
    like to create? We will select the Microservice gateway (third option) and then
    click *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bfa5cc5a-e486-4c5d-b189-0ce4693d240c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we will enter the base name of our application. We will use the name
    `store`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ffbf974-3a76-47c8-b4b4-a9bb4122d43b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we are working with microservices, there is a high risk of having port
    conflicts. In order to avoid them, JHipster will ask you to select a port for
    each microservice application (both gateway and application). By default, we will
    have `8080` as the port, but we can change the port as necessary. For now, we
    will use the default port since the gateway will run on `8080`, similar to what
    our monolithic application had:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d85a3d1-a89a-4e9b-8f5f-ced6207d3cc6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we enter the package name for our application. We will use the default
    name that is available, which is `com.mycompany.store`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d47aabf3-4b7b-48b1-bed7-e98a36b075b1.png)'
  prefs: []
  type: TYPE_IMG
- en: For the next question, JHipster will ask you to configure the registry service.
    We will select the necessary registry service to configure, monitor, and scale
    our microservices and gateway application. We can either choose to use the JHipster
    registry or Consul. This is also optional; we don't need to choose any registry
    service here. We can then select No service discovery.
  prefs: []
  type: TYPE_NORMAL
- en: When you select No service discovery, the microservice URLs are hardcoded in
    the property files.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/804d5adf-7774-4922-bdcf-2509505072f5.png)'
  prefs: []
  type: TYPE_IMG
- en: For the next question, JHipster will ask you to select the authentication type.
    JHipster provides three options for the authentication type, which are JWT, OAuth2,
    and UAA server-based. JWT is stateless, while the UAA runs on a different server
    (and application altogether). OAuth2, on the other hand, will provide authorization
    tokens, while the authorization is done on the third-party system.
  prefs: []
  type: TYPE_NORMAL
- en: JHipster does provide an option to create a UAA server application.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at JWT in more detail shortly. For now, we will select JWT authentication.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/443b3149-1253-4a02-aa27-54bb51cbb2b2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will select the database type next. We have an option to select either SQL
    and NoSQL. In terms of NoSQL, we can choose MongoDB or Cassandra. We will select
    the SQL database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84c34984-58bb-4d75-a980-1dda176da298.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, we will select the database that we will be using for production and development.
    JHipster provides an option to use a different database for your production and
    development environment. This really helps to kick-start application development
    faster and easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will select a MySQL database for production:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aeb5da7b-b329-4619-aac0-b210a80dcff4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we will select H2 with disk-based persistence for development:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7d52a14-8a6e-4e02-9308-16911416e47d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Following the databases, we will select yes for the second level hibernate
    cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b6f1490-0960-4328-ba4d-38618a10e329.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we will select Gradle for building the backend. We have an option to
    select Gradle for the backend development:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a48dce56-58d2-4880-b47e-8d93dc072e52.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we can select any other additional technologies that we need to use.
    JHipster provides an option to select Elasticsearch, using Hazelcast for clustered
    applications, WebSockets, and Swagger Codegen for API-based development and Kafka-based
    asynchronous messaging. We will select WebSockets here, similar to what we used
    in our monolithic store:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d69c4e3c-e728-47eb-a145-37edc6a2c490.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since our gateway application needs a user interface, for the next question
    we can choose the framework that we need to use for the client. We will select
    `Angular 5` for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/419cca66-7b4e-449d-9c6b-76a92e9b7be8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we will select whether we need to use a SASS-based preprocessor for the
    CSS. We will use SASS here, so we will select y:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/352fdcac-4156-4c4c-a5ae-71e47f12cd1d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we will select whether we need to enable internationalization support.
    We will select yes for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fc1836a-ec40-47ce-a0fd-bd32b0218efc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we will choose English as our native language:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5173b16-8f5f-4751-a6e1-6eee2d2e5b3a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, choose any other additional languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/166821e5-0441-48ac-99fa-6571be79b2f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, select any other testing frameworks, such as Gatling, Cucumber, and/or
    Protractor, since this is required. We will select Protractor as the testing tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9732311a-69d6-4d73-961d-51b0660747fc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, JHipster asks us to install any other generators from the marketplace;
    we will select no here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d93c0cd7-4a57-4c2b-b0a4-69e9472ef74e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will create all the necessary files and install the frontend dependencies
    using Yarn:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6135ec47-8d4a-4998-b5d6-4ae12bb2c9b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, our gateway application is generated. JHipster will automatically commit
    the generated files to Git; if you wish to do this step yourself, you can do so
    by passing the `skip-git` flag during execution, for example, `jhipster --skip-git`,
    and executing the steps manually as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Gateway configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The gateway application is generated in a similar fashion to the monolithic
    application, except for configurations related to Zuul proxy, Eureka Client, and
    Hystrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We have selected the JHipster registry for our registry service. This will
    be a standalone registry server which other microservice applications and gateways
    will register itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@EnableDiscoveryClient` is added to Spring Boot''s main class, which will
    enable the Netflix Discovery Client. The microservice applications and gateways need
    to register themselves to the registry service. It uses Spring Cloud''s discovery
    client abstraction to interrogate its own host and port, and then adds them to
    the registry server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zuul, on the other hand, is the gatekeeper. This helps route the authorized
    requests to the respective endpoints, limits the requests per route, and relays
    the necessary tokens to the microservice application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@EnableZuulProxy` helps the microservice gateway application route the requests
    to the applicable microservice application based on the configurations provided
    in the `application.yml`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the gateway app, we have specified the aforementioned settings  for Zuul
    configuration. The maximum number of total connections that a proxy can hold open
    is kept at `1000`. The maximum number of route connections that a proxy can hold
    open is kept at `100`. Semaphore is kept to a maximum of `500`. (Semaphore is
    like a counter that is used for synchronization between threads and processes.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Access to the backend microservice endpoint is controlled by `AccessControlFilter`,
    which will check whether the request is authorized, and is allowed to request
    the endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Zuul, as a gatekeeper, also acts as a rate limiter. A rate-limiting filter
    is added to the generated application, which limits the number of HTTP calls that
    are made per client. This is enabled conditionally with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`SwaggerBasePathRewritingFilter` is also used, which will help to rewrite the
    microservice Swagger URL base path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'A `TokenRelayFilter` is added to remove the authorization from Zuul''s ignore
    list. This will help to propagate the generated authorization token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Each application should have a Eureka client that helps load balance the requests
    among the services, as well as sending health information to the Eureka Server
    or registries. The Eureka client is configured in `application-dev.yml` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have chosen to enable health checks and have the interval to register and
    replicate be within `10` seconds, as well as instances where we define the lease
    renewal interval and expiration duration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will configure timeout in Hystrix, beyond which the server is considered
    to be closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If the server does not respond within `10` seconds, then the server is considered
    dead and is registered in the registry service. This makes sure no subsequent
    requests are sent to that server until the server is made active.
  prefs: []
  type: TYPE_NORMAL
- en: JWT authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to transfer information between microserves securely. The requests must
    be verified and signed digitally, where the applications verify the authenticity
    of the requests and respond to them.
  prefs: []
  type: TYPE_NORMAL
- en: We need to have a compact way to handle this information in the REST or HTTP
    world, since the information is required to be sent with each request. JWT is
    here to help. JWT is basically JSON web tokens in an open web standard that helps
    to securely transfer information between parties (applications). JWT will be signed
    using a secret, based on the HMAC algorithm, or with a public/private key. They
    are compact and self-contained.
  prefs: []
  type: TYPE_NORMAL
- en: For advanced uses, we need to add Bouncy Castle ([librarieshttps://en.wikipedia.org/wiki/Bouncy_Castle_(cryptography)](https://en.wikipedia.org/wiki/Bouncy_Castle_(cryptography))).
  prefs: []
  type: TYPE_NORMAL
- en: '**Compact**: They are small and can be sent to each request.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Self-contained**: The payload contains all the necessary details about the
    user, which prevents us from querying the database for user authentication.'
  prefs: []
  type: TYPE_NORMAL
- en: 'JWT consists of the header, payload, and signature. They are base64 encoded
    strings, separated by `.` (a period):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How JWT works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a user logs in to the system, a token is generated based on the payload
    (that is, the user information and secret key). The generated token is stored
    locally. For all future requests, this token is added to the request and the application
    will validate the token before responding to the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06f4754b-3f61-4656-ba67-e7feac2d7197.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The token will be in this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In JHipster, we use **JJWT** (**Java-based JSON Web Tokens**) from Okta. This
    is a simplified builder pattern-based library used to generate and sign the token
    as a producer, and parse and validate the token as a consumer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating the token**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**Validating the token**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have created a gateway application, which will serve as a single
    point of entry for our application and services. Now, we will generate a microservice
    application using JHipster.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice applications are *the* services. We will construct two sample services
    in this book and discuss the features that JHipster offers, one with the SQL database
    (MySQL) and the other with the NoSQL database (MongoDB). These services are individual
    and loosely coupled.
  prefs: []
  type: TYPE_NORMAL
- en: With JHipster, you can build microservice applications serving as REST endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice application -  Invoice Service with MySQL database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can take the invoice service from our monolithic application, separate it,
    and make them separate microservice applications. Let's name it `Invoice Service`.
    This service is responsible for creating and tracking invoices.
  prefs: []
  type: TYPE_NORMAL
- en: Application generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's see how we can generate a microservices application. In the `e-commerce-app`
    folder, create a new folder where you will keep the microservices application.
    Let's name the folder `invoice`. Go into the directory and start creating the
    application by typing `jhipster`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first question we are asked is to select the type of application we would
    like to create. We have to choose Microservice application and then click *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e17b905-7db2-486e-bcbb-3b66de4aee72.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, you need to give a base name to your application. We will go with the
    default application name, `invoice` (by default, JHipster selects a folder name
    the same as the application name):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9fd3d888-bb65-4f1c-8584-cc23c1f133ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we will select the default port in which the application has to run.
    By default, JHipster prompts `8081` as the default port for microservices, since
    we use `8080` for the gateway application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8017b65a-03b6-4170-8285-9eba66127c9f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we will select the default package name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46ad4bf4-8b4d-49b7-8efc-5ae201772ab8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we have selected JHipster Registry for the gateway application, we will
    select the same here. Similarly, if we selected Consul for the gateway application,
    then we can select Consul. We can even choose to have no registry and then add
    any custom registry there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c801cc1d-6ed1-4fc2-abaa-eb2a625a2efc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, JHipster asks for the type of authentication that we would like to use.
    We will select JWT authentication, the same as we have selected for the gateway
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0edeebcc-c85f-4b4c-a6f3-1d7a16cd319b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, select the type of database that we need to have. As highlighted, the
    invoice service will have the SQL database. We will select the SQL option. JHipster
    provides an option to opt out of the database itself. When No database is selected,
    the application is generated with no database connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9bac2b4-739a-42ba-a709-0a6e3677a425.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will select the production database as MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38ca070e-3f68-4f09-b85a-c3d79ffb1eb5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will then select the development database as H2 with disk-based persistence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d9676cd-e413-4466-860e-d0f631aeef24.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, we will select HazelCast cache as the Spring cache abstraction. Hazelcast
    provides a shared cache among all sessions. It is possible to hold the persistent
    data across the cluster or at the JVM level. We can have different modes available,
    with single or multiple nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ehcache is a local cache and it is useful for storing information in a single
    node. Infinispan and HazelCast are capable of creating a cluster and sharing information
    among multiple nodes, with HazelCast using a distributed cache, each of them connected
    together. On the other hand, Inifinispan is a hybrid cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0835f7db-0939-4f5c-9af0-d9e5e23d9e3c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we will choose Hibernate 2nd level cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34d9625d-60b7-49dc-9915-5b3bf5adf143.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will select Gradle for the build tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f3a071c-bb09-4dbe-bfca-97b757a55100.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, JHipster asks whether we have any other technologies that we would like
    to add. We will not select anything here and go with the default option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79e8b6a6-5547-431e-a07b-0c6f758d6aab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we will opt to have **internationalization** (**i18n**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8de93a2f-1f4e-4ff9-ae80-4d674117f23b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And then, we will select English as the default option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cee1b70b-d3d7-4908-9ad1-3077b6a6c761.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And select the additional languages that we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/590fd2e0-1caf-4c0c-a854-252000be3ad4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, select any other testing frameworks that we would like to add to Gatling
    or Cucumber. Note that since it will not generate a frontend application, options
    such as Protractor are not listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d055b131-1c63-4e08-84e4-613406808f4b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we will select any other generators that we need to install from the
    JHipster marketplace. Currently, we will not select any other generators (default
    option):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8a4d1f5-1b1a-48ff-aceb-3c8860351241.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, the server application is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d34b1df-4ba3-4ec6-bb2f-c67a21fcb26b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our microservice application is generated. JHipster will automatically commit
    the generated files to Git. If you wish to do this step yourself, you can do so
    by passing the `skip-git` flag during execution, for example, `jhipster --skip-git`,
    and executing the steps manually as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Microservice configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application that is generated will not feature any frontend. Again, the
    invoice service is a Spring Boot-based application. The security features are
    configured in `MicroserviceSecurityConfiguration.java`*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Ignore all the frontend related requests, so whenever a user tries to reach
    any frontend-related resources such as HTML, CSS, and JS, the request will be
    ignored by the invoice service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Since the services are independent, they can be deployed and run on another
    server with a different IP address. This requires us to disable **CSRF** (**Cross
    Site Request Forgery**) by default. We will also enable the STATELESS session
    policy in session management. This makes our application unable to create or maintain
    any sessions. Every request is authenticated and authorized based on the token.
  prefs: []
  type: TYPE_NORMAL
- en: We will also use the STATELESS session policy in session management. This is
    the strictest session policy available. This will not allow our application to
    generate a session, and so our requests have to have the (time-bound) tokens attached
    to each and every request. This enhances the security of our services. Their stateless
    constraint is another advantage of using REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: For more options and information on session policies, please look at the following
    documentation:  [https://docs.spring.io/autorepo/docs/spring-security/4.2.3.RELEASE/apidocs/org/springframework/security/config/http/SessionCreationPolicy.html](https://docs.spring.io/autorepo/docs/spring-security/4.2.3.RELEASE/apidocs/org/springframework/security/config/http/SessionCreationPolicy.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, all API-related requests and Swagger resources should be allowed once
    the request is authorized (based on the JWT token):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: On the resource side, in `bootstrap.yml`, we have defined the registry-related
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our current microservice application uses the JHipster registry as the registry
    service in order to register and deregister their existence in a heartbeat. We
    need to provide the password of our registry service with which the application
    can connect to the registry service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the name of the Spring Boot service and the default Spring Cloud Config
    parameters are enabled in the `bootstrap.yml`. We have also added the URI that
    we have to connect in order to fetch the configuration of the registry service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the gateway, the rest of the service-related configurations are done
    in the `application.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Eureka configuration is exactly the same as in the gateway application.
    All the generated applications will have a similar Eureka configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The database and JPA configurations are made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the configurations remain similar to what was generated in the gateway
    application, and they can be tweaked or customized based on your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can boot up the application alongside the gateway application and registry
    service. Since the application tries to connect to the registry service first,
    if there is no registry service available at the specified location, then the
    application will not know where to connect and whom to respond to.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the invoice service is generated. Now, we can generate a notification
    service with NoSQL as the backend database.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice application - notification service with NoSQL database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For an e-commerce website, it is really essential that orders are tracked and
    users are notified at the right moment. We will create a notification service
    which will notify users whenever their order status changes.
  prefs: []
  type: TYPE_NORMAL
- en: Application generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's generate our second microservice application (notification service) in
    the `e-commerce-app` folder. Create a new folder where you will keep the microservices
    application. Let's name the folder `notification`. Go into the directory and start
    creating the application by running `jhipster`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first question we are asked is to select the type of application we would
    like to create. We have to choose Microservice application and then click *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/178c818e-593f-495b-9e30-6c70f754d4c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we will select the default application name, `notification`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54fbf7a7-c148-41ba-8002-1be2d6173916.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we will select the port for the application. Since we have selected `8080`
    for the monolithic application and `8081` for the invoice service, we will use
    port `8082` for the notification service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ac1b9cd-bb3e-41d8-b3d2-1265b8987630.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the next three questions, we will use the same options as we did previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d475c013-8d0b-43fc-91f5-c874a3d462c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we will select MongoDB as the database. After selecting MongoDB, JHipster
    will now ask for the different types of database you would like to use for the
    development and production servers. We will use MongoDB as both the development
    and production database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ccad6fc7-b2c4-454d-bd26-75100bde78b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the remaining questions, we will select options that are similar to what
    we chose for the invoice service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/546e532b-012d-4490-851d-0b35940b89e0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The server is generated successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/290c5027-31e8-4cc1-a49d-003da91c9138.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our microservice application is generated. JHipster will automatically commit
    the generated files to Git. If you wish to do this step yourself, you can do so
    by passing the `skip-git` flag during execution, for example, `jhipster --skip-git`,
    and executing the steps manually as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Microservice configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The application is finally generated, since we have selected similar options
    for both microservices. The code generated will be similar, except for the database
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75ed1cc5-10a4-4410-b82b-17934bb4a4b8.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, we have generated a gateway application and two microservice applications
    in this chapter. We have shown you how easy it is to generate a microservice bundle
    with JHipster. Now, before we run our application, we need to kick-start our registry
    server.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will kick-start the registry server, and we will also
    see how to add entities to our new services.
  prefs: []
  type: TYPE_NORMAL
