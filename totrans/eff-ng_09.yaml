- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Enhancing the Performance and Security of Angular Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升Angular应用程序的性能和安全
- en: In this chapter, you’ll learn how to improve the performance and security of
    your Angular applications. You will do a deep dive into the change detection mechanism
    of Angular so you will know how you can reduce the number of components Angular
    has to check for changes and re-render in the browser. Next, you will learn about
    actions you can take to optimize the page load times and runtime performance of
    your Angular applications. Once you know how to enhance your Angular applications’
    performance, you will learn about security. You will learn what risks you can
    encounter when building Angular applications and how you can mitigate these risks
    so you can build safe applications for your end users.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何提高你的Angular应用程序的性能和安全。你将深入研究Angular的变更检测机制，以便你知道如何减少Angular在浏览器中需要检查变更和重新渲染的组件数量。接下来，你将了解你可以采取哪些措施来优化Angular应用程序的页面加载时间和运行时性能。一旦你知道如何提升Angular应用程序的性能，你将学习有关安全性的知识。你将了解在构建Angular应用程序时可能遇到的风险，以及如何减轻这些风险，以便为你的最终用户提供安全的应用程序。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding Angular change detection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Angular变更检测
- en: Enhancing the performance of Angular applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提升Angular应用程序的性能
- en: Building secure Angular applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建安全的Angular应用程序
- en: Understanding Angular change detection
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Angular变更检测
- en: For small applications, performance isn’t usually a bottleneck. Still, when
    applications grow and you start to add and compose more components, your application
    can become slow, impairing the user experience and decreasing user retention.
    One of the reasons your applications become slow is that Angular will check more
    and more components for changes if you develop without taking measures to help
    Angular perform better change detection. So, to build performant Angular applications,
    you need to understand how the **change detection mechanism** works so you can
    reduce the number of components the framework has to check for changes and re-render
    in the browser.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小型应用程序，性能通常不是瓶颈。然而，当应用程序增长并且你开始添加和组合更多组件时，你的应用程序可能会变慢，损害用户体验并降低用户留存率。你的应用程序变慢的一个原因是，如果你在开发时没有采取措施帮助Angular执行更好的变更检测，Angular将检查越来越多的组件以查找变更。因此，为了构建性能良好的Angular应用程序，你需要了解**变更检测机制**是如何工作的，这样你就可以减少框架需要检查变更和重新渲染的组件数量。
- en: To better understand the problem, you must first understand how Angular performs
    change detection and where the problems start.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解问题，你必须首先了解Angular如何执行变更检测以及问题从何开始。
- en: 'Let’s say you have a simple component with a title property and a `changeTitle()`
    function, like so:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个简单的组件，具有标题属性和`changeTitle()`函数，如下所示：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you call the `changeTitle()` function, Angular can keep everything synchronized
    after changing the title. Inside the call stack, Angular will first call the `changeTitle()`
    function, and all subsequent functions will be called due to the `changeTitle()`
    function being called. Then, behind the scenes, Angular will call a `tick()` function
    to run the change detection. The change detection will run for the entire component
    tree because you might change a value inside a service that is used in one or
    more components inside the component tree. This scenario will work as expected;
    although Angular must check the entire component tree, it will keep the application
    state and the view synchronized.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你调用`changeTitle()`函数，Angular可以在更改标题后保持一切同步。在调用栈中，Angular将首先调用`changeTitle()`函数，随后所有后续函数都将由于调用`changeTitle()`函数而被调用。然后，在幕后，Angular将调用一个`tick()`函数来运行变更检测。变更检测将运行整个组件树，因为你可能在一个或多个组件内部更改了服务中使用的值。这种场景将按预期工作；尽管Angular必须检查整个组件树，但它将保持应用程序状态和视图的同步。
- en: Now, imagine you run some asynchronous code before updating the title property;
    the problems will start in this scenario. Angular will detect that `changeTitle()`
    has been called and run the change detection. Because of how the call stack works,
    Angular will not wait for the asynchronous operations to complete before calling
    a function to run the change detection behind the scenes. As a result, Angular
    will run change detection before you update the title property, resulting in a
    broken application because the old value is still shown.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你在更新标题属性之前运行一些异步代码；问题将始于这个场景。Angular 会检测到 `changeTitle()` 被调用并运行变更检测。由于调用栈的工作方式，Angular
    不会在调用后台运行变更检测的函数之前等待异步操作完成。因此，Angular 将在更新标题属性之前运行变更检测，导致应用程序损坏，因为仍然显示旧值。
- en: Important note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In reality, asynchronous changes don’t break the synchronization between the
    code and view because Angular uses Zone.js to tackle this issue!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，异步更改不会破坏代码和视图之间的同步，因为 Angular 使用 Zone.js 来解决这个问题！
- en: Now you know that asynchronous changes can lead to undetected changes. Next,
    let’s learn about Zone.js and how Angular uses it to account for this issue so
    it can perform successful change detection for synchronous and asynchronous changes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道异步更改可能导致未检测到的更改。接下来，让我们了解 Zone.js 以及 Angular 如何使用它来处理这个问题，以便它可以成功执行同步和异步更改的变更检测。
- en: Zone.js and Angular
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Zone.js 和 Angular
- en: '`Zone.JS` library monkey patches (i.e., dynamically updates the behavior at
    runtime) the browser API and allows you to hook into the life cycle of browser
    events. This means you can run code before and after browser events happen. Using
    Zone.js, you can create a **Zone** and run code before the code inside the Zone
    is executed and after all code within the Zone has finished, including asynchronous
    events.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`Zone.JS` 库通过猴子补丁（即动态更新运行时行为）浏览器 API，并允许你挂钩到浏览器事件的生存周期。这意味着你可以在浏览器事件发生前后运行代码。使用
    Zone.js，你可以创建一个 **Zone**，在 Zone 内部代码执行之前和所有 Zone 内部代码完成之后（包括异步事件）运行代码。'
- en: 'To demonstrate this, here is a simple example of such a Zone:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，这里有一个这样的 Zone 的简单示例：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, a Zone is created, and inside the Zone, we perform asynchronous
    code – in our case, a `setTimeout` function. The preceding code will first log
    the message we declared before the `delegate.InvokeTask()` method. Next, it will
    run the code we declared inside the `zone.run()` callback function; this can be
    both synchronous and asynchronous code. Lastly, when the code inside the callback
    is finished, the message we declared after the `delegate.InvokeTask()` method
    will be logged.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，创建了一个 Zone，并在 Zone 内部执行异步代码——在我们的例子中是一个 `setTimeout` 函数。前面的代码将首先记录在
    `delegate.InvokeTask()` 方法之前声明的消息。接下来，它将运行在 `zone.run()` 回调函数内部声明的代码；这可以是同步和异步代码。最后，当回调函数内部的代码完成时，将记录在
    `delegate.InvokeTask()` 方法之后声明的消息。
- en: Behind the scenes, Angular uses a similar approach to our Zone example to create
    a Zone wrapped around our entire application called the `onMicrotaskEmpty` that
    emits a value when no more microtasks are in the queue. Angular uses this `onMicrotaskEmpty`
    Observable to determine when all synchronous and asynchronous code within the
    NgZone is finished, and Angular can safely run change detection without potentially
    missing changed values.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Angular 使用与我们的 Zone 示例类似的方法创建了一个围绕整个应用程序的 Zone，称为 `onMicrotaskEmpty`，当队列中没有更多微任务时，它会发出一个值。Angular
    使用这个 `onMicrotaskEmpty` 可观察对象来确定 NgZone 内部的所有同步和异步代码何时完成，Angular 可以安全地运行变更检测而不会错过已更改的值。
- en: 'In *Figure 9**.1*, you can see an illustration of how the NgZone created by
    Angular wraps around the entire component tree, allowing Angular to safely monitor
    asynchronous changes:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **图 9**.1 中，你可以看到 Angular 创建的 NgZone 如何围绕整个组件树，允许 Angular 安全地监控异步更改：
- en: '![Figure 9.1: Component tree inside NgZone](img/B21625_09_001.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1：NgZone 内部的组件树](img/B21625_09_001.jpg)'
- en: 'Figure 9.1: Component tree inside NgZone'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1：NgZone 内部的组件树
- en: When running change detection, Angular will check all components in the component
    tree and update and re-render the components if any bindings are changed (bindings
    are values bound to the HTML template).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行变更检测时，Angular 将检查组件树中的所有组件，如果任何绑定发生变化（绑定是绑定到 HTML 模板的值），则更新和重新渲染组件。
- en: Now you know how Angular uses Zone.js to trigger change detection when all synchronous
    and asynchronous tasks are finished, and that Angular checks the entire component
    tree when change detection runs. Let’s learn why Angular checks the entire component
    tree and how you can reduce the number of components Angular has to check and
    re-render when change detection runs.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道了 Angular 如何在所有同步和异步任务完成后使用 Zone.js 触发变化检测，以及 Angular 在变化检测运行时检查整个组件树。让我们学习为什么
    Angular 检查整个组件树，以及您如何在变化检测运行时减少 Angular 必须检查和重新渲染的组件数量。
- en: Improving change detection efficiency
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高变化检测效率
- en: 'Angular marks components as `OnPush` change detection strategy in your components,
    like in the following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 将组件标记为 `OnPush` 变化检测策略，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When using the `OnPush` change detection strategy, Angular only runs change
    detection for components marked as dirty, significantly reducing the number of
    components that must be checked and re-rendered. There are a couple of things
    that mark a component as dirty:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `OnPush` 变化检测策略时，Angular 只会对标记为脏的组件执行变化检测，这显著减少了必须检查和重新渲染的组件数量。有几个因素会将组件标记为脏：
- en: Browser events handled inside the component (hover, click, keydown, etc.)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件内部处理的浏览器事件（悬停、点击、键入等）
- en: Changed component input values
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变的组件输入值
- en: Component output emissions
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件输出发射
- en: 'When a component is marked as dirty, Angular will also mark all ancestors of
    the component as dirty. In *Figure 9**.2*, you can see this visualized to better
    grasp the concept:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件被标记为脏时，Angular 也会将组件的所有祖先标记为脏。在 *图 9**.2* 中，您可以可视化地看到这一点，以更好地理解概念：
- en: '![Figure 9.2: Dirty component tree](img/B21625_09_002.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2：脏组件树](img/B21625_09_002.jpg)'
- en: 'Figure 9.2: Dirty component tree'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2：脏组件树
- en: Now, components that use the `OnPush` change detection strategy and aren’t dirty
    will not be checked for changes when Angular runs change detection, reducing the
    number of components that must be checked by the framework. Angular will also
    skip all child components of the components that use `OnPush` and aren’t marked
    as dirty.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 `OnPush` 变化检测策略且未标记为脏的组件在 Angular 运行变化检测时不会被检查更改，这减少了框架必须检查的组件数量。Angular
    也会跳过使用 `OnPush` 且未标记为脏的组件的所有子组件。
- en: '*Figure 9**.3* illustrates the mechanism of change detection with the `OnPush`
    strategy:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9**.3* 展示了使用 `OnPush` 策略的变化检测机制：'
- en: '![Figure 9.3: Change detection with the OnPush strategy](img/B21625_09_003.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3：使用 OnPush 策略的变化检测](img/B21625_09_003.jpg)'
- en: 'Figure 9.3: Change detection with the OnPush strategy'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3：使用 OnPush 策略的变化检测
- en: As you can see in *Figure 9**.3*, Angular will not check whether it must refresh
    the bindings for all child components of non-dirty components using the `OnPush`
    change detection strategy. This also illustrates why all ancestor components must
    be marked as dirty when using `OnPush`. Angular checks whether it must refresh
    bindings from the top down, starting at the root component. So, if you click on
    a component at the bottom of the component tree, Angular starts at the root and
    works its way down the component tree. If the parent of the clicked component
    uses the `OnPush` change detection strategy, Angular will skip the children if
    the component isn’t marked as dirty. As a result, Angular wouldn’t check the component
    where you click, resulting in a mismatch between the code and view because the
    changes related to the click will not be processed. Because of the aforementioned
    reason, Angular must mark all parent components as dirty when the components use
    `OnPush` change detection.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在 *图 9**.3* 中所见。Angular 不会检查是否需要使用 `OnPush` 变化检测策略刷新非脏组件的所有子组件的绑定。这也说明了为什么在使用
    `OnPush` 时，所有祖先组件都必须标记为脏。Angular 从顶部向下检查是否需要刷新绑定，从根组件开始。因此，如果您在组件树底部的组件上点击，Angular
    会从根组件开始，逐层向下遍历组件树。如果点击的组件的父组件使用 `OnPush` 变化检测策略，并且该组件未标记为脏，Angular 将跳过其子组件。结果，Angular
    不会检查您点击的组件，导致代码和视图不匹配，因为与点击相关的更改将不会被处理。由于上述原因，当组件使用 `OnPush` 变化检测时，Angular 必须将所有父组件标记为脏。
- en: 'Another interesting case for `OnPush` change detection is Observables. Observables
    are the primary tool within the Angular framework to handle asynchronous events
    and data streams, yet Observables receiving new values will not mark the component
    as dirty. So, when using the `OnPush` change detection strategy, the component
    will not be updated if the Observable receives a new value. To tackle this issue,
    you can use the `async` pipe because the `async` pipe will automatically mark
    the component to be checked and handle the update like a regular event, marking
    the component as dirty and running change detection afterward. Alternatively,
    you can use `ChangeDetectorRef` and call the `markForCheck()` or `detectChanges()`
    method manually, like so:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`OnPush`变更检测，另一个有趣的案例是Observables。Observables是Angular框架中处理异步事件和数据流的主要工具，但接收新值的Observables不会将组件标记为脏。因此，当使用`OnPush`变更检测策略时，如果Observables接收新值，组件将不会更新。为了解决这个问题，你可以使用`async`管道，因为`async`管道会自动标记组件为检查，并像常规事件一样处理更新，标记组件为脏并在之后运行变更检测。或者，你可以使用`ChangeDetectorRef`并手动调用`markForCheck()`或`detectChanges()`方法，如下所示：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `markForCheck()` method will mark the component to be checked during the
    next change detection cycle, whereas `detectChanges()` will mark the component
    as dirty and immediately trigger change detection for that specific component.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`markForCheck()`方法将在下一个变更检测周期中将组件标记为检查，而`detectChanges()`方法将立即将组件标记为脏并触发该特定组件的变更检测。'
- en: However, you have to be careful when using the `detectChanges()` method because
    it can also cause performance issues. The `detectChanges()` method will run the
    entire change detection in a single browser task, blocking the main threat until
    that task is completed. When, for example, you display a large array on the screen
    and must frequently detect change for this array, that results in a lot of work
    for the browser, slowing down your Angular application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在使用`detectChanges()`方法时你必须小心，因为它也可能导致性能问题。`detectChanges()`方法将在单个浏览器任务中运行整个变更检测，直到该任务完成才会释放主线程。例如，当你需要在屏幕上显示一个大型数组并且必须频繁检测该数组的变更时，这会给浏览器带来大量工作，从而减慢你的Angular应用程序。
- en: Now that you better understand how `OnPush` change detection works and how you
    can mark components as dirty or run change detection manually, let’s learn how
    Signals are handled by the Angular change detection mechanism.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经更好地理解了`OnPush`变更检测的工作原理以及如何标记组件为脏或手动运行变更检测，让我们学习一下Angular变更检测机制是如何处理信号的。
- en: Angular change detection and Signals
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular变更检测和信号
- en: In Angular 17, **Signals** was released as a developer preview, and with that,
    the change detection mechanism received an upgrade. When using a signal inside
    the template, Angular will register an effect that listens to the signal used
    in the template. When the value of the signal changes, the effect runs and will
    mark the component to be checked by Angular change detection.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular 17中，**信号**作为开发者预览版发布，随之变更检测机制也得到了升级。当在模板中使用信号时，Angular会注册一个效果，该效果监听模板中使用的信号。当信号值发生变化时，效果会运行并将组件标记为Angular变更检测需要检查的组件。
- en: The change detection cycle will work differently when the component is marked
    to be checked because a signal value changed. First, the component with the signal
    change will receive a `RefreshView` flag. Next, it will traverse up the component
    tree and mark all its ancestors with `HAS_CHILD_VIEWS_TO_REFRESH`. It will not
    mark ancestors as dirty. Now, when change detection runs, Angular will perform
    so-called **glo-cal** (**global + local**) change detection.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件被标记为检查，因为信号值发生变化时，变更检测周期的工作方式将有所不同。首先，信号值发生变化的组件将收到一个`RefreshView`标志。接下来，它将遍历组件树并标记所有祖先组件为`HAS_CHILD_VIEWS_TO_REFRESH`。它不会将祖先组件标记为脏。现在，当变更检测运行时，Angular将执行所谓的**全局+局部**（**glo-cal**）变更检测。
- en: When running glo-cal change detection, the component tree will be checked top-down,
    just as usual. But when Angular encounters a non-dirty `OnPush` component with
    the `HAS_CHILD_VIEWS_TO_REFRESH` flag, it will skip the `OnPush` component but
    continue down the component tree to look for the component with the `RefreshView`
    flag. As a result, only the component with the `RefreshView` flag will be updated
    and re-rendered; all its parent components with the `OnPush` change detection
    strategy will not be checked or re-rendered, further improving the efficiency
    of the Angular change detection mechanism.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: You now know how Angular change detection works and how to use the `OnPush`
    change detection strategy to make the change detection process more efficient.
    Then, you learned how to handle Observables when using `OnPush` change detection
    for your components. You also know how to manually mark components to be checked
    or run change detection using the `markForCheck()` and `detectChanges()` functions.
    Lastly, you’ve seen how you can improve change detection even more by using Signals
    combined with the `OnPush` change detection strategy and trigger glo-cal change
    detection. All these changes will significantly enhance the performance of your
    application, especially when your application grows and you have large and complex
    component trees.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore other methods to enhance the performance
    of your Angular applications.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the performance of Angular applications
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding how Angular change detection works using the `OnPush` change detection
    strategy on as many components as possible and using Signals to further improve
    the change detection is a good first step to building a performant application.
    However, the framework has more to offer when developing performant applications.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explore the built-in tools and learn tips you can use
    to enhance the performance of your Angular applications and ensure swift page
    loads and good runtime performance. The first built-in tool to enhance performance
    that we will explore is the `runOutsideAngular()` method.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and using the runOutsideAngular() method
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Angular applications, optimizing performance sometimes involves executing
    specific tasks outside the Angular Zone. In the previous section, you learned
    about Zone.js, how Angular uses it to create the NgZone, and how it relates to
    change detection and the update behavior of your application. The `runOutsideAngular()`
    method provides a way to run specific code outside Angular’s change detection
    mechanism, which can improve the responsiveness and efficiency of your application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: By executing tasks outsideAngular’s Zone using `runOutsideAngular()`, you can
    prevent unnecessary change detection cycles from being triggered. This can lead
    to smoother user interactions and reduce the overhead associated with Angular’s
    change detection mechanism. Tasks executed outside the Angular Zone are not automatically
    detected by Angular’s change detection cycle, improving the overall performance
    of your application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`runOutsideAngular()`在Angular的Zone外执行任务，您可以防止不必要的变更检测周期被触发。这可以导致更平滑的用户交互，并减少与Angular的变更检测机制相关的开销。在Angular
    Zone外执行的任务不会被Angular的变更检测周期自动检测，从而提高应用程序的整体性能。
- en: 'The `runOutsideAngular()` method is provided by Angular’s NgZone service. The
    `runOutsideAngular()` method can run heavy computational functions outside the
    NgZone. Some examples of heavy computational functions are complex mathematical
    computations, sorting large arrays, and processing large datasets. Other scenarios
    in which you might want to run something outside the NgZone are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`runOutsideAngular()`方法由Angular的NgZone服务提供。`runOutsideAngular()`方法可以在NgZone外运行重计算函数。一些重计算函数的例子包括复杂的数学计算、排序大型数组以及处理大型数据集。您可能希望在NgZone外运行的其他场景如下：'
- en: '**Running code from third-party libraries**: Running code related to initializing,
    configuring, or interacting with third-party libraries outside the Angular zone
    prevents Angular from performing unnecessary change detection, leading to better
    performance and avoiding potential side effects.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行第三方库中的代码**：在Angular Zone外运行与初始化、配置或与第三方库交互相关的代码，可以防止Angular执行不必要的变更检测，从而提高性能并避免潜在的副作用。'
- en: '**Handling WebSocket communication or long-polling requests**: This involves
    frequent updates to the application state without triggering user-initiated actions.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理WebSocket通信或长轮询请求**：这涉及到频繁更新应用程序状态，而不触发用户发起的操作。'
- en: '**Animations or rendering optimizations that involve low-level DOM manipulation
    or canvas drawing operations**: Running the related code outside the Angular zone
    can enhance performance by bypassing Angular’s change detection and allowing for
    more direct control over rendering updates.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**涉及低级DOM操作或canvas绘图操作的动画或渲染优化**：在Angular Zone外运行相关代码可以通过绕过Angular的变更检测并允许对渲染更新有更直接的控制来提高性能。'
- en: 'By strategically utilizing `runOutsideAngular()`, you can improve the performance
    and responsiveness of your Angular application, particularly when dealing with
    computationally intensive tasks or interactions with external libraries. However,
    it’s crucial to balance performance optimization with maintaining the integrity
    and functionality of your application. When running tasks inside `runOutsideAngular()`,
    change detection will not detect the tasks, so you risk showing incorrect data
    to the user. A good countermeasure to this is running the heavy computation inside
    the `runOutsideAngular()` method, and then assigning the values to your component
    properties inside the NgZone again by using the `run()` method, as shown in the
    following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过战略性地使用`runOutsideAngular()`，您可以提高Angular应用程序的性能和响应速度，尤其是在处理计算密集型任务或与外部库交互时。然而，平衡性能优化与保持应用程序的完整性和功能至关重要。当在`runOutsideAngular()`内运行任务时，变更检测将不会检测到这些任务，因此您可能会向用户显示错误的数据。对此的一个良好对策是在`runOutsideAngular()`方法内运行重计算，然后通过使用`run()`方法再次在NgZone内将值分配给组件属性，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, you can see how to use the `runOutsideAngular()` and
    `run()` methods. You inject the NgZone and call the methods on the service provided
    to you by Angular. Within the callbacks of each method, you can perform any logic
    you want to perform inside or outside of the NgZone.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您可以看到如何使用`runOutsideAngular()`和`run()`方法。您注入NgZone并调用Angular提供的服务上的方法。在每个方法的回调中，您可以在NgZone内或外执行任何逻辑。
- en: 'Now that you know how to use `runOutsideAngular()` and run code outside the
    NgZone to improve the performance of your application, let’s move on to the next
    tool Angular offers us to develop more performant applications: the `NgOptimizedImage`
    directive.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何使用`runOutsideAngular()`在NgZone外运行代码以提高应用程序的性能，让我们继续了解Angular提供的下一个工具，以开发更高效的应用程序：`NgOptimizedImage`指令。
- en: Understanding and using the NgOptimizedImage directive
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解和使用NgOptimizedImage指令
- en: Another crucial aspect when building performant applications is optimizing your
    images. The load time of your images is a huge factor in the **Largest Contentful
    Paint** (**LCP**) of your website, which is one of the three Core Web Vital metrics
    [the other two Core Web Vital metrics are **First Input Delay** (**FID**) and
    **Cumulative Layout Shift** (**CLS**)]. The LCP indicates the speed at which the
    primary content of a webpage loads, specifically measuring the duration from when
    the user triggers the page load to when the largest image or text block is displayed
    within the visible area of the browser window. Because images mostly take longer
    to load compared to text content, how your images are loaded and displayed plays
    a vital role in the LCP of your applications.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建高性能应用程序时，优化图像是另一个关键方面。您的图像加载时间对网站的最大内容渲染时间（**Largest Contentful Paint**，**LCP**）有很大影响，这是三个核心
    Web Vital 指标之一[其他两个核心 Web Vital 指标是**首次输入延迟**（**FID**）和**累积布局偏移**（**CLS**）]。LCP
    表示网页主要内容的加载速度，具体测量从用户触发页面加载到浏览器窗口可见区域内显示最大图像或文本块之间的持续时间。由于图像的加载时间通常比文本内容长，因此图像的加载和显示方式在应用程序的
    LCP 中起着至关重要的作用。
- en: Within the Angular framework, you can improve how images are loaded by using
    the `NgOptimizedImage` directive. `NgOptimizedImage` focuses on prioritizing the
    loading of the LCP images.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 框架中，您可以通过使用 `NgOptimizedImage` 指令来改进图像的加载方式。`NgOptimizedImage` 指令专注于优先加载
    LCP 图像。
- en: By default, this directive enables lazy loading for non-priority images, conserving
    bandwidth and improving initial page load times. Additionally, `NgOptimizedImage`
    generates a `preconnect` link tag in the document head, optimizing resource fetching
    strategies. `NgOptimizedImage` automatically sets the `fetchpriority` attribute
    on the `img` tag, emphasizing the loading priority of the LCP image. Furthermore,
    the directive streamlines the process of generating `srcset` attributes. By using
    `srcset` attributes, the browsers request images at the right size for the user’s
    viewport and because of that, no time and resources are wasted downloading an
    image that’s too large.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此指令为非优先图像启用懒加载，节省带宽并提高初始页面加载时间。此外，`NgOptimizedImage` 在文档头部生成一个 `preconnect`
    链接标签，优化资源获取策略。`NgOptimizedImage` 自动在 `img` 标签上设置 `fetchpriority` 属性，强调 LCP 图像的加载优先级。此外，该指令简化了生成
    `srcset` 属性的过程。通过使用 `srcset` 属性，浏览器请求适合用户视口的图像大小，因此不会浪费时间和资源下载过大的图像。
- en: 'Besides prioritizing the loading of LCP images, `NgOptimizedImage` ensures
    a series of image best practices are applied:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了优先加载 LCP 图像外，`NgOptimizedImage` 还确保应用一系列图像最佳实践：
- en: '**Image CDN utilization**: The directive encourages the use of image content
    delivery network (CDN) URLs, facilitating image optimizations and efficient delivery
    across global networks.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像 CDN 利用**：该指令鼓励使用图像内容分发网络（CDN）的 URL，以促进图像优化并在全球网络中高效传输。'
- en: '`NgOptimizedImage` incorrectly or not setting dimensions results in a warning.
    By setting width and height properties, you mitigate layout shifts, improve your
    CLS, and ensure proper rendering.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `NgOptimizedImage` 设置错误或未设置尺寸，将导致警告。通过设置宽度和高度属性，您可以减轻布局偏移，提高您的 CLS，并确保正确的渲染。
- en: '`NgOptimizedImage` alerts developers to potential visual distortions in rendered
    images.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NgOptimizedImage` 会提醒开发者注意渲染图像中可能出现的视觉扭曲。'
- en: 'Now that you know why you need the `NgOptimizedImage` directive, let’s see
    how you can use it. The `NgOptimizedImage` directive is standalone, so you begin
    by importing the `NgOptimizedImage` directive directly into the necessary `NgModule`
    or standalone component. Next, you can use `NgOptimizedImage` by replacing the
    `src` attribute on an `img` tag with `ngSrc`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 既然您已经知道了为什么需要 `NgOptimizedImage` 指令，让我们看看如何使用它。`NgOptimizedImage` 指令是独立的，因此您首先需要将
    `NgOptimizedImage` 指令直接导入必要的 `NgModule` 或独立组件。接下来，您可以通过将 `img` 标签上的 `src` 属性替换为
    `ngSrc` 来使用 `NgOptimizedImage`：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As mentioned, you also need to set the width and height properties:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您还需要设置宽度和高度属性：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <img ngSrc="dog.jpg" width="400" height="200 priority ">
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <img ngSrc="dog.jpg" width="400" height="200" priority>
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <img ngSrc="dog.jpg" fill attribute is used when you want the image to fill
    the containing element. A good use case for the fill attribute is when you want
    to use the image as a background image, or when you don’t know the exact size
    of your image and want to fit it inside a container of which you do know the size
    in relation to the screen size. When using the fill attribute, you don’t have
    to set the width and height properties, as Angular will set them for you behind
    the scenes when the sizes are resolved.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要图像填充包含元素时，使用`ngSrc="dog.jpg"`和`fill`属性。当你想将图像用作背景图像，或者当你不知道图像的确切大小，但想将其适应一个你知道其相对于屏幕大小的大小时，可以使用填充属性。当使用填充属性时，你不需要设置宽度和高度属性，因为Angular会在大小解决后为你设置它们。
- en: To control how the image will fill the container, you can use the `object-fit`
    CSS property.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制图像如何填充容器，你可以使用`object-fit` CSS属性。
- en: More information
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: Besides the `priority` and `fill` attributes, when using a third-party service
    for your images, the `NgOptimizedImage` directive has more cool features such
    as low-resolution placeholders and custom image loaders. These features are out
    of scope for this book, but if you want, you can read about them in the official
    Angular documentation at [https://angular.io/guide/image-directive](https://angular.io/guide/image-directive).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`priority`和`fill`属性之外，当使用第三方服务处理你的图片时，`NgOptimizedImage`指令还有更多酷炫的功能，例如低分辨率占位符和自定义图片加载器。这些功能超出了本书的范围，但如果你有兴趣，可以在官方Angular文档中阅读有关它们的内容：[https://angular.io/guide/image-directive](https://angular.io/guide/image-directive)。
- en: 'Now that you know about `NgOptimizedImage` and how you can use it to optimize
    your image and improve the LCP of your applications, let’s dive into the next
    performance optimization step: using the `trackBy` or `track` function for loops
    inside the HTML template.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了`NgOptimizedImage`以及如何使用它来优化你的图像并提高应用程序的LCP，让我们深入了解下一个性能优化步骤：在HTML模板中使用`trackBy`或`track`函数进行循环。
- en: Understanding and using the trackBy and track functions
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 理解和使用trackBy和track函数
- en: In Angular applications, rendering large lists or collections of data can sometimes
    lead to performance issues due to frequent DOM manipulations. To optimize the
    performance of your Angular application, it’s crucial you understand and leverage
    tools such as the `trackBy` or `track` function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular应用程序中，渲染大量列表或数据集合有时会导致性能问题，因为频繁的DOM操作。为了优化你的Angular应用程序的性能，了解并利用像`trackBy`或`track`函数这样的工具至关重要。
- en: The `trackBy` function is a feature provided by Angular that improves the performance
    when rendering lists using the `*ngFor` directives. The `track` function is the
    counterpart of the Angular control flow syntax. The `trackBy` function is optional,
    whereas the `track` function is required when using the control flow syntax.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`trackBy`函数是Angular提供的一个功能，它通过在`*ngFor`指令渲染列表时提高性能。`track`函数是Angular控制流语法的对应物。`trackBy`函数是可选的，而`track`函数在使用控制流语法时是必需的。'
- en: By default, Angular uses object identifiers to track changes in the data provided
    to an `*ngFor` directive. However, this approach can lead to unnecessary re-renders
    of DOM elements, particularly when dealing with dynamic data. The `track` and
    `trackBy` functions allow Angular to efficiently track changes in the collection
    by providing a unique identifier for each item. This results in fewer DOM manipulations
    and significantly improves rendering performance, especially when dealing with
    large datasets.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Angular使用对象标识符来跟踪`*ngFor`指令提供的数据的变化。然而，这种方法可能导致DOM元素的不必要重渲染，尤其是在处理动态数据时。`track`和`trackBy`函数允许Angular通过为每个项目提供一个唯一标识符来高效地跟踪集合中的变化。这导致DOM操作更少，显著提高了渲染性能，尤其是在处理大量数据集时。
- en: 'When you use the `*ngFor` directive, you assign the `trackBy` property to a
    function and declare the corresponding function inside your component class. The
    function should return the unique identifier you want to use to track the items
    inside the list you are rendering:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`*ngFor`指令时，你需要将`trackBy`属性分配给一个函数，并在你的组件类内部声明相应的函数。该函数应该返回你想要用来跟踪你正在渲染的列表中项目的唯一标识符：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'trackById(index: number, item: Item) { return item.id }'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 'trackById(index: number, item: Item) { return item.id }'
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '@for (item of items; track item.id) { … }'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '@for (item of items; track item.id) { … }'
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ng generate web-worker <location>
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ng generate web-worker <location>
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: addEventListener('message', ({ data }) => {
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: addEventListener('message', ({ data }) => {
- en: const response = `worker response to ${data}`;
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: const response = `worker response to ${data}`；
- en: postMessage(response);
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: if (typeof Worker !== 'undefined') {
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: const worker = new Worker(new URL(‹./heavy-duty.worker', import.meta.url));
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: worker.onmessage = ({ data }) => {
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: console.log(`page got message ${data}`);
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: worker.postMessage(‹hello›);
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '} else { // Fallback for environment. }'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '@Component({……})'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: export class FooComponent {
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: heavyDutyResult;
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: heavyDutyInput = {……};
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: constructor() { this.runWebWorker() }
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: runWebWorker () {
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: if (typeof Worker !== ‹undefined›) {
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: const worker = new Worker(new URL(‹./heavy-duty.worker›, import.meta.url));
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: worker.onmessage = ({ data }) => {
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: this.heavyDutyResult = data;
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: worker.postMessage(this. heavyDutyInput);
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '} else { // Fall back }'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: addEventListener('message', ({ data }) => {
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: const response = heavyDutyFunction(data);
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: postMessage(response);
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '{'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'path: ‹…'','
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'loadComponent: () => import(‹……''),'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'canMatch: [],'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'canActivate: [],'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'canMatch: [() => inject(UserService).loggedIn],'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'export const hasRouteSegements: CanMatchFn = (route: Route, segments: UrlSegment[])
    => {'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: return inject(UserService).loggedIn && segments.length > 1;
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'canMatch: [hasRouteSegements]'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'canDeactivate: [(component: UserComponent) => !component.hasUnsavedChanges]'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <div>{{ data }}</div> + userInput
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <div [innerHTML]="htmlSnippet"></div>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: <div [style]="userProvidedStyles">...</div>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: protected readonly sanitizer = inject(DomSanitizer);
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: this.trustedUrl = this.sanitizer.bypassSecurityTrustUrl(this.dangerousUrl);
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'export const MockInterceptor: HttpInterceptorFn = ('
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'req: HttpRequest<unknown>,'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'next: HttpHandlerFn,'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: ) => {
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: const csrfToken = inject(AuthService).getCsrfToken();
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: const csrfReq = req.clone({
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'setHeaders: {'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '‹X-XSRF-TOKEN›: csrfToken,'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: return next(csrfReq);
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
