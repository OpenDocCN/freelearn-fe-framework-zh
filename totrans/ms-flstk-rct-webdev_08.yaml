- en: Docker and the EC2 Container Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have done all the stuff related to database-as-a-backend with mLab. The publishing
    application should be working 100 percent remotely on the mLab MongoDB instance,
    so you don't need to run the `mongod` command anymore.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to prepare our Docker container and deploy it on EC2 completely with
    the use of ECS (EC2 Container Service) and load balancers.
  prefs: []
  type: TYPE_NORMAL
- en: What is Docker? It's a very useful piece of software that is open source and
    helps you pack, ship, and run any app as a light (in comparison to a virtual machine,
    for example) container.
  prefs: []
  type: TYPE_NORMAL
- en: A container's goals are similar to virtual machines--the big difference is that
    Docker was created with software development in mind, as opposed to VMs. You need
    to also be aware that a fully virtualized system has its own resources allocated
    to it, which causes minimal resource sharing, which is different for Docker containers.
    Of course, in VMs, you get more isolation, but the cost is that the VMs are much
    heavier (requiring more disk space, RAM, and other resources). Docker's containers
    are lightweight and are able to share more things among different containers in
    comparison to VMs.
  prefs: []
  type: TYPE_NORMAL
- en: The good part is that Docker's containers are hardware and platform independent,
    so all worries about whether what you are working on will run everywhere are disappearing.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, Docker's benefits are that it increases developers' productivity,
    helps them ship software faster, helps move the software from local development
    machines to production deployments on AWS, and so on. Docker also allows versioning
    (similar to Git) of your software, which can be helpful when you need a quick
    rollback on the production server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Docker app on your machine with Docker Toolbox on non-Linux machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing whether your Docker setup is correct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the publishing app in order to use mLab Mongo for the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new Docker container for the publishing app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first Dockerfile, which will deploy the publishing app on Linux
    CentOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EC2 Container Service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS load balancers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Amazon Route 53 for DNS services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS identity and access management (IAM)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker installation with Docker Toolbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing Docker is quite easy. Visit the official installation page at [https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/)
    because it will guide you best depending on your operating system. There are easy-to-follow
    installers for iOS and Windows and a lot of instructions for different Linux distributions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using a non-Linux machine, then you also need to install Docker
    Toolbox for Windows or OS X. This is quite simple with its installers, which are
    available at [https://www.docker.com/products/docker-toolbox](https://www.docker.com/products/docker-toolbox),
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00094.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you are using Linux, there are some extra steps to be performed as you need
    to turn on virtualization in BIOS:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the Docker machine with instructions from the official docs at [https://docs.docker.com/machine/install-machine/](https://docs.docker.com/machine/install-machine/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Ubuntu, you need to install VirtualBox manually fromÂ [https://help.ubuntu.com/community/VirtualBox](https://help.ubuntu.com/community/VirtualBox)[](https://docs.docker.com/machine/install-machine/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For other Linux distributions visit [https://www.virtualbox.org/wiki/Linux_Downloads](https://www.virtualbox.org/wiki/Linux_Downloads)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After you have installed Docker (together with Toolbox on OS X and Windows)
    on your local machine, run in the Terminal the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After you run this command, you will be able to see something similar to the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00095.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you can see something like this, then your installation is successful. Let's
    continue with Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Hub - an hello world example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start creating the publishing app's Docker container, let's start
    playing with an official Docker *hello world* example that will make you aware
    of how the Docker Hub works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Hub is to Docker containers as GitHub is to Git''s repositories. You
    can have public and private containers in Docker. The main page of Docker Hub
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00096.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Just to give you a feel for it, if you visit [https://hub.docker.com/explore/](https://hub.docker.com/explore/),
    you can see different containers that are ready for use, like this, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00097.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Just for our demo exercise, we will use a container called `hello world`, which
    is publicly available at [https://hub.docker.com/r/library/hello-world/](https://hub.docker.com/r/library/hello-world/).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to run this `hello-world` example, run the following in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After you run this, you will see something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00098.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s understand what''s just happened: we use the `docker run` command in
    order to start the container based on an image (in our example, we have used the
    hello world container image). In this case, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the command that tells Docker to start the container named `hello-world`
    with no extra commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you hit Enter, Docker will download Docker Hub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then it will start the container in the VM, using Docker Toolbox on non-Linux
    systems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `hello-world` image comes from the public registry called Docker Hub as
    mentioned before (which you can visit at [https://hub.docker.com/r/library/hello-world/](https://hub.docker.com/r/library/hello-world/)).
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every image is composed of a Dockerfile. An example Dockerfile for the `hello-world`
    example looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A Dockerfile is a set of instructions that tell Docker how to build a container
    image. We will create our own in a moment. An analogy for a Dockerfile can be
    the Bash language that you can use on any Linux/Unix machine. Of course, it's
    different, but the general idea of writing instructions to create the job is similar.
  prefs: []
  type: TYPE_NORMAL
- en: Modifications to our codebase in order to create it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, we are sure that our Docker application's setup is working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need to make some modifications to our current codebase as
    there are small tweaks to make it work properly.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the following files have the proper content.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `server/.env` file''s content has to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For now, we will load the environment variables from a file, but later we will
    load them from the AWS panel. It's not really production-secure to keep all that
    secret data on the server. We use it now for the sake of brevity; later, we'll
    delete it in favor of a more secure approach.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the Mongo environment variables, we learned them in the previous chapter
    about setting up mLab (get to back to the chapter if you missed any of the details
    required at this point).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `server/index.js` file''s content has to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you are loading `.env` from the file at the beginning of `server/index.js`.
    It will be required in order to load the mLab Mongo details from the environment
    variables (`server/.env`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `server/configMongoose.js` file''s content has to be replaced. Find the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The new version of the same improved code has to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have added the ability to connect with a specific DB's user.
    We need it because the localhost on which we were working didn't require any user,
    but when we start using the mLab MongoDB, then specifying our database's user
    is a must. Otherwise, we won't be able to authenticate correctly.
  prefs: []
  type: TYPE_NORMAL
- en: From this point, you don't need to run the `mongod` process in the background
    of your system, because the app will connect with the mLab MongoDB node that you
    created in the previous chapter. The mLab MongoDB (free version) runs 24/7, but
    if you plan to use it for production-ready apps, then you need to update it and
    start using the replica set feature as well (which was mentioned in the previous
    chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can try to run the project with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you should be able to load the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00099.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The important difference now is that all the CRUD operations (read/write via
    our publishing app) are done on our remote MongoDB (not on the local one).
  prefs: []
  type: TYPE_NORMAL
- en: After the publishing app uses the mLab MongoDB, we are ready to prepare our
    Docker image and then deploy it on several instances of AWS EC2 with AWS Load
    Balancer and EC2 Container Service.
  prefs: []
  type: TYPE_NORMAL
- en: Working on the publishing app Docker image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before continuing, you should be able to run your project locally by using remote
    mLab MongoDB. It's required because we will start running our publishing app in
    the Docker container. Our app will then connect with Mongo remotely. We won't
    run any MongoDB process in any Docker container. This is why it's so important
    to use mLab in the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the Dockerfile by executing the following command in a terminal/command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the following content in your new Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look step by step at the Dockerfile we are going to use in our publishing
    app together with Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM centos:centos7`: This says that we will use as a starting point the CentOS
    7 Linux distribution from the [https://hub.docker.com/r/_/centos/](https://hub.docker.com/r/_/centos/)
    public Docker repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use any other package as a starting point, such as Ubuntu, but we are
    using CentOS 7 because it's more lightweight and generally very good for web app
    deployment. You can find further details at [https://www.centos.org/](https://www.centos.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Documentation of all commands is available at [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).
  prefs: []
  type: TYPE_NORMAL
- en: '`RUN yum update -y`: This updates packages from the command line with `yum--`standard
    for any Linux setup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN yum install -y tar wget`: This installs two packages as `tar` (for unpacking
    files) and `wget` (for downloading files).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN wget -q https://nodejs.org/dist/v4.0.0/node-v4.0.0-linux-x64.tar.gz -O
    - | tar xzf - -C /opt/*`: This command downloads `node4.0.0` to our CentOS container,
    unpacks it, and puts all the files into the `/opt/` directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN mv /opt/node-v /opt/node*`: This renames the folder we just downloaded
    and unpacked (with `node`) to simply `node` without version naming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN ln -s /opt/node/bin/node /usr/bin/node`: We are linking the `/opt/node/bin/node`
    location with a `/usr/bin/node` link, so we are able to use a simple `$ node`
    command in the Terminal. This is standard stuff for Linux users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN ln -s /opt/node/bin/npm /usr/bin/npm`: The same as with `node`, but with
    `npm`. We are linking it in order to make usage easier and linking it to `$ npm`
    on our CentOS 7.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COPY . /opt/publishing-app/`: This copies all the files in the context (The
    `.` (dot) sign is the location when you start the container build. We will do
    that in a moment.) It copies all the files into the `/opt/publishing-app/` location
    in our container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our case, we have created the Dockerfile in our publishing app's directory,
    so it will copy all the project files in the container to the given location at
    `/opt/publishing-app/`.
  prefs: []
  type: TYPE_NORMAL
- en: '`WORKDIR /opt/publishing-app`: After we have our publishing app''s files in
    our Docker container, we need to choose the working directory. It''s similar to
    `$ cd /opt/publishing-app` on any Unix/Linux machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN npm install`: When we are in our working directory, which is `/opt/publishing-app`,
    then we run the standard `npm install` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN yum clean all`: We clean the `yum` cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXPOSE 80`: We define the port that is using our publishing application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMD ["npm", "start"]`: Then, we specify how to run the application in our
    Docker container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will also create in the main project directory, a `.dockerignore` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The file content will be as following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We don't want to copy over the mentioned files `(.DS_Store` is specific to OS
    X).
  prefs: []
  type: TYPE_NORMAL
- en: Building the publishing app container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, you will be able to build the Docker's container.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main directory of the project, you need to run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `login` command will prompt you to insert your Docker username and password.
    After you are authenticated correctly, you can run the `build` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the username and the container name combination has to be yours.
    Replace it with your details.
  prefs: []
  type: TYPE_NORMAL
- en: 'That preceding command will build the container with the use of Dockerfile
    commands. This is what you will see (step 1, step 2, and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00100.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After a successful build, you will see in your Terminal/command line something
    similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see here from the Docker Terminal, we have built a container in a
    successful manner. The next step is to test it locally and then learn a little
    bit more of Docker's basics and finally start working on our AWS deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Running the publishing app container locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to test whether the container has been built correctly, perform the
    following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will give you output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We are looking for the `DOCKER_HOST` IP address; in this case, it's `192.168.99.100`.
  prefs: []
  type: TYPE_NORMAL
- en: This Docker host IP will be used to check whether our application is running
    correctly in the container. Note it down.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to run our local container with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Regarding flags: the `d` flag stands for "detached," so the process will run
    in the background. You can list all running Docker processes with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'An example output would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00101.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `-p` flag is telling us that the container's port `80` is bound to port
    `80` on the Docker IP host. So if we expose our Node app on port `80` in the container,
    then it will be able to run on a standard port `80` on the IP (in the examples,
    it will be `192.168.99.100:80`; obviously, port `80` is for all HTTP requests).
  prefs: []
  type: TYPE_NORMAL
- en: The `przeor/pub-app-docker` command will specify the name of the container that
    we want to run.
  prefs: []
  type: TYPE_NORMAL
- en: With `npm start`, we tell which command we want to run in the Docker container
    right after starting (otherwise, the container would run and stop immediately).
  prefs: []
  type: TYPE_NORMAL
- en: More references about `docker run` are available at [https://docs.docker.com/engine/reference/run/](https://docs.docker.com/engine/reference/run/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding command will run the app, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00102.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the IP address in the browser's URL bar is http://192.168.99.100\.
    It's our Docker host IP.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In case the container doesn''t work for you, like in the following screenshot,
    use the following command to debug and find the reason:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This command with the `-i -t -p` flags will show you all the logs in the Terminal/command
    line, like in the following screenshot (this is just an example in order to show
    you the ability to debug a Docker container locally):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00103.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Pushing a Docker container to a remote repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a container works for you locally, then it's almost ready for AWS deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before pushing the container, let''s add the `.env` file to`.dockerignore`,
    because you have in it all the sensitive data that you won''t put into containers.
    So, into the `.dockerignore` file, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After you add `.env` to `.gitignore`, we need to change the `server/index.js`
    file and add an additional `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This `if` statement checks whether we're running the app locally (with an `.env`
    file) or remotely on an AWS instance (then we pass the `env` variables in a more
    secure manner).
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have added the `.env` file into `.dockerignore` (and modified `server/index.js`),
    build the container that will be ready for the push:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Regarding the environment variables, we will add them via AWS advanced options.
    You will learn about this later, but to get a general idea of how to add them
    when running them on the localhost, check out the following example (fake data
    provided in the command''s flag):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you have provided your correct `AWS_REGION_NAME`. Mine is `eu-central-1`,
    but yours can be different.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, everything from the `server/.env` file has been moved to the
    Docker run command in the Bash terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can find here, the `-e` flag is for an `env` variable. The last thing
    is to push the container to the remote repository hosted by Docker Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you will be able to find in your Bash/command line something similar to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00104.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The link to the pushed repo will be similar to this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00105.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot has been made from the pushed Docker repository.
  prefs: []
  type: TYPE_NORMAL
- en: A summary of useful Docker commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are a few useful Docker commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This command will list all the images, and `docker rm` can delete the repo
    from your local machine in case you want to delete it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can use just the first three characters from `CONTAINER-ID`. You don't need
    to write down whole container ID. This is a convenience.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This one is used for stopping a running Docker container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use version tag of your containers with the following approach:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: After you have listed the Docker images, you may notice that you have two containers,
    one with the tag `latest` and the other with `0.1`. This is a way to track changes,
    because if you push the container, the tag will also be listed on Docker Hub.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check your container''s local IP:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Build your container from a Dockerfile:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your container in "detached" mode:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your container to debug it without detaching it so that you can find what
    is going on in the container''s Bash terminal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Introduction to Docker on AWS EC2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two chapters ago, we implemented Amazon AWS S3 for static image uploading. You
    should already have an AWS account, so you are ready for the following steps to
    create our deployment on AWS.
  prefs: []
  type: TYPE_NORMAL
- en: In general, you can use the steps with free AWS tiers, but we will use the paid
    version in this tutorial. Read the AWS EC2 pricing before starting this section
    on how to deploy Docker containers on AWS.
  prefs: []
  type: TYPE_NORMAL
- en: AWS also has great Docker container support with their service called **EC2
    Container Service** (**ECS**).
  prefs: []
  type: TYPE_NORMAL
- en: If you bought this book, it probably means you haven't been using AWS so far.
    Because of this, we will first deploy Docker manually on EC2 in order to show
    you how the EC2 instances work so that you can get more knowledge from the book.
  prefs: []
  type: TYPE_NORMAL
- en: Our main goal is to make the deployment of our Docker containers automatic,
    but for now, we will start with a manual approach. If you have already used EC2,
    you can skip the next subsection and go straight to ECS.
  prefs: []
  type: TYPE_NORMAL
- en: Manual approach - Docker on EC2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We were running our Docker container locally with the following command (a
    few pages previously):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We will do the same thing, not locally but on the EC2 instance, 100% manually
    for now; later, we will do it 100% automatically with AWS ECS.
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue, let's understand what EC2 is. It's a scalable computing
    capacity located in the Amazon Web Services cloud. In EC2, you don't need to invest
    money upfront in buying any hardware. Everything you pay is for the time spent
    using an EC2 instance. This allows you to deploy applications faster. Very quickly,
    you can add new virtual servers (when there is a bigger web traffic demand). There
    are some mechanisms to scale the number of EC2 instances automatically with the
    use of **AWS CloudWatch**. Amazon EC2 gives you the ability to scale up or down
    to handle changed requirements (such as spikes in popularity)--this feature reduces
    your need to forecast traffic (and saves you time and money).
  prefs: []
  type: TYPE_NORMAL
- en: For now, we will use only one EC2 instance (later in the book, we will see more
    EC2 instances with load balancers and ECS).
  prefs: []
  type: TYPE_NORMAL
- en: Basics - launching an EC2 instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will launch an EC2 instance, then log in to it via SSH (you can use **Putty**
    on Windows OS).
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in to AWS Console by visiting this link: [https://eu-central-1.console.aws.amazon.com/console/home](https://eu-central-1.console.aws.amazon.com/console/home).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the EC2 link: [https://eu-central-1.console.aws.amazon.com/ec2/v2/home](https://eu-central-1.console.aws.amazon.com/ec2/v2/home)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then click on the blue Launch Instance button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00106.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The button looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00107.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After you click on the button, you will be redirected to the **Amazon Machine
    Image** (**AMI**) page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00108.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The AMI has a list of images that you can run an EC2 instance with. Each image
    has a list of preinstalled software. For example, the most standard image is the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00109.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It has preinstalled software; for example, the Amazon Linux AMI is an EBS-backed,
    AWS-supported image. The default image includes AWS command-line tools, Python,
    Ruby, Perl, and Java. The repositories include Docker, PHP, MySQL, PostgreSQL,
    and other packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the same page, you can also find other AMIs to buy on the marketplace or
    created and shared by the community for free. You can also filter the images so
    that it will list only the free tier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00110.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For the sake of making this step-by-step guide simple, let's choose the image
    that is in the preceding screenshot; its name will be similar to `Amazon Linux
    AMI 2016.03.3 (HVM), SSD Volume Type`.
  prefs: []
  type: TYPE_NORMAL
- en: The name of the image may slightly vary; don't worry about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the blue Select button. Then you will be transferred to the Step 2:
    Choose an Instance Type page, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00111.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'From this page, select the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00112.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, click on this button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00113.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The simplest method is to choose the default options:'
  prefs: []
  type: TYPE_NORMAL
- en: Review.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure security group (we will make some changes in this tab).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tag instance (keep the options default).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add storage (keep the options default).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the instance (keep the options default).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose an instance type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose an AMI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generally, keep clicking on the next button until we get to the Configure security.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An indicator of progress you can find at the top is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00114.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our goal for now is to get to the security configuration page because we need
    to customize slightly the allowed ports. A security group consists of rules that
    control network traffic for an EC2 instance (a.k.a. firewall options). For security,
    set the name to `ssh-and-http-security-group`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00115.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can find here, you also need to click on the Add Rule button and add
    a new one called HTTP. This will allow our new EC2 instance to be available via
    port 80 for all the IPs.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have added the name and HTTP port 80 as the new rule, you can click
    on the Review and Launch button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00116.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, after you are happy with reviewing the instance, click on the blue button
    called Launch in that view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00117.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After you click on the Launch button, you will see a modal that says Select
    an existing key pair or create a new key pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00118.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Usually, you''ll need to create a new key pair. Give it the name `pubapp-ec2-key-pair`
    and then click on the Download button, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00119.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After you have downloaded `pubapp-ec2-key-pai`, you will be able to click on
    the blue Launch button. Next, you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00120.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'From this screen, you can go directly to the EC2 launch logs (click on the
    View launch log link) so that you will be able to find your instance listed, as
    seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00121.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Great. Your first EC2 has been launched successfully! We need to log in to it
    and set up the Docker container from there.
  prefs: []
  type: TYPE_NORMAL
- en: Save the public IP of your EC2 instance. In the preceding launch log, you can
    find that the machine we've just created has the public IP 52.29.107.244.
  prefs: []
  type: TYPE_NORMAL
- en: Your IP will be different (of course, this is just an example). Save it somewhere;
    we will use it in a moment as you'll need it to log in via SSH to the server and
    install the Docker app.
  prefs: []
  type: TYPE_NORMAL
- en: SSH access via PuTTy - Windows users only
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you don't work on Windows, you can skip this subsection.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be using PuTTy, which is available for download at [http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html](http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html)
    (`putty.exe`, `pageant.exe`, and `puttygen.exe`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Download key pairs for the EC2 instance, and convert them to `ppk` using `puttygen.exe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00122.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on the Load button and choose the `pubapp-ec2-key-pair.pem` file, and
    then covert it to `ppk`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then you need to click on the Save private key button. You are done; you can
    close `puttygen.exe` and open `pageant.exe`. From it, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose Add Key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then check whether your key has been added correctly to the Pageant key list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your private key is on the list, you are ready to use `putty.exe`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00123.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you have opened the PuTTy program, you need to log in via SSH by typing your
    EC2 instance IP and clicking on the Open button, as shown in the preceding screenshot.
    PuTTy allows using SSH connections on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to an EC2 instance via SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a previous chapter, after we launched the EC2 instance, we found out our
    public IP (remember that your public IP will be different): `52.29.107.244`. We
    need to connect to the remote EC2 instance with this public IP.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ve saved `pubapp-ec2-key-pair.pem` in my `Downloads` directory, so go to
    the directory where you have downloaded your `.pem` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In PuTTy on Windows, it will look similar after this step. You need to provide
    in the PuTTy box the IP and ports in order to correctly log in to the machine.
    When you get a prompt to type a username, use `ec2-user`, as in the SSH example.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a successful login, you will be able to see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00124.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following instructions are for all OS users (OS X, Linux, and Windows)
    as we are logged in to the EC2 instance via SSH. The following commands are required
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands will update the `yum` package manager and install and start
    the Docker service in the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'After you run the `docker info` command, it will show something similar to
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00125.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you look at the preceding screenshot, you''ll see that everything is all
    right, and we can continue with running the publishing app''s Docker container
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you have provided your correct `AWS_REGION_NAME`. Mine is `eu-central-1`,
    but yours could be different.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, everything from the `server/.env` file has been moved to the
    `docker run` command in the Bash terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Also make sure to rename `AWS_BUCKET_NAME`, `AWS_REGION_NAME`, or `MONGO_ENV`
    if you have a different one (if you set it differently than what was suggested
    in the previous chapters).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in order to check whether everything went well, you can also use the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will show you whether the Docker process runs correctly in the
    background as a detached container. And after 10-30 seconds, when `npm start`
    will run the whole project, you can test with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'After the application has been bootstraped correctly, you can see output similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00126.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After you visit the EC2 instance''s public IP (in our example, it is `52.29.107.244`),
    you will be able to find our publishing app available online as we have set up
    the security group of our EC2 instance with the exposed port `80` to the world.
    The following is the screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00127.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you see our publishing app under a public IP, then you have just deployed
    a Docker container on Amazon AWS EC2 successfully!
  prefs: []
  type: TYPE_NORMAL
- en: The process we just went through is very inefficient and manual, but shows exactly
    what is going on under the hood when we start using ECS.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are missing the following in our current approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Integration with other Amazon services, such as load balancing, monitoring,
    alerting, crash recovery, and route 53.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation, as currently we are unable to efficiently deploy 10 Docker containers
    quickly. This is also important if you want to deploy different Docker containers
    for different services as, for example, you can have separate containers for serving
    the frontend, backend, and even the database (in our case, we use mLab, so we
    don't need one here).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You've just learned the basics of Amazon Web Services.
  prefs: []
  type: TYPE_NORMAL
- en: Basics of ECS - AWS EC2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The EC2 Container Service helps you create a cluster of Docker Container instances
    (many copies of the same container on several EC2 instances). Each container is
    deployed automatically--this means you don't need to log in to any of the EC2
    instances via SSH as we did it in the previous chapter (manual approach). The
    whole job is done by the AWS and Docker software, which you will learn to use
    in the future (a more automated approach).
  prefs: []
  type: TYPE_NORMAL
- en: For example, you set that you want to have five different EC2 instances--the
    group of EC2 instances in the exposed port 80 so you are able to find the publishing
    application under the `http://[[EC2_PUBLIC_IP]]` address. Additionally, we are
    adding a load balancer between all the EC2 instances and the rest of the world
    so that in case there is any spike in traffic or any of the EC2 instances break,
    the load balancer will replace the broken EC2 instance with a new one or scale
    down/up the number of EC2 instances based on the traffic.
  prefs: []
  type: TYPE_NORMAL
- en: A great feature of the AWS load balancer is that it pings each EC2 instance
    with port 80, and if the pinged instance doesn't respond with the correct code
    (200), then it terminates the broken instance and turns on a fresh new instance
    with the Docker Container that has the image of our publishing app. This helps
    us maintain continuous availability of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we will use Amazon Route 53 in order to have a highly available
    and scalable cloud **domain name system** (**DNS**) web service so we will be
    able to set up a top level domain; in our case, I will use a domain I have bought
    specially for the book: `http://reactjs.space`.'
  prefs: []
  type: TYPE_NORMAL
- en: That will be our HTTP address, of course. If you build a different service,
    you need to buy your own domain in order to follow the instructions and learn
    how Amazon Route 53 works.
  prefs: []
  type: TYPE_NORMAL
- en: Working with ECS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start working on ECS, let''s understand some basic nomenclature:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cluster**: This is the main part of our process that will pool underlying
    resources as EC2 instances and any attached storage. It clusters many EC2 instances
    into one containerized application that aims to be scalable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Task definition**: This task determines what Docker Containers you are going
    to run on each EC2 instance (that is, the `docker run` command) and it also helps
    you define more advanced options, such as environment variables that you want
    to pass down into a container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service**: This is a kind of glue between the cluster and a task definition.
    The service handles the login of a running task on our cluster. This also contains
    the management of revisions of the task (combination of a container and its settings)
    you want to run. Every time you change any setting in your task, it creates a
    new revision of your task. In the service, you specify what the task is and its
    revision that you want to run on your EC2 instances in your ECS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Visit the AWS Console and find the ECS. Click on the link to go to the EC2
    Container Service Console. There, you will find a blue button named Get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00128.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After that, you will see an ECS wizard with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a task definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Step 1 - creating a task definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In ECS, a task definition is a recipe for a container. It's something that helps
    an ECS understand what Docker Container you want to run on the EC2 instances.
    It's a recipe or a blueprint of steps that the ECS has automatically done in order
    to successfully deploy our publishing app's container.
  prefs: []
  type: TYPE_NORMAL
- en: 'TheÂ details for this step are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00129.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can find that our task definition name is `pubapp-task`.
    The container name is `pubapp-container`.
  prefs: []
  type: TYPE_NORMAL
- en: For Image, we use the same argument as when we were running a container locally
    with `docker run`. In the case of `przeor/pub-app-docker`, ECS will know that
    it has to download the container from [https://hub.docker.com/r/przeor/pub-app-docker/](https://hub.docker.com/r/przeor/pub-app-docker/).
  prefs: []
  type: TYPE_NORMAL
- en: For now, let's keep the maximum memory at the default value (`300`). Set both
    port mappings to `80`.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, there are some problems if your container
    doesn't expose port `80`. It's probably a bug with the ECS wizard; without the
    wizard, any port can be used on the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on Advanced options in the task definition view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00130.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will see a slide panel with additional options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00131.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to specify the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Command**: This has to be separated with commas, so we useÂ `npm,start`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Working directory**: We use `/opt/publishing-app` (identical path is set
    in the Dockerfile).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Env variables**: Here, we specify all values from the `server/.env` file.
    This part is important to set up; the app will not work correctly without the
    correct details provided via the environment variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rest of the values/inputs**: Keep them at the default without changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's very important to add all the environment variables. We need to be very
    careful as it's easy to make a mistake here that will break the app inside an
    EC2 instance.
  prefs: []
  type: TYPE_NORMAL
- en: After all these changes, you can click on the Next button.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - configuring the service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally, a service is a mechanism that keeps a certain amount of EC2 instances
    running while checking their health at the same time (using the **Elastic Load
    Balancing** (**ELB**)). Â ELB automatically distributes incoming application traffic
    across multiple Amazon EC2 instances. If a server doesn't respond on port 80 (the
    default but can be changed to more advanced health checks), then the service runs
    a new service while the unhealthy one is being shut down. This helps you maintain
    very high availability for your application.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00132.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The service name is `pubapp-service`. In this book, we will set up three different
    EC2 instances (you can set up fewer or more; it's up to you), so this is the number
    for the *desired number of tasks* input.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same step, we also have to set up the **Elastic Load Balancer** (**ELB**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00133.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Container name:host port: Choose from the drop-down list `pubapp-container:80`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ELB listener protocol*: HTTP'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ELB listener port*: `80`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ELB health check: Keep default; you can change it while you are out of the
    wizard (on the specific ELB''s page)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Service IAM role: The wizard will create this for us'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After all this, you can click on the Next step button to continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00134.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Step 3 - configuring the cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, you'll set up the details of the ECS container agent, called a cluster.
    Here, you specify the name of your cluster, what kind of instances you'd like
    to use, the number of instances (it has to be bigger than the number required
    by the service), and the key pair.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00135.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Cluster name: Our cluster name is `pubapp-ecs-cluster`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'EC2 instance type: `t2.micro` (in production, use a bigger one).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Number of instances: Five, and that means the service will keep three instances
    alive and another two instances will be on the bench, waiting for any fatal situations.
    By bench, I mean that at a time (with our setup), we''ll use only three instances,
    whereas another two are ready for use, but not actively used (traffic is not redirected
    to them).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Key pair: I specified the key pair called `pubapp-ec2-key-pair` earlier in
    this chapter. Always keep them in a safe place for later use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the same page, you will also find the security group and container instance
    IAM roles setup, but we''ll keep it at the default for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00136.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Step 4 - reviewing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last thing is to review whether everything looks good:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00137.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, choose Launch instances & run service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00138.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Launch status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After you have clicked on the Launch button, you will find a page with the
    status. Keep it open until you get all the boxes green with success indicators:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00139.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s what it looks like all up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00140.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After all the boxes have a success indicator, then you will be able to click
    on the View service button that is at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00141.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on that button (View service) after it becomes available.
  prefs: []
  type: TYPE_NORMAL
- en: Finding your load balancer address
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After you click on the View service button, you will see the main dashboard,
    where all your clusters are listed (currently there will only be one):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00142.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on pubapp-ecs-cluster and you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00143.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the preceding screen, click on pubapp-service from the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00144.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00145.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'From this page, choose the Elastic Balancer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00146.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The final view of ELB is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00147.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding view, you will find (under the Description Name tab) an elastic
    balancer address like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If you try to open the address and it doesn't work, then give it more time.
    The EC2 instances may be in progress in terms of running our Docker publishing
    app container. We must be patient during the initial run of our ECS cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the address of your ELB, which you can put into the browser and see
    the publishing app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00148.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: AWS Route 53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last step left in this chapter is to set up Route 53, which is a highly
    available and scalable cloud DNS web service.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this step, you have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Having your own domain already registered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering a new domain via Route 53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following procedure, we will use the first option, so we assume that
    we have already registered the `reactjs.space` domain (of course, you need to
    have your own domain in order to successfully follow these steps).
  prefs: []
  type: TYPE_NORMAL
- en: We will route end users to the publishing app by translating the name `http://reactjs.space`
    into the address of our ELB (`EC2Contai-EcsElast-1E4Y3WOGMV6S4-39378274.eu-central-1.elb.amazonaws.com`)
    so that users will be able to visit our application in a more user-friendly manner
    by typing `reactjs.space` into the browser's address bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose Route 53 from the AWS services list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00149.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will be able to see a main page like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00150.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to create a hosted zone on Route 53, so click on the blue
    button called Create Hosted Zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00151.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After this, you won''t see any hosted zones, so click again on the blue button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00152.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The form will have a Domain Name field, where you put your domain name (in
    our case, it''s `reactjs.space`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00153.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Success! Now you will be able to see your DNS names:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00154.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to park the DNSes on your domain''s provider. The last step
    is to change DNS settings at your domain registrar; in my case, they''re as follows
    (yours will be different):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the `.` (dots) at the end; you can get rid of them so the final DNSes
    that we have to change are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: After all these steps, you can visit the `http://reactjs.space` website (the
    DNS change may take up to 48 hours).
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing is to create an alias of the `reactjs.space` domain that points
    to our Elastic Load Balancer. Click the following button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00155.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, you''ll have the following view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00156.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Choose Yes from the alias''s radio button and then select the ELB from the
    list, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00157.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Currently, everything will be working after the DNS changes are finished (which
    may take up to 48 hours). To improve the experience with our application, let's
    also make an alias from `www.reactjs.space` to `reactjs.space`, so if anyone types
    `www.` before the domain name, it will work as intended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click again on the button called Create Record Set, choose an alias, and type
    `www`., after which you will be able to choose the `www.reactjs.space` domain.
    Do so and hit the Create button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00158.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are done with all the AWS/Docker setup. After a successful DNS change, you
    will be able to find our application under the `http://reactjs.space` address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00159.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The next chapter will talk about the basics of continuous integration and also
    help you wrap up the remaining things in the app before it is 100% production
    ready (minification is missing so far).
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue in the next chapter with a more detailed description of the remaining
    topics that are going to be covered in the book.
  prefs: []
  type: TYPE_NORMAL
