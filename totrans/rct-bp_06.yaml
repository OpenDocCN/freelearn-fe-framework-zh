- en: Chapter 6. Advanced React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first part of this chapter, we'll look at **Webpack**, **Redux**, and
    how to write components with the new class syntax introduced in JavaScript 2015\.
    Writing ReactJS components with the class syntax is a little bit different than
    using `React.createClass`, so we'll be looking at the differences and the pros
    and cons.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of this chapter, we'll write an app that handles authentication
    using Redux.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what we''ll cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A new bundling strategy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Browserify works
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How Webpack works
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A difficult choice
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new scaffold with Webpack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Babel configuration
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Webpack configuration
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding assets
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an Express server
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding ReactJS to the mix
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting the server
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Redux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single store
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Actions in Redux
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding reducers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Devtools
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a login API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new bundling strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we've been using Browserify, but from now on, we'll switch to Webpack.
    You may wonder why we should make this switch and what the differences between
    the technologies are.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a closer look at both of them.
  prefs: []
  type: TYPE_NORMAL
- en: How Browserify works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Browserify** works by examining the entry point that you specify and building
    a dependency tree based on all the files and modules you require in your code.
    Each dependency gets wrapped in a `closure` code, which contains the module''s
    source code, a map of the module''s dependencies, and a key. It injects features
    that are native to the *node* but don''t exist in JavaScript, such as **module
    handling**.'
  prefs: []
  type: TYPE_NORMAL
- en: In short, it is able to analyze your source code, find and wrap up all your
    dependencies, and compile them into a single bundle. It's very performant and
    is an excellent start up tool for new projects.
  prefs: []
  type: TYPE_NORMAL
- en: Using it in practice is as simple as writing a set of code and sending it to
    Browserify. Let's write two files that require each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s call the first one `helloworld.js` and place the following code into
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s call the second one `entry.js` and place the following code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, pass both the files to Browserify from the command line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The result will be an immediately invoked function expression (IIFE for short)
    containing your "`hello world`" code. An IIFE is also referred to as an anonymous
    self-executing function or simply a code block that executes as soon as you load
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated code looks rather incomprehensible, but let''s try to understand
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This entire first block passes the module source and executes it. The first
    argument takes our source code, the second a cache (usually empty), and the third
    a key, mapping it to the module it is required from.
  prefs: []
  type: TYPE_NORMAL
- en: 'The inner function is an internal `cache` function. It''s used at the end of
    the function to either retrieve the function from the cache, or store it so that
    it''s ready the next time it''s requested. Here, a required module is listed,
    along with the entire source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this is passed in a parenthesis with three arguments, matching the
    IIFE function.
  prefs: []
  type: TYPE_NORMAL
- en: It's not vital that you fully understand how this works. The important thing
    to take away is that Browserify will generate a complete static bundle containing
    all of your code and will also take care of how they relate to each other.
  prefs: []
  type: TYPE_NORMAL
- en: So far, Browserify looks fantastic. However, there is a fly in the ointment.
    If you want to do something more with your code—for instance, minify it or convert
    *JavaScript 2015* to *ECMAScript 5* or the *ReactJS JSX* code to plain JavaScript—you
    would need to pass additional transforms to it.
  prefs: []
  type: TYPE_NORMAL
- en: Browserify has a huge ecosystem of transforms that you can use to transmogrify
    your code. Knowing how to wire it up is the hard part, and the fact that Browserify
    itself is not entirely opinionated on the matter means that you are left on your
    own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a JavaScript 2015 transform to illustrate how you run Browserify
    with transforms. Change `helloworld.js` to this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the standard `browserify` command now will result in a parse error.
    Let''s try it with the Babel transformer that we''ve been using in our scaffold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The code will now parse.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you compare the resulting code, you'll notice that the generated JavaScript
    2015 code from Babel is rather different from the code Browserify generated using
    plain ECMAScript 5\. It's a little bit bigger (in this example, it's approximately
    25 percent larger, but it's a very small sample code set, so the difference won't
    be as dramatic with a more realistic code set).
  prefs: []
  type: TYPE_NORMAL
- en: You can run the code in several ways. You can create an HTML file and reference
    it in a script tag, or you can simply open a browser and paste it into the console
    window in Chrome or the Scratchpad in FireFox. The result will be the same in
    any case; the text **Hello world!** will appear in your console log.
  prefs: []
  type: TYPE_NORMAL
- en: How Webpack works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like Browserify, Webpack is a module bundler. It's operationally similar to
    Browserify but is very different under the hood. There are many differences, but
    the key difference is that Webpack can be used dynamically, while Browserify is
    strictly static. We'll take a look at how Webpack works and show how this can
    benefit us greatly while using Webpack to write code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with Browserify, generating code with Webpack is initiated from an `entry`
    file. Let''s use the "`Hello World`" code from the previous example (the ECMAScript
    5 version). Webpack requires you to specify an `output` file, so let''s write
    it to `bundle.js` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The generated code is a lot more verbose than Browserify by default and is actually
    quite readable (adding the `-p` parameter will generate a minified version).
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the preceding code will result in the following code being generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Like Browserify, Webpack generates an IIFE. The first thing it does is set
    up a module cache and then check whether the module is cached. If not, the module
    is put into the cache, let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, it executes the `module` function, flags it as loaded, and returns the
    exports of the module, let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it exposes the module''s object, cache, and the public path and then
    returns the entry module, let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`Hello` is now assigned to `__webpack_require__(1)`. The number refers to the
    next module (since it starts counting at `0`). Now refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Both module sources themselves are executed as arguments to the IIFE.
  prefs: []
  type: TYPE_NORMAL
- en: So far, both Webpack and Browserify look very much alike. They both analyze
    your entry file and wrap the sources in a self-executable closure. They also include
    a caching strategy and maintain a relation tree so that it can tell how the module
    requires one another.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, just by looking at the generated code, it's hard to see that there's
    much to separate them, different code styles aside.
  prefs: []
  type: TYPE_NORMAL
- en: There's a very big difference, however, and that is how Webpack has organized
    its ecosystem and configuration strategy. While it's true the configuration is
    convoluted and slightly hard to understand, it's hard to argue against the results
    you can achieve.
  prefs: []
  type: TYPE_NORMAL
- en: You can configure Webpack to do (almost) anything you want, including replacing
    the current code loaded in your browser with the updated code while preserving
    the state of the app. This is called **hot module replacement** or **hmr** for
    short.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack is configured by writing a special configuration file, usually called
    `webpack.config.js`. In this file, you specify the entry and output parameters,
    plugins, module loaders, and various other configuration parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very basic `config` file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s executed by issuing this command from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Or simply, without the `config` parameters, Webpack will automatically look
    for the presence of `webpack.config.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to convert the `source` files before bundling, you use module loaders.
    Adding this section to the Webpack config file will make sure Babel converts JavaScript
    2015 code into ECMAScript 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s review the options in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The first option (required), `test`, is a regex match that tells Webpack which
    files this loader operates on. The regex tells Webpack to look for files with
    a *period* followed by the letters *js* and then any optional letters `(?)` before
    the end `($)`. This makes sure the loader reads both plain JavaScript files and
    JSX files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second option (required), `loader`, is the name of the package that we'll
    use to convert the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third option (optional), `exclude`, is another regex used to explicitly
    ignore a set of folders or files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final option (optional), `query`, contains special configuration options
    for your loader. In our case, it contains options for the Babel loader. For Babel,
    the recommended way to do it is actually setting them in a special file called
    `.babelrc`. We'll be doing this later in the scaffold that we'll develop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A difficult choice – Browserify or Webpack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Browserify gets points for being easy to get started with, but loses out because
    of the increase in complexity when you need to add transforms and because it's,
    in general, more limited than Webpack.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack is harder to grasp initially, but progressively gets more useful as
    you unravel the complexity. The big upside to using Webpack is its ability to
    replace code in runtime with its ecosystem of hot reload tools, and the powerful,
    opinionated way in which it can be extended to suit every need. It's worth noting
    that there's efforts underway to develop an `hmr` module for Browserify as well.
    You can preview the project at [https://github.com/AgentME/browserify-hmr](https://github.com/AgentME/browserify-hmr).
  prefs: []
  type: TYPE_NORMAL
- en: They're both terrific tools, and it's worth learning to use both. For some types
    of projects, using Browserify makes the most sense, and for others, Webpack is
    clearly the way to go.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on, we'll create a new basic setup, a scaffold, which we'll use when
    developing a login app with Redux later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This is going to be a lot of fun!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new scaffold with Webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new folder and initialize it with `npm init` and then add the following
    dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: All but one of the dependencies will be saved as `devDependencies`. When you
    perform an `npm install` command later, all modules in both the `dependencies`
    section and the `devDependencies` section will be installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can specify which section to install by providing `npm` with either the
    `dev` or `production` flag. For instance, this will install only the packages
    in the dependencies section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Your `package.json` file should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The Babel configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, create a new file, name it `.babelrc` (no prefix before the dot), and
    add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This `configuration` file will be used by Babel to use the presets we just installed
    (React and ES2015). It will also instruct Babel which transforms we'd like to
    use. Putting the transforms inside the `env:development` file will make sure it
    won't be accidentally enabled in production.
  prefs: []
  type: TYPE_NORMAL
- en: The Webpack configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let''s add the Webpack configuration module. Create a new file called
    `webpack.config.js` and add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will instruct Webpack to first use the hot module replacement as the initial
    entry point and then our source root. Now refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We'll set the output path to be the `public` folder, meaning that any content
    that is accessed should reside in this folder. We'll also instruct Webpack to
    use the `bundle.js` filename and specify that it should be accessed from the `assets`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: In our `index.html` file, we will access the file via a script tag pointing
    to `assets/bundle.js`, but we won't actually put a real `bundle.js` file in the
    `assets` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The hot middleware client will make sure that when we try to access the bundle,
    the generated bundle will be served instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we''re ready to create the real bundle for production, we''ll generate
    a `bundle.js` file with the production `flag` parameter and store it in `public/assets/bundle.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll use three plugins. The first one makes sure the modules are loaded in
    order, the second is to prevent unnecessary error reporting in our console log,
    and the third one is to enable the hot module loader, such as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll add the Babel loader so that any JavaScript or JSX file gets transpiled
    before being bundled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: And finally, we'll tell Webpack to resolve files that we import regardless of
    them having the `.js` or `.jsx` extension. This means that we will not have to
    write `import foo from 'foo.jsx'`, but can write `import foo from 'foo'` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Adding assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, let's add the `assets` folder and the files we'll reference there. We'll
    create it in the `root` folder rather than create a `public` folder. (We actually
    won't need to do this at all. This folder is not necessary to create while in
    development mode).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the folder and add two files: `app.css` and `favicon.ico`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `favicon.ico` is not strictly necessary, so you may choose to drop it. You
    can probably find one scattered around your computer, or create one by going to
    favicon generator sites such as [http://www.favicon.cc](http://www.favicon.cc).
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason it''s included here is this: if it''s not present, you''ll see failed
    requests for the icon in your log every time you reload your site, so it represents
    log noise that''s worth getting rid of.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `assets/app.css` and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This simply adds a general padding of `50` pixels around the body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to add an `index.html` file. Create it in the root of your app
    and add this content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Creating an Express server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We also need to create an Express app to power our development server. Add
    `server.js` to your root folder and then add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This module lets us join path strings in a more comfortable and safe manner
    than concatenating strings. For one, it takes away our worry of knowing whether
    the directory path has a trailing slash or not.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You almost always get this wrong on your first try when you're concatenating
    strings manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use the Express web server, Webpack, and the Webpack config we just
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll preset the port we''re going to use as `8080` unless it''s specified
    as a parameter to the node. To specify parameters, such as the port, start the
    server in a way that it would look like `PORT=8081 node server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll create a local variable called `app` and point it to a new instance
    of the *Express* web server. We''ll also create another variable called `compiler`
    that will configure *Webpack* to use our `config` file. This is equivalent to
    starting Webpack from the command line with `webpack –config webpack.config.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll define the `assets` folder as a `static` folder in Express. This is
    built-in middleware that configures Express to look for files in the provided
    folders. Middleware is software that serves to glue applications together or provide
    additional functionality. The static middleware lets us reference `app.css` directly
    in the link tag in our `index.html` file rather than referencing the `assets`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll tell *Express* to use `webpack-dev-middleware` with the `compiler` variable,
    along with some extra instructions (`noInfo` will prevent the console log from
    showing the Webpack compile information every time it recompiles; `publicPath`
    instructs the middleware to use the path we defined in our `config` file, and
    `quiet` hushes up any other debug that `noInfo` covers):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This instructs *Express* to use the `hot` `middleware` package (while the previous
    one told it to use the `dev` middleware). The `dev` middleware is a wrapper for
    Webpack that serves the files emitted from Webpack in memory rather than bundling
    them as files. When we couple this with the `hot middleware` package, we gain
    the ability to have any code changes reloaded and executed in the browser. The
    `heartbeat` parameter tells the middleware how often it should update.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can adjust the heartbeat to update more often, but the number chosen works
    rather well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This section routes every request to the Express app to our root folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we start the app on the chosen port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The server is now ready. All you need to complete your setup now is add a ReactJS
    component. We'll use the new ES6 class-based syntax rather than the `createClass`
    syntax we've used until now.
  prefs: []
  type: TYPE_NORMAL
- en: Adding ReactJS to the mix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a new folder called `source` and add a file called `index.jsx`. Then, add
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `render` function looks the same as before.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we've also not used commas anymore to separate our functions. They
    aren't necessary within a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The last function call is made to react-dom `render`, which takes care of populating
    the document container with the `app` ID along with the contents of our source
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re ready to run our server and be able to see the results for the first
    time. Start the app by executing `node server.js` in your terminal and open `http://localhost:8080`
    in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting the server](img/B04943_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You should now be greeted with the intro text you added to `source/index.jsx`.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You've completed all the steps necessary to get going with
    Webpack and hot reload.
  prefs: []
  type: TYPE_NORMAL
- en: Granted, this setup is a bit more complex as compared to the `Browserify` setup,
    but the benefits of increased complexity will be apparent to you as you go ahead
    and make modifications to your source files; you'll be able to see the changes
    being updated in your browser as soon as you hit the **Save** button.
  prefs: []
  type: TYPE_NORMAL
- en: This is superior to the way we did it before because the app is able to keep
    the state of the app intact, even while reloading changes in your code. This means
    that when you're developing a complex app, you don't need to reiterate a lot of
    state changes to reach some code that you changed. This is guaranteed to save
    you a lot of time and frustration in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we've used **Reflux** to handle store and state interaction, but
    moving forward, we'll use a different implementation of the *Flux* architecture.
    It's called **Redux** and is quickly gaining traction as a superior *Flux* implementation.
  prefs: []
  type: TYPE_NORMAL
- en: It's also infamous for being hard to understand, throwing both newcomers and
    experienced developers off-kilter with its duality of simplicity and complexity.
    This is partly because it's purely a functional approach to *Flux*.
  prefs: []
  type: TYPE_NORMAL
- en: When ReactJS was first introduced to the public in late 2013 / early 2014, you
    would often hear it mentioned together with functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: However, there's no inherent requirement to write functional code when writing
    React, and JavaScript itself being a multi-paradigm language is neither strictly
    functional nor strictly procedural, imperative, or even object-oriented.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of benefits to choosing a functional approach:'
  prefs: []
  type: TYPE_NORMAL
- en: No side-effects allowed, that is, the operation is stateless
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always returns the same output for a given input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ideal for creating recursive operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ideal for parallel execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to establish the single source of truth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to debug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to persist the store state for a faster development cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to create functionalities, such as undo and redo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to inject a store state for server rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of stateless operations is possibly the number one benefit, as it
    makes it very easy to reason the state of your application. We already used this
    approach with the *Reflux* example in our first app in [Chapter 2](ch02.html "Chapter 2. Creating
    a Web Shop"), *Creating a Web Shop*, where the store state was only changed in
    the main app and then propagated downward to all the app's children. This is,
    however, not the idiomatic *Reflux* approach, because it's actually designed to
    create many stores and have the children listen to changes separately.
  prefs: []
  type: TYPE_NORMAL
- en: The application state is the single hardest part of any application, and every
    single implementation of *Flux* has attempted to solve this problem. *Redux* solves
    it by not actually doing *Flux* at all; it actually uses an amalgamation of the
    ideas of *Flux* and the functional programming language, **Elm**.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three parts to *Redux*: **actions**, **reducers**, and **the global
    store**.'
  prefs: []
  type: TYPE_NORMAL
- en: The global store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Redux*, there is only one global store. It is an object that holds the state
    of your entire application. You create a store by passing your `root-reducing`
    function (or reducer for short) to a method called `createStore`.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than creating more stores, you use a concept called **reducer composition**
    to split data-handling logic. You will then need to use a function called `combineReducers`
    to create a single root reducer.
  prefs: []
  type: TYPE_NORMAL
- en: The `createStore` function is derived from Redux and is usually called once
    in the root of your app (or your `store` file). It is then passed on to your app
    and then propagated to the app's children.
  prefs: []
  type: TYPE_NORMAL
- en: The only way to change the state of the store is to dispatch an action to it.
    This is not the same as a Flux dispatcher, because Redux doesn't have one. You
    can also subscribe to changes from the store in order to update your components
    when the store changes state.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An action is an object that represents an intention to change the state. It
    must have a type field that indicates what kind of action is being performed.
    They can be defined as constants and imported from other modules.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from this requirement, designing the structure of an object is entirely
    up to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic action object can look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `payload` property is optional and can work like objects we discussed earlier
    or any other valid JavaScript type, such as a function or primitive.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding reducers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **reducer** is a function that accepts an accumulation along with a value
    and returns a new accumulation. In other words, it returns the next state based
    on the previous state and an action.
  prefs: []
  type: TYPE_NORMAL
- en: It must be a pure function, free of side effects, and it does not mutate the
    existing state.
  prefs: []
  type: TYPE_NORMAL
- en: For smaller apps, it's okay to start with a single reducer, but as your app
    grows, you split off smaller reducers that manage specific parts of your state
    tree.
  prefs: []
  type: TYPE_NORMAL
- en: This is what's called **reducer composition** and is the fundamental pattern
    of building apps with Redux.
  prefs: []
  type: TYPE_NORMAL
- en: You start with a single reducer, but as your app grows, you need to split it
    off into smaller reducers that manage specific parts of the state tree. Because
    reducers are just functions, you can control the order in which they are called,
    pass additional data, or even make reusable reducers for common tasks such as
    pagination.
  prefs: []
  type: TYPE_NORMAL
- en: It's okay to have many reducers. In fact, it's encouraged.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Redux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s add *Redux* to our scaffold and see how it works. You only need two
    packages when getting started with redux: `redux` and `react-redux`. We''ll add
    a few more to our app that will help us debug when we are developing the app.
    First, install these dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When this is done, the `devDepencies` section of your `package.json` file should
    have these packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's worth noting that new versions get released all the time, so it's good
    to make sure you have the same version numbers that were current when these examples
    were written. You can install the exact version numbers when you install packages
    by adding the version number to the `install` command, like we've done in the
    preceding code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a login app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've made a new scaffold based on Webpack and added Redux to the mix,
    let's go ahead and make an app that handles authentication using the new libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to start by adding an action. The app we'll be making is a login
    app, where you'll be prompted for a username and password upon entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by making a folder structure separating the functionality. Create
    a folder called `actions` within the `source` folder and add a file called `login.js`;
    then, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`Fetch` is a new interface for fetching resources. It will be recognizable
    if you''ve used `XMLHttpRequest` in the past or **Superagent** with **Promises**,
    as we''ve used in previous chapters. The new API supports Promises out of the
    box, supporting a generic definition of Request and Response objects. It also
    provides a definition for concepts such as **Cross-Origin Resource Sharing** (**CORS**)
    and HTTP Origin header semantics.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have used `Fetch` right out of the box with Babel, but this package
    is preferable because it adds `Fetch` as a global function that has a consistent
    API for use in both server and client code. This will be in a later chapter where
    we''ll create an isomorphic app. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This defines a single action constant that we can use when we want to dispatch
    the action. Now check this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we create and export a single function called `login` that accepts
    a `userData` object. Now we''ll create a `body` variable that holds the username
    and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not strictly necessary as we can easily pass the `userData` object
    along, but the idea is that by making it explicit, we''re sending a username and
    password and nothing else. This will be easy to understand when you look at the
    next chunk of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We will send the `POST` request with an `Accept` header and `Content-Type`,
    both specifying that we're working with JSON data. We'll also send an authorization
    header with a bearer token.
  prefs: []
  type: TYPE_NORMAL
- en: You have seen this bearer token before, in [Chapter 4](ch04.html "Chapter 4. Building
    a Real-Time Search App"), *Building a Real-Time Search App*. The API that we're
    going to reference is very similar to the one we built then. We'll look at the
    API as soon as we're finished with the frontend code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The body is passed through the `JSON.stringify()` method because we can''t
    send a raw JavaScript object through HTTP. The method converts an object to a
    proper JSON representation, optionally replacing values if a replacer function
    is specified. Check this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This is the `return` section of our `login` function. It first connects to our
    login API through the `fetch` function, which returns a `Promise`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that we're using the new backticks available through JavaScript 2015.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the Promise is resolved, we fetch the JSON response from the object through
    the `native json()` method available with the fetch API. Finally, we return the
    JSON data through a dispatch to an internal function called `setLoginDetails`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: If `json` contains a valid response, `setLoginDetails` returns an `action` object
    with a type that maps to the `LOGIN_USER` string value and two custom values.
    Remember that an action must always return a `type` and that anything else it
    returns is optional and up to you. If the `json` parameter is empty, the function
    returns `LOGIN_FAIL`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a reducer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next file we''re going to add is a `reducer`. We''ll put it in a folder
    of its own. So create a folder called `reducers` within `source` and add a file
    called `login.js` (same as the action), then add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll import the file we just created as well as the `combineReducer()` method
    from Redux. We''ll only create one reducer for now, but I like to add it from
    the start since it''s typical to add more reducers as the app grows. It generally
    makes sense to have a `root` file to combine reducers as the number of your reducers
    grow. Next, we''ll declare a function that expects a `state` object and `action`
    as its arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'When `action.type` returns a successful state, we return the state and add
    or update the `userData` and `timestamp` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in order to use the spread operator in our reducer, we need to add
    a new preset to our `.babelrc` configuration. This is not part of EcmaScript 6
    but is proposed as an extension to the language. Open up your terminal and run
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, modify the presets section in `.babelrc` so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also add a *case* in case there is a failure to log the user in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll add a *default case*. It''s not strictly necessary, but it''s
    generally prudent to handle any unforeseen cases like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Creating a store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next file we''re going to add is a store. Create a folder called `stores`
    within your `source` folder, add the `store.js` file, and then add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll import the `reducer` we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We'll need a few methods from Redux. The `devtools` package is needed for development
    only and must be removed when going to production.
  prefs: []
  type: TYPE_NORMAL
- en: In computer science, `thunk` is an anonymous expression that has no parameters
    of its own wrapped in an argument expression. A `redux-thunk` package lets you
    write action creators that return a function instead of an action. The `thunk`
    package can be used to delay the dispatch of an action, or to dispatch only if
    a certain condition is met. The inner function receives the store methods dispatch
    and `getState()` as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use this to send an asynchronous dispatch to our login API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Adding devtools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Devtools are the primary way you will work with the state in your app. We'll
    install the default log and dock monitors, but you may develop your own if they
    don't suit you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file called `devtools.js` to your `source` folder and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '`Monitors` are separate packages, and you can make custom ones, let''s take
    a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '**Monitors** are individually adjustable with props. Take a look at the source
    code for the devtools to learn more about how they''re built. Here, we put `LogMonitor`
    inside a `DockMonitor` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Tying the files together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s time to tie the app together. Open `index.jsx` and replace the existing
    content with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This adds all the files we created and the methods we needed from ReactJS.
    Now refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This function dispatches the `login` action we defined in `actions/login.js`
    with the contents of the `username` and `password` input fields defined in the
    `render()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a small piece of JSX code that we use to display either a welcome message
    or an error message after a login attempt. Now check out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: These are the input fields for logging in a user.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we must bind the context ourselves with `.bind(this)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `createClass`, binds were created automatically, but no such magic exists
    when you use JavaScript 2015 classes. The next iteration of JavaScript may bring
    a proposed new syntactic sugar for bind (`::`), which means that we could have
    used `this.handleSelect` without explicitly binding it, but it''s still a way
    off from being implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This `render` block simply presents the visitor with the option to log in. The
    app will attempt to log in when the user clicks on *Enter*, and it will either
    present the visitor with a welcome message or the **invalid login** message.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function converts the app state to a set of properties that we can pass
    to the children components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This is where we define the app with the Redux `connect()` method, which connects
    a React component to a Redux store. Rather than modifying the component in place,
    it returns a new `component` class that we can render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a new component class that wraps the `LoginApp` component inside
    a `Provider` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Provider` component is special because it is responsible for passing the
    store as a property to the children components. It''s recommended that you create
    a `root` component wrapping the app inside `Provider`, unless you want to manually
    pass the store yourself to all children components. Finally, we pass the `Root`
    component to render it and to ask it to display the contents inside `div` with
    the ID `App` in `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of doing this is illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tying the files together](img/B04943_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The app itself looks very unassuming, but it's worth looking at the devtools
    to the right of the screen. This is the *Redux dev tools*, and it tells you that
    you have an app state with a user object with two keys. If you click on **user**,
    it will open and show you that it consists of an object with an empty `message`
    string and an empty `userData` object.
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly how we configured it in `source/index.jsx`, so if you see this,
    it's working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Try to log in by typing in a username and password. Hint: the combo *darth/vader*
    or *john/sarah* will let you log in.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that you can now instantly navigate through your app state by clicking
    on the action buttons in your developer toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: Handling refresh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your app is ready and you're able to log in, but if you refresh, your login
    information is gone.
  prefs: []
  type: TYPE_NORMAL
- en: While it'd be nice if your users never refreshed your page after login, it's
    not feasible to expect this behavior from your users, and you'd surely be left
    with users either complaining or leaving your site and never coming back.
  prefs: []
  type: TYPE_NORMAL
- en: What we need to do is find a way to inject the previous state in our stores
    upon initializing. Fortunately, this is not very hard; we just need a secure place
    to store the data that we want to survive a refresh.
  prefs: []
  type: TYPE_NORMAL
- en: To this end, we'll use `sessionStorage`. It is similar to `localStorage`, the
    only difference being that while data stored in `localStorage` has no expiration
    set, any data stored in `sessionStorage` gets cleared when the page session ends.
  prefs: []
  type: TYPE_NORMAL
- en: A session lasts for as long as the browser window is open and it survives page
    reloads and restores.
  prefs: []
  type: TYPE_NORMAL
- en: It doesn't support opening the same page in a new tab or a window, which is
    the main difference between this and, for instance, session cookies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we''ll do is change `actions/login.js` and modify the function
    `setLoginDetails`. Replace the function with this code (and note that now we will
    export it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll then enter `index.jsx` and add the function to our imports. Add it to
    the line with imports from `actions/login` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, we''ll add a new function within the `App` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Before the component mounts, it will check whether there's a stored entry inside
    `sessionStorage` that holds the user info. If there is, it will dispatch an action
    call to `setLoginDetails`, which will simply set the state to logged in and display
    the familiar welcome message.
  prefs: []
  type: TYPE_NORMAL
- en: And that's all you need to do.
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways to inject a state than by simply dispatching actions. You
    could do it in the `mapStateToProps` function and set an initial state based on
    `sessionStorage`, session cookies, or some other source of data (we'll come back
    to this when making an isomorphic app).
  prefs: []
  type: TYPE_NORMAL
- en: The Login API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the app we just created, we logged in to an existing API. You may wonder
    how the API is constructed, so let's take a look at it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the API, start a new project and execute `npm init` to create an
    empty `package.json` file. Then, install the following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Your `package.json` file should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: We'll use **3** to hold our user data as we did in [Chapter 4](ch04.html "Chapter 4. Building
    a Real-Time Search App"), *Building a Real-Time Search App*, and I refer you to
    this chapter to set it up on your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire API is a single Express application. Create a file in the root of
    your app called `index.js` and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Cross-Origin Resource Sharing (CORS) defines a way in which a browser and server
    can interact to safely determine whether or not to allow a cross-origin request.
    It''s famous for making life hard for API developers, so it''s worth your while
    to install the `cors` package and use it in your Express app to alleviate the
    pain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll use a free MongoLab instance if it exists in our config file, or a local
    MongoDB database if not. We''ll use the same token as in [Chapter 4](ch04.html
    "Chapter 4. Building a Real-Time Search App"), *Building a Real-Time Search App*,
    but we''ll look at making it more secure in a later chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The database model is very simple, but could be expanded to add user e-mail
    addresses and more information if it''s deemed as worthwhile to fetch. However,
    the more information you ask for, the less likely it is that the user will sign
    up for your service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll encrypt all passwords stored in the database with AES 256-bit encryption.
    This is a very strong form of security (and is in fact the same as the TLS/SSL
    encryption used for secure communication on the Internet):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the functions we''ll use to encrypt and decrypt user passwords. We''ll
    accept user password as text, then encrypt it and check whether the encrypted
    version exists in our database. Now check this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: This API needs `POST` data, so we'll display helpful information to anyone trying
    to access this via `GET`, since it isn't possible to fetch any data with the `GET`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll look for usernames and passwords and make sure we lowercase them because
    we don''t support variable case strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Moreover, we'll also specify that the password should not be a part of the resulting
    result set by setting the field to `0` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll then search our database for a user that has the requested username
    and the provided password (but we need to make sure to look for the encrypted
    version). This way, we never know what the user''s real password is. The API will
    use `/v1` as the route prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you could alternately use an `accept` header to separate between
    versions of your API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can start the API. When we try to send a `GET` request, we get
    the anticipated error response, and when we send a valid body with the correct
    username and password, the API delivers the data it has. Let''s take a look at
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Login API](img/B04943_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! With this, you've just completed the advanced ReactJS chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You've learned the difference between Browserify and Webpack and made a new
    basic setup with Webpack and hot module replacement that provides you with a fantastic
    developer experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ve also learned how to create React components using JavaScript 2016 classes
    and how to add the popular state management library: Redux. Furthermore, you wrote
    another API, this time the one used for logging in users with a username and password.'
  prefs: []
  type: TYPE_NORMAL
- en: Pat yourself on the back, because this was a very heavy chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The finished project can be viewed online at [https://reactjsblueprints-chapter6.herokuapp.com](https://reactjsblueprints-chapter6.herokuapp.com).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll use what we've learned in the last couple of chapters
    to write a web app that relies heavily on web APIs and the Webpack/Redux setup
    from this chapter. Roll up your sleeves because we're going to make a social network
    based around snapping images.
  prefs: []
  type: TYPE_NORMAL
