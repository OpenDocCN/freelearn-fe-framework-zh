- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Server Components & Server Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create and use **React Server Components** ( **RSCs** )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe how (and when) RSCs are executed and rendered to the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetch data and perform asynchronous operations with the help of RSCs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Draw server-client boundaries by building and using client components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform server-side data mutations with the help of Server Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the **user interface** ( **UI** ) in response to Server Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned that you can use **server-side rendering**
    ( **SSR** ) to render React components on the server. SSR ensures that users receive
    a fully populated HTML document upon their initial HTTP request, not an almost
    empty page shell. You were also introduced to Next.js and learned how you may
    use that framework to build React apps that come with SSR (and many other useful
    features) out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter builds upon the previous one—specifically, you’ll learn about
    two crucial React features that are unlocked by Next.js: **React Server Components**
    ( **RSCs** ) and **Server Actions** .'
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, you’ll learn how these two features help with data
    fetching and mutations, and why you can’t use them in every React project, even
    though they’re technically part of React—not Next.js.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: RSCs and Server Actions are relatively new React features. Supporting them in
    custom React projects is tricky, as you will learn throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Whilst unlikely, it is possible that concepts or features related to RSCs or
    Server Actions change. It’s also possible that supporting these features in custom
    projects gets easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s why this book comes with a dedicated document that tracks any significant
    changes you should be aware of: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/main/CHANGELOG.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/main/CHANGELOG.md)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: The Problem with Server-side Data Fetching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have an SSR-enabled React app, either by manually enabling it, for example,
    in a Vite-based project, or by using a framework like Next.js, your React component
    functions get executed on the server. Thus, any data required by those components
    should be fetched on the server.
  prefs: []
  type: TYPE_NORMAL
- en: But as explained in the previous chapter, in the *Server-side Data Fetching
    Is Not Trivial* section, sending HTTP requests with the help of `useEffect()`
    or trying to update the UI via `useState()` does not work when using SSR. On the
    server, React only calls the component functions once—it does not re-execute them
    when the state changes. It also doesn’t call your effect functions.
  prefs: []
  type: TYPE_NORMAL
- en: This is a serious limitation since many React apps need to fetch data from some
    backend or a database. Not being able to fetch and render that data on the server
    means that website visitors will again receive incomplete HTML documents (and
    wait for the data to be fetched on the client side), and search engine crawlers
    will not see the most important content of the web page.
  prefs: []
  type: TYPE_NORMAL
- en: That’s one of the reasons why React introduced **RSCs** .
  prefs: []
  type: TYPE_NORMAL
- en: Introducing RSCs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RSCs, despite their name, are not necessarily components that run on a server.
    Instead, their defining characteristic is that their component functions are never,
    under any circumstances, executed on the client side!
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, RSCs may be executed on a server, but they may also be called
    during the build process, hence pre-generating components at build time. They
    definitely won’t be executed in the browser, though.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a server  Description automatically generated](img/B31339_16_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.1: RSCs can’t be called from the client side'
  prefs: []
  type: TYPE_NORMAL
- en: But what’s the purpose of RSCs? How are they created and used?
  prefs: []
  type: TYPE_NORMAL
- en: Making Sense of RSCs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core idea behind RSCs is that you can build components that render outside
    of the browser (e.g., on the server). As a result, these components can execute
    code that wouldn’t work in the browser—for example, because Node.js-specific APIs
    are used, or code that relies on credentials (e.g., database credentials) that
    must not be exposed to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike “normal” components (client components) that are rendered via SSR, RSCs
    can be rendered (on the server) after the initial page load. Hence, RSCs are not
    just about rendering an initial page snapshot. In addition, RSCs can fetch data
    on the server side. Later in this chapter, the *RSCs vs Server-side Rendering*
    section will take a closer look at the relationship between RSCs and “normal”
    components rendered via SSR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, RSCs solve an important problem: they allow you to intertwine frontend
    and backend React code. Whereas, in the past, before RSCs, you typically had to
    build separate backend and frontend web applications, you can now build integrated
    fullstack apps that blend server-side and client-side React code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using RSCs therefore offers various advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Building fully integrated fullstack applications where the backend and frontend
    are closely connected and use the same server becomes much easier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Asynchronous server-side data fetching inside of components becomes possible:
    Unlike on the client side (or when using SSR), React allows you to use `async/await`
    and return a `Promise` value in your component functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Website visitors download smaller client-side JavaScript bundles since the code
    of RSCs is omitted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running compute-heavy operations or using large third-party libraries gets easier
    since the operations and their code can be outsourced to the server (or to the
    build process).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code or credentials that shouldn’t be accessible by your website users can be
    moved into RSCs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, thanks to RSCs, you can create components like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `ProductsPage` component contains code that reaches out to a PostgreSQL
    database to fetch product data from there.
  prefs: []
  type: TYPE_NORMAL
- en: Without RSCs, this kind of component would be impossible to build and use. You
    wouldn’t be allowed to use `async/await` , the `pg` package might rely on some
    APIs that are not available in the browser, and you would expose your database
    credentials in the client-side code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: All these things are allowed when building RSCs. React explicitly does allow
    you to return a `Promise` (and hence use `async/await` ) when building an RSC.
    Since the code is guaranteed to never end up on the client side, connecting to
    a database is safe, too.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, you can easily build fully integrated fullstack apps where backend
    and frontend code blend seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: However, using RSCs is both simple and complex at the same time, as the next
    section will explain.
  prefs: []
  type: TYPE_NORMAL
- en: Creating & Using RSCs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a Next.js project that uses the App Router, all React components, no matter
    if used as pages or nested in some other component, are, by default, RSCs.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can tell if you inspect any React component function in a Next.js project,
    there really is nothing special about them. They look like regular React components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You may use `async/await` with them, but you don’t have to. You may use server-side
    APIs and packages, but you don’t have to. So, creating RSCs is simple—they’re
    just normal components after all.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same is true for using them—you use them as you always used React components:
    as custom JSX elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you wouldn’t be able to tell that this is a special kind of
    component. It’s created and used as you learned it through this entire book.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, all the other components from all the other chapters of this book,
    which were used in Vite-based React projects, were not RSCs. They were regular
    components or **client components** .
  prefs: []
  type: TYPE_NORMAL
- en: So, what makes the components in a Next.js project special? Why is a feature
    provided by React available in Next.js projects but not necessarily in other React
    projects (e.g., in Vite-based projects)?
  prefs: []
  type: TYPE_NORMAL
- en: Unlocking RSCs in React Projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RSCs are a feature provided by React, not Next.js. Yet, not all React projects
    can use this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for that, and for why RSCs are available in Next.js projects, is
    the Next.js build process and what Next.js does to these components (and to the
    entire React project code, actually) behind the scenes. At a high level, you can
    think of Next.js doing the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: The build workflow and bundling process separates server and client components
    to ensure that no RSC code ends up on the client side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next.js sets up API endpoints (i.e., URL addresses to which the client-side
    code may send requests) that trigger RSC component functions on the server and
    return instructions that allow the client-side React code to update the UI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next.js calls these endpoints when needed—for example, when navigating to a
    new page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next.js passes the API response (which contains these rendering instructions)
    to React, which uses the returned instructions to update the UI as needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![img](img/B31339_16_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.2: Client and server component code are separated; communication
    happens via HTTP requests'
  prefs: []
  type: TYPE_NORMAL
- en: Technically, it’s a bit more complex than that, but for the purpose of this
    book and for using the feature, a deep understanding of the internals is not required—just
    as you don’t need to understand what exactly happens internally when using `useState()`
    , for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can verify the mentioned points by running a demo Next.js project you find
    here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/16-rsc-server-actions/examples/01-rsc-intro](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/16-rsc-server-actions/examples/01-rsc-intro)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'This demo app consists of two basic page component files: `app/page.js` and
    `app/info/page.js` . The main page component (the `Home` component inside `app/page.js`
    ) outputs a `ServerComponentInfo` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'That component in turn simply outputs some static, hardcoded content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Both the `Home` and the `ServerComponentInfo` components are RSCs—simply because
    they are components in a Next.js project. As mentioned earlier, all components
    in Next.js projects are server components by default. If these components were
    part of a Vite-based React project that is not set up to support RSCs, these components
    would instead be “normal” components (client components).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same demo project, there is also a component for the `/info` page. This
    component contains some code that wouldn’t work in a component that isn’t an RSC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This code wouldn’t work in any of the (Vite-based) React projects you saw before
    in this book because of the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The `InfoPage` component uses Node’s `fs` package to load data from a `rsc-info.json`
    file (which is part of the project).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The component uses `async/await` , hence returning a `Promise` that eventually
    yields the JSX code (i.e., the React elements).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In projects that do not support RSCs, you’re not able to use server-side APIs
    since all the code runs in the browser. You’re also not allowed to return a `Promise`
    in your components. In non-RSCs, that would not be considered a valid component
    function return value. When working with RSCs, both things are allowed and possible,
    though.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the *Making Sense of RSCs* section, using server-side functionalities
    (like Node.js APIs) is something that’s unlocked because the `InfoPage` component,
    like all components in Next.js projects, is an RSC. For RSCs, React also supports
    the usage of `async/await` .
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, as expected, you won’t find the code of the `InfoPage` component
    in the client-side JavaScript code bundles. You can verify this by visiting the
    `/info` page. If you open the **Network** tab in the browser developer tools,
    and you then reload the page, you’ll see all the HTTP requests sent to the server.
    This includes all requests for JavaScript code files that are needed on the client
    side of this React app.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_16_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.3: When visiting /info, requests for CSS, JS, and some other files
    are sent to the server'
  prefs: []
  type: TYPE_NORMAL
- en: If you then go through all the JavaScript files requested and search for `rsc-info.json`
    in the downloaded code files, you won’t have any matches in any file. This proves
    that this code, which is part of the `InfoPage` component function, does not end
    up in any client-side code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_16_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.4: The data source filename that’s included in the RSC code can’t
    be found on the client side'
  prefs: []
  type: TYPE_NORMAL
- en: How does the content fetched from the `rsc-info.json` file show up on the screen
    then?
  prefs: []
  type: TYPE_NORMAL
- en: This gets answered if you use a different browser than Chrome or Edge. This
    is required since there is a bug with the **Network** tab in the developer tools
    of Chrome/Edge that leads to the response of a request being hidden under certain
    circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, you can, for example, use Firefox, to visit the root page ( `/` ).
    There, click the link that’s visible on the page to navigate to the `/info` page.
    As you do so, one new HTTP request will be sent. If you inspect that request and
    its response (in Firefox’s browser developer tools), you’ll see the serialized
    RSC instructions that are returned by the server.
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_16_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.5: Serialized instructions for client-side React are received from
    the server'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it’s not HTML content that’s received as a response. Instead,
    it’s a bunch of serialized instructions that are translated to DOM elements by
    React on the client side (i.e., in the browser).
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, as you can tell, building and using RSCs is simple, but preparing
    the project to handle them is not. Instead, you need a build process that separates
    client and server code, and API endpoints that invoke server component functions
    on the server. You also need client-side code that sends requests to those API
    endpoints whenever the server components should be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: RSCs and Server Actions Can’t Be Used in All Projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thus far in this book, whenever some new React feature was introduced, you could
    simply use it in your React project, no matter whether it was a project created
    and managed by Vite or any other tool (e.g., **create-react-app** ).
  prefs: []
  type: TYPE_NORMAL
- en: With RSCs and Server Actions, this changes. Due to the many things that must
    be done behind the scenes (see the previous section), even though these are features
    provided by React, you can’t just start using them in any React project. Instead,
    to unlock these features, you must have a project that’s configured to support
    them.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, at the point of time where this book is written, RSCs and Server
    Actions can really only be used with the help of frameworks that integrate and
    actively support these features—for example, the Next.js framework.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it is technically possible to set up a project that supports both
    features on your own, but it requires advanced knowledge regarding backend development
    and build workflow configuration. Consequently, most React projects that need
    these features rely on frameworks like Next.js. Since the way you work with RSCs
    and Server Actions will always be the same, no matter in which kind of project
    you use them, this book will therefore ignore the custom setup part and instead
    focus on how to use these two core concepts.
  prefs: []
  type: TYPE_NORMAL
- en: RSCs vs Server-side Rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At first sight, using RSCs may look similar to SSR React components. After all,
    both concepts are about running some code outside of the browser.
  prefs: []
  type: TYPE_NORMAL
- en: But even though the concepts sound similar, they are quite different.
  prefs: []
  type: TYPE_NORMAL
- en: SSR is all about rendering a component tree to HTML when a request is received.
    It’s about creating an initial page snapshot, in the end.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, when building an interactive web application, a vital part of SSR
    is that the pre-rendered HTML snapshot gets hydrated on the client side—as explained
    in the previous chapter (see the *Making Sense of Server-side Rendering (SSR)*
    section and *Figure 15.3* ).
  prefs: []
  type: TYPE_NORMAL
- en: As a result, when using SSR, the entire component tree with all its component
    functions is evaluated on the server side as well as on the client side. There
    is no split between server-side and client-side code—it’s the same app and the
    same component tree on both sides. For that reason, you also can’t have any server-exclusive
    code in your React components.
  prefs: []
  type: TYPE_NORMAL
- en: With RSCs, that changes. The code of their component functions, as explained
    in the previous sections, never ends up on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a software application  Description automatically generated](img/B31339_16_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.6: RSCs are not hydrated; instead, their output is requested via
    HTTP requests'
  prefs: []
  type: TYPE_NORMAL
- en: That’s why an SSR-enabled project doesn’t automatically support RSCs. On the
    other hand, you could set up a project that supports RSCs but also uses SSR for
    some components—components that should be pre-rendered on the server but that
    are also needed on the client side (e.g., because they add interactivity to the
    page). These types of components will be explored in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also worth noting that RSCs, like server-side rendered components in SSR
    projects, only execute once per request. However, RSCs, unlike “normal” components
    rendered via SSR, can be executed on-demand while the app is running. They’re
    not limited to being called to create an initial page snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an important question, though: how can you add interactivity, and,
    for example, handle user input, in React apps where all components are rendered
    on the server? User interaction takes place in the browser, after all.'
  prefs: []
  type: TYPE_NORMAL
- en: RSCs vs Client Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'RSCs provide some convincing advantages (see the *Making Sense of RSCs* section),
    but they also introduce one potentially big problem: if all the component code
    “lives” and executes on the server, there’s no room for client-side interactivity.'
  prefs: []
  type: TYPE_NORMAL
- en: Not All Components Should Be RSCs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you have a component that needs to manage some state (e.g., some shopping
    cart that should only be shown upon user interaction), that state and the UI must
    be managed and updated by client-side React. Because that was (and is) one of
    the main selling points of React: you can use it to build highly reactive and
    interactive UIs. But this goal clearly clashes with the idea of RSCs, where no
    component code makes it to the browser, and where components are only rendered
    once per request.'
  prefs: []
  type: TYPE_NORMAL
- en: That’s why React allows you to define so-called **server-client boundaries**
    by adding the `'use client'` directive at the top of files that contain component
    functions that should run on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_16_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.7: The ‘use client’ directive creates a boundary between server-side
    and client-side code'
  prefs: []
  type: TYPE_NORMAL
- en: You already encountered `'use client'` in the previous chapter, in the *Highlighting
    Active Links & Using the ‘use client’ Directive* section. Back then, this directive
    didn’t make a lot of sense. Now, with your newly gained knowledge about RSCs,
    the purpose behind this directive will become clearer.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `''use client''` added to a component file, the components defined in
    that file become client components. Client components are also pre-rendered on
    the server, but their code executes on the client side, too. They are hydrated,
    as explained in the previous chapter. Thus, unlike the code of server components,
    the code of client components makes it to the client side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `Cart` component is a client component because `'use client'`
    is added at the top of the file. This is required because the `Cart` component
    uses the `useState()` Hook, which only works in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you add the `'use client'` directive to a component file, the component
    functions in that file will be included in the client-side code bundle. Thus,
    the component functions can (and will) be executed in the browser—therefore you
    can use features that rely on running there, like `useState()` or code that should
    run upon user input (e.g., if a `<button>` was pressed).
  prefs: []
  type: TYPE_NORMAL
- en: That’s also why Next.js shows an error if you try to use a Hook in a component
    that’s not marked as a client component via `'use client'` .
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_16_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.8: Next.js complains about the usage of the useState() Hook in an
    RSC'
  prefs: []
  type: TYPE_NORMAL
- en: 'This error occurs because you’re trying to build something impossible: a component
    that’s only evaluated on the server but that also reacts to user input and updates
    some state. Since the latter, as you learned in *Chapter 4* , *Working with Events
    and State* , will typically result in a UI update, the code needs to execute on
    the client side—something that’s clearly in conflict with the goal of running
    the component code only on the server.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, `'use client'` must be added whenever you have a component that needs
    to run in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you will not need to add the `'use client'` directive in projects
    that don’t implement RSCs. That’s why you didn’t see it in any other React project
    in earlier chapters.
  prefs: []
  type: TYPE_NORMAL
- en: ‘use client’ Affects Child Components, Too!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the `''use client''` directive in a component file has one very important
    implication: all nested components become client components, too—even if you don’t
    use `''use client''` in their component files.'
  prefs: []
  type: TYPE_NORMAL
- en: This is technically necessary since the JSX code of client components is re-evaluated,
    and all custom components used there are re-executed, every time the client component
    function is called again (e.g., because of some state change)—that’s something
    you learned in *Chapter 10* , *Behind the Scenes of React and Optimization Opportunities*
    .
  prefs: []
  type: TYPE_NORMAL
- en: As a result, all the components nested inside a client component must be client
    components themselves since their code would otherwise not be available on the
    client side.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a product  Description automatically generated](img/B31339_16_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.9: Child components of client components become client components,
    too'
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep the client code bundle small and performant, it’s typically a good
    idea to maximize the number of server components and thus minimize the number
    of client components. Since nested components of client components become client
    components automatically, you should therefore try to move the server-client boundary
    (i.e., the usage of `''use client''` ) as far down the component tree as possible.
    Ideally, only the leaves of your component tree use React Hooks or handle user
    input. Put in other words: only use `''use client''` when you must and try to
    affect as few components with it as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a product  Description automatically generated](img/B31339_16_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.10: The majority of components are RSCs'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16.10* shows an example component tree where only a small subset of
    all components are client components.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The question therefore is this: how can you combine and optimize the usage
    of server and client components in React projects that support RSCs?'
  prefs: []
  type: TYPE_NORMAL
- en: Combining RSCs and Client Components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Typically, you’ll end up with React projects where most components don’t need
    to be client components (therefore, they should be RSCs), but where some component
    functions do need to run in the browser (i.e., they do need `'use client'` ).
  prefs: []
  type: TYPE_NORMAL
- en: You can think of `'use client'` marking the point in the component tree where
    the component type switches from server to client component (see *Figure 16.9*
    and *Figure 16.10* ).
  prefs: []
  type: TYPE_NORMAL
- en: 'For that reason, React allows you to combine both kinds of components in the
    same project, though, you need to follow a couple of important rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Server components may import and render client components (i.e., output a client
    component in their JSX code).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client components must not directly import and render server components that
    rely on server-side features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client components may implicitly render server components via props (e.g., via
    the `children` prop).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make these rules a bit less abstract, each case will be shown with a concrete
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Outputting Client Components in Server Components
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can use client components in the JSX code of server components without issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example `UserTodos` component, which allows users to
    manage an array of to-dos that’s stored locally via `localStorage` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Since `localStorage` (a browser API), refs, state ( `todos` via `useState()`
    ), and event listeners ( `submit` via `onSubmit` ) are used, this must be a client
    component. That’s why `'use client'` is added at the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this component can be used in a server component without issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s possible because client components can also be rendered on the server—they’re
    just not exclusive to that environment (unlike RSCs, which are). Put in other
    words: client components are rendered on the server like all components were in
    SSR projects that do not support RSCs (e.g., the Vite-based SSR-enabled project
    from the previous section). An initial snapshot is rendered upon the first request,
    thereafter client-side React takes over and hydrates the component.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, data is loaded from `localStorage` via `useEffect()`
    . This is done to ensure that the code runs on the server. Since `localStorage`
    is not available there, accessing it without wrapping with `useEffect()` would
    cause an error.
  prefs: []
  type: TYPE_NORMAL
- en: Since `useEffect()` is ignored on the server, it’s a safe way of using browser-exclusive
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Outputting Server Components in Client Components
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As already mentioned in the *‘use client’ Affects Child Components, Too!* section,
    you can’t import server components into client components and render them there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though, in many situations, you’ll not get an error. For example, you might
    have a client-side `Cart` component defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike `Cart` , the `CartItem` component function might be a server component
    (i.e., it’s not marked via `''use client''` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This code works because the component that used to be a server component ( `CartItem`
    ) simply becomes a client component once it is imported and used in a client component
    file.
  prefs: []
  type: TYPE_NORMAL
- en: You will, however, face an error message if you’re trying to import and use
    a server component that uses server component-specific features, like a Node.js
    API or `async/await` .
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following adjusted `DynamicCartItem` component tries to use
    Node’s `fs` package to load a cart item from a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Importing and using this component in the `Cart` component will cause an error.
  prefs: []
  type: TYPE_NORMAL
- en: Trying to run this code will lead to an error message being shown on the screen
    because React fails to automatically convert `CartItem` to a client component
    (due to the usage of RSC-exclusive features). Therefore, it’ll complain about
    some server-side code (e.g., some Node.js API) you’re trying to use on the client
    side.
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_16_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.11: React complains about the usage of a Node.js API in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: Hence, in situations like this, you’ll need to restructure your application
    to end up with a valid component combination again. For example, by passing server
    components as props to client components, instead of directly importing and rendering
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering Server Components via Props
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can’t import and use server components that perform some server-side exclusive
    operation (like using Node.js APIs) in client components.
  prefs: []
  type: TYPE_NORMAL
- en: 'But you can change your client component code to not directly import and use
    the server component. Instead, you can expect to get a server component as a prop—for
    example, via the special `children` prop about which you learned in *Chapter 3*
    , *Components and Props* :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This adjusted `Cart` component is still a client component. However, since it
    no longer directly imports and renders the `DynamicCartItem` server component,
    React is happy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, the `DynamicCartItem` component is now imported and output in the
    `Home` component like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `DynamicCartItem` elements are passed as a value for the `children` prop
    to the `Cart` component.
  prefs: []
  type: TYPE_NORMAL
- en: This might be unintuitive at first but it’s vital to understand that this works
    because the `DynamicCartItem` components are now rendered as part of another server
    component—the `Home` component. It’s the result of that rendering process that’s
    then passed as a value to the `Cart` component. That component therefore does
    not include the `DynamicCartItem` component in its part of the component tree.
    Instead, both `Cart` and `DynamicCartItem` are direct children of the `Home` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The overall application component tree would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_16_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.12: DynamicCartItem and Cart are both direct child components of
    the Home component'
  prefs: []
  type: TYPE_NORMAL
- en: Even though, in the finished UI, it might look as if the `DynamicCartItem` is
    a child of `Cart` , technically, it’s not.
  prefs: []
  type: TYPE_NORMAL
- en: It’s key to understand that wrapping a component with another component ( `<Cart><DynamicCartItem
    /></Cart>` ) leads to a different component tree structure than rendering a component
    inside another component.
  prefs: []
  type: TYPE_NORMAL
- en: This is therefore a pattern that can be useful in situations where you might
    need to include a server component in a client component.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, you are able to combine RSCs and client components as needed. Furthermore,
    Next.js also provides some additional features that can help with RSCs and data
    fetching via RSCs.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Data Fetching with Next.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned before, in the *Making Sense of RSCs* section, data fetching via
    RSCs offers various advantages compared to data fetching in client components.
    You don’t have to use `useEffect()` to send HTTP requests to separate backend
    APIs, you can directly reach out to a database, you can use `async/await` , and
    so on. Therefore, it’s absolutely recommended to fetch data via RSCs whenever
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: When working with Next.js, RSC-based data fetching becomes even easier because
    Next.js helps with showing fallback content while you’re waiting for data to arrive.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Loading States with Next.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with Next.js (with the App Router), you can define `loading.js`
    files inside the `app/` folder to set up components that will be rendered while
    sibling or nested server components are loading data. Next.js determines whether
    a component is loading data or not by checking whether it returns a `Promise`
    that hasn’t resolved yet.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will dive even deeper into handling loading states and showing
    fallback content. It will explore React’s Suspense feature, which allows for granular
    loading state management as data streams in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example `GoalsPage` component, which fetches data from a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The function ( `fetchGoals()` ) that performs the actual data fetching has a
    delay built-in to simulate a slow database or network connection.
  prefs: []
  type: TYPE_NORMAL
- en: Without a `loading.js` file added to the project, the user will stare at a blank
    or outdated page for a couple of seconds before the requested page is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_16_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.13: After clicking the link, it takes three seconds for the new page
    to load'
  prefs: []
  type: TYPE_NORMAL
- en: This behavior occurs because the new page is not ready yet and can’t be rendered
    since it’s still fetching data.
  prefs: []
  type: TYPE_NORMAL
- en: To improve the user experience, a `loading.js` file can be added next to the
    slow `app/goals/page.js` file (or, if necessary, in some parent folder, since
    `loading.js` will also display its content for child routes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the newly created `app/goals/loading.js` file, a regular React component
    is created. Like all components in Next.js projects, this is an RSC by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The component name ( `LoadingGoals` ) does not matter. But this component now
    ensures that the `Loading user goals, please wait…` fallback text is shown on
    the screen while the user waits for the `GoalsPage` to load and render.
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_16_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.14: The loading fallback content is shown while the page is transitioning'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you can show any fallback content of your choice—it doesn’t have
    to be some simple text as in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when working with Next.js, adding `loading.js` files to define fallback
    components can tremendously improve the experience of your website users.
  prefs: []
  type: TYPE_NORMAL
- en: Besides fetching data, many React apps also need to change data at some point.
  prefs: []
  type: TYPE_NORMAL
- en: From Data Fetching to Data Mutations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you have learned a lot about RSCs, client components, and how
    they can (and cannot) work together. In the *Making Sense of RSCs* section, you
    also learned about some advantages offered by RSCs.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you also might want to change data, though—not just load and display
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Data Mutations with Server Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React does not just provide support for RSCs; it also allows you to add so-called
    **Server Actions** to your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Server Actions build up on the same idea as client (form) actions, which were
    introduced and explained in *Chapter 9* , *Handling User Input & Forms with Form
    Actions* . However, Server Actions, as their name implies, will execute on the
    server side, not on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, you can use Server Actions to retrieve submitted user input on the server
    and process it there. For example, you could store the submitted data in a file
    or database.
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, Server Actions are an important building block when aiming to
    build fully integrated fullstack React applications. Typically, data fetching
    alone is not enough, which is why the Server Actions feature exists. By having
    both, RSCs and Server Actions, you’re able to fetch and mutate data on the server,
    while still enabling interactive client-side user experiences where needed.
  prefs: []
  type: TYPE_NORMAL
- en: Unlocking Server Actions in React Projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like RSCs, you can’t use Server Actions in all React projects. Instead, a special
    project setup is required to use this feature. For example, Next.js projects support
    Server Actions out of the box (when using the App Router). Just as with RSCs,
    you can think of Next.js doing the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: The build workflow and bundling process separate the code that belongs to Server
    Actions so that it doesn’t end up in the client-side bundle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next.js sets up API endpoints that trigger the Server Action functions and respond
    with any return values defined in those functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next.js calls these endpoints when needed (e.g., when submitting a form that’s
    connected to a Server Action—as shown in the next section).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, Server Actions, like RSCs, can be tricky to support in custom projects
    that do not use Next.js. It’s absolutely possible to create custom projects that
    provide support for both Server Actions and RSCs, but it’s not trivial.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, using Server Actions (in projects that support them) is not complicated,
    though.
  prefs: []
  type: TYPE_NORMAL
- en: Defining and Triggering Server Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in the *Handling Data Mutations with Server Actions* section, Server
    Actions are very similar to the client form actions you already know from *Chapter
    9* .
  prefs: []
  type: TYPE_NORMAL
- en: 'But there are two key differences that must be considered when creating a Server
    Action:'
  prefs: []
  type: TYPE_NORMAL
- en: A Server Action function must be asynchronous— (i.e., it must use `async/await`
    ). There are no synchronous Server Actions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the Server Action function, at the very beginning of the function body,
    you must add the `'use server'` directive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A valid Server Action can therefore be defined and used in a component like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, besides the fact that it must be asynchronous and that it uses
    the `'use server'` directive, this action function looks like the ones you saw
    in *Chapter 9* . It receives a `formData` object that will be provided by React
    when the form is submitted, and you set the `action` function as a value for the
    `action` prop on a `<form>` element.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the previous section, if you were to search for this code in
    the code files downloaded by the browser, you wouldn’t find it—this code really
    only runs on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The `UserFeedback` component from the previous example is an RSC.
  prefs: []
  type: TYPE_NORMAL
- en: If you think about it, this might be strange, though. After all, this component
    does handle some user input and interaction. Why does it work without `'use client'`
    then?
  prefs: []
  type: TYPE_NORMAL
- en: Because Server Actions (bound to the `<form>` 's `action` prop) are special.
    React explicitly supports this pattern inside of RSCs. `'use client'` is indeed
    required for any other kind of user input handling (e.g., if you rely on the `onSubmit`
    or `onChange` props). But binding Server Actions via the `action` prop is supported.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, it’s important to understand that the `'use server'` directive
    only exists to mark actions as Server Actions. You, for example, can’t use it
    to mark components as server components.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the preceding example Server Action currently only logs the input
    to the console. A more realistic action would probably store that data somewhere
    and redirect the user to some other page.
  prefs: []
  type: TYPE_NORMAL
- en: Handling User Input & Updating the UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider this updated version of the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `saveFeedback()` Server Action now stores the extracted feedback via the
    `storeFeedback()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function is defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In a real app, data might be stored in a database. Here, in this simple example,
    it’s simply stored in a `user-feedback.json` file that’s part of the overall Next.js
    project.
  prefs: []
  type: TYPE_NORMAL
- en: As you can tell, just as you can directly reach out to a file or database from
    inside an RSC, you are able to directly edit a file or send a database query from
    inside a Server Action.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also update the UI by programmatically navigating the user to a different
    page thereafter. In a Next.js application, you can use the `redirect()` function
    provided by Next.js to trigger such a navigation action—for example, right after
    storing the submitted feedback text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is a very common pattern when building fullstack applications since you
    often want to navigate your website users to a different page once they have submitted
    data.
  prefs: []
  type: TYPE_NORMAL
- en: But you can also use a different pattern and update the UI that contains the
    form, based on the form submission.
  prefs: []
  type: TYPE_NORMAL
- en: Server Actions and useActionState()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might remember the `useActionState()` Hook from *Chapter 9* , *Handling
    User Input & Forms with Form Actions* . This Hook can be used to derive some component
    state from a (form) action. That state, in turn, can be used to update the UI
    based on the result of the action.
  prefs: []
  type: TYPE_NORMAL
- en: Since a Server Action is a special kind of form action, you can use that same
    Hook to update the UI based on your Server Action and its returned values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you could try using `useActionState()` in the `UserFeedback` component
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'However, using this code would cause an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_16_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.15: React complaints about the usage of a Hook in an RSC'
  prefs: []
  type: TYPE_NORMAL
- en: It’s an error message you already know from the *Not All Components Should Be
    RSCs* section and *Figure 16.8* . React does not allow the usage of Hooks in RSCs—and
    `UserFeedback` is an RSC.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution, of course, is straightforward: simply add the `''use client''`
    directive at the top of the `UserFeedback.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'But with this change applied, you’ll encounter another error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_16_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.16: React now complains about the usage of ‘use server’ and ‘use
    client’ in the same file'
  prefs: []
  type: TYPE_NORMAL
- en: This error message occurs because the `UserFeedback` component file is currently
    using both the `'use client'` and `'use server'` directives—in different places,
    but in the same file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put in other words: you can only define a Server Action (and hence use `''use
    server''` ) inside an RSC—not inside a client component.'
  prefs: []
  type: TYPE_NORMAL
- en: One possible solution for this problem is to move the feedback form and the
    `useActionState()` Hook into a new component that will be used as a child component
    of `UserFeedbackForm` . The Server Action function can then be passed via props
    to that newly added component.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can create a `FeedbackForm` component that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This `FeedbackForm` component expects an `action` prop, which is then passed
    as a value to `useActionState()` . Consequently, the `FeedbackForm` component
    can be used in the `UserFeedback` component like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you were to run this code, the application would work without any problems.
    So, again, just as with RSCs, it’s all about coming up with a working component
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: This is an absolutely valid way of solving this problem. But if you would rather
    not split the `UserFeedback` component into multiple components and outsource
    the form into `FeedbackForm` , there is also another possible solution.
  prefs: []
  type: TYPE_NORMAL
- en: Storing Server Actions in Separate Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can define Server Actions directly inside of RSCs. As you learned in the
    previous chapter, you can also pass them around via props.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative, React also permits storing them in separate files. Doing
    so allows you to build leaner components since the Server Action code is moved
    out of the component functions. Furthermore, React is fine with importing a Server
    Action that’s stored in a separate file into a client component file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering the previous code examples, you could move the `saveFeedback()`
    Server Action into a separate `actions/feedback.js` file in your Next.js project
    folder—though, the file and folder names are entirely up to you. In that file,
    you can then also move the `''` `use server''` directive out of the Server Action
    and put it at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Adding the `'use server'` directive at the top of the file enables you to create
    multiple Server Action functions in that same file. You can then export and use
    them in any other file they might be needed in.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can import the `saveFeedback()` action into the `UserFeedback`
    component, which now doesn’t need the separate `FeedbackForm` child component
    anymore. Since externally stored Server Actions can be imported into client component
    files without issues, the final `UserFeedback.js` file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, storing Server Actions in separate files does not just lead to leaner
    components, but can also help prevent unnecessary component refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Though, no matter which approach you choose, you can use Server Actions to handle
    form submissions on the server. Together with RSCs, you can therefore build fullstack
    applications that seamlessly blend client-side and server-side code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary and Key Takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React supports two special server-side functionalities: RSCs and Server Actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both features are not available in React projects unless the project is specifically
    configured to support them—typically, you’ll therefore need to use a framework
    that supports these features (e.g., Next.js).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RSCs are components that are never rendered on the client side—instead, they
    may be rendered on the server (initiated via HTTP requests) or during the build
    process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RSCs return rendering instructions that are picked up by client-side React.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since RSCs never run on the client side, you may use server-exclusive APIs and
    features in them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React also permits RSCs to return `Promise` values, hence you can use `async/await`
    and fetch data asynchronously without issues in RSCs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to build interactive websites where the UI may change after being rendered,
    you can also mark components as client components by using the `'use client'`
    directive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only client components can use Hooks like `useState()` or set up event listeners.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client components are also pre-rendered on the server, but unlike RSCs, they
    may also execute on the client side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may import and use client components inside of RSCs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When importing server components into client components, the server components
    automatically become client components, if possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an RSC can’t be converted into a client component (e.g., because it uses
    `async/await` ), you’ll need to restructure the component tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may pass server components to client components (without converting them)
    via props.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React helps with handling form submissions on the server via Server Actions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server Actions work like client actions (see *Chapter 9* ) but must be asynchronous
    ( `async/await` ) and use the `'use server'` directive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can define Server Actions inside of RSCs or in separate files—in the latter
    scenario, you can move the `'use server'` directive to the top of the file to
    define multiple Server Actions in the same file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s Next?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned about RSCs and Server Actions. You learned that
    creating and using them is relatively straightforward, but that supporting them
    in projects is not—hence frameworks like Next.js are commonly used to take advantage
    of these features.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter gave you an idea of how RSCs and Server Actions work behind the
    scenes, and which advantages are offered by these features. Throughout this chapter,
    you also learned about client components and how to combine server and client
    components. Finally, Server Actions were discussed and different ways of defining
    and using Server Actions were shown.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will build up on this chapter and explore how React’s **Suspense**
    functionality may help with showing fallback content while fetched data is being
    streamed in.
  prefs: []
  type: TYPE_NORMAL
- en: Test Your Knowledge!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test your knowledge of the concepts covered in this chapter by answering the
    following questions. You can then compare your answers to examples that can be
    found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/16-rsc-server-actions/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/16-rsc-server-actions/exercises/questions-answers.md)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: What is the defining characteristic of React Server Components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the problems that React Server Components solve?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are React Server Components created and used in Next.js projects?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why can’t React Server Components and Server Actions be used in all React projects?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the key difference between Server-Side Rendering (SSR) and React Server
    Components (RSCs)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `'use client'` directive?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the `'use client'` directive affect child components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the rules for combining server components and client components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you handle loading states in Next.js while fetching data with RSCs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are Server Actions in React, and how do they differ from client actions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you trigger a Server Action?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you update the UI after a Server Action?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you define Server Actions in separate files?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply What You Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all the newly gained knowledge about Next.js, it’s time to apply it to
    a real demo project—a demo application that will be rendered on the server.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you’ll find an activity that allows you to practice
    working with Next.js. As always, you will also need to employ some of the concepts
    covered in earlier chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 16.1: Build a Mini Blog'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, your job is to build a very simple blog website (with Next.js)
    that allows users to create and view blog posts. Each blog post should consist
    of a title, date, and body text. A list of blog post titles and dates should be
    rendered on the starting page ( `/` ); upon clicking on a post, users should be
    taken to the details page ( `/blog/<some-id>` ), which shows the complete blog
    post data. A `/blog/new` page should display a form that can be used to create
    a new post.
  prefs: []
  type: TYPE_NORMAL
- en: Posts should be stored in a `posts.json` file (which may simply store an array
    of post objects). After creating a new post, users should be redirected to that
    post’s detail page. If users leave either the title or the body field (or both)
    empty, an error message should be displayed below the form.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: You can find a starting project snapshot for this activity at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/16-rsc-server-actions/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/16-rsc-server-actions/activities/practice-1-start)
    . When downloading this code, you’ll always download the entire repository. Make
    sure to then navigate to the subfolder with the starting code ( `activities/practice-1-start`
    , in this case) to use the right code snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: In the provided starting project, you can explore the `globals.css` file to
    get an idea of the elements and element structure you might want to use to take
    advantage of the provided styles. Of course, you can also set up and use your
    own styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'After downloading the code and running `npm install` in the project folder
    to install all required dependencies, the solution steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add three new `page.js` files (and an appropriate folder structure) for the
    three pages: `/` , `/blog/new` , and `/blog/<some-id>` .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new `posts.json` file in a `data/` folder in the root project folder.
    This file should initially store an empty array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output a `<form>` with title and body input fields on the `/blog/new` page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Server Action in a separate file and import and “connect” it to
    `<form>` . The Server Action should retrieve the entered title and body text,
    create a new object, which also includes an ID and creation date snapshot, and
    store that data in the `posts.json` file. Data must be stored such that existing
    blog posts aren’t lost.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the Server Action to implement input validation and output the validation
    results above the submit button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fetch the blog posts on the starting page and output a list of blog posts (title
    and date). Each post should be clickable and take the user to the details page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the details page, fetch and output the blog post details (by using the ID).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, redirect the user to the appropriate details page from inside the Server
    Action, after a blog post is created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final page should look as shown in the following screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_16_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.17: The home page, showing a list of blog posts'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_16_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.18: The /blog/new page, waiting for user input'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_16_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.19: The /blog/<some-id> page displaying blog post details'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the full code for this activity, and an example solution, here:
    [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/16-rsc-server-actions/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/16-rsc-server-actions/activities/practice-1)
    .'
  prefs: []
  type: TYPE_NORMAL
