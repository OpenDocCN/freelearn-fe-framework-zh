<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting Started</h1>
                
            
            <article>
                
<p class="calibre3">Developing applications in JavaScript is always a challenge. Due to its malleable nature and lack of type checking, building a decent-sized application in JavaScript is difficult. Moreover, we use JavaScript for all types of processes, such as <strong class="calibre5">user interface</strong> (<strong class="calibre5">UI</strong>) manipulation, client-server interaction, and business processing/validations. As a result, we end up with spaghetti code that is difficult to maintain and test.</p>
<p class="calibre3">Libraries such as jQuery do a great job of taking care of various browser quirks and providing constructs that can lead to an overall reduction in the lines of code. However, these libraries lack any structural guidance that can help us when the code-base  <kbd class="calibre13">/grows</kbd>.</p>
<p class="calibre3">In recent years, JavaScript frameworks have emerged to manage this complexity. Many of these frameworks, including earlier versions of Angular, use a design pattern called <strong class="calibre5">Model-View-Controller</strong> to separate the elements of the application into more manageable pieces. The success of these frameworks and their popularity in the developer community have established the value of using this pattern.</p>
<p class="calibre3">Web development, however, is constantly evolving and has changed a lot since Angular was first introduced in 2009. Technologies such as Web Components, the new version of JavaScript (ES2015), and TypeScript have all emerged. Taken together, they offer the opportunity to build a new, forward-looking framework. And with this new framework comes a new design pattern—the component pattern.</p>
<p class="calibre3">This chapter is dedicated to understanding the component pattern and how to put it into practice as we build a simple app using Angular.</p>
<p class="calibre3">The topics that we will cover in this chapter are as follows:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Angular basics</strong>: We will briefly talk about the component pattern that is used to build Angular applications</li>
<li class="calibre12"><strong class="calibre1">Building our first Angular app</strong>: We will build a small game—<em class="calibre2">Guess the Number!—</em>in Angular</li>
<li class="calibre12"><strong class="calibre1">An introduction to some Angular constructs</strong>: We will review some of the constructs that are used in Angular, such as interpolation, expressions, and the data binding syntax</li>
<li class="calibre12"><strong class="calibre1">Change detection</strong>: We will discuss how change detection is managed in an Angular app</li>
<li class="calibre12"><strong class="calibre1">Tools and resources</strong>: Lastly, we will provide some resources and tools that will come in handy during Angular development and debugging</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Angular basics</h1>
                
            
            <article>
                
<p class="calibre3">Let's get started by looking at how Angular implements the component pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The component pattern</h1>
                
            
            <article>
                
<p class="calibre3">Angular applications use the component pattern. You may not have heard of this pattern, but it is all around us. It is used not only in software development but also in manufacturing, construction, and other fields. Put simply, it involves combining smaller, discrete building blocks into larger finished products. For example, a battery is a component of an automobile.</p>
<p class="calibre3">In software development, components are logical units that can be combined into larger applications. Components tend to have internal logic and properties that are shielded or hidden from the larger application. The larger application then consumes these building-blocks through specific gateways, called <strong class="calibre5">interfaces</strong>, which expose only what is needed to make use of the component. In this way, the component's internal logic can be modified without affecting the larger application, as long as the interfaces are not changed.</p>
<p class="calibre3">Getting back to our battery example, the car consumes the battery through a series of connectors. If the battery dies, however, it can be replaced by an entirely new battery, as long as that battery has the same connectors. This means that the builder of the car does not have to worry about the internals of the battery, which simplifies the process of building the car. Even more importantly, the car owner does not have to replace their car every time the battery dies.</p>
<p class="calibre3">To extend the analogy, manufacturers of batteries can market them for a range of different vehicles, for example, ATVs, boats, or snowmobiles. So the component pattern enables them to realize even greater economies of scale.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using the component pattern in web applications</h1>
                
            
            <article>
                
<p class="calibre3">As web applications continue to become more sophisticated, the need to be able to construct them out of smaller and discrete components becomes more compelling. Components allow applications to be built in a way that prevents them from becoming messes of spaghetti code. Instead, component-based design allows us to reason about specific parts of the application in isolation from the other parts, and then we can stitch the application together into a finished, whole through agreed-upon points of connection.</p>
<p class="calibre3">Also, maintenance costs are less because each component's internal logic can be managed separately without affecting the other parts of the application. And putting applications together using self-describing components makes the application easier to understand at a higher level of abstraction.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Why weren't components used before in Angular?</h1>
                
            
            <article>
                
<p class="calibre3">If this idea makes so much sense, why was the component pattern not adopted in earlier versions of Angular? The answer is that the technologies that existed when Angular was first released did not fully support the implementation of this pattern in web applications.</p>
<p class="calibre3">Earlier versions of Angular, however, made substantial steps in the direction of enabling more intelligent web application design and organization. For example, they implemented the MVC pattern, which separates an application into a model, view, and controller (you will see the use of the MVC pattern continuing within the components that we will build in Angular).</p>
<p class="calibre3">With the MVC pattern, the model is the data, the view is a web page (or a mobile app screen or even a Flash page), and the controller populates the view with data from the model. In this way, separation of concerns is achieved. Following this pattern along with an intelligent use of directives will get you pretty close to components.</p>
<p class="calibre3">So, the earlier versions of Angular allowed applications to be designed and built more logically. However, this approach was limited by the fact that the technologies used were not truly isolated. Instead, they all ended up being rendered without any true separation from other elements on the screen.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What's new that enables Angular to use the component pattern?</h1>
                
            
            <article>
                
<p class="calibre3">By contrast, the newest version of Angular embraces recently emerging technologies, which make it possible to implement the component pattern more fully. These technologies include Web Components, ES2015 (the new version of JavaScript), and TypeScript. Let's discuss what each of these technologies brings to the mix that makes this possible.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Web Components</h1>
                
            
            <article>
                
<p class="calibre3">Web Components is an umbrella term that actually covers four emerging standards for web browsers:</p>
<ul class="calibre11">
<li class="calibre12">Custom elements</li>
<li class="calibre12">Shadow DOM</li>
<li class="calibre12">Templates</li>
<li class="calibre12">HTML imports</li>
</ul>
<div class="title-page-name">
<div class="packt_infobox">
<p class="calibre20">More information on Web Components can be found at <a href="https://www.webcomponents.org/introduction" target="_blank" class="calibre21">https://www.webcomponents.org/introduction</a></p>
</div>
</div>
<p class="calibre3">Let's now discuss each of these in detail:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Custom elements</strong> enable new types of DOM elements to be created other than the standard HTML tags such as <kbd class="calibre13">&lt;div&gt;</kbd> and <kbd class="calibre13">&lt;p&gt;</kbd>.  You will see the use of these custom elements throughout this book. For example, the application that we are building in this chapter will have a root element named <kbd class="calibre13">&lt;app-root&gt;</kbd>, but you can give this element any name you like.  Individual components will also use custom elements. For example, in the following chapters we are building a more sophisticated application that breaks the screen down into components. The header of the page will use a custom element <kbd class="calibre13">&lt;abe-header&gt;</kbd>  to display its content (the prefix <kbd class="calibre13">abe</kbd> is unique to our application and helps to avoid naming collisions with native HTML elements or custom elements in other apps). The ability to add custom tags provides a location on the screen that can be reserved for binding a component. In short, this is the first step towards separating a component from the rest of the page and making it possible to become truly self-contained.</li>
<li class="calibre12"><strong class="calibre1">Shadow DOM</strong> provides a hidden area on the page for scripts, CSS, and HTML. Markup and styles that are within this hidden area will not affect the rest of the page, and equally importantly they will not be affected by the markup and styles on other parts of the page. Our component can use this hidden area to render its display. So, this is the second step in making our component self-contained.</li>
<li class="calibre12"><strong class="calibre1">Templates</strong> are fragments of HTML that do not initially render in a web page, but can be activated at runtime using JavaScript. Many JavaScript frameworks already support some form of templating. Web Components standardize this templating and provide direct support for it in the browser. Templates can be used to make the HTML and CSS inside the Shadow DOM used by our component dynamic. So, this is the third step in making our component.</li>
<li class="calibre12">The final standard that makes up Web Components is <strong class="calibre1">HTML imports</strong>. They provide a way to load resources such as HTML, CSS, and JavaScript in a single bundle. Angular does not use HTML imports. Instead, it relies on JavaScript module loading, which we will discuss a little later in this chapter.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Angular and Web Components</h1>
                
            
            <article>
                
<p class="calibre3">Web Components are not fully supported in current web browsers. For that reason, Angular components are not strictly Web Components. It is probably more accurate to say that Angular components implement the design principles behind Web Components. They also make it possible to build components that can run in today's browsers.</p>
<div class="title-page-name">
<div class="packt_infobox">
<p class="calibre20">At the time of writing, Angular supports evergreen browsers, such as Chrome, Firefox, Safari, and Edge, as well as IE 9 and above. <span class="calibre22">It also has support for Android and IOS. For a list of browsers supported by Angular, visit </span><span class="calibre22"><a href="https://angular.io/guide/browser-support" target="_blank" class="calibre21">https://angular.io/guide/browser-support.</a></span></p>
</div>
</div>
<p class="calibre3">Therefore, throughout the rest of this book, we will focus on building Angular components and not Web Components. Despite this distinction, Angular components align closely with Web Components and can even inter-operate with them. As browsers begin to support Web Components more fully, the differences between Angular components and Web Components will begin to disappear. So, if you want to begin adopting the Web Component standards of the future, Angular provides you with the opportunity to do so today.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Language support in Angular</h1>
                
            
            <article>
                
<p class="calibre3">You can develop components with ES5 (the version of JavaScript supported in all current browsers), but Angular enhances the ability to develop components by adding support for key features that are found in the latest languages, such as ES2015 and TypeScript.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">ES2015</h1>
                
            
            <article>
                
<p class="calibre3">ES2015 is the new version of JavaScript; it was approved in June 2015. It adds many improvements to the language, which we will see throughout this book, but the two that interest us the most at this point are the following:</p>
<ul class="calibre11">
<li class="calibre12">Classes</li>
<li class="calibre12">Module loading</li>
</ul>
<p class="calibre3"><strong class="calibre5">Classes</strong> did not previously exist in JavaScript. The key advantage of using them, now that they do exist, is that they offer a simple, clear syntax that we can use to create convenient containers for the code in our components. As you will find when you begin working on the applications in this book. Classes also provide a convenient shorthand designation for our components that makes it easier to stitch them together with each other through things such as dependency injection.</p>
<div class="title-page-name">
<div class="packt_infobox">
<p class="calibre20"><span class="calibre22">To be clear, JavaScript classes do not introduce something that is completely new. The <strong class="calibre23">Mozilla Developer Network</strong> (<strong class="calibre23">MDN</strong>) describes them</span> as primarily syntactical sugar over JavaScript's existing prototype-based inheritance.  For mo<span class="calibre22">re information visit <span class="calibre22"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" class="calibre21">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes</a>.</span></span></p>
</div>
</div>
<p class="calibre3">We'll explore classes throughout the examples in this book. If you have not worked with object-oriented languages, you may not be familiar with classes, so we will cover them as we work through the examples in this chapter.</p>
<p class="calibre3">ES2015 also introduces a new approach to <strong class="calibre5">module loading</strong>. A module provides a way for JavaScript files to be encapsulated. When they are encapsulated, they do not pollute the global namespace and can interact with other modules in a controlled manner. </p>
<p class="calibre3">Once we have our modules defined, we need a way to load them into our application for execution. Module loading allows us to select just what we need for our application from the modules that make up Angular and other components that we create or use.</p>
<p class="calibre3">Currently, a range of approaches and libraries exists to support module loading in JavaScript. ES2015 adds a new, consistent syntax for loading modules as part of the language. The syntax is straightforward and involves prefixing modules with the <kbd class="calibre13">export</kbd> keyword (or using the default export) and then using <kbd class="calibre13">import</kbd> to consume them elsewhere in our application.</p>
<p class="calibre3">ES 2015 module loading enables us to combine components into useful bundles or features that can be imported or exported within our applications. In fact, modules are at the core of Angular itself. We will see that modules are used extensively both in Angular itself and in the applications that we are building throughout this book.</p>
<div class="title-page-name">
<div class="packt_infobox">
<p class="calibre20"><span class="calibre22">It is important to understand that, while Angular uses syntax that has similarities to ES2015 module-loading syntax, Angular modules (which we will discuss a little later in this chapter) are not the same as JavaScript modules. For further details on these differences, see the Angular documentation at <span class="calibre22"><a href="https://angular.io/guide/architecture#ngmodules-vs-javascript-modules" target="_blank" class="calibre21">https://angular.io/guide/architecture#ngmodules-vs-javascript-modules</a></span>. </span></p>
</div>
</div>
<p class="calibre3">Because ES2015 is not fully supported by today's browsers, we will need to convert ES2015 into ES5 in order to use features such as classes and module loading in our applications. We do this through a process called <strong class="calibre5">transpilation</strong>.</p>
<p class="calibre3">Transpilation is like compilation, except that instead of converting our code into a machine language as compilation does, transpilation converts one type of source code to another type of source code. In this case, it converts ES2015 to ES5. There are several tools called <strong class="calibre5">transpilers</strong> that enable us to do that. Common transpilers include Traceur and Babel. TypeScript (which we will discuss next) is also a transpiler, and it is the one that we will use for the examples in this book.</p>
<p class="calibre3">Once ES2015 is transpiled to ES5, we can then use a module loader such as <strong class="calibre5">SystemJS</strong> to load our modules. <strong class="calibre5">SystemJS</strong> follows the ES2015 syntax for module loading and gives us the ability to do module loading in today's browsers. Alternatively, we can  use a module bundler such as <strong class="calibre5">webpack</strong> to load and combine our modules. For the projects in this book we will be using <strong class="calibre5">webpack</strong> to load, bundle, and deploy the modules in our applications.</p>
<div class="title-page-name">
<div class="packt_infobox">
<p class="calibre20">Since the release of ES2015, the schedule for releases of new versions of ECMAScript (the official name for JavaScript) is on an annual basis—so we now have ES2016 and ES2017 and will soon have ES2018.  Since the features that we are highlighting throughout this book were first introduced in ES2015, we will be referring to ES2015 instead of any of the newer versions. The newer versions, however, are fully compatible with the language features that we are highlighting here and elsewhere in the book.</p>
</div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">TypeScript</h1>
                
            
            <article>
                
<p class="calibre3">TypeScript was created by Microsoft as a superset of JavaScript, which means that it contains the features of ES2015 (such as classes and module loading) and adds the following:</p>
<ul class="calibre11">
<li class="calibre12">Types</li>
<li class="calibre12">Decorators</li>
</ul>
<p class="calibre3"><strong class="calibre5">Types</strong> allow us to mark variables, properties, and parameters in our classes to indicate that they are numbers, strings, Booleans, or various structures such as arrays and objects. This enables us to perform type checking at design time to make sure that the proper types are being used in our application.</p>
<p class="calibre3"><strong class="calibre5">Decorators</strong> are simple annotations that we can add to our classes using the <kbd class="calibre13">@</kbd> symbol along with a function. They provide instructions (called metadata) for the use of our classes. In the case of Angular, decorators allow us to identify our classes as Angular components. Decorators also enable us to specify a custom element to which to bind our component and to identify a template that adds an HTML view to our component. We will cover much more about the use of decorators as we go through this book.</p>
<p class="calibre3">Decorators  are not part of ES2015, but are part of a proposal to include them in the JavaScript language in the future. They were added to TypeScript as part of a collaboration between Microsoft and Google. As mentioned earlier, TypeScript compiles into ES5, so we are able to use both types and decorators in browsers that do not fully support ES2015 or the proposed standard for decorators.</p>
<div class="title-page-name">
<div class="packt_infobox">
<p class="calibre20"><span class="calibre22">As mentioned previously, it is not necessary to use either ES2015 or TypeScript with Angular. However, we think that you will see the advantages of using them as we work through the examples in this book.</span></p>
</div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Putting it all together</h1>
                
            
            <article>
                
<p class="calibre3">By following the Web Component standards and adding support for ES2015 and TypeScript, Angular gives us the ability to create web applications that implement the component design pattern. These components help realize the vision behind the standards of building large-scale applications through collections of self-describing and self-contained building blocks.</p>
<p class="calibre3">We hope that you will see in the examples in this book that Angular enables components to be constructed in a straightforward and declarative way that makes it easier for developers to implement them. As we proceed through the examples in this book, we will highlight where each of these technologies is being used.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Angular modules</h1>
                
            
            <article>
                
<p class="calibre3">Components are the basic building block of an Angular application. But how do we then organize these building blocks into complete applications? Angular modules provide the answer to this question. They enable us to combine our components into reusable groups of functionality that can be exported and imported throughout our application. For example, in a more sophisticated application we would want to have modules for things such as authentication, common utilities, and external service calls. At the same time, modules enable us to group features within an application in a way that allows us to load them on demand. This is called lazy loading, a topic that we will cover in <span class="calibre6"><a href="" class="calibre10">Chapter 4</a></span>, <em class="calibre17">Building Personal Trainer</em>.</p>
<p class="calibre3">Each Angular application will have one or more modules that contain its components. Angular has introduced <kbd class="calibre13">NgModule</kbd> as a way to conveniently specify the components that make up a module. Every Angular application must have at least one of these modules—the root module.</p>
<div class="title-page-name">
<div class="packt_infobox">
<p class="calibre20"><span class="calibre22">Angular itself is built as modules that we import into our application. So you will see the use of modules all over as you build Angular apps.</span></p>
</div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The basic steps to building Angular applications</h1>
                
            
            <article>
                
<p class="calibre3">To sum up: at a basic level, you will see that to develop applications in Angular, you will do the following:</p>
<ol class="calibre14">
<li value="1" class="calibre12">Create components</li>
<li value="2" class="calibre12">Bundle them into modules</li>
<li value="3" class="calibre12">Bootstrap your application</li>
</ol>
<p class="calibre3">The best way to understand Angular and the component design pattern is by seeing it in action. Hence, we are going to build our first Hello World app in Angular. This app will help you become familiar with the Angular framework and see the component design pattern in action.</p>
<p class="calibre3">Let's get started doing that.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The customary Hello Angular app – Guess the Number!</h1>
                
            
            <article>
                
<p class="calibre3">As our first exercise, we want to keep things simple, but still showcase the framework's capabilities. Therefore, we are going to build a very simple game called <em class="calibre17">Guess the Number!</em>. The objective of the game is to guess a random computer-generated number in as few tries as possible.</p>
<p class="calibre3">This is how the game looks:</p>
<div class="packt_figure"><img class="image-border" src="../images/00005.jpeg"/></div>
<div class="title-page-name">
<p class="calibre3">Let's now build <em class="calibre17">Guess the Number!</em>.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Building Guess the Number!</h1>
                
            
            <article>
                
<p class="calibre3">The standard practice while building user interfaces is to build them top-down. Start by designing the UI and then plug in the data and behavior according to your needs. With such an approach, the UI, data, and behavioral aspects of the app are all tightly coupled, which is a less than ideal situation!</p>
<p class="calibre3">With component-based design, we work differently. We start by looking at the UI and expected behavior, and then we encapsulate all of this into a building block that we call a <strong class="calibre5">component</strong>. This component is then hosted on our page. Within the component, we separate the UI into a view and the behavior into a class, with the appropriate properties and methods needed to support the behavior. If you are not familiar with classes, don't worry. We'll be discussing what they are in detail as we move through the example.</p>
<p class="calibre3">Okay, so let's identify the UI and behavior that we will need for our application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Designing our first component</h1>
                
            
            <article>
                
<p class="calibre3">To determine what needs to go into our component, we will start by detailing the features that we want the app to support:</p>
<ul class="calibre11">
<li class="calibre12">Generating random numbers (<kbd class="calibre13">original</kbd>)</li>
<li class="calibre12">Providing input for a user to guess the value (<kbd class="calibre13">guess</kbd>)</li>
<li class="calibre12">Tracking the number of guesses already made (<kbd class="calibre13">noOfTries</kbd>)</li>
<li class="calibre12">Giving the user hints to improve their guess based on their input (<kbd class="calibre13">deviation</kbd>)</li>
<li class="calibre12">Giving a success message if the user guesses the number correctly (<kbd class="calibre13">deviation</kbd>)</li>
</ul>
<p class="calibre3">Now that we have our features, we can determine what we need to display to the user and what data we need to track. For the preceding feature set, the elements in parentheses denote the properties that will support those features and will need to be included in our component.</p>
<div class="packt_infobox">
<p class="calibre20">Designing the component is a very crucial process. If it is done right, we can logically organize our application in a way that makes it understandable and easy to maintain.</p>
<p class="calibre20">While building any app, we urge you to first think about the functionality you want to offer, and then the data and behavior that can support the functionality. Lastly, think about how to build a user interface for it. This is a good practice irrespective of the library or framework that you use to build your app.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Developing our first component</h1>
                
            
            <article>
                
<p class="calibre3">Now that we have a design for our first component, we’ll start developing it using the <span class="calibre6"><strong class="calibre5">Angular Command Line Interface</strong> (</span><strong class="calibre5">Angular CLI</strong><span class="calibre6">). </span>The Angular CLI enables us to start building Angular applications and deploying them through a series of console commands. We’ll be covering the <strong class="calibre5">Angular CLI</strong> in greater detail in future chapters. For now, we will install it and use it to generate a basic application as the beginning point for our first component.</p>
<p class="calibre3">To use the <strong class="calibre5">Angular CLI</strong> you must first install <strong class="calibre5">Node.js</strong> and <strong class="calibre5">npm</strong> (<strong class="calibre5">Node</strong>'s package manager). <strong class="calibre5">Node</strong> is available cross-platform and you can download it from <a href="http://nodejs.org" target="_blank" class="calibre10">http://nodejs.org</a>. Installing <strong class="calibre5">Node </strong>also installs<span class="calibre6"> <strong class="calibre5">npm</strong>.</span> <span class="calibre6">For this book, we are using <strong class="calibre5">Node.js</strong> version 8.9.4 and <strong class="calibre5">npm</strong> version 5.6.0. You can find more information about installing <strong class="calibre5">Node</strong> and updating <strong class="calibre5">npm</strong> to the latest version at <a href="https://docs.npmjs.com/getting-started/installing-node" target="_blank" class="calibre10">https://docs.npmjs.com/getting-started/installing-node</a>. </span><span class="calibre6"> </span></p>
<p class="calibre3">Once <strong class="calibre5">Node</strong> and <strong class="calibre5">npm </strong>are installed, open a Command Prompt and type the following:</p>
<pre class="calibre19"><strong class="calibre1">npm install -g @angular/cli</strong></pre>
<p class="calibre3"><span class="calibre6">This installs the <strong class="calibre5">Angular CLI</strong> that we will use to start building our application. </span><span class="calibre6">Now from a directory on your local machine, enter the following commands:</span></p>
<pre class="calibre19"><strong class="calibre1">ng new guessthenumber --inlineTemplate<br class="title-page-name"/>cd guessthenumber<br class="title-page-name"/>ng serve</strong></pre>
<p class="calibre3">With the first command the <strong class="calibre5">Angular CLI</strong> will create a new Angular project on your local machine (<span class="calibre6">the </span><span class="calibre6"><kbd class="calibre13">--inlineTemplate</kbd> </span><span class="calibre6">flag creates a template within our component</span><span class="calibre6">, which is perfect for what we want to show in this chapter</span>). With the second command, you are navigating to the directory that the <strong class="calibre5">Angular CLI</strong> has created for your new project. The third command launches the application, which you can view at <kbd class="calibre13">http://localhost:4200/</kbd>. If you do that you should see a standard default Angular page in the browser.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Installing Bootstrap</h1>
                
            
            <article>
                
<p class="calibre3">There is one more step before we build out the specifics of our application. Let’s add the Bootstrap library to enhance the look and feel of our application. First, stop the application by typing <em class="calibre17">Ctrl</em> + <em class="calibre17">C</em> in the Terminal from which it was launched and enter <em class="calibre17">Y</em> when asked if you want to terminate the batch job. Next from the <kbd class="calibre13">guessthenumber</kbd> directory, enter the following command:</p>
<pre class="calibre19"><strong class="calibre1">npm install bootstrap --save</strong></pre>
<p class="calibre3">This will install the latest release of Bootstrap (which at the time of writing was version 4.0.0). You may see a few warning messages about unmet dependencies. You can ignore them.</p>
<p class="calibre3">Next configure your new project to include the Bootstrap<strong class="calibre5"> </strong>style sheet:</p>
<ol class="calibre14">
<li value="1" class="calibre12">In the <kbd class="calibre13">guessthenumber</kbd> directory find and open the file <kbd class="calibre13">angular.json</kbd></li>
<li value="2" class="calibre12">In that file find the <kbd class="calibre13">projects</kbd> property, which contains the settings in our new project</li>
<li value="3" class="calibre12">Then find the <kbd class="calibre13">styles</kbd> property within <kbd class="calibre13">architect.build.options</kbd> and you will see that it contains an array that holds <kbd class="calibre13">styles.css</kbd>, the default style sheet for our new project</li>
<li value="4" class="calibre12">Add to that array the location of the <kbd class="calibre13">bootstrap.min.css</kbd> style sheet like so:</li>
</ol>
<pre class="calibre18">"styles": [<br class="title-page-name"/>   "node_modules/bootstrap/dist/css/bootstrap.min.css",<br class="title-page-name"/>   "src/styles.css"<br class="title-page-name"/>],</pre>
<div class="title-page-name">
<div class="packt_infobox">
<p class="calibre20">These instructions for including Bootstrap using the <strong class="calibre23">Angular CLI</strong> can be found at <a href="https://github.com/angular/angular-cli/wiki/stories-include-bootstrap" target="_blank" class="calibre21">https://github.com/angular/angular-cli/wiki/stories-include-bootstrap</a>.</p>
</div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What do we have so far?</h1>
                
            
            <article>
                
<p class="calibre3">If you take a look in the <kbd class="calibre13">guessthenumber</kbd> directory that the <strong class="calibre5">Angular CLI </strong>has been created, you will see a large number of files. This may look overwhelming at first, but the important thing <span class="calibre6">to understand is that the <strong class="calibre5">Angular CLI</strong> has generated all these files for us with</span> <span class="calibre6">just a few command line statements. In that way it </span><span class="calibre6">makes getting started with an Angular application much smoother and easier. It takes the grunt work out of the process and enables us able to build and serve our application with minimal effort. In this chapter, we will be focusing on just a few files that we will need to touch in order to create our application.</span></p>
<div class="title-page-name">
<div class="packt_infobox">
<p class="calibre20">If you are running the application in Internet Explorer, there is one file that you will need to look at—<kbd class="calibre24">polyfill.ts</kbd>. This adds various other files that are needed to run the application in Internet Explorer. You will need to uncomment several sections in that file to add these necessary files. Instructions for doing this are contained in the file itself.</p>
</div>
</div>
<p class="calibre3"><span class="calibre6">Before turning to building out the specifics of our application, let's take a look at one of the key files that will be used to get our application up and running.</span></p>
<div class="packt_tip">
<p class="calibre20"><span class="calibre22">Downloading the example code</span></p>
<p class="calibre20">The code in this book is available on GitHub at<span class="calibre22"> </span><span class="calibre22"><a href="https://github.com/chandermani/angular6byexample" target="_blank" class="calibre21">https://github.com/chandermani/angular6byexample</a></span>. It is organized in checkpoints that allow you to follow along step by step as we build our sample projects in this book. The branch to download for this chapter is GitHub's<span class="calibre22"> </span>Branch: checkpoint1.1. Look in the<span class="calibre22"> </span><kbd class="calibre24">guessthenumber</kbd><span class="calibre22"> </span>folder for the code we are covering here. <span class="calibre22">If you are not using</span><span class="calibre22"> </span><span class="calibre22">Git</span><span class="calibre22">, download the snapshot of</span><span class="calibre22"> </span><span class="calibre22">C</span><span class="calibre22">heckpoint 1.1 (a</span><span class="calibre22"> </span><span class="calibre22">ZIP</span><span class="calibre22"> file) from the following GitHub location:</span><span class="calibre22"> </span><a href="https://github.com/chandermani/angular6byexample/tree/checkpoint1.1" target="_blank" class="calibre21">https://github.com/chandermani/angular6byexample/tree/checkpoint1.1</a><span class="calibre22">. Refer to the</span><span class="calibre22"> </span><kbd class="calibre24">readme.md</kbd><span class="calibre22"> </span><span class="calibre22">file in the</span><span class="calibre22"> </span><kbd class="calibre24">guessthenumber</kbd><span class="calibre22"> </span><span class="calibre22">folder when setting up the snapshot for the first time.</span></p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The host file - index.html</h1>
                
            
            <article>
                
<p class="calibre3">Navigate to the <kbd class="calibre13">src</kbd> folder in the <kbd class="calibre13">guessthenumber</kbd> directory and open <kbd class="calibre13">index.html</kbd>. You will see the following: </p>
<pre class="calibre19">&lt;!doctype html&gt;<br class="title-page-name"/>&lt;html lang="en"&gt;<br class="title-page-name"/>&lt;head&gt;<br class="title-page-name"/>  &lt;meta charset="utf-8"&gt;<br class="title-page-name"/>  &lt;title&gt;Guessthenumber&lt;/title&gt;<br class="title-page-name"/>  &lt;base href="/"&gt;<br class="title-page-name"/><br class="title-page-name"/>  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;<br class="title-page-name"/>  &lt;link rel="icon" type="image/x-icon" href="favicon.ico"&gt;<br class="title-page-name"/>&lt;/head&gt;<br class="title-page-name"/>&lt;body&gt;<br class="title-page-name"/>  &lt;app-root&gt;&lt;/app-root&gt;<br class="title-page-name"/>&lt;/body&gt;<br class="title-page-name"/>&lt;/html&gt;</pre>
<p class="calibre3"><kbd class="calibre13">index.html</kbd> is the host file for our application. It will be launched by the browser when the application is first run and will host the components in our application. <span class="calibre6">If you have any exposure to web development, </span>most of the HTML code in this file should look familiar . It has standard <kbd class="calibre13">html</kbd>, <kbd class="calibre13">head</kbd>, and <kbd class="calibre13">body</kbd> tags along with a couple of optional tags, one a meta tag for the viewport, which configures how the app will display in a mobile device, and the other a link to an Angular favicon image that will display on the tab in the browser in which the application is loaded.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Custom element</h1>
                
            
            <article>
                
<p class="calibre3">However, there is one more important tag on the page that may not look as familiar to you:</p>
<pre class="calibre19">&lt;app-root&gt;&lt;/app-root&gt; </pre>
<p class="calibre3">This tag is a <strong class="calibre5">custom element</strong>. It instructs Angular where to inject the component that we will be building.</p>
<div class="title-page-name">
<div class="packt_infobox">
<p class="calibre20"><em class="calibre25">Guess the Number!</em><span class="calibre22"> and all the other apps that are part of this book have been tested against the Angular 6 final release.</span></p>
</div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The component file</h1>
                
            
            <article>
                
<p class="calibre3">Now let's turn to building out the specifics of our application. Given the previous discussion of the component pattern, you will not be surprised that to do this we will be constructing a component.  In this case our application will be simple enough that we will need only one component (later in this book you will see the use of multiple components as we build more complex applications). The Angular CLI has already given us a start by generating a component file for us. Of course, that file does not contain any of the particulars of our application, so we will have to modify it. To do that navigate to the <kbd class="calibre13">src</kbd> folder in the <kbd class="calibre13">app</kbd> directory and open <kbd class="calibre13">app.component.ts</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The import statement</h1>
                
            
            <article>
                
<p class="calibre3">At the top of the page, you will find the following line:</p>
<pre class="calibre19">import { Component } from '@angular/core';</pre>
<p class="calibre3">This is an import statement. It tells us what modules we will be loading and using in our component. In this case, we are selecting one module that we need to load from Angular: <kbd class="calibre13">Component</kbd>. Angular has many other modules, but we load only what we need.</p>
<p class="calibre3">You'll notice that the location from which we are importing is not identified as a path or directory within our application. Instead, it is identified as <kbd class="calibre13">@angular/core</kbd>. Angular has been divided into barrel modules that are prefixed with <kbd class="calibre13">@angular</kbd>.</p>
<p class="calibre3">These barrels combine several modules that are logically related. In this case, we are indicating that we want to import the <kbd class="calibre13">core</kbd> barrel module, which in turn brings in the <kbd class="calibre13">Component</kbd> module. </p>
<div class="packt_infobox"><span class="packt_screen">The Angular documentation describes a barrel as<strong class="calibre26">:</strong></span><strong class="calibre26"><br class="calibre27"/>
<br class="calibre27"/></strong> <span class="packt_screen">A way to </span>roll up exports<span class="packt_screen"> from several ES2015 modules into a single convenient ES2015 module. The barrel itself is an ES2015 module file that re-exports </span>selected<span class="packt_screen"> exports of other ES2015 modules.<br class="calibre27"/>
<br class="calibre27"/></span> For more information about barrels, see <a href="https://angular.io/guide/glossary#barrel" target="_blank" class="calibre21">https://angular.io/guide/glossary#barrel</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Decorator</h1>
                
            
            <article>
                
<p class="calibre3">Next, replace the code block that starts with <kbd class="calibre13">@Component</kbd> with the following:</p>
<pre class="calibre19">@Component({<br class="title-page-name"/> selector: 'app-root',<br class="title-page-name"/> template: `<br class="title-page-name"/>  &lt;div class="container"&gt;<br class="title-page-name"/>      &lt;h2&gt;Guess the Number !&lt;/h2&gt;<br class="title-page-name"/>        &lt;div class="card bg-light mb-3"&gt;<br class="title-page-name"/>           &lt;div class="card-body"&gt;<br class="title-page-name"/>              &lt;p class="card-text"&gt;Guess the computer generated random number between 1 <br class="title-page-name"/>                                                                          and 1000.&lt;/p&gt;<br class="title-page-name"/>           &lt;/div&gt;<br class="title-page-name"/>        &lt;/div&gt;<br class="title-page-name"/>       &lt;div&gt;<br class="title-page-name"/>         &lt;label&gt;Your Guess: &lt;/label&gt;<br class="title-page-name"/>         &lt;input type="number" [value]="guess" (input)="guess = $event.target.value" /&gt;<br class="title-page-name"/>         &lt;button (click)="verifyGuess()" class="btn btn-primary btn-sm"&gt;Verify&lt;/button&gt;<br class="title-page-name"/>         &lt;button (click)="initializeGame()" class="btn btn-warning btn-<br class="title-page-name"/>                                                               sm"&gt;Restart&lt;/button&gt;<br class="title-page-name"/>       &lt;/div&gt;<br class="title-page-name"/>      &lt;div&gt;<br class="title-page-name"/>         &lt;p *ngIf="deviation&lt;0" class="alert alert-warning"&gt;Your guess is higher.&lt;/p&gt;<br class="title-page-name"/>         &lt;p *ngIf="deviation&gt;0" class="alert alert-warning"&gt;Your guess is lower.&lt;/p&gt;<br class="title-page-name"/>         &lt;p *ngIf="deviation===0" class="alert alert-success"&gt;Yes! That's it.&lt;/p&gt;<br class="title-page-name"/>      &lt;/div&gt;<br class="title-page-name"/>      &lt;p class="text-info"&gt;No of guesses :<br class="title-page-name"/>        &lt;span class="badge"&gt;{{noOfTries}}&lt;/span&gt;<br class="title-page-name"/>      &lt;/p&gt;<br class="title-page-name"/>  &lt;/div&gt; <br class="title-page-name"/>  `<br class="title-page-name"/>})</pre>
<p class="calibre3">This is the decorator for our component and it is placed directly above the class definition, which we will discuss soon. The <kbd class="calibre13">@</kbd> symbol is used to identify a decorator. The <kbd class="calibre13">@Component</kbd> decorator has a property called selector, and you may not be surprised to see that it is set to the <kbd class="calibre13">&lt;app-root&gt;</kbd> tag in our HTML page. This setting tells Angular to inject this component into that tag on the HTML page.</p>
<p class="calibre3">The decorator also has a property called <kbd class="calibre13">template</kbd>, and this property identifies the HTML markup for our component. Notice the use of back ticks (introduced by ES2015) for rendering the template string over multiple lines. Alternatively, we can set a <kbd class="calibre13">templateUrl</kbd> property that would point to a separate file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Defining the class</h1>
                
            
            <article>
                
<p class="calibre3">Now replace the code block that begins with  <kbd class="calibre13"><span>export class App</span>Component</kbd><span class="calibre6"> wi</span>th the following:</p>
<pre class="calibre19">export class AppComponent {<br class="title-page-name"/>  deviation: number;<br class="title-page-name"/>  noOfTries: number;<br class="title-page-name"/>  original: number;<br class="title-page-name"/>  guess: number;<br class="title-page-name"/><br class="title-page-name"/>  constructor() {<br class="title-page-name"/>      this.initializeGame();<br class="title-page-name"/>  }<br class="title-page-name"/>  initializeGame() {<br class="title-page-name"/>      this.noOfTries = 0;<br class="title-page-name"/>      this.original = Math.floor((Math.random() * 1000) + 1);<br class="title-page-name"/>      this.guess = null;<br class="title-page-name"/>      this.deviation = null;<br class="title-page-name"/>  }<br class="title-page-name"/>  verifyGuess() {<br class="title-page-name"/>      this.deviation = this.original - this.guess;<br class="title-page-name"/>      this.noOfTries = this.noOfTries + 1;<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre3">If you have been developing in ES5, the version of JavaScript that is supported in all current browsers, you may not be familiar with the use of classes here. So, we will take a few moments to walk through what makes up a class (for those of you who have developed using an object-oriented programming language, such as C# or Java, this should be familiar territory).</p>
<p class="calibre3">The class file holds the code that we will use to run our component. At the top, we give the class a name, which is <kbd class="calibre13">AppComponent</kbd>. Then, inside the curly braces, we have four lines that declare the properties for our class. These are similar to ES5 variables, and we will use them to hold the values that we will need to run the application (you'll notice that these are the four values that we identified when we designed our component).</p>
<p class="calibre3">What makes these properties different from standard JavaScript variables is that each property name is followed by <kbd class="calibre13">:</kbd> and a number. These set the type of the property. In this case, we are indicating that each of these four properties will be set to the number type, which means we are expecting the values of all of these properties to be numbers. The ability to specify types for our properties is provided by TypeScript and it is not available in standard JavaScript.</p>
<p class="calibre3">As we move down, we will see three blocks of script that have names, followed by parentheses, and then curly braces with several lines of script inside them. These are the methods for our class, and they contain the operations that our component will support. They are a lot like standard JavaScript functions.</p>
<p class="calibre3">The first of these methods is <kbd class="calibre13">constructor()</kbd>, which is a special method that will run when an instance of our component is first created. In our example, the constructor does only one thing when the class is created; it calls another method in our class, called <kbd class="calibre13">initializeGame()</kbd>.</p>
<p class="calibre3">The <kbd class="calibre13">initializeGame()</kbd> method sets the starting values of the four properties in the class using the assignment operator <kbd class="calibre13">=</kbd>. We set these values to <kbd class="calibre13">null</kbd> or <kbd class="calibre13">zero</kbd>, except for <kbd class="calibre13">original</kbd>, in which we use a random number generator to create the number to be guessed.</p>
<p class="calibre3">The class holds one more method called <kbd class="calibre13">verifyGuess()</kbd>, which updates the <kbd class="calibre13">deviation</kbd> and <kbd class="calibre13">noOfTries</kbd> properties. This method is not being called from within the component class; instead, it will be called from the view, as we will see when we examine the view more closely later. You'll also notice that our methods refer to properties in the same class by prepending <kbd class="calibre13">this</kbd> to them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The module file</h1>
                
            
            <article>
                
<p class="calibre3">As we<span class="calibre6"> </span>mentioned<span class="calibre6"> </span>earlier, every<span class="calibre6"> </span>Angular<span class="calibre6"> </span>component must be contained within an Angular module. This means that at a minimum we must add at least one Angular module file to the<span class="calibre6"> </span>root<span class="calibre6"> </span>of our application. We call this the<span class="calibre6"> </span><strong class="calibre5">root module</strong>. For a simple application like <em class="calibre17">Guess the Number!</em>, the root module may be the only module we will need. However, as an Angular application increases in size, it will often make sense to have multiple Angular module files broken down by features. We will cover that situation as we move into building more complex applications in later chapters in this book.</p>
<p class="calibre3">Let's go ahead and take a look at our Angular module file. Again the Angular CLI has created this file for us. Open <kbd class="calibre13">app.module.ts</kbd><span class="calibre6"> </span>in the<span class="calibre6"> </span><kbd class="calibre13">app</kbd><span class="calibre6"> </span>directory within the<span class="calibre6"> </span><kbd class="calibre13">src</kbd><span class="calibre6"> </span>folder and you will see the following:</p>
<pre class="calibre19">import { BrowserModule } from '@angular/platform-browser';<br class="title-page-name"/>import { NgModule } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>import { AppComponent } from './app.component';<br class="title-page-name"/><br class="title-page-name"/>@NgModule({<br class="title-page-name"/>  declarations: [<br class="title-page-name"/>    AppComponent<br class="title-page-name"/>  ],<br class="title-page-name"/>  imports: [<br class="title-page-name"/>    BrowserModule<br class="title-page-name"/>  ],<br class="title-page-name"/>  providers: [],<br class="title-page-name"/>  bootstrap: [AppComponent]<br class="title-page-name"/>})<br class="title-page-name"/>export class AppModule { }</pre>
<p class="calibre3">The first two statements import<span class="calibre6"> </span><span class="calibre6"><kbd class="calibre13">BrowserModule</kbd> </span>and<span class="calibre6"> <kbd class="calibre13">NgModule</kbd></span>. Notice that, while<span class="calibre6"> </span><kbd class="calibre13">NgModule</kbd><span class="calibre6"> </span>is being imported from<span class="calibre6"> </span><kbd class="calibre13">@angular/core</kbd>,<span class="calibre6"> </span><kbd class="calibre13">BrowserModule</kbd><span class="calibre6"> </span>is being imported from a different module:<span class="calibre6"> </span><kbd class="calibre13">@angular/platform-browser</kbd>. What's significant here is that the import is not coming from<span class="calibre6"> </span><kbd class="calibre13">@angular/core</kbd><span class="calibre6">, </span>but from a separate module that is specific to browser-based applications. This is a reminder that Angular can support devices other than browsers, such as mobile devices, hence the need to place<span class="calibre6"> </span><kbd class="calibre13">BrowserModule</kbd><span class="calibre6"> </span>into a separate module.</p>
<p class="calibre3">The other import in this file is our component<span class="calibre6"> </span><kbd class="calibre13">AppComponent</kbd>. If you go back to that component you will notice that <kbd class="calibre13">export</kbd><span class="calibre6"> is </span><span class="calibre6">added </span><span class="calibre6">in front of the class definition, which means we are using module loading within our own application.</span></p>
<p class="calibre3">We next define a new component<span class="calibre6"> </span><kbd class="calibre13">AppModule</kbd>.  There is nothing in the class itself other than a few imports and a decorator:<span class="calibre6"> </span><kbd class="calibre13">@ngModule</kbd>. We can use this decorator to configure the module in our application.<span class="calibre6"> </span><span class="calibre6">The first property is declarations and with that property we provide an array of the components that will be used in our application. In this case, we have just one component:</span><span class="calibre6"> </span><kbd class="calibre13">AppComponent</kbd><span class="calibre6">. </span></p>
<p class="calibre3">We next add imports, which in this case include the<span class="calibre6"> </span><kbd class="calibre13">BrowserModule</kbd>. As the name suggests, this module will provide the functionality needed to run our application in a browser. The next property is<span class="calibre6"> </span><kbd class="calibre13">providers</kbd><span class="calibre6">. This property is used to register providers (such as services and other objects) that will be available to be used throughout our application through dependency injection. We have no need for providers in the simple application we are building here, so this property is empty. We will be discussing providers and dependency injection in detail in <a href="part0117.html#3FIHQ0-7edc9b1e1ea341adae33006323903887" class="calibre10">Chapter 3</a>, <em class="calibre17">More Angular – SPA, Routing</em>.</span></p>
<p class="calibre3">Finally, we set the<span class="calibre6"> </span><kbd class="calibre13">bootstrap</kbd><span class="calibre6"> </span>property. This indicates the first component that will be loaded when our application starts up. Again this is the<span class="calibre6"> </span><kbd class="calibre13">AppComponent</kbd>.</p>
<p class="calibre3">With this configuration in place, we are now ready to bootstrap our component.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Bootstrapping</h1>
                
            
            <article>
                
<p class="calibre3">The class<span class="calibre6"> </span>definition<span class="calibre6"> </span>for<span class="calibre6"> </span><kbd class="calibre13">AppComponent</kbd><span class="calibre6"> </span>operates as a blueprint for the component, but the script inside it does not run until we have created an instance of the component. In order to run our application then, we need something in our<span class="calibre6"> </span>application<span class="calibre6"> </span>that creates this instance. The process of doing that requires us to add code that bootstraps our component.</p>
<p class="calibre3">In the <kbd class="calibre13">src</kbd> folder, look for a file named<span class="calibre6"> </span><kbd class="calibre13">main.ts</kbd><span class="calibre6">. </span>Open it and you will see the following code:</p>
<pre class="calibre19">import { enableProdMode } from '@angular/core';<br class="title-page-name"/>import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';<br class="title-page-name"/><br class="title-page-name"/>import { AppModule } from './app/app.module';<br class="title-page-name"/>import { environment } from './environments/environment';<br class="title-page-name"/><br class="title-page-name"/>if (environment.production) {<br class="title-page-name"/>  enableProdMode();<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>platformBrowserDynamic().bootstrapModule(AppModule)<br class="title-page-name"/>  .catch(err =&gt; console.log(err));</pre>
<p class="calibre3">As you can see, we are importing<span class="calibre6"> </span><kbd class="calibre13">enableProdMode</kbd><span class="calibre6"> </span>from<span class="calibre6"> </span><kbd class="calibre13">@angular/core</kbd><span class="calibre6"> </span>and the<span class="calibre6"> </span> <kbd class="calibre13">platformBrowserDynamic</kbd><span class="calibre6"> </span>module from<span class="calibre6"> </span><kbd class="calibre13">@angular/platform-browser-dynamic</kbd>. Like the import of<span class="calibre6"> </span><kbd class="calibre13">BrowseModule</kbd><span class="calibre6"> </span>in the<span class="calibre6"> </span><kbd class="calibre13">appModule</kbd><span class="calibre6"> </span>file, this latter import is specifically for browser-based applications. Next we add an import of our<span class="calibre6"> </span><kbd class="calibre13">AppModule</kbd> and a file called<span class="calibre6"> </span><kbd class="calibre13">environment</kbd><span class="calibre6"> </span>that is located in the<span class="calibre6"> </span><kbd class="calibre13">environments</kbd><span class="calibre6"> </span>directory of our application.</p>
<p class="calibre3">In the next lines of code we check to see if the constant <span class="calibre6"><kbd class="calibre13">environment</kbd> in the <kbd class="calibre13">environment</kbd> file</span><span class="calibre6"> </span><span class="calibre6">has its <kbd class="calibre13">production</kbd> property set to <kbd class="calibre13">true</kbd>, and if so, call <kbd class="calibre13">enableProdMode()</kbd>, which as the name suggests enables production mode. The default setting for <kbd class="calibre13">environment.production</kbd> is <kbd class="calibre13">false</kbd>, which is fine for our purposes here since we are not running the application in production mode.</span></p>
<div class="packt_infobox">
<p class="calibre20">If you open<span class="calibre22"> </span><kbd class="calibre24">environments.ts</kbd><span class="calibre22">, </span>you will see some comments that provide guidance for overwriting the settings in this file as part of the build process. We won't be covering the Angular build process until <a href="part0065.html#1TVKI0-7edc9b1e1ea341adae33006323903887" class="calibre21">Chapter 2</a>, <em class="calibre25">Building Our First App – 7 Minute Workout</em>; so we won't cover that material here.</p>
</div>
<p class="calibre3">Finally, we call the <span class="calibre6"><kbd class="calibre13">platformBrowserDynamic().boostrapModule</kbd></span> method with our<span class="calibre6"> </span><kbd class="calibre13">AppModule</kbd><span class="calibre6"> </span>as a parameter. The <kbd class="calibre13">bootstrapModule</kbd> method then creates a new instance of our<span class="calibre6"> </span><kbd class="calibre13">AppModule</kbd><span class="calibre6"> </span>component, which in turn initializes our<span class="calibre6"> </span><kbd class="calibre13">AppComponent</kbd>, which we have marked as the component to bootstrap. It does that by calling our component's constructor method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">We're up and running!</h1>
                
            
            <article>
                
<p class="calibre3">Well, the app is complete and ready to be tested! From the <kbd class="calibre13">guessthenumber</kbd> directory again type the following:</p>
<pre class="calibre19">    <strong class="calibre1">ng serve</strong></pre>
<p class="calibre3">The app should appear on your browser.</p>
<div class="title-page-name">
<div class="title-page-name">
<div class="packt_infobox">
<p class="calibre20"><span class="calibre22">If you are having trouble running the app, you can check out a working version available on GitHub at </span><span class="calibre22"><a href="https://github.com/chandermani/angular6byexample" target="_blank" class="calibre21">https://github.com/chandermani/angular6byexample</a></span><span class="calibre22">. If you are not using Git, download the snapshot of Checkpoint 1.1 (a ZIP file) from the following GitHub location: </span><a href="https://github.com/chandermani/angular6byexample/tree/checkpoint1.1" target="_blank" class="calibre21">https://github.com/chandermani/angular6byexample/tree/checkpoint1.1</a><span class="calibre22">. Refer to the </span><kbd class="calibre24">readme.md</kbd><span class="calibre22"> file in the </span><kbd class="calibre24">guessthenumber</kbd><span class="calibre22"> folder when setting up the snapshot for the first time</span></p>
</div>
</div>
</div>
<p class="calibre3">If we glance at our component file and template, we should be mightily impressed with what we have achieved. We are not writing any code to update the UI when the application is running. Still, everything works perfectly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Digging deeper</h1>
                
            
            <article>
                
<p class="calibre3">To understand how this app functions in the Angular context, we need to delve a little deeper into our component. While the class definition in the component is pretty simple and straightforward, we need to look more closely at the HTML in the template to understand how Angular is working here. It looks like standard HTML with some new symbols, such as <kbd class="calibre13">[ ]</kbd>, <kbd class="calibre13">( )</kbd>, <kbd class="calibre13">{{</kbd>, and <kbd class="calibre13">}}</kbd>.</p>
<p class="calibre3">In the Angular world, these symbols mean the following:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">{{</kbd> and <kbd class="calibre13">}}</kbd> are interpolation symbols</li>
<li class="calibre12"><kbd class="calibre13">[ ]</kbd> represents property bindings</li>
<li class="calibre12"><kbd class="calibre13">( )</kbd> represents event bindings</li>
</ul>
<p class="calibre3">Clearly, these symbols have some behavior attached to them and seem to be linking the view HTML and component code. Let's try to understand what these symbols actually do.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Interpolation</h1>
                
            
            <article>
                
<p class="calibre3">Look at this HTML fragment from the template in  <kbd class="calibre13">app.component.ts</kbd>:</p>
<pre class="calibre19">&lt;p class="text-info"&gt;No of guesses :  
  &lt;span class="badge"&gt;{{noOfTries}}&lt;/span&gt; 
&lt;/p&gt; </pre>
<p class="calibre3">The term <kbd class="calibre13">noOfTries</kbd> is sandwiched between two interpolation symbols. Interpolation works by replacing the content of the interpolation markup with the value of the expression (<kbd class="calibre13">noOfTries</kbd>) inside the interpolation symbol. In this case, <kbd class="calibre13">noOfTries</kbd> is the name of a component property. So the value of the component property will be displayed as the contents inside the interpolation tags.</p>
<p class="calibre3">Interpolations are declared using this syntax: <kbd class="calibre13">{{expression}}</kbd>. This expression looks similar to a JavaScript expression, but is always evaluated in the context of the component. Notice that we did not do anything to pass the value of the property to the view. Instead, the interpolation tags read the value of the property directly from the component without any need for additional code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Tracking changes in the number of tries</h1>
                
            
            <article>
                
<p class="calibre3">Another interesting aspect of interpolation is that changes made to component properties are automatically synchronized with the view. Run the app and make some guesses; the <kbd class="calibre13">noOfTries</kbd> value changes after every guess and so does the view content:</p>
<div class="packt_figure"><img class="image-border1" src="../images/00006.jpeg"/></div>
<p class="calibre3">Interpolation is an excellent debugging tool in scenarios where we need to see the state of the model. With interpolation, we don't have to put a breakpoint in code just to know the value of a component property. Since interpolation can take an expression, we can pass a component's method call or a property and see its value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Expressions</h1>
                
            
            <article>
                
<p class="calibre3">Before going any further, we need to spend a few moments understanding what template expressions are in Angular.</p>
<p class="calibre3">Template expressions in Angular are nothing but pieces of plain JavaScript code that are evaluated in the context of the component instance associated with the template in which they are used. But as the documentation at <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#template-expressions" target="_blank" class="calibre10"><span>https://angular.io/docs/ts/latest/guide/template-syntax.html#template-expressions</span></a> makes it clear, there are some differences:</p>
<ul class="calibre11">
<li class="calibre12">Assignment is prohibited</li>
<li class="calibre12">The <kbd class="calibre13">new</kbd> operator is prohibited</li>
<li class="calibre12">The bitwise operators <kbd class="calibre13">|</kbd> and <kbd class="calibre13">&amp;</kbd> are not supported</li>
<li class="calibre12">Increment and decrement operators, <kbd class="calibre13">++</kbd> and <kbd class="calibre13">--</kbd>, aren't supported</li>
<li class="calibre12">Template expression operators, such as <kbd class="calibre13">|</kbd> and <kbd class="calibre13">?.</kbd>, add new meanings</li>
</ul>
<p class="calibre3">In the light of our discussion on component-based design, you probably won't be surprised to learn that the documentation also makes some things clear; template expressions cannot:</p>
<ul class="calibre11">
<li class="calibre12">Refer to anything in the global namespace</li>
<li class="calibre12">Refer to a window or document</li>
<li class="calibre12">Call <kbd class="calibre13">console.log</kbd></li>
</ul>
<p class="calibre3">Instead, these expressions are confined to the expression context, which is typically the component instance supporting a particular template.</p>
<p class="calibre3">However, these limitations do not stop us from doing some nifty stuff with expressions. As we can see in the following examples, these all are valid expressions:</p>
<pre class="calibre19">// outputs the value of a component property 
{{property}} 
 
// adds two values 
{{ 7 + 9 }} 
 
//outputs the result of boolean comparison. Ternary operator 
{{property1 &gt;=0?'positive': 'negative'}} 
 
//call a component's testMethod and outputs the return value 
{{testMethod()}} </pre>
<div class="title-page-name">
<div class="title-page-name">
<div class="title-page-name">
<div class="packt_infobox">
<p class="calibre20"><span class="calibre22">Having looked into expressions, we strongly advise you to keep your expressions simple, thus keeping the HTML readable. The <kbd class="calibre24">*ngIf="formHasErrors()"</kbd> expression is always better than <kbd class="calibre24">*ng-if="name==null || email==null || emailformatInValid(email) || age &lt; 18"</kbd>. So, when an expression starts to become complex, move it into a method in your component.</span></p>
</div>
</div>
</div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The safe navigation operator</h1>
                
            
            <article>
                
<p class="calibre3">Before we move on there is one other expression that we should touch on: the Angular safe navigation operator (<kbd class="calibre13">?.</kbd>). This operator provides a convenient way to check for null values in lengthy property paths, like so:</p>
<pre class="calibre19">{{customer?.firstName }} </pre>
<p class="calibre3">If the safe navigation operator finds a null value (here the customer), it stops processing the path, but lets the application continue running. Without it, the application will crash when it reaches anything after the first null (here the customer name) and the view will not display. The safe navigation operator is especially helpful in situations where you are loading data asynchronously and it might not be immediately available to the view. The safe navigation operator will prevent the application from crashing and then load the data when it is available.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Data binding</h1>
                
            
            <article>
                
<p class="calibre3">Learning interpolation and expressions was easy. Now let's look at another framework construct that is being used by our sample app-data binding. We will be covering data binding in far more detail in the upcoming chapters. At this point, we will just touch briefly on the bindings that are used in the sample app we are building.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Property binding</h1>
                
            
            <article>
                
<p class="calibre3">If we look through the template in <kbd class="calibre13">app.component.ts</kbd>, we will see several places where square brackets <kbd class="calibre13">[ ]</kbd> are used. These are <strong class="calibre5">property bindings</strong>.</p>
<p class="calibre3">Let's look at the first of the bindings that we created:</p>
<pre class="calibre19">&lt;input type="number" [value]="guess" (input)="guess = $event.target.value" /&gt;</pre>
<p class="calibre3">This binding works by linking the value of the <kbd class="calibre13">guess</kbd> property in our component class to the <kbd class="calibre13">value</kbd> of the input field in the view. The binding is dynamic; so, as the value of the <kbd class="calibre13">guess</kbd> property changes, the <kbd class="calibre13">value</kbd> of the input field will be synchronized to the same value; and we do not have to write any code to do that.</p>
<p class="calibre3">At the outset, when we initialize the game, this property is set to null in the initialization method of the component class, so we will not see anything in the input field. However, as the game progresses, this number will be updated with the value of the guess as it changes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Event binding</h1>
                
            
            <article>
                
<p class="calibre3">Looking again at the template in <kbd class="calibre13">app.component.ts</kbd>, we find several places where parentheses <kbd class="calibre13">( )</kbd> appear. These are <strong class="calibre5">event bindings</strong>.</p>
<p class="calibre3">Let's look at the HTML code line that we created for the first of these event bindings. It should be familiar since the event binding is on the same tag that we first looked at for property binding: the <kbd class="calibre13">input</kbd> tag:</p>
<pre class="calibre19">&lt;input type="number" [value]="guess" (input)="guess = $event.target.value" /&gt;</pre>
<p class="calibre3">In this case, the <kbd class="calibre13">input</kbd> event of the input element is bound to an expression. The expression sets the <kbd class="calibre13">guess</kbd> property in our component class to <kbd class="calibre13">$event.target.value</kbd>, which is the value being entered by the user. Behind the scenes, when we use this syntax, Angular sets up an event handler for the event that we are binding to. In this case, the handler updates the <kbd class="calibre13">guess</kbd> property in our component class whenever the user enters a number in the <kbd class="calibre13">input</kbd> field.</p>
<p class="calibre3">There are a couple of other places in our code where the <kbd class="calibre13">( )</kbd> parentheses appear:</p>
<pre class="calibre19">&lt;button (click)="verifyGuess()" class="btn btn-primary btn-sm"&gt;Verify&lt;/button&gt;
&lt;button (click)="initializeGame()" class="btn btn-warning    btn-sm"&gt;Restart&lt;/button&gt;</pre>
<p class="calibre3">These two event bindings tie the <kbd class="calibre13">click</kbd> events for the buttons on the screen to methods in our component. So in this case, behind the scenes, Angular sets up event handlers that bind directly to the methods in our component. When the <span class="calibre6">Verify</span> button is clicked, the <kbd class="calibre13">verifyGuess</kbd> method is called, and when the <span class="calibre6">Restart</span> button is clicked, the <kbd class="calibre13">initializeGame</kbd> method is called.</p>
<p class="calibre3">As you work through the samples in this book, you will see many places where the <kbd class="calibre13">[]</kbd> tags for property bindings are combined with the <kbd class="calibre13">()</kbd> tags for events. In fact, this pairing is so common that, as we will see later, Angular has come up with a shorthand syntax to combine these tags into one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Structural directives</h1>
                
            
            <article>
                
<p class="calibre3">Next, we'll examine something that looks similar to data binding but incorporates an Angular feature that we haven't seen before: <strong class="calibre5">structural directives</strong>:</p>
<pre class="calibre19">&lt;div&gt;
  &lt;p *ngIf="deviation&lt;0" class="alert alert-warning"&gt; Your guess is higher.&lt;/p&gt; 
  &lt;p *ngIf="deviation&gt;0" class="alert alert-warning"&gt; Your guess is lower.&lt;/p&gt;
  &lt;p *ngIf="deviation===0" class="alert alert-success"&gt; Yes! That's it.&lt;/p&gt; 
&lt;/div&gt; </pre>
<p class="calibre3"><kbd class="calibre13">*ngIf</kbd> inside the <kbd class="calibre13">&lt;p&gt;</kbd> tags is the <kbd class="calibre13">NgIf</kbd> structural directive. Structural directives allow us to manipulate the structure of DOM elements. The <kbd class="calibre13">NgIf</kbd> directive removes or adds DOM elements based on the result of an expression that is assigned to it.</p>
<div class="packt_infobox">
<p class="calibre20">The asterisk <kbd class="calibre24">*</kbd> in front of <kbd class="calibre24">ngIf</kbd> is a simplified syntax that Angular, under the hood, expands into <kbd class="calibre24">ng-template</kbd>, which is Angular's implementation of the Web Components template that we discussed earlier. We'll be learning a lot more about this syntax and about structural directives in the next chapter.</p>
</div>
<p class="calibre3">In this case we are using <kbd class="calibre13">NgIf</kbd> with a simple expression, similar to the types of expression we saw with interpolation. The expression resolves to either <kbd class="calibre13">true</kbd> or <kbd class="calibre13">false</kbd> based on the value of the guess being made and its relation (higher, lower, or equal) to the correct number. It then assigns that result to <kbd class="calibre13">NgIf</kbd>, which will either add the DOM element if the result is <kbd class="calibre13">true</kbd> or remove it if it is <kbd class="calibre13">false</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Revisiting our app</h1>
                
            
            <article>
                
<p class="calibre3">So now that we have looked more closely at what makes up our view, let's take another look at our app when it is up and running. When we run our app, Angular binding starts up once the browser has rendered the raw HTML in our view. The framework then compiles this view template and, in the process, sets up the necessary binding. Next, it does the necessary synchronization between our component class and the view template that produces the final rendered output. The following screenshot depicts the transformations that happen to the view template after data binding is done for our app:</p>
<div class="packt_figure"><img src="../images/00007.jpeg" class="calibre28"/></div>
<p class="calibre3">We can ourselves see the untransformed view template of the app (what is shown on the left-hand side of the preceding screenshot) by removing the three <kbd class="calibre13">*ngIf</kbd> directives and the expressions assigned to them from the paragraphs below the input box and refreshing the app in the browser.</p>
<p class="calibre3">Angular differs from other template frameworks, in that these bindings between a component and its view are live. Changes made to the properties of the component update the view. Angular never regenerates the HTML; it just works on the relevant part of the HTML and updates only the HTML elements that need to change as component properties change. This data binding capability makes Angular an exceptional view templating engine too.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Looking at how our code handles updates</h1>
                
            
            <article>
                
<p class="calibre3">If we go back and look at the code for our class, we will see that the properties and methods in the class do not directly reference the view. Instead, the methods simply operate on the properties in the class. As a consequence, the code for our class is more readable, hence more maintainable (and of course, testable):</p>
<div class="packt_figure"><img src="../images/00008.jpeg" class="calibre28"/></div>
<p class="calibre3">So far, we have discussed how Angular updates the view based on changes in a component's properties. This is an important concept to understand as it can save us from countless hours of debugging and frustration. The next section is dedicated to learning about change detection and how these updates are managed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Maintaining state</h1>
                
            
            <article>
                
<p class="calibre3">First, let's look at how we maintain state in our Angular application. Since Angular apps are dynamic and not static, we need to understand the mechanisms that are used to make sure that these dynamic values are kept up to date as the data in an application gets updated. For example, in our application, how does the number of guesses get updated on the screen? How does the application decide to display the correct message about whether the guess is correct based on the user input?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Component as the container for state</h1>
                
            
            <article>
                
<p class="calibre3">Since we have been emphasizing so far that Angular uses the component design pattern, you will probably not be surprised to know that the basic container for the application state is the component itself. This means that when we have a component instance, all the properties in the component and their values are available for the template instance that is referenced in the component. At a practical level, this means that we can use these values directly in expressions and bindings in the template without having to write any plumbing code to wire them up.</p>
<p class="calibre3">In the sample app, for example, to determine what message to display, we can use <kbd class="calibre13">deviation</kbd> directly in the template expression. Angular will scan our component to find a property with that name and use its value. The same is true for <kbd class="calibre13">noOfTries</kbd>; Angular will look for the value of this property within our component and then use it to set its value in the interpolation within the template. We don't have to write any other code:</p>
<pre class="calibre19"> &lt;div&gt;
    &lt;p *ngIf="deviation&lt;0" class="alert alert-warning"&gt; Your guess is higher.&lt;/p&gt;
    &lt;p *ngIf="deviation&gt;0" class="alert alert-warning"&gt; Your guess is lower.&lt;/p&gt;
    &lt;p *ngIf="deviation===0" class="alert alert-success"&amp;gt; Yes! That's it.&lt;/p&gt;&lt;/div&gt; 
    &lt;p class="text-info"&gt;No of guesses : 
      &lt;span class="badge"&gt;{{noOfTries}}&lt;/span&gt; 
    &lt;/p&gt; 
&lt;/div&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Change detection</h1>
                
            
            <article>
                
<p class="calibre3">So how does Angular keep track of changes in our component as it runs? So far, it appears as if this is all done by magic. We just set up our component properties and methods, and then we bind them to the view using interpolation along with property and event binding. Angular does the rest!</p>
<p class="calibre3">But this does not happen by magic, of course, and in order to make effective use of Angular, you need to understand how it updates these values as they change. This is called <strong class="calibre5">change detection</strong>, and Angular has a very different approach to doing this than what previously existed.</p>
<p class="calibre3">If you use the debugger tool in your browser to walk through the application, you will see how change detection works. Here, we are using Chrome's Developer tools and setting a watch for the <kbd class="calibre13">noOfTries</kbd> property. If you place a breakpoint at the end of the <kbd class="calibre13">verifyGuess()</kbd> method, you will see that when you enter a guess, the <kbd class="calibre13">noOfTries</kbd> property is first updated as soon as you hit the breakpoint, as follows:</p>
<div class="packt_figure"><img src="../images/00009.jpeg" class="calibre28"/></div>
<p class="calibre3">Once you move past the breakpoint, the display on the screen updates with the correct number of guesses, as seen in the following screenshot:</p>
<div class="packt_figure"><img src="../images/00010.jpeg" class="calibre29"/></div>
<p class="calibre3">What is really going on under the hood is that Angular is reacting to events in the application and using change detectors, which go through every component, to determine whether anything has changed that affects the view. In this case, the event is a button click. The event generated by the button click calls the <kbd class="calibre13">verifyGuess()</kbd> method on the component that updates the <kbd class="calibre13">noOfTries</kbd> property.</p>
<p class="calibre3">That event triggers the change detection cycle, which identifies that the <kbd class="calibre13">noOfTries</kbd> property that is being used in the view has changed. As a result, Angular updates the element in the view that is bound to <kbd class="calibre13">noOfTries</kbd> with the new value of that property.</p>
<p class="calibre3">As you can see, this is a multistep process where Angular first updates the components and domain objects in response to an event, then runs change detection, and finally rerenders elements in the view that have changed. And, it does this on every browser event (as well as other asynchronous events, such as XHR requests and timers). Change detection in Angular is reactive and one way.</p>
<p class="calibre3">This approach allows Angular to make just one pass through the change detection graph. It is called <strong class="calibre5">one-way data binding</strong>, and it vastly improves the performance of Angular.</p>
<div class="title-page-name">
<div class="title-page-name">
<div class="title-page-name">
<div class="packt_infobox">
<p class="calibre20"><span class="calibre22">We'll be covering Angular change detection in depth in <a href="" target="_blank" class="calibre21">Chapter 8</a>, <em class="calibre25">Some Practical Scenarios</em>. For a description of this process by the Angular team, visit <a href="https://vsavkin.com/two-phases-of-angular-2-applications-fda2517604be#.fabhc0ynb" target="_blank" class="calibre21">https://vsavkin.com/two-phases-of-angular-2-applications-fda2517604be#.fabhc0ynb</a>.</span></p>
</div>
</div>
</div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Tools</h1>
                
            
            <article>
                
<p class="calibre3">Tools make our lives easy, and we are going to share some tools that will help you with different aspects of Angular development, from code writing to debugging:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Visual Studio Code</strong>: This is a new IDE that<span> </span>Microsoft<span> </span>has developed (<span><a href="https://code.visualstudio.com/" target="_blank" class="calibre10">https://code.visualstudio.com/</a></span>). It provides excellent IntelliSense and code<span> </span>completion<span> </span>support for Angular and TypeScript. Visual Studio 2017 (<span><a href="https://www.visualstudio.com/" class="calibre10">https://www.visualstudio.com/</a></span>) also includes support for Angular and TypeScript.</li>
<li class="calibre12"><strong class="calibre1">IDE extensions</strong><span>: Many of the </span>popular<span> IDEs on the </span>market<span> have plugins/extensions that make Angular development easy for us. Examples include:</span>
<ul class="calibre30">
<li class="calibre12"><strong class="calibre1">JetBrains WebStorm</strong>:<span> </span><span><a href="https://www.jetbrains.com/webstorm/" target="_blank" class="calibre10">https://www.jetbrains.com/webstorm/</a></span></li>
<li class="calibre12"><strong class="calibre1">Angular2 Snippets for Sublime Text</strong>:<span> </span><span><a href="https://github.com/evanplaice/angular2-snippets" target="_blank" class="calibre10">https://github.com/evanplaice/angular2-snippets</a></span> and the<span> </span><strong class="calibre1">TypeScript plugin for Sublime</strong> <a href="https://github.com/Microsoft/TypeScript-Sublime-Plugin" target="_blank" class="calibre10">https://github.com/Microsoft/TypeScript-Sublime-Plugin</a></li>
<li class="calibre12"><strong class="calibre1">Angular 2 TypeScript snippets for Atom</strong><span> </span><a href="https://atom.io/packages/angular-2-typescript-snippets" target="_blank" class="calibre10">https://atom.io/packages/angular-2-typescript-snippets </a>and the<span> </span><strong class="calibre1">TypeScript</strong><span> </span>plugin for<strong class="calibre1"> </strong><span>Atom</span>: <a href="https://atom.io/packages/atom-typescript" target="_blank" class="calibre10">https://atom.io/packages/atom-typescript</a></li>
</ul>
</li>
<li class="calibre12">The<span> </span><strong class="calibre1">Angular language service</strong>: One of the exciting new Developer tools, it provides auto-completions, error checking, and F12 navigation inside Angular templates that are placed in component decorators or external HTML files. You can find installation instructions and more information about the service at <a href="https://angular.io/guide/language-service" target="_blank" class="calibre10">https://angular.io/guide/language-service</a>.</li>
<li class="calibre12"><strong class="calibre1">Browser developer console</strong>: All<span> </span>current<span> </span>browsers have excellent capabilities when it comes to JavaScript debugging. Since we are<span> </span>working<span> </span>with JavaScript, we can put in breakpoints, add a watch, and do everything that is otherwise possible with JavaScript. Remember that a lot of errors with code can be detected just by looking at the browser's console window.</li>
<li class="calibre12"><strong class="calibre1">Augury</strong> (<span><a href="https://augury.angular.io/" target="_blank" class="calibre10">https://augury.angular.io/</a>)</span>: This is a Chrome Dev Tools extension for debugging Angular applications.</li>
<li class="calibre12">Component vendors are starting to offer support for Angular as well. For example, Telerik has released Kendo UI for Angular: <span><a href="http://www.telerik.com/kendo-angular-ui/" target="_blank" class="calibre10">http://www.telerik.com/kendo-angular-ui/</a></span>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Resources</h1>
                
            
            <article>
                
<p class="calibre3">Angular is a new framework, but already a vibrant community is starting to emerge around it. Together with this book, there are also blogs, articles, support forums, and plenty of help. Some of the prominent resources that will be useful are explained as follows:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Framework code and documentation</strong>: The Angular documentation can be found at <span><a href="https://angular.io/docs" target="_blank" class="calibre10">https://angular.io/docs</a></span>. Then, there is always the Angular source code, a great source of learning. It can be found at <span><a href="https://github.com/angular/angular" class="calibre10">https://github.com/angular/angular</a></span>.</li>
<li class="calibre12"><strong class="calibre1">The Angular team's blog</strong>: You can refer to the Angular team's blog for more information about Angular at <span><a href="https://blog.angular.io/" target="_blank" class="calibre10">https://blog.angular.io/</a></span>.</li>
<li class="calibre12"><strong class="calibre1">Awesome Angular</strong>: <strong class="calibre1">A curated list of awesome Angular resources</strong>: This is a community-driven effort that is maintained at <span><a href="https://github.com/gdi2290/awesome-angular" target="_blank" class="calibre10">https://github.com/gdi2290/awesome-angular</a></span>.</li>
<li class="calibre12"><strong class="calibre1">The Angular gitter chat room</strong> (<strong class="calibre1"><span><a href="https://gitter.im/angular/angular" target="_blank" class="calibre10">https://gitter.im/angular/angular</a></span></strong>)<strong class="calibre1"> </strong>is very active. Also check out <strong class="calibre1">Angular</strong> on <strong class="calibre1">Reddit</strong>: <span><a href="https://www.reddit.com/r/Angular" class="calibre10">https://www.reddit.com/r/Angular</a>.</span></li>
<li class="calibre12"><strong class="calibre1">The Angular Google group</strong> (<span><a href="https://groups.google.com/forum/#!forum/angular" target="_blank" class="calibre10">https://groups.google.com/forum/#!forum/angular</a></span>) and <strong class="calibre1">the Stack Overflow channel</strong> (<span><a href="http://stackoverflow.com/questions/tagged/Angular" target="_blank" class="calibre10">http://stackoverflow.com/questions/tagged/Angular</a></span>): Head over here if you have any questions or are stuck with some issue.</li>
<li class="calibre12"><strong class="calibre1">Angular Expo</strong> (<a href="http://angularexpo.com/" target="_blank" class="calibre10">http://angularexpo.com/</a>): People have  created some amazing apps using Angular. This site showcases such apps, and most of them have source code available for us to take a look at.</li>
</ul>
<p class="calibre3">That's it! The chapter is complete and it's now time to summarize what you've learned.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre3">The journey has started and we have reached the first milestone. Despite this chapter being named <em class="calibre17">Getting Started</em>, we have covered a lot of concepts that you will need to know in order to understand the bigger picture. Your learning was derived from our <em class="calibre17">Guess the Number!</em> app, which we built and dissected throughout the chapter.</p>
<p class="calibre3">You learned how Angular implements the component design pattern using the emerging standards for Web Components, along with the latest versions of JavaScript and TypeScript. We also reviewed some of the constructs that are used in Angular, such as interpolation, expressions, and the data binding syntax. Finally, we took a look at change detection and some useful tools and resources that will help you get started with Angular development.</p>
<p class="calibre3">The groundwork has been laid, and now we are ready for some serious app development on the Angular framework. In the next chapter, we will start working on a more complex exercise and expose ourselves to a number of new Angular constructs.</p>


            </article>

            
        </section>
    </body></html>