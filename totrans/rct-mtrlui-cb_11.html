<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Text - Collecting Text Input</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, you'll learn <span>about the following topics</span>:</p>
<ul>
<li>Controlling input with state</li>
<li>Placeholder and helper text</li>
<li>Validation and error display</li>
<li>Password fields</li>
<li>Multiline input</li>
<li>Input adornments</li>
<li>Input masking</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Material-UI<span> has a flexible text input component that can be used in a variety of ways to collect user input. Its usages range from collecting simple one-liner text input to masked input adorned with icons.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Controlling input with state</h1>
                </header>
            
            <article>
                
<p>The <kbd>TextField</kbd> component can be controlled by the React component, <kbd>state</kbd>, just like regular HTML text input elements. As with other types of form controls, the actual value is often the starting point—the state for each form control grows more complex as more functionality is added.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Just like any other text input element, you need to provide the <kbd>TextField</kbd> component with an <kbd>onChange</kbd> event handler that updates the state for the input. Without this handler, the value of the input won't change as the user types. Let's look at an example where three text fields are rendered and they're each controlled by their own piece of state:</p>
<pre>import React, { useState } from 'react';<br/><br/>import { makeStyles } from '@material-ui/styles';<br/>import TextField from '@material-ui/core/TextField';<br/>import Grid from '@material-ui/core/Grid';<br/><br/>const useStyles = makeStyles(theme =&gt; ({<br/>  container: { margin: theme.spacing.unit * 2 }<br/>}));<br/><br/>export default function ControllingInputWithState() {<br/>  const classes = useStyles();<br/>  const [first, setFirst] = useState('');<br/>  const [second, setSecond] = useState('');<br/>  const [third, setThird] = useState('');<br/><br/>  return (<br/>    &lt;Grid container spacing={4} className={classes.container}&gt;<br/>      &lt;Grid item&gt;<br/>        &lt;TextField<br/>          id="first"<br/>          label="First"<br/>          value={first}<br/>          onChange={e =&gt; setFirst(e.target.value)}<br/>        /&gt;<br/>      &lt;/Grid&gt;<br/>      &lt;Grid item&gt;<br/>        &lt;TextField<br/>          id="second"<br/>          label="Second"<br/>          value={second}<br/>          onChange={e =&gt; setSecond(e.target.value)}<br/>        /&gt;<br/>      &lt;/Grid&gt;<br/>      &lt;Grid item&gt;<br/>        &lt;TextField<br/>          id="third"<br/>          label="Third"<br/>          value={third}<br/>          onChange={e =&gt; setThird(e.target.value)}<br/>        /&gt;<br/>      &lt;/Grid&gt;<br/>    &lt;/Grid&gt;<br/>  );<br/>}</pre>
<p>When you first load the screen, here's what you'll see:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d8024952-a0e0-408b-abda-dcf7598f720c.png" style="width:37.17em;height:3.92em;"/></p>
<p>If you type in each of the text fields, you'll update the state of the component for the screen:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0ea51776-70c6-4e2c-a1fb-08c4cc328278.png" style="width:48.58em;height:6.42em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The setter functions that are created with <kbd>useState()</kbd>: <kbd>setFirst()</kbd>, <kbd>setSecond()</kbd>, and <kbd>setThird()</kbd>, change the value of the <kbd>TextField</kbd> component by changing the state that's used by the component in the <kbd>onChange</kbd> event.</p>
<div class="packt_infobox">The <kbd>TextField</kbd> component is a convenient abstraction that builds on other Material-UI components, such as <kbd>FormControl</kbd> and <kbd>Input</kbd>. You could achieve the exact same result by replacing <kbd>TextField</kbd> with each of these components. But all you would get is more code to maintain.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>What if, instead of only keeping the <kbd>TextField</kbd> value in the component state, you also kept the <kbd>id</kbd> and <kbd>label</kbd> information as well? It might seem confusing to store values that never change as a state, but the trade-off is that you can have the state data drive what's rendered by the component instead of having to repeat the same <kbd>TextField</kbd> components over and over.</p>
<p>First, let's change the shape of the component state, as follows:</p>
<pre>const [inputs, setInputs] = useState([<br/>  { id: 'first', label: 'First', value: '' },<br/>  { id: 'second', label: 'Second', value: '' },<br/>  { id: 'third', label: 'Third', value: '' }<br/>]);</pre>
<p>Instead of an object with string properties to hold the text field values, the <kbd>inputs</kbd> state is an array of objects. It's an array so that the component can iterate over the values while maintaining their order. Each object has everything necessary to render <kbd>TextField</kbd>. Let's look at the updated markup next:</p>
<pre>&lt;Grid container spacing={4} className={classes.container}&gt;<br/>  {inputs.map(input =&gt; (<br/>    &lt;Grid item key={input.id}&gt;<br/>      &lt;TextField<br/>        id={input.id}<br/>        label={input.label}<br/>        value={input.value}<br/>        onChange={onChange}<br/>      /&gt;<br/>    &lt;/Grid&gt;<br/>  ))}<br/>&lt;/Grid&gt;</pre>
<p>Each <kbd>Grid</kbd> item now maps to an element from the <kbd>inputs</kbd> array. If you need to add, remove, or change something about one of these text fields, you can do so by updating the state. Finally, let's see what the <kbd>onChange()</kbd> implementation looks like:</p>
<pre>const onChange = ({ target: { id, value } }) =&gt; {<br/>  const newInputs = [...inputs];<br/>  const index = inputs.findIndex(input =&gt; input.id === id);<br/><br/>  newInputs[index] = { ...inputs[index], value };<br/><br/>  setInputs(newInputs);<br/>};</pre>
<p>The <kbd>onChange()</kbd> function updates an item in an array, the <kbd>inputs</kbd> array. First, it finds the <kbd>index</kbd> of the item to update, based on the text field <kbd>id</kbd>. Then, it updates the <kbd>value</kbd> property with the value of the text field.</p>
<p>The functionality is the exact same as before, with a different approach that requires less JSX markup.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>TextField</kbd> demos: <a href="https://material-ui.com/demos/text-fields/">https://material-ui.com/demos/text-fields/</a></li>
<li><kbd>TextField</kbd> API documentation: <a href="https://material-ui.com/api/text-field/">https://material-ui.com/api/text-field/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Placeholder and helper text</h1>
                </header>
            
            <article>
                
<p>At a minimum, text fields should have a label so that the user knows what to type. But a label on its own can be downright confusing—especially if you have several text fields on the same screen. To help the user understand what to type, you can utilize <kbd>placeholder</kbd> and <kbd>helperText</kbd> in addition to <kbd>label</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's write some code that showcases various <kbd>label</kbd>, <kbd>placeholder</kbd>, and <kbd>helperText</kbd> configurations you can use with the <kbd>TextField</kbd> component:</p>
<pre>import React from 'react';<br/><br/>import { withStyles } from '@material-ui/core/styles';<br/>import Grid from '@material-ui/core/Grid';<br/>import TextField from '@material-ui/core/TextField';<br/><br/>const styles = theme =&gt; ({<br/>  container: { margin: theme.spacing(2) }<br/>});<br/><br/>const PlaceholderAndHelperText = withStyles(styles)(({ classes }) =&gt; (<br/>  &lt;Grid container spacing={4} className={classes.container}&gt;<br/>    &lt;Grid item&gt;<br/>      &lt;TextField label="The Value" /&gt;<br/>    &lt;/Grid&gt;<br/>    &lt;Grid item&gt;<br/>      &lt;TextField placeholder="Example Value" /&gt;<br/>    &lt;/Grid&gt;<br/>    &lt;Grid item&gt;<br/>      &lt;TextField helperText="Brief explanation of the value" /&gt;<br/>    &lt;/Grid&gt;<br/>    &lt;Grid item&gt;<br/>      &lt;TextField<br/>        label="The Value"<br/>        placeholder="Example Value"<br/>        helperText="Brief explanation of the value"<br/>      /&gt;<br/>    &lt;/Grid&gt;<br/>  &lt;/Grid&gt;<br/>));<br/><br/>export default PlaceholderAndHelperText;</pre>
<p>Here's what the four text fields look like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/25391d7d-8f72-4426-b852-3f47470da137.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's take a look at each of these text fields and break down their strengths and weaknesses.</p>
<p>First, there's a text field with a <kbd>label</kbd> component only:</p>
<pre>&lt;TextField label="The Value" /&gt;</pre>
<p>When you only have <kbd>label</kbd>, it is displayed where the user would enter text:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9b0626b6-ecd4-4027-918e-211150f60b6a.png" style="width:13.33em;height:4.08em;"/></p>
<p>When the user navigates to the text field and it receives focus, the <kbd>label</kbd> shrinks and moves out of the way:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/03fe8f73-1944-411e-9e59-df5c5619237f.png" style="width:13.42em;height:5.25em;"/></p>
<p>The next text field specifies placeholder text using the <kbd>placeholder</kbd> property:</p>
<pre>&lt;TextField placeholder="Example Value" /&gt;</pre>
<p>The <kbd>placeholder</kbd> text should provide the user with an example of a valid value if possible:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0e6f3ced-f537-423a-8a42-275e56e9c4bb.png" style="width:12.58em;height:3.58em;"/></p>
<p>When the user starts entering text, the <kbd>placeholder</kbd> value goes away:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9006a19c-5496-46e9-85d9-394f8e24f94d.png" style="width:12.42em;height:3.33em;"/></p>
<p class="mce-root">The next text field provides the <kbd>helperText</kbd> property with a value:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/46b2b250-5ad6-4e09-bc12-654793bd8fdc.png" style="width:13.83em;height:4.00em;"/></p>
<p>The helper text of a text field is static in the sense that it's always visible and doesn't move, even after the user starts typing. Lastly, text fields can have all three properties that help the user figure out what value to provide:</p>
<ul>
<li>A label that tells the user what the value is</li>
<li>Placeholder text that provides an example value</li>
<li>Helper text that gives more of an explanation of why the value is needed</li>
</ul>
<p>When you combine these three properties, you're increasing the likelihood that the user will understand what to type. When the text field is unfocused, the label and the helper text are visible:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cb208c84-4ee7-4935-8206-e77698bcf5f6.png" style="width:13.00em;height:4.67em;"/></p>
<p>When the text field receives focus, the label shrinks and the placeholder value is revealed:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d42f7cac-235b-44dc-ae5c-f43fd3887427.png" style="width:14.33em;height:6.50em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>TextField</kbd> demos: <a href="https://material-ui.com/demos/text-fields/">https://material-ui.com/demos/text-fields/</a></li>
<li><kbd>TextField</kbd> API documentation: <a href="https://material-ui.com/api/text-field/">https://material-ui.com/api/text-field/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Validation and error display</h1>
                </header>
            
            <article>
                
<p>Even with helper text, placeholders, and labels, users will inevitably enter something that's not quite right. It's not that they are trying to mess things up (some are, to be fair); it's that mistakes happen. When mistakes are made, text input fields need to be marked as being in an error state.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say that you have two inputs: a phone number and an email address, and you want to make sure that the values provided by the user are correct.</p>
<div class="packt_infobox">Please note: Validation isn't perfect. Thankfully, this piece can work, however, you need it to and you'll still get all of the Material-UI pieces.</div>
<p>Here's the code to do it:</p>
<pre>import React, { useState } from 'react';<br/><br/>import { makeStyles } from '@material-ui/styles';<br/>import Grid from '@material-ui/core/Grid';<br/>import TextField from '@material-ui/core/TextField';<br/><br/>const useStyles = makeStyles(theme =&gt; ({<br/>  container: { margin: theme.spacing(2) }<br/>}));<br/><br/>export default function ValidationAndErrorDisplay() {<br/>  const classes = useStyles();<br/>  const [inputs, setInputs] = useState([<br/>    {<br/>      id: 'phone',<br/>      label: 'Phone',<br/>      placeholder: '999-999-9999',<br/>      value: '',<br/>      error: false,<br/>      helperText: 'Any valid phone number will do',<br/>      getHelperText: error =&gt;<br/>        error<br/>          ? 'Woops. Not a valid phone number'<br/>          : 'Any valid phone number will do',<br/>      isValid: value =&gt;<br/>        /^[\+]?[(]?[0-9]{3}[)]?[-\s\.]?[0-9]{3}[-\s\.]?[0-9]{4,6}$/.test(<br/>          value<br/>        )<br/>    },<br/>    {<br/>      id: 'email',<br/>      label: 'Email',<br/>      placeholder: 'john@acme.com',<br/>      value: '',<br/>      error: false,<br/>      helperText: 'Any valid email address will do',<br/>      getHelperText: error =&gt;<br/>        error<br/>          ? 'Woops. Not a valid email address'<br/>          : 'Any valid email address will do',<br/>      isValid: value =&gt; /\S+@\S+\.\S+/.test(value)<br/>    }<br/>  ]);<br/><br/>  const onChange = ({ target: { id, value } }) =&gt; {<br/>    const newInputs = [...inputs];<br/>    const index = inputs.findIndex(input =&gt; input.id === id);<br/>    const input = inputs[index];<br/>    const isValid = input.isValid(value);<br/><br/>    newInputs[index] = {<br/>      ...input,<br/>      value: value,<br/>      error: !isValid,<br/>      helperText: input.getHelperText(!isValid)<br/>    };<br/><br/>    setInputs(newInputs);<br/>  };<br/><br/>  return (<br/>    &lt;Grid container spacing={4} className={classes.container}&gt;<br/>      {inputs.map(input =&gt; (<br/>        &lt;Grid item key={input.id}&gt;<br/>          &lt;TextField<br/>            id={input.id}<br/>            label={input.label}<br/>            placeholder={input.placeholder}<br/>            helperText={input.helperText}<br/>            value={input.value}<br/>            onChange={onChange}<br/>            error={input.error}<br/>          /&gt;<br/>        &lt;/Grid&gt;<br/>      ))}<br/>    &lt;/Grid&gt;<br/>  );<br/>}</pre>
<p>The <kbd>ValidationAndErrorDisplay</kbd> component will render two <kbd>TextField</kbd> components on the screen. This is what they look like when the screen first loads:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7b8d39f4-978d-446f-956a-87e915e50775.png" style="width:29.08em;height:5.75em;"/></p>
<p>The <span class="packt_screen">Phone</span> and <span class="packt_screen">Email</span> text fields are just regular text fields with labels, helper text, and placeholders. For example, when the <span class="packt_screen">Phone</span> field receives focus, it looks like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e75273ea-ba88-4bde-9ae0-01b6bdd1f234.png" style="width:14.33em;height:6.83em;"/></p>
<p>As you start typing, the value of the text field is validated against a phone format regular expression. Here's what the field looks like when it has an invalid phone number value:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/810fbb72-4907-491c-bcfb-a5941ec70789.png" style="width:15.50em;height:6.58em;"/></p>
<p>Then, once you have a valid phone number value, the state of the text field goes back to normal:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2f2b37a4-9080-4505-bc7b-93d6c691bc0d.png" style="width:16.17em;height:7.42em;"/></p>
<p>The <span class="packt_screen">Email</span> field works the same way—the only difference is the regular expression used to validate the format of the value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's start by taking a look at the state of the <kbd>ValidationAndErrorDisplay</kbd> component:</p>
<pre>const [inputs, setInputs] = useState([<br/>  {<br/>    id: 'phone',<br/>    label: 'Phone',<br/>    placeholder: '999-999-9999',<br/>    value: '',<br/>    error: false,<br/>    helperText: 'Any valid phone number will do',<br/>    getHelperText: error =&gt;<br/>      error<br/>        ? 'Woops. Not a valid phone number'<br/>        : 'Any valid phone number will do',<br/>    isValid: value =&gt;<br/>      /^[\+]?[(]?[0-9]{3}[)]?[-\s\.]?[0-9]{3}[-\s\.]?[0-9]{4,6}$/.test(<br/>        value<br/>      )<br/>  },<br/>  {<br/>    id: 'email',<br/>    label: 'Email',<br/>    placeholder: 'john@acme.com',<br/>    value: '',<br/>    error: false,<br/>    helperText: 'Any valid email address will do',<br/>    getHelperText: error =&gt;<br/>      error<br/>        ? 'Woops. Not a valid email address'<br/>        : 'Any valid email address will do',<br/>    isValid: value =&gt; /\S+@\S+\.\S+/.test(value)<br/>  }<br/>]);</pre>
<p>The <kbd>inputs</kbd> array is mapped to <kbd>TextField</kbd> components by the <kbd>render()</kbd> method. Each object in this array has properties that map directly to the <kbd>TextField</kbd> component. For instance, <kbd>id</kbd>, <kbd>label</kbd>, <kbd>placeholder</kbd>—these are all <kbd>TextField</kbd> properties. The objects each have two functions that help with validating the text field values. First, <kbd>getHelperText()</kbd> returns either the default helper text, or error text that replaces the helper text if the <kbd>error</kbd> argument is true. The <kbd>isValid()</kbd> function validates the <kbd>value</kbd> argument against a regular expression and returns <kbd>true</kbd> if it matches.</p>
<p>Next, let's look at the <kbd>onChange()</kbd> handler:</p>
<pre>const onChange = ({ target: { id, value } }) =&gt; {<br/>  const newInputs = [...inputs];<br/>  const index = inputs.findIndex(input =&gt; input.id === id);<br/>  const input = inputs[index];<br/>  const isValid = input.isValid(value);<br/><br/>  newInputs[index] = {<br/>    ...input,<br/>    value: value,<br/>    error: !isValid,<br/>    helperText: input.getHelperText(!isValid)<br/>  };<br/><br/>  setInputs(newInputs);<br/>};</pre>
<p>As the user types, this function updates the value state of the given text field. It also calls the <kbd>isValid()</kbd> function, passing it the updated value. The <kbd>error</kbd> state is set to <kbd>true</kbd> if the value is invalid. The <kbd>helperText</kbd> state is also updated using <kbd>getHelperText()</kbd>, which also depends on the validity of the value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>What if this example could be modified so that you didn't have to store error messages as a state, or have a function to change the helper text of the text field? To do this, you could introduce a new <kbd>TextField</kbd> abstraction that handles setting the <kbd>error</kbd> property and changes the <kbd>helperText</kbd> component when the value is <kbd>invalid</kbd>. Here's the new component:</p>
<pre>const MyTextField = ({ isInvalid, ...props }) =&gt; {<br/>  const invalid = isInvalid(props.value);<br/><br/>  return (<br/>    &lt;TextField<br/>      {...props}<br/>      error={invalid}<br/>      helperText={invalid || props.helperText}<br/>    /&gt;<br/>  );<br/>};</pre>
<p>Instead of having a function that returns <kbd>true</kbd> if the data is valid, the <kbd>MyTextField</kbd> component expects an <kbd>isInvalid()</kbd> property that returns <kbd>false</kbd> if the data is valid and an <kbd>error</kbd> message when it's <kbd>invalid</kbd>. Then, the <kbd>error</kbd> property can use this value, which changes the color of the text field to indicate that it's in an error state and the <kbd>helperText</kbd> property can use either the string that is returned by the <kbd>isInvalid()</kbd> function, or the <kbd>helperText</kbd> property that was passed to the component.</p>
<p>Next, let's look at the state that the <kbd>ValidationAndErrorDisplay</kbd> component uses now:</p>
<pre>const [inputs, setInputs] = useState([<br/>  {<br/>    id: 'phone',<br/>    label: 'Phone',<br/>    placeholder: '999-999-9999',<br/>    value: '',<br/>    helperText: 'Any valid phone number will do',<br/>    isInvalid: value =&gt;<br/>      value === '' ||<br/>      /^[\+]?[(]?[0-9]{3}[)]?[-\s\.]?[0-9]{3}[-\s\.]?[0-9]{4,6}$/.test(<br/>        value<br/>      )<br/>        ? false<br/>        : 'Woops. Not a valid phone number'<br/>  },<br/>  {<br/>    id: 'email',<br/>    label: 'Email',<br/>    placeholder: 'john@acme.com',<br/>    value: '',<br/>    helperText: 'Any valid email address will do',<br/>    isInvalid: value =&gt;<br/>      value === '' || /\S+@\S+\.\S+/.test(value)<br/>        ? false<br/>        : 'Woops. Not a valid email address'<br/>  }<br/>]);</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The inputs no longer need the <kbd>getHelperText()</kbd> function or the <kbd>error</kbd> state. The <kbd>isInvalid()</kbd> function returns the error helper text when the value is invalid. Next, let's look at the <kbd>onChange()</kbd> handler:</p>
<pre>const onChange = ({ target: { id, value } }) =&gt; {<br/>  const newInputs = [...inputs];<br/>  const index = inputs.findIndex(input =&gt; input.id === id);<br/><br/>  newInputs[index] = {<br/>    ...inputs[index],<br/>    value: value<br/>  };<br/><br/>  setInputs(newInputs);<br/>};</pre>
<p>Now, it doesn't have to touch the <kbd>error</kbd> state, or worry about updating the helper text, or about calling any validation functions—this is all handled by <kbd>MyTextField</kbd> now.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>TextField</kbd> demos: <a href="https://material-ui.com/demos/text-fields/">https://material-ui.com/demos/text-fields/</a></li>
<li><kbd>TextField</kbd> API documentation: <a href="https://material-ui.com/api/text-field/">https://material-ui.com/api/text-field/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Password fields</h1>
                </header>
            
            <article>
                
<p>Password fields are a special type of text input that hides the individual characters on the screen as they are typed. Material-UI <kbd>TextField</kbd> components support this type of field by changing the value of the <kbd>type</kbd> property.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Here's a simple example that changes a regular text input into a <kbd>password</kbd> input that prevents the value from displaying on the screen:</p>
<pre>import React, { useState } from 'react';<br/><br/>import TextField from '@material-ui/core/TextField';<br/><br/>export default function PasswordFields() {<br/>  const [password, setPassword] = useState('12345');<br/><br/>  const onChange = e =&gt; {<br/>    setPassword(e.target.value);<br/>  };<br/><br/>  return (<br/>    &lt;TextField<br/>      type="password"<br/>      label="Password"<br/>      value={password}<br/>      onChange={onChange}<br/>    /&gt;<br/>  );<br/>}</pre>
<p>Here's what the screen looks like when it first loads:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9a6e6e19-0632-4b5f-b229-446065797c30.png" style="width:14.75em;height:4.92em;"/></p>
<p>If you change the value of the <span class="packt_screen">Password</span> field, any new characters remain hidden, even though the actual value typed is stored in the <kbd>password</kbd> state of the <kbd>PasswordFields</kbd> component.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>type</kbd> property tells the <kbd>TextField</kbd> component to use a password HTML <kbd>input</kbd> element. This is how the value remains hidden as the user types it, or if the field is pre-populated with a <kbd>password</kbd> value. Sometimes, <span class="packt_screen">Password</span> fields can be autofilled.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>You can use the <kbd>autoComplete</kbd> property to control how password values are automatically filled by the browser. A common case for this value is to have the <span class="packt_screen">Password</span> field automatically filled on a login screen once the <span class="packt_screen">Username</span> field is filled. Here's an example of how you can use this property when you have <span class="packt_screen">Username</span> and <span class="packt_screen">Password</span> fields on the screen:</p>
<pre>import React, { useState } from 'react';<br/><br/>import { makeStyles } from '@material-ui/styles';<br/>import Grid from '@material-ui/core/Grid';<br/>import TextField from '@material-ui/core/TextField';<br/><br/>const useStyles = makeStyles(theme =&gt; ({<br/>  container: { margin: theme.spacing(2) }<br/>}));<br/><br/>export default function PasswordFields() {<br/>  const classes = useStyles();<br/>  const [username, setUsername] = useState('');<br/>  const [password, setPassword] = useState('');<br/><br/>  return (<br/>    &lt;Grid container spacing={4} className={classes.container}&gt;<br/>      &lt;Grid item&gt;<br/>        &lt;TextField<br/>          id="username"<br/>          label="Username"<br/>          autoComplete="username"<br/>          InputProps={{ name: 'username' }}<br/>          value={username}<br/>          onChange={e =&gt; setUsername(e.target.value)}<br/>        /&gt;<br/>      &lt;/Grid&gt;<br/>      &lt;Grid item&gt;<br/>        &lt;TextField<br/>          id="password"<br/>          type="password"<br/>          label="Password"<br/>          autoComplete="current-password"<br/>          value={password}<br/>          onChange={e =&gt; setPassword(e.target.value)}<br/>        /&gt;<br/>      &lt;/Grid&gt;<br/>    &lt;/Grid&gt;<br/>  );<br/>}</pre>
<p>The first <kbd>TextField</kbd> component uses the <kbd>autoComplete</kbd> value of <kbd>username</kbd>. It also passes <kbd>{ name: 'username' }</kbd> to <kbd>InputProps</kbd> so that the <kbd>name</kbd> property is set on the <kbd>&lt;input&gt;</kbd> element. The reason you need to do this is so that, in the second <kbd>TextField</kbd> component, the <kbd>autoComplete</kbd> value of <kbd>current-password</kbd> tells the browser to look up the password based on the <kbd>username</kbd> field value.</p>
<div class="packt_infobox">Not all browsers implement this functionality the same. In order for any credentials to be automatically filled in text fields, they have to be saved using the native browser credential remembering tool.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>TextField</kbd> demos: <a href="https://material-ui.com/demos/text-fields/">https://material-ui.com/demos/text-fields/</a></li>
<li><kbd>TextField</kbd> API documentation: <a href="https://material-ui.com/api/text-field/">https://material-ui.com/api/text-field/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Multiline input</h1>
                </header>
            
            <article>
                
<p>For some fields, users need the ability to provide text values that span multiple lines. The <kbd>multiline</kbd> property helps accomplish this goal.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say that you have a field that could require multiple lines of text, provided by the user. You can specify the <kbd>multiline</kbd> property to allow for this:</p>
<pre>import React, { useState } from 'react';<br/><br/>import TextField from '@material-ui/core/TextField';<br/><br/>export default function MultilineInput() {<br/>  const [multiline, setMultiline] = useState('');<br/><br/>  return (<br/>    &lt;TextField<br/>      multiline<br/>      value={multiline}<br/>      onChange={e =&gt; setMultiline(e.target.value)}<br/>    /&gt;<br/>  );<br/>}</pre>
<p>The text field looks like a normal field when the screen first loads, because it has one row by default:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3a19c398-c8e5-45c3-9dec-9d0913d74504.png" style="width:15.25em;height:4.00em;"/></p>
<p>You can enter as many lines as you need to in this text field. New lines are started by pressing <em>Enter</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3e2e2af7-818a-4787-b57c-34a6c8067726.png" style="width:11.58em;height:12.42em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>multiline</kbd> Boolean property is used to indicate to the <kbd>TextField</kbd> component that <kbd>multiline</kbd> support is needed for the field. With the preceding example, you might run into a couple of issues if you're planning on using the <kbd>multiline</kbd> input in a crowded space, such as a screen with many other fields on it or in a dialog:</p>
<ul>
<li>The height of the field changes as the user presses <em>Enter</em>, adding more rows to the component. This might cause layout problems as other elements are moved around.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<ul>
<li>If the field starts with one row and looks like a regular single-line text input, then the user might not realize that they can enter multiple lines of text in the field.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>To help prevent scenarios where a dynamically-sized <kbd>multiline</kbd> text field might cause problems, you can specify the number of rows used by a <kbd>multiline</kbd> text field. Here's <span>an example of how</span> to use the <kbd>rows</kbd> property:</p>
<pre>&lt;TextField<br/>  multiline<br/>  rows={5}<br/>  label="Address"<br/>  value={multiline}<br/>  onChange={e =&gt; setMultiline(e.target.value)}<br/>/&gt;</pre>
<p>Now, the text field will have exactly five rows:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/d5ad81ce-816c-4031-8f1f-981b822fc656.png" style="width:11.58em;height:8.50em;"/></p>
<p>If the user enters more than five lines of text, a vertical scrollbar will be displayed—the height of the text doesn't change and can't impact the layout of other surrounding components. You can impose the same type of height restriction on the <kbd>TextField</kbd> component by using the <kbd>rowsMax</kbd> property instead of <kbd>rows</kbd>. The difference is that the text field will start out with one row and will grow as the user adds new lines. But if you set <kbd>rowsMax</kbd> to <kbd>5</kbd>, the text field will not exceed five rows.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>TextField</kbd> demos: <a href="https://material-ui.com/demos/text-fields/">https://material-ui.com/demos/text-fields/</a></li>
<li><kbd>TextField</kbd> API documentation: <a href="https://material-ui.com/api/text-field/">https://material-ui.com/api/text-field/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Input adornments</h1>
                </header>
            
            <article>
                
<p>Material-UI <kbd>Input</kbd> components have properties that allow you to customize the way that they look and behave. The idea is that you can adorn inputs with other Material-UI components to extend the functionality of basic text inputs in a way that makes sense for the users of your application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say that your app has several screens that have password inputs. The users of your app like the ability to see passwords as they're typed. By default, values will be hidden, but if the input component itself had a button that toggles the visibility of the value, that would make your users happy.</p>
<p>Here's an example of a generic component that will adorn password fields with a visibility toggle button:</p>
<pre>import React, { useState } from 'react';<br/><br/>import TextField from '@material-ui/core/TextField';<br/>import IconButton from '@material-ui/core/IconButton';<br/>import InputAdornment from '@material-ui/core/InputAdornment';<br/><br/>import VisibilityIcon from '@material-ui/icons/Visibility';<br/>import VisibilityOffIcon from '@material-ui/icons/VisibilityOff';<br/><br/>function PasswordField() {<br/>  const [visible, setVisible] = useState(false);<br/><br/>  const toggleVisibility = () =&gt; {<br/>    setVisible(!visible);<br/>  };<br/><br/>  return (<br/>    &lt;TextField<br/>      type={visible ? 'text' : 'password'}<br/>      InputProps={{<br/>        endAdornment: (<br/>          &lt;InputAdornment position="end"&gt;<br/>            &lt;IconButton onClick={toggleVisibility}&gt;<br/>              {visible ? &lt;VisibilityIcon /&gt; : &lt;VisibilityOffIcon /&gt;}<br/>            &lt;/IconButton&gt;<br/>          &lt;/InputAdornment&gt;<br/>        )<br/>      }}<br/>    /&gt;<br/>  );<br/>}<br/><br/>export default function InputAdornments() {<br/>  const [password, setPassword] = useState('');<br/><br/>  return (<br/>    &lt;PasswordField<br/>      value={password}<br/>      onChange={e =&gt; setPassword(e.target.value)}<br/>    /&gt;<br/>  );<br/>}</pre>
<p>Here is what you'll see if you start typing without clicking on the toggle visibility button:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/930874fb-fa0e-486a-afd1-8f3b1b38adab.png" style="width:18.42em;height:3.42em;"/></p>
<p>Here's what the <span class="packt_screen">Password</span> field looks like if we click on the toggle visibility button:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/49398d97-f542-4a88-988c-d61ea6aad051.png" style="width:16.67em;height:2.92em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's take a closer look at the <kbd>PasswordField</kbd> component:</p>
<pre>function PasswordField() {<br/>  const [visible, setVisible] = useState(false);<br/><br/>  const toggleVisibility = () =&gt; {<br/>    setVisible(!visible);<br/>  };<br/><br/>  return (<br/>    &lt;TextField<br/>      type={visible ? 'text' : 'password'}<br/>      InputProps={{<br/>        endAdornment: (<br/>          &lt;InputAdornment position="end"&gt;<br/>            &lt;IconButton onClick={toggleVisibility}&gt;<br/>              {visible ? &lt;VisibilityIcon /&gt; : &lt;VisibilityOffIcon /&gt;}<br/>            &lt;/IconButton&gt;<br/>          &lt;/InputAdornment&gt;<br/>        )<br/>      }}<br/>    /&gt;<br/>  );<br/>}</pre>
<p>This component maintains a piece of state called <kbd>visible</kbd>. The reason that <kbd>PasswordField</kbd> maintains this state instead of the parent component is because of the separation of concerns principle. The parent component, for example, probably needs access to the value of the password field. This value gets passed into <kbd>PasswordField</kbd> as a property. However, only <kbd>PasswordField</kbd> cares about the <kbd>visibility</kbd> state. So, by keeping it encapsulated within this component, you've simplified any code that uses <kbd>PasswordField</kbd>.</p>
<p>The other valuable aspect of this abstraction is the adornment itself. The <kbd>type</kbd> property changes as the <kbd>visible</kbd> state changes—this is the mechanism that reveals or hides the password value. The <kbd>endAdornment</kbd> property is passed to the <kbd>Input</kbd> component that <kbd>TextField</kbd> renders, passed via <kbd>InputProps</kbd>. This is how you can add components to the field. In this example, you're adding an icon button to the right-hand side (end) of the input. The icon here changes based on the visible state and, when clicked, the <kbd>toggleVisible()</kbd> method is called to actually change the visible state.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>You can use input adornments for more than buttons that reveal the value of a password field. For example, in a field that is validated, you can use input adornments to help visualize the validation state of the field. Let's say that you need to validate an email field as the user types. You could create an abstraction in the form of a component that changes the color and the adornment of the component based on the result of validating what the user has provided. Here's what that component looks like:</p>
<pre>const ValidationField = props =&gt; {<br/>  const { isValid, ...rest } = props;<br/>  const empty = props.value === '';<br/>  const valid = isValid(props.value);<br/>  let startAdornment;<br/><br/>  if (empty) {<br/>    startAdornment = null;<br/>  } else if (valid) {<br/>    startAdornment = (<br/>      &lt;InputAdornment position="start"&gt;<br/>        &lt;CheckCircleIcon color="primary" /&gt;<br/>      &lt;/InputAdornment&gt;<br/>    );<br/>  } else {<br/>    startAdornment = (<br/>      &lt;InputAdornment position="start"&gt;<br/>        &lt;ErrorIcon color="error" /&gt;<br/>      &lt;/InputAdornment&gt;<br/>    );<br/>  }<br/><br/>  return (<br/>    &lt;TextField<br/>      {...rest}<br/>      error={!empty &amp;&amp; !valid}<br/>      InputProps={{ startAdornment }}<br/>    /&gt;<br/>  );<br/>};</pre>
<p>The idea with <kbd>ValidationField</kbd> is to take an <kbd>isValid()</kbd> function property and use it to test the value property. If it returns <kbd>true</kbd>, then <kbd>startAdornment</kbd> is a checkmark. If <kbd>isValid()</kbd> returns <kbd>false</kbd>, then <kbd>startAdornment</kbd> is a red <em>x</em>. Here's how the component is used:</p>
<pre>&lt;ValidationField<br/>  label="Email"<br/>  value={this.state.email}<br/>  onChange={this.onEmailChange}<br/>  isValid={v =&gt; /\S+@\S+\.\S+/.test(v)}<br/>/&gt;</pre>
<p>The <kbd>ValidationField</kbd> component can be used almost identically to <kbd>TextField</kbd>. The one addition is the <kbd>isValid</kbd> property. Any state is handled outside of <kbd>ValidationField</kbd>, which means that <kbd>isValid()</kbd> is called any time the value changes, and will update the appearance of the component to reflect the validity of the data. <span>By way of an</span> added bonus: you don't actually have to store any kind of error state anywhere, because <kbd>ValidationField</kbd> derives everything that it needs from the value and <kbd>isValid</kbd> properties.</p>
<p>Here's what the field looks like with an invalid email address:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/91f68951-9510-4ca3-bc1a-5881aee255a0.png" style="width:12.50em;height:3.75em;"/></p>
<p>Here's what the field looks like with a valid email address:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1ee21ae7-f4cf-4f60-96e6-423060dfa997.png" style="width:11.83em;height:3.75em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>TextField</kbd> demos: <a href="https://material-ui.com/demos/text-fields/">https://material-ui.com/demos/text-fields/</a></li>
<li><kbd>TextField</kbd> API documentation: <a href="https://material-ui.com/api/text-field/">https://material-ui.com/api/text-field/</a></li>
<li><kbd>IconButton</kbd> API documentation: <a href="https://material-ui.com/api/icon-button/">https://material-ui.com/api/icon-button/</a></li>
<li><kbd>InputAdornment</kbd> API documentation: <a href="https://material-ui.com/api/input-adornment/">https://material-ui.com/api/input-adornment/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Input masking</h1>
                </header>
            
            <article>
                
<p>Some text inputs require values with a specific format. With Material-UI <kbd>TextField</kbd> components, you can add masking capabilities that help guide the user toward providing the correct format.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say that you have phone number and email fields and you want to provide an input mask for each. Here's how you can use the <kbd>MaskedInput</kbd> component from <kbd>react-text-mask</kbd> with <kbd>TextField</kbd> components to add masking abilities:</p>
<pre>import React, { Fragment, useState } from 'react';<br/>import MaskedInput from 'react-text-mask';<br/>import emailMask from 'text-mask-addons/dist/emailMask';<br/><br/>import { makeStyles } from '@material-ui/styles';<br/>import TextField from '@material-ui/core/TextField';<br/><br/>const useStyles = makeStyles(theme =&gt; ({<br/>  input: { margin: theme.spacing.unit * 3 }<br/>}));<br/><br/>const PhoneInput = ({ inputRef, ...props }) =&gt; (<br/>  &lt;MaskedInput<br/>    {...props}<br/>    ref={ref =&gt; {<br/>      inputRef(ref ? ref.inputElement : null);<br/>    }}<br/>    mask={[<br/>      '(',<br/>      /[1-9]/,<br/>      /\d/,<br/>      /\d/,<br/>      ')',<br/>      ' ',<br/>      /\d/,<br/>      /\d/,<br/>      /\d/,<br/>      '-',<br/>      /\d/,<br/>      /\d/,<br/>      /\d/,<br/>      /\d/<br/>    ]}<br/>    placeholderChar={'\u2000'}<br/>  /&gt;<br/>);<br/><br/>const EmailInput = ({ inputRef, ...props }) =&gt; (<br/>  &lt;MaskedInput<br/>    {...props}<br/>    ref={ref =&gt; {<br/>      inputRef(ref ? ref.inputElement : null);<br/>    }}<br/>    mask={emailMask}<br/>    placeholderChar={'\u2000'}<br/>  /&gt;<br/>);<br/><br/>export default function InputMasking() {<br/>  const classes = useStyles();<br/>  const [phone, setPhone] = useState('');<br/>  const [email, setEmail] = useState('');<br/><br/>  return (<br/>    &lt;Fragment&gt;<br/>      &lt;TextField<br/>        label="Phone"<br/>        className={classes.input}<br/>        value={phone}<br/>        onChange={e =&gt; setPhone(e.target.value)}<br/>        InputProps={{ inputComponent: PhoneInput }}<br/>      /&gt;<br/>      &lt;TextField<br/>        label="Email"<br/>        className={classes.input}<br/>        value={email}<br/>        onChange={e =&gt; setEmail(e.target.value)}<br/>        InputProps={{ inputComponent: EmailInput }}<br/>      /&gt;<br/>    &lt;/Fragment&gt;<br/>  );<br/>}</pre>
<p>Here's what the screen looks like when it first loads:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/eefc70ba-4ed3-4d28-ac55-7e79a69076ec.png" style="width:19.08em;height:3.17em;"/></p>
<p>Once you start typing a value into the <span class="packt_screen">Phone</span> field, the format mask appears:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1748999d-66b2-4e88-ad00-42e2597f9915.png" style="width:12.25em;height:4.50em;"/></p>
<p>Here's what the completed value looks like—the user never has to type <kbd>(</kbd>, <kbd>)</kbd>, or <kbd>-</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/061f343c-d584-4ca4-b4e6-910d33d9e61b.png" style="width:13.50em;height:5.00em;"/></p>
<p>Here's what the completed <span class="packt_screen">Email</span> value looks like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/27b064e0-fbc5-46a2-923d-ea369d627a79.png" style="width:13.75em;height:5.08em;"/></p>
<p>With the email input, the user will actually have to type <kbd>@</kbd> and <kbd>.</kbd> because the mask doesn't know how many characters are in any part of the email address. It does, however, prevent the user from putting either of these characters in the wrong place.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>To make this work, you created a <kbd>PhoneInput</kbd> component and an <kbd>EmailInput</kbd> component. The idea of each is to provide a basic abstraction around the <kbd>MaskedInput</kbd> component. Let's take a closer look at each, starting with <kbd>PhoneInput</kbd>:</p>
<pre>const PhoneInput = ({ inputRef, ...props }) =&gt; (<br/>  &lt;MaskedInput<br/>    {...props}<br/>    ref={ref =&gt; {<br/>      inputRef(ref ? ref.inputElement : null);<br/>    }}<br/>    mask={[<br/>      '(',<br/>      /[1-9]/,<br/>      /\d/,<br/>      /\d/,<br/>      ')',<br/>      ' ',<br/>      /\d/,<br/>      /\d/,<br/>      /\d/,<br/>      '-',<br/>      /\d/,<br/>      /\d/,<br/>      /\d/,<br/>      /\d/<br/>    ]}<br/>    placeholderChar={'\u2000'}<br/>  /&gt;<br/>);</pre>
<p>The properties that are passed to <kbd>PhoneInput</kbd> are forwarded to <kbd>MaskedInput</kbd> for the most part. The <kbd>ref</kbd> property needs to be set explicitly because it's named differently. The <kbd>placeholder</kbd> property is set to be whitespace. The <kbd>mask</kbd> property is the most important—this is what determines the pattern that the user sees as they start typing. The value passed to <kbd>mask</kbd> is an array with regular expressions and string characters. The string characters are what show up when the user starts typing—in the case of phone number, these are the <kbd>(</kbd>, <kbd>)</kbd>, and <kbd>-</kbd> characters. The regular expressions are the dynamic pieces that match against what the user types. With a phone number, any digit will do, but symbols and letters aren't allowed.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Let's look at the <kbd>EmailInput</kbd> component now:</p>
<pre>const EmailInput = ({ inputRef, ...props }) =&gt; (<br/>  &lt;MaskedInput<br/>    {...props}<br/>    ref={ref =&gt; {<br/>      inputRef(ref ? ref.inputElement : null);<br/>    }}<br/>    mask={emailMask}<br/>    placeholderChar={'\u2000'}<br/>  /&gt;<br/>);</pre>
<p>This follows the same approach as <kbd>PhoneInput</kbd>. The main difference is that, instead of passing an array of strings and regular expressions, the <kbd>emailMask</kbd> function (imported from <kbd>react-text-mask</kbd>) is used.</p>
<p>Now that you have these two masked inputs, you use them by passing them to the <kbd>inputComponent</kbd> property:</p>
<pre>&lt;TextField<br/>  label="Phone"<br/>  className={classes.input}<br/>  value={phone}<br/>  onChange={e =&gt; setPhone(e.target.value)}<br/>  InputProps={{ inputComponent: PhoneInput }}<br/>/&gt;<br/>&lt;TextField<br/>  label="Email"<br/>  className={classes.input}<br/>  value={email}<br/>  onChange={e =&gt; setEmail(e.target.value)}<br/>  InputProps={{ inputComponent: EmailInput }}<br/>/&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>TextField</kbd> demos: <a href="https://material-ui.com/demos/text-fields/">https://material-ui.com/demos/text-fields/</a></li>
<li><kbd>TextField</kbd> API documentation: <a href="https://material-ui.com/api/text-field/">https://material-ui.com/api/text-field/</a></li>
<li>React text mask: <a href="https://github.com/text-mask/text-mask">https://github.com/text-mask/text-mask</a></li>
</ul>


            </article>

            
        </section>
    </body></html>