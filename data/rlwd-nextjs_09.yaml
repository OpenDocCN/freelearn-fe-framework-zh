- en: '*Chapter 7*: Using UI Frameworks'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 7 章*：使用 UI 框架'
- en: In the previous chapter, we saw how Next.js can improve our productivity by
    giving us many valid alternatives for writing CSS without the need to install
    and configure many different external packages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了 Next.js 如何通过为我们提供许多无需安装和配置多个不同外部包即可编写 CSS 的有效替代方案来提高我们的生产力。
- en: Still, there are cases where we may want to use pre-built UI libraries to take
    advantage of their components, themes, and built-in features so that we don't
    have to build them from scratch and to take advantage of a vast community that
    can help us when any problem occurs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，有些情况下我们可能希望使用预构建的 UI 库来利用它们的组件、主题和内置功能，这样我们就不必从头开始构建，并利用庞大的社区在出现任何问题时帮助我们。
- en: 'In this chapter, we will discover some modern UI libraries and learn how to
    integrate them properly in any Next.js application. We will look at the following
    in detail:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将发现一些现代 UI 库，并学习如何正确地将它们集成到任何 Next.js 应用程序中。我们将详细探讨以下内容：
- en: What UI libraries are and why we might need them
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI 库是什么以及为什么我们可能需要它们
- en: How to integrate **Chakra UI**
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何集成 **Chakra UI**
- en: How to integrate **TailwindCSS**
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何集成 **TailwindCSS**
- en: How to use **Headless UI** components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 **Headless UI** 组件
- en: By the end of the chapter, you will be able to integrate any UI library by following
    the tips and principles that we'll see in the following sections.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够通过遵循以下章节中我们将看到的提示和原则来集成任何 UI 库。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To run the code examples in this chapter, you need to have both Node.js and
    npm installed on your local machine.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码示例，您需要在您的本地计算机上安装 Node.js 和 npm。
- en: 'If you prefer, you can use an online IDE such as [https://repl.it](https://repl.it)
    or [https://codesandbox.io](https://codesandbox.io); they both support Next.js,
    and you don''t need to install any dependency on your computer. As for the other
    chapters, you can find the code base for this chapter on GitHub: https://github.com/PacktPublishing/Real-World-Next.js.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，可以使用在线 IDE，例如 [https://repl.it](https://repl.it) 或 [https://codesandbox.io](https://codesandbox.io)；它们都支持
    Next.js，您不需要在您的计算机上安装任何依赖项。至于其他章节，您可以在 GitHub 上找到本章的代码库：https://github.com/PacktPublishing/Real-World-Next.js。
- en: An introduction to UI libraries
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI 库简介
- en: UI libraries, frameworks, and utilities are not essential. We could build any
    user interface (despite its complexity) from scratch using vanilla JavaScript,
    HTML, and CSS. Still, we would often find ourselves using the same patterns, accessibility
    rules, optimizations, and utility functions on every user interface we build.
    So here comes the concept of a UI library.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: UI 库、框架和实用工具并非必需品。我们可以从头开始使用纯 JavaScript、HTML 和 CSS 构建任何用户界面（尽管可能很复杂）。然而，我们经常发现自己会在构建的每个用户界面上使用相同的模式、可访问性规则、优化和实用函数。因此，UI
    库的概念应运而生。
- en: The idea is to abstract our most common use cases, reuse most of the code on
    different user interfaces, improve our productivity, and use well-known, tested,
    and **themeable** UI components.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是将我们最常用的用例抽象化，在不同的用户界面中重用大部分代码，提高我们的生产力，并使用知名、经过测试且 **可主题化** 的 UI 组件。
- en: With "themeable," we refer to those libraries and components that allow us to
    customize the color scheme, spacing, and the whole design language of a given
    framework.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: “可主题化”指的是那些允许我们自定义给定框架的颜色方案、间距和整个设计语言的库和组件。
- en: We could take the popular *Bootstrap* library as an example. It allows us to
    override its default variables (such as colors, fonts, mixins, and so on) to customize
    the default theme. Thanks to that feature, we could potentially use Bootstrap
    on dozens of different UIs, with each UI having a very different look and feel.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以流行的 *Bootstrap* 库为例。它允许我们覆盖其默认变量（如颜色、字体、混入等）以自定义默认主题。多亏了这个特性，我们有可能在数十个不同的
    UI 上使用 Bootstrap，每个 UI 都有非常不同的外观和感觉。
- en: While Bootstrap is still a good, tested, and well-known library, we will concentrate
    on more modern alternatives in the following sections. Each option will take a
    different approach, allowing you to understand what to look for when choosing
    a UI library.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Bootstrap 仍然是一个好、经过测试且广为人知的库，但在以下章节中，我们将关注更现代的替代品。每个选项将采用不同的方法，让您了解在选择 UI
    库时应该寻找什么。
- en: Integrating Chakra UI in Next.js
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成 Next.js 中的 Chakra UI
- en: Chakra UI is an open source component library used for building modular, accessible,
    and good-looking user interfaces.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Chakra UI 是一个开源组件库，用于构建模块化、可访问且美观的用户界面。
- en: 'Its main strengths are the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 它的主要优势如下：
- en: '*Accessibility*: Chakra UI allows us to use pre-built components (such as buttons,
    modals, inputs, and many more) created by the Chakra UI team with extra attention
    to accessibility.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可访问性*：Chakra UI 允许我们使用 Chakra UI 团队创建的预构建组件（如按钮、模态框、输入框等），并额外关注可访问性。'
- en: '*Themeable*: The library ships with a default theme, where (for instance) buttons
    have a particular default background color, border radius, padding, and so on.
    We can always customize the default theme using Chakra UI built-in functions for
    editing every style of the library components.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可主题化*：该库附带默认主题，其中（例如）按钮具有特定的默认背景颜色、边框半径、填充等。我们可以始终使用 Chakra UI 内置的编辑库组件每个样式的函数来自定义默认主题。'
- en: '*Light and dark mode*: They''re both supported out of the box and can rely
    on the user''s system settings. If users set their computer to use dark mode by
    default, Chakra UI will load the dark theme as soon as it loads.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*浅色和深色模式*：它们都支持默认设置，并且可以依赖于用户的系统设置。如果用户将计算机设置为默认使用深色模式，Chakra UI 将在加载时立即加载深色主题。'
- en: '*Composability*: We can create more and more components starting from the Chakra
    UI ones. The library will give us the building blocks for creating custom components
    with ease.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可组合性*：我们可以从 Chakra UI 组件开始创建更多组件。该库将为我们提供创建自定义组件的构建块。'
- en: '*TypeScript support*: Chakra UI is written in TypeScript and provides first-class
    types for a beautiful developer experience.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*TypeScript 支持*：Chakra UI 使用 TypeScript 编写，并提供了一流的类型，以提供美好的开发者体验。'
- en: To see how to integrate Chakra UI into a Next.js application, we will be building
    a simple company employee directory using static Markdown documents as pages.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何将 Chakra UI 集成到 Next.js 应用程序中，我们将通过使用静态 Markdown 文档作为页面来构建一个简单的公司员工目录。
- en: 'So, let''s start by creating a new Next.js project:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先创建一个新的 Next.js 项目：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We now need to install Chakra UI and its dependencies:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要安装 Chakra UI 及其依赖项：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We''re now ready to integrate Chakra UI with Next.js. To do that, let''s open
    the `pages/_app.js` file and wrap the default `<Component />` component in the
    Chakra provider:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好将 Chakra UI 与 Next.js 集成。要做到这一点，让我们打开 `pages/_app.js` 文件并将默认的 `<Component
    />` 组件包裹在 Chakra 提供者中：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Using `ChakraProvider`, we can also pass a `theme` prop containing an object
    representing the themes overrides. In fact, we can overwrite the default Chakra
    UI theme by using our custom colors, fonts, spacing, and so on, by using the built-in
    `extendTheme` function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ChakraProvider`，我们还可以传递一个包含表示主题覆盖的对象的 `theme` 属性。实际上，我们可以通过使用内置的 `extendTheme`
    函数来使用我们的自定义颜色、字体、间距等来覆盖默认的 Chakra UI 主题：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can now open the `pages/index.js` file and add some Chakra UI components
    using our custom colors:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以打开 `pages/index.js` 文件并使用我们的自定义颜色添加一些 Chakra UI 组件：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Opening the page in a web browser, we will see the following result:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页浏览器中打开页面，我们将看到以下结果：
- en: '![Figure 7.1 – Chakra UI buttons with custom theme colors'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1 – 带自定义主题颜色的 Chakra UI 按钮'
- en: '](img/Figure_7.01_B16985.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 7.01_B16985.jpg](img/Figure_7.01_B16985.jpg)'
- en: Figure 7.1 – Chakra UI buttons with custom theme colors
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 带自定义主题颜色的 Chakra UI 按钮
- en: You can feel free to add your custom styles to that Chakra UI installation before
    moving any further with the chapter so that the result will reflect your taste!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本章之前，你可以自由地向该 Chakra UI 安装添加你的自定义样式，以确保结果符合你的品味！
- en: 'If you want to learn more about custom property names, I suggest you read the
    official guide before proceeding: https://chakra-ui.com/docs/theming/customize-theme.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于自定义属性名称的信息，我建议你在继续之前先阅读官方指南：https://chakra-ui.com/docs/theming/customize-theme。
- en: One thing we've already talked about but haven't seen yet is the built-in dark/light
    mode support provided by Chakra UI.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过但尚未看到的是 Chakra UI 提供的内置深色/浅色模式支持。
- en: 'The library uses the light mode by default, but we can modify this behavior
    by opening the `pages/_document.js` file and adding the following content:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 该库默认使用浅色模式，但我们可以通过打开 `pages/_document.js` 文件并添加以下内容来修改此行为：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `ColorModeScript` component will inject a script allowing our application
    to run in light/dark mode depending on the user's preference. Given the preceding
    configuration, we will adopt the user system's preference for rendering the components.
    For example, suppose the user has set their operating system to run in dark mode.
    In that case, our website will render the components in dark mode by default,
    and vice versa, it will render the components in light mode if the user sets their
    operating system to that preference.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorModeScript`组件将注入一个脚本，允许我们的应用程序根据用户的偏好以浅色/深色模式运行。鉴于前面的配置，我们将采用用户系统的偏好来渲染组件。例如，假设用户已将操作系统设置为深色模式。在这种情况下，我们的网站将默认以深色模式渲染组件，反之亦然，如果用户将操作系统设置为该偏好，它将以浅色模式渲染组件。'
- en: 'We can test that the script is working correctly by opening the `pages/index.js`
    file and replacing its content as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过打开`pages/index.js`文件并替换其内容来测试脚本是否正确工作：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Thanks to Chakra UI's `useColorMode` hook, we always know what color mode is
    being used and can render specific components (or changing colors) depending on
    that value. Also, Chakra UI will remember the user's decision, so if they set
    the color mode to dark, they will find the same color mode applied to the web
    page once they come back to the website.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢Chakra UI的`useColorMode`钩子，我们总能知道正在使用哪种颜色模式，并且可以根据该值渲染特定的组件（或更改颜色）。此外，Chakra
    UI将记住用户的决定，因此如果他们设置了深色模式，当他们回到网站时，他们将发现网页应用了相同的颜色模式。
- en: 'If we now open our website''s home page, we will be able to change its color
    mode. The result should look like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在打开我们网站的首页，我们将能够更改其颜色模式。结果应该看起来像这样：
- en: '![Figure 7.2 – Chakra UI color mode'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 – Chakra UI颜色模式'
- en: '](img/Figure_7.02_B16985.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.02_B16985.jpg)'
- en: Figure 7.2 – Chakra UI color mode
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – Chakra UI颜色模式
- en: Now that we have taken our first steps with Chakra UI and Next.js, we're finally
    ready to start developing an employee directory.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经迈出了与Chakra UI和Next.js的第一步，我们终于准备好开始开发员工目录了。
- en: 'The website will be pretty simple: it will only have a home page listing all
    the employees of a fictional company that we''ll call *ACME Corporation* and a
    single page for every single user.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 该网站将非常简单：它将只有一个列出虚构公司ACME Corporation所有员工的首页，以及每个用户的单个页面。
- en: On every page, we will have a button for switching from dark to light mode and
    vice versa.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个页面上，我们将有一个按钮用于在深色和浅色模式之间切换。
- en: Building an employee directory with Chakra UI and Next.js
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Chakra UI和Next.js构建员工目录
- en: We can reuse the project we already set up in the introduction section for Chakra
    UI and Next.js to build our employee directory. Still, we will need to make some
    minor changes to the code we have already written.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重用介绍部分中为Chakra UI和Next.js设置的现有项目来构建我们的员工目录。但我们仍需要对已编写的代码进行一些小的修改。
- en: 'If you have any doubts, you can see the complete website example on GitHub:
    https://github.com/PacktPublishing/Real-World-Next.js/tree/main/07-using-ui-frameworks/with-chakra-ui.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有任何疑问，您可以在GitHub上查看完整的网站示例：https://github.com/PacktPublishing/Real-World-Next.js/tree/main/07-using-ui-frameworks/with-chakra-ui。
- en: 'First of all, we will need the employee data. You can find a complete employee
    list (generated with fake data) at this URL: [https://github.com/PacktPublishing/Real-World-Next.js/blob/main/07-using-ui-frameworks/with-chakra-ui/data/users.js](https://github.com/PacktPublishing/Real-World-Next.js/blob/main/07-using-ui-frameworks/with-chakra-ui/data/users.js).
    If you prefer, you can write custom employee data by creating an array of objects,
    where each object must have the following properties:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要员工数据。您可以在以下URL找到完整的员工列表（使用假数据生成）：[https://github.com/PacktPublishing/Real-World-Next.js/blob/main/07-using-ui-frameworks/with-chakra-ui/data/users.js](https://github.com/PacktPublishing/Real-World-Next.js/blob/main/07-using-ui-frameworks/with-chakra-ui/data/users.js)。如果您愿意，您可以通过创建一个对象数组来编写自定义员工数据，其中每个对象必须具有以下属性：
- en: '`id`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`'
- en: '`username`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`用户名`'
- en: '`first_name`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`名字`'
- en: '`last_name`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`姓氏`'
- en: '`description`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`描述`'
- en: '`job_title`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`职位名称`'
- en: '`avatar`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`头像`'
- en: '`cover_image`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`封面图片`'
- en: 'Now create a new directory called `/data` and a JavaScript file called `users.js`,
    where we''ll place our employee data:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个新的目录`/data`和一个名为`users.js`的JavaScript文件，我们将在这里放置我们的员工数据：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can leave the `pages/_document.js` file untouched from the introduction section.
    This way, we will have access to the dark/light theme switch for our website.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以保留`pages/_document.js`文件中的介绍部分不变。这样，我们将能够访问我们网站的深色/浅色主题切换功能。
- en: 'Going to the `pages/_app.js` page, we can modify its content by including a
    new `TopBar` component (which we will create in just a moment) and removing the
    custom theme, as we don''t need it for the moment:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 `pages/_app.js` 页面，我们可以通过包含一个新的 `TopBar` 组件（我们将在下一刻创建）并移除自定义主题来修改其内容，因为我们目前不需要它：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see in the previous code block, we've wrapped our `<Component />`
    component in a Chakra UI `Box` component.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个代码块所示，我们将 `<Component />` 组件包裹在一个 Chakra UI `Box` 组件中。
- en: 'By default, `<Box>` acts as an empty `<div>`, and like any other Chakra UI
    component, it accepts any CSS directive as a prop. In this case, we''re using
    `margin="auto"` (which translates to `margin: auto`) and `maxWidth="container.xl"`,
    which translates to `max-width: var(--chakra-sizes-container-xl)`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '默认情况下，`<Box>` 作为空的 `<div>`，并且像任何其他 Chakra UI 组件一样，它接受任何 CSS 指令作为属性。在这种情况下，我们使用
    `margin="auto"`（这相当于 `margin: auto`）和 `maxWidth="container.xl"`，这相当于 `max-width:
    var(--chakra-sizes-container-xl)`。'
- en: 'Let''s create a new file, `/components/TopBar/index.js`, and create the `TopBar`
    component:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的文件，`/components/TopBar/index.js`，并创建 `TopBar` 组件：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This component is not different from the one we already created in the previous
    section; every time the user clicks on the button, it will toggle dark/light mode
    using the Chakra UI built-in `toggleColorMode` function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件与我们之前在上一节中创建的组件没有区别；每次用户点击按钮时，它将使用 Chakra UI 内置的 `toggleColorMode` 函数切换暗/亮模式。
- en: 'We can now create one more component inside a new `components/UserCard/index.js`
    file:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在新的 `components/UserCard/index.js` 文件中创建一个额外的组件：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, we're wrapping the whole component inside a Next.js `<Link>`
    component, passing the `href` value to an `<a>` child element.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们将整个组件包裹在一个 Next.js `<Link>` 组件中，将 `href` 值传递给 `<a>` 子元素。
- en: We're then using the vertical stack (`VStack`) component, which uses *flexbox*
    under the hood, to help us to arrange the child elements vertically.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后使用垂直堆叠（`VStack`）组件，它底层使用 *flexbox* 来帮助我们垂直排列子元素。
- en: 'Depending on the selected color theme, we may want different background colors
    for our user card. We can achieve that by using the Chakra UI built-in `useColorModeValue`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 根据所选的颜色主题，我们可能希望为我们的用户卡片设置不同的背景颜色。我们可以通过使用 Chakra UI 内置的 `useColorModeValue`
    来实现这一点：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first value (`'gray.50'`) will be applied by Chakra UI when the user selects
    the light theme. When the dark theme is selected, the UI library will use the
    second value (`'gray.700'`) instead.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个值（`'gray.50'`）将在用户选择亮色主题时由 Chakra UI 应用。当选择暗色主题时，UI 库将使用第二个值（`'gray.700'`）代替。
- en: 'If we now pass the right props to our `<UserCard>` component, we will see something
    like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在向 `<UserCard>` 组件传递正确的属性，我们将看到如下内容：
- en: '![Figure 7.3 – The UserCard component'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.3 – 用户卡片组件'
- en: '](img/Figure_7.03_B16985.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.03_B16985.jpg)'
- en: Figure 7.3 – The UserCard component
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 用户卡片组件
- en: 'We''re finally ready to render the employee list on our home page! Let''s head
    to our `pages/index.js` file, import the employee list, and display them using
    the newly created `UserCard` component:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好在主页上渲染员工列表了！让我们转到我们的 `pages/index.js` 文件，导入员工列表，并使用新创建的 `UserCard` 组件显示它们：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On this page, we can spot another nice Chakra UI feature: responsive props.
    We''re using the `<Grid>` component to build a grid template for our users'' cards:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个页面上，我们可以看到另一个不错的 Chakra UI 功能：响应式属性。我们使用 `<Grid>` 组件为用户的卡片构建一个网格模板：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Every Chakra UI prop can accept an array of values as input. In the preceding
    example, the UI library will render `'1fr'` on mobile screens, `'repeat(2, 1fr)'`
    on medium screens (for example, a tablet), and `'repeat(3, 1fr)'` on larger screens
    (desktop).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Chakra UI属性都可以接受一个值数组作为输入。在上面的例子中，UI库将在移动屏幕上渲染 `'1fr'`，在中等屏幕（例如平板电脑）上渲染 `'repeat(2,
    1fr)'`，在更大屏幕（桌面）上渲染 `'repeat(3, 1fr)'`。
- en: 'We can finally run the development server and see the result:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行开发服务器并查看结果：
- en: '![Figure 7.4 – Employee directory home page in light mode'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.4 – 亮色模式下的员工目录主页'
- en: '](img/Figure_7.04_B16985.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.04_B16985.jpg)'
- en: Figure 7.4 – Employee directory home page in light mode
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 亮色模式下的员工目录主页
- en: 'In my case, I had the system preference set to `TopBar` component:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，我设置了系统偏好为 `TopBar` 组件：
- en: '![Figure 7.5 – Employee directory home page in dark mode'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.5 – 暗色模式下的员工目录主页'
- en: '](img/Figure_7.05_B16985.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.05_B16985.jpg)'
- en: Figure 7.5 – Employee directory home page in dark mode
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 暗色模式下的员工目录主页
- en: We now only need to create a single employee page.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在只需要创建一个员工页面。
- en: Let's create a new file called `pages/users/[username].js`; here, we'll use
    the Next.js built-in methods to statically render each page at build time.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `pages/users/[username].js` 的新文件；在这里，我们将使用 Next.js 内置方法在构建时静态渲染每个页面。
- en: 'We can start by importing the `users.js` file and create all the static paths
    using the Next.js `getStaticPaths` function:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先导入 `users.js` 文件，并使用 Next.js 的 `getStaticPaths` 函数创建所有静态路径：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With the `getStaticPaths` function, we're telling Next.js that we need to render
    a new page for each user found in the users' array.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `getStaticPaths` 函数，我们告诉 Next.js 我们需要为用户数组中找到的每个用户渲染一个新页面。
- en: 'We''re also telling Next.js to display a 404 page if the requested path hasn''t
    been generated at build time; we do that by using the `fallback: false` property.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还告诉 Next.js 如果请求的路径在构建时未生成，则显示 404 页面；我们通过使用 `fallback: false` 属性来完成此操作。'
- en: If set to `true`, that property tells Next.js to try to render a page on the
    server side if it hasn't been rendered at build time. That's because we may want
    to get the pages from a database or external API, and we don't want to rebuild
    the whole website every time we create a new page. So, when we set `fallback`
    to `true`, Next.js will rerun the `getStaticProps` function on the server side,
    render the page, and serve it as a static page.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置为 `true`，该属性告诉 Next.js 如果在构建时没有渲染页面，则尝试在服务器端渲染页面。这是因为我们可能希望从数据库或外部 API 获取页面，我们不希望在创建新页面时每次都重建整个网站。因此，当我们设置
    `fallback` 为 `true` 时，Next.js 将在服务器端重新运行 `getStaticProps` 函数，渲染页面，并将其作为静态页面提供服务。
- en: In this case, we don't need this feature as we're taking our data from a static
    JavaScript file, but we'll use the feature in later chapters.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不需要这个功能，因为我们是从静态 JavaScript 文件中获取数据，但我们在后面的章节中会使用这个功能。
- en: 'Let''s move on by writing the `getStaticProps` function:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续编写 `getStaticProps` 函数：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With that function, we're querying the specific user that we want to display
    on the page by filtering the users' array.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个函数，我们通过过滤用户数组来查询我们想在页面上显示的特定用户。
- en: 'Before we move on to writing the page content, let''s import the required Chakra
    UI and Next.js dependencies:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写页面内容之前，让我们导入所需的 Chakra UI 和 Next.js 依赖项：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can finally write our `UserPage` component. We will be wrapping everything
    inside a Chakra UI `<Center>` component, which uses flexbox under the hood to
    center all the child elements.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以编写我们的 `UserPage` 组件。我们将把所有内容都包裹在一个 Chakra UI `<Center>` 组件中，该组件底层使用 flexbox
    来居中所有子元素。
- en: 'We''ll then use other Chakra UI built-in components such as `<Image>`, `<Flex>`,
    `<Avatar>`, `<Text>`, and so on, to create our component:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用其他 Chakra UI 内置组件，如 `<Image>`、`<Flex>`、`<Avatar>`、`<Text>` 等，来创建我们的组件：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can notice other great Chakra UI features, such as the `as` prop used in
    the `Back to all users` button:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注意到其他优秀的 Chakra UI 功能，例如在“返回所有用户”按钮中使用的 `as` 属性：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we're telling Chakra UI to render the `Button` component as an `<a>` HTML
    element. That way, we can use the `passHref` prop in its parent Next.js `Link`
    component to pass its `href` value to the button, making a more accessible UI;
    in doing so, we will create an actual `<a>` element with a proper `href` property
    attached to it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉 Chakra UI 将 `Button` 组件渲染为 `<a>` HTML 元素。这样，我们就可以在 Next.js 的父 `Link`
    组件中使用 `passHref` 属性将 `href` 值传递给按钮，从而创建一个更易于访问的 UI；这样做时，我们将创建一个带有适当 `href` 属性的实际
    `<a>` 元素。
- en: 'We can now run the development server and test the final result:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行开发服务器并测试最终结果：
- en: '![Figure 7.6 – Single employee in light mode'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.6 – 亮模式下的单个员工'
- en: '](img/Figure_7.06_B16985.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.06_B16985.jpg)'
- en: Figure 7.6 – Single employee in light mode
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 亮模式下的单个员工
- en: 'By clicking on the **Toggle theme** button, we can also access the dark version
    of our user interface, which looks like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击“切换主题”按钮，我们还可以访问用户界面的暗黑版本，它看起来是这样的：
- en: '![Figure 7.7 – Single employee in dark mode'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.7 – 暗黑模式下的单个员工'
- en: '](img/Figure_7.07_B16985.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.07_B16985.jpg)'
- en: Figure 7.7 – Single employee in dark mode
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 暗黑模式下的单个员工
- en: 'We have also used responsive styles, so we can test our UI by resizing the
    browser page:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了响应式样式，因此我们可以通过调整浏览器页面的大小来测试我们的 UI：
- en: '![Image 7.8 – Single employee page (mobile view)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图像 7.8 – 单个员工页面（移动视图）'
- en: '](img/Figure_7.08_B16985.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.08_B16985.jpg)'
- en: Image 7.8 – Single employee page (mobile view)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图像 7.8 – 单个员工页面（移动视图）
- en: As you can see, implementing a responsive user interface with Chakra UI's built-in
    components was straightforward.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用 Chakra UI 内置组件实现响应式用户界面非常简单。
- en: If you want to dig deeper into all the existing components, hooks, and utilities,
    you can learn more at [https://chakra-ui.com](https://chakra-ui.com).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想深入了解所有现有的组件、钩子和实用工具，您可以在 [https://chakra-ui.com](https://chakra-ui.com)
    上了解更多信息。
- en: Conclusive words about Chakra UI
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于 Chakra UI 的总结性话语
- en: Chakra UI is a great modern UI library, and I personally use it on many of the
    projects I work on. It's open source and free to use, with a great community that
    works every day to optimize it and make it even more accessible, performant, and
    complete.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Chakra UI 是一个优秀的现代 UI 库，我本人也在我工作的许多项目中使用它。它是开源的，并且免费使用，有一个每天都在优化它并使其更加易于使用、性能更佳和更完整的社区。
- en: It also provides a premium set of pre-made UI components built by the Chakra
    UI core team. If you're interested, you can look at them at [https://pro.chakra-ui.com/components](https://pro.chakra-ui.com/components).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供了一套由 Chakra UI 核心团队构建的预制的 UI 组件。如果您感兴趣，可以在 [https://pro.chakra-ui.com/components](https://pro.chakra-ui.com/components)
    上查看。
- en: 'In the next section, we will change our focus to another popular yet completely
    different UI library: TailwindCSS.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将把我们的重点转移到另一个流行的但完全不同的 UI 库：TailwindCSS。
- en: Integrating TailwindCSS in Next.js
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Next.js 中集成 TailwindCSS
- en: '**TailwindCSS** is a utility-first CSS framework that allows you to build any
    user interface using pre-made CSS classes that map CSS rules in a straightforward
    way.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**TailwindCSS** 是一个以工具优先的 CSS 框架，它允许您使用预制的 CSS 类来构建任何用户界面，这些类以直接的方式映射 CSS 规则。'
- en: Unlike Chakra UI, Material UI, and many other UI frameworks, it just provides
    CSS rules; the framework gives no JavaScript scripts or React components, so we'll
    need to write them by ourselves.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Chakra UI、Material UI 以及许多其他 UI 框架不同，它只提供 CSS 规则；框架不提供任何 JavaScript 脚本或 React
    组件，因此我们需要自己编写它们。
- en: 'Its main strengths are the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 它的主要优势如下：
- en: '*Framework agnostic*: You can use TailwindCSS in React, Vue, Angular, and even
    in plain HTML and JavaScript. It''s just a set of CSS rules.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*框架无关性*：您可以在 React、Vue、Angular 以及纯 HTML 和 JavaScript 中使用 TailwindCSS。它只是一组
    CSS 规则。'
- en: '*Themeable*: Just like Chakra UI, you can customize all the TailwindCSS variables
    to make them match your design tokens.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可定制主题*：就像 Chakra UI 一样，您可以自定义所有 TailwindCSS 变量，使它们与您的设计令牌相匹配。'
- en: '*Dark and light theme support*: You can easily enable or disable the dark theme
    by modifying a specific CSS class from the `<html>` element.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*暗黑和亮色主题支持*：您可以通过修改 `<html>` 元素中的一个特定 CSS 类来轻松启用或禁用暗黑主题。'
- en: '*Highly optimized*: TailwindCSS is formed of many CSS classes, but it''s able
    to prune the unused ones at build time, reducing the final bundle size, as unused
    CSS classes get removed.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高度优化*：TailwindCSS 由许多 CSS 类组成，但在构建时能够修剪未使用的类，从而减少最终包的大小，因为未使用的 CSS 类会被移除。'
- en: '*Mobile-ready*: You can use specific CSS classes'' prefixes to apply certain
    rules to mobile, desktop, or tablet screens only.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*移动端兼容性*：您可以使用特定 CSS 类的前缀来仅将某些规则应用于移动、桌面或平板屏幕。'
- en: In this section, we will see how to integrate, customize, and optimize TailwindCSS
    in Next.js by rebuilding the same project we did in the last section. That way,
    the differences between Chakra UI and TailwindCSS will be even more evident.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何通过重建上一节中做的相同项目来在 Next.js 中集成、自定义和优化 TailwindCSS。这样，Chakra UI 和 TailwindCSS
    之间的差异将更加明显。
- en: 'Let''s create a new project and install all the required dependencies:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的项目并安装所有必需的依赖项：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'TailwindCSS only requires three `devDependencies`, so let''s enter the newly
    created project and install them:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: TailwindCSS 只需要三个 `devDependencies`，所以让我们进入新创建的项目并安装它们：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As we''ve already seen, TailwindCSS doesn''t ship with any JavaScript utility,
    so, unlike Chakra UI, we will need to manage the dark/light theme switch ourselves.
    However, we can take advantage of the `next-themes` library to help us manage
    the themes, so let''s install that package:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，TailwindCSS 不附带任何 JavaScript 实用工具，因此，与 Chakra UI 不同，我们将需要自己管理暗黑/亮色主题切换。然而，我们可以利用
    `next-themes` 库来帮助我们管理主题，所以让我们安装这个包：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now that we have all the dependencies installed, we need to set up the basic
    TailwindCSS configuration files. We can do that by using the `tailwindcss init`
    command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了所有依赖项，我们需要设置基本的 TailwindCSS 配置文件。我们可以通过使用 `tailwindcss init` 命令来完成：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will create two different files:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建两个不同的文件：
- en: '`tailwind.config.js`: This file will help us configure the TailwindCSS theme,
    unused CSS purge, dark mode, plugins, and more.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tailwind.config.js`：此文件将帮助我们配置 TailwindCSS 主题、未使用 CSS 清除、暗黑模式、插件等。'
- en: '`postcss.config.js`: `postcss.config.js` that we can always edit as we prefer.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postcss.config.js`：我们可以随时按我们的喜好编辑 `postcss.config.js`。'
- en: 'First of all, we want to configure TailwindCSS to remove unused CSS from the
    final build. We can do that by opening the `tailwind.config.js` file and editing
    it as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想要配置 TailwindCSS 以从最终构建中移除未使用的 CSS。我们可以通过打开 `tailwind.config.js` 文件并按以下方式编辑它来实现：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, we're telling TailwindCSS to check every file ending with `.js`
    or `.jsx` inside both `pages/` and `components/` directories and remove all the
    CSS classes that are not used inside of any of those files.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们告诉 TailwindCSS 检查 `pages/` 和 `components/` 目录中所有以 `.js` 或 `.jsx` 结尾的文件，并删除其中任何文件未使用的所有
    CSS 类。
- en: We also set the `darkMode` property to `'class'`. That way, the framework will
    look at the `<html>` class element to determine whether we need to render the
    components using dark or light mode.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将 `darkMode` 属性设置为 `'class'`。这样，框架将查看 `<html>` 类元素以确定我们是否需要使用深色或浅色模式渲染组件。
- en: 'We now only need to include the default `tailwind.css` CSS file on every single
    page of our application, and we''re ready to start. We can do that by importing
    `''tailwindcss/tailwind.css''` inside our `pages/_app.js` file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要在我们的应用程序的每一页上包含默认的 `tailwind.css` CSS 文件，我们就可以开始了。我们可以通过在 `pages/_app.js`
    文件中导入 `'tailwindcss/tailwind.css'` 来做到这一点：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can now start to include specific TailwindCSS classes. Keeping the `pages/_app.js`
    file open in our code editor, we can begin by importing `ThemeProvider` from the
    `next-themes` package, which will help us manage the dark/light theme switch,
    and wrap every other component inside of it:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始包含特定的 TailwindCSS 类。保持我们的代码编辑器中的 `pages/_app.js` 文件打开，我们可以首先从 `next-themes`
    包中导入 `ThemeProvider`，这将帮助我们管理深色/浅色主题切换，并将其他所有组件包裹在其中：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, we're following the same steps we did with Chakra UI. We're
    importing the `TopBar` component (which will be common to all the pages on our
    website) and wrapping the Next.js `<Component />` component inside a container.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在遵循与 Chakra UI 相同的步骤。我们导入 `TopBar` 组件（它将适用于我们网站上的所有页面）并将 Next.js `<Component
    />` 组件包裹在一个容器中。
- en: 'We''ll see how to write the `TopBar` component in just a moment; for now, let''s
    concentrate on the `<div>` that is wrapping the `<Component />` component:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会看到如何编写 `TopBar` 组件；现在，让我们集中精力在包裹 `<Component />` 组件的 `<div>` 上：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We used four different CSS classes; let''s break them down:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了四个不同的 CSS 类；让我们逐一分析：
- en: '`dark:bg-gray-900`: When the theme is set to dark mode, the background color
    for this `<div>` will be set to `bg-gray-900`, a TailwindCSS variable that maps
    to the `#111927` HEX color.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dark:bg-gray-900`：当主题设置为深色模式时，此 `<div>` 的背景颜色将设置为 `bg-gray-900`，这是一个映射到 `#111927`
    HEX 颜色的 TailwindCSS 变量。'
- en: '`bg-gray-50`: By default (so in light mode), the background color for this
    div will be set to `bg-gray-50`, which maps to the `#f9fafb` HEX color.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bg-gray-50`：默认情况下（因此在浅色模式下），此 `div` 的背景颜色将设置为 `bg-gray-50`，它映射到 `#f9fafb`
    HEX 颜色。'
- en: '`w-full`: This means "full width," so the `<div>` will have the `width` property
    set to `100%`.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w-full`：这意味着“全宽”，因此 `<div>` 将将 `width` 属性设置为 `100%`。'
- en: '`min-h-screen`: This CSS class stands for *set the min-height property to the
    whole screen height*, shorthand for `min-height: 100vh`.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min-h-screen`：这个 CSS 类代表 *将最小高度属性设置为整个屏幕高度*，是 `min-height: 100vh` 的缩写。'
- en: 'We can now create a new `/components/TopBar/index.js` file and add the following
    content:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个新的 `/components/TopBar/index.js` 文件并添加以下内容：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we're creating the full-width horizontal green bar (`className="w-full
    p-2 bg-green-500"`) with 0.5rem of padding (`p-2` class) and `#12b981` as the
    background color (`bg-green-500`).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个全宽的水平绿色条（`className="w-full p-2 bg-green-500"`），具有 0.5rem 的填充（`p-2`
    类）和 `#12b981` 作为背景颜色（`bg-green-500`）。
- en: Inside that `<div>`, we're placing another centered `<div>` with 75% width (`w-10/12`).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个 `<div>` 内部，我们放置另一个居中的 `<div>`，宽度为 75%（`w-10/12`）。
- en: 'We''re then importing the `ThemeSwitch` button, which still needs to be created.
    Let''s do that by creating a new file under `components/ThemeSwitch/index.js`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们导入 `ThemeSwitch` 按钮，该按钮仍需创建。让我们在 `components/ThemeSwitch/index.js` 的新文件中创建它：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This component is pretty straightforward; we use the `useTheme` hook packed
    with the `next-themes` library and change the theme value to `light` or `dark`,
    depending on the current set theme.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件相当简单；我们使用 `next-themes` 库打包的 `useTheme` 钩子，并根据当前设置的主题将主题值更改为 `light` 或 `dark`。
- en: One thing to notice is that we're doing that on the client side only (by writing
    `typeof window === 'undefined'`). In fact, this hook adds a `theme` entry in the
    browser's `localStorage`, which of course, is not accessible on the server side.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一件需要注意的事情是我们只在客户端执行这个操作（通过编写`typeof window === 'undefined'`）。实际上，这个钩子会在浏览器的`localStorage`中添加一个`theme`条目，当然，在服务器端是无法访问的。
- en: For that reason, the `ThemeSwitch` component will be rendered on the client
    side only.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`ThemeSwitch`组件将仅在客户端渲染。
- en: Talking about the `<button>` CSS classes, we can see that we're building a rounded
    button with a green background. The green tonality, by the way, will be different
    depending on the currently selected theme.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到`<button>` CSS类，我们可以看到我们正在构建一个带有绿色背景的圆角按钮。顺便说一句，绿色色调将根据当前选定的主题而有所不同。
- en: 'Now let''s write the `UserCard` component. Create a new file under `components/UserCard/index.js`
    and add the following content:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写`UserCard`组件。在`components/UserCard/index.js`下创建一个新文件，并添加以下内容：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Except for the CSS class names, this component is not that different from the
    Chakra UI one.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 除了CSS类名外，这个组件与Chakra UI的组件没有太大区别。
- en: Image Optimizations
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图片优化
- en: As you can see, we're not currently optimizing the images, and we're serving
    them using the default `<img />` HTML element. Unfortunately, that can make our
    website slower and lead to a lousy SEO score.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们目前没有对图片进行优化，并且使用默认的`<img />` HTML元素来提供它们。不幸的是，这可能会使我们的网站变慢，并导致糟糕的SEO评分。
- en: Try to configure automatic image optimization and serve them using the Next.js
    `<Image />` component!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试配置自动图片优化，并使用Next.js的`<Image />`组件来提供它们！
- en: Can't remember how to do it? You can go over [*Chapter 3*](B16985_03_Final_SB_epub.xhtml#_idTextAnchor038),
    *Next.js Basics and Built-In Components*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得怎么做吗？您可以查看[*第3章*](B16985_03_Final_SB_epub.xhtml#_idTextAnchor038)，*Next.js基础和内置组件*。
- en: We're now ready to write the home page for our ACME employee directory. First,
    make sure to have the same `users.js` file we used in the previous section positioned
    under `data/users.js`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好编写ACME员工目录的首页。首先，确保将我们在上一节中使用的相同`users.js`文件放置在`data/users.js`下。
- en: 'If you need to download it again, you can do it by copying the content from
    here: [https://github.com/PacktPublishing/Real-World-Next.js/blob/main/07-using-ui-frameworks/with-tailwindcss/data/users.js](https://github.com/PacktPublishing/Real-World-Next.js/blob/main/07-using-ui-frameworks/with-tailwindcss/data/users.js).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要再次下载，可以通过复制以下内容来完成：[https://github.com/PacktPublishing/Real-World-Next.js/blob/main/07-using-ui-frameworks/with-tailwindcss/data/users.js](https://github.com/PacktPublishing/Real-World-Next.js/blob/main/07-using-ui-frameworks/with-tailwindcss/data/users.js)。
- en: 'Now we can open the `pages/index.js` file, import both the `users.js` file
    and the `UserCard` component, then put everything together to create a user grid
    as we did with Chakra UI:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以打开`pages/index.js`文件，导入`users.js`文件和`UserCard`组件，然后将所有内容组合起来创建一个用户网格，就像我们使用Chakra
    UI所做的那样：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As you can see, here we''re starting to use some responsive directives:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这里我们开始使用一些响应式指令：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `sm:` prefix is used to apply a specific rule when the window width is greater
    than or equal to `640px`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`sm:`前缀用于在窗口宽度大于或等于`640px`时应用特定规则。'
- en: 'By default, TailwindCSS classes are mobile-first, and if we want to apply a
    specific class to wider screens, we will need to prefix those classes with one
    of the following prefixes: `sm:` (`640px`), `md:` (`768px`), `lg:` (`1024px`),
    `xl:` (`1280px`), or `2xl:` (`1536px`).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，TailwindCSS类是针对移动端优先的，如果我们想要将特定类应用于更宽的屏幕，我们需要在这些类名前加上以下前缀之一：`sm:`（`640px`）、`md:`（`768px`）、`lg:`（`1024px`）、`xl:`（`1280px`）或`2xl:`（`1536px`）。
- en: 'We can now run the development server and head to the home page. We will see
    the following result:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行开发服务器并转到首页。我们将看到以下结果：
- en: '![Figure 7.9 – Employee directory built with TailwindCSS (light theme)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.9 – 使用TailwindCSS（浅色主题）构建的员工目录'
- en: '](img/Figure_7.09_B16985.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.09_B16985.jpg)'
- en: Figure 7.9 – Employee directory built with TailwindCSS (light theme)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 – 使用TailwindCSS（浅色主题）构建的员工目录
- en: 'We can also switch the theme to **dark** by clicking on the button on the green
    bar at the top of the screen:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过点击屏幕顶部的绿色栏中的按钮来切换到**深色**主题：
- en: '![Figure 7.10 – Employee directory built with TailwindCSS (dark theme)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.10 – 使用TailwindCSS（深色主题）构建的员工目录'
- en: '](img/Figure_7.10_B16985.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.10_B16985.jpg)'
- en: Figure 7.10 – Employee directory built with TailwindCSS (dark theme)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 – 使用TailwindCSS（深色主题）构建的员工目录
- en: If you compare the visual results of the Chakra UI implementation and the TailwindCSS
    one, you will see how similar they look!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您比较Chakra UI实现和TailwindCSS实现的视觉结果，您将看到它们多么相似！
- en: 'Let''s complete our website by creating the single-user page. If you haven''t
    already, create a new page called `pages/user/[username].js`, and start by importing
    the required dependencies:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建单用户页面来完成我们的网站。如果您还没有创建，请创建一个名为`pages/user/[username].js`的新页面，并首先导入所需的依赖项：
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can now write the `getStaticPaths` function:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写`getStaticPaths`函数：
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And let''s write the `getStaticProps` function:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写`getStaticProps`函数：
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You may have noticed that those functions are the same as we wrote in the Chakra
    UI section. In fact, with this implementation, we only change the way we render
    the page content; all the server-side data fetching and manipulation will remain
    the same.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，这些函数与我们之前在Chakra UI部分编写的函数相同。实际上，通过这种实现方式，我们只改变了渲染页面内容的方式；所有服务器端的数据获取和处理将保持不变。
- en: 'We''re finally ready to write the single-user page component. Here, we will
    be creating a similar structure to the one we wrote with Chakra UI, but of course,
    using TailwindCSS classes and standard HTML elements:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好编写单用户页面组件了。在这里，我们将创建与Chakra UI类似的架构，但当然，使用TailwindCSS类和标准HTML元素：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: And we're done! We've rewritten our entire application by using TailwindCSS.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了！我们通过使用TailwindCSS重写了整个应用。
- en: At the time of writing, the original TailwindCSS stylesheet size is around 4.7
    MB. After building the website for production by just running `yarn build`, the
    final TailwindCSS file will be about 6 KB.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，原始的TailwindCSS样式表大小约为4.7 MB。通过仅运行`yarn build`来构建用于生产的网站，最终的TailwindCSS文件将大约为6
    KB。
- en: You can quickly test this by commenting on the `purge` property inside of the
    `tailwind.config.js` file.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在`tailwind.config.js`文件中注释掉`purge`属性来快速测试这一点。
- en: So far, we've seen two different (yet very modern) approaches to styling a web
    application, and they both have their pros and cons.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了两种不同的（但非常现代的）为网页应用添加样式的方案，它们各有优缺点。
- en: While they share some ideas about how to write styles for any website, Chakra
    UI has the advantage of providing pre-built React components, which can come in
    handy when you want to integrate the library in your Next.js/React application
    and make it more dynamic with ease.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们在如何为任何网站编写样式方面有一些共同的想法，但Chakra UI的优势在于提供预构建的React组件，这在您想要将库集成到Next.js/React应用中并轻松使其更动态时非常有用。
- en: 'Luckily, the TailwindCSS team came up with the innovative idea of providing
    a dynamic interface to TailwindCSS (and possibly any other UI framework): Headless
    UI.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，TailwindCSS团队提出了一个创新的想法，即提供TailwindCSS（以及可能的其他UI框架）的动态接口：Headless UI。
- en: In the next section, we will look at Headless UI and how it can make things
    easier for us when building modern, performant, and optimized web applications
    with Next.js.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨Headless UI以及它如何帮助我们使用Next.js构建现代、高性能和优化的网页应用。
- en: Integrating Headless UI
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成Headless UI
- en: As we saw in the previous section, TailwindCSS only provides CSS classes to
    be used inside any web component.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所述，TailwindCSS仅提供用于任何网页组件内部的CSS类。
- en: If we want to implement something dynamic, such as a modal, a switch button,
    and so on, we need to write some JavaScript logic on our own.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要实现一些动态内容，例如模态框、开关按钮等，我们需要自己编写一些JavaScript逻辑。
- en: '**Headless UI** solves this problem by providing the opposite of TailwindCSS:
    dynamic components without any CSS class or style. That way, we''re free to use
    TailwindCSS or any other CSS framework to style pre-built components in a straightforward
    way.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**Headless UI**通过提供TailwindCSS的相反面：没有CSS类或样式的动态组件，来解决这一问题。这样，我们可以自由地使用TailwindCSS或任何其他CSS框架以简单的方式对预构建组件进行样式化。'
- en: 'Headless UI is a free and open source project created by the *Tailwind Labs*
    team (the same organization behind TailwindCSS), and if you''re interested, you
    can browse the source code at the following URL: [https://github.com/tailwindlabs/headlessui](https://github.com/tailwindlabs/headlessui).'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Headless UI是由*Tailwind Labs*团队（TailwindCSS背后的组织）创建的免费开源项目，如果您感兴趣，可以浏览以下URL的源代码：[https://github.com/tailwindlabs/headlessui](https://github.com/tailwindlabs/headlessui)。
- en: Integrating Headless UI and TailwindCSS is not very different from integrating
    TailwindCSS alone. We can set up a new project and install all the TailwindCSS
    dependencies just like we did in the previous section.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 将Headless UI和TailwindCSS集成与仅集成TailwindCSS并没有很大区别。我们可以设置一个新的项目并安装所有TailwindCSS依赖项，就像我们在上一节中所做的那样。
- en: 'After that, we can install Headless UI itself. We will also install `classnames`,
    a simple and widely used utility that will help us create dynamic CSS class names:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以安装Headless UI本身。我们还将安装`classnames`，这是一个简单且广泛使用的实用工具，它将帮助我们创建动态CSS类名：
- en: '[PRE36]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We will now develop a simple menu component by using Headless UI and TailwindCSS.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用Headless UI和TailwindCSS开发一个简单的菜单组件。
- en: 'Let''s go to the `pages/index.js` file and import Headless UI, `classnames`,
    and Next.js'' `Link` component:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去`pages/index.js`文件中导入Headless UI、`classnames`和Next.js的`Link`组件：
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, inside the same page, let''s create an array of menu elements. We will
    be using them to populate the menu with mocked data:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在同一页面上，让我们创建一个菜单元素的数组。我们将使用它们用模拟数据填充菜单：
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can now destructure the Headless UI `Menu` component and take all the components
    we need to build our menu:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以解构Headless UI的`Menu`组件，并获取我们构建菜单所需的所有组件：
- en: '[PRE39]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Every menu entry will be wrapped inside an `Item` component. Given that every
    menu entry will behave the same way, we can create a generic `MenuEntry` component
    and apply it to our array of entries:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 每个菜单条目都将被包裹在一个`Item`组件中。鉴于每个菜单条目都将以相同的方式表现，我们可以创建一个通用的`MenuEntry`组件并将其应用于条目数组：
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, Headless UI will pass an `active` state to all the elements
    inside of `Item`. We will use that state to show the user which element of the
    menu is currently active.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，Headless UI将传递一个`active`状态给`Item`内的所有元素。我们将使用这个状态来显示用户当前激活的菜单元素。
- en: 'We now only need to wrap everything together inside the `Menu` component:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要将所有内容包裹在`Menu`组件中：
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If we now launch the development server, we will see an utterly unstyled button
    at the top right of our screen. We can click on this button to reveal – and then
    hide – its content.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在启动开发服务器，我们将在屏幕右上角看到一个完全没有样式的按钮。我们可以点击这个按钮来显示——然后隐藏——其内容。
- en: 'We can now proceed to style our menu, beginning with the `MenuEntry` component:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始为我们的菜单进行样式设计，从`MenuEntry`组件开始：
- en: '[PRE42]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Moving on to the main component, we can simply add the CSS classes required
    for styling `Button` and `Item` components. We want the menu button to be purple
    with white text, and the drop-down menu to have rounded corners with a nice box
    shadow, so let''s add the following classes:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们转到主组件，我们可以简单地添加所需的CSS类来为`Button`和`Item`组件进行样式设计。我们希望菜单按钮是紫色并带有白色文字，而下拉菜单要有圆角和漂亮的阴影，所以让我们添加以下类：
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can also apply a transition to our menu, making the reveal/hide part smoother.
    We just need to import the `Transition` component from Headless UI and wrap the
    menu items inside it:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以给我们的菜单添加一个过渡效果，使显示/隐藏部分更加平滑。我们只需要从Headless UI导入`Transition`组件，并将菜单项包裹在其中：
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We just styled our first headless component with TailwindCSS, but we can use
    our own CSS rules or any other CSS framework!
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用TailwindCSS样式化了第一个无头组件，但我们可以使用自己的CSS规则或任何其他CSS框架！
- en: Just like Chakra UI, TailwindCSS provides a series of premium components, and
    many of those components rely on Headless UI for managing their interactions.
    If you're interested in that, you can learn more at [https://tailwindui.com](https://tailwindui.com).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Chakra UI一样，TailwindCSS提供了一系列高级组件，其中许多组件依赖于Headless UI来管理它们的交互。如果你对此感兴趣，你可以在[https://tailwindui.com](https://tailwindui.com)了解更多信息。
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen three different and modern approaches for building
    user interfaces with Next.js, React, and even plain HTML.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了使用Next.js、React甚至纯HTML构建用户界面的三种不同且现代的方法。
- en: In the following chapters, where we will be working on real-world web applications,
    we will be using the lessons learned in these sections to speed up the UI development,
    always keeping an eye on performance, accessibility, and developer experience.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将使用这些部分学到的经验来加速UI开发，同时始终关注性能、可访问性和开发者体验。
- en: 'If you''re interested in learning more about the differences between Chakra
    UI and TailwindCSS specifically, you can read the official guide on the Chakra
    UI website: https://chakra-ui.com/docs/comparison.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解Chakra UI和TailwindCSS之间的具体差异，你可以在Chakra UI网站上阅读官方指南：https://chakra-ui.com/docs/comparison。
- en: Both libraries provide excellent support for implementing beautiful user interfaces,
    and even though they share some features, they are quite different in practice.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个库都为实施美观的用户界面提供了出色的支持，尽管它们共享一些功能，但在实践中它们相当不同。
- en: Chakra UI exposes a fantastic set of components, but they are only available
    for React and Vue. What if your project uses Angular or Svelte?
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Chakra UI提供了一套出色的组件，但它们仅适用于React和Vue。如果你的项目使用Angular或Svelte怎么办？
- en: 'TailwindCSS, on the other hand, is 100% framework-agnostic: you can use it
    for writing the frontend of any web application independently of the technology
    you''re using.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，TailwindCSS是100%框架无关的：你可以独立于你使用的任何技术来用它编写任何网络应用程序的前端。
- en: 'In my opinion, there is no clear winner: choosing either of these libraries
    is entirely up to personal taste.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，并没有明显的胜者：选择这两个库中的任何一个完全取决于个人喜好。
- en: In the next chapter, we will change our focus to the backend of our applications,
    learning how to dynamically serve a Next.js web application from a custom Node.js
    server.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把我们的关注点转向我们应用程序的后端，学习如何从自定义Node.js服务器动态地提供Next.js网络应用程序。
