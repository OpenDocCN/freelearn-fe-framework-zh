- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Building a Logo Interpreter
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Logo解释器
- en: Logo is a programming environment created in the 1960s. It was, for many decades,
    a popular way to teach children how to code—I have fond memories of writing Logo
    programs back in high school. At its core, it is a method for building graphics
    via imperative instructions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Logo是在20世纪60年代创建的一个编程环境。在许多十年里，它是教授孩子们如何编码的一种流行方式——我对高中时编写Logo程序的记忆犹新。其核心，它是一种通过命令式指令构建图形的方法。
- en: In this part of the book, we’ll build an application called **Spec Logo**. The
    starting point is an already-functioning interpreter and a barebones UI. In the
    following chapters, we’ll bolt on additional features to this codebase.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，我们将构建一个名为**Spec Logo**的应用程序。起点是一个已经可以工作的解释器和基本的UI。在接下来的章节中，我们将向这个代码库添加更多功能。
- en: 'This chapter provides a second opportunity to test-drive Redux. It covers the
    following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了第二次测试Redux的机会。它涵盖了以下主题：
- en: Studying the **Spec Logo** user interface
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究Spec Logo用户界面
- en: Undoing and redoing user actions in Redux
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Redux中撤销和重做用户操作
- en: Saving to local storage via Redux middleware
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Redux中间件将数据保存到本地存储
- en: Changing keyboard focus
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改键盘焦点
- en: By the end of the chapter, you’ll have learned how to test-drive complex Redux
    reducers and middleware.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何测试驱动复杂的Redux reducer和中间件。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter can be found here:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：
- en: '[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter14](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter14)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter14](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter14)'
- en: Studying the Spec Logo user interface
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 研究Spec Logo用户界面
- en: 'The interface has two panes: the left pane is the drawing pane, which is where
    the output from the Logo script appears. On the right side is a prompt where the
    user can edit instructions:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 界面有两个面板：左侧面板是绘图面板，这是Logo脚本输出出现的地方。右侧是一个提示框，用户可以在此编辑指令：
- en: '![Figure 14.1: The Spec Logo interface ](img/Figure_14.01_B18423.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1：Spec Logo界面](img/Figure_14.01_B18423.jpg)'
- en: 'Figure 14.1: The Spec Logo interface'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1：Spec Logo界面
- en: 'Look at the screenshot. You can see the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下截图。你可以看到以下内容：
- en: The **script name** in the top-left corner. This is a text field that the user
    can click on to change the name of the current script.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左上角的**脚本名称**。这是一个用户可以点击以更改当前脚本名称的文本字段。
- en: The **display**, which shows script output on the left-hand side of the page.
    You can see a shape has been drawn here, which is the result of the Logo statements
    entered at the prompt.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示区域**，它显示脚本输出在页面左侧。你可以看到这里绘制了一个形状，这是在提示框中输入的Logo语句的结果。'
- en: The **turtle**, shown in the middle of the screen. This is a little green triangle
    that marks where drawing commands originate. The turtle has an *x* and *y* position,
    starting at *0,0*, which is the middle of the screen. The viewable drawing is
    600x600 in size, and the turtle can move throughout this area. The turtle also
    has an angle, initially zero, which is pointing directly right.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕中间的**海龟**。这是一个标记绘图命令起点的绿色三角形。海龟有一个*x*和*y*位置，起始位置为*0,0*，这是屏幕的中间。可见的绘图大小为600x600，海龟可以在这个区域内移动。海龟还有一个角度，初始为零，指向正右方。
- en: The **prompt** in the bottom right-hand corner, marked with a **>** symbol.
    This is where you enter your statements, which can be multiline. Hitting *Enter*
    will send the current prompt text to the interpreter. If it makes a complete statement,
    it will be executed, and the prompt cleared ready for your next statement.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右下角的**提示框**，标记为**>**符号。这是你输入语句的地方，可以是多行的。按下*Enter*键将当前提示文本发送到解释器。如果它是一个完整的语句，它将被执行，并且提示框将被清除，以便输入下一个语句。
- en: The **statement history** above the prompt. It lists all the previously executed
    statements. Each is given a number so you can refer back to the statement.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上方提示框中的**语句历史**。它列出了所有之前执行过的语句。每个语句都有一个编号，这样你可以回溯到相应的语句。
- en: A **menu bar** in the top-right corner, containing **Undo**, **Redo**, and **Reset**
    buttons. It is this menu bar that we’ll be building out in this chapter.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右上角的**菜单栏**，包含**撤销**、**重做**和**重置**按钮。我们将在本章中构建这个菜单栏。
- en: 'Although we won’t be writing any Logo code in this chapter, it’s worth spending
    some time playing around and making your own drawings with the interpreter. Here’s
    a list of instructions that you can use:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们本章不会编写任何 Logo 代码，但花些时间在解释器上玩耍并制作自己的绘图是值得的。以下是一份您可以使用的指令列表：
- en: '![](img/B18423_Table_14.1.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18423_Table_14.1.jpg)'
- en: It’s also worth looking through the codebase. The `src/parser.js` file and the
    `src/language` directory contain the Logo interpreter. There are also corresponding
    test files in the test directory. We won’t be modifying these files, but you may
    be interested in seeing how this functionality has been tested.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一看的是代码库。`src/parser.js` 文件和 `src/language` 目录包含 Logo 解释器。测试目录中也有相应的测试文件。我们不会修改这些文件，但您可能对查看此功能是如何被测试的感兴趣。
- en: There is a single Redux reducer in `src/reducers/script.js`. Its `defaultState`
    definition neatly encapsulates everything needed to represent the execution of
    a Logo program. Almost all the app’s React components use this state in some way.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/reducers/script.js` 中有一个单独的 Redux reducer。它的 `defaultState` 定义巧妙地封装了表示
    Logo 程序执行所需的一切。几乎所有的 React 组件都以某种方式使用这个状态。
- en: 'In this chapter, we’ll be adding two more reducers into this directory: one
    for undo/redo and one for prompt focus. We’ll be making modifications to three
    React components: `MenuButtons`, `Prompt`, and `ScriptName`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向该目录添加两个额外的 reducer：一个用于撤销/重做，另一个用于提示焦点。我们还将对三个 React 组件进行修改：`MenuButtons`、`Prompt`
    和 `ScriptName`。
- en: Let’s start by building a new reducer, named `withUndoRedo`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构建一个新的 reducer 开始，命名为 `withUndoRedo`。
- en: Undoing and redoing user actions in Redux
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Redux 中撤销和重做用户操作
- en: 'In this section, we’ll add undo and redo buttons at the top of the page, which
    allow the user to undo and redo statements that they’ve previously run. They’ll
    work like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在页面顶部添加撤销和重做按钮，允许用户撤销和重做他们之前运行的语句。它们的工作方式如下：
- en: Initially, both buttons will be disabled.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始时，两个按钮都将被禁用。
- en: Once the user executes a statement, the **Undo** button will become enabled.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦用户执行了一个语句，**撤销**按钮将变为可用。
- en: When the user clicks the **Undo** button, the last statement will be undone.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户点击**撤销**按钮时，最后一个语句将被撤销。
- en: At that point, the **Redo** button becomes available, and the user can choose
    to redo the last statement.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，**重做**按钮变为可用，用户可以选择重做最后一个语句。
- en: Multiple actions can be undone and then redone, in sequence.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以按顺序撤销和重做多个操作。
- en: If the user performs a new action while **Redo** is available, the redo sequence
    is cleared, and the **Redo** button becomes unavailable again.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户在**重做**可用时执行新的操作，重做序列将被清除，**重做**按钮再次不可用。
- en: 'Aside from adding button elements, the work involved here is building a new
    reducer, `withUndoRedo`, which will *decorate* the script reducer. This reducer
    will return the same state as the script reducer, but with two additional properties:
    `canUndo` and `canRedo`. In addition, the reducer stores `past` and `future` arrays
    within it that record the past and future states. These will never be returned
    to the user, just stored, and will replace the current state should the user choose
    to undo or redo.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了添加按钮元素外，这里的工作涉及构建一个新的 reducer，名为 `withUndoRedo`，它将**装饰**脚本 reducer。这个 reducer
    将返回与脚本 reducer 相同的状态，但有两个额外的属性：`canUndo` 和 `canRedo`。此外，reducer 在其中存储 `past` 和
    `future` 数组，记录过去和未来的状态。这些将不会被返回给用户，只是存储，如果用户选择撤销或重做，将替换当前状态。
- en: Building the reducer
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 reducer
- en: 'The reducer will be a higher-order function that, when called with an existing
    reducer, returns a new reducer that returns the state we’re expecting. In our
    production code, we’ll replace this store code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 reducer 将是一个高阶函数，当与现有的 reducer 一起调用时，返回一个新的 reducer，该 reducer 返回我们期望的状态。在我们的生产代码中，我们将用以下
    store 代码替换它：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We’ll replace it with this decorated reducer, which takes exactly the same
    reducer and wraps it in the `withUndoRedo` reducer that we’ll build in this section:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用这个装饰过的 reducer 来替换它，这个 reducer 完全相同的 reducer，并用我们将在本节中构建的 `withUndoRedo`
    reducer 包装：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To test this, we’ll need to use a spy to act in place of the script reducer,
    which we’ll call `decoratedReducerSpy`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个，我们需要使用一个间谍来代替脚本 reducer，我们将称之为 `decoratedReducerSpy`。
- en: Setting the initial state
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置初始状态
- en: 'Let’s make a start by building the reducer itself, before adding buttons to
    exercise the new functionality:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构建 reducer 本身开始，然后再添加按钮来练习新功能：
- en: 'Create a new file named `test/reducers/withUndoRedo.test.js` and add the following
    setup and test, which specifies what should happen when we pass an undefined state
    to the reducer. This is equivalent to how we began testing our other reducers,
    but in this case, we pass the call through to the decorated reducer. The test
    passes an `undefined` state to the reducer, which is the required mechanism for
    initializing a reducer:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `test/reducers/withUndoRedo.test.js` 的新文件，并添加以下设置和测试，该测试指定了当我们向reducer传递一个未定义的状态时应该发生什么。这相当于我们开始测试其他reducer的方式，但在这个情况下，我们将调用传递给装饰reducer。测试将一个
    `undefined` 状态传递给reducer，这是初始化reducer所需机制：
- en: '[PRE2]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a new `src/reducers/withUndoRedo.js` file and make the test pass with
    the following code:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `src/reducers/withUndoRedo.js` 的新文件，并使用以下代码使测试通过：
- en: '[PRE3]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the next test to the `describe` block, as shown. This uses the `toMatchObject`
    matcher, which we first encountered in [*Chapter 6*](B18423_06.xhtml#_idTextAnchor099),
    *Exploring Test Doubles*:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下所示将下一个测试添加到 `describe` 块中。这使用了我们在 [*第6章*](B18423_06.xhtml#_idTextAnchor099)
    中首次遇到的 `toMatchObject` 匹配器，*探索测试替身*：
- en: '[PRE4]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Make that pass by adding the `return` keyword:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加 `return` 关键字来使测试通过：
- en: '[PRE5]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Initially, both `canUndo` and `canRedo` should be `false`, as there are no
    previous or future states that we can move to. Let’s add those two tests as a
    pair, still in the same `describe` block:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始时，`canUndo` 和 `canRedo` 都应该是 `false`，因为没有可以移动到的前一个或未来状态。让我们将这两个测试作为一对添加，仍然在同一
    `describe` 块中：
- en: '[PRE6]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To make these tests pass, we need to create a new object with those properties
    added:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这些测试通过，我们需要创建一个新的对象，并添加以下属性：
- en: '[PRE7]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s move on to the meat of the reducer. After performing an action, we want
    to be able to perform an `present` and `future` constants to denote those states:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续到reducer的核心部分。在执行一个动作之后，我们希望能够执行 `present` 和 `future` 常量来表示那些状态：
- en: '[PRE8]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Make that pass with the following code. Since we’re no longer dealing with
    an undefined state, this is the moment that we need to wrap our existing code
    in a conditional block:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码使测试通过。由于我们不再处理未定义的状态，这是我们需要将现有代码包裹在条件块中的时刻：
- en: '[PRE9]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we make sure we call the reducer again since, for this new block, it
    won’t happen. Write the following test:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们确保再次调用reducer，因为对于这个新块，它不会发生。编写以下测试：
- en: '[PRE10]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To make that pass, simply call the reducer before the `return` value:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使测试通过，只需在 `return` 值之前调用reducer：
- en: '[PRE11]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The next test shows that this object also needs to return the new state:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个测试显示这个对象还需要返回新的状态：
- en: '[PRE12]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Make that pass by saving the reducer value in a variable named `newPresent`
    and returning it as part of the returned object:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将reducer值保存在名为 `newPresent` 的变量中，并将其作为返回对象的一部分返回来使测试通过：
- en: '[PRE13]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The script reducer holds a special value named `nextInstructionId`. We can
    use this to determine whether the script instruction was processed or whether
    an error occurred. When a statement is valid, it is executed and `nextInstructionId`
    is incremented. But when a statement can’t be processed, `nextInstructionId` remains
    the same. We can use that fact to avoid saving history if a statement contains
    an error. To do that, modify the `present` and `future` constants to include this
    parameter, and add the new test, as shown next:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本reducer持有一个名为 `nextInstructionId` 的特殊值。我们可以使用这个值来确定脚本指令是否被处理，或者是否发生了错误。当一条语句有效时，它将被执行，`nextInstructionId`
    将递增。但是当一条语句无法被处理时，`nextInstructionId` 保持不变。我们可以使用这个事实来避免在语句包含错误时保存历史记录。为此，修改 `present`
    和 `future` 常量以包含此参数，并添加新的测试，如下所示：
- en: '[PRE14]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Make that pass by wrapping our new `return` block in a conditional, and returning
    the old state if the condition doesn’t pass:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将我们的新 `return` 块包裹在条件语句中，并在条件不满足时返回旧状态来使测试通过：
- en: '[PRE15]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This covers all the functionality for performing any actions *other than* **Undo**
    and **Redo**. The next section covers **Undo**.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了执行任何动作的所有功能，除了**撤销**和**重做**。下一节将介绍**撤销**。
- en: Handling the undo action
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理撤销动作
- en: 'We’ll create a new Redux action, of type `UNDO`, which causes us to push the
    current state into a new array called `past`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的Redux动作，类型为 `UNDO`，这将导致我们将当前状态推入一个新的数组 `past` 中：
- en: 'For this test, we can reuse the `present` and `innerAction` properties, so
    push those up into the outer `describe` block now. Also, define a new `undoAction`
    Redux action. We’ll use it within our first test:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个测试，我们可以重用 `present` 和 `innerAction` 属性，所以现在将它们推送到外部的 `describe` 块中。同时，定义一个新的
    `undoAction` Redux动作。我们将在第一个测试中使用它：
- en: '[PRE16]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add a new nested `describe` block with the following test and setup. The `beforeEach`
    block sets up a scenario where we’ve already performed an action that will have
    stored a previous state. We’re then ready to undo it within the test:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的嵌套`describe`块，包含以下测试和设置。`beforeEach`块设置了一个场景，其中我们已经执行了一个将存储先前状态的行动。然后我们就可以在测试中撤销它：
- en: '[PRE17]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Performing an action within a beforeEach block
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`beforeEach`块内执行操作
- en: Notice the call to the `reducer` function in the `beforeEach` setup. This function
    is the function under test, so it could be considered part of the `reducer` is
    part of the test setup, since all these tests rely on having performed at least
    one action that can then be undone. In this way, we can consider this `reducer`
    call to be part of the **Assert** phase.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`beforeEach`设置中对`reducer`函数的调用。这个函数是我们要测试的函数，因此可以认为它是`reducer`测试设置的一部分，因为所有这些测试都依赖于至少执行了一个可以撤销的操作。这样，我们可以将这个`reducer`调用视为**断言**阶段的一部分。
- en: 'Make that pass by modifying the function as follows. We use a `past` variable
    to store the previous state. If we receive an `UNDO` action, we return that value.
    We also use a `switch` statement since we’ll be adding a case for `REDO` later:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下方式修改函数以使测试通过。我们使用一个`past`变量来存储先前状态。如果我们收到一个`UNDO`操作，我们返回该值。我们还使用`switch`语句，因为我们稍后会添加一个`REDO`的情况：
- en: '[PRE18]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, let’s adjust this so that we can undo any number of levels deep. Add
    the next test:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们调整它，以便我们可以撤销任意深度的操作。添加下一个测试：
- en: '[PRE19]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For this, we’ll need to upgrade `past` to an array:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这一点，我们需要将`past`升级为一个数组：
- en: '[PRE20]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There’s one final test we need to do. We need to check that after undoing,
    we can also redo:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要进行一个最后的测试。我们需要检查在撤销之后，我们也可以重做：
- en: '[PRE21]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To make that pass, return a new object comprised of `lastEntry` and the new
    `canRedo` property:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个测试通过，返回一个由`lastEntry`和新的`canRedo`属性组成的新对象：
- en: '[PRE22]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That’s all there is to the `UNDO` action. Next, let’s add the `REDO` action.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`UNDO`操作的全部内容。接下来，让我们添加`REDO`操作。
- en: Handling the redo action
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理重做操作
- en: 'Redo is very similar to undo, just reversed:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 重做与撤销非常相似，只是顺序相反：
- en: 'First, add a new definition for the Redux action of type `REDO`, in the top-level
    `describe` block:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在顶级`describe`块中添加一个Redux操作类型`REDO`的新定义：
- en: '[PRE23]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Underneath the undo `describe` block, add the following redo `describe` block
    with the first test. Be careful with the setup for the spy; the call is `mockReturnValueOnce`
    here, not `mockReturnValue`. The test needs to ensure it takes its value from
    the stored `redo` state:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在撤销`describe`块下方，添加以下重做`describe`块和第一个测试。注意间谍的设置；这里的调用是`mockReturnValueOnce`，而不是`mockReturnValue`。测试需要确保它从存储的`redo`状态中获取其值：
- en: '[PRE24]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To make this pass, in your production code, declare a `future` variable, next
    to the declaration for `past`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个测试通过，在你的生产代码中，声明一个`future`变量，紧挨着`past`的声明：
- en: '[PRE25]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Set this within the `UNDO` action:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UNDO`操作中设置此值：
- en: '[PRE26]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that it’s saved, we can handle the `REDO` action. Add the following `case`
    statement, between the `UNDO` clause and the `default` clause:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在它已经保存，我们可以处理`REDO`操作。在`UNDO`子句和`default`子句之间添加以下`case`语句：
- en: '[PRE27]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The next test is for multiple levels of redo. This is slightly more complicated
    than the same case in the `undo` block—we’ll have to modify the `beforeEach` block
    to take us back *twice*. First, pull out the `futureFuture` value from the undo
    test and bring it into the outer scope, next to the other values, just below `future`:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个测试是针对多级重做的。这比`undo`块中的相同情况稍微复杂一些——我们需要修改`beforeEach`块，使其回退两次。首先，从撤销测试中提取`futureFuture`值并将其带入外部作用域，紧挨着其他值，位于`future`下方：
- en: '[PRE28]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, update `beforeEach` to take two steps forward and then two back:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新`beforeEach`以向前移动两步然后后退两步：
- en: '[PRE29]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, add the test:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加以下测试：
- en: '[PRE30]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To make this pass, start by initializing the `future` variable to be an empty
    array:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个测试通过，首先初始化`future`变量为一个空数组：
- en: '[PRE31]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Update the `UNDO` clause to push the current value to it:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`UNDO`子句以将当前值推入其中：
- en: '[PRE32]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Update the `REDO` clause to pull out that value we just pushed. After this
    change, the test should be passing:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`REDO`子句以提取我们刚刚推入的值。在此更改之后，测试应该通过：
- en: '[PRE33]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There’s one final test we need to write for our barebones implementation, which
    checks that a redo followed by an undo brings us back to the original state:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的基础实现，我们需要编写一个最后的测试，该测试检查重做操作后跟一个撤销操作能否带我们回到原始状态：
- en: '[PRE34]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Make that pass by setting the `past` property in the `REDO` case:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过设置`REDO`情况中的`past`属性来使测试通过：
- en: '[PRE35]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This completes our reducer. However, our implementation has a memory leak! We
    never clear out the `future` array when we generate new states. If the user repeatedly
    hit `future` but become inaccessible, due to `canRedo` being `false` in the latest
    state.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这完成了我们的reducer。然而，我们的实现存在内存泄漏！当我们生成新状态时，我们从未清除`future`数组。如果用户反复点击`future`但变得不可访问，这是由于最新状态中的`canRedo`为`false`。
- en: 'To test for this scenario, you can simulate the sequence and check that you
    expect to return `undefined`. This test isn’t *great* in that we really shouldn’t
    be sending a `REDO` action when `canRedo` returns `false`, but that’s what our
    test ends up doing:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个场景，你可以模拟序列并检查你期望返回`undefined`。这个测试并不*很好*，因为我们实际上不应该在`canRedo`返回`false`时发送`REDO`动作，但我们的测试最终就是这样做的：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To make that pass, simply clear `future` when setting a new state, as shown:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成这个操作，只需在设置新状态时清除`future`，如下所示：
- en: '[PRE37]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We are now done with the reducer. To finish this off, hook it into our Redux
    store. Open `src/store.js` and make the following changes:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经完成了reducer。为了完成这个任务，将其连接到我们的Redux存储。打开`src/store.js`并做出以下更改：
- en: '[PRE38]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Your tests should all be passing and the app should still run.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您的所有测试都应该通过，并且应用程序仍然可以运行。
- en: However, the undo and redo functionality is still not accessible. For that,
    we need to add some buttons to the menu bar.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，撤销和重做功能仍然不可访问。为此，我们需要在菜单栏中添加一些按钮。
- en: Building buttons
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建按钮
- en: 'The final piece to this puzzle is adding buttons to trigger the new behavior
    by adding **Undo** and **Redo** buttons to the menu bar:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个谜题的最后一部分是添加按钮来触发新的行为，通过在菜单栏中添加**撤销**和**重做**按钮：
- en: 'Open `test/MenuButtons.test.js` and add the following `describe` block at the
    bottom of the file, nested inside the `MenuButtons` `describe` block. It uses
    a couple of helper functions that have already been defined with the `renderWithStore`
    file and button:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`test/MenuButtons.test.js`并在文件的底部添加以下`describe`块，嵌套在`MenuButtons` `describe`块内部。它使用了一些已经通过`renderWithStore`文件和按钮定义的辅助函数：
- en: '[PRE39]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Make that pass by modifying the implementation for `MenuButtons` as shown,
    in the `src/MenuButtons.js` file:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过修改`src/MenuButtons.js`文件中的`MenuButtons`实现来执行这个操作，如下所示：
- en: '[PRE40]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add the next test, which checks that the button is initially disabled:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加下一个测试，该测试检查按钮最初是禁用的：
- en: '[PRE41]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Make that pass by adding a hardcoded `disabled` attribute, as shown:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加硬编码的`disabled`属性来执行这个操作，如下所示：
- en: '[PRE42]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we add in the code that will require us to connect with Redux:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们添加代码，这将需要我们连接到Redux：
- en: '[PRE43]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Modify `MenuButtons` to pull out `canUndo` from the store. It already uses
    the `script` state for the **Reset** button behavior, so in this case, we just
    need to destructure it further:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`MenuButtons`以从存储中提取`canUndo`。它已经使用`script`状态来处理**重置**按钮的行为，因此在这种情况下，我们只需要进一步解构它：
- en: '[PRE44]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The final test for the `UNDO` action when it is clicked:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当点击`UNDO`动作时的最终测试：
- en: '[PRE45]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Make that pass by adding the lines highlighted next. We add the new `undo`
    action helper and then use that to call `dispatch`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加下面突出显示的行来完成这个操作。我们添加了新的`undo`动作辅助函数，然后使用它来调用`dispatch`：
- en: '[PRE46]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Repeat from *Step 2* to *Step 8* for the `canRedo` property from the script
    state.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从*步骤2*到*步骤8*重复`canRedo`属性从脚本状态。
- en: That’s the last change needed. The undo and redo functionality is now complete.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 需要做的最后一个更改。撤销和重做功能现在已完成。
- en: Next up, we’ll move from building a Redux reducer to building Redux middleware.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从构建Redux reducer转移到构建Redux中间件。
- en: Saving to local storage via Redux middleware
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Redux中间件将数据保存到本地存储
- en: In this section, we’ll update our app to save the current state to *local storage*,
    a persistent data store managed by the user’s web browser. We’ll do that by way
    of Redux middleware.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更新我们的应用程序，将当前状态保存到*本地存储*，这是一个由用户的网络浏览器管理的持久数据存储。我们将通过Redux中间件来实现这一点。
- en: Each time a statement is executed in the `LocalStorage` API. When the user next
    opens the app, the tokens will be read and replayed through the parser.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 每当在`LocalStorage` API中执行一个语句时。当用户下次打开应用程序时，这些令牌将被读取并通过解析器重新播放。
- en: The parseTokens function
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseTokens`函数'
- en: As a reminder, the parser (in `src/parser.js`) has a `parseTokens` function.
    This is the function we’ll call from within our middleware, and in this section,
    we’ll build tests to assert that we’ve called this function.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，解析器（在`src/parser.js`中）有一个`parseTokens`函数。这是我们将在中间件内部调用的函数，在本节中，我们将构建测试来断言我们已调用此函数。
- en: 'We’ll write a new piece of Redux middleware for the task. The middleware will
    pull out two pieces of the script state: `name` and `parsedTokens`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这个任务编写一个新的 Redux 中间件。该中间件将提取脚本状态中的两个部分：`name` 和 `parsedTokens`。
- en: 'Before we begin, let’s review the browser `LocalStorage` API:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们回顾一下浏览器的 `LocalStorage` API：
- en: '`window.localStorage.getItem(key)` returns the value of an item in local storage.
    The value stored is a string, so if it’s a serialized object, then we need to
    call `JSON.parse` to deserialize it. The function returns `null` if no value exists
    for the given key.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window.localStorage.getItem(key)` 返回本地存储中一个项的值。存储的值是一个字符串，因此如果它是一个序列化对象，那么我们需要调用
    `JSON.parse` 来反序列化它。如果给定键没有值，函数返回 `null`。'
- en: '`window.localStorage.setItem(key, value)` sets the value of an item. The value
    is serialized as a string, so we need to make sure to call `JSON.stringify` on
    any objects before we pass them in here.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window.localStorage.setItem(key, value)` 设置一个项的值。该值被序列化为字符串，因此我们需要确保在传递之前对任何对象调用
    `JSON.stringify`。'
- en: Building middleware
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建中间件
- en: 'Let’s test-drive our middleware:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试驱动我们的中间件：
- en: 'Create the `src/middleware` and `test/middleware` directories, and then open
    the `test/middleware/localStorage.test.js` file. To make a start, define two spies,
    `getItemSpy` and `setItemSpy`, which will make up the new object. We have to use
    `Object.defineProperty` to set these spies because the `window.localStorage` property
    is write protected:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `src/middleware` 和 `test/middleware` 目录，然后打开 `test/middleware/localStorage.test.js`
    文件。为了开始，定义两个间谍函数，`getItemSpy` 和 `setItemSpy`，它们将组成新的对象。我们必须使用 `Object.defineProperty`
    来设置这些间谍函数，因为 `window.localStorage` 属性是只写的：
- en: '[PRE47]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let’s write our first test for the middleware. This test simply asserts that
    the middleware does what all middleware should, which is to call `next(action)`.
    Redux middleware functions have complicated semantics, being functions that return
    functions that return functions, but our tests will make short work of that:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为中间件编写第一个测试。这个测试简单地断言中间件做了所有中间件都应该做的事情，即调用 `next(action)`。Redux 中间件函数具有复杂的语义，是返回函数的函数，但我们的测试将轻松处理这一点：
- en: '[PRE48]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To make that pass, create the `src/middleware/localStorage.js` file and add
    the following definition:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使其通过，创建 `src/middleware/localStorage.js` 文件并添加以下定义：
- en: '[PRE49]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The next test checks that we return that value:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个测试检查我们是否返回该值：
- en: '[PRE50]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Update the `save` function to return that value:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `save` 函数以返回该值：
- en: '[PRE51]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, check that we add the stringified value to local storage:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，检查我们是否将字符串化的值添加到本地存储中：
- en: '[PRE52]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To make that pass, complete the implementation of the `save` middleware:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使其通过，完成 `save` 中间件的实现：
- en: '[PRE53]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let’s move on to the `load` function, which isn’t middleware but there’s no
    harm in placing it in the same file. Create a new `describe` block with the following
    test, ensuring `import` is updated as well:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续到 `load` 函数，它不是中间件，但将其放在同一文件中并无害。创建一个新的 `describe` 块，包含以下测试，并确保更新 `import`：
- en: '[PRE54]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Make that pass by defining a new function in the production code, by adding
    `load`, just below the definition of `save`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 `save` 的定义下方添加 `load` 函数来使该操作通过，在生成代码中定义一个新的函数：
- en: '[PRE55]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now to send this data to the parser. For this, we’ll need a `parserSpy` spy
    function that we use to spy on the parser’s `parseTokens` function:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在要将这些数据发送到解析器。为此，我们需要一个 `parserSpy` 间谍函数，我们使用它来监视解析器的 `parseTokens` 函数：
- en: '[PRE56]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Add the following production code to make that pass:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下生成代码以使其通过：
- en: '[PRE57]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The next test makes sure the data is returned in the right format:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个测试确保数据以正确的格式返回：
- en: '[PRE58]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Make that pass by returning an object with the parsed response:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过返回一个包含解析响应的对象来使其通过：
- en: '[PRE59]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Next, let’s add the name to that data structure:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们将名称添加到该数据结构中：
- en: '[PRE60]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To make that pass, first, we need to save the name that’s returned from local
    storage, and then we need to insert it into the `present` object:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使其通过，首先，我们需要保存从本地存储返回的名称，然后将其插入到 `present` 对象中：
- en: '[PRE61]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, we need to deal with the case where no state has been saved yet. The
    `LocalStorage` API gives us `null` back in that case, but we’d like to return
    `undefined`, which will trigger Redux to use the default state. Add this test
    to the outer `describe` block, so that it won’t pick up the extra `getItemSpy`
    mock values:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要处理尚未保存任何状态的情况。在这种情况下，`LocalStorage` API 返回 `null`，但我们希望返回 `undefined`，这将触发
    Redux 使用默认状态。将此测试添加到外部的 `describe` 块中，这样它就不会拾取额外的 `getItemSpy` 模拟值：
- en: '[PRE62]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Make that pass by wrapping the `return` statement in an `if` statement:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将 `return` 语句包裹在 `if` 语句中来使其通过：
- en: '[PRE63]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Open `src/store.js` and modify it to include the new middleware. I’m defining
    a new function, `configureStoreWithLocalStorage`, so that our tests can continue
    using `configureStore` without interacting with local storage:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/store.js`并修改它以包含新的中间件。我正在定义一个新的函数`configureStoreWithLocalStorage`，这样我们的测试就可以继续使用`configureStore`而不与本地存储交互：
- en: '[PRE64]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Open `src/index.js` and replace the call to `configureStore` with a call to
    `configureStoreWithLocalStorage`. You’ll also need to update `import` for this
    new function:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/index.js`并将对`configureStore`的调用替换为对`configureStoreWithLocalStorage`的调用。你还需要更新`import`以使用这个新函数：
- en: '[PRE65]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: That’s it. If you like, this is a great time to run the app for a manual test
    and try it. Open the browser window, type a few commands, and try it out!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。如果你愿意的话，这是一个运行手动测试和尝试应用的好时机。打开浏览器窗口，输入几个命令，然后试试看！
- en: 'If you’re stuck for commands to run a manual test, you can use these:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道要运行手动测试的命令，可以使用以下命令：
- en: '[PRE66]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: These commands exercise most of the functionality within the interpreter and
    display. They’ll come in handy in [*Chapter 15*](B18423_15.xhtml#_idTextAnchor306),
    *Adding Animation*, when you’ll want to be manually testing as you make changes.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令在解释器和显示中的大多数功能都会得到锻炼。当你在[*第15章*](B18423_15.xhtml#_idTextAnchor306)“添加动画”中进行手动测试时，它们会很有用。
- en: You’ve learned how to test-drive Redux middleware. For the final part of the
    chapter, we will write another reducer, this time one that helps us manipulate
    the browser’s keyboard focus.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何测试驱动Redux中间件。对于本章的最后一部分，我们将编写另一个reducer，这次是一个帮助我们操作浏览器键盘焦点的reducer。
- en: Changing keyboard focus
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变键盘焦点
- en: The user of our application will, most of the time, be typing in the prompt
    at the bottom right of the screen. To help them out, we’ll move the keyboard focus
    to the prompt when the app is launched. We should also do this when another element—such
    as the name text field or the menu buttons—has been used but has finished its
    job. Then, the focus should revert back to the prompt, ready for another instruction.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的用户，大多数时候，会在屏幕右下角的提示框中输入。为了帮助他们，当应用启动时，我们将键盘焦点移动到提示框。当另一个元素——例如名称文本框或菜单按钮——被使用并完成其工作后，我们也应该这样做。然后，焦点应该回到提示框，准备接收下一个指令。
- en: React doesn’t support setting focus, so we need to use a **React ref** on our
    components and then drop it into the DOM API.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: React不支持设置焦点，因此我们需要在我们的组件上使用一个**React ref**，然后将其放入DOM API中。
- en: 'We’ll do this via a Redux reducer. It will have two actions: `PROMPT_FOCUS_REQUEST`
    and `PROMPT_HAS_FOCUSED`. Any of the React components in our application will
    be able to dispatch the first action. The `Prompt` component will listen for it
    and then dispatch the second, once it has focused.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过Redux reducer来实现这一点。它将有两个动作：`PROMPT_FOCUS_REQUEST`和`PROMPT_HAS_FOCUSED`。我们应用程序中的任何React组件都可以发出第一个动作。`Prompt`组件将监听它，并在它聚焦后发出第二个动作。
- en: Writing the reducer
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写reducer
- en: 'We’ll start, as ever, with the reducer:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像往常一样，从reducer开始：
- en: 'Create a new file named `test/reducers/environment.test.js` and add the following
    `describe` block. This covers the basic case of the reducer needing to return
    the default state when `undefined` is passed to it:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`test/reducers/environment.test.js`的新文件，并添加以下`describe`块。这涵盖了reducer在接收到`undefined`时需要返回默认状态的基本情况：
- en: '[PRE67]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Make the test pass with the following code, in a file named `src/reducers/environment.js`.
    Since we’ve built reducers before, we know where we’re going with this one:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码使测试通过，在一个名为`src/reducers/environment.js`的文件中。由于我们之前已经构建过reducer，我们知道这次的目标在哪里：
- en: '[PRE68]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Add the next test, which checks that we set the `promptFocusRequest` value:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加下一个测试，该测试检查我们是否设置了`promptFocusRequest`值：
- en: '[PRE69]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Make that pass by adding in a `switch` statement, as shown:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加一个`switch`语句使其通过，如下所示：
- en: '[PRE70]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Add the final test for this reducer:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这个reducer添加最后的测试：
- en: '[PRE71]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Finally, make that pass by adding another `case` statement:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过添加另一个`case`语句使其通过：
- en: '[PRE72]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Before we can use the new reducer in our tests, we’ll need to add it to the
    store. Open up `src/store.js` and modify it as follows:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以在测试中使用新的reducer之前，我们需要将其添加到存储中。打开`src/store.js`并按以下方式修改：
- en: '[PRE73]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: That gives us a new reducer that’s hooked into the Redux store. Now, let’s make
    use of that.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个新的reducer，它已经连接到Redux存储。现在，让我们利用它。
- en: Focusing the prompt
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 焦点提示
- en: 'Let’s move on to the most difficult part of this: focusing the actual prompt.
    For this, we’ll need to introduce a React ref:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到这部分最困难的部分：聚焦实际的提示。为此，我们需要引入一个React ref：
- en: 'Open `test/Prompt.test.js` and add the following `describe` block at the bottom,
    nested within the `Prompt` `describe` block. The test uses the `document.activeElement`
    property, which is the element that currently has focus. It’s also using the `renderInTableWithStore`
    function, which is the same as the `renderWithStore` helper you’ve seen already,
    except that the component is first wrapped in a table:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `test/Prompt.test.js` 并在 `Prompt` `describe` 块底部添加以下 `describe` 块。测试使用 `document.activeElement`
    属性，它是当前具有焦点的元素。它还使用 `renderInTableWithStore` 函数，它与您已经看到的 `renderWithStore` 辅助函数相同，只是组件首先被包裹在一个表格中：
- en: '[PRE74]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Let’s make that pass. We define a new ref using the `useRef` hook and add a
    `useEffect` hook to focus when the component mounts. Make sure to pull out the
    new constants from the React constant, which is at the top of the file:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过这个。我们使用 `useRef` 钩子定义一个新的引用，并添加一个 `useEffect` 钩子以在组件挂载时聚焦。确保从 React 常量中提取新的常量，该常量位于文件顶部：
- en: '[PRE75]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'For the next test, we’ll dispatch an action to the Redux store. Since this
    test suite hasn’t yet got a test that dispatches actions, we’ll need to add all
    the plumbing. Start by importing the `dispatchToStore` function into the test
    suite:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于下一个测试，我们将向 Redux 存储发送一个动作。由于这个测试套件还没有发送动作的测试，我们需要添加所有管道。首先，将 `dispatchToStore`
    函数导入到测试套件中：
- en: '[PRE76]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, we need a new helper function that will clear focus. Because focus will
    be set as soon as the component mounts, we need to unset it again so we can verify
    the behavior of our focus request. Once we have that helper, we can add the next
    test:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要一个新的辅助函数来清除焦点。因为焦点将在组件挂载时立即设置，我们需要再次取消设置，以便我们可以验证我们的焦点请求的行为。一旦我们有了这个辅助函数，我们就可以添加下一个测试：
- en: '[PRE77]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'To make that pass, first, create a new call to `useSelector` to pull out the
    `promptFocusRequest` value from the store:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了通过这个测试，首先，创建一个新的 `useSelector` 调用来从存储中提取 `promptFocusRequest` 值：
- en: '[PRE78]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Then, add a new effect that will run when `promptFocusRequest` changes. This
    uses the ref to call the DOM’s `focus` method on the HTML element:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加一个当 `promptFocusRequest` 发生变化时运行的新效果。这使用引用来调用 DOM 的 `focus` 方法在 HTML 元素上：
- en: '[PRE79]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'For the next test, dispatch an action when the focus has occurred:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于下一个测试，当焦点发生时发送一个动作：
- en: '[PRE80]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'To make that pass, start by adding a new action helper function that we can
    call within the `Prompt` component:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了通过这个测试，首先添加一个新的动作辅助函数，我们可以在 `Prompt` 组件中调用它：
- en: '[PRE81]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Finally, call `promptHasFocused` within the `useEffect` hook:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `useEffect` 钩子中调用 `promptHasFocused`：
- en: '[PRE82]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: There is a slight issue with this last code snippet. The dispatched `PROMPT_HAS_FOCUSED`
    action will set `promptFocusRequest` back to `false`. That then causes the `useEffect`
    hook to run a second time, with the component re-rendering. This is clearly not
    intended, nor is it necessary. However, since it has no discernable effect on
    the user, we can skip fixing it at this time.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个代码片段有一个小问题。发送的 `PROMPT_HAS_FOCUSED` 动作会将 `promptFocusRequest` 设置回 `false`。这会导致
    `useEffect` 钩子再次运行，组件重新渲染。这显然不是预期的，也不是必要的。然而，由于它对用户没有可识别的影响，我们可以暂时跳过修复它。
- en: This completes the `Prompt` component, which now steals focus anytime the `promptFocusRequest`
    variable changes value.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了 `Prompt` 组件，现在每当 `promptFocusRequest` 变量值发生变化时，它都会夺取焦点。
- en: Requesting focus in other components
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在其他组件中请求焦点
- en: 'All that’s left is to call the request action when required. We’ll do this
    for `ScriptName`, but you could also do it for the buttons in the menu bar:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只是当需要时调用请求动作。我们将为 `ScriptName` 做这件事，但你也可以为菜单栏中的按钮做这件事：
- en: 'Open `test/ScriptName.test.js`, find the `describe` block named `when the user
    hits Enter`:, and add the following test:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `test/ScriptName.test.js`，找到名为 `when the user hits Enter` 的 `describe` 块，并添加以下测试：
- en: '[PRE83]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'In `src/ScriptName.js`, modify the component to define an action helper named
    `promptFocusRequest`:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/ScriptName.js` 中，修改组件以定义一个名为 `promptFocusRequest` 的动作辅助器：
- en: '[PRE84]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Call that from within the edit completion handler:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑完成处理程序中调用它：
- en: '[PRE85]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: That’s it! If you build and run now, you’ll see how focus is automatically given
    to the `prompt` textbox, and if you edit the script name (by clicking on it, typing
    something, and then hitting *Enter*), you’ll see that focus returns to the prompt.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！如果你现在构建并运行，你会看到焦点是如何自动赋予 `prompt` 文本框的，如果你编辑脚本名称（通过点击它，输入一些内容，然后按 *Enter*），你会看到焦点返回到提示。
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You should now have a good understanding of test-driving complex Redux reducers
    and middleware.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该对测试驱动复杂的 Redux 红ucer 和中间件有一个很好的理解。
- en: First, we added support undo/redo with a Redux decorator reducer. Then, we built
    Redux middleware to save and load existing states via the browser’s `LocalStorage`
    API. And finally, we looked at how to test-drive changing the browser’s focus.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过Redux装饰器reducer添加了撤销/重做功能。然后，我们构建了Redux中间件，通过浏览器的`LocalStorage` API保存和加载现有状态。最后，我们探讨了如何测试驱动改变浏览器的焦点。
- en: 'In the next chapter, we’ll look at how to test-drive something much more intricate:
    animation.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何测试驱动更复杂的动画。
- en: Further reading
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Wikipedia entry on the Logo programming language:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Logo编程语言的维基百科条目：
- en: '[https://en.wikipedia.org/wiki/Logo_(programming_language)](https://en.wikipedia.org/wiki/Logo_(programming_language))'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Logo_(programming_language)](https://en.wikipedia.org/wiki/Logo_(programming_language))'
