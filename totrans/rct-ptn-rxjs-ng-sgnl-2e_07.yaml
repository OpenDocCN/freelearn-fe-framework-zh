- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sharing Data between Angular Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sharing data between components is a very common use case in web applications.
    Angular provides many approaches for communicating between parent and child components,
    such as the popular `@Input()` and `@Output()` decorator patterns. The `@Input()`
    decorator allows parent components to provide data to their child components,
    while the `@Output()` decorator allows the child component to send data to a parent
    component. That’s great, but when data needs to be shared between components that
    are either deeply nested or not immediately connected, those kinds of techniques
    become less efficient and difficult to maintain.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: So, what’s the best way to share data between sibling components? This is the
    heart of this chapter. We will start by explaining the sharing data requirement,
    before walking through the different steps to implement the reactive pattern for
    sharing data between sibling components in our app. Finally, we will introduce
    Angular’s new Deferrable Views feature to maximize our app’s performance.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Defining the sharing data requirement
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the reactive pattern to share data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging Deferrable Views in Angular 17
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that you have a basic understanding of RxJS.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The source code of this chapter is available at [https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap07](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap07).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Defining the sharing data requirement
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s assume that we have four components – **C1**, **C2**, **C3**, and **C4**
    – that do not have any relationship with each other, and there is information
    – **DATA** – shared between those components:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Shared data between components](img/B21180_07_1.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Shared data between components
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The components can update and consume **DATA** at the same time. But at any
    time during the process, the components should be able to access the last value
    of **DATA**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s make that explanation clearer with a more concrete example.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: In our recipe application, when the user clicks on one recipe, it gets selected,
    but we want all components to have access to the last selected recipe by the user.
    In that case, the selected recipe represents our shared data.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: One of the components that will need access to the selected recipe is the `RecipeDetailsComponent`
    component, as it will display the details of the selected recipe.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Without further ado, in the next section, let’s see how we can make this data
    available to everyone in a reactive way.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the reactive pattern to share data
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular services are powerful and efficient for creating common references to
    share both data and business logic between components. We will combine Angular
    services with Observables – more specifically, `BehaviorSubject` instances – to
    create stateful, reactive services that will allow us to synchronize the state
    efficiently across an entire application. So, in the following subsections, let’s
    explain the steps to implement a reactive pattern to share data between unrelated
    or sibling components.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – Creating a shared service
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will create an Angular service called `SharedDataService` using the
    Angular CLI, as usual under the `src/app/core/services` folder:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Here, we named the service `SharedDataService` for demonstration purposes. While
    it’s true that we already have a service named `RecipesService` that could have
    accommodated the shared data, the purpose of this chapter is to underscore the
    broader concept of data sharing. Therefore, we chose a more generic term. However,
    in your own application, it’s recommended to use specific and descriptive names
    such as `RecipesService` or another name that accurately reflects the role and
    domain of the service. A name that accurately reflects the purpose of your service
    is crucial for clarity and maintainability, especially in a framework such as
    Angular where conventions can guide developers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `SharedDataService` class, we need to create the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'A private `BehaviorSubject` instance called `selectedRecipeSubject` that emits
    the value of the currently selected recipe, which represents the data to be shared:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `selectedRecipeSubject` has `Recipe` as the type and `undefined` as the
    initial value since initially, we don’t have any selected value.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Also, `selectedRecipeSubject` is declared as `private` to ensure that it’s only
    accessible within `SharedDataService`, where it’s defined, protecting it from
    external manipulation. Otherwise, any external process could have access to the
    property and consequently call the next method and change the emissions, which
    is dangerous. This encapsulation is important for maintaining control over the
    state and preventing unintended changes.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A public Observable, named `selectedRecipe$`, extracted from `selectedRecipeSubject`
    to handle data as an Observable:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we used the `asObservable()` method available in the `Subject` type to
    derive a read-only Observable from `selectedRecipeSubject`. This ensures that
    the emissions of `selectedRecipeSubject` are only consumed in read-only mode,
    preventing external processes from altering the `selectedRecipeSubject` value.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A method called `updateSelectedRecipe` that will update the shared data, which
    is the selected recipe:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method only calls `next` on `selectedRecipeSubject` to notify all subscribers
    of the last selected recipe passed as a parameter. The process that updates the
    selected recipe will call this method, which we will discuss in the next step.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This is what the service looks like after putting all the pieces together:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we have prepared the groundwork by creating our shared data service
    and defined the behavior subject that will hold the shared data, let’s see how
    we can update the shared data in the next section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – Updating the last selected recipe
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should update the shared `selectedRecipe` instance when the user clicks
    on one of the recipe cards in the `RecipesListComponent` component. As a reminder,
    here are the recipe cards in our `Recipe` app:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – List of recipes](img/B21180_07_2.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – List of recipes
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to update the shared `selectedRecipe` instance when the user clicks
    on the card, we need to incorporate the `(click)` event output in the `RecipesListComponent`
    HTML template, which triggers the execution of the `editRecipe(recipe)` method.
    This is the HTML code required:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, `(click)` event binding is applied to each card, ensuring that when clicked,
    the `editRecipe(recipe)` method is invoked to update the `selectedRecipe` instance.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'In `RecipesListComponent`, we implement the `editRecipe` method as follows
    :'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `editRecipe` method takes the selected recipe as the input and performs
    two actions:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'It notifies `selectedRecipeSubject` that the value of `selectedRecipe` has
    changed by calling the `updateSelectedRecipe(recipe:Recipe)` method, available
    in `SharedDataService`. So, we should inject the `SharedDataService` service in
    `RecipesListComponent` as follows :'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It displays the details of the recipe by routing to `RecipeDetailsComponent`,
    the standalone component responsible for rendering and displaying the details
    of a recipe. We’ve added a route configuration in the `app-routing-module.ts`
    file as follows :'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At this point, we have put in place the mechanism that updates the value of
    the shared data. Now, all that is left is to listen to the shared data and consume
    it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – Consuming the last selected recipe
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `RecipeDetails` component, we need to consume the last selected recipe
    in order to display its details. So, again, we need to inject `SharedDataService`
    and define the `selectedRecipe$` Observable – which will emit the last selected
    recipe – as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we will subscribe to the `selectedRecipe$` Observable using the `async`
    pipe in the `RecipeDetailsComponent` HTML template in order to display the selected
    recipe’s details, as follows :'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: And that’s it – this is how you can share data between unrelated components
    throughout the application!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use the latest value of the recipe everywhere – we only have to
    inject `SharedDataService` into the component that needs the shared data and subscribe
    to the public Observable that emits the read-only value. For example, we can add
    this code in `HeaderComponent` to display the title of the last selected recipe
    in the application’s header:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If we change the shared value in this component, all other components that listen
    to the shared data will get notified to update their processes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: We used this pattern in [*Chapter 5*](B21180_05.xhtml#_idTextAnchor083), *Combining
    Streams*, to share the value of the filter in `RecipesFilterComponent` with `RecipesListComponent`
    instances, and then we combined the streams to display the filtered results.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up the data-sharing reactive pattern
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To summarize everything, here’s a wrap-up of the steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Begin by creating an Angular service that will be shared across components.
    Within this service, define a private `BehaviorSubject` instance that will emit
    the shared value to its subscribers, remembering to specify the type of data emitted
    by `BehaviorSubject` and initialize it with the initial value of the shared data.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s important to note that we use `BehaviorSubject` for two primary reasons:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It allows us to broadcast shared data to multiple observers.
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It stores the latest value emitted to its observers, and any new subscriber
    immediately receives the last emitted value upon subscription.
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, define a public Observable within the shared service to hold the read-only
    shared value.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement an `update` method within the shared service to update the shared
    value by calling the `next` method of the `Subject` type to emit the updated value
    to subscribers.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inject the shared service in the component responsible for updating the value
    of the shared data and call the `update` method implemented in the service.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inject the shared service in the component that consumes the value of the shared
    data and subscribe to the exposed Observable in the service.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This reactive sharing data pattern has many benefits:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: It improves the sharing of data between unrelated components.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It manages mutability risk. In fact, as we only expose the read-only extracted
    Observable to other consumers and keep `BehaviorSubject` private, we prevent shared
    data from being modified by subscribers, which can lead to data corruption and
    unexpected behavior.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes communication between components easier as you will only have to inject
    the shared service where you need it and just take care of updating the data.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As far as I’m concerned, this is the simplest way to share data between unrelated
    components in Angular and manage the application state. This works perfectly in
    many situations, but for big applications where there are a lot of user interactions
    and multiple data sources, managing states in services can become complicated.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'In those cases, we can use a state management library to manage the state of
    our application. There are many great state management libraries out there to
    manage states in Angular, all with one thing in common – they are built on top
    of RxJS Observables, and the state is stored in `BehaviorSubject`. The most popular
    state management library is NgRx, which you can find out more about here: [https://ngrx.io/guide/store](https://ngrx.io/guide/store).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Data-sharing mechanisms facilitate communication between different components
    and improve the user experience, as well as the responsiveness of your application.
    Before ending this chapter, I want to shed light on a new feature introduced in
    Angular 17, Deferrable Views, which can complement data sharing and contribute
    to creating more responsive and efficient applications. Let’s see this in action
    in the next section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging Deferrable Views in Angular 17
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Deferrable Views** allow you to declaratively mark parts of your templates
    as non-essential for immediate rendering. It is kind like delaying the rendering
    of certain parts of a page to improve the perceived performance of your application,
    as well as optimize the initial bundle size and loading times.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of real-world scenarios where defer rendering can help to
    achieve faster load times such as e-commerce product pages – in this example,
    you can initially display the essential product details and then lazy load additional
    content such as reviews when the user clicks on a **Read more** button or scrolls
    down the page.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s quickly see how this works. To lazy load a component, you need to use
    a Standalone component, otherwise deferring won’t work. Then you want to wrap
    up the Standalone component in a `@defer` block, like so:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can also define conditions for when exactly the deferred component should
    load. You can do this by using **triggers**, which specify events or situations
    that initiate loading:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, the `on viewport` trigger is used to display the `delayed-component` when
    it enters the viewport area of the user’s browser window.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides `on viewport`, there are other triggers that can be used such as `on
    hover`, which only initiates the content to load when the user’s mouse hovers
    over the delayed content. You can find a full list of available triggers here:
    [https://angular.dev/guide/defer#triggers](https://angular.dev/guide/defer#triggers).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, the `@defer` block has some important sub-blocks. For example,
    you can display alternative content before the deferred content loads using the
    `@placeholder` sub-block, like so:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In addition to `@placeholder`, `@defer` also offers two other sub-blocks –
    `@loading` and `@``error` :'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: The `@loading` block is similar to the `@placeholder` block, but it specifically
    shows content like a loading message while the actual content is being prepared.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@error` block is displayed if there is an error while fetching or processing
    the deferred content. This allows you to provide a user-friendly error message,
    or alternative content, in case something goes wrong.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let’s look at how we can utilize defer rending in our Recipe app. Given
    that the images for each recipe have a high resolution, let’s delay the rendering
    of the images in `RecipesListComponent` HTML template so that they are only shown
    when the user hovers over the image:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, we surrounded the code block displaying the image with a `@defer`
    block, and used the `on hover` trigger. Then we used the `@placeholder` block
    to specify some text that should be displayed while the deferred content is not
    yet loaded. In this case, inside the <div> element, we added the text, **Hover
    to load** **the image**.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们在显示图像的代码块周围使用了`@defer`块，并使用了`on hover`触发器。然后我们使用`@placeholder`块指定一些在延迟内容尚未加载时应显示的文本。在这种情况下，我们在`<div>`元素中添加了文本，**悬停以加载**
    **图像**。
- en: For more details about the Deferrable Views feature, refer to [https://angular.dev/guide/image-optimization](https://angular.dev/guide/image-optimization).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有关可延迟视图功能的更多详细信息，请参阅[https://angular.dev/guide/image-optimization](https://angular.dev/guide/image-optimization)。
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explained the motivation behind sharing data between components
    and learned how to implement it in a reactive way. First, we learned how we can
    use `BehaviorSubject` combined with Angular services to share data between unrelated
    components and manage our application state. Then, we highlighted the advantages
    of the sharing data reactive pattern. Finally, we explored Angular’s new Deferrable
    Views feature.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们解释了组件间共享数据的动机，并学习了如何以反应式的方式实现它。首先，我们学习了如何结合Angular服务使用`BehaviorSubject`在无关组件之间共享数据并管理我们的应用程序状态。然后，我们强调了共享数据反应模式的优点。最后，我们探讨了Angular的新可延迟视图功能。
- en: The features covered in this chapter will help you implement a good architecture
    for your web application, making it more reactive and performant, improving load
    times, and reducing the cost of maintainability.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的特性将帮助您为您的Web应用程序实现一个良好的架构，使其更具反应性和性能，提高加载时间，并降低维护成本。
- en: Now, get ready for an exciting journey, because in the next chapter, we delve
    into a brand-new feature called Angular Signals! We’ll cover some reactive patterns
    using Signals and even integrate them into what we’ve learned so far.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，准备好开始一段激动人心的旅程，因为在下一章中，我们将深入探讨一个全新的功能，称为Angular信号！我们将介绍一些使用信号的反应模式，并将它们整合到我们迄今为止所学的内容中。
- en: 'Part 3: The Power of Angular Signals'
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：Angular信号的强大之处
- en: Dive into the exciting world of Angular Signals!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 沉浸在激动人心的Angular信号世界中！
- en: In this section, you will discover the core functionalities and advantages of
    Angular Signals, as well as unlock the potential of reactivity by leveraging Angular
    Signals and RxJS together. We will also go through the latest Angular Signals
    improvements.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将发现Angular信号的核心功能和优势，以及通过利用Angular信号和RxJS一起解锁反应性的潜力。我们还将介绍最新的Angular信号改进。
- en: 'This part includes the following chapter:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 8*](B21180_08.xhtml#_idTextAnchor119), *Mastering Reactivity with
    Angular Signals*'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B21180_08.xhtml#_idTextAnchor119)，*使用Angular信号掌握反应性*'
