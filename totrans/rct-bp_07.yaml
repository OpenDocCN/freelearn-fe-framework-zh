- en: Chapter 7. Reactagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll apply the skills we've developed in the previous chapters
    and assemble a social web app based around photos. The app will be usable on desktop
    browsers as well as native phones and tablets.
  prefs: []
  type: TYPE_NORMAL
- en: We'll explore an alternative to the Flux architecture in this chapter by connecting
    to a real-time database solution called **Firebase**. We'll create a higher order
    function that we'll implement as a singleton wrapped around our routes. This setup
    will enable us to provide our users with real-time streaming as well as the *like*
    functionality in our app while still adhering to the principle of *one-way data
    flow*.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also explore another cloud-based service called **Cloudinary**. It's a
    cloud service for uploading and hosting images. It's a pay service, but has a
    generous free tier that will suffice our needs. We'll make an upload service in
    our Express server that will handle image uploading, and we'll also explore image
    manipulation in canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the topics that we''ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the web camera API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing photo input to an HTML5 canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying an image filter by manipulating canvas pixels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to Firebase and uploading images to the cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing a stream of all the submitted photos in real time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-time comments and likes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start by using the Webpack scaffold we developed in [Chapter 6](ch06.html
    "Chapter 6. Advanced React"), *Advanced React*. These are the dependencies we
    need to install from `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We'll use the same setup as in the previous chapter, but we'll make some minor
    changes to `server.js`, add a few lines to `index.html`, and add some content
    to our CSS file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the tree structure in our original Webpack scaffold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It's worth making sure that your structure is identical to this one.
  prefs: []
  type: TYPE_NORMAL
- en: We'll need to make a few modifications to our `server.js` file. We're going
    to set up an upload service that we will access from our app, so it needs support
    for Cross-Origin Resource Sharing (CORS) and a POST route in addition to our normal
    GET routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `server.js` and replace the content with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Our app needs the `body-parser` package in order to access the request data
    in our POST route. We''re going to be sending images to our route, so we also
    need to make sure that the data limit is higher than the default value. Refer
    to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This `POST` call will handle image uploads in our app. It will send the image
    to Cloudinary and store it for later retrieval in our image stream. You will have
    to create an account at [http://cloudinary.com/](http://cloudinary.com/) and replace
    the API credentials we just saw with the real credentials in your user administration
    section. The following is the major change we''re making:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes sure that any request to any file that''s not part of the static
    `asset` folder will be routed to `index.html`. This is important because it will
    allow us to access dynamic routes using the history API instead of using hashed
    routes, let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open `assets/index.html` and replace the contents with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We're going to rely on Bootstrap for our grid layout, so we need to add the
    Bootstrap CSS files. We're also going to add the free Bitter font family as our
    main font for the app.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we'll change is `app.css`. We'll add a set of styles that'll
    make sure the app we're building is functional on the Web as well as on tablets
    and smartphones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `app.css` and replace the content with this styling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This applies the `Bitter` font as the main font for our app and adds a top
    margin for our navigation header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `hidden` class will be applied to all the elements that should stay hidden
    and out of sight. Now check out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is our only `media` query. It will make sure the canvas stays in a centered
    and fixed position on small smartphones. The height and width of `imageCanvas`
    will be overwritten when the user uploads images, so these values are only defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the code to set the left and right menu buttons in our header.
    They''ll be our navigation elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Check out the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is about the **Filter** buttons. They will be displayed after the images
    have been captured but before they are sent to the app, let''s take a look at
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to reuse the `spinner` from the earlier chapters. This will be
    displayed while the user is uploading images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The basic setup of our app is now complete, and you can run it by issuing this
    command in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see Webpack compile your app, and when ready, log this information
    in your terminal window (with a different hash and millisecond count of course):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You'll also need to register accounts at Firebase and Cloudinary. Both services
    are free for development use. You can register an account with Firebase by visiting
    [https://www.firebase.com/](https://www.firebase.com/) and registering a database
    name to use when developing this app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how the app will look on an iPhone once we''re
    done writing the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started](img/B04943_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting up the routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start this app by setting up the router configuration in the root of our
    app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `index.jsx` and replace the contents with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that we reference two files that we haven't created yet, so let's
    go ahead and add them to our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `config.js` in the root of the `source` folder and then add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace `YOURAPP` with the name of your registered Firebase app, let''s take
    a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create `routes.jsx` and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re importing a number of components that we haven''t created yet.
    We''ll proceed by creating the components one by one, starting with `FBConnect`.
    This component is special because it''s a higher order component that will make
    sure that the components it wraps will be provided with a correct state. It works
    much in the same way as Redux, which we explored in [Chapter 6](ch06.html "Chapter 6. Advanced
    React"), *Advanced React*. Now add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: After you've added this code, Webpack will throw a number of errors and the
    app will show a red error screen in the browser. We'll need to add all of the
    components we'll use before the app is usable again, and as you add them, you'll
    see that the error log will gradually diminish until the app is ready to be displayed
    properly again.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a higher order function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A higher order function is a function that takes one or more functions as arguments
    and returns a function as its result. All other functions are first-order functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using higher order functions is a brilliant way to extend your composition-making
    skills and an easy way to make complex apps easier. It complements the use of
    mixins, which is another way of providing inheritance in your components.
  prefs: []
  type: TYPE_NORMAL
- en: The function we'll create is a higher order component with mixins. It will connect
    to Firebase by using the configuration we provide in `config.js` and make sure
    the stateful data we rely on is kept in sync in real time. That's a tall order,
    but by using Firebase, we'll unload much of the heavy lifting needed to provide
    this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: As you've seen earlier, we'll use this function to wrap our routed components
    and provide them with a state in the form of props.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `fbconnect.jsx` in the root of your `source` folder and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will fetch the contents of your image stream and store them in `this.state.imageStream`.
    The state will be available to all wrapped components in `this.props.imageStream`.
    We''ll be setting it so that it''s ordered by the timestamp value. Refer to the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we return the component passed to this function along with the state
    from Firebase and a set of stateful functions in `FBFunc`, such as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Sorting with Firebase**'
  prefs: []
  type: TYPE_NORMAL
- en: Firebase will always return data in ascending order, which means that newer
    pictures will be inserted at the bottom. If you want to sort by descending order,
    replace the `bindAsArray` function with a custom loop and then reverse the array
    before you store it with `setState()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need to create a file that will hold the functions you''ll use
    to add content to the image stream. Create a file called `fbfunc.js` in the root
    of your project and enter this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will store new images with an image URL to Cloudinary, the username,
    a timestamp, and zero likes. The following is our `like` functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, every press on like will add a `+1` like(s) to the image it''s
    attached to. You could extend the functionality to prevent the current user from
    voting on their own images and also prevent them from voting more than once. Now
    refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `comment` functionality will be visible in `item.jsx`, which is a page
    displaying a single photo. This function will store a new comment, along with
    the username of the submitter along with a timestamp. Now we move on to the two
    `helper` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: These functions will let you either remove a single item or clear the entire
    database. The latter one is especially useful for debugging but very dangerous
    to keep around if you go live with the app.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a random username
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to separate the different images coming in, you need to give the users
    a name. We'll do this in a very simple manner, so please refer to [Chapter 6](ch06.html
    "Chapter 6. Advanced React"), *Advanced React*, for details on how to implement
    a more secure login solution.
  prefs: []
  type: TYPE_NORMAL
- en: The way we're going to do this is by simply picking one word from a list of
    adjectives and another from a list of nouns and composing a username from both.
    We'll store the names in `localStorage` and generate a new one if we are unable
    to find an existing one.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Local storage**'
  prefs: []
  type: TYPE_NORMAL
- en: All of the major browsers now support `localStorage`, but if you're planning
    on supporting older browsers, especially Internet Explorer, it might be wise to
    look into polyfills. A good discussion on polyfilling `localStorage` can be found
    at [https://gist.github.com/juliocesar/926500](https://gist.github.com/juliocesar/926500).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our `username` function. Create a file called `username.js` and
    put it in the `tools` folder. Add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The number of adjectives and nouns has been cut for brevity, but go ahead and
    add more words to add a touch of variety to your usernames.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting usernames will be a variation of the following: *autumn-breeze*,
    *misty-dawn*, and *empty-smoke*.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to explore name and sentence generation in more depth, I urge you
    to take a look at [https://www.npmjs.com/package/rantjs](https://www.npmjs.com/package/rantjs).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need the file that actually implements this functionality and sets
    the desired username. This is `userinfo.js`, which is referenced in `fbconnect.js`.
    Add the file to your `root` folder and then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This file is a mixin and will extend `getInitialState` and `componentDidMount`
    in `fbconnect` with a username state variable, and it will create a username and
    store it in `localStorage` if none exist.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a welcome screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create an app header and a welcome screen. We'll do this in two different
    files, `app.jsx` and `welcome.jsx`, which we'll place in the `components` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `components/app.jsx` and then add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `goBack()` function will send you back to the correct page depending on
    your current location. If you''re viewing a single item, you''ll be taken back
    to the stream if you press **Go Back**. If you''re on the stream, you''ll be taken
    to the front page, let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'These two styles will prevent the links from being displayed when there''s
    no need for them to be visible. The **Back** button will only be visible when
    you''re not on the front page, and the the photo button will be hidden if you''re
    on the photo page. Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we add a Bootstrap grid with a fixed navigation bar. This makes
    sure that the navigation bar is always present. The code block `{ this.props.children
    }` makes sure that any React.js components are rendered within the grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create `components/welcome.jsx` and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We'll use the built-in `push` functionality in `react-router` to transition
    our users to the desired location. The URL will be `http://localhost:8080/stream`
    or `http://localhost:8080/camera`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that the routes are non-hashed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We bind the route argument to the `historyPush` function as a handy way to
    transition our users on click. The first argument is the context, but since we
    don''t need it, we assign it to `null`. The second is the route we want the user
    to be transitioned to. Let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the application will look in the browser after you''ve added the
    preceding code. Note that the links won''t work at this point because we haven''t
    made the components yet. We''ll get to them shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a welcome screen](img/B04943_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Taking a picture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll be using the camera API to take pictures for our image app. Through this
    interface, it is possible to take pictures with a native camera device as well
    as select pictures to upload them through a web page.
  prefs: []
  type: TYPE_NORMAL
- en: The API is set up by adding an input element with `type="file"` and an `accept`
    attribute to declare to our component that it accepts images.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ReactJS JSX looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When a user activates the element, they are presented with an option to choose
    a file or take a picture with the built-in camera (if available). The user must
    accept the picture before it's sent to the `<input type="file">` element, and
    its `onchange` event is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a reference to the picture, you can render it to an image element
    or a canvas element. We'll do the latter, as rendering to canvas opens up a lot
    of possibilities for manipulating an image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `camera.jsx` and put it in the `components` folder.
    Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Leave this commented out until we add the code for this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ImageToCanvas` module contains a lot of code that was originally written
    for this chapter, but since it consists of a lot of camera- and canvas-specific
    code, it was a bit too niche to include. Take a look at the code in the GitHub
    repository if you want to delve more into the canvas code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll use this state variable to switch between showing the input field or
    the captured image. When an image is captured, this state is set to `true`. Consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As illustrated in the code, we''ll hide the canvas until we''ve got some content
    to show. The spinner should only be visible while the user is uploading an image.
    Refer to the helper functions in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'These functions will be useful when rendering the final image to the user.
    Now check this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This function takes care of all the canvas-handling logic that we'll need to
    display an image with proper ratios. Our default is 4:3 (portrait pictures), and
    we'll scale the images down to approximately 400 pixels in height and 300 pixels
    in width. The reduced image size will result in quality degradation, but it will
    make image processing faster and reduce the file size, resulting in a faster upload
    speed and better user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'This does mean that square pictures or photos in landscape mode will appear
    squished. This function could thus be extended to look for horizontally placed
    square or rectangular photos so that they could be scaled properly, let''s take
    a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Cameras on native devices will take pictures with different orientations. Unless
    we adjust this, we''ll end up with images rotated left, right, or upside down,
    let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If we can''t get the `exif` information, we''ll default the orientation to
    `1`, meaning no transformation is needed, let''s take a look at the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll set up three different filters: `grayscale`, `threshold`, and `brightness`.
    We''ll go more into the filters when we add `filters.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user saves an image, we''ll turn down the opacity of the entire page
    and display the loading spinner, as illustrated in the last part of the preceding
    code, let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'When the image is uploaded to **Cloudinary**, we''ll store the result in Firebase
    using the `uploadImage` function from `fbfunc.js`. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `classNames` function provides an easy interface to toggle classes
    on our HTML nodes, let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now be able to click on the camera button and take a picture with
    your camera phone or select an image from your hard drive if you''re working on
    a desktop computer. The following screenshot shows an image from the desktop selected
    with the file browser using the camera button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Taking a picture](img/B04943_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The filters won't work yet, but we're going to add them now. Once we've done
    this, remove the comments from the `import` function in `camera.jsx`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've set up a few filter buttons for manipulating the image after it's been
    captured from the image uploader, but we're yet to set up the actual filter functions.
  prefs: []
  type: TYPE_NORMAL
- en: You apply filters to the images by reading the canvas pixels, modifying them,
    and then writing them back to the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by fetching the image pixels. This is how you do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In `camera.jsx`, we''ll pass the results of `getImageData` as an argument to
    the `filter` function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have the pixels, you can loop through them and apply your modifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the complete grayscale filter. Add a file called `filters.js`
    and put it in the `tools` folder. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We fetch the values for `red`, `green`, and `blue` separately and then apply
    the RGB to the Luma conversion formula, which is a set of weights that will deemphasize
    color information and produce a grayscale image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We then replace the original color value with the new, monochromatic color
    value, let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This filter makes the pixels brighter by simply increasing the RGB values.
    It''s similar to setting the color values of a font in CSS to `#eeeeee (R: 238
    G: 238 B: 238)` from `#999 (R: 153 G: 153 B: 153)`. Now we move on to threshold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, threshold is applied by comparing the grayscale value of a
    pixel with the threshold value. Once this is done, set the color to either black
    or white, let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This is a very basic set of filters, and you can easily create more by tuning
    the values. You can also check out [https://github.com/kig/canvasfilters](https://github.com/kig/canvasfilters)
    for a good set of filters to add, including blur, sobel, blend, luminance, and
    invert.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a picture with brightness and threshold applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding filters](img/B04943_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding the stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's now time to add the `stream` functionality. It's very simple because the
    data stream is already available through `fbconnect.js`, so all we have to do
    is map through the stream data and render the HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `stream.jsx` in your `components` folder and add this
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'A user can click on like as many times as they want, and the counter will be
    updated every time. The like counter is transaction-based, so if two or more users
    click on the like button at the same time, the operation will be queued until
    all likes have been counted, let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `try…catch` block will prevent blank sections from appearing (or the app
    from throwing an error), in case a user has unwittingly uploaded a broken image
    (or due to some error, the image upload failed). If an error is caught, this will
    be logged to the console and the image will simply not be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: One of the many benefits of using a service like Cloudinary is that you can
    request a different version of your image file and have it delivered without having
    to do any work on our end.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we request a cropped image with a height of 300, weighted at the center.
    This makes sure that the images we return on this page are uniform in height,
    though the width may vary by a few pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cloudinary has a wealth of options, and you could conceivably use it for filtering
    the images instead of doing it in JavaScript. You can make changes to the app
    such that whenever the user captures an image, you could send it to Cloudinary
    before further processing. All filters could then be applied by adding filters
    to the image URL provided by Cloudinary, let''s take a look at the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: If images are added, or the like count is updated, the changes will immediately
    be visible in the stream. Try opening the app on a device and a browser window
    or two browser windows at the same time, and you'll notice that any changes made
    will be synchronized in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an item page and adding comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you click on any of the pictures in the stream, you'll be taken to the item
    page. We don't need to set up a new query for this because we already have everything
    we need to display it. We'll get the item key from the router and apply a filter
    to the image stream, and we'll end up with a single item.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, notice that the comment section has been added
    and that two random users have added some comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an item page and adding comments](img/B04943_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a new file called `item.jsx` in the `components` folder and add this
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `renderStream()` function is almost identical to the one we created for
    `stream.jsx`, except that we''ve removed the link here and added a way to display
    and add comments. Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: First we grab the comment identifiers by using `Object.keys()`, which returns
    an array of keys. Then, we map through this array to find and render each individual
    comment to HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also take the timestamp and convert it to a human-readable date by using
    the international date formatter. Further, we used the en-US locale in this example,
    but you can easily swap it with any locale. Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we render an input field and a submit button with an `onclick` handler
    to the `addComment()` function in `fbfunc.js`. Finally, we return to the `render()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: As illustrated, we get the key from the router parameters and apply a filter
    to the image stream so that we're left with an array containing just the single
    item we want from the stream data.
  prefs: []
  type: TYPE_NORMAL
- en: We then apply a `map` function to the array, fetch the image, and call the `renderStream()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to add the `padding` file we imported at the top of `item.jsx`, so
    create a file called `pad.js` in the `tools` folder and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: It will transform 1 to 01 and so on, but will not do anything with 10, 11, or
    12\. So it's safe to use whenever you want to add left padding to a string.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your social-photo-sharing app is now ready for action. It should now compile
    fully and work without problems on desktop browsers and native smartphones and
    tablets.
  prefs: []
  type: TYPE_NORMAL
- en: Working with images and canvas can be a bit tricky when it comes to native devices.
    The file size of a photo often becomes a problem because many smartphones have
    very little memory to work with, so you may often run into problems rendering
    canvas images.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the reasons we're working with downscaled images in this app.
    The other is of course to make it faster when transmitting photos to the cloud.
    Both of these problems are very real but can more or less be classified as corner
    cases, so I'm leaving this up to you, should you go ahead and develop the app
    further.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see the app deployed on an iPad:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wrapping up](img/B04943_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the final file structure of the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: It's a very concise file structure for an app that already is quite capable.
    You could argue that the `config` files and the Firebase files could be put in
    a folder of their own, and you wouldn't find me disagreeing.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, the way you organize your files is often down to personal preference.
    Some may like having all JavaScript files in a single folder, while others prefer
    to sort them by functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The finished project can be viewed online at [http://reactjsblueprints-chapter7.herokuapp.com](http://reactjsblueprints-chapter7.herokuapp.com).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use the camera/filereader API using the
    HTML5 canvas and how to manipulate images by modifying the pixels. You connected
    to Firebase and Cloudinary, both popular cloud-based tools that help you as a
    developer to work on your apps rather than your infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: You also experienced that by using a tool such as Firebase, you can completely
    avoid using Flux. It's not a common architecture, but it's worth knowing that
    it's at least possible to go down this route.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, you made a real-time social photo app that you can easily extend
    further and mark with your brand.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at how you could develop isomorphic apps with
    ReactJS. An isomorphic app means an app that is pre-rendered on the server, so
    we'll look at techniques to serve up your ReactJS apps even to users who don't
    have JavaScript enabled in their respective browsers.
  prefs: []
  type: TYPE_NORMAL
