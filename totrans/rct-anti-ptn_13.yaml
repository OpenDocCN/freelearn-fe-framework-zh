- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recapping Anti-Pattern Principles
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this short final chapter, we’ll briefly revisit the crucial insights from
    the book and furnish additional resources for you to delve deeper into the realm
    of React and software design.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The primary objective of this book was to unearth common anti-patterns often
    encountered in React code bases, especially within large-scale React applications.
    We delved into potential remedies and techniques to rectify these issues. The
    examples throughout the narrative were drawn either from my prior projects or
    are related to domains with which developers are likely to be familiar – such
    as shopping carts, user profiles, and network requests, to name a few.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: I championed a step-by-step and incremental delivery approach, guiding you from
    an initial, less-than-ideal implementation toward a polished version, making one
    small improvement at a time. We embarked on organizing a typical React application,
    ventured into the realm of frontend testing through **test-driven development**
    (**TDD**), and initiated our journey with common refactoring techniques. Thereafter,
    we navigated the challenging waters of data/state management in React, elucidated
    common design principles, and explored compositional strategies. A slew of chapters
    were dedicated to constructing full examples from scratch, including a drop-down
    list, a shopping cart, and a weather application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: During this expedition, we discovered numerous handy tips, such as how to stub
    network requests in both Cypress and Jest, apply the strategy design pattern to
    a JavaScript model, and employ **Anti-Corruption Layers** (**ACLs**) in real-world
    code scenarios.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: The techniques discussed in this book may not be groundbreaking or novel; indeed,
    many are well established. However, their application in the React ecosystem has
    remained underexplored. I earnestly hope that this book has adeptly bridged that
    gap, reintroducing these invaluable design principles and patterns to the React
    community, thereby facilitating a smoother coding experience for developers in
    the long term.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll revisit the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting common anti-patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skimming through design patterns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revisiting foundational design principles
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recapping techniques and practices
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revisiting common anti-patterns
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We explored numerous anti-patterns in the preceding chapters. Recognizing an
    anti-pattern is the initial step toward rectifying it. Let’s briefly recap what
    we’ve learned thus far.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Props drilling
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Props drilling emerges when a prop traverses through multiple component levels,
    only to be employed in a deeper-level component, rendering intermediate components
    unnecessarily privy to this prop. This practice can lead to convoluted and hard-to-maintain
    code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution*: Employing the Context API to create a central store and functions
    to access this store allows the component tree to access props when needed without
    prop-drilling.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Long props list/big component
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A component that accepts an extensive list of props or harbors a large amount
    of logic can become a behemoth, hard to understand, reuse, or maintain. This anti-pattern
    infringes upon the **Single Responsibility Principle** (**SRP**), which advocates
    that a component or module should only have one reason to change.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution*: Dismantling the component into smaller, more digestible components
    and segregating concerns can ameliorate this issue. Each component should embody
    a clear, singular responsibility. Custom Hooks also serve as a potent means to
    simplify the code within a component and reduce its size.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Business leakage
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Business leakage transpires when business logic is implanted within components
    that should remain purely presentational, which can complicate application management
    and reduce component reusability.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution*: Extricating business logic from presentation logic using custom
    Hooks or relocating the business logic to a separate module or layer can address
    this issue. Employing an ACL can be an effective technique to rectify this issue.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Complicated logic in views
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The embedding of complex logic within view components can muddle the code, making
    it arduous to read, comprehend, and maintain. Views should remain as uncluttered
    as possible, solely responsible for rendering data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution*: Relocating complex logic to custom Hooks, utility functions, or
    a separate business logic layer can help keep view components clean and manageable.
    Initially, breaking down components into smaller ones, and then gradually segregating
    the logic into appropriate places can be beneficial.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Lack of tests (at each level)
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The absence of adequate unit, integration, or end-to-end tests to ascertain
    application functions, as anticipated, can usher in bugs, regressions, and code
    that’s challenging to refactor or extend.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution*: Adopting a robust testing strategy encompassing unit testing, integration
    testing, and end-to-end testing, coupled with practices such as TDD, can ensure
    code correctness and ease of maintenance.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Code duplications
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reiterating similar code across multiple components or sections of the application
    can complicate code-base maintenance and augment the likelihood of bugs.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution*: Adhering to the **Don’t Repeat Yourself** (**DRY**) principle and
    abstracting common functionality into shared utility functions, components, or
    Hooks can help curtail code duplication and enhance code maintainability.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Having dissected common anti-patterns, it’s now imperative to delve into the
    design principles that act as antidotes to these prevalent issues. These principles
    not only provide solutions but also guide you toward writing cleaner, more efficient
    code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Skimming through design patterns
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are effective patterns to counter anti-patterns in React, and interestingly,
    some of these patterns extend beyond the React context, being useful in broader
    scenarios. Let’s swiftly revisit these patterns.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order components
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Higher-order components** (**HOCs**) are a potent pattern in React for reusing
    component logic. HOCs are functions that accept a component and return a new component
    augmented with additional properties or behaviors. By leveraging HOCs, you can
    extract and share common behaviors across your components, aiding in mitigating
    issues such as props drilling and code duplications.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Render props
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **render props** pattern encompasses a technique for sharing code between
    React components using a prop whose value is a function. It’s a method to pass
    a function as a prop to a component, and that function returns a React element.
    This pattern can be instrumental in alleviating issues such as long props lists
    and big components by promoting reuse and composition.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Headless components
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Headless components are those that manage behavior and logic but do not render
    the UI, bestowing the consumer with control over the rendering. They separate
    behavior logic from presentation logic, which can be a viable solution to business
    leakage and complicated logic in views, making components more flexible and maintainable.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Data modeling
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data modeling entails organizing and defining your data, which aids in understanding
    and managing the data within your application, thereby simplifying the logic within
    your components. This principle can be employed to tackle complicated logic in
    views and business logic leakage.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Layered architecture
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Layered architecture involves segregating concerns and organizing code such
    that each layer has a specific responsibility. This separation can lead to a more
    organized and manageable code base, addressing issues such as business leakage
    and complicated logic in views.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, *Figure 13**.1* depicts this layered architecture. In a layered
    architecture, each layer contains numerous modules, each dedicated to specific
    tasks within the overall application. This includes modules for data retrieval
    (the **Fetcher** module, shown in *Figure 13**.1*), adapters to interface with
    external services such as social media logins and payment gateways (the **Adaptor**
    gateway, shown in *Figure 13**.1*), as well as components for analytics and security-related
    functions:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1: Layered architecture in a React application](img/B31103_13_01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: Layered architecture in a React application'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: We conducted a comprehensive case study on this topic in [*Chapter 11*](B21103_11.xhtml#_idTextAnchor286),
    delving deeply into the evolution of the system and pinpointing the appropriate
    circumstances for applying such an architectural style.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Context as an interface
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Utilizing context as an interface allows components to interact with data without
    the need to pass props down multiple levels. This strategy can alleviate props
    drilling and long props lists, rendering the component tree more readable and
    maintainable.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: With a solid grasp of foundational and design principles, it’s time to explore
    techniques that will arm you with the practical knowledge to implement these principles
    in your daily coding endeavors.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting foundational design principles
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides React-specific patterns, we’ve discussed several higher-level design
    principles throughout various chapters. These principles serve as guidelines applicable
    to various aspects of your work, be it React, data modeling, event testing, or
    scripts that facilitate integration. They are not confined to a particular context,
    and embracing them can significantly enhance your coding approach across different
    domains.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Single Responsibility Principle
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SRP advocates that a class or component should only harbor one reason to
    change. Adhering to the SRP can lead to more maintainable and understandable code,
    mitigating issues such as big components and complicated logic in views.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: We’ve explored this principle at various levels, from carving out a smaller
    component from a larger one, to creating a new Hook, and up to significant refactoring
    such as integrating an ACL into a weather application. It’s worth noting that
    whenever you find yourself entangled within a large component, the SRP remains
    your most trustworthy ally.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Inversion Principle
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Dependency Inversion Principle** (**DIP**) emphasizes depending on abstractions,
    not concretions, which leads to a decoupling of high-level and low-level structures.
    This principle can be utilized to manage business logic leakage and promote a
    clean **separation of** **concerns** (**SoC**).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Don't Repeat Yourself
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The DRY principle is about minimizing repetition within code. By adhering to
    the DRY principle, you can minimize code duplication, making your code base easier
    to maintain and extend.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Anti-Corruption Layers
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An ACL serves as a barrier between different parts or layers of an application,
    creating a stable interface. Implementing an ACL can be a potent strategy to manage
    business leakage and ensure a clean SoC.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'An ACL proves to be especially beneficial when your code needs to interact
    with other systems in any capacity, a scenario that often arises when collaborating
    with different teams—a common occurrence in many setups. By establishing a clear
    system boundary through ACL, we can mitigate the impact of changes in other systems
    on our own, thereby maintaining better control over our application and alleviating
    potential integration challenges. *Figure 13**.2* illustrates how an ACL is applied
    in React:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure\uFEFF 13.2: Applying an ACL in React](img/B31103_13_02.jpg)"
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: Applying an ACL in React'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Using composition
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Composition is a core principle in React that empowers developers to build components
    from other components, promoting reuse and simplicity. Employing composition can
    alleviate various issues, including long props lists, big components, and code
    duplications, leading to a more maintainable and organized code base.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Understanding these anti-patterns, design patterns, and principles is crucial
    for managing the complexity of a frontend code base. However, the techniques and
    practices are equally important as they represent the hands-on work developers
    engage in on a daily basis.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Recapping techniques and practices
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have placed significant emphasis on the importance of testing and making
    incremental improvements. This approach not only maintains high code quality but
    also cultivates a well-rounded developer – honing critical thinking skills and
    the ability to focus on solving one problem at a time.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Writing user acceptance tests
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**User acceptance testing** (**UAT**) is a pivotal part of the development
    process that ensures your application aligns with its specifications and functions
    as desired. Implementing UAT can aid in identifying issues early in the development
    process, ensuring your application is on the right trajectory.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'As depicted in *Figure 13**.3*, we emphasize that tests should be written from
    the end user’s perspective, focusing on delivering customer value rather than
    on implementation details. This is especially pertinent when you commence the
    implementation of a feature at a higher level:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: "![F\uFEFFigure 13.3: User acceptance tests](img/B31103_13_03.jpg)"
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.3: User acceptance tests'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Test-Driven Development
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TDD is a software engineering technique where tests are penned before code
    that needs to be tested. The process is primarily segmented into the following
    iterative development cycles: write a test, make the test pass, and then refactor.
    TDD can significantly help in ensuring that your code base is functional and bug-free,
    addressing the lack of tests at each level.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring and common code smells
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refactoring entails enhancing the design of existing code without altering its
    external behavior. Being cognizant of common code smells and continuously refactoring
    your code can lead to a healthier, more maintainable code base. This technique
    can be instrumental in tackling issues such as code duplication, complicated logic
    in views, and business leakage, among others.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve navigated through common anti-patterns, elucidated design principles,
    and explored techniques, it’s time to look beyond this book. The following section
    provides a list of recommended readings that will further deepen your understanding
    and hone your skills in the domain of React, TypeScript, and software design principles.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we draw the curtains on the contents of this book, the journey toward mastering
    React and avoiding common pitfalls is far from over. The landscape of web development,
    particularly with frameworks such as React, is ever-evolving. Continuous learning
    and adaptation are the keystones of staying relevant and proficient.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: The following section is crafted to provide you with additional avenues for
    learning and exploration. These books are meticulously chosen to extend your understanding
    and introduce you to broader or complementary concepts in software development.
    Each book opens up a new dimension of knowledge, ensuring your growth trajectory
    remains steep and rewarding. So, as you step forward from here, let these resources
    be your companions in the continuous journey of learning and mastering the art
    of web development.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'I would like to recommend a few seminal books that can further deepen your
    understanding and appreciation of good design, architecture, and development practices
    in the realm of web applications, with a particular focus on React and TypeScript:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '*Refactoring: Improving the Design of Existing Code* by Martin Fowler'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Martin Fowler’s cornerstone work on refactoring is a repository of knowledge
    on how to enhance the structure of your code while preserving its functionality
    and bug-free nature. It’s a must-read for anyone aspiring to hone their refactoring
    skills.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Clean Code: A Handbook of Agile Software Craftsmanship* by Robert Martin'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Robert Martin’s *Clean Code* is a hallmark in the software development world.
    It delves into various practices and principles of penning clean, maintainable
    code, which is crucial for long-term success in complex projects.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Patterns of Enterprise Application Architecture* by Martin Fowler'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expand your architectural vistas with this book, which dissects various patterns
    crucial for designing robust and scalable enterprise applications. It’s a significant
    read to grasp the bigger picture of application architecture, extending beyond
    the frontend realm.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Test-Driven Development with React and TypeScript* by Juntao Qiu'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immerse yourself in the world of TDD with a focus on React and TypeScript. This
    book navigates you through the principles of TDD and how it can markedly improve
    the quality, maintainability, and robustness of your code.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I want to extend my heartfelt gratitude for your dedication and passion for
    honing your craft and striving for technical excellence. It’s individuals such
    as you, thirsty for knowledge and improvement, that propel our industry forward.
    As you turn over this last page, remember that the journey doesn’t end here; in
    fact, it unfolds a new chapter of exploration and application in your real-world
    projects.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The essence of growth lies in the application and the continuous effort to apply
    what you’ve learned to challenge norms and strive for better solutions. This book
    aims to provide you with a solid foundation, but the real magic happens when you
    take these concepts, experiment with them, and integrate them into your daily
    work.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: I sincerely appreciate your time spent traversing these pages and engaging with
    the material. It’s my earnest wish that you carry forward this momentum, dive
    deeper, and continue to enrich the React community with your contributions. As
    you embark on the next phase of your journey, I wish you the best of luck. May
    your code be clean, your solutions innovative, and your journey rewarding.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我衷心感谢您花时间浏览这些页面并与材料互动。我真诚地希望您能继续保持这种势头，深入研究，并继续通过您的贡献丰富 React 社区。随着您踏上旅程的下一阶段，我祝愿您好运。愿您的代码整洁，您的解决方案创新，您的旅程充满回报。
- en: Thank you, and good luck on your onward journey of continuous learning and improvement!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您，祝您在持续学习和改进的旅程中一切顺利！
