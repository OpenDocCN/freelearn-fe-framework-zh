- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recipes – Master/Detail, Data Tables, and NgRx
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we complete the router-first architecture implementation on
    LemonMart by implementing the top three most used features in business applications:
    master/detail views, data tables, and state management. I will demonstrate data
    tables with server-side pagination, highlighting the integration between the frontend
    and backend using LemonMart and LemonMart Server.'
  prefs: []
  type: TYPE_NORMAL
- en: We will leverage the router orchestration concept to orchestrate how our components
    load data or render. We will then use resolve guards to reduce boilerplate code
    when loading data before navigating to a component. We will use auxiliary routes
    to lay out components through the router configuration and reuse the same component
    in multiple contexts.
  prefs: []
  type: TYPE_NORMAL
- en: We will then dive into NgRx using the LocalCast Weather app and explore NgRx
    Signal Store with LemonMart, so you can become familiar with more advanced application
    architecture concepts in Angular. By the end of this chapter, we will have touched
    upon the major functionality that Angular and Angular Material offer – only the
    good parts, if you will.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers a lot of ground. It is organized in a recipe format, so
    you can quickly refer to a particular implementation when working on your projects.
    I cover the architecture, design, and major components of the implementation and
    highlight important pieces of code to explain how the solution comes together.
    Leveraging what you’ve learned, I expect the reader to fill in routine implementation
    and configuration details. However, you can always refer to the GitHub repo if
    you get stuck.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading data with resolve guard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusing components with binding and route data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Master/detail view using auxiliary routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data tables with pagination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NgRx store and effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NgRx ecosystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a global spinner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring server proxies with the Angular CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most up-to-date versions of the sample code for the book are on GitHub at
    the repository linked in the following list. The repository contains the final
    and completed state of the code. You can verify your progress at the end of this
    chapter by looking for the end-of-chapter snapshot of code under the `projects`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'For *Chapter 9*:'
  prefs: []
  type: TYPE_NORMAL
- en: Be sure that **lemon-mart-server** is up and running. Refer to *Chapter 7*,
    *Working with REST and GraphQL APIs*.
  prefs: []
  type: TYPE_NORMAL
- en: Clone the repositories at [https://github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
    and [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `npm install` on the root folder to install dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The beginning state of the project is reflected at:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The end state of the project is reflected at:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the stage name to any `ng` command to act only on that stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `dist/stage12` folder at the root of the repository will contain
    the compiled result.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 8,* *Recipes – Reusability, Forms, and Caching*, we created a `ViewUserComponent`
    with an `editUser` function. We need this functionality later in the chapter when
    implementing a master/detail view in the system, where a manager can see all users
    in the system and edit them. Before enabling the `editUser` functionality, we
    need to ensure that the `ViewUserComponent` component alongside the `ProfileComponent`
    can load any user given their ID.
  prefs: []
  type: TYPE_NORMAL
- en: In the next couple of sections, we will learn about resolve guards to simplify
    our code and reduce the amount of boilerplate. Let’s start by implementing a resolve
    guard we can use for both components.
  prefs: []
  type: TYPE_NORMAL
- en: Loading data with resolve guard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A resolve guard is a different kind of router guard, as mentioned in *Chapter
    6*, *Implementing Role-Based Navigation*. A resolve guard can load necessary data
    for a component by reading record IDs from `route` parameters, asynchronously
    loading the data, and having it ready when the component activates and initializes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The major advantages of a resolve guard include reusability of the loading
    logic, a reduction of boilerplate code, and the shedding of dependencies because
    the component can receive the data it needs without having to import any service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `user.resolve.ts` class under `user/user`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Similar to the `updateUser` method in `UserService`, we use `map(User.Build)`
    to hydrate the `user` object, so it is ready to be used when a component loads
    data from the `route` snapshot, as we’ll see next.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify `user-routing.module.ts` to add a new path, `profile/:userId`, with
    a route resolver and the `canActivate authGuard`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When combined with an auth guard, the `resolve` function won’t be executed until
    the guard succeeds.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `profile` component to load the data from the `route` if it exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We first check whether a user is present in the `route` snapshot. If so, we
    call `patchUser` to load this user. Otherwise, we fall back to our conditional
    cache-loading logic.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `patchUser` method also sets the `currentUserId` and `nameInitialDate$`
    Observables and calls the `patchUpdateData` base to update the form data.
  prefs: []
  type: TYPE_NORMAL
- en: You can verify that the resolver is working by navigating to the profile with
    your user ID. Using the out-of-the-box settings, this URL will look something
    like `http://localhost:4200/user/profile/5da01751da27cc462d265913`.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing components with binding and route data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let’s refactor the `viewUser` component so that we can reuse it in multiple
    contexts. User information is displayed in two places in the app per the mock-ups
    created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first place is the **Review** step of the user profile that we implemented
    in the previous chapter. The second place is on the user management screen on
    the `/manager/users` route, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_09_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Manager user management mock-up'
  prefs: []
  type: TYPE_NORMAL
- en: To maximize code reuse, we must ensure that our shared `ViewUser` component
    can be used in both contexts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first use case, we bind the current user to the **Review** step of the
    multi-step input form. In the second use case, the component will need to load
    its data using a resolve guard, so we don’t need to implement additional logic
    to achieve our goal:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `viewUser` component to inject the `Router` and `ActivatedRoute`.
    In `ngOnInit` we need to set `currentUser` from the route in and subscribe to
    future route change events to apply updates to the user using a helper function
    `assignUserFromRoute` and unsubscribe from the event in `ngOnDestroy`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ngOnInit` will only fire once when the component is initialized within another
    component or loaded within the router context. If any data for the route has been
    resolved, we update `currentUser`. When the user wants to view another user, a
    new navigation event will occur with a different user ID. Since Angular will reuse
    the component, we must subscribe to router events to react to subsequent user
    changes. In this case, in case of a `NavigationEnd` event, if the route has resolved
    user data, we again update `currentUser`.'
  prefs: []
  type: TYPE_NORMAL
- en: We now have three independent events to update and handle data. Within the parent
    component context, `ngOnChanges` handles updates to the `@Input` value and updates
    `currentUser` if `this.user` has been bound to. The code we added above handles
    the remaining two cases with router context on the first navigation and subsequent
    navigation events.
  prefs: []
  type: TYPE_NORMAL
- en: Since LemonMart is bootstrapped as a standalone application and `viewUser` is
    a standalone component, we can use this component across multiple lazy-loaded
    modules without additional orchestration.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not using standalone components, you must wrap this component inside
    a `SharedComponentsModule` and import that module in your lazy-loaded modules.
    You can find an example implementation in the GitHub history of the project.
  prefs: []
  type: TYPE_NORMAL
- en: With the key pieces in place, let’s begin implementing the master/detail view.
  prefs: []
  type: TYPE_NORMAL
- en: Master/detail view using auxiliary routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The true power of router-first architecture comes to fruition with auxiliary
    routes, where we can influence the layout of components solely through router
    configuration, allowing for rich scenarios where we can remix the existing components
    into different layouts. Auxiliary routes are routes that are independent of each
    other where they can render content in named outlets that have been defined in
    the markup, such as `<router-outlet name="master">` or `<router-outlet name="detail">`.
    Furthermore, auxiliary routes can have their parameters, browser history, children,
    and nested auxiliaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will implement a basic master/detail view using
    auxiliary routes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement a simple component with two named outlets defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a new `userTable` component under `manager`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update `manager-routing.module.ts` to define the auxiliary routes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This means that when a user navigates to `/manager/users`, they’ll see the `UserTableComponent`,
    because it is implemented with the default path.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Provide `UserResolve` in `manager.module.ts` since `viewUser` depends on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement a temporary button in `userTable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `skipLocationChange` directive navigates without pushing a new record into
    history. So, if the user views multiple records and hits the **Back** button,
    they will be taken back to the previous screen instead of having to scroll through
    the records they viewed first.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Imagine that a user clicks on a **View detail** button like the one defined
    previously – then, `ViewUserComponent` will be rendered for the user with the
    given `userId`. In the next screenshot, you can see what the **View Details**
    button will look like after we implement the data table in the next section:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![A screenshot of a phone  Description automatically generated](img/B20960_09_02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 9.2: View Details button'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can have as many combinations as possible and alternative components defined
    for the master and detail, allowing for the infinite possibilities of dynamic
    layouts. However, setting up the `routerLink` can be a frustrating experience.
    Depending on the exact condition, you must either supply or not supply all or
    some outlets in the link.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example, in the preceding scenario, consider this alternative implementation,
    where the master outlet is explicitly defined:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The router will not correctly parse this route and silently fail to load. If
    it is `master: []` it will work. This comes down to how pattern matching happens
    on empty routes; while this makes logical sense in the framework code, it doesn’t
    make intuitive sense for developers using the APIs.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we’ve completed the implementation of the resolve guard for `ViewUserComponent`,
    you can use Chrome DevTools to see the data being loaded correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Before debugging, ensure that the **lemon-mart-server** we created in *Chapter
    7*, *Working with REST and GraphQL APIs*, is running.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In **Chrome DevTools**, set a breakpoint right after `this.currentUser` is assigned,
    as shown:![A screenshot of a computer  Description automatically generated](img/B20960_09_03.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.3: Dev Tools debugging ViewUserComponent'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You will observe that `this.currentUser` is correctly set without any boilerplate
    code for loading data inside the `ngOnInit` function, showing the true benefit
    of a resolve guard. `ViewUserComponent` is the detail view; now, let’s implement
    the master view as a data table with pagination.
  prefs: []
  type: TYPE_NORMAL
- en: Data tables with pagination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created the scaffolding to lay out our master/detail view. In the master
    outlet, we will have a paginated data table of users, so let’s implement `UserTableComponent`,
    which will contain a `MatTableDataSource` property named `dataSource`. We will
    need to be able to fetch user data in bulk using standard pagination controls
    such as `pageSize` and `pagesToSkip` and narrow down the selection further with
    user-provided search text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by adding the necessary functionality to `UserService`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement a new `IUsers` interface to describe the data structure of the paginated
    data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the interface for `UserService` with a `getUsers` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add `getUsers` to `UserService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `sort` direction is indicated by the keywords `asc` for ascending
    and `desc` for descending. When sorting a column in ascending order, we pass the
    column name as a parameter to the server. We prepend the column name with a minus
    sign to sort a column in descending order.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set up `UserTable` with pagination, sorting, and filtering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We define and initialize various properties to support loading paginated data.
    `items$` stores the observable stream that defines what data is displayed on the
    data table. `displayedColumns`, a computed signal, defines the columns for the
    table. To dynamically show or hide columns we can defined a toggle using a signal,
    such as `demoViewDetailsColumn`. Since this signal is referenced within the computed
    signal, when it updates the computed signal will also be updated., which will
    then be reflected on the table. `paginator` and `sort` provide pagination and
    sorting preferences `.search` provides the text we need to filter our results
    by.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`resetPage` helps rewind the pagination to the first page and hide the detail
    view. This is useful after a search, pagination, or sort event, otherwise the
    detail view of a random record will be displayed.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`showDetail` uses the router to display the detail view of a selected record
    in the named outlet `detail`. Later in this section, we will go over a version
    of the same link implemented in the template. I purposefully included both options,
    so you can see how both are implemented.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'I purposefully left the following code commented out in the code base:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I found in certain instances the router may not be able to gracefully close
    an outlet. `OutletCloserService`, found in the `common` folder, can close any
    outlet from any context without fuss.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The reference to the original version by Andrew Scott is at [https://stackblitz.com/edit/close-outlet-from-anywhere](https://stackblitz.com/edit/close-outlet-from-anywhere).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The magic happens in `ngAfterViewInit`. We first subscribe to `sort` and `paginator`
    change events, so we can properly reset the table. Next, we use the `merge` method
    within a `setTimeout` call, as highlighted in the preceding snippet, to listen
    for changes in pagination, sorting, and filter properties that impact what data
    needs to be displayed. If one property changes, the whole pipeline is triggered.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Why is the `setTimeout` necessary? Since we use references to paginator and
    sort extracted from the template, we must use the `ngAfterViewInit` lifecycle
    hook. However, at this point, Angular has already set the `dataSource` property
    for the Material data table component. If we re-assign it with the `merge` operator,
    we’ll get NG0100 `ExpressionChangedAfterItHasBeenCheckedError`. Using `setTimeout`
    pushes the reassignment into the next change detection cycle, avoiding the error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is similar to how we implemented the login routine in `AuthService`. The
    pipeline contains a call to `this.userService.getUsers`, which will retrieve users
    based on the pagination, sorting, and filter preferences passed in. Results are
    then piped into the `this.items$` Observable, which the data table subscribes
    to with an `async` pipe to display the data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There’s no need to subscribe to `this.items$`, because the Material data table
    already subscribes to it internally. If you subscribe, every call to the server
    will be made twice.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: However, you must take care to place the `takeUntilDestroyed` call as the last
    element in the pipe. Otherwise, you could leak subscriptions merged after the
    call.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Read more about it at [https://cartant.medium.com/rxjs-avoiding-takeuntil-leaks-fb5182d047ef](https://cartant.medium.com/rxjs-avoiding-takeuntil-leaks-fb5182d047ef).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import the following modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the CSS for `userTable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The styles below the comment `/* row selection styles */` assist in the material
    ripple effect when individual rows are clicked.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, implement the `userTable` template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the implementation of the `loading-shade` style, which places a spinner
    over the table while loading data. This is an example of a localized spinner.
    Later in the *Implementing a global spinner with NgRx/SignalState section*, I
    cover how we can implement a global version. Most very large applications will
    require a localized spinner to avoid excessive full-screen interruptions caused
    by a global spinner.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We bind `items$` to `dataSource` to activate the Observable. Below, the `mat-icon-button`
    with `[routerLink]="[''../users'', { outlets: { detail: [''user'', { userId: row._id
    }] } }]"` uses the context row variable to assign a URL that will display `ViewUserComponent`
    in the `detail` outlet. `skipLocationChange` ensures that the URL in the browser
    won’t be updated with the outlet information.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that using the relative URL `'../users'` in the `routerLink`, as shown
    above, allows the `UserTableComponent` to be decoupled from the context of the
    manager feature module. This way, the component could be reused under other contexts
    like `/owner/users` or `/ceo/users` instead of being hard coded to `/manager/users`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Setting up the router within lazy-loaded modules and named outlets could be
    error-prone.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can enable the router’s debug mode by modifying the root provider in `app.config.ts`
    by adding the `withDebugTracing` function as shown:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Further on, the `matRipple` directive enables a Material Design ripple when
    a row is clicked. Right after this, we implement the click handlers. By default,
    clicking on a row will display the detail view using the `showDetail` function;
    otherwise, users will click on a view button on the rightmost column.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, observe the click on the refresh button, which causes an update in
    the `refresh$` Observable. This will be picked up by the merge pipeline we implemented
    in the component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With just the master view in place, the table is as shown in the following
    screenshot (make sure you’ve updated to the latest version of Angular):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B20960_09_04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 9.4: User table'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you click on a row, `ViewUserComponent` will get rendered in the detail
    outlet using the `showDetails` function, as shown:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_09_05.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 9.5: Master/detail view with row click'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note how the row is highlighted to indicate selection. If you flip the **Demo
    ‘View Details’ Column** option on the top right, you will unhide the **View Details**
    column.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you click on the **View** icon, `ViewUserComponent` will get rendered in
    the detail outlet using `routerLink` in the template, as shown:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B20960_09_06.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 9.6: Master/detail view icon click'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the previous chapter, we implemented the **Edit** button, represented by
    the pencil icon in the top right, passing the `userId` to the `UserProfile` to
    edit and update the data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the **Edit** button to be taken to the `ProfileComponent`, edit the
    user record, and verify that you can update another user’s record.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirm that you can view the updated user record in the data table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This demonstration of data tables with pagination completes the major functionality
    of LemonMart for this book. Before moving on, make sure all the tests have passed.
  prefs: []
  type: TYPE_NORMAL
- en: For the unit tests, I import concrete implementations of `NameInputComponent`
    or `ViewUserComponent` instead of using the `createComponentMock` function from
    `angular-unit-test-helper`. This is because `createComponentMock` is not sophisticated
    enough to bind data to child components. In the *Further reading* section, I’ve
    included a blog post by Aiko Klostermann that covers testing Angular components
    with `@Input()` properties.
  prefs: []
  type: TYPE_NORMAL
- en: With the heavy lifting of the implementation completed, we can now explore alternative
    architectures, tools, and libraries to better understand the best ways to architect
    Angular apps for various needs. Next, let’s explore NgRx.
  prefs: []
  type: TYPE_NORMAL
- en: NgRx store and effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As covered in *Chapter 1*, *Angular’s Architecture and Concepts*, the NgRx library
    brings reactive state management to Angular based on RxJS. State management with
    NgRx allows developers to write atomic, self-contained, and composable pieces
    of code, creating actions, reducers, and selectors. This kind of reactive programming
    isolates side effects in state changes. NgRx is an abstraction layer over RxJS
    to fit the **Flux pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four major elements of NgRx:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Store**: The central location where state information is persisted. You implement
    a reducer to store a state transition in the store and a selector to read data
    out of the store. These are atomic and composable pieces of code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A view (or user interface) displays data from the store by using a selector.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Action**: Unique events that happen throughout your app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actions are triggered from a view with the purpose of dispatching them to the
    store.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Dispatcher**: This is a method to send actions to the store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducers in the store listen for dispatched actions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Effect**: This is a combination of an action and a dispatcher. Effects are
    usually used for actions that are not triggered from a view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s revisit the following Flux pattern diagram, which now highlights an **Effect**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a system  Description automatically generated](img/B20960_09_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.7: Flux pattern diagram'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s demonstrate how NgRx works by going over a concrete example. To keep it
    simple, we will leverage the LocalCast Weather app.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing NgRx for LocalCast Weather
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will implement NgRx to execute the search functionality in the LocalCast
    Weather app. Consider the following architecture diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a weather forecast  Description automatically generated](img/B20960_09_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.8: LocalCast Weather architecture'
  prefs: []
  type: TYPE_NORMAL
- en: We will use the NgRx store and effects libraries to achieve our implementation.
    NgRx store actions are reflected in the diagram in light gray with a `WeatherLoaded`
    reducer and the app state. At the top, actions are represented as a stream of
    various data objects, either dispatching actions or acting on dispatched actions,
    enabling us to implement the **Flux pattern** introduced in *Chapter 1*, *Angular’s
    Architecture and Concepts*. The NgRx effects library extends the Flux pattern
    by isolating side effects in its model without littering the store with temporary
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The effects workflow, represented in dark gray in *Figure 9.8*, begins with
    *step 1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CitySearchComponent` dispatches the `search` action.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `search` action appears on the Observable `@ngrx/action` stream (or data
    stream).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CurrentWeatherEffects` acts on the `search` action to perform a search.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`WeatherService` performs the search to retrieve current weather information
    from the **OpenWeather API**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Store actions, represented in light gray, begin with *step A* (uppercase A):'
  prefs: []
  type: TYPE_NORMAL
- en: '`CurrentWeatherEffects` dispatches the `weatherLoaded` action.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `weatherLoaded` action appears on the Observable data stream, labeled `@ngrx/action`
    stream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `weatherLoaded` reducer acts on the `weatherLoaded` action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `weatherLoaded` reducer transforms the weather information to be stored
    as the new state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new state is a persisted `search` state, part of the `appStore` state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that there’s a parent-level `appStore` state containing a child `search`
    state. I intentionally retained this setup to demonstrate how the parent-level
    state scales as you add different kinds of data elements to the store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, a view (an Angular component) reads from the store, beginning with
    *step a* (lowercase a):'
  prefs: []
  type: TYPE_NORMAL
- en: The `CurrentWeather` component subscribes to the `selectCurrentWeather` selector
    using the `async` pipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `selectCurrentWeather` selector listens for changes to the `store.search.current`
    property in the `appStore` state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `appStore` state retrieves the persisted data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using an NgRx selector is like writing a query to read data stored in a database.
    The database, in this case, is the store.
  prefs: []
  type: TYPE_NORMAL
- en: Using NgRx, when a user searches for a city, the actions to retrieve, persist,
    and display that information on `CurrentWeatherComponent` happen automatically
    via individual composable and immutable elements.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing BehaviorSubject and NgRx
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will implement NgRx alongside `BehaviorSubject` so you can see the differences
    in implementing the same feature. To do this, we will need a slide toggle to switch
    between the two strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: This section uses the **local-weather-app** repo. You can find the code samples
    for this chapter under the `projects/stage12` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the main app under the `src` folder uses a button toggle to switch
    between `Signals`, `BehaviorSubject`, and `NgRx`.
  prefs: []
  type: TYPE_NORMAL
- en: Start by implementing a `<mat-slide-toggle>` element on `CitySearchComponent`,
    as shown in the following screenshot:![A screenshot of a weather forecast  Description
    automatically generated](img/B20960_09_09.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.9: LocalCast Weather slide toggle'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ensure the field is backed by a property on your component named `useNgRx`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Refactor the `doSearch` method to extract the `BehaviorSubject` code into its
    own function named `behaviorSubjectBasedSearch`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Stub out a function called `ngRxBasedSearch`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will be dispatching an action from the `ngRxBasedSearch` function that you
    just created.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up NgRx
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can add the NgRx Store package with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a `reducers` folder with an `index.ts` file in it. Now add
    the NgRx `effects` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We use the `--minimal` option here to avoid creating unnecessary boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, install the NgRx schematics library so you can take advantage of generators
    to create the boilerplate code for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Implementing NgRx can be confusing due to its highly decoupled nature, which
    may necessitate some insight into the library’s inner workings.
  prefs: []
  type: TYPE_NORMAL
- en: The sample project under `projects/stage12` configures `@ngrx/store-devtools`
    for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to be able to `console.log` NgRx actions for debugging or
    instrumentation during runtime, you can use a MetaReducer as described in the
    NgRx documentation, [https://ngrx.io/guide/store/metareducers](https://ngrx.io/guide/store/metareducers).
  prefs: []
  type: TYPE_NORMAL
- en: Defining NgRx actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can implement effects or reducers, we first need to define the actions
    our app will be able to execute. For LocalCast Weather, there are two types of
    actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`search`: Fetches the current weather for the city or zip code that’s being
    searched'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`weatherLoaded`: Indicates that new current weather information has been fetched'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create an action named `search` by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Take the default options when prompted.
  prefs: []
  type: TYPE_NORMAL
- en: The `--group` option groups actions under a folder named `action`. The `--creators`
    option uses creator functions to implement actions and reducers, which is a more
    familiar and straightforward way to implement these components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s implement the two actions using the `createAction` function, providing
    a name and an expected list of input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The search action has the name `'[Search] Search'` and has `searchText` and
    an optional `country` parameter as inputs. The `weatherLoaded` action follows
    a similar pattern. At the end of the file, we create a union type of actions,
    so we can group them under one parent type to use in the rest of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that action names are prepended by `[Search]`. This convention helps
    developers visually group related actions together during debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our actions are deﬁned, we can implement the effect to handle the search
    action and dispatch a `weatherLoaded` action.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing NgRx effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, effects let us change the stored state without necessarily
    storing the event data causing the change. For example, we want our state only
    to have weather data, not the search text itself. Effects allow us to do this
    in one step, rather than forcing us to use an intermediate store for the `searchText`
    and a far more complicated chain of events to turn that into weather data.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, we would have to implement a reducer in between. We first need to
    store this value in the NgRx store, then retrieve it from a service, and finally
    dispatch a `weatherLoaded` action. The effect will make it simpler to retrieve
    data from the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s add `CurrentWeatherEffects` to our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Take the default options when prompted.
  prefs: []
  type: TYPE_NORMAL
- en: You will have a new `current-weather.effects.ts` file under the `effects` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, `--group` is used to group effects under a folder of the same name.
    `--root` registers the effect in `app.module.ts` and we use creator functions
    with the `--creators` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `CurrentWeatherEffects` ﬁle, start by implementing a private `doSearch`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that we’re choosing to ignore errors thrown with the `EMPTY` function.
    You can surface these errors to the user with a `UiService` like the one you’ve
    implemented for LemonMart.
  prefs: []
  type: TYPE_NORMAL
- en: This function takes an action with search parameters, calls `getCurrentWeather`,
    and upon receiving a response, dispatches the `weatherLoaded` action, passing
    in the current weather property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s create the effect itself, so we can trigger the `doSearch` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is where we tap into the Observable action stream, `this.actions$`, and
    listen to actions of the `SearchAction.search` type. We then use the `exhaustMap`
    operator to register for the emitted event.
  prefs: []
  type: TYPE_NORMAL
- en: Due to its unique nature, `exhaustMap` won’t allow another search action to
    be processed until the `doSearch` function completes dispatching its `weatherLoaded`
    action.
  prefs: []
  type: TYPE_NORMAL
- en: Impact of RxJS operators on actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding example, I used the `exhaustMap` operator. This is not necessarily
    the correct RxJS operator for this use case, `switchMap` is. I selected `exhaustMap`
    with the express purpose of limiting the number of API calls generated toward
    a free resource, which can aggressively rate limit requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore four RxJS operators we can choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mergeMap`: Allows for handling multiple actions in parallel, ideal for scenarios
    where each action’s effect is independent and doesn’t need to be synchronized.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`concatMap`: Processes actions in sequence, starting the next one only after
    the previous action is complete, ensuring actions are handled in the order they
    were dispatched, which is useful for maintaining consistency in state updates.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`switchMap`: On receiving a new action, it cancels the previous one and switches
    to the new one, which is suitable for use cases like search bar inputs where only
    the latest action (e.g., user input) is relevant.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`exhaustMap`: Ignores new actions if one is already being processed, making
    it useful for avoiding duplicate or conflicting requests, such as multiple submissions
    of the same form.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `exhaustMap`, if actions are created rapidly before the `doSearch` function
    completes, the actions that haven’t been processed will be dropped. So, if actions
    *a*, *b*, *c*, *d*, and *e* are created, but `doSearch` completes between when
    *c* and *d* were created, then actions *b*, *c*, and *e* are never processed,
    but action *d* will be. API calls for *b*, *c*, and *e* are never made. Only a
    `weatherLoaded` action for *d* is dispatched. While we avoid making unnecessary
    API calls for results users will never see, the end state will confuse the user.
  prefs: []
  type: TYPE_NORMAL
- en: Using `mergeMap`, all search actions are processed in parallel, API calls made,
    and `weatherLoaded` actions dispatched. So, if actions *a*, *b*, *c*, *d*, and
    *e* are created rapidly. The user may see flashes of results from all actions,
    but the last one displayed will be *e*.
  prefs: []
  type: TYPE_NORMAL
- en: With `concatMap`, actions are processed sequentially. Considering actions *a*,
    *b*, *c*, *d*, and *e*, the API call for *b* isn’t made until after the `weatherLoaded`
    action is dispatched for *a* and the result is rendered. This will happen for
    each action until the weather for *e* is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: With `switchMap`, API calls will be made with each action. However, only the
    last action will be dispatched, so the user will only see the last action displayed.
  prefs: []
  type: TYPE_NORMAL
- en: So, from a UX perspective, `switchMap` is functionally the correct implementation.
    You could also implement a loading spinner or disable user input while data is
    processed to prevent expensive API calls.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, depending on your use case and UX needs, consider a different RxJS
    operator. Not all dispatched actions result in a screen that needs to be rendered.
    If you wanted to retain all data input, you could process actions in a service
    worker background thread and update a notification panel or a badge with a counter
    in your app.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing reducers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the `weatherLoaded` action triggered, we need a way to ingest the current
    weather information and store it in our `appStore` state. Reducers will help us
    handle specific actions, creating an isolated and immutable pipeline to store
    our data predictably.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a `search` reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Take the default options. Here, we use `--group` to keep files organized under
    the `reducers` folder and `--creators` to leverage the creator style of creating
    NgRx code. We also specify the location of our parent `appStore` state at `reducers/index.ts`
    with `--reducers`, so our new reducer can be registered with it.
  prefs: []
  type: TYPE_NORMAL
- en: You may observe that `reducers.index.ts` has been updated to register the new
    `search.reducer.ts`. Let’s implement it step by step.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `search` state, we will be storing the current weather, so implement
    the interface to reﬂect this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s specify the `initialState`. This is similar to how we need to define
    a default value of a `signal` or `BehaviorSubject`. Refactor the `WeatherService`
    to export a `const defaultWeather: ICurrentWeather` object that you can use to
    initialize `BehaviorSubject` and `initialState`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, implement `searchReducer` to handle the `weatherLoaded` action using
    the `on` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We register for the `weatherLoaded` action, unwrap the stored data, and pass
    it into the `search` state.
  prefs: []
  type: TYPE_NORMAL
- en: This is, of course, a very simplistic case. However, it is easy to imagine a
    more complicated scenario where we may need to flatten or process a piece of data
    received and store it in an easy-to-consume manner. Isolating such logic in an
    immutable way is the key value proposition of utilizing a library like NgRx.
  prefs: []
  type: TYPE_NORMAL
- en: Registering with Store using selector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need `CurrentWeatherComponent` to register with the `appStore` state for
    updated current weather data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by dependency injecting the `appStore` state and registering the selector
    to pluck current weather from the `State` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We listen to state change events that flow through the store. Using the `select`
    function, we can implement an inline select to get the data we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can refactor this a bit and make our selector reusable by using a `createSelector`
    to create a `selectCurrentWeather` property on `reducers/index.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As the number of TypeScript interfaces and NgRx selectors increases, you should
    break them into separate files and organize your code better.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, since we want to maintain the continued operation of `BehaviorSubject`,
    we can implement a `merge` operator in `CurrentWeatherComponent` to listen to
    both `WeatherService` updates and `appStore` state updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we can listen to store updates, let’s implement the final puzzle piece:
    dispatching the search action.'
  prefs: []
  type: TYPE_NORMAL
- en: Dispatching store actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to dispatch the search action so that our search effect can fetch the
    current weather data and update the store. Earlier in this chapter, you implemented
    a stubbed function called `ngRxBasedSearch` in the `CitySearchComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement `ngRxBasedSearch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Don’t forget to inject the `appState` store into the component!
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it! Now you should be able to run your code and test to see whether
    it all works.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, NgRx brings a lot of sophisticated techniques to the table to
    create ways to make data transformations immutable, well deﬁned, and predictable.
    However, this comes with considerable implementation overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Use your best judgment to determine whether you need the Flux pattern in your
    Angular app. The frontend application code can often be made much simpler by implementing
    RESTful APIs that return ﬂat data objects, with complicated data manipulations
    handled server side, reducing, if not eliminating, the need for tools like NgRx.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing reducers and selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can implement unit tests for the `weatherLoaded` reducer and the `selectCurrentWeather`
    selector in `search.reducer.spec.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: These unit tests are straightforward and will ensure that no unintentional changes
    to the data structure can happen within the store.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing components with MockStore
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to update the tests for `CurrentWeatherComponent` so that we can inject
    a mock `Store` into the component to test the value of the `current$` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the delta of what needs to be added to the `spec` file to configure
    the mock store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now update the `''should get currentWeather from weatherService''` test
    to see whether `CurrentWeatherComponent` works with a mock store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The mock store allows us to set the store’s current state, which in turn allows
    the selector to call in the constructor to fire and grab the provided fake weather
    data.
  prefs: []
  type: TYPE_NORMAL
- en: '`TestBed` is not a hard requirement for writing unit tests in Angular, a topic
    covered well at [https://angular.dev/guide/testing](https://angular.dev/guide/testing).
    My colleague and reviewer of the 2^(nd) edition, Brendon Caulkins, contributed
    a bedless `spec` file for this chapter, named `current-weather.component.nobed.spec.ts`.
    He cites significant performance increases when running the tests, with fewer
    imports and less maintenance, but a higher level of care and expertise required
    to implement the tests. If you’re on a large project, consider skipping `TestBed`.'
  prefs: []
  type: TYPE_NORMAL
- en: The sample code on GitHub is under the `projects/stage12` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and update the remainder of your tests, and do not move on until they
    all start passing.
  prefs: []
  type: TYPE_NORMAL
- en: NgRx ecosystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you understand NgRx better beyond just theory, let’s examine the different
    available options within the ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some popular options from the community, including sibling packages
    from NgRx:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NgRx/Data**, a gentle introduction to NgRx with simplified entity management'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NgRx/ComponentStore**, a component-scoped version of NgRx/Store with less
    boilerplate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NgRx/SignalStore**, the next generation of state management in Angular'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Akita**, a reactive state management offering tailor-made for JS applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elf**, a reactive store with magical powers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s explore these options.
  prefs: []
  type: TYPE_NORMAL
- en: NgRx/Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If NgRx is a configuration-based framework, NgRx Data is a convention-based
    sibling of NgRx. NgRx Data automates the creation of stores, effects, actions,
    reducers, dispatches, and selectors. If most of your application actions are **CRUD**
    (**Create**, **Retrieve**, **Update**, and **Delete**) operations, then NgRx Data
    can achieve the same result as NgRx with much less code needing to be written.
  prefs: []
  type: TYPE_NORMAL
- en: '`@ngrx/data` works in tandem with the `@ngrx/entity` library. Together they
    offer a rich feature set, including transactional data management.'
  prefs: []
  type: TYPE_NORMAL
- en: NgRx Data may be a much better introduction to the Flux pattern for you and
    your team, allowing an easy ramp-up for the full NgRx framework. Unfortunately,
    NgRx Data is no longer recommended for new projects.
  prefs: []
  type: TYPE_NORMAL
- en: As of version 17, NgRx Data is officially in maintenance mode, and it’s not
    recommended for new projects or adding to existing projects.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about it at [https://ngrx.io/guide/data](https://ngrx.io/guide/data).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add NgRx Data to your project by executing the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: So, should you implement NgRx Data in your next app? It depends, but probably
    not, given its maintenance mode status. Since the library is an abstraction layer
    on top of NgRx, you may find yourself lost and restricted if you don’t have a
    good understanding of the internals of NgRx. However, the library holds much promise
    for reducing boilerplate code regarding entity data management and CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re doing lots of CRUD operations in your app, you may save time, but
    be careful to limit the scope of your implementation to the areas that need it.
    As the NgRx documentation highlights, NgRx Data lacks many capabilities of a full-featured
    entity management system, like deep entity cloning, server-side querying, relationships,
    key generation, and non-normalized server responses.
  prefs: []
  type: TYPE_NORMAL
- en: For a full-featured entity management library, consider BreezeJS [https://www.getbreezenow.com/breezejs](https://www.getbreezenow.com/breezejs).
    However, beware that Breeze doesn’t adhere to reactive, immutable, and redux principles
    as NgRx does.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s investigate ComponentStore for a less demanding and more focused
    application of the Flux pattern.
  prefs: []
  type: TYPE_NORMAL
- en: NgRx/ComponentStore
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NgRx ComponentStore offers a lightweight, reactive state management solution
    ideal for local state within components or modules.
  prefs: []
  type: TYPE_NORMAL
- en: It’s designed to manage local state without needing a global store, maintaining
    a clean separation of concerns, and making components simple and maintainable.
    This approach is particularly useful for complex components with many local states
    and interactions, as it allows for push-based services that manage this state
    with the component’s lifecycle, supporting reusability and independent instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can implement the data source of your paginated data table using `ComponentStore`,
    similar to how this is done with Elf. Check out this excellent two-part blog post
    by Pierre Bouillon: [https://dev.to/this-is-angular/handling-pagination-with-ngrx-component-stores-1j1p](https://dev.to/this-is-angular/handling-pagination-with-ngrx-component-stores-1j1p).'
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, NgRx Store manages a global shared state and is beneficial for
    larger applications requiring scalability, multiple effects, and DevTools integration.
    ComponentStore, while less scalable and with many updaters and effects, ensures
    type safety, performance, and ease of testing, allowing for a more encapsulated
    and component-specific state management.
  prefs: []
  type: TYPE_NORMAL
- en: The choice between `ComponentStore` and `Store` hinges on the application’s
    size, component dependencies, state longevity, and business requirements, among
    other factors.
  prefs: []
  type: TYPE_NORMAL
- en: Read more about ComponentStore at [https://ngrx.io/guide/component-store](https://ngrx.io/guide/component-store).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add ComponentStore to your project by executing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In short, `ComponentStore` is an alternative to the “Service with a Subject”
    approach we’ve covered in the book. However, with Angular’s architecture shifting
    toward Signals, you may want to skip the `ComponentStore` and implement `SignalStore`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: NgRx/Signals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I introduced you to signals in the *Using Angular signals* section of *Chapter
    2*, *Forms, Observables, Signals, and Subjects*. NgRx/Signals is a self-contained
    library offering a reactive state management solution alongside a suite of utilities
    for working with Angular Signals. It’s architected for simplicity, presenting
    an intuitive API for developers. Its lightweight nature ensures minimal load on
    applications while maintaining high performance.
  prefs: []
  type: TYPE_NORMAL
- en: The library champions declarative programming, fostering clean and concise code.
    It facilitates the crafting of autonomous components that are easily integrated,
    promoting scalable and flexible applications. Additionally, it enforces type safety,
    mitigating errors early in the development cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The library includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: SignalStore is a robust state management system bringing the best of both worlds
    from NgRx/Store and NgRx/ComponentStore.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SignalState is a streamlined utility for managing state within Angular components
    and services overtaking any need for self-managed signal properties in service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rxMethod` provides opt-in usage to interact with Observables. Useful for interacting
    with existing code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`withEntities` is an entity management plugin offering an efficient approach
    to facilitate CRUD operations for managing entities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will investigate SignalState and SignalStore in depth in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Read more about NgRx Signals at [https://ngrx.io/guide/signals](https://ngrx.io/guide/signals).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add SignalStore to your project by executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Let’s round up our state management ecosystem tour with some popular non-NgRx
    options, Akita and Elf.
  prefs: []
  type: TYPE_NORMAL
- en: Akita
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Akita is a state management solution combining Flux, Redux, and RxJS concepts
    into the Observable Data Store model, favoring immutability and streaming data.
    It emphasizes simplicity, reduces boilerplate code, and is accessible to developers
    at all levels due to its moderate learning curve. Akita adopts object-oriented
    principles, making it intuitive for those familiar with OOP, and enforces a consistent
    structure to guide and standardize team development practices.
  prefs: []
  type: TYPE_NORMAL
- en: Akita is built around RxJS/`BehaviorSubject` and provides specialized classes
    for state management, such as `Store`, `Query`, and `EntityStore`. Like NgRx,
    Akita exposes state changes as RxJS Observables and utilizes the update method
    for state mutations, enabling an OOP style for state management.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worthwhile to experiment with Akita if you’re looking for a simpler solution
    with built-in entity management, plugins for state history, server-side pagination,
    more OOP versus functional, and, overall, less boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about Akita at [https://opensource.salesforce.com/akita/](https://opensource.salesforce.com/akita/).
  prefs: []
  type: TYPE_NORMAL
- en: Elf
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Elf is the most magical option of the bunch. It’s a newer state management library
    for Angular that aims to simplify reactivity and state mutations with a minimalistic
    API, focusing on ergonomics and ease of use. It uses modern RxJS patterns for
    state management, enabling fine-grained control over state changes and reactivity.
    Elf is designed to be lightweight and straightforward, offering a simpler alternative
    to the more comprehensive NgRx suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Elf is modular, fully tree-shakable, and provides first-class support for the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Request cache** to prevent redundant API calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entities** such as NgRx/Data or Akita.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State persistence** for offline-first applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State history** for easy undo/redo functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced pagination** to optimize fetching and caching of paginated data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elf integrates features and best practices for building reactive web apps with
    statement management and makes them easy. While features like pagination support
    can be implemented using NgRx/ComponentStore, the built-in pagination caching
    support is impressive. In addition, Elf has a plugin to sync state across browser
    tabs, enabling truly advanced state management.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given the number of built-in and high-quality features that ship with Elf, it
    is a standout solution that may be the right option for your next project. You
    can learn more about Elf at [https://ngneat.github.io/elf/](https://ngneat.github.io/elf/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ve covered the nuances of the NgRx ecosystem. Let’s learn how you can configure
    proxies with Angular to deal with convention-based state management libraries
    that expect a certain way to access server-side data.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring server proxies with the Angular CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some state management libraries, especially convention-based entity stores like
    NgRx Data, make assumptions about accessing server-side data. In the case of NgRx
    Data, the library wants to access the REST API via the `/api` path hosted on the
    same port as your Angular app. We must leverage the Angular CLI’s proxy feature
    to accomplish this during development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, HTTP requests are sent to our web server, and our API server should
    have the same URL. However, during development, we usually host both applications
    on two different ports of `http://localhost`. Certain libraries, including NgRx
    Data, require that HTTP calls be on the same port. This creates a challenge for
    creating a frictionless development experience. For this reason, the Angular CLI
    ships with a proxy feature with which you can direct the `/api` path to a different
    endpoint on your localhost. This way, you can use one port to serve your web app
    and your API requests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `proxy.conf.json` file under `src`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you’re working in the **lemon-mart-server** monorepo, this will be `web-app/src`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Register the proxy with `angular.json`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now the server that is started when you run `npm start` or `ng serve` can rewrite
    the URLs of any call made to the `/api` route with `http://localhost:3000`. This
    is the port that **lemon-mart-server** runs by default.
  prefs: []
  type: TYPE_NORMAL
- en: Use the correct port number and child route if your API is running on a different
    port.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a global spinner with NgRx/SignalState
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Multi-step responsive forms* section of *Chapter 8*, *Recipes – Reusability,
    Forms, and Caching*, and the *Data tables with pagination* section earlier in
    this chapter, I discussed the differences between localized spinners and global
    ones. A global spinner is the ultimate 80-20 solution to paper over UX issues
    stemming from UI elements not being ready for interaction while data loads. However,
    this will cause excessive full-screen interruptions in large applications with
    multiple on-screen components or background service workers loading data. In that
    case, most components will require local spinners instead.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, let’s go after the 80-20 solution. We can use an `HttpInterceptor`
    to detect when an API call is made within the application. This allows us to show
    or hide a global spinner. However, if multiple calls are made concurrently, we
    must keep track of this, otherwise the global spinner may behave erratically.
    With NgRx/SignalState, we can keep track of the number of calls without introducing
    the local state in a service.
  prefs: []
  type: TYPE_NORMAL
- en: NgRx/SignalState
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SignalState is a lightweight utility provided by `@ngrx/signals` for managing
    signal-based state in Angular components and services in a concise and minimalistic
    manner. It is used to create and operate on small slices of state directly in
    your component class, service, or a standalone function. You can provide a deeply
    nested signal of the object properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'SignalState should be used within a component or service to manage simple state.
    The library offers the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`signalState` is a utility function that takes the initial state of the store
    and defines the shape of the state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`patchState` updates the stored value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read more about NgRx SignalState at [https://ngrx.io/guide/signals/signal-state](https://ngrx.io/guide/signals/signal-state).
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by adding `signalState`, `computed` `signal`, `showLoader`, and `hideLoader`
    functions to `UiService`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify UiService as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We start by defining a private `signalState` and initializing the `count` and
    `isLoading` properties. The state should always be encapsulated within the boundaries
    it’s being used to avoid uncontrolled side effects. As we cover in the next section,
    SignalStore is a more robust solution to manage side effects. However, we want
    `isLoading` to be publicly available, so a UI component can bind it to hide or
    display the spinner. So, we implement a `computed` signal, which acts as a selector
    to return the current value of `isLoading` in a read-only manner.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`patchState` is a utility function that provides a type-safe way to perform
    immutable updates on pieces of state. We use it to update the values of `count`
    and `isLoading`, whenever `show` or `hide` functions are called.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, implement `LoadingHttpInterceptor` under `src/common` to call the `show`
    and `hide` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We inject `UiService` and call `showLoader` to increment the count by one. We
    then set up the finalize operator, so when the API call is finished `hideLoader`
    is called to decrement the count by one. So, whenever a loader function is called
    and the count is equal to zero, we know we either need to show or hide the spinner.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Don’t forget to provide the new interceptor in `app.config.ts`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, create a `LoadingOverlayComponent` under common and use `isLoading` to
    show or hide a spinner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We inject and use the computed `isLoading` signal from `UiService`. With the
    `@if` flow control, the spinner will be shown or hidden depending on whether `isLoading`
    is set to true or false.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The use of `ViewEncapsulation.ShadowDom` in Angular allows component styles
    to be encapsulated within a Shadow DOM. By default, Angular uses an emulated mode
    to scope styles to components. However, the Shadow DOM encapsulation provides
    more robust support for dynamic CSS features.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, update `app.component.ts` to import and place the new component at
    the top of the template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Give it a try. A glorious lemon spinner will take over the screen whenever an
    API call is made.![A screenshot of a lemon login  Description automatically generated](img/B20960_09_10.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.10: LemonMart’s lemon spinner'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This resolves the data pop-in issues in the user profile form mentioned in *Chapter
    8*, *Recipes – Reusability, Forms, and Caching*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are your API calls happening too quickly to appreciate the spinner?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In **lemon-mart-server**, you can add a two-second delay:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Or you can slow things down in your browser’s DevTools **Network** tab by changing
    the **No Throttling** dropdown to **Fast 3G** or **Slow 3G**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Pre-loading screens with HTML and CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you follow the tip from the previous section and slow down the network speed
    of your browser to **Slow 3G** and **Disable caching**, you’ll notice that it
    takes forever and a half for anything to be shown on screen. In *Chapter 3*, *Architecting
    an Enterprise App*, I covered how to implement **Server-side Rendering** (**SSR**)
    to overcome such issues. However, that may not always be an option or may be overkill.
    Using simple HTML and CSS we can implement an easy solution to present an attractive
    and dynamic loading screen to entertain bored users staring at your app on a slow
    network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by adding the CSS in LemonMart:'
  prefs: []
  type: TYPE_NORMAL
- en: Create `spinner.css` under `src/assets/styles`. Copy the contents from LemonMart’s
    GitHub repo at [https://github.com/duluca/lemon-mart/blob/main/src/assets/styles/spinner.css](https://github.com/duluca/lemon-mart/blob/main/src/assets/styles/spinner.css).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update `index.html` to import the stylesheet and place the necessary HTML inside
    the `<app-root>` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When Angular launches, the contents of `<app-root>` will be replaced by your
    application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that this pre-loading screen is designed to be minimal and should come
    up instantly on screen. However, you will notice it still can take up to 6 seconds
    to display. This is because Angular prioritizes the global `styles.scss` file
    for loading first. If you’re using Angular Material, this adds 165 KB of content,
    which takes almost 6 seconds to load in **Slow 3G**. However, this is still much
    better in the context of a 50-second total loading time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Restart your Angular app and you should see the pre-loading screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_09_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.11: Preloading screen on slow networks'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand how to work with a state slice using NgRx/SignalState,
    let’s dive into the excellent NgRx/SignalStore library next. In fact, it’s so
    good that it inspired me to rewrite the LocalCast Weather app to be nearly Observable
    and RxJS operator-free with zero subscribe calls or async pipes.
  prefs: []
  type: TYPE_NORMAL
- en: Rewriting Angular apps with NgRx/SignalStore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Observables, the best subscription is the one you don’t have to make. Throughout
    this book, we used the `async pipe`, `take(1)`, `takeUntilDestroyed`, and `unsubscribe`
    in `ngOnDestroy` to try and manage them. The sample code for this book has been
    through many reviews by various practitioners and experts over a period of six
    years. Every review highlighted some oversight or bug with the RxJS code.
  prefs: []
  type: TYPE_NORMAL
- en: The 3^(rd) edition of the book provides a 99% bug-free implementation. I could
    never claim 100% due to the insane complexity of the RxJS ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: I take pride in not taking the easy way out. I do my best to provide realistic
    and complete examples for you, not just counters and to-do lists. However, these
    are still highly controlled and small-sized projects compared to what happens
    in real life. You rarely have time to go back and reevaluate your entire project.
    Mistakes get compounded over time. This is a sad reality of working with RxJS.
    It’s wonderful for what it does, but 95+ percent of code written doesn’t require
    the flexibility and reactivity the tool brings. Most code is about retrieving
    some data from an API once and displaying it. Signals with async/await-driven
    promises make this kind of code straightforward to write.
  prefs: []
  type: TYPE_NORMAL
- en: RxJS and signal helpers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Several important functions will help you transition away from Observables
    and RxJS:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript promises** are a construct that allows for asynchronous operations,
    providing a way to handle the eventual success value or failure reason.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JavaScript async/await** is syntactic sugar in JavaScript that allows you
    to write asynchronous code in a synchronous fashion, built on top of promises.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RxJS Interop** `toSignal` creates a signal that tracks the value of an Observable,
    like the async pipe in templates but more flexible. Similar to async pipe, `toSignal`
    manages the subscription for us, so there’s no need to use subscribe, `takeUntil`,
    or unsubscribe. There’s also `toObservable`, which is a useful bridge during the
    transition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ChangeDetectionStrategy.OnPush` is a strategy that tells Angular to run change
    detection on a component only when its input properties change, improving performance
    by reducing the number of checks. You will need to set the `changeDetection` property
    of your components to this until Signal-based components arrive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lastValueFrom` is a utility function that converts an Observable to a promise
    that resolves with the last value emitted by the Observable. This operator also
    manages the subscription for us. There’s also `firstValueFrom`, but you probably
    won’t need that one. This conversation will be necessary until Angular implements
    promise-based APIs to modules such as `HttpClient`, `Router`, `FormControl`, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RxJS Interop is in developer preview.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can read more about it at [https://angular.dev/guide/signals/rxjs-interop](https://angular.dev/guide/signals/rxjs-interop).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: State management remains key to managing the complexity of large applications.
    Let’s see how NgRx SignalStore can help with the transition.
  prefs: []
  type: TYPE_NORMAL
- en: NgRx/SignalStore
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SignalStore is a fully featured state management solution built around declarative
    programming, ensuring clean and concise code. SignalStore is for managing larger
    stores with complex state as opposed to SignalState, which is designed to contain
    simple state within a single component or service.
  prefs: []
  type: TYPE_NORMAL
- en: Read more about NgRx SignalStore at [https://ngrx.io/guide/signals/signal-store](https://ngrx.io/guide/signals/signal-store).
  prefs: []
  type: TYPE_NORMAL
- en: 'SignalStore can provided at the root level or component level. The library
    offers the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`signalStore` is a utility function for managing larger and more complex pieces
    of state in an application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`withState` takes the initial state of the store and defines the shape of the
    state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`withComputed` derives computed properties from existing pieces of state in
    the store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`withMethods` contains custom functions (store methods) that are exposed publicly
    to operate on the store with a well-defined API. `withMethods` can use `patchState`
    and injected services to update the store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`withHooks` are called when the store is created or destroyed, allowing for
    fetching data to initialize the store or updating state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`withEntities` is an extension to facilitate CRUD operations for managing entities.
    It is like `@ngrx/entity` but not the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read more about NgRx SignalStore entities at [https://ngrx.io/guide/signals/signal-store/entity-management](https://ngrx.io/guide/signals/signal-store/entity-management).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Also, see advanced use cases with custom store features at [https://ngrx.io/guide/signals/signal-store/custom-store-features](https://ngrx.io/guide/signals/signal-store/custom-store-features).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s see how we can apply SignalStore to LocalCast Weather. The diagram below
    is a recreation of the one from the *Implementing NgRx for LocalCast Weather*
    section earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a diagram  Description automatically generated](img/B20960_09_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.12: LocalCast Weather architecture'
  prefs: []
  type: TYPE_NORMAL
- en: Upon initial inspection, SignalStore appears simpler than the NgRx store implementation.
    That’s because the inherent reactivity of signals is baked into Angular. You must
    remember this invisible thread that makes the magic work beneath the surface of
    this implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The workflow, represented in dark gray in *Figure 9.12*, begins with *step
    1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CitySearchComponent` triggers the `doSearch` method, which in turn calls `store.updateWeather`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`withMethods` activates the `updateWeather` function, which has an injected
    reference to `WeatherService` and calls `getCurrentWeather` from it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`updateWeather` awaits the result from `getCurrentWeather`, which retrieves
    the current weather information from **OpenWeather**, and uses `patchState` to
    update `store.current`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CurrentWeatherComponent` is bound to `store.current`, so when the value updates,
    the template is automatically updated.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we understand how SignalStore operates conceptually, let’s take a tour
    of the new code base.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring RxJS and NgRx code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will review the refactored LocalCast Weather app to examine how the code
    was rewritten to be simpler and more concise using signals and SignalStore.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this section is under `projects/signal-store` on the `local-weather-app`
    repository at [https://github.com/duluca/local-weather-app/tree/main/projects/signal-store](https://github.com/duluca/local-weather-app/tree/main/projects/signal-store).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the project by executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Run Cypress tests with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: NgRx Store to SignalStore
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start with the Store implementation under `projects/signal-store/src/app/store`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`withState` defines and initializes the store. `withMethods` implements the
    `updateWeather` function, which encapsulates the behavior for updating the current
    weather. This function used to be in `WeatherService` but has now been moved into
    the store. Arguably, this should have been the case for the NgRx Store implementation;
    however, with an overall simpler architecture, it is easier to see that any potential
    side effect is best implemented in the store.'
  prefs: []
  type: TYPE_NORMAL
- en: Services from Observables to Signals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We must update API calls to return a Promise instead of an Observable. I first
    updated `PostalCodeService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '`resolvePostalCode` now returns `Promise<IPostalCode>`. We store the Observable
    from `httpClient.get` as a local `httpCall$` variable, which is then wrapped by
    `lastValueFrom`. In the process, we also removed the pipe, which implemented `mergeMap`
    and `defaultIfEmpty` to clean up the received data. We must implement a similar
    functionality in the `then` function. As shown previously, `then` behaves similarly
    to a `tap` function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s look at `WeatherService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '`getCurrentWeather` is now an async function to await the result of `postalCodeService.resolvePostalCode`.
    The logic inside the `switchMap` to handle the response from `resolvePostalCode`
    is now a simple if-else statement with less nesting. `getCurrentWeatherHelper`
    has been refactored similar to how we refactored `resolvePostalCode`.'
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, there’s no longer a `BehaviorSubject`, a `signal`, or any
    code that remains in the service that updates the value of `currentWeather`.
  prefs: []
  type: TYPE_NORMAL
- en: Components from Observables to Signals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the services updated, we can now complete the refactor and update the components
    to use signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with `CitySearchComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We first set the `changeDetection` strategy to be `OnPush`. Next, we wrap `search.valueChanges`
    in a `toSignal` function to convert the Observable to a signal. This is notably
    the only pipe remaining in the app. The main reason is because of the `debounceTime`
    operator. See the tip box for more. We then use the `effect` function to react
    to changes pushed to `searchSignal`, which triggers `doSearch`, which in turn
    calls `store.updateWeather`. As we covered earlier, `store.updateWeather` will
    end up updating the `store.current` signal. Notably, we no longer reference `WeatherService`
    from this component, and no template changes were needed.
  prefs: []
  type: TYPE_NORMAL
- en: Filter and debounce are the only RxJS operators left in LocalCast Weather. Currently,
    there aren’t operators for signals. You can check out how a debounced signal function
    might work in this Stack Overflow answer [https://stackoverflow.com/a/76597576/178620](https://stackoverflow.com/a/76597576/178620).
    However, as the author An Nguyen notes, it’s complicated code, and it’s better
    to use a well-tested library for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s look at `CurrentWeatherComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The most remarkable change happens within `CurrentWeatherComponent`. We set
    `changeDetection` as before, but now we only have to inject `WeatherStore`. That’s
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In the template, we can remove the null guard because the signal is always initialized.
    Then we simply bind to `store.current()` signal. This, of course, requires a rather
    annoying refactoring of the template. We have to update every reference to `current`
    with `store.current()`. This could have been avoided by introducing a local variable
    named `current` and then using an `effect` to listen to updates on `store.current()`.
    However, with that configuration, you wouldn’t get the benefits of the granular
    change detection that `signal` and `OnPush` offer.
  prefs: []
  type: TYPE_NORMAL
- en: 'I expect when Signal-based components arrive, we will be able to write code
    similar to how async pipe works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This will be a tremendous help in avoiding annoying template rewrites.
  prefs: []
  type: TYPE_NORMAL
- en: And with the component updates done, the application refactor is complete. There
    are other subtle changes around the app code. You will notice a lot less imports
    and providers.
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, the signal-only code is easier to understand and maintain; far
    superior to the RxJS alternative. I hope you enjoyed this glimpse into Angular’s
    future.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we completed going over all major Angular app design considerations
    using router-first architecture, along with our recipes, to implement a line-of-business
    app easily. We reviewed how to edit existing users, leverage a resolve guard to
    load user data, and hydrate and reuse a component in different contexts.
  prefs: []
  type: TYPE_NORMAL
- en: We implemented a master/detail view using auxiliary routes and demonstrated
    how to build data tables with pagination. We then learned how to implement NgRx/Store
    and NgRx/SignalStore using **local-weather-app**. We covered the available options
    within the NgRx ecosystem, including NgRx/Data, NgRx/ComponentStore, Akita, and
    Elf, and the differences between those options, so you can make informed decisions
    about what to include in your project.
  prefs: []
  type: TYPE_NORMAL
- en: We also implemented a pre-loading animation, so your app looks responsive when
    loading in slow connections. We also implemented a global spinner within the app
    to handle data pop-in-related UX issues. Finally, we took a peek into Angular’s
    signal-based future by touring a full refactor of **local-weather-app** using
    SignalStore and developer preview features.
  prefs: []
  type: TYPE_NORMAL
- en: Using the router-first design, architecture, and implementation approach, we
    tackled our application’s design with a high-level understanding of what we wanted
    to achieve. We saw the power of router orchestration by demonstrating the use
    of router outlets and reusing the same component in two different contexts. By
    identifying code reuse opportunities early on, we optimized our implementation
    strategy to implement reusable components ahead of time without running the risk
    of grossly over-engineering our solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we learn about containerization using Docker and deploying
    your apps to the cloud. Docker allows powerful workflows that can greatly improve
    development experiences while allowing you to implement your server configuration
    as code, putting the final nail in the coffin of the developer’s favorite excuse
    when their software breaks: “But it works on my machine!”'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Update `UserTableComponent` and related services in **lemon-mart** to leverage
    Elf entities and pagination to enable optimized handling of requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the guide on [https://ngneat.github.io/elf/docs/features/pagination](https://ngneat.github.io/elf/docs/features/pagination).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rewrite your Angular app with NgRx/SignalStore to be nearly Observable and RxJS
    operator-free with zero subscribe calls or async pipes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you think this is a hilarious exercise tacked on toward the end of the book,
    give me a shoutout on my GitHub profile at [https://github.com/duluca](https://github.com/duluca).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Testing Angular Components With @Input()*, Aiko Klostermann, 2017, available
    at [https://medium.com/better-programming/testing-angular-components-with-input-3bd6c07cfaf6](https://medium.com/better-programming/testing-angular-components-with-input-3bd6c07cfaf6
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What is NgRx?*, 2020, available at [https://ngrx.io/docs](https://ngrx.io/docs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*NgRx Testing*, 2020, available at [https://ngrx.io/guide/store/testing](https://ngrx.io/guide/store/testing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*@ngrx/data*, 2020, available at [https://ngrx.io/guide/data](https://ngrx.io/guide/data)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*NgRx: Action Creators redesigned*, Alex Okrushko, 2019, available at [https://medium.com/angular-in-depth/ngrx-action-creators-redesigned-d396960e46da](https://medium.com/angular-in-depth/ngrx-action-creators-redesigned-d396960e46da)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Simplifying Frontend State Management with Observable Store*, Dan Wahlin,
    2019, available at [https://blog.codewithdan.com/simplifying-front-end-state-management-with-observable-store/](https://blog.codewithdan.com/simplifying-front-end-state-management-with-observable-store/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Handling pagination with NgRx component stores*, Pierre Bouillon, 2023, [https://dev.to/this-is-angular/handling-pagination-with-ngrx-component-stores-1j1p](https://dev.to/this-is-angular/handling-pagination-with-ngrx-component-stores-1j1p)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Navigating the Nuances of toSignal in Angular: What to Know*, Netanel Basal,
    2023, [https://netbasal.com/navigating-the-nuances-of-tosignal-in-angular-what-to-know-e4d6a4b5dfaf](https://netbasal.com/navigating-the-nuances-of-tosignal-in-angular-what-to-know-e4d6a4b5dfaf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A Guide to Angular Signals With Practical Use Cases*, Arman Murzabulatov,
    2023, [https://hackernoon.com/a-guide-to-angular-signals-with-practical-use-cases-part-1](https://hackernoon.com/a-guide-to-angular-signals-with-practical-use-cases-part-1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Power of @ngrx/signalstore: A Deep Dive Into Task Management*, Peter Eijgermans,
    2024, [https://dzone.com/articles/the-power-of-ngrxsignalstore-a-deep-dive-into-task](https://dzone.com/articles/the-power-of-ngrxsignalstore-a-deep-dive-into-task)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How to Implement a Global Loader in Angular*, Faizan Shaikh , 2023, [https://blog.bitsrc.io/how-to-implement-a-global-loader-in-angular-df111a2c43d9](https://blog.bitsrc.io/how-to-implement-a-global-loader-in-angular-df111a2c43d9)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*RxJS: Avoiding takeUntil Leaks*, Nicholas Jamieson, 2018, [https://cartant.medium.com/rxjs-avoiding-takeuntil-leaks-fb5182d047ef](https://cartant.medium.com/rxjs-avoiding-takeuntil-leaks-fb5182d047ef)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Comprehensive Guide to Higher-Order RxJS Mapping Operators: switchMap, mergeMap,
    concatMap (and exhaustMap)*, Angular University, 2023, [https://blog.angular-university.io/rxjs-higher-order-mapping](https://blog.angular-university.io/rxjs-higher-order-mapping
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions as best as possible to ensure you’ve understood
    the key concepts from this chapter without googling anything. Do you know if you
    got all the answers right? Visit [https://angularforenterprise.com/self-assessment](https://angularforenterprise.com/self-assessment)
    for more:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a resolve guard?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of router orchestration?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an auxiliary route?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does NgRx differ from using RxJS/Subject?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the value of NgRx Data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `UserTableComponent`, why do we use `readonly` `isLoadingResults$: BehaviorSubject<Boolean>`
    over a simple Boolean to drive the loading spinner?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/AngularEnterpise3e](Chapter_9.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1116411172100421421.png)'
  prefs: []
  type: TYPE_IMG
