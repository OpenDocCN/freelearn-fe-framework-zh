<html><head></head><body>
		<div id="_idContainer101">
			<h1 id="_idParaDest-95" class="chapter-number"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.2.1">Testing Your App with Vitest and Cypress</span></h1>
			<p><span class="koboSpan" id="kobo.3.1">No matter how much experience you have under your belt in writing code, testing your app is a must to produce a high-quality code base. </span><span class="koboSpan" id="kobo.3.2">There are different testing tools out there, but in this book, we are going to learn Vitest for unit tests and Cypress for </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">end-to-end testing.</span></span></p>
			<p><span class="koboSpan" id="kobo.5.1">Testing is a large topic, and in this chapter, we will learn the basics of both testing methodologies, leaving out advanced techniques for future reading and training that you will encounter in the course of </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">your career.</span></span></p>
			<p><span class="koboSpan" id="kobo.7.1">First, we are going to learn the different testing methods and how they each contribute to producing quality software. </span><span class="koboSpan" id="kobo.7.2">We will then introduce unit tests by learning how to use Vitest and Vue Test Utils to test individual components in our application. </span><span class="koboSpan" id="kobo.7.3">Then, we will move our focus </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.8.1">away from the individual components and concentrate on our application, by introducing </span><strong class="old"><span class="koboSpan" id="kobo.9.1">E2E</span></strong><span class="koboSpan" id="kobo.10.1"> (</span><strong class="old"><span class="koboSpan" id="kobo.11.1">end-to-end</span></strong><span class="koboSpan" id="kobo.12.1">) tests with Cypress. </span><span class="koboSpan" id="kobo.12.2">We will then write an E2E test to cover a small user journey before moving on to the last section, which will be used to introduce advanced topics such as mocking </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">and spies.</span></span></p>
			<p><span class="koboSpan" id="kobo.14.1">This chapter consists of the </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">following sections:</span></span></p>
			<ul>
				<li><span class="No-Break"><span class="koboSpan" id="kobo.16.1">Testing pyramids</span></span></li>
				<li><span class="koboSpan" id="kobo.17.1">Unit testing </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">with Vitest</span></span></li>
				<li><span class="koboSpan" id="kobo.19.1">E2E tests </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">with Cypress</span></span></li>
				<li><span class="koboSpan" id="kobo.21.1">Introducing advanced </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">testing techniques</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.23.1">By the end of this chapter, you will have gained a basic understanding of testing in general. </span><span class="koboSpan" id="kobo.23.2">You will be able to set up both Vitest and Cypress on your future projects and know how to write basic tests in both unit tests and E2E tests. </span><span class="koboSpan" id="kobo.23.3">Finally, you will also be exposed to future testing techniques that you may encounter in </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">your career.</span></span></p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.25.1">Technical requirements</span></h1>
			<p><span class="koboSpan" id="kobo.26.1">In this chapter, the </span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.27.1">branch is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.28.1">CH08</span></strong><span class="koboSpan" id="kobo.29.1">. </span><span class="koboSpan" id="kobo.29.2">To pull this branch, run the following command or use your GUI of choice to support you in </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">this operation:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.31.1">
git switch CH08.</span></pre>
			<p><span class="koboSpan" id="kobo.32.1">The branch includes all the files updated from the </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">previous chapter.</span></span></p>
			<p><span class="koboSpan" id="kobo.34.1">The code files for the chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">at </span></span><a href="https://github.com/PacktPublishing/Vue.js-3-for-Beginners"><span class="No-Break"><span class="koboSpan" id="kobo.36.1">https://github.com/PacktPublishing/Vue.js-3-for-Beginners</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.37.1">.</span></span></p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.38.1">The testing pyramids</span></h1>
			<p><span class="koboSpan" id="kobo.39.1">Clean code, coding standards, and peer reviews are essential parts of a good application, but they </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.40.1">are not the only ones. </span><span class="koboSpan" id="kobo.40.2">In fact, a good and reliable application is not only the source of good development but also the result of a good level of testing coverage available within </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">the application.</span></span></p>
			<p><span class="koboSpan" id="kobo.42.1">Testing covers a very large spectrum. </span><span class="koboSpan" id="kobo.42.2">Some companies do very minimal tests, letting their end users be the actual testers by shipping them new code to look for bugs and errors, while others invest time and budgets in developing comprehensive sets of tests and adding them to </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">their processes.</span></span></p>
			<p><span class="koboSpan" id="kobo.44.1">Even if companies invest different amounts of time in testing, all developers can at least agree that increased testing can, on average, result in fewer bugs being shipped to the user and a more </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">flexible application.</span></span></p>
			<p><span class="koboSpan" id="kobo.46.1">Multiple levels of testing can be developed for an application, and they are divided into layers that together form a pyramid (hence the name </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.47.1">testing pyramid</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">).</span></span></p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<span class="koboSpan" id="kobo.49.1"><img src="image/B21130_08_01.jpg" alt="Figure 8.1: The testing pyramid"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.50.1">Figure 8.1: The testing pyramid</span></p>
			<p><span class="koboSpan" id="kobo.51.1">The bottom of the </span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.52.1">pyramid is where </span><strong class="old"><span class="koboSpan" id="kobo.53.1">unit tests</span></strong><span class="koboSpan" id="kobo.54.1"> are found. </span><span class="koboSpan" id="kobo.54.2">Unit tests look at a single unit, which is </span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.55.1">usually a component or a helper file. </span><span class="koboSpan" id="kobo.55.2">These tests are very fast to run and, therefore, are usually produced in </span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.56.1">large quantities. </span><span class="koboSpan" id="kobo.56.2">Then, we have </span><strong class="old"><span class="koboSpan" id="kobo.57.1">integration tests</span></strong><span class="koboSpan" id="kobo.58.1">, which are where different parts of the system are connected to ensure that all parts work together. </span><span class="koboSpan" id="kobo.58.2">An integration test could test that the method successfully adds an entry to a database, by integrating the code and the database together, hence the name </span><em class="italic"><span class="koboSpan" id="kobo.59.1">integration test</span></em><span class="koboSpan" id="kobo.60.1">. </span><span class="koboSpan" id="kobo.60.2">These tests take longer to run and require a bigger architecture, so they are expected to be used less than unit tests. </span><span class="koboSpan" id="kobo.60.3">Moving up in the pyramid, we find E2E tests. </span><span class="koboSpan" id="kobo.60.4">E2E testing encapsulates both manual tests, that are run by a quality assurance team, and automatic E2E tests that makes use of tools such as Cypress or Playwright. </span><span class="koboSpan" id="kobo.60.5">which are run manually by a quality assurance team, and automatic E2E tests are run by a tool such as Cypress or Playwright. </span><span class="koboSpan" id="kobo.60.6">An individual E2E test spans a full user journey and, due to its large scope, you will just require a few tests needed to cover your </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">full application.</span></span></p>
			<p><span class="koboSpan" id="kobo.62.1">For the scope of this book, we are going to cover unit tests and E2E tests. </span><span class="koboSpan" id="kobo.62.2">Integration tests will not be covered because their usefulness is gradually decreasing, due to the advancement of </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">E2E tools.</span></span></p>
			<p><span class="koboSpan" id="kobo.64.1">The difference in the test types is not only defined by the different bugs that they can catch but also by their “development cost” and “speed to run.” </span><span class="koboSpan" id="kobo.64.2">Let’s see how different tests perform in the </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">following diagram:</span></span></p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<span class="koboSpan" id="kobo.66.1"><img src="image/B21130_08_02_BW.jpg" alt="Figure 8.2: A comparison between the different test types"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.67.1">Figure 8.2: A comparison between the different test types</span></p>
			<p><span class="koboSpan" id="kobo.68.1">If an application only did E2E tests, it would catch bugs too late in development, slowing down the development process. </span><span class="koboSpan" id="kobo.68.2">Conversely, if an application only did unit tests, it would not pick </span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.69.1">up bugs and inconsistencies produced by different parts of the system working together, due to the fact that Unit Tests focus on a single unit and therefore cannot ensure that different part of the application work </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">as expected.</span></span></p>
			<p><span class="koboSpan" id="kobo.71.1">Tests also exhibit differences in costs. </span><span class="koboSpan" id="kobo.71.2">A test cost is measured in the amount of time and effort that it takes to write the test, as well as its “speed to run,” which refers to the amount of time a single </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">test takes.</span></span></p>
			<p><span class="koboSpan" id="kobo.73.1">In an ideal world, all aspects of tests would be performed as part of your development process. </span><span class="koboSpan" id="kobo.73.2">But this is far from the truth. </span><span class="koboSpan" id="kobo.73.3">I have worked on many projects in my career, and I can count just a handful of businesses that really took ownership of their tests, implementing the whole pyramid. </span><span class="koboSpan" id="kobo.73.4">Unfortunately, for many businesses, tests are seen as an overhead (i.e, a cost that does not directly </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">produce revenue).</span></span></p>
			<p><span class="koboSpan" id="kobo.75.1">Before moving forward to the next chapter and starting to develop our first test, it is important to try and define what makes tests worthwhile. </span><span class="koboSpan" id="kobo.75.2">We have already discussed the ability of tests to catch bugs early before they reach your clients. </span><span class="koboSpan" id="kobo.75.3">But this is not the only benefit; in fact, when asked by upper management why they should invest in tests, I usually prove my point by introducing the topic of “Increased flexibility and the reduced risk </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">of change.”</span></span></p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.77.1">Increased flexibility and the reduced risk of change</span></h2>
			<p><span class="koboSpan" id="kobo.78.1">When working on a big migration, the first task is ensuring that all E2E tests are set. </span><span class="koboSpan" id="kobo.78.2">Likewise, when developing a redesign, unit tests on the components are a must-have. </span><span class="koboSpan" id="kobo.78.3">A well-tested </span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.79.1">application does not only experience a lower level of bugs reaching the client but is also more flexible with updates. </span><span class="koboSpan" id="kobo.79.2">Knowing that you can easily test the major features of your application and quickly be informed if something has </span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.80.1">regressed or broken is a key aspect of agile development, setting your application for success and making it less risky to make changes to the </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">code base.</span></span></p>
			<p><span class="koboSpan" id="kobo.82.1">I hope this is enough to convince you to understand the importance of testing. </span><span class="koboSpan" id="kobo.82.2">It is now time to move forward and learn how to write tests within our application. </span><span class="koboSpan" id="kobo.82.3">Tests can be quite tricky to implement on existing applications, and they also have a higher initial learning curve before you get started, but the payback of this investment is invaluable for your career and your </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">code quality.</span></span></p>
			<p><span class="koboSpan" id="kobo.84.1">Let’s see how Vitest can be set up and implemented to test some components of our </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">Companion App.</span></span></p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.86.1">Unit testing with Vitest</span></h1>
			<p><span class="koboSpan" id="kobo.87.1">Vitest is one </span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.88.1">of the main unit test frameworks in the JavaScript ecosystem, and it has a syntax very </span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.89.1">similar to Jest. </span><span class="koboSpan" id="kobo.89.2">Most of the knowledge </span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.90.1">you will gain in this chapter is transferrable to other testing frameworks, as they all follow a very </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">similar structure.</span></span></p>
			<p><span class="koboSpan" id="kobo.92.1">Vitest is already set up in our application, but we will cover the basic steps required to add it to your new or </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">existing applications.</span></span></p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.94.1">Installing Vitest in your application</span></h2>
			<p><span class="koboSpan" id="kobo.95.1">The first </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.96.1">step required is the package for </span><strong class="old"><span class="koboSpan" id="kobo.97.1">Vitest</span></strong><span class="koboSpan" id="kobo.98.1"> and </span><strong class="old"><span class="koboSpan" id="kobo.99.1">Vue Test Utils</span></strong><span class="koboSpan" id="kobo.100.1">, which </span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.101.1">are, respectively, the test runner and the Vue components testing framework. </span><span class="koboSpan" id="kobo.101.2">We can achieve this by opening the terminal and running the following command in the root folder of </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">our application:</span></span></p>
			<pre class="console"><span class="koboSpan" id="kobo.103.1">
npm install -D vitest @vue/test-utils</span></pre>
			<p><span class="koboSpan" id="kobo.104.1">Now that the packages are installed, we just need to add a script to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">package.json</span></strong><span class="koboSpan" id="kobo.106.1"> file so that we can simply run it in </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">the future:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.108.1">
...
</span><span class="koboSpan" id="kobo.108.2">"scripts": {
  "dev": "vite",
  "build": "vite build",
  "preview": "vite preview",
  </span><strong class="old"><span class="koboSpan" id="kobo.109.1">"test:unit": "vitest"</span></strong><span class="koboSpan" id="kobo.110.1">
}...</span></pre>
			<p><span class="koboSpan" id="kobo.111.1">The command </span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.112.1">string used is arbitrary, but it is common practice to name it </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">"test:unit"</span></strong><span class="koboSpan" id="kobo.114.1">. </span><span class="koboSpan" id="kobo.114.2">This will allow us later to also define </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">"test:e2e"</span></strong><span class="koboSpan" id="kobo.116.1"> and clearly define the two different </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">test procedures.</span></span></p>
			<p><span class="koboSpan" id="kobo.118.1">To run Vitest, we can just run the newly created script in our terminal with </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">npm run test:unit.</span></strong><span class="koboSpan" id="kobo.120.1"> The result should be </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">the following:</span></span></p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<span class="koboSpan" id="kobo.122.1"><img src="image/B21130_08_03.jpg" alt="Figure 8.3: A terminal screenshot of the test results"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.123.1">Figure 8.3: A terminal screenshot of the test results</span></p>
			<p><span class="koboSpan" id="kobo.124.1">The console terminal should show an error message, </span><strong class="old"><span class="koboSpan" id="kobo.125.1">No test files found</span></strong><span class="koboSpan" id="kobo.126.1">. </span><span class="koboSpan" id="kobo.126.2">This is what we expected, as adding the package to the repository does not also add any tests, which need to be added manually. </span><span class="koboSpan" id="kobo.126.3">It is time to learn how to structure a test, and we will do so by testing our atoms component </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">theButton.vue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">.</span></span></p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.130.1">Writing our first unit test</span></h2>
			<p><span class="koboSpan" id="kobo.131.1">Now that </span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.132.1">everything is set, it is time to start and write our first test using our base </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">button component.</span></span></p>
			<p><span class="koboSpan" id="kobo.134.1">A unit test has a very important goal – test a single unit of your application. </span><span class="koboSpan" id="kobo.134.2">In a framework such as Vue.js, a unit is defined as a component, a composable, or a </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">store file.</span></span></p>
			<p><span class="koboSpan" id="kobo.136.1">When testing a unit of logic, you should focus on its functionality and not its static content, such as text. </span></p>
			<p><span class="koboSpan" id="kobo.137.1">Creating a text-focused test that just compare text values, such as headings and buttons, will not only provide any benefits to our application, but will also be hard to maintain , due to its flakiness (produced by the fact that the tests will have to change every time we change the copy of </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">our component).</span></span></p>
			<p><span class="koboSpan" id="kobo.139.1">Before creating </span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.140.1">our test file, let’s open </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">TheButton.vue</span></strong><span class="koboSpan" id="kobo.142.1"> and see what part of this component could </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">be tested:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.144.1">
&lt;template&gt;
&lt;button
  :class="theme"
&gt;
  {{ value }}
&lt;/button&gt;
&lt;/template&gt;
&lt;script setup&gt;
defineProps({
  value: {
    type: [String, Number],
    required: true
  },
  width: {
    type: String,
    default: "100px"
  },
  theme: {
    type: String,
    default: "light",
    validator: (value) =&gt; ["light", "dark"].includes(value)
  }
})
&lt;/script&gt;
&lt;style scoped&gt;
...
</span><span class="koboSpan" id="kobo.144.2">&lt;/style&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.145.1">Our component </span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.146.1">is a standard button and, as such, includes all the basic functionality that we would expect from one. </span><span class="koboSpan" id="kobo.146.2">A few test scenarios for this component could be </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">the following:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.148.1">Checking that the component renders successfully, ensuring that there are no mistakes in the </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">component structure</span></span></li>
				<li><span class="koboSpan" id="kobo.150.1">Checking that the default styles load </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">by default</span></span></li>
				<li><span class="koboSpan" id="kobo.152.1">Checking that the theme props work to change </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">the theme</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.154.1">These three initial tests are great for us to get started on this topic. </span><span class="koboSpan" id="kobo.154.2">As I said before, tests can have quite a steep learning curve, so it is good to start small and slowly build on </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">that knowledge.</span></span></p>
			<p><span class="koboSpan" id="kobo.156.1">It is now time to create our test files. </span><span class="koboSpan" id="kobo.156.2">Test files are named in the nameOfFileTested.spec.js format, so in our case, it would </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">be TheButton.spec.js.</span></span></p>
			<p><span class="koboSpan" id="kobo.158.1">We can create a test file in any folder we want, but it is good practice to decide a standard for the project and consistently follow it. </span><span class="koboSpan" id="kobo.158.2">In our case, we are going to create this file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">__tests__</span></strong><span class="koboSpan" id="kobo.160.1"> folder. </span><span class="koboSpan" id="kobo.160.2">The full path of the file should look </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">like this:</span></span></p>
			<pre class="console"><span class="koboSpan" id="kobo.162.1">
/src/components/__tests__/TheButton.spec.js</span></pre>
			<p><span class="koboSpan" id="kobo.163.1">Before we start discussing the test structure, we need to import a few modules that will allow us to create the test. </span><span class="koboSpan" id="kobo.163.2">We are going to import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">expect</span></strong><span class="koboSpan" id="kobo.165.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">describe</span></strong><span class="koboSpan" id="kobo.167.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">it</span></strong><strong class="old"> </strong><span class="koboSpan" id="kobo.169.1">methods from Vitest, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">mount</span></strong><span class="koboSpan" id="kobo.171.1"> method from </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">@vue/test-utils</span></strong><span class="koboSpan" id="kobo.173.1">, and finally, the component itself. </span><span class="koboSpan" id="kobo.173.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">import</span></strong><span class="koboSpan" id="kobo.175.1"> statement at the top of our test should look </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">like this:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.177.1">
import { expect, describe, it } from 'vitest'
import {mount} from "@vue/test-utils";
import component from '../atoms/TheButton.vue'</span></pre>
			<p><span class="koboSpan" id="kobo.178.1">Now that our </span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.179.1">imports are set, it is time to start to learn how to structure a test. </span><span class="koboSpan" id="kobo.179.2">The structure of tests follows a callback approach, where each method has a callback to another method, and </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">so on.</span></span></p>
			<p><span class="koboSpan" id="kobo.181.1">Even if this approach, also referred to as callback hell, is usually a sign of bad practice in JS, it is the best way to provide structure for </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">your tests.</span></span></p>
			<p><span class="koboSpan" id="kobo.183.1">To write a well-structured unit test, we can use the Given, When, and Then syntax that answers the following </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">three questions:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.185.1">What are we </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">testing (Given</span></span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">)</span></span></li>
				<li><span class="koboSpan" id="kobo.188.1">What is the </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">scenario (When)?</span></span></li>
				<li><span class="koboSpan" id="kobo.190.1">What is the expected </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">outcome (Then)?</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.192.1">We can then use </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">Given</span></strong><span class="koboSpan" id="kobo.194.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">When</span></strong><span class="koboSpan" id="kobo.196.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">Then</span></strong><span class="koboSpan" id="kobo.198.1"> to create our own test cases by creating a simple sentence. </span><span class="koboSpan" id="kobo.198.2">So, in the case of our button, the sentence could be as follows: “Given </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">TheButton.vue</span></strong><span class="koboSpan" id="kobo.200.1">, when </span><em class="italic"><span class="koboSpan" id="kobo.201.1">it is mounted</span></em><span class="koboSpan" id="kobo.202.1">, then it </span><em class="italic"><span class="koboSpan" id="kobo.203.1">should </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.204.1">render properly</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">.”</span></span></p>
			<p><span class="koboSpan" id="kobo.206.1">With the preceding sentence. </span><span class="koboSpan" id="kobo.206.2">we can now go and write our first </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">unit test.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.208.1">Write your test in words first</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.209.1">It is beneficial to break down your tests by writing them in sentences first. </span><span class="koboSpan" id="kobo.209.2">Being able to write down all the tests by just defining a single sentence for each test will help you define better tests and ensure that you cover your components fully. </span><span class="koboSpan" id="kobo.209.3">Reading and comparing a couple of sentences is simpler than doing the same after the tests </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">are written.</span></span></p>
			<p><span class="koboSpan" id="kobo.211.1">To structure our tests, we will make use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">describe</span></strong><span class="koboSpan" id="kobo.213.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">it</span></strong><span class="koboSpan" id="kobo.215.1"> methods provided </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">by Vitest:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.217.1">
describe('TheButton.vue', () =&gt; {
  describe('when mounted', () =&gt; {
    it('renders properly', () =&gt; {
      // Test goes here
    });
  });
});</span></pre>
			<p><span class="koboSpan" id="kobo.218.1">A test uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">describe</span></strong><span class="koboSpan" id="kobo.220.1"> method to define the aforementioned Given and When syntax, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">it</span></strong><span class="koboSpan" id="kobo.222.1"> method to define the actual test (</span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">Then</span></strong><span class="koboSpan" id="kobo.224.1">). </span><span class="koboSpan" id="kobo.224.2">A test can have multiple nested </span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.225.1">descriptions. </span><span class="koboSpan" id="kobo.225.2">Test names are very important because they are used by a testing framework in error messages, triggered when a test fails. </span><span class="koboSpan" id="kobo.225.3">Having a very well-structured name will help you save time if something breaks and your test fails. </span><span class="koboSpan" id="kobo.225.4">Let’s try to run our empty test for the first time and see what the output is. </span><span class="koboSpan" id="kobo.225.5">To run our tests, we need to open the terminal, access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">project </span></strong><span class="koboSpan" id="kobo.227.1">folder, and run the following </span><span class="No-Break"><strong class="old"><span class="koboSpan" id="kobo.228.1">npm </span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">command:</span></span></p>
			<pre class="console"><span class="koboSpan" id="kobo.230.1">
npm run test:unit</span></pre>
			<p><span class="koboSpan" id="kobo.231.1">The output of the preceding command should be </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">the following:</span></span></p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<span class="koboSpan" id="kobo.233.1"><img src="image/B21130_08_04.jpg" alt="Figure 8.4: The terminal output of Vitest"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.234.1">Figure 8.4: The terminal output of Vitest</span></p>
			<p><span class="koboSpan" id="kobo.235.1">The test results </span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.236.1">follow the same nested structure that we defined in our test. </span><span class="koboSpan" id="kobo.236.2">The words used within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">describe</span></strong><span class="koboSpan" id="kobo.238.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">it</span></strong><span class="koboSpan" id="kobo.240.1"> methods form a readable word. </span><span class="koboSpan" id="kobo.240.2">If an error is triggered locally or in any deployment environment, the log will display the file name, followed by the different words we used to declare our test. </span><span class="koboSpan" id="kobo.240.3">In our case it would be </span><em class="italic"><span class="koboSpan" id="kobo.241.1">TheButton.vue when mounted </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.242.1">renders properly.</span></em></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.243.1">Vitest is fast – very fast</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.244.1">In the previous section, we mentioned that unit tests are fast, but we have not mentioned that among all unit test frameworks, Vitest is the fastest of all unit test frameworks. </span><span class="koboSpan" id="kobo.244.2">Its speed is to be attributed to the Vite server on which Vitest </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">is built.</span></span></p>
			<p><span class="koboSpan" id="kobo.246.1">Our first test has not tested anything yet, as it has an empty body. </span><span class="koboSpan" id="kobo.246.2">Let’s go back and see how we can test our component. </span><span class="koboSpan" id="kobo.246.3">To complete this task, we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">mount</span></strong><span class="koboSpan" id="kobo.248.1"> method offered by Vue Test Utils and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">expect</span></strong><span class="koboSpan" id="kobo.250.1"> method, used to tell the Unit Test engine what we want </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">to test.</span></span></p>
			<p><span class="koboSpan" id="kobo.252.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">mount</span></strong><span class="koboSpan" id="kobo.254.1"> method is used to initialize a component by rendering it within the test framework, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">expect</span></strong><span class="koboSpan" id="kobo.256.1"> is used to define our </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">test cases.</span></span></p>
			<p><span class="koboSpan" id="kobo.258.1">In every test, we start by setting out our component and any state that this may require. </span><span class="koboSpan" id="kobo.258.2">In our case, we just need to </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">mount it:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.260.1">
const wrapper = mount(component, {});</span></pre>
			<p><span class="koboSpan" id="kobo.261.1">Next, we will assert that our component rendered successfully by checking whether it includes a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">button</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.263.1"> element:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.264.1">
expect(wrapper.html()).toContain('button');</span></pre>
			<p><span class="koboSpan" id="kobo.265.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">expect</span></strong><span class="koboSpan" id="kobo.267.1"> method accepts the value being tested as its argument and is then chained to the test performed on the given value. </span><span class="koboSpan" id="kobo.267.2">Vitest comes with a huge list </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">of assertions.</span></span></p>
			<p><span class="koboSpan" id="kobo.269.1">For example, if we </span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.270.1">wanted to create a test that checks if two number are equals, we would do </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">the following:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.272.1">
const numberFive = 5;
expect(numberFive).toEqual(5);</span></pre>
			<p><span class="koboSpan" id="kobo.273.1">The full test file should look </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">like this:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.275.1">
import { expect, describe, it } from 'vitest'
import component from '../atoms/TheButton.vue'
import {mount} from "@vue/test-utils";
describe('TheButton.vue', () =&gt; {
  describe('when mounted', () =&gt; {
    it('renders properly', () =&gt; {
      const wrapper = mount(component, {});
      expect(wrapper.html()).toContain('button');
    });
  });
});</span></pre>
			<p><span class="koboSpan" id="kobo.276.1">So, to recap, we learned that tests follow a very structured approach. </span><span class="koboSpan" id="kobo.276.2">They require us to define what we are testing, and the scenario and assertion that we </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">are considering.</span></span></p>
			<p><span class="koboSpan" id="kobo.278.1">Let’s add another test that would create the following test sentence: “Given </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">TheButton.vue</span></strong><span class="koboSpan" id="kobo.280.1">, when </span><em class="italic"><span class="koboSpan" id="kobo.281.1">it is mounted</span></em><span class="koboSpan" id="kobo.282.1">, then it </span><em class="italic"><span class="koboSpan" id="kobo.283.1">defaults to the </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.284.1">light theme</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">.”</span></span></p>
			<p><span class="koboSpan" id="kobo.286.1">As you can see from the first two parts of the sentence, </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">Given</span></strong><span class="koboSpan" id="kobo.288.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">When</span></strong><span class="koboSpan" id="kobo.290.1"> are the same, so this means that we can reuse the existing code blocks and just add </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">another test.</span></span></p>
			<p><span class="koboSpan" id="kobo.292.1">To check whether </span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.293.1">the correct theme is applied, we will check whether the CSS class </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">light</span></strong><span class="koboSpan" id="kobo.295.1"> has been applied to </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">the component.</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.297.1">
import { expect, describe, it } from 'vitest'
import component from '../atoms/TheButton.vue'
import {mount} from "@vue/test-utils";
describe('TheButton.vue', () =&gt; {
  describe('when mounted', () =&gt; {
    it('renders properly', () =&gt; {
      const wrapper = mount(component, {});
      expect(wrapper.html()).toContain('button');
    });
    </span><strong class="old"><span class="koboSpan" id="kobo.298.1">it('defaults to light theme', () =&gt; {</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.299.1">      const wrapper = mount(component, {});</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.300.1">      expect(wrapper.classes()).toContain('light');</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.301.1">    });</span></strong><span class="koboSpan" id="kobo.302.1">
  });
});</span></pre>
			<p><span class="koboSpan" id="kobo.303.1">As shown by the highlighted text in the preceding code block, adding extra tests that follow the same setup is quite simple. </span><span class="koboSpan" id="kobo.303.2">To complete the new test, we used </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">mount</span></strong><span class="koboSpan" id="kobo.305.1"> again to initialize a version of our component. </span><span class="koboSpan" id="kobo.305.2">We then used </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">wrapper.classes()</span></strong><span class="koboSpan" id="kobo.307.1"> to extract all the classes of the component and asserted this to contain </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">light</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.309.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">expect().toContain().</span></strong></span></p>
			<p><span class="koboSpan" id="kobo.311.1">Due to the fact that both of the tests have the same When, we were able to reuse the describe method </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">describe('when mounted'..)</span></strong><span class="koboSpan" id="kobo.313.1">. </span><span class="koboSpan" id="kobo.313.2">Doing so will help us break up </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">tests logically.</span></span></p>
			<p><span class="koboSpan" id="kobo.315.1">The tests are automatically updated, so when the file is saved, our terminal should output the new result with two </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">passing tests:</span></span></p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<span class="koboSpan" id="kobo.317.1"><img src="image/B21130_08_05.jpg" alt="Figure 8.5: The Vitest test results showing two passing tests"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.318.1">Figure 8.5: The Vitest test results showing two passing tests</span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.319.1">Your turn</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.320.1">Write the last unit test to complete the testing of </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">TheButton.vue</span></strong><span class="koboSpan" id="kobo.322.1">. </span><span class="koboSpan" id="kobo.322.2">The last test should test that the component renders the dark theme when the correct properties are passed. </span><span class="koboSpan" id="kobo.322.3">Research Vue Test Utils and the Vitest documentation to learn how to define properties when mounting a component. </span><span class="koboSpan" id="kobo.322.4">Next chapter branch will include the test for you, so that you can check if your test was </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">written correctly.</span></span></p>
			<p><span class="koboSpan" id="kobo.324.1">Unit tests are </span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.325.1">a big topic, and this was just a very simple introduction to give you some necessary initial information. </span><span class="koboSpan" id="kobo.325.2">Each project will create tests that are slightly different, either because of the project structure, the breakdown of components, or even the naming convention used. </span><span class="koboSpan" id="kobo.325.3">For this reason, the best way to truly learn how to write tests is </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">to practice.</span></span></p>
			<p><span class="koboSpan" id="kobo.327.1">Before we move forward, I want to share one more tip to ensure you test your code correctly. </span><span class="koboSpan" id="kobo.327.2">In fact, it is common when writing unit tests to make them too dependent on the inside of a component. </span><span class="koboSpan" id="kobo.327.3">A unit test is expected to test what a single unit of code would </span><strong class="old"><span class="koboSpan" id="kobo.328.1">output</span></strong><span class="koboSpan" id="kobo.329.1"> when given a specific </span><strong class="old"><span class="koboSpan" id="kobo.330.1">input</span></strong><span class="koboSpan" id="kobo.331.1">. </span><span class="koboSpan" id="kobo.331.2">What this means is that you should be able to test a component without the need to open the file, just by knowing the properties it accepts and the UI/events that it emits. </span><span class="koboSpan" id="kobo.331.3">When writing your unit tests, always focus on the input and output, and leave the implementation details out of </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">your test.</span></span></p>
			<p><span class="koboSpan" id="kobo.333.1">In this section, we introduced unit tests and discussed how to use Vitest to test our component. </span><span class="koboSpan" id="kobo.333.2">We learned the syntax required to write a unit test and introduced Vue Test Utils to help </span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.334.1">us work with our Vue component. </span><span class="koboSpan" id="kobo.334.2">Then, we covered the importance of the test name and how this follows the Given, When, and </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">Then methodology.</span></span></p>
			<p><span class="koboSpan" id="kobo.336.1">In the next section, we will ascend the pyramid and learn to write E2E tests. </span><span class="koboSpan" id="kobo.336.2">We will be able to reuse some of the knowledge we learned in this section and continue to learn how to make our code </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">more reliable.</span></span></p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.338.1">E2E tests with Cypress</span></h1>
			<p><span class="koboSpan" id="kobo.339.1">It is time to move our testing focus from a micro level, offered by unit tests, to a macro level, provided </span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.340.1">by E2E tests. </span><span class="koboSpan" id="kobo.340.2">If unit tests focus on a single state of a single component, E2E will help us test a complete </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">user journey.</span></span></p>
			<p><span class="koboSpan" id="kobo.342.1">As I mentioned previously, we will be able to use some of the knowledge that we learned in </span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.343.1">the previous section, since E2E tests follow a similar structure to the ones we learned about </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">in Vitest.</span></span></p>
			<p><span class="koboSpan" id="kobo.345.1">Let’s break down this section into three different parts. </span><span class="koboSpan" id="kobo.345.2">First, we are going to learn how to install </span><strong class="old"><span class="koboSpan" id="kobo.346.1">Cypress</span></strong><span class="koboSpan" id="kobo.347.1"> in your </span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.348.1">application. </span><span class="koboSpan" id="kobo.348.2">Then, we will learn the basic structure of an E2E test file and its placement within a project. </span><span class="koboSpan" id="kobo.348.3">Lastly, we will end the section by writing an E2E test for </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">our application.</span></span></p>
			<p><span class="koboSpan" id="kobo.350.1">The most used E2E tools within the JS industry are Cypress and Playwright. </span><span class="koboSpan" id="kobo.350.2">Cypress has been around for quite a few years, and it currently holds a very large section of the market. </span><span class="koboSpan" id="kobo.350.3">Playwright is a little newer, but it is gaining a lot of market share due to its integration with IDEs and extensive </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">browser emulation.</span></span></p>
			<p><span class="koboSpan" id="kobo.352.1">Just like unit tests, the syntax of the different players on the market is very similar, so most of the features and syntax that you learn in one could be used in another one if you later decide </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">to switch.</span></span></p>
			<p><span class="koboSpan" id="kobo.354.1">Let’s start by installing Cypress into </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">your project.</span></span></p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.356.1">Installing Cypress into your project</span></h2>
			<p><span class="koboSpan" id="kobo.357.1">Today’s JS ecosystem offers us tools with amazing user experiences that offer very simple </span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.358.1">installation processes, and Cypress is one </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">of those.</span></span></p>
			<p><span class="koboSpan" id="kobo.360.1">Our Companion App already includes a set of tests, and they are installed by the Vue project initialization that we introduced in </span><a href="B21130_03.xhtml#_idTextAnchor039"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.361.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.362.1">. </span><span class="koboSpan" id="kobo.362.2">However, it is helpful to learn how to add Cypress to your new or existing project. </span><span class="koboSpan" id="kobo.362.3">Due to the fact that Cypress is already part of the Companion App, you would have to follow the following steps in a </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">new folder.</span></span></p>
			<p><span class="koboSpan" id="kobo.364.1">The official </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.365.1">documentation provided at </span><a href="http://cypress.io"><span class="koboSpan" id="kobo.366.1">cypress.io</span></a><span class="koboSpan" id="kobo.367.1"> offers </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.368.1">two installation methods, a </span><strong class="old"><span class="koboSpan" id="kobo.369.1">direct download</span></strong><span class="koboSpan" id="kobo.370.1"> and an </span><span class="No-Break"><strong class="old"><span class="koboSpan" id="kobo.371.1">npm installation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.373.1">We are going to follow the installation using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">npm</span></strong><span class="koboSpan" id="kobo.375.1"> package manager. </span><span class="koboSpan" id="kobo.375.2">To initialize this, access the root folder of your project in your preferred terminal and type the </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">following command:</span></span></p>
			<pre class="console"><span class="koboSpan" id="kobo.377.1">
npm install cypress</span></pre>
			<p><span class="koboSpan" id="kobo.378.1">The next step is to run Cypress. </span><span class="koboSpan" id="kobo.378.2">This can be achieved with the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">npx</span></strong><span class="koboSpan" id="kobo.380.1"> command (note that the command is </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">npx</span></strong><span class="koboSpan" id="kobo.382.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">not </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">npm</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">):</span></span></p>
			<pre class="console"><span class="koboSpan" id="kobo.386.1">
npx cypress open</span></pre>
			<p><span class="koboSpan" id="kobo.387.1">After a few seconds, you should be presented with a </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">welcome screen.</span></span></p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<span class="koboSpan" id="kobo.389.1"><img src="image/B21130_08_06.jpg" alt="Figure 8.6: Cypress’s opening dashboard"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.390.1">Figure 8.6: Cypress’s opening dashboard</span></p>
			<p><span class="koboSpan" id="kobo.391.1">Cypress can be </span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.392.1">set up for E2E and component testing. </span><span class="koboSpan" id="kobo.392.2">The wizard in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.393.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.394.1">.6</span></em><span class="koboSpan" id="kobo.395.1"> marks our test as </span><strong class="old"><span class="koboSpan" id="kobo.396.1">Not Configured</span></strong><span class="koboSpan" id="kobo.397.1">. </span><span class="koboSpan" id="kobo.397.2">Let’s begin the configuration of the E2E testing by clicking on the left block. </span><span class="koboSpan" id="kobo.397.3">Doing so will generate a set of example files that we will need to run our </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">first test.</span></span></p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<span class="koboSpan" id="kobo.399.1"><img src="image/B21130_08_07.jpg" alt="Figure 8.7: The Cypress wizard test file creation"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.400.1">Figure 8.7: The Cypress wizard test file creation</span></p>
			<p><span class="koboSpan" id="kobo.401.1">The wizard has </span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.402.1">created four files. </span><span class="koboSpan" id="kobo.402.2">The first is the main configuration file that is hosted in the root of our project under the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">cypress.config.js</span></strong><span class="koboSpan" id="kobo.404.1">, which includes all the settings related to Cypress. </span><span class="koboSpan" id="kobo.404.2">The second and third are example files for support that are used to create reusable commands; commands are for more advanced users and are not covered in this book. </span><span class="koboSpan" id="kobo.404.3">The last file is a fixture example JSON, accessible at </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">cypress/fixtures/example.json</span></strong><span class="koboSpan" id="kobo.406.1">. </span><span class="koboSpan" id="kobo.406.2">Fixture files are used to save reusable information, such as text input or an </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">API response.</span></span></p>
			<p><span class="koboSpan" id="kobo.408.1">If we continue our journey within the installation wizard, we will be presented with the browser selector screen. </span><span class="koboSpan" id="kobo.408.2">This screen will be displayed every time you run Cypress and allows you to select which browser you want </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">to use.</span></span></p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<span class="koboSpan" id="kobo.410.1"><img src="image/B21130_08_08.jpg" alt="Figure 8.8: Cypress’s Choose a browser screen"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.411.1">Figure 8.8: Cypress’s Choose a browser screen</span></p>
			<p><span class="koboSpan" id="kobo.412.1">Let’s open </span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.413.1">the test runner by clicking </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">on Chrome.</span></span></p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<span class="koboSpan" id="kobo.415.1"><img src="image/B21130_08_09.jpg" alt="Figure 8.9: The first instance of Cypress’s chrome test runner"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.416.1">Figure 8.9: The first instance of Cypress’s chrome test runner</span></p>
			<p><span class="koboSpan" id="kobo.417.1">Since we chose Chrome as our test runner, we will start in a new Chrome window. </span><span class="koboSpan" id="kobo.417.2">This runner will offer us the ability to create example tests or generate a </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">test template.</span></span></p>
			<p><span class="koboSpan" id="kobo.419.1">We are going to stop at this point in the installation wizard; it is time to return to our Companion App </span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.420.1">and continue our journey there to learn more about E2E tests </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">and Cypress.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.422.1">Installing and reading the example tests</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.423.1">The tests provided by the “scaffold example specs” are very extensive and well-written. </span><span class="koboSpan" id="kobo.423.2">These sample tests provide you with an amazing insight into what E2E tests can achieve. </span><span class="koboSpan" id="kobo.423.3">Spend a few minutes installing and reading through these tests before moving on to the </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">next chapter.</span></span></p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.425.1">Learning the E2E tests’ file format and file location</span></h2>
			<p><span class="koboSpan" id="kobo.426.1">In the previous section, we learned how to install Cypress into our projects. </span><span class="koboSpan" id="kobo.426.2">In this section, we will </span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.427.1">learn the file location and format of these E2E </span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.428.1">test files before moving on to create our first test. </span><span class="koboSpan" id="kobo.428.2">Remember that we are now working within our Companion App, so you should go and open it with your IDE </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">of choice.</span></span></p>
			<p><span class="koboSpan" id="kobo.430.1">The location of our E2E tests is defined within the Cypress configuration file. </span><span class="koboSpan" id="kobo.430.2">As we learned from the previous section, this is located at the root of our application and is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">cypress.config.js</span></strong><span class="koboSpan" id="kobo.432.1">. </span><span class="koboSpan" id="kobo.432.2">This file includes a couple of settings, one of which is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">specPattern</span></strong><span class="koboSpan" id="kobo.434.1">. </span><span class="koboSpan" id="kobo.434.2">This configuration setting informs Cypress where to find </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">the tests:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.436.1">
specPattern: 'cypress/e2e/**/*.{cy,spec}.{js,jsx,ts,tsx}'</span></pre>
			<p><span class="koboSpan" id="kobo.437.1">This pattern expects the E2E files to be located within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">cypress/e2e</span></strong><span class="koboSpan" id="kobo.439.1"> folder and for the filename to end with a combination of </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">cy,spec</span></strong><span class="koboSpan" id="kobo.441.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">js, jsx, ts </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">and tsx</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.445.1">So, a test file could be called </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">mytest.spec.ts</span></strong><span class="koboSpan" id="kobo.447.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">mytest.cy.js</span></strong><span class="koboSpan" id="kobo.449.1">, and if it is within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">cypress/e2e</span></strong><span class="koboSpan" id="kobo.451.1"> folder, the Cypress test runner will be able to see and </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">utilize it.</span></span></p>
			<p><span class="koboSpan" id="kobo.453.1">Let’s go and create our first test, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">homepage</span></strong><span class="koboSpan" id="kobo.455.1">. </span><span class="koboSpan" id="kobo.455.2">Because I want to distinguish between unit tests and E2E tests, I will end this file with </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">cy.js</span></strong><span class="koboSpan" id="kobo.457.1"> (the unit tests end in </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">spec.js</span></strong><span class="koboSpan" id="kobo.459.1">). </span><span class="koboSpan" id="kobo.459.2">The full location of the new file would be </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">as follows:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.461.1">
Cypress/e2e/homepage.cy.js</span></pre>
			<p><span class="koboSpan" id="kobo.462.1">Now that the file has been created, it is time to learn how to structure these files. </span><span class="koboSpan" id="kobo.462.2">As I previously mentioned, there are some similarities between E2E and unit tests’ structures. </span><span class="koboSpan" id="kobo.462.3">In fact, both tests follow the same syntax, with a structure based on callbacks and methods called </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">describe</span></strong><span class="koboSpan" id="kobo.464.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">it</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">, respectively.</span></span></p>
			<p><span class="koboSpan" id="kobo.467.1">A Test scaffold should look </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">like this:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.469.1">
describe('Homepage', () =&gt; {
  it('default journey', () =&gt; {});
});</span></pre>
			<p><span class="koboSpan" id="kobo.470.1">As you can see, the code structure is noticeable, like the one offered by Vitest, with the only difference being that, in this case, we do not need to import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">describe</span></strong><span class="koboSpan" id="kobo.472.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">it</span></strong><span class="koboSpan" id="kobo.474.1"> methods, as they are automatically imported </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">for us.</span></span></p>
			<p><span class="koboSpan" id="kobo.476.1">Another small </span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.477.1">difference is the name of the test. </span><span class="koboSpan" id="kobo.477.2">When we </span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.478.1">defined a name in a unit test, it was a very important part of the test, with the well-defined </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">Given</span></strong><span class="koboSpan" id="kobo.480.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">When</span></strong><span class="koboSpan" id="kobo.482.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">Then</span></strong><span class="koboSpan" id="kobo.484.1"> methodology. </span><span class="koboSpan" id="kobo.484.2">In E2E tests, names are a little less important, mainly because these tests can have a large scope, such as a full check of the home page, and providing a single sentence to define what we are testing is not </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">always possible.</span></span></p>
			<p><span class="koboSpan" id="kobo.486.1">Before we move forward, we are going to try and run E2E tests in our application and learn the steps required to </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">do so.</span></span></p>
			<p><span class="koboSpan" id="kobo.488.1">In the previous section, we used </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">npx cypress open</span></strong><span class="koboSpan" id="kobo.490.1"> to start Cypress. </span><span class="koboSpan" id="kobo.490.2">This can still be used, but our </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">package.json</span></strong><span class="koboSpan" id="kobo.492.1"> has a couple of scripts ready for us to use that come with extra configurations, simplifying our </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">development experience:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.494.1">
"test:e2e": "start-server-and-test preview http://localhost:4173 'cypress run --e2e'",
"test:e2e:dev": "start-server-and-test 'vite dev --port 4173' http://localhost:4173 'cypress open --e2e'"</span></pre>
			<p><span class="koboSpan" id="kobo.495.1">The application offers two scripts, </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">"test:e2e"</span></strong><span class="koboSpan" id="kobo.497.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">"test:e2e:dev"</span></strong><span class="koboSpan" id="kobo.499.1">. </span><span class="koboSpan" id="kobo.499.2">The first is used to run E2E on a preview build, while the second is used to run the test on a development build with </span><strong class="old"><span class="koboSpan" id="kobo.500.1">hot reload</span></strong><span class="koboSpan" id="kobo.501.1">. </span><span class="koboSpan" id="kobo.501.2">This will allow us to make modifications to our application while the E2E test runner is ready </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">to run.</span></span></p>
			<p><span class="koboSpan" id="kobo.503.1">Try to run the development E2E test environment by running the following command in </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">the terminal:</span></span></p>
			<pre class="console"><span class="koboSpan" id="kobo.505.1">
npm run test:e2e:dev</span></pre>
			<p><span class="koboSpan" id="kobo.506.1">The result of this command should be the Cypress dashboard that we saw before. </span><span class="koboSpan" id="kobo.506.2">Just like before, you should click on </span><strong class="old"><span class="koboSpan" id="kobo.507.1">E2E tests</span></strong><span class="koboSpan" id="kobo.508.1"> and choose </span><strong class="old"><span class="koboSpan" id="kobo.509.1">Chrome</span></strong><span class="koboSpan" id="kobo.510.1"> as the browser to run </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">our tests.</span></span></p>
			<p><span class="koboSpan" id="kobo.512.1">The result </span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.513.1">should be a Chrome browser, as shown in the </span><a id="_idIndexMarker419"/><span class="No-Break"><span class="koboSpan" id="kobo.514.1">following screenshot:</span></span></p>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<span class="koboSpan" id="kobo.515.1"><img src="image/B21130_08_10.jpg" alt="Figure 8.10: The Cypress test dashboard in Chrome"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.516.1">Figure 8.10: The Cypress test dashboard in Chrome</span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.517.1">Browse around</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.518.1">Before continuing the chapter, you should spend a couple of minutes to familiarize yourself with the test runner. </span><span class="koboSpan" id="kobo.518.2">Knowing what it has to offer and how it works will be very beneficial for what you learn in the future and your usage of </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">E2E tests.</span></span></p>
			<p><span class="koboSpan" id="kobo.520.1">To run our test, click on the test name, </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">homepage.cy.js</span></strong><span class="koboSpan" id="kobo.522.1">. </span><span class="koboSpan" id="kobo.522.2">This will load the Cypress </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">test runner:</span></span></p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<span class="koboSpan" id="kobo.524.1"><img src="image/B21130_08_11.jpg" alt="Figure 8.11: The Cypress test runner"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.525.1">Figure 8.11: The Cypress test runner</span></p>
			<p><span class="koboSpan" id="kobo.526.1">Currently, the test </span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.527.1">runner is not very useful, as the only test </span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.528.1">we have </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">is empty.</span></span></p>
			<p><span class="koboSpan" id="kobo.530.1">Now, it’s time to move on to the next section, where we will write our first test </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">in Cypress.</span></span></p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.532.1">Writing your first E2E test</span></h2>
			<p><span class="koboSpan" id="kobo.533.1">E2E tests are </span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.534.1">usually referred to as a </span><strong class="old"><span class="koboSpan" id="kobo.535.1">journey</span></strong><span class="koboSpan" id="kobo.536.1">. </span><span class="koboSpan" id="kobo.536.2">The name is derived from the fact that it encapsulates a specific user’s journey. </span><span class="koboSpan" id="kobo.536.3">These could be the steps required to complete a </span><strong class="old"><span class="koboSpan" id="kobo.537.1">contact us</span></strong><span class="koboSpan" id="kobo.538.1"> form, or the ones required to buy </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">a product.</span></span></p>
			<p><span class="koboSpan" id="kobo.540.1">Due to the size of our current application, the journey will be quite small, but it can still be useful to ensure we build a </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">stable application.</span></span></p>
			<p><span class="koboSpan" id="kobo.542.1">Our test will complete the </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">following aspects:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.544.1">Accessing </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">the site</span></span></li>
				<li><span class="koboSpan" id="kobo.546.1">Displaying the </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">app title</span></span></li>
				<li><span class="koboSpan" id="kobo.548.1">Ensuring that posts </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">are loaded</span></span></li>
				<li><span class="koboSpan" id="kobo.550.1">Checking whether a post that has no comments, show the correct </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">empty message</span></span></li>
				<li><span class="koboSpan" id="kobo.552.1">Checking whether a post that has comments displays </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">them correctly.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.554.1">E2E tests are written sequentially, in the same way that you would complete the same journey manually. </span><span class="koboSpan" id="kobo.554.2">So, we are going to start our test by accessing the site on the main page. </span><span class="koboSpan" id="kobo.554.3">This is done by using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">cy.visit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.556.1"> command:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.557.1">
describe('Homepage', () =&gt; {
  it('default journey', () =&gt; {
    cy.visit('/');
  });
});</span></pre>
			<p><span class="koboSpan" id="kobo.558.1">When using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">visit</span></strong><span class="koboSpan" id="kobo.560.1"> command, you can pass any relative URL. </span><span class="koboSpan" id="kobo.560.2">In our scenario, we will just </span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.561.1">pass a forward slash, as we are going to visit the </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">home page.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.563.1">A base URL preset</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.564.1">Note that we were able to visit the home page by using a single forward slash because we have set a </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">baseUrl</span></strong><span class="koboSpan" id="kobo.566.1"> preset within </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">cypress.config.js</span></strong><span class="koboSpan" id="kobo.568.1">. </span><span class="koboSpan" id="kobo.568.2">Without the </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">baseUrl</span></strong><span class="koboSpan" id="kobo.570.1"> setting, you would have had to insert the full URL within the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">cy.visit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.572.1"> command.</span></span></p>
			<p><span class="koboSpan" id="kobo.573.1">Next, we are going to check for the presence of the title </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">Companion App</span></strong><span class="koboSpan" id="kobo.575.1">. </span><span class="koboSpan" id="kobo.575.2">This is achieved using two new methods, </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">get</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.577.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">should</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.580.1">
...
</span><span class="koboSpan" id="kobo.580.2">cy.visit('/');
</span><strong class="old"><span class="koboSpan" id="kobo.581.1">cy.get('h1').should('be.visible');</span></strong><span class="koboSpan" id="kobo.582.1">
...</span></pre>
			<p><span class="koboSpan" id="kobo.583.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">get</span></strong><span class="koboSpan" id="kobo.585.1"> method is just like </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">document.querySelector</span></strong><span class="koboSpan" id="kobo.587.1"> and allows you to select a given element on a page. </span><span class="koboSpan" id="kobo.587.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">should</span></strong><span class="koboSpan" id="kobo.589.1"> method allows you to set an expectation – that is, what defines a test as a pass or a fail. </span><span class="koboSpan" id="kobo.589.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">should</span></strong><span class="koboSpan" id="kobo.591.1"> method accepts a parameter that is the logic by </span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.592.1">which we test our selector. </span><span class="koboSpan" id="kobo.592.2">These parameters are called </span><strong class="old"><span class="koboSpan" id="kobo.593.1">chainers</span></strong><span class="koboSpan" id="kobo.594.1"> and have hundreds of different possibilities. </span><span class="koboSpan" id="kobo.594.2">The best way to learn all the available </span><strong class="old"><span class="koboSpan" id="kobo.595.1">chainers </span></strong><span class="koboSpan" id="kobo.596.1">is to either access the documentation (</span><a href="https://docs.cypress.io/guides/references/assertions"><span class="koboSpan" id="kobo.597.1">https://docs.cypress.io/guides/references/assertions</span></a><span class="koboSpan" id="kobo.598.1">) or use the </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">IntelliSense IDE.</span></span></p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<span class="koboSpan" id="kobo.600.1"><img src="image/B21130_08_12.jpg" alt="Figure 8.12: An IntelliSense pop-up of chainers"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.601.1">Figure 8.12: An IntelliSense pop-up of chainers</span></p>
			<p><span class="koboSpan" id="kobo.602.1">A list of chainers is displayed automatically within your IDE while you write your </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">test expectation.</span></span></p>
			<p><span class="koboSpan" id="kobo.604.1">Whether you </span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.605.1">use the documentation or the IDE, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.606.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.607.1">.12</span></em><span class="koboSpan" id="kobo.608.1">, all that really matters is that you familiarize yourself with these different chainers and understand what you can and </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">cannot use.</span></span></p>
			<p><span class="koboSpan" id="kobo.610.1">In the preceding example, we just passed a single argument when calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">should</span></strong><span class="koboSpan" id="kobo.612.1"> method, but it can also accept two arguments. </span><span class="koboSpan" id="kobo.612.2">The second argument is used to pass a value when the condition defined in the first argument requires one. </span><span class="koboSpan" id="kobo.612.3">For example, we could be comparing the number of elements on screen with a variable, comparing two strings, or ensuring that the value returned by the API matches a specific object. </span><span class="koboSpan" id="kobo.612.4">In our current test, we just check that </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">&lt;H1&gt;</span></strong><span class="koboSpan" id="kobo.614.1"> exists, but we are not really checking whether it is the correct heading, so we could change our implementation to use </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">two arguments:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.616.1">
...
</span><span class="koboSpan" id="kobo.616.2">cy.visit('/');
cy.get('h1').should('contain.text', 'Companion App');
...</span></pre>
			<p><span class="koboSpan" id="kobo.617.1">When using </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">contain.text</span></strong><span class="koboSpan" id="kobo.619.1">, we compare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">innerText</span></strong><span class="koboSpan" id="kobo.621.1"> string of the element we selected with an </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">arbitrary value.</span></span></p>
			<p><span class="koboSpan" id="kobo.623.1">The next step of our E2E test will be to ensure that the posts load successfully, by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">get</span></strong><span class="koboSpan" id="kobo.625.1"> method to fetch the element and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">have.length</span></strong><span class="koboSpan" id="kobo.627.1"> chainer to ensure that the result value is what </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">we expected:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.629.1">
...
</span><span class="koboSpan" id="kobo.629.2">cy.get('h1').should('contain.text', 'Companion App');
</span><strong class="old"><span class="koboSpan" id="kobo.630.1">cy.get('.SocialPost').should('have.length', 5);</span></strong><span class="koboSpan" id="kobo.631.1">
...</span></pre>
			<p><span class="koboSpan" id="kobo.632.1">When the application loads correctly, it will load five posts, and to check this in our test, we select all the elements that have a class of </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">SocialPost</span></strong><span class="koboSpan" id="kobo.634.1"> and compare their lengths, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">should('have.length', </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">value)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.637.1"> syntax.</span></span></p>
			<p><span class="koboSpan" id="kobo.638.1">Next, we will </span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.639.1">need to test the comment component. </span><span class="koboSpan" id="kobo.639.2">We will achieve this by clicking the </span><strong class="old"><span class="koboSpan" id="kobo.640.1">Show comment</span></strong><span class="koboSpan" id="kobo.641.1"> button. </span><span class="koboSpan" id="kobo.641.2">If we check the HTML of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">SocialPost.vue</span></strong><span class="koboSpan" id="kobo.643.1"> component, we would find out that the best way to find the button is to use a large selector, </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">.SocialPost .interactions button</span></strong><span class="koboSpan" id="kobo.645.1">. </span><span class="koboSpan" id="kobo.645.2">This selector is not an optimal solution, not only because it is very verbose, but also because it is too dependent on the structure of the component and, therefore, very fragile. </span><span class="koboSpan" id="kobo.645.3">To avoid using complex selection, we can add an E2E attribute. </span><span class="koboSpan" id="kobo.645.4">This is usually defined by adding a </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">data-cy</span></strong><span class="koboSpan" id="kobo.647.1"> attribute to an element and using it for testing purposes (</span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">cy</span></strong><span class="koboSpan" id="kobo.649.1"> in the data stands </span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">for cypress).</span></span></p>
			<p><span class="koboSpan" id="kobo.651.1">Adding a data attribute to your code will make your test more robust, avoiding the creation of flaky tests associated with changes in CSS classes and HTML </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">element structure.</span></span></p>
			<p><span class="koboSpan" id="kobo.653.1">Before continuing with our test, let’s open </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">SocialPost.vue</span></strong><span class="koboSpan" id="kobo.655.1"> and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">required attribute:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.657.1">
&lt;TheButton
  @click="onShowCommentClick"
  value="Show comment"
  width="auto"
  theme="dark"
</span><strong class="old"><span class="koboSpan" id="kobo.658.1">  data-cy="showCommentButton"</span></strong><span class="koboSpan" id="kobo.659.1">
/&gt;</span></pre>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">data-cy</span></strong><span class="koboSpan" id="kobo.661.1"> is just a simple data attribute, but it is industry-standard and is used by many developers to provide a direct selector for E2E tests. </span><span class="koboSpan" id="kobo.661.2">We are now able to update our test to use the newly declared </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">showCommentButton </span></strong><span class="koboSpan" id="kobo.663.1">attributeto select </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">our button:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.665.1">
cy.get('.SocialPost').should('have.length', 5);
</span><strong class="old"><span class="koboSpan" id="kobo.666.1">cy.get('[data-cy="showCommentButton"]').first().click();</span></strong></pre>
			<p><span class="koboSpan" id="kobo.667.1">Since we have five posts on the page but just want to click on the first one, we will use a helper method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">first</span></strong><span class="koboSpan" id="kobo.669.1"> that is used to retrieve just the first element returned by </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">get()</span></strong><span class="koboSpan" id="kobo.671.1">. </span><span class="koboSpan" id="kobo.671.2">Then, we end the chain by calling a </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">click</span></strong><span class="koboSpan" id="kobo.673.1"> method to emulate a mouse click on the button. </span><span class="koboSpan" id="kobo.673.2">The result should be the comment </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">component loaded.</span></span></p>
			<p><span class="koboSpan" id="kobo.675.1">If you check </span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.676.1">the browser window displaying our test runner, you should be able to see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">comment</span></strong><span class="koboSpan" id="kobo.678.1"> component loaded in the </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">first element.</span></span></p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<span class="koboSpan" id="kobo.680.1"><img src="image/B21130_08_13.jpg" alt="Figure 8.13: A Cypress test showing the Companion App with the comments loaded"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.681.1">Figure 8.13: A Cypress test showing the Companion App with the comments loaded</span></p>
			<p><span class="koboSpan" id="kobo.682.1">Next, we are going to use the knowledge we learned in the last section to test the correct rendering of posts with comments. </span><span class="koboSpan" id="kobo.682.2">As shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.683.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.684.1">.13</span></em><span class="koboSpan" id="kobo.685.1">, the first post has no comments. </span><span class="koboSpan" id="kobo.685.2">To better increase our coverage, we should also find a post with comments. </span><span class="koboSpan" id="kobo.685.3">A post with a comment is found in the last post (number 5), so we can use that to ensure that the comments are </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">correctly displayed.</span></span></p>
			<p><span class="koboSpan" id="kobo.687.1">Based on what we have learned, we should be able to write a test that looks </span><span class="No-Break"><span class="koboSpan" id="kobo.688.1">like this:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.689.1">
cy.get('[data-cy="showCommentButton"]').first().click();
</span><strong class="old"><span class="koboSpan" id="kobo.690.1">cy.get('.SocialPostComments').should('contain.text', 'There are no comments for this post!');</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.691.1">cy.get('[data-cy="showCommentButton"]').last().click();</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.692.1">cy.get('.SocialPostComments').last().should('not.contain.text', 'There are no comments for this post!');</span></strong></pre>
			<p><span class="koboSpan" id="kobo.693.1">The code displays three commands. </span><span class="koboSpan" id="kobo.693.2">The first checks the content of the social post comment component. </span><span class="koboSpan" id="kobo.693.3">We are using the main class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">.SocialPostComments</span></strong><span class="koboSpan" id="kobo.695.1">, to select the component and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">contain.text</span></strong><span class="koboSpan" id="kobo.697.1"> command. </span><span class="koboSpan" id="kobo.697.2">This command checks the </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">innerText</span></strong><span class="koboSpan" id="kobo.699.1">  string of that selector and compares it with a string that is passed as an argument. </span><span class="koboSpan" id="kobo.699.2">In our case, we passed </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">There are no comments for this post!</span></strong><span class="koboSpan" id="kobo.701.1">. </span><span class="koboSpan" id="kobo.701.2">Then, we clicked the last post by replicating the command we previously used and replaced </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">first()</span></strong><span class="koboSpan" id="kobo.703.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">last()</span></strong><span class="koboSpan" id="kobo.705.1">. </span><span class="koboSpan" id="kobo.705.2">Lastly, we again replicated the command we recently used to check the content of the string, and we checked the opposite by adding the word </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">not</span></strong><span class="koboSpan" id="kobo.707.1"> in front of the chainer. </span><span class="koboSpan" id="kobo.707.2">It is common when creating E2E tests to have commands that test something (e.g., a string or a number), and then a command that tests that that </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.708.1">assertion does not happen again. </span><span class="koboSpan" id="kobo.708.2">Because of this recurring scenario, the E2E framework provides you the ability to add the word </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">not</span></strong><span class="koboSpan" id="kobo.710.1"> in front of the chainer to check for the opposite. </span><span class="koboSpan" id="kobo.710.2">So, if this </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">should('contain.text', 'hello')</span></strong><span class="koboSpan" id="kobo.712.1"> checks whether the element includes the word </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">hello</span></strong><span class="koboSpan" id="kobo.714.1">, then </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">should('not.contain.text', 'hello')</span></strong><span class="koboSpan" id="kobo.716.1"> checks for the opposite – that is, to make sure that the element selected does not contain the </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">word </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">hello</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.720.1">This is the end of our E2E journey. </span><span class="koboSpan" id="kobo.720.2">In the next section, we are going to introduce advanced techniques that have not yet been covered in this chapter but may turn out to be very useful for your future </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">testing experience.</span></span></p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.722.1">Introducing advanced testing techniques</span></h1>
			<p><span class="koboSpan" id="kobo.723.1">In this closing section, we will introduce a couple of extra topics that are part of testing but have </span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.724.1">not been covered in this chapter. </span><span class="koboSpan" id="kobo.724.2">As I mentioned at the start of this chapter, testing is a very large subject, and this was just a quick introduction to ensure that you will know how to get started and create simple tests. </span><span class="koboSpan" id="kobo.724.3">However, it is by no means a complete guide, and further learning </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">is required.</span></span></p>
			<p><span class="koboSpan" id="kobo.726.1">The aim of this section is to explain a few aspects of testing that you may find in your future experience when creating E2E testing or unit testing. </span><span class="koboSpan" id="kobo.726.2">Some of this applies to both E2E and unit testing, while others are unique to a single </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">testing methodology.</span></span></p>
			<p><span class="koboSpan" id="kobo.728.1">Testing is a very interesting subject because what you learn about it is driven entirely by which you work. </span><span class="koboSpan" id="kobo.728.2">So, some people may have to learn how to write tests that heavily rely on external APIs and therefore focus on implementing stubs and mocks, while other developers </span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.729.1">may work on application that rely heavily on state management and may have to learn the ins and out of testing components that </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">use state.</span></span></p>
			<p><span class="koboSpan" id="kobo.731.1">Let’s dive in and share a few words on these </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">three topics:</span></span></p>
			<ul>
				<li><span class="No-Break"><span class="koboSpan" id="kobo.733.1">Mocking</span></span></li>
				<li><span class="No-Break"><span class="koboSpan" id="kobo.734.1">Spying</span></span></li>
				<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">shallowMount</span></strong></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.736.1">We will start </span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">with mocking.</span></span></p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.738.1">Mocking</span></h2>
			<p><span class="koboSpan" id="kobo.739.1">Mocking is </span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.740.1">a method used in both unit tests </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.741.1">and E2E tests. </span><span class="koboSpan" id="kobo.741.2">The definition of mocking is </span><span class="No-Break"><span class="koboSpan" id="kobo.742.1">as follows:</span></span></p>
			<p class="author-quote"><span class="koboSpan" id="kobo.743.1">“Mocking is a process used in testing to isolate and focus on the code being tested and not on the behavior or state of external dependencies, by emulating a method or object.”</span></p>
			<p><span class="koboSpan" id="kobo.744.1">There are some cases, when writing a test, where you may want to avoid the use of real services (methods or objects). </span><span class="koboSpan" id="kobo.744.2">For example, you may want to avoid creating an order at every test run or having to use a paid API to fetch some dummy data. </span><span class="koboSpan" id="kobo.744.3">Another example would be mocking native APIs like fetch </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">and IntersectionObserver</span></span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.747.1">To avoid these external dependencies, we can create a fake method or object that emulates the real third-party app or service. </span><span class="koboSpan" id="kobo.747.2">This is </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">called </span></span><span class="No-Break"><strong class="old"><span class="koboSpan" id="kobo.749.1">mocking</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.751.1">Mocking is an essential technique used to ensure that your tests are scoped and do not rely on </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">external factors.</span></span></p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.753.1">Spying</span></h2>
			<p><strong class="old"><span class="koboSpan" id="kobo.754.1">Spies</span></strong><span class="koboSpan" id="kobo.755.1"> are very </span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.756.1">similar to mocking; in fact, they give </span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.757.1">you the ability to analyze the use of a specific method. </span><span class="koboSpan" id="kobo.757.2">This information can then be used in testing expectations – for example, being able to assert that a method was called </span><em class="italic"><span class="koboSpan" id="kobo.758.1">X</span></em><span class="koboSpan" id="kobo.759.1"> number of times. </span><span class="koboSpan" id="kobo.759.2">The main difference from mocking is that spies do not actually change the original method and just listen to </span><span class="No-Break"><span class="koboSpan" id="kobo.760.1">its usage.</span></span></p>
			<p><strong class="old"><span class="koboSpan" id="kobo.761.1">Spying</span></strong><span class="koboSpan" id="kobo.762.1"> is very useful to ensure the correct execution of an application, without interfering with the actual methods. </span><span class="koboSpan" id="kobo.762.2">Adding a spy is very similar to using a proxy, where all requests for a spied method would first pass through the </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">test framework.</span></span></p>
			<p><span class="koboSpan" id="kobo.764.1">You may need to spy on an action in a store to ensure that it is called during the execution of your test, spy on a log method to ensure that the correct values are passed to it, or keep an eye on a global method within the </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">window object.</span></span></p>
			<p><span class="koboSpan" id="kobo.766.1">While mocking is done to prevent us from using external services, spying is more aimed at providing us with a tool to make the correct assumption and assertion within </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">a test.</span></span></p>
			<p><span class="koboSpan" id="kobo.768.1">Just like mocking, we can spy on methods and modules using tools provided by </span><span class="No-Break"><span class="koboSpan" id="kobo.769.1">testing frameworks.</span></span></p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.770.1">shallowMount (unit tests only)</span></h2>
			<p><span class="koboSpan" id="kobo.771.1">This last </span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.772.1">feature is available only in unit testing and, more precisely, to test </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.773.1">components. </span><span class="koboSpan" id="kobo.773.2">In the </span><em class="italic"><span class="koboSpan" id="kobo.774.1">Unit testing with Vitest section</span></em><span class="koboSpan" id="kobo.775.1">, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">mount</span></strong><span class="koboSpan" id="kobo.777.1"> method to create an instance of our component, but there is another method available, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">shallowMount</span></strong><span class="koboSpan" id="kobo.779.1">, and in this section, we will explain the main difference </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">between them.</span></span></p>
			<p><span class="koboSpan" id="kobo.781.1">Unit testing is all about speed, and it is essential when writing a unit test to always choose the faster approach that uses fewer resources and completes the test quicker. </span><span class="koboSpan" id="kobo.781.2">One of these economies can come from how we initialize </span><span class="No-Break"><span class="koboSpan" id="kobo.782.1">our components.</span></span></p>
			<p><span class="koboSpan" id="kobo.783.1">When using </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">mount</span></strong><span class="koboSpan" id="kobo.785.1">, Vue Test Utils renders the component and any other component included in it. </span><span class="koboSpan" id="kobo.785.2">So, running mount on </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">app.vue</span></strong><span class="koboSpan" id="kobo.787.1"> would render the complete application within it. </span><span class="koboSpan" id="kobo.787.2">Because a unit test is expected to be focused on a specific unit, you may need to render only the component you are testing and not </span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">its children.</span></span></p>
			<p><span class="koboSpan" id="kobo.789.1">To achieve this, we can </span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">use </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">shallowMount</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">.</span></span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">shallowMount</span></strong><span class="koboSpan" id="kobo.794.1"> will render the component but then </span><strong class="old"><span class="koboSpan" id="kobo.795.1">stub</span></strong><span class="koboSpan" id="kobo.796.1"> the children component by just rendering placeholder HTML. </span><span class="koboSpan" id="kobo.796.2">Doing so will reduce the resources needed by the test and make it </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">more performant.</span></span></p>
			<p><span class="koboSpan" id="kobo.798.1">Choosing which </span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.799.1">one to use is due to your preferences and the overall </span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.800.1">architecture of your app. </span><span class="koboSpan" id="kobo.800.2">I personally prefer to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">mount</span></strong><span class="koboSpan" id="kobo.802.1"> for most of the components, ensuring that they load correctly even with their dependencies, and I rely on </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">shallowMount</span></strong><span class="koboSpan" id="kobo.804.1"> for complex components with </span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">several children.</span></span></p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.806.1">Summary</span></h1>
			<p><span class="koboSpan" id="kobo.807.1">In this chapter, we introduced the testing pyramid, covering the importance of tests and the different testing practices available within software development. </span><span class="koboSpan" id="kobo.807.2">We then moved on to unit tests and learned how to test our application using Vitest and Vue Test Utils. </span><span class="koboSpan" id="kobo.807.3">We then moved up to the testing pyramid and introduced E2E testing with Cypress. </span><span class="koboSpan" id="kobo.807.4">We created a small test that covered a simple user journey and learned a couple of techniques to select and test our application. </span><span class="koboSpan" id="kobo.807.5">Lastly, we closed the chapter with the introduction of future testing features that are part of the testing ecosystem and could be useful for </span><span class="No-Break"><span class="koboSpan" id="kobo.808.1">future learning.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.809.1">Your turn</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.810.1">Spend a couple of hours trying and testing more components to learn more about unit tests and expand the user journey of our E2E tests. </span><span class="koboSpan" id="kobo.810.2">Make sure to read the official documentation that includes all the available commands for both testing frameworks and is the best resource to find what </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">you need.</span></span></p>
			<p><span class="koboSpan" id="kobo.812.1">In the next chapter, we are going to introduce two advanced techniques called </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">slot </span></strong><span class="No-Break"><span class="koboSpan" id="kobo.814.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">Refs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.816.1">.</span></span></p>
		</div>
	</body></html>