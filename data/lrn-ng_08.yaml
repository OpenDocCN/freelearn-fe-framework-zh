- en: Firebase
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Firebase
- en: Firebase is a mobile and web application platform first developed by Firebase
    Inc. in 2011 and bought by Google in 2014\. Since then, it has gone from a reactive
    database in the cloud to a whole suite of products. We will, however, focus on
    the database side of things, as that is the interesting part for an Angular developer.
    So, the best way to think of Firebase is as a backend as a service. That means
    that with Firebase, there is no reason to build your own REST services; you only
    need to connect to it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase是一个移动和Web应用平台，最初由Firebase Inc.在2011年开发，2014年被Google收购。从那时起，它已经从云中的响应式数据库发展成了一个完整的产品套件。然而，我们将专注于数据库方面的事情，因为这对于Angular开发人员来说是有趣的部分。所以，最好的方式是将Firebase视为后端作为服务。这意味着使用Firebase，没有理由构建自己的REST服务；你只需要连接到它。
- en: It's worth pointing out that it is ultimately a product with paid plans, but
    it is definitely possible to create toy projects with it without having to pay
    anything.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，它最终是一个有付费计划的产品，但绝对可以在不支付任何费用的情况下创建玩具项目。
- en: 'Okay, so backend as a service, got it. That''s not all, however; its real selling
    point is the fact that it is reactive. It is reactive in the sense that if you
    subscribe to a collection on the database and a client somewhere makes a change
    to that collection, you will be notified and can act accordingly. Does that sounds
    familiar? Yes, you are thinking right: it sounds like RxJS and Observables, which
    is why the Firebase API has been wrapped in RXJS called AngularFire2, an Angular
    module that you can easily install from `npm` and add to your project.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，后端作为服务，知道了。然而，它真正的卖点在于它是响应式的。它是响应式的，意味着如果你订阅了数据库上的一个集合，而客户端在某处对该集合进行了更改，你将收到通知并可以相应地采取行动。这听起来熟悉吗？是的，你想对了：它听起来像RxJS和Observables，这就是为什么Firebase
    API已经被封装在了称为AngularFire2的RXJS中，这是一个你可以轻松从`npm`安装并添加到你的项目中的Angular模块。
- en: So, the business case for using Firebase in the first place is when you want
    to create collaboration applications. I'm going to be so bold as to say that it
    is like web sockets, but in the cloud and with an underlying database, so with
    not only the communication part, but data as well.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用Firebase的商业案例首先是当你想要创建协作应用程序时。我要大胆地说，这就像是Web套接字，但在云中并且有一个底层数据库，所以不仅有通信部分，还有数据部分。
- en: 'In this chapter, you will learn:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将学到：
- en: What Firebase is
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firebase是什么
- en: To leverage AngularFire2 in your Angular app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的Angular应用中利用AngularFire2
- en: How to listen for and act on changes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何监听并对变化做出反应
- en: How to use CRUD operations to manipulate your Firebase data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用CRUD操作来操作你的Firebase数据
- en: Why it is important to deal with authentication and authorization and how to
    set them up
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么处理身份验证和授权很重要以及如何设置它们
- en: Three-way binding versus two-way binding
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三向绑定与双向绑定
- en: 'We have different kinds of bindings. AngularJS made the two-way binding famous.
    This entails being able to change data from two different directions:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有不同类型的绑定。AngularJS使双向绑定变得著名。这意味着能够从两个不同的方向改变数据：
- en: A change in the view changes data on the controller
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图中的变化会改变控制器上的数据
- en: A change on the controller is reflected in the view
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器上的变化会反映在视图中
- en: 'As for three-way binding, what do we mean? Let''s illustrate this with an app;
    it''s best described through an image:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 至于三向绑定，我们是什么意思？让我们通过一个应用来说明这一点；最好通过一张图片来描述。
- en: '![](assets/ae528e84-5583-436c-bb3e-6d28cf69bdd5.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ae528e84-5583-436c-bb3e-6d28cf69bdd5.png)'
- en: What you need to imagine here is that we developed an application that uses
    Firebase. We are launching said application in two different browser windows.
    In the first window, we make a change that is being reflected in the second browser
    window, for example, adding an item to a list. So, what steps take place?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在这里想象的是，我们开发了一个使用Firebase的应用程序。我们在两个不同的浏览器窗口中启动了该应用程序。在第一个窗口中，我们进行了一项更改，这一更改在第二个浏览器窗口中得到了反映，例如，向列表中添加一个项目。那么，会发生什么步骤呢？
- en: 'What we see here is best read from right to left:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的最好是从右到左阅读：
- en: 'Instance one: user changes a view'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例一：用户更改视图
- en: 'Instance one: change propagates to the model'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例一：更改传播到模型
- en: This triggers synchronisation with the Firebase database instance
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这会触发与Firebase数据库实例的同步
- en: The second instance is listening to the synchronisation
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个实例正在监听同步
- en: The model for the second instance is being updated
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个实例的模型正在更新
- en: The view for the second instance is being updated
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个实例的视图正在更新
- en: 'There you have it: change in one place, and see the results in two or more
    instances depending on how many instances you have spawned.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了：在一个地方进行更改，在两个或更多实例中看到结果，取决于你生成了多少实例。
- en: Some words on storage - the problem with a list
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于存储的一些话-列表的问题
- en: 'Before venturing deeper into Firebase, let''s first explain why we are talking
    about lists in the first place. In a relational database, we would be using SQL,
    tables, and normal forms to define our database. This is not the case with a Firebase
    database, as it is made of a JSON structure, looking something like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解Firebase之前，让我们首先解释为什么我们首先谈论列表。在关系数据库中，我们将使用SQL、表和标准形式来定义我们的数据库。这在Firebase数据库中并不适用，因为它由JSON结构组成，看起来像这样：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice how the orders collection in a relational database would be an `orders`
    table with a lot of rows. Here, it seems to be an object; why is that?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在关系数据库中，订单集合将是一个`orders`表，有很多行。在这里，它似乎是一个对象；为什么呢？
- en: Objects in a list - solving the deletion problem
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表中的对象-解决删除问题
- en: 'A list normally has an index associated to every item in the list, like so:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表通常与列表中的每个项目关联一个索引，如下所示：
- en: '0: item1'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0：项目1
- en: '1: item2'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1：项目2
- en: '2: item3'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2：项目3
- en: There's nothing wrong with that, until you start to think about what happens
    when many simultaneous users start to access the same data. As long as we do reads,
    we don't have a problem. But what happens if we attempt something else, such as
    deletion?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这没有问题，直到你开始考虑当许多同时用户开始访问相同的数据时会发生什么。只要我们进行读取，就没有问题。但是如果我们尝试其他操作，比如删除，会发生什么呢？
- en: 'Normally when you delete things, the index gets reassigned. If we delete the
    preceding `item2`, we have a new situation that looks like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当你删除东西时，索引会被重新分配。如果我们删除前面的`item2`，我们将得到一个新的情况，看起来像这样：
- en: '0: item1'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0：项目1
- en: '1: item3'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1：项目3
- en: 'Imagine we do deletions based on the index and your data looks like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们根据索引进行删除，你的数据看起来像这样：
- en: '0: item1'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0：项目1
- en: '1: item2'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1：项目2
- en: '2: item3'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2：项目3
- en: '3: item4'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3：项目4
- en: Now, two different users can access this data and one wants to delete index
    1 and the other wants to delete index 3\. We would probably employ a locking algorithm,
    so one user deletes index 1 a few milliseconds before user two deletes index 3\.
    The intention of the first user was to delete `item2` and the intention of the
    second user was to delete `item4`. The first user succeeds in what they set out
    to do, but the second one deletes an index that is out of bounds.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，两个不同的用户可以访问这些数据，其中一个想要删除索引1，另一个想要删除索引3。我们可能会采用一个锁定算法，所以一个用户在几毫秒之前删除了索引1，而另一个用户删除了索引3。第一个用户的意图是删除`item2`，第二个用户的意图是删除`item4`。第一个用户成功地完成了他们的目标，但第二个用户删除了一个超出范围的索引。
- en: 'This means that deleting things on the index is just crazy in a multiuser database,
    but in the case of Firebase, it means that lists are not lists when they are stored;
    they are objects, looking like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在多用户数据库中删除索引上的东西是疯狂的，但在Firebase的情况下，这意味着当它们被存储时，列表不是列表；它们是对象，看起来像这样：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This circumvents the deletion problem and is, therefore, the reason that lists
    are represented the way they are.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这避免了删除问题，因此是列表以其方式表示的原因。
- en: AngularFire2
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AngularFire2
- en: AngularFire2 is the name of the library where the Firebase API is wrapped in
    Observables. That means we can somewhat anticipate what it might look like when
    we want to listen for changes and so on. We will come back to the change scenario
    in a later section in this chapter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: AngularFire2是将Firebase API封装在Observables中的库的名称。这意味着我们可以在想要监听更改等情况时，对它可能的外观有一些预期。我们将在本章的后面部分回到更改场景。
- en: 'The official repository can be found at the following link:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 官方存储库可以在以下链接找到：
- en: '[https://github.com/angular/angularfire2](https://github.com/angular/angularfire2)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/angular/angularfire2](https://github.com/angular/angularfire2)'
- en: Excellent documentation on how to do CRUD and work with authentication can be
    found at the bottom of the page the preceding link leads to.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如何进行CRUD和处理身份验证的出色文档可以在上述链接的页面底部找到。
- en: The core classes
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心类
- en: 'There is some basic information that is good to know before venturing deeper
    into AngularFire2; it''s about core objects and what their responsibilities are:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究AngularFire2之前，了解一些基本信息是很有必要的；这些信息涉及核心对象及其职责：
- en: '`AngularFireAuth`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AngularFireAuth`'
- en: '`FirebaseObjectObservable`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FirebaseObjectObservable`'
- en: '`FirebaseListObservable`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FirebaseListObservable`'
- en: '`AngularFireAuth` deals with authentication. `FirebaseObjectObservable`is the
    core object you want to talk to when you know that the database property you deal
    with is of the type object. Lastly, `FirebaseListObservable`is the object that
    acts like a list. From before, we know that Firebase lists aren''t really lists,
    but that doesn''t stop this object from having methods on it that a list would
    normally have.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`AngularFireAuth`处理身份验证。`FirebaseObjectObservable`是您想要与之交谈的核心对象，当您知道您处理的数据库属性是对象类型时。最后，`FirebaseListObservable`是一个类似列表的对象。从前面我们知道Firebase列表并不真正是列表，但这并不妨碍该对象具有列表通常具有的方法。'
- en: The admin tools
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理工具
- en: The admin tools can be found at [https://firebase.google.com/](https://firebase.google.com/).
    Once there, in the top-right corner, click on the GO TO CONSOLE link. You should
    have a Gmail account. If you do, then you have a Firebase account as well, and
    you only need to set up the database. Then, you should choose to create a project;
    give it a title of your choice and your location.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 管理工具可以在[https://firebase.google.com/](https://firebase.google.com/)找到。一旦进入，点击右上角的GO
    TO CONSOLE链接。您应该有一个Gmail帐户。如果有的话，那么您也有一个Firebase帐户，您只需要设置数据库。然后，您应该选择创建一个项目；给它一个您选择的标题和您的位置。
- en: 'It should look like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该是这样的：
- en: '>![](assets/bfbbe7cb-04fd-45ea-bbb5-72b08f85f070.png)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '>![](assets/bfbbe7cb-04fd-45ea-bbb5-72b08f85f070.png)'
- en: 'Once you''ve done this, you will be taken to the admin page, which looks like
    this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，您将被带到管理页面，它看起来像这样：
- en: '![](assets/9944befd-010f-4912-89dc-7317796d1d9c.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9944befd-010f-4912-89dc-7317796d1d9c.png)'
- en: 'The preceding screenshot displays the left menu, and then to the right, you
    would have a content pane. What content is displayed on the right varies based
    on what you choose on the left. As you can see, you can control a lot of things.
    Your most important options when starting to craft your database are:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 上述屏幕截图显示了左侧菜单，然后右侧是内容窗格。右侧显示的内容根据您在左侧选择的内容而变化。正如您所看到的，您可以控制很多东西。在开始创建数据库时，您最重要的选项是：
- en: '**Authentication**: Here, you set up what kind of authentication you want: no
    authentication, username/password, social logins, and so on.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证**：在这里，您设置想要的身份验证类型：无身份验证、用户名/密码、社交登录等。'
- en: '**Database**: Here, you design what the database should look like. There are
    also some tabs in here that let us control authorization for the database collections.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库**：在这里，您设计数据库应该是什么样子。这里还有一些选项卡，让我们控制数据库集合的授权。'
- en: The other options are interesting, but for the purposes of this section, this
    is something beyond our scope.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 其他选项也很有趣，但对于本节的目的来说，这超出了我们的范围。
- en: Defining your database
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义您的数据库
- en: 'We go to the Database menu option on our left. In the following screenshot,
    I have already added a node to the root node, the book node:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们转到左侧的数据库菜单选项。在下面的截图中，我已经向根节点添加了一个节点，即book节点：
- en: '![](assets/0641a4ff-fc3c-4407-aac8-27d93f3f468b.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0641a4ff-fc3c-4407-aac8-27d93f3f468b.png)'
- en: 'Hovering over our root element, we are presented with a + character that allows
    us to add a child to the root. Of course, we can also create more complex objects
    by clicking on a specific element and adding child nodes to them that look something
    like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的根元素上悬停，我们会看到一个+字符，允许我们向根节点添加一个子节点。当然，我们也可以通过单击特定元素并向其添加子节点来创建更复杂的对象，看起来像这样：
- en: '![](assets/1f94c123-e0cf-4866-8707-0d6e6b84be19.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1f94c123-e0cf-4866-8707-0d6e6b84be19.png)'
- en: As you can see, we can quite easily build out our database and it has a JSON-like
    appearance.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们可以很容易地构建出我们的数据库，它具有类似JSON的外观。
- en: Adding AngularFire2 to your app
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将AngularFire2添加到您的应用程序
- en: 'The time has come to add Firebase support to our Angular application. To do
    that, we need to do the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到了将Firebase支持添加到我们的Angular应用程序的时候。为了做到这一点，我们需要做以下事情：
- en: Download the `npm` library for AngularFire2.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载AngularFire2的`npm`库。
- en: Import said library into our Angular application.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该库导入到我们的Angular应用程序中。
- en: Set up our Firebase configuration so Firebase lets us retrieve the data.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置我们的Firebase配置，以便Firebase让我们检索数据。
- en: Inject the proper Firebase service so we can access the data.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注入适当的Firebase服务，以便我们可以访问数据。
- en: Present the data in a component.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个组件中呈现数据。
- en: The link [https://github.com/angular/angularfire2/blob/master/docs/install-and-setup.md](https://github.com/angular/angularfire2/blob/master/docs/install-and-setup.md)
    is the official link to set up Firebase in your Angular application. This might
    change over time, so it can be worth checking this page if the instructions of
    the book no longer seem to work after an update of the AngularFire2 library. Let's
    go through the steps though.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 链接[https://github.com/angular/angularfire2/blob/master/docs/install-and-setup.md](https://github.com/angular/angularfire2/blob/master/docs/install-and-setup.md)是在您的Angular应用程序中设置Firebase的官方链接。这可能会随时间而改变，因此如果在更新AngularFire2库后，书中的说明似乎不再起作用，可以值得检查此页面。不过，让我们按照步骤进行。
- en: 'Downloading the AngularFire2 library is as simple as typing this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下载AngularFire2库就像输入这样简单：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next step is to grab the configuration data from the Firebase admin page
    and save that to a configuration object. Go back to the admin page. You go to
    the correct page for the configuration by pressing:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是从Firebase管理页面获取配置数据，并将其保存到配置对象中。返回管理页面。通过按下以下按钮，您可以转到配置的正确页面：
- en: Overview
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概述
- en: Add Firebase to your web app
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Firebase添加到您的Web应用程序
- en: 'At this point, you have a configuration in the form of an object with the following
    properties:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您已经有了一个对象形式的配置，具有以下属性：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding values differ depending on your project. I can only urge you to
    copy the configuration from the admin page for your next step.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的值取决于您的项目。我只能建议您从管理页面复制配置，以进行下一步。
- en: 'The next step is to scaffold an Angular application using `@angular-cli` and
    look up the `app.module.ts` file. In it, we will assign our config to the following
    variable:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用`@angular-cli`搭建一个Angular应用程序，并查找`app.module.ts`文件。在其中，我们将把我们的配置分配给以下变量：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we need to instruct the module to import the modules we need. Essentially,
    there are three modules that we can import:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要指示模块导入我们需要的模块。基本上，有三个模块可以导入：
- en: '`AngularFireModule`: This is used to initialize the app'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AngularFireModule`：这用于初始化应用程序'
- en: '`AngularFireDatabaseModule`: This is used to access the database; this is necessary
    to import'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AngularFireDatabaseModule`：这用于访问数据库；这是必要的导入'
- en: '`AngularFireAuthModule`: This is used to work with authentication; it''s not
    necessary at first, but will definitely become so as the app grows - security
    anyone?'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AngularFireAuthModule`：这用于处理身份验证；一开始不是必要的，但随着应用程序的增长，它肯定会变得必要 - 安全性问题？'
- en: 'Let''s import the first two, so we can work with Firebase and pull some data
    from it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们导入前两个，这样我们就可以使用Firebase并从中提取一些数据：
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'At this point, we are done configuring the Angular module and can move on to
    `AppComponent`, which is where we will inject a Firebase service so we can finally
    pull some data from Firebase:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经完成了配置Angular模块，可以继续进行`AppComponent`，这是我们将注入Firebase服务的地方，这样我们最终可以从Firebase中提取一些数据：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And there you have it: a complete Firebase setup, from downloading AngularFire2
    to displaying your first data.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样：一个完整的Firebase设置，从下载AngularFire2到显示您的第一个数据。
- en: Protecting our app
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护我们的应用程序
- en: 'Protecting our app is vital. It''s not an if, it is a must, unless you are
    building a toy application. There are currently three ways to do this in Firebase:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 保护我们的应用程序至关重要。这不是一个如果，这是一个必须，除非您正在构建一个玩具应用程序。目前在Firebase中有三种方法可以做到这一点：
- en: 'Authentication: This is where we verify that the user enters the correct credentials
    to be logged on to the application'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证：这是我们验证用户输入正确凭据以登录应用程序的地方
- en: 'Authorization: This is where we set up what resources in the application the
    user has a right to access/modify'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权：这是我们设置用户有权访问/修改应用程序中哪些资源的地方
- en: 'Validation: This is where we ensure that only valid data is persisted in the
    database'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证：这是我们确保只有有效数据被持久化在数据库中的地方
- en: Authentication - allowing access to the app
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证 - 允许访问应用程序
- en: 'Authentication means that we identify you when you attempt to log on. If your
    credentials match a user in the database, then the app should let you in; otherwise,
    you are shown the door. Firebase has different ways of authenticating you. Currently,
    the following authentication methods are possible:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证意味着当您尝试登录时我们识别您。如果您的凭据与数据库中的用户匹配，那么应用程序应该让您进入；否则，您将被拒之门外。Firebase有不同的身份验证方式。目前，以下身份验证方法是可能的：
- en: Email/password
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件/密码
- en: Phone
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电话
- en: Google
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谷歌
- en: Facebook
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Facebook
- en: Twitter
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twitter
- en: GitHub
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub
- en: Anonymous
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名
- en: 'This is pretty much what you would expect in 2017: everything from simple authentication
    with email/password to OAuth.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是您在2017年所期望的：从简单的电子邮件/密码身份验证到OAuth的一切。
- en: Authorization - deciding who gets to access what data, and how
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权 - 决定谁有权访问哪些数据，以及如何访问
- en: 'As for authorization, it is possible to set rules:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 至于授权，可以设置规则：
- en: On the whole database
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在整个数据库上
- en: Per collection
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个集合
- en: 'It is also important to know that the rules are enforced in these ways:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是要知道规则是通过以下方式执行的：
- en: '**Atomically**: Applies to a specific element'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子地**：适用于特定元素'
- en: '**Cascading**: Applies to a specific element and all its children'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**级联**：适用于特定元素及其所有子元素'
- en: 'The permission level is either:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 权限级别要么是：
- en: '**Read**: This will make it possible to read the contents of the resource'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读取**：这将使读取资源的内容成为可能'
- en: '**Write**: This will give you the ability to modify the resource'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**写入**：这将使您能够修改资源'
- en: '**Deny**: This will stop any write or read actions from being possible on the
    targeted resource'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拒绝**：这将阻止对目标资源的任何写入或读取操作'
- en: 'This calls for an example. Imagine you have the following database structure:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一个例子。想象一下，您有以下数据库结构：
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Atomic authorization means that we need to be explicit; if we are not explicit,
    the default is to deny access. Let''s try to enforce some rules on the preceding
    structure. We navigate to the rules section under the Database menu option. A
    rule is defined as a JSON object, like so:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 原子授权意味着我们需要明确；如果我们不明确，那么默认情况下是拒绝访问。让我们试着对前面的结构强制执行一些规则。我们转到数据库菜单选项下的规则部分。规则被定义为一个JSON对象，如下所示：
- en: '[PRE8]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This means that we have set an explicit atomic rule for `bar` and that rule
    is inherited by its child elements, that is, it acts in a cascading way`foo`,
    on the other hand, has no rule to it. This would have the following consequence
    if trying to access the collections:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们已经为`bar`设置了一个明确的原子规则，并且该规则被其子元素继承，也就是说，它以级联方式起作用。另一方面，`foo`没有规则。如果尝试访问这些集合，这将产生以下后果：
- en: '[PRE9]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This explains the types of rules that are in place. I urge you to look into
    this topic deeper by studying the following links:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了现行规则的类型。我敦促您通过研究以下链接来深入了解这个主题：
- en: Securing your data in general: [https://firebase.google.com/docs/database/security/securing-data](https://firebase.google.com/docs/database/security/securing-data)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般情况下保护您的数据：[https://firebase.google.com/docs/database/security/securing-data](https://firebase.google.com/docs/database/security/securing-data)
- en: Securing data per user, that is, setting different permission levels for different
    types of users: [https://firebase.google.com/docs/database/security/user-security](https://firebase.google.com/docs/database/security/user-security)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个用户保护数据，即为不同类型的用户设置不同的权限级别：[https://firebase.google.com/docs/database/security/user-security](https://firebase.google.com/docs/database/security/user-security)
- en: Validation
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证
- en: 'This is quite an interesting topic. What is meant here is that we can control
    what data is allowed to enter our collections by setting up rules about the shape
    of the data. You essentially specify a set of requirements that the data must
    have for an insertion or update to be considered okay to perform. Just like the
    read/write authorization rules, we specify a rules object. Let''s describe two
    different versions of validation so you get the hang of it:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有趣的话题。这里所指的是，我们可以通过设置关于数据形状的规则来控制允许进入我们集合的数据。您基本上指定了数据必须具备的一组要求，以便插入或更新被认为是可以执行的。就像读/写授权规则一样，我们指定一个规则对象。让我们描述两种不同版本的验证，这样你就能掌握它：
- en: Incoming data must include these fields
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传入数据必须包括这些字段
- en: Incoming data must have a value within this range
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传入数据必须在此范围内
- en: 'The first case we can describe like so:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样描述第一种情况：
- en: '[PRE10]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here is a code snippet showing the impact when the preceding rules are in place:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个代码片段，展示了前面的规则生效时的影响：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the second case, we can set up the rules like so:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们可以这样设置规则：
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding specified rule states that any incoming data must be of type number,
    must be larger than or equal to `0`, and smaller than or equal to `100`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 前面指定的规则规定，任何传入的数据必须是数字类型，必须大于或等于`0`，并且小于或等于`100`。
- en: 'Here is a code snippet showing the impact with this rule in place:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个代码片段，展示了这个规则的影响：
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, this makes it very easy to protect our data from unwanted input
    and thereby keeps the database nice and consistent.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这使得我们非常容易保护我们的数据免受不必要的输入，从而保持数据库的整洁和一致。
- en: Working with data - CRUD
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数据 - CRUD
- en: 'Now, we have come to the exciting part: how to work with the data, read our
    data, add more data, and so on. In short, the term **Create, Read, Update, Delete** (**CRUD**).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来到了令人兴奋的部分：如何处理数据，读取我们的数据，添加更多数据等等。简而言之，术语**创建，读取，更新，删除**（**CRUD**）。
- en: 'So, when we work with CRUD, we need to know a little something about the structure
    that we are operating on. We need to know whether it is of type object or list.
    In terms of code, this means the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们使用CRUD时，我们需要了解我们正在操作的结构的一些信息。我们需要知道它是对象还是列表类型。在代码方面，这意味着以下内容：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding states that we can treat the data we look at, from the database,
    as either an object or list. Depending on our choice, this has an impact on what
    methods will be available to us, but also what the data looks like coming back.
    This is especially obvious if we have a list-like structure in the database and
    choose to treat it as an object. Assume we have the following stored structure:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 前面说到，我们可以将我们从数据库中查看的数据视为对象或列表。根据我们的选择，这将影响我们可以使用的方法，也会影响返回的数据样式。如果数据库中有类似列表的结构，并选择将其视为对象，这一点尤其明显。假设我们有以下存储结构：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we choose to treat this as a list, we get the following response back:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择将其视为列表，我们将得到以下响应：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This means we can use methods such as `push()` to add things to it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以使用`push()`等方法向其中添加内容。
- en: 'If we choose to treat the data as an object, then it comes back as the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择将数据视为一个对象，那么它将返回如下内容：
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This may or may not be what you want. So remember, if it is a list, treat it
    as one. Firebase won't punish you with an exception if you choose `.object()`
    over `.list()`, but it might make the data harder to work with.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是你想要的，也可能不是。因此请记住，如果它是一个列表，就把它当作一个列表。如果你选择`.object()`而不是`.list()`，Firebase不会因此对你进行惩罚，但这可能会使数据更难处理。
- en: Reading data
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取数据
- en: 'Let''s look at the read case. The following code will read the data from a
    property in our database:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看读取的情况。以下代码将从数据库中的属性读取数据：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As it is a stream, this means that we can get the data in one of two ways:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是一个流，这意味着我们可以通过两种方式之一获取数据：
- en: Using the async pipe, which displays the observable as is, in the template
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用async管道，在模板中显示可观察对象本身
- en: Grabbing the data from the `subscribe()` method and assigning it to a property
    on your class
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`subscribe()`方法中获取数据并将其分配给类的属性。
- en: 'If we do the first scenario, it will look something like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进行第一种情况，代码将如下所示：
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It is worth highlighting how we ask for the path in the database and transform
    the result with the `.map()` operator:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 值得强调的是我们如何请求数据库中的路径，并使用`.map()`操作符转换结果：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the template, we use the async pipe and an expression to show the title
    of our `Book` entity when it has been resolved:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，我们使用async管道和一个表达式来显示我们的`Book`实体的标题，当它已经解析时：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we do the second scenario, it will look something like this in code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进行第二种情况，代码将如下所示：
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will take away a little of the typing, but you now must remember to unsubscribe
    to your stream; this has not been added in the previous example. When possible,
    use the async pipe.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这将减少一些输入，但现在你必须记住取消订阅你的流；这在之前的例子中没有添加。在可能的情况下，请使用async管道。
- en: Changing data
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改数据
- en: 'There are two types of data changes that can happen:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的数据更改可能发生：
- en: '**Destructive update**: We override what is there'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**破坏性更新**：我们覆盖了原有的内容'
- en: '**Non-destructive update**: We merge the incoming data with what is already
    there'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非破坏性更新**：我们将传入的数据与已有的数据合并'
- en: 'The method used for the destructive update is called `set()` and is used in
    the following way:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 用于破坏性更新的方法称为`set()`，使用方式如下：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Given that our previous data was the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们之前的数据如下：
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It has now become:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它已经变成了：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is exactly what we mean by a destructive update: we get the `title` property
    overridden, but we also lose the `description` property as the entire object is
    being replaced.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们所说的破坏性更新：我们覆盖了`title`属性，但我们也失去了`description`属性，因为整个对象被替换了。
- en: 'If the destruction of the data was not what you had in mind, then there is
    a softer update you can use, which is the `update()` method. Using it is as easy
    as writing the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据的破坏不是您想要的，那么您可以使用更轻的`update()`方法。使用它就像写下面这样简单：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Given that the data looked like the following before the `update()` operation:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在`update()`操作之前，数据看起来像下面这样：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It now looks like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来像这样：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Remember to select the appropriate update operation depending on your intention
    as it makes a difference.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 记住根据您的意图选择适当的更新操作，因为这会有所不同。
- en: Removing data
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除数据
- en: Removing data is simple. We need to split this up into two different parts,
    as they differ a bit, to remove for an object and to remove an item in a list.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 删除数据很简单。我们需要将其分成两个不同的部分，因为它们有些不同，一个是删除对象，一个是删除列表中的项目。
- en: There are different ways of subscribing to data in Firebase. You can either
    subscribe to changes, using a method called `valueChanges()`. This will give you
    the data you want to display. As long as you want to display data, then you are
    fine using this method. However, when you start to want to change specific data
    like removing an item in a list or in short, when you need to know the exact key
    value of the resource you are trying to manipulate, then you need a new function.
    This function is called `snapshotChanges()`. Using said function gives you a more
    raw version of the resource you want. In this case, you need to dig out the value
    that you want to display.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firebase中，有不同的订阅数据的方式。您可以使用称为`valueChanges()`的方法订阅更改。这将为您提供要显示的数据。只要您想要显示数据，那么使用此方法就可以了。但是，当您开始想要更改特定数据，比如从列表中删除项目，或者简而言之，当您需要知道您要操作的资源的确切键值时，那么您需要一个新的函数。这个函数被称为`snapshotChanges()`。使用该函数会给您一个更原始的资源版本。在这种情况下，您需要挖掘出要显示的值。
- en: Let's start with the first case, that of removing an object.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一种情况开始，即删除一个对象。
- en: Removing an object
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除对象
- en: 'Let''s look at two different `remove()` scenarios. In the first scenario, we
    want to remove what our path is pointing to. Imagine we are looking at the path/book.
    Then, our remove code for this is very simple:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两种不同的`remove()`场景。在第一种情况下，我们想要删除我们的路径指向的内容。想象一下我们正在查看路径/书。那么，我们的删除代码非常简单：
- en: '[PRE29]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Removing an item in a list
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除列表中的项目
- en: 'A list in Firebase looks something like this when looking at the database from
    the Firebase console:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firebase中，从Firebase控制台查看数据库时，列表看起来像这样：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Of course, there is an internal representation of each item that points to
    a key with a hash value. We have the following scenario; we want to delete the
    first item in the list. We write some code that looks like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，每个项目都有一个内部表示，指向具有哈希值的键。我们有以下情景；我们想要删除列表中的第一项。我们编写的代码看起来像这样：
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It''s now that we discover that we don''t know what the key is for the item
    we want to remove. This is where we start using the method `snapshotChanges()`
    and try to find this out:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们发现我们不知道要删除的项目的键是什么。这就是我们开始使用`snapshotChanges()`方法并尝试找出这一点的地方：
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The list parameter is a list, but the list items is a complicated object that
    contains the key we need as well as the value that we mean to display in the UI.
    We realise that this is the way to go and decide on using a `map()` function on
    our stream to transform the it into a list of books.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 列表参数是一个列表，但列表项是一个包含我们需要的键以及我们打算在UI中显示的值的复杂对象。我们意识到这是正确的方法，并决定在我们的流上使用`map()`函数将其转换为书籍列表。
- en: 'First off, we amend our `book.model.ts` file to contain a key property, like
    so:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们修改我们的`book.model.ts`文件，包含一个key属性，就像这样：
- en: '[PRE33]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can see that we needed to change how we access data; our data was to be
    found under the `payload.val()` and our `key` was easy to retrieve. With this
    knowledge, we can now build a list :'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们需要改变如何访问数据；我们的数据可以在`payload.val()`下找到，而我们的`key`很容易检索到。有了这个知识，我们现在可以构建一个列表：
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the following code snippet, we loop all the books in the list and create
    a remove button for each book in the list. We also wire up each remove button
    to point to the `book.key`, that is, our `key`, which is what we need when communicating
    a remove action to Firebase:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们循环遍历列表中的所有书籍，并为列表中的每本书创建一个删除按钮。我们还将每个删除按钮连接到`book.key`，也就是我们的`key`，这是我们在向Firebase通信删除操作时需要的。
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Responding to change
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应变化
- en: Firebase's cloud database is not just a database that looks like JSON, it also
    pushes out the data when it changes. You can listen for when that happens. This
    gives you not only cloud storage, but also the opportunity to build applications
    in a more collaborative and real-time manner. A lot of systems out there work
    like this already, such as most ticketing systems, chat applications, and so on.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase的云数据库不仅仅是一个看起来像JSON的数据库，它还在数据发生变化时推送数据。您可以监听这种变化。这不仅为您提供了云存储，还为您提供了以更协作和实时的方式构建应用程序的机会。许多系统已经像这样工作，例如大多数售票系统、聊天应用程序等。
- en: Imagine a system built with Firebase that, for example, books movie tickets.
    You would be able to see when a person books a ticket, or an incoming message
    in a chat system, without polling logic or refreshing the app; it would be almost
    child's play to build.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，使用Firebase构建的系统，例如，预订电影票。您可以看到一个人何时预订了一张票，或者在聊天系统中收到了一条消息，而无需轮询逻辑或刷新应用程序；构建起来几乎是小菜一碟。
- en: 'AngularFire2, the Angular framework on top of Firebase, uses Observables. Observables
    convey changes when they happen. From before, we know that we can listen to such
    changes by giving a subscribe method a callback, like so:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: AngularFire2，即Firebase上的Angular框架，使用Observables。Observables在发生变化时传达这些变化。从之前的知识中，我们知道可以通过给subscribe方法一个回调来监听这些变化，就像这样：
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: What you can do as a developer is intercept when such a change happens, by signing
    up to the `subscribe()` method, and for example, show a CSS animation to draw
    the user's attention to the change, so they can respond accordingly.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，您可以拦截这种变化发生时，通过注册`subscribe()`方法，例如，显示CSS动画以吸引用户对变化做出响应，以便他们可以相应地做出响应。
- en: Adding authentication
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加身份验证
- en: 'We can''t really build an application and call it ready for release unless
    we at least have some proper authentication. Essentially, we can''t trust just
    anyone with our data, only authenticated users. In Firebase, you can set authentication
    on the highest level for your database. Click on the Database menu option tab
    in your admin tool and then select the tab rules. That should showcase the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们至少有一些适当的身份验证，否则我们无法真正构建一个应用程序并称其为发布准备就绪。基本上，我们不能信任任何人使用我们的数据，只有经过身份验证的用户。在Firebase中，您可以为数据库设置最高级别的身份验证。在管理工具中点击数据库菜单选项卡，然后选择规则选项卡。应该显示如下内容：
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s highlight the following row:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来强调以下行：
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this case, this sets up the read permission for your entire database and
    we give it the value `auth != null`. This means that you need to be authenticated
    to have any kind of read access to the database. You can see in the following
    row we have the same value, but this time for a rule called `.write`, which governs
    the writing access.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这设置了你整个数据库的读取权限，并且我们给了它值`auth != null`。这意味着你需要认证才能有任何读取数据库的权限。你可以看到在下一行我们有相同的值，但这次是针对一个叫做`.write`的规则，它控制着写入权限。
- en: This is a good default permission to have. Of course, when testing the database
    out, you might want to have the value `auth == null`to shut off authentication,
    but remember to set the value back to `auth != null`, or you will leave your database
    wide open.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的默认权限。当然，在测试数据库时，你可能想要将值`auth == null`来关闭认证，但记得将值设置回`auth != null`，否则你会让你的数据库完全开放。
- en: 'Setting up any kind of authentication means we need to perform some steps,
    namely:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 设置任何类型的认证意味着我们需要执行一些步骤，即：
- en: Ensuring the rules are on, that is, `auth != null`
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保规则是开启的，也就是`auth != null`
- en: Enabling a security method
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用安全方法
- en: Adding a user or token (if it is OAuth)
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加用户或令牌（如果是OAuth）
- en: Using the `AuthService` in the application to programmatically log on the user
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用中使用`AuthService`来以编程方式登录用户
- en: Simple authentication with email/password
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用邮箱/密码进行简单认证
- en: 'Let''s set up a simple user/password authentication. Click on the Authentication
    menu option and select the Sign-in method tab. Then, enable the email/password
    option. It should look like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一个简单的用户/密码认证。点击认证菜单选项，然后选择登录方法选项卡。然后，启用邮箱/密码选项。它应该看起来像这样：
- en: '![](assets/f37a176b-c3f9-4d8b-8671-b164de447bd0.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f37a176b-c3f9-4d8b-8671-b164de447bd0.png)'
- en: 'At this point, we need to add a user, a user that is allowed to access our
    data. So, let''s set up the user. We go to the Users tab instead and clickADD
    USER button. It should look something like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要添加一个用户，一个被允许访问我们数据的用户。所以，让我们设置这个用户。我们去到用户选项卡，然后点击“添加用户”按钮。它应该看起来像这样：
- en: '![](assets/3d5db160-fb7e-45ef-8e44-5a6eca202001.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3d5db160-fb7e-45ef-8e44-5a6eca202001.png)'
- en: Okay, so now we have a user with an email `a@b.com` and password `abc123`. We
    still need to log in such a user for the database to show us the data. If we don't
    log in, our application will look very empty and devoid of any data. We will also
    get a lot of errors on the console log saying that we lack permission to look
    at the data.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们有一个邮箱为`a@b.com`，密码为`abc123`的用户。我们仍然需要登录这样一个用户，数据库才会显示数据给我们。如果我们不登录，我们的应用看起来会非常空，没有任何数据。我们还会在控制台日志中得到很多错误，说我们没有权限查看数据。
- en: 'In the previous setup of Firebase, we had only set up the database itself,
    not the authentication part. As Firebase is an Angular module, there are some
    rules we need to follow:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前设置Firebase时，我们只设置了数据库本身，而没有设置认证部分。由于Firebase是一个Angular模块，我们需要遵循一些规则：
- en: Import the module and add it to the `import` keyword of the `@NgModule`
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入模块并将其添加到`@NgModule`的`import`关键字中
- en: Put the `AngularFireAuth` service in the `providers` keyword in `@NgModule`,
    so a component is able to inject it into its constructor
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`AngularFireAuth`服务放入`@NgModule`中的`providers`关键字中，这样组件就能够将其注入到其构造函数中
- en: Perform a programmatic login
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一个编程登录
- en: 'The module side of things looks like the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 模块方面的事情看起来像下面这样：
- en: '[PRE39]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we are ready to inject the service into the component and perform the
    login:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备将服务注入到组件中并执行登录：
- en: '[PRE40]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, we do two interesting things.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们做了两件有趣的事情。
- en: 'First off, we assign the `authState` of the  `authService`to a user. This is
    an Observable that, once logged in, will contain your user. We have now learned
    that we can show Observables with the async pipe. However, we are interested in
    getting two things from this user, `uid` and `email`, so we can see we are logged
    in as the correct user. It is tempting to write template code that looks like
    this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`authService`的`authState`分配给一个用户。这是一个Observable，一旦登录，将包含你的用户。我们现在已经学会了可以使用async管道显示Observables。然而，我们有兴趣从这个用户中获取两件事，`uid`和`email`，这样我们就可以看到我们以正确的用户身份登录了。编写模板代码看起来像这样是很诱人的：
- en: '[PRE41]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This creates the variable user for us that we can refer to instead. As expected,
    this prints out the user for us once logged in.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们创建了一个名为user的变量，我们可以在登录后引用它。正如预期的那样，一旦登录，这将为我们打印出用户。
- en: 'Now, to the second piece of our preceding code, the login call:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来看看我们之前的代码的第二部分，登录调用：
- en: '[PRE42]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, we talk to the `auth` property on the `authService` and we call the `signInWithEmailAndPassword(email,
    password)` method.We pass it the credentials. The method returns a promise and,
    on resolving that promise, we set our properties' book and books. If we don't
    do it this way and first authenticate, we will get a lot of `access not allowed
    errors`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们与`authService`的`auth`属性交谈，并调用`signInWithEmailAndPassword(email, password)`方法。我们传递凭据。该方法返回一个promise，解决了这个promise后，我们设置了我们的属性`book`和`books`。如果我们不这样做，首先进行身份验证，我们将会得到很多“访问不允许”的错误。
- en: 'There are a ton more `signInWith...` methods, as shown here:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有更多的`signInWith...`方法，如下所示：
- en: '![](assets/7c8330f4-25e4-4674-9468-6a269cf26186.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7c8330f4-25e4-4674-9468-6a269cf26186.png)'
- en: We urge you to try them out for yourself.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们敦促你亲自尝试一下。
- en: 'As for ways of authenticating, we have just scratched the surface. The following
    is the full range of login methods:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 至于认证方式，我们只是触及了表面。以下是完整的登录方法范围：
- en: '![](assets/769e6c33-b4a4-436f-bc47-1de55aa58552.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/769e6c33-b4a4-436f-bc47-1de55aa58552.png)'
- en: Try them out and see what works for you and your app.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下，看看哪些对你和你的应用程序有用。
- en: Summary
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Firebase is a powerful technology that is essentially a backend in the cloud;
    it has a reactive API. AngularFire2 is the name of the library wrapping Firebase.
    The library is especially made for use with Angular.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase是一种强大的技术，本质上是云端的后端；它具有响应式API。AngularFire2是包装Firebase的库的名称。该库专门用于与Angular一起使用。
- en: It is possible to listen for changes from Firebase. AngularFire2 communicates
    those changes through RxJS and Observables, which makes it very easy for us to
    involve Firebase in our apps once we grow the basics of Observables with HTTP.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 可以监听来自Firebase的更改。AngularFire2通过RxJS和Observables传达这些更改，这使得我们很容易将Firebase纳入我们的应用程序中，一旦我们掌握了使用HTTP的Observables的基础知识。
- en: Hopefully, this has been an educational chapter which has further motivated
    you to use RxJS in Angular as your choice for anything async.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这是一个有教育意义的章节，进一步激励你选择在Angular中使用RxJS作为异步操作的首选。
- en: This chapter has been about the standalone product Firebase. The point was to
    show that there is a very powerful piece of technology at your fingertips that
    expands on your newfound knowledge of RxJS.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于独立产品Firebase的。重点是要展示在你的指尖上有一种非常强大的技术，它扩展了你对RxJS的新知识。
- en: In the next chapter, we will cover a very important aspect of building Angular
    applications, namely routing. Routing is a central concept that allows us to divide
    our application into several logical pages. We talk about logical pages instead
    of actual pages as we are building an SPA, which is a single page application.
    What is the difference, you ask? The routing component, which you will read more
    about in the next chapter, will help you to define components that can be routed
    to, as well as helping you to define viewports in your application that can be
    switched out. Think of your application as a passepartout or a frame. Inside the
    frame of your application, you can define things such as a top menu or left menu,
    but the painting in the middle is the part of your application that can be switched
    out.  We call that replaceable part a page.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将涵盖构建Angular应用程序的一个非常重要的方面，即路由。路由是一个核心概念，它允许我们将应用程序分成几个逻辑页面。我们谈论逻辑页面而不是实际页面，因为我们正在构建单页面应用程序（SPA）。你会问什么是区别？路由组件，你将在下一章中了解更多信息，将帮助你定义可以路由到的组件，以及帮助你定义应用程序中可以切换的视口。把你的应用程序想象成一个通行证或者一个框架。在应用程序的框架内，你可以定义诸如顶部菜单或左侧菜单之类的东西，但中间的绘画是你的应用程序中可以切换的部分。我们称之为可替换部分的页面。
