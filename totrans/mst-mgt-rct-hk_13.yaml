- en: '*Chapter 10*: Use Case Scenario 4 – React Tracked'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Tracked ([https://react-tracked.js.org](https://react-tracked.js.org))
    is a library for state usage tracking that optimizes re-renders automatically
    based on property access. It provides the same functionality to eliminate extra
    re-renders as Valtio, which we discussed in [*Chapter 9*](B17780_09_Final_VK_ePub.xhtml#_idTextAnchor116),
    *Use Case Scenario 3 – Valtio*.
  prefs: []
  type: TYPE_NORMAL
- en: React Tracked can be used with other state management libraries. The primary
    use case is `useState` or `useReducer`, but it can also be used with Redux ([https://redux.js.org](https://redux.js.org)),
    Zustand (discussed in [*Chapter 7*](B17780_07_Final_VK_ePub.xhtml#_idTextAnchor092),
    *Use Case Scenario 1 – Zustand*), and other similar libraries.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will again discuss optimizing re-renders with state usage
    tracking and compare related libraries. We will learn two usages of React Tracked,
    one with `useState` and the other with React Redux ([https://react-redux.js.org](https://react-redux.js.org)).
    We will wrap up with a look at how React Tracked will work with the future version
    of React.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding React Tracked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using React Tracked with `useState` and `useReducer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using React Tracked with React Redux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Future prospects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are expected to have a moderate amount of knowledge about React, including
    React Hooks. Refer to the official site, [https://reactjs.org](https://reactjs.org),
    to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: In some code, we use TypeScript ([https://www.typescriptlang.org](https://www.typescriptlang.org)),
    and you should have basic knowledge of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in this chapter is available on GitHub: [https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_10](https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_10).'
  prefs: []
  type: TYPE_NORMAL
- en: To run the code snippets, you need a React environment – for example, Create
    React App ([https://create-react-app.dev](https://create-react-app.dev)) or CodeSandbox
    ([https://codesandbox.io](https://codesandbox.io)).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding React Tracked
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been learning about several global state libraries, but React Tracked
    is slightly different from the ones we have learned about so far. React Tracked
    doesn't provide state functionality, but what it does provide is render optimization
    functionality. We call this functionality **state usage tracking**.
  prefs: []
  type: TYPE_NORMAL
- en: Let's recap how React Context behaves because one of the use cases of state
    usage tracking in React Tracked is for a React Context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we define a Context with `createContext` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`createContext` takes an initial value, which is an array in this case. The
    first item in the array is an initial state object. The second item in the array,
    `() => {}`, is a dummy updating function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason we put such an array as the initial value is to match the return
    value of `useState`. We often define `NameProvider` with `useState` for a global
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You should usually use the `NameProvider` component in a root component or some
    component close to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the `NameProvider` component, we can consume it under its
    tree. To consume the Context value, we use `useContext`. Let''s assume we only
    need `firstName` and define a `useFirstName` hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This works fine. However, there's a possibility of extra re-renders. If we update
    only `lastName` without changing `firstName`, the new Context value will be propagated
    and `useContext(NameContext)` triggers a re-render. The `useFirstName` hook only
    reads `firstName` from the Context value. Hence, this becomes an extra re-render.
  prefs: []
  type: TYPE_NORMAL
- en: This behavior is obvious from an implementation point of view. But from a developer's
    point of view, it doesn't seem ideal because it only uses `firstName` from the
    Context value. From the developer's point of view, the expectation would be that
    it doesn't depend on other properties – in this case, `lastName`.
  prefs: []
  type: TYPE_NORMAL
- en: State usage tracking is the feature that realizes this expected behavior. If
    we only use `firstName` in the state object, we expect the hook to trigger re-renders
    only when `firstName` changes. This can be accomplished with proxies.
  prefs: []
  type: TYPE_NORMAL
- en: 'React Tracked allows us to define a hook called `useTracked`, which can be
    used instead of `useContext(NameContext)`. `useTracked` wraps the state with proxies
    and tracks its usage. The expected usage of `useTracked` looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The usage doesn't differ from the usage of `useContext(NameContext)`. This is
    the whole point of state usage tracking. Our code looks just as usual, but behind
    the scenes, it tracks the state usage and optimizes renders automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Automatic render optimization was discussed in [*Chapter 9*](B17780_09_Final_VK_ePub.xhtml#_idTextAnchor116),
    *Use Case Scenario 3 – Valtio*. React Tracked and Valtio use the same state usage
    tracking feature. Actually, they use the same internal library, which is called
    `proxy-compare`: [https://github.com/dai-shi/proxy-compare](https://github.com/dai-shi/proxy-compare).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we revisited state usage tracking and learned how it can optimize
    re-renders. In the next section, we will learn how to use React Tracked with `useState`
    and `useReducer`.
  prefs: []
  type: TYPE_NORMAL
- en: Using React Tracked with useState and useReducer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary use case of React Tracked is to replace a use case of React Context.
    The API in React Tracked is specifically designed for this use case.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore two usages with `useState` and `useReducer`. First, let's learn
    about the usage with `useState`.
  prefs: []
  type: TYPE_NORMAL
- en: Using React Tracked with useState
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before exploring the usage of React Tracked with `useState`, let's revisit how
    we can create a global state with React Context.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first create a custom hook, which calls `useState` with an initial state
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Defining the custom hook is good for TypeScript because you can grab the type
    with the `typeof` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a definition of our Context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It has a type annotation in TypeScript. The default value is `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the Context, we need a `Provider` component. The following is a custom
    `Provider` that uses `useValue` for the Context value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is a component that injects the `StateContext.Provider` component. As we
    defined `useValue` separately, the implementation of `Provider` can use it in
    **JavaScript Syntax Extension** (**JSX**).
  prefs: []
  type: TYPE_NORMAL
- en: 'To consume the Context''s value, we use `useContext`. We define a custom hook
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This custom hook checks the existence of `Provider` by comparing `contextValue`
    with `null`. If it's `null`, it throws an error, and developers will notice that
    `Provider` is missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to define some components for the app. The first component
    is `Counter`, which shows the `count` property of the state as well as a button
    to increment the `count` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that `useStateContext` returns a tuple of the `state` value and the updating
    function. This is exactly the same as what `useValue` returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define the second component, `TextBox`, which shows an input field
    for the `text` property of the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We again use `useStateContext` and get the `state` value and the `setState`
    function. The `setText` function takes a string argument and invokes the `setState`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we define the `App` component, which has the `Provider`, `Counter`,
    and `TextBox` components in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How does this app behave? The Context handles the state object as a whole, and
    `useContext` will trigger re-renders when the state object changes. Even if only
    a single property changes in the state object, all `useContext` hooks trigger
    re-renders. This means that if we click a button in the `Counter` component, it
    increments the `count` property of the state object, and it causes both the `Counter`
    and `TextBox` components to re-render. While the `Counter` component re-renders
    with the new `count` value, the `TextBox` component re-renders with the same `text`
    value. This is an extra re-render.
  prefs: []
  type: TYPE_NORMAL
- en: The extra re-render behavior with Context is expected, and if we want to avoid
    it, we should split it into smaller pieces. Refer to [*Chapter 3*](B17780_03_Final_VK_ePub.xhtml#_idTextAnchor049),
    *Sharing the Component State with Context*, to learn more about best practices
    with React Context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what does it look like with React Tracked? Let''s convert the previous
    example to a new example with React Tracked. First, we import `createContainer`
    from the React Tracked library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use the `useValue` hook defined in `const useValue = () => useState({
    count: 0, text: "hello" });` and call the `createContainer` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: From the results, `Provider` and `useTracked` are extracted. The `Provider`
    component can be used in the same way as in the previous example of this section.
    The `useTracked` hook can be used in the same way as the `useStateContext` hook
    we defined in the previous example of this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the new `useTracked` hook, the `Counter` component becomes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We simply replaced `useStateContext` with `useTracked`. The rest of the code
    is the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, the following is the new `TextBox` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The only change is the replacement of `useStateContext` with `useTracked`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `App` component is exactly the same as in the previous example of this
    section, using the new `Provider` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'How does this new app behave? The `state` object returned by `useTracked` is
    tracked, which means the `useTracked` hook remembers which properties of `state`
    are accessed. The `useTracked` hook will trigger a re-render only if the accessed
    properties are changed. Hence, if you click a button in the `Counter` component,
    only the `Counter` component re-renders, and the `TextBox` component doesn''t
    re-render, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – A screenshot of the app with React Tracked and useState ](img/Figure_10.1_B17780.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – A screenshot of the app with React Tracked and useState
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, what we changed is `createContainer` instead of `createContext`,
    and `useTracked` instead of `useStateContext`. The result gives us optimized re-renders.
    This is the state usage tracking feature.
  prefs: []
  type: TYPE_NORMAL
- en: The `useValue` custom hook we passed to the `createContainer` function can be
    anything as long as it returns a tuple such as `useState`. Let's look at another
    example using `useReducer`.
  prefs: []
  type: TYPE_NORMAL
- en: Using React Tracked with useReducer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we use `useReducer` instead of `useState`. The `useReducer`
    hook is an advanced hook with more features, but it's mostly syntactic difference.
    Refer to the *Exploring the similarity and difference between useState and useReducer*
    section in [*Chapter 1*](B17780_01_Final_VK_ePub.xhtml#_idTextAnchor012), *What
    Is Micro State Management with React Hooks?*, for more detailed discussions.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note about useReducer
  prefs: []
  type: TYPE_NORMAL
- en: The `useReducer` hook is an official React hook. It takes a reducer function
    to update states. A reducer function is a programming pattern, not related to
    React or even JavaScript. The `useReducer` hook applies the pattern to states.
    The reducer function in React is popularized by Redux. The `useReducer` covers
    Redux's use cases in terms of the reduce pattern. However, it doesn't cover the
    other Redux use cases, such as React Redux and store enhancer or middleware. The
    `useReducer` hook accepts any kind of actions unlike Redux, which requires an
    action to be an object with a `type` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new `useValue` hook uses `useReducer` and `useEffect`. `useReducer` is
    defined with a reducer function and an initial state. `useEffect` has a function
    that logs the state value to the console. The following is the `useValue` code
    in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The reducer function accepts action types of `INC` and `SET_TEXT`. The `useEffect`
    hook is used in console logging, but it's not limited to it. For example, it can
    interact with remote resources. The `useValue` hook returns a tuple of `state`
    and `dispatch`. As long as the return tuple follows this shape, we can implement
    the hook as we like. For example, we could use more than one `useState` hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the new `useValue` hook, we run `createContainer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The way we use `createContainer` doesn't change, even if we change `useValue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the new `useTracked` hook, we implement the `Counter` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Because `useTracked` returns the same shaped tuple as `useValue` returns, we
    name the second item in the tuple `dispatch`, which is a function that dispatches
    an action. The `Counter` component dispatches an `INC` action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the `TextBox` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Likewise, the `dispatch` function is used for a `SET_TEXT` action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The behavior of the new `App` component is exactly the same as the previous
    one. The difference between the examples with `useState` and `useReducer` is that
    `useValue` returns a tuple of `state` and `dispatch`; thus `useTracked` also returns
    a tuple of `state` and `dispatch`.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why React Tracked can optimize re-renders is not only state usage
    tracking but also its internal library called `use-context-selector` ([https://github.com/dai-shi/use-context-selector](https://github.com/dai-shi/use-context-selector)).
    It allows us to subscribe to the Context value with a `selector` function. This
    subscription bypasses the limitations of React Context.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we saw a basic example with bare React Context, and two examples
    with React Tracked with `useState` and `useReducer`. In the next section, we will
    learn a usage of React Tracked with React Redux, which uses the state usage tracking
    feature without `use-context-selector`.
  prefs: []
  type: TYPE_NORMAL
- en: Using React Tracked with React Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary use case of React Tracked is to replace a use case of React Context.
    This is done by using `use-context-selector` internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'React Tracked exposes a low-level function called `createTrackedSelector` to
    cover non-React Context use cases. It takes a hook called `useSelector` and returns
    a hook called `useTrackedState`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`useSelector` is a hook that takes a selector function and returns the result
    of the selector function. It will trigger re-renders when the result changes.
    `useTrackedState` is a hook that returns an entire state wrapped in proxies to
    track the `state` usage.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a concrete example with React Redux. This provides a `useSelector`
    hook, and it's straightforward to apply `createTrackedSelector`.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note about React Redux
  prefs: []
  type: TYPE_NORMAL
- en: React Redux uses React Context internally, but it doesn't use Context for propagating
    a state value. It uses React Context for dependency injection, and the state propagation
    is done by subscription. React Redux's `useSelector` is optimized to re-render
    only if the selector result changes. This is not possible with Context propagation
    at the time of writing. There are many other libraries that take the same approach,
    and in fact, the `use-context-selector` UserLand solution is the same too.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import some functions from libraries, namely `redux`, `react-redux`,
    and `react-tracked`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The first two import lines are a traditional React Redux setup. The third line
    is our addition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define a Redux store with `initialState` and `reducer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is one traditional way to create a Redux store. Note that it has nothing
    to do with React Tracked, and any way of creating a Redux store would work.
  prefs: []
  type: TYPE_NORMAL
- en: '`createTrackedSelector` allows us to create the `useTrackedState` hook from
    the `useSelector` hook, which is imported directly from `react-redux`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We need to explicitly type the hook with `<State>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `useTrackedState`, the `Counter` component is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This should be mostly like a normal React Redux pattern except for the `useTrackedState`
    line. In React Redux, it would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The change may seem trivial, but with `useSelector`, developers have more control
    and responsibility for re-renders, whereas with `useTrackedState`, the hook controls
    re-renders automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, the `TextBox` component is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we used `useTrackedState` instead of `useSelector` for automatic render
    optimization. To explain how automatic render optimization is useful, let''s imagine
    that `TextBox` takes a `showCount` prop property, which is a Boolean value to
    show the `count` value in `state`. We can modify the `TextBox` component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note that we didn't change the `useTrackedState` line at all. With a single
    `useSelector`, implementing the same behavior would be difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the following is the `App` component to combine all components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is exactly the same as using normal React Redux without React Tracked.
    The re-renders are optimized in this app, which means clicking a button only triggers
    the `Counter` component to re-render, and the `TextBox` component won''t re-render,
    as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – A screenshot of the app with React Tracked and React Redux
    ](img/Figure_10.2_B17780.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – A screenshot of the app with React Tracked and React Redux
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to use React Tracked with a non-React Context
    use case. Next, we will discuss what React Tracked can look like with a future
    version of React.
  prefs: []
  type: TYPE_NORMAL
- en: Future prospects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The implementation of React Tracked depends on two internal libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '`proxy-compare` ([https://github.com/dai-shi/proxy-compare](https://github.com/dai-shi/proxy-compare))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`use-context-selector` ([https://github.com/dai-shi/use-context-selector](https://github.com/dai-shi/use-context-selector))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we learned in the *Using React Tracked with useState and useReducer* section
    and the *Using React Tracked with React Redux* section, there are two ways to
    use React Tracked. The first way is via React Context with `createContainer` and
    the second is via React Redux with `createTrackedSelector`. The base function
    is `createTrackedSelector`, which is implemented with the `proxy-compare` library.
    The `createContainer` function is a higher abstraction, which is implemented with
    `createTrackedSelector` and the `use-context-selector` library.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of the use of Context in React Tracked, the `use-context-selector`
    library is important. What is the role of `use-context-selector`? It provides
    a `useContextSelector` hook. As we learned in the *Understanding Context* section
    in [*Chapter 3*](B17780_03_Final_VK_ePub.xhtml#_idTextAnchor049), *Sharing the
    Component State with Context*, React Context is designed so that all Context consumer
    components re-render when the Context value is changed. There is a proposal to
    improve the Context behavior – `useContextSelector`. The `use-context-selector`
    library is a Userland library that emulates the proposed `useContextSelector`
    hook as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: It's very uncertain at the point of writing, but a future version of React may
    implement `useContextSelector`, or a similar form of it. In this situation, React
    Tracked can easily migrate from the `use-context-selector` library to a native
    `useContextSelector`. Hopefully, this should give full compatibility with React
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting `use-context-selector` away in the implementation of React Tracked
    helps migration. If React has an official `useContextSelector` hook in the future,
    React Tracked can migrate without changing its public API. In this implementation
    design, `createTrackedSelector` is a building block function in React Tracked,
    and `createContainer` is a glue function. Exporting both functions allows us to
    have both usages.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed the implementation design of React Tracked and
    how it can migrate to a possible future version of React.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about a library – React Tracked. This library has
    two purposes. One purpose is to replace the use case of React Context. The other
    purpose is to enhance the selector hook provided by some other libraries, such
    as React Redux.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, the React Tracked library is not a global state library. It's to
    be used with state functions, such as `useState` and `useReducer`, or Redux. All
    React Tracked provides is a feature to optimize re-renders.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will compare the three libraries for global state, namely
    Zustand, Jotai, and Valtio, and discuss global state patterns to wrap up this
    book.
  prefs: []
  type: TYPE_NORMAL
