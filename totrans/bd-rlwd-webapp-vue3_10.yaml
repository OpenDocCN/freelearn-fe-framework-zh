- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Creating a Portfolio with Nuxt.js and Storyblok
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Nuxt.js 和 Storyblok 创建作品集
- en: If you’ve been checking off the topics from the to-do list of applications from
    [*Chapter 1*](B19563_01.xhtml#_idTextAnchor015), you may have noticed that we’ve
    reached the final chapter. To celebrate our achievements, we’ll create a portfolio
    where we can showcase our completed projects from the past, with the flexibility
    to add future projects as well. We’ll also look into deploying the portfolio to
    an online space via an automated process.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经从 [*第一章*](B19563_01.xhtml#_idTextAnchor015) 的待办事项列表中检查了应用程序的主题，你可能已经注意到我们已经到达了最后一章。为了庆祝我们的成就，我们将创建一个作品集，在这里我们可以展示我们过去完成的项目，同时也有灵活性添加未来的项目。我们还将探讨通过自动化流程将作品集部署到在线空间。
- en: We’ll build the portfolio using Nuxt ([https://nuxt.com/](https://nuxt.com/)),
    which will greatly speed up our development process. The content will be stored
    in a Storyblok ([https://www.storyblok.com/](https://www.storyblok.com/)) space.
    For publication, we’ll make use of Netlify ([https://www.netlify.com/](https://www.netlify.com/)),
    which is a very developer-friendly platform for hosting modern web apps.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Nuxt ([https://nuxt.com/](https://nuxt.com/)) 来构建作品集，这将大大加快我们的开发过程。内容将存储在
    Storyblok ([https://www.storyblok.com/](https://www.storyblok.com/)) 空间中。对于发布，我们将利用
    Netlify ([https://www.netlify.com/](https://www.netlify.com/))，这是一个非常友好的开发者平台，用于托管现代网络应用。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Refresher on using Nuxt and using Nuxt as a static site renderer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nuxt 的使用复习以及将 Nuxt 作为静态网站渲染器使用
- en: Learning to apply a headless CMS to organize and manage content
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习将无头 CMS 应用于组织和内容管理
- en: Connecting Nuxt and Storyblok using existing integrations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用现有集成连接 Nuxt 和 Storyblok
- en: Applying proven patterns to optimize a website
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用经过验证的模式来优化网站
- en: Automating deployment to a public host
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化部署到公共主机
- en: While we’re going to focus on building the essentials of a portfolio website,
    you should be able to make modifications to further personalize the final product
    so that it can continue serving as your personal portfolio website to showcase
    your talents.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将专注于构建作品集网站的基本要素，但你应该能够进行修改以进一步个性化最终产品，使其能够继续作为你的个人作品集网站来展示你的才能。
- en: Note
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Parts of the project in this chapter are based on a guide published by Storyblok:
    [https://www.storyblok.com/tp/add-a-headless-CMS-to-nuxt-3-in-5-minutes](https://www.storyblok.com/tp/add-a-headless-CMS-to-nuxt-3-in-5-minutes).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章项目的一部分基于 Storyblok 发布的指南：[https://www.storyblok.com/tp/add-a-headless-CMS-to-nuxt-3-in-5-minutes](https://www.storyblok.com/tp/add-a-headless-CMS-to-nuxt-3-in-5-minutes)。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Like in [*Chapter 8*](B19563_08.xhtml#_idTextAnchor233), we’ll use Nuxt ([https://nuxt.com/](https://nuxt.com/))
    as the framework to build our portfolio website. For our styling and interactions,
    we’ll use a UI library that is part of the Nuxt ecosystem: Nuxt UI ([https://ui.nuxt.com/](https://ui.nuxt.com/)).
    We need to run our local development in SSL mode, for which we will use `mkcert`
    ([https://github.com/FiloSottile/mkcert](https://github.com/FiloSottile/mkcert))
    to generate a locally trusted development certificate.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 像在 [*第八章*](B19563_08.xhtml#_idTextAnchor233) 中一样，我们将使用 Nuxt ([https://nuxt.com/](https://nuxt.com/))
    作为构建作品集网站的框架。对于我们的样式和交互，我们将使用 Nuxt 生态系统的一部分 UI 库：Nuxt UI ([https://ui.nuxt.com/](https://ui.nuxt.com/))。我们需要在
    SSL 模式下运行本地开发，为此我们将使用 `mkcert` ([https://github.com/FiloSottile/mkcert](https://github.com/FiloSottile/mkcert))
    生成一个本地可信的开发证书。
- en: Our content will be managed and stored using Storyblok ([https://www.storyblok.com/](https://www.storyblok.com/)),
    which offers an excellent headless **Content Management System** (**CMS**) solution
    with a free tier we can use. A headless CMS is a system that focuses primarily
    on the content and aims to separate the content from the presentation. In our
    case, our presentation is handled by Nuxt, but it could be any application that
    we grant access to the content. This separation of concerns is a concept that
    helps in building scalable applications. Once we have built our portfolio, we
    will use Netlify ([https://www.netlify.com/](https://www.netlify.com/)) to publish
    our portfolio on a public URL.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的内容将通过 Storyblok ([https://www.storyblok.com/](https://www.storyblok.com/))
    进行管理和存储，它提供了一个优秀的无头 **内容管理系统** (**CMS**) 解决方案，我们可以使用其免费层。无头 CMS 是一个主要关注内容的系统，旨在将内容与展示分离。在我们的案例中，我们的展示由
    Nuxt 处理，但它可以是任何我们授予访问内容的任何应用程序。这种关注点的分离有助于构建可扩展的应用程序。一旦我们构建了我们的作品集，我们将使用 Netlify
    ([https://www.netlify.com/](https://www.netlify.com/)) 在公共 URL 上发布我们的作品集。
- en: 'When developing this project, it will help if you have some data prepared beforehand
    to prevent switching contexts during development. Let’s go through previous completed
    projects. For each project we want to display, we prefer a couple of screenshots
    (*Screenshot.rocks* is an excellent browser plugin for creating styled screenshots
    from your window: [https://screenshot.rocks/](https://screenshot.rocks/)) and
    have descriptions prepared.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发这个项目时，如果你事先准备了一些数据，这将有助于防止在开发过程中切换上下文。让我们回顾一下之前完成的项目。对于每个我们想要展示的项目，我们更喜欢准备一些截图（*Screenshot.rocks*是一个从你的窗口创建样式截图的出色浏览器插件：[https://screenshot.rocks/](https://screenshot.rocks/))，并准备描述。
- en: 'You can find the complete code for this chapter here: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/10.portfolio](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/10.portfolio).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到本章的完整代码：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/10.portfolio](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/10.portfolio)。
- en: With several projects prepared, we can get started with the initial content
    setup!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好几个项目后，我们可以开始初始内容设置！
- en: Setting up Storyblok
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Storyblok
- en: 'Registering on the Storyblok website is pretty self-explanatory. After the
    initial registration, you will end up in a demo space. We will skip the demo (you
    can always revisit this as part of **Spaces**) and choose to **Create a new space**,
    where we will choose the appropriate name and server location:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Storyblok网站上注册相当直观。在初始注册后，你将进入一个演示空间。我们将跳过演示（你总是可以将其作为**空间**的一部分重新访问）并选择**创建一个新的空间**，在那里我们将选择适当的名字和服务器位置：
- en: '![Figure 10.1 – Creating a new Storyblok space for our portfolio](img/B19563_10_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 为我们的作品集创建一个新的Storyblok空间](img/B19563_10_01.jpg)'
- en: Figure 10.1 – Creating a new Storyblok space for our portfolio
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 为我们的作品集创建一个新的Storyblok空间
- en: After creation, you may encounter a modal referring to a trial period. You can
    select the free community plan directly or after the 14-day trial period.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，你可能会遇到一个关于试用期的模态窗口。你可以直接选择免费社区计划，或者在14天试用期后选择。
- en: 'The welcome screen will look like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎屏幕看起来像这样：
- en: '![Figure 10.2 – The Storyblok dashboard](img/B19563_10_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – Storyblok仪表板](img/B19563_10_02.jpg)'
- en: Figure 10.2 – The Storyblok dashboard
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – Storyblok仪表板
- en: For the sake of our portfolio, we can close and ignore the **Get Started** section.
    We’ll mainly focus on the **Settings**, **Content**, **Block Library**, and **Assets**
    sections.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的作品集，我们可以关闭并忽略**入门**部分。我们将主要关注**设置**、**内容**、**块库**和**资产**部分。
- en: 'If we open the **Content** section, we’ll see an entry titled **Home**. Let’s
    open it and take a look:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开**内容**部分，我们会看到一个标题为**主页**的条目。让我们打开它看看：
- en: '![Figure 10.3 – The initial wizard on the Home entry](img/B19563_10_03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 主页条目上的初始向导](img/B19563_10_03.jpg)'
- en: Figure 10.3 – The initial wizard on the Home entry
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 主页条目上的初始向导
- en: This screen lets us know that we can preview our content in what Storyblok refers
    to as an **in-context preview**. This means we can load our portfolio in the Storyblok
    environment to offer a very realistic preview of our portfolio!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个屏幕告诉我们，我们可以在Storyblok所说的**上下文预览**中预览我们的内容。这意味着我们可以在Storyblok环境中加载我们的作品集，以提供非常逼真的作品集预览！
- en: Let’s set this up to see what this means in practice. We will need (you may
    have guessed it by this point) the **Access token** value to connect the CMS to
    our application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一下，看看这实际上意味着什么。我们需要（你可能已经猜到了）**访问令牌**值来连接CMS到我们的应用程序。
- en: Initializing the Nuxt portfolio
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化Nuxt作品集
- en: 'We’ll use the `nuxi` Nuxt CLI tool to create a new project, similar to what
    we did in [*Chapter 8*](B19563_08.xhtml#_idTextAnchor233):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`nuxi` Nuxt CLI工具创建一个新的项目，类似于我们在[*第8章*](B19563_08.xhtml#_idTextAnchor233)中做的：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Again, we’ll choose `npm` as our package manager. If you haven’t installed
    the `mkcert` tool ([https://github.com/FiloSottile/mkcert](https://github.com/FiloSottile/mkcert))
    to generate SSL certificates, you need to follow the appropriate installation
    instructions to proceed: [https://github.com/FiloSottile/mkcert#installation](https://github.com/FiloSottile/mkcert#installation).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将选择`npm`作为我们的包管理器。如果你还没有安装用于生成SSL证书的`mkcert`工具([https://github.com/FiloSottile/mkcert](https://github.com/FiloSottile/mkcert))，你需要遵循适当的安装说明来继续：[https://github.com/FiloSottile/mkcert#installation](https://github.com/FiloSottile/mkcert#installation)。
- en: 'Once the installation is done, we can generate a localhost certificate using
    the following command in the command-line interface:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以在命令行界面使用以下命令生成 localhost 证书：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The command should result in an output similar to the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 命令应该产生类似于以下输出的结果：
- en: '![Figure 10.4 – Successfully generated SSL certificate](img/B19563_10_04.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – 成功生成 SSL 证书](img/B19563_10_04.jpg)'
- en: Figure 10.4 – Successfully generated SSL certificate
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – 成功生成 SSL 证书
- en: 'The next thing we need to do is update the development script in the `package.json`
    file so that we can run the Nuxt development servers in SSL mode. Find the following
    command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，我们需要更新 `package.json` 文件中的开发脚本，以便我们可以以 SSL 模式运行 Nuxt 开发服务器。找到以下命令：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Replace it with the following line, which adds the certificate and points the
    process to a `.``env` file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下行替换它，该行添加了证书并将进程指向一个 `.env` 文件：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We’ll also create a `.env` file containing the following information (the **Access
    token** value can be found on the **Welcome** page in Storyblok):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建一个包含以下信息的 `.env` 文件（**访问令牌**值可以在 Storyblok 的 **欢迎** 页面上找到）：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you have skipped the Storyblok **Welcome** page, you can review the token
    via the Storyblok menu. Navigate to **Settings**, then **Access tokens** – it
    should be listed there.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您跳过了 Storyblok **欢迎** 页面，您可以通过 Storyblok 菜单查看令牌。导航到 **设置**，然后 **访问令牌** – 它应该列在那里。
- en: Now, we must run the `npm run dev` command from the terminal to start the development
    server. Note that you can access the server now via the HTTPS protocol!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须从终端运行 `npm run dev` 命令以启动开发服务器。请注意，您现在可以通过 HTTPS 协议访问服务器！
- en: On the Storyblok **Welcome** page, we can now fill in the **Set up preview URL**
    field so that it contains the local URL (this should be similar to the prefilled
    placeholder). Don’t forget the trailing slash!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Storyblok **欢迎** 页面上，我们现在可以填写 **设置预览 URL** 字段，使其包含本地 URL（这应该与预先填充的占位符相似）。不要忘记结尾的斜杠！
- en: 'If you get an error in Storyblok, you may need to open the URL in your browser
    first as the browser might flag the local certificate as not private. If you accept
    the certificate in your browser, you can reload the Storyblok interface; it should
    show the Nuxt welcome page:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 Storyblok 中遇到错误，您可能需要首先在浏览器中打开该 URL，因为浏览器可能会将本地证书标记为不安全。如果您在浏览器中接受证书，您可以重新加载
    Storyblok 界面；它应该显示 Nuxt 欢迎页面：
- en: '![Figure 10.5 – The Nuxt welcome screen loaded in the Storyblok interface!](img/B19563_10_05.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – 在 Storyblok 界面中加载的 Nuxt 欢迎屏幕！](img/B19563_10_05.jpg)'
- en: Figure 10.5 – The Nuxt welcome screen loaded in the Storyblok interface!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 在 Storyblok 界面中加载的 Nuxt 欢迎屏幕！
- en: This is pretty neat! You’re able to see a locally run preview from an online
    CMS interface! Nothing is editable yet, but we’ll work on this next.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常方便！您现在可以从在线 CMS 界面看到本地运行的预览！目前还没有可编辑的内容，但我们将在下一阶段进行改进。
- en: Installing Nuxt modules
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Nuxt 模块
- en: 'For now, we can stop the Nuxt server to install some Nuxt modules we’ll be
    using. In the terminal, use the following command to install the Storyblok module
    ([https://github.com/storyblok/storyblok-nuxt](https://github.com/storyblok/storyblok-nuxt)):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '目前，我们可以停止 Nuxt 服务器以安装我们将要使用的 Nuxt 模块。在终端中，使用以下命令安装 Storyblok 模块 ([https://github.com/storyblok/storyblok-nuxt](https://github.com/storyblok/storyblok-nuxt)):'
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The *Storyblok Nuxt* module is an SDK that has opinionated, and therefore low-code,
    integration with Nuxt. It supports auto-importing and can map Vue components directly
    to Storyblok entities with very little effort.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*Storyblok Nuxt* 模块是一个具有意见化且因此低代码集成的 SDK，与 Nuxt 集成。它支持自动导入，并且可以非常容易地将 Vue 组件直接映射到
    Storyblok 实体。'
- en: 'We need to add a little configuration before the *Storyblok Nuxt* module can
    function properly, so let’s open the `nuxt.config.ts` file and modify it so that
    it has the following contents:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Storyblok Nuxt* 模块能够正常工作之前，我们需要添加一些配置，因此让我们打开 `nuxt.config.ts` 文件并修改它，使其包含以下内容：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you’re operating from a different region, be sure to pick the corresponding
    region.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在另一个区域操作，请确保选择相应的区域。
- en: 'While we’re setting up the modules, we can add the UI library ([https://ui.nuxt.com/](https://ui.nuxt.com/))
    at this point too. We’ll install the library from the terminal with the following
    command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在设置模块时，我们也可以在这个时候添加 UI 库 ([https://ui.nuxt.com/](https://ui.nuxt.com/))。我们将使用以下命令从终端安装库：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once the installation is done, we need to register the module by adding the
    module’s name to the `modules` property in `nuxt.config.ts`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们需要通过在 `nuxt.config.ts` 文件中的 `modules` 属性中添加模块的名称来注册该模块：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Before we start adding our own content to the CMS, let’s test whether we can
    show the contents from Storyblok in our application.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始向 CMS 添加自己的内容之前，让我们测试一下我们是否可以在我们的应用程序中显示 Storyblok 的内容。
- en: 'First, we’ll open the **Home** entry in the **Content** section. Using **Entry
    configuration**, we’ll tell Storyblok that this page is published on the root
    of the domain, using the **Real** **path** property:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在 **内容** 部分的 **Home** 条目中打开。使用 **条目配置**，我们将告诉 Storyblok，这个页面是通过 **实路径**
    属性在域根处发布的：
- en: '![Figure 10.6 – Updating the Real path value for our home page](img/B19563_10_06.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – 更新主页的实路径值](img/B19563_10_06.jpg)'
- en: Figure 10.6 – Updating the Real path value for our home page
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 更新主页的实路径值
- en: This change makes the contents of the **Home** page available on the main URL
    of our application. As mentioned previously, Storyblok offers a low-code SDK to
    integrate the CMS with our application. “Low-code” often means that we need to
    adopt certain patterns.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改使得 **主页** 的内容可以在我们应用程序的主 URL 上可用。如前所述，Storyblok 提供了一个低代码 SDK，用于将 CMS 与我们的应用程序集成。“低代码”通常意味着我们需要采用某些模式。
- en: One of the things that the SDK does for us, for instance, is map the contents
    from the Block library to Vue components.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: SDK 为我们做的事情之一，例如，是将块库的内容映射到 Vue 组件。
- en: 'For this to work, we need to place those components in a `./storyblok` folder
    at the root of our project. For our test, we need to create two files. First,
    we’ll start with `Page.vue` in the `./``storyblok` folder:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要将这些组件放置在我们项目的根目录下的 `./storyblok` 文件夹中。为了我们的测试，我们需要创建两个文件。首先，我们将在
    `./storyblok` 文件夹中开始创建 `Page.vue` 文件：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we’ll create a `Teaser.vue` file in the same folder:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在同一文件夹中创建一个 `Teaser.vue` 文件：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `v-editable` directives are important to note in these files since they
    signal back to Storyblok that the contents of these blocks are indeed editable.
    We can now start creating a `./pages` folder in our application and temporarily
    create an `index.vue` file with the following contents:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些文件中需要注意 `v-editable` 指令，因为它们向 Storyblok 信号，这些块的内容确实是可编辑的。我们现在可以在我们的应用程序中创建一个
    `./pages` 文件夹，并临时创建一个包含以下内容的 `index.vue` 文件：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s create a simple layout for our website. First, we’ll place a `Header.vue`
    file in a `./components` folder: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/10.portfolio/.notes/10.1-Header.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/10.portfolio/.notes/10.1-Header.vue).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的网站创建一个简单的布局。首先，我们将在 `./components` 文件夹中放置一个 `Header.vue` 文件：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/10.portfolio/.notes/10.1-Header.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/10.portfolio/.notes/10.1-Header.vue)。
- en: 'We must also create another file called `Footer.vue` in the same folder: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/10.portfolio/.notes/10.2-Footer.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/10.portfolio/.notes/10.2-Footer.vue).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须在同一文件夹中创建另一个名为 `Footer.vue` 的文件：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/10.portfolio/.notes/10.2-Footer.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/10.portfolio/.notes/10.2-Footer.vue)。
- en: 'In both of these templates, we’re using some Nuxt UI components, but other
    than that, nothing special is going on. We’ll complete the base layout by creating
    a `default.vue` file in the `./``layouts` folder:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个模板中，我们都在使用一些 Nuxt UI 组件，但除此之外，没有其他特别之处。我们将通过在 `./layouts` 文件夹中创建一个 `default.vue`
    文件来完成基本布局：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With the page structure (albeit limited) in place, we can remove the `app.vue`
    file from our project’s root. In the Storyblok interface, you will see a **Hello
    world!** message, replacing the Nuxt welcome view. Opening the development server
    in a browser window will yield the same result. Now, if you change the text in
    Storyblok and save the change, you will see it reflected in both the Storyblok
    interface as well as directly in the browser!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面结构（尽管有限）就绪后，我们可以从项目的根目录中移除 `app.vue` 文件。在 Storyblok 界面中，你会看到一个 **Hello world!**
    消息，取代了 Nuxt 欢迎视图。在浏览器窗口中打开开发服务器将得到相同的结果。现在，如果你在 Storyblok 中更改文本并保存更改，你将看到它在 Storyblok
    界面以及直接在浏览器中都有所反映！
- en: '![Figure 10.7 – Updating and saving the contents of the home page](img/B19563_10_07.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7 – 更新并保存主页内容](img/B19563_10_07.jpg)'
- en: Figure 10.7 – Updating and saving the contents of the home page
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 更新并保存主页内容
- en: Here, you can see how very little we needed to manually configure and set up
    to establish a connection! If we use the correct naming convention for our Storyblok
    components, the SDK can automatically populate the components with the content
    from Storyblok using the slug. On top of that, those components are editable in
    the Storyblok editor view.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们手动配置和设置以建立连接所需是多么少！如果我们为我们的Storyblok组件使用正确的命名约定，SDK可以自动使用slug将Storyblok中的内容填充到组件中。除此之外，这些组件在Storyblok编辑器视图中也是可编辑的。
- en: Apart from automatically mapping contents to components, the SDK also helps
    in identifying the URL and providing the corresponding contents. In the next section,
    we’ll add more content to the CMS so that we can start to explore this connection
    a bit better!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了自动将内容映射到组件之外，SDK还有助于识别URL并提供相应的内容。在下一节中，我们将向CMS添加更多内容，以便我们可以更好地探索这种连接！
- en: What we’ve done so far is set up pages. With Storyblok, you can easily create
    and modify pages using predetermined components. These are the **bloks**. Having
    a collection of reusable blocks allows editors to create a page and compose the
    contents by adding bloks and configuring them. Having the preview option available
    allows editors to see the changes before they’re deployed, which is a valuable
    feature of Storyblok.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止所做的是设置页面。使用Storyblok，你可以轻松地创建和修改页面，使用预定义的组件。这些是**bloks**。拥有可重复使用的bloks集合允许编辑者通过添加bloks并配置它们来创建页面和组合内容。预览选项的可用性允许编辑者在部署前看到更改，这是Storyblok的一个宝贵功能。
- en: Working with multiple content types
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与多种内容类型协同工作
- en: 'To define the types and content to use on our pages, we can navigate to **Block
    library** in Storyblok. By default, you will see four existing blocks: **feature**,
    **grid**, **page**, and **teaser**. Between the blocks, there are two different
    types. **page** is of the **Content** type, while the rest are of the **Nestable**
    type. The key difference is that **Content type** is a top-level type of content.
    You can consider it a sort of page with a unique URL. You use this to hold different
    compositions of the lower level of content type – that is, **Nestable**. These
    are the building blocks of the pages: you can add them to a page to build the
    content you like.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义我们页面上要使用的类型和内容，我们可以导航到Storyblok中的**Block library**。默认情况下，你会看到四个现有的bloks：**feature**、**grid**、**page**和**teaser**。在bloks之间，有两种不同的类型。**page**是**Content**类型，而其余的是**Nestable**类型。关键区别在于**Content
    type**是内容的一个顶级类型。你可以把它看作是一种具有独特URL的页面。你使用它来保存不同层次的内容类型的组合——即**Nestable**。这些是页面的构建块：你可以将它们添加到页面中，以构建你喜欢的页面内容。
- en: There’s also **Universal type**, which can act as either of the aforementioned
    types. We won’t use it in our example, though.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有**Universal type**，它可以充当上述任何一种类型。尽管如此，我们不会在我们的示例中使用它。
- en: 'Let’s create a new block for our portfolio purposes by clicking on the `portfolio`
    since lowercase is preferred in this case. This will be a **Content type** block,
    and we’ll configure the type by clicking on the **Add Block** button. Next, we’ll
    add the minimum fields we’ll need to present a project in our portfolio. Let’s
    go with the following settings:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过点击`portfolio`（在这种情况下，小写是首选）来创建一个新的bloks以用于我们的投资组合。这将是一个**Content type**
    bloks，我们将通过点击**Add Block**按钮来配置类型。接下来，我们将添加我们展示项目所需的最小字段。让我们使用以下设置：
- en: Add a `title` field name of the **Text** type.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**Text**类型的**title**字段名称。
- en: 'Add an `image` field name of the **Asset** type:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**Asset**类型的**image**字段名称：
- en: After creation, configure the field to only allow **Images**.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建后，配置字段以仅允许**Images**。
- en: Add a `description` field name of the `150` characters.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`150`字符的**description**字段名称。
- en: Add a `body` field name of the **Richtext** type.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个**Richtext**类型的**body**字段名称。
- en: Now, we’ll start to add some entries to the portfolio by navigating to the **Content**
    section of the Storyblok interface.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过导航到Storyblok界面的**Content**部分，开始向我们的投资组合添加一些条目。
- en: Configuring the portfolio
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置投资组合
- en: We want our portfolio to be published on a `/portfolio` path, where the slug
    is added to the URL. On the `/portfolio` path, eventually, we will want to show
    an overview of projects. In the `Portfolio`. The slug will be filled in automatically.
    Note the **Content type** field, where we can restrict what types of content can
    be shown as part of the folder. We’ll keep the default settings for now, but we’ll
    circle back to that option in a few steps. Click **Create** to add the folder
    to our content.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的投资组合在`/portfolio`路径上发布，其中slug会添加到URL中。在`/portfolio`路径上，最终我们希望展示项目的概览。在`Portfolio`中。slug将自动填充。注意**内容类型**字段，我们可以限制可以显示为文件夹一部分的内容类型。我们现在将保持默认设置，但稍后我们会回到这个选项。点击**创建**将文件夹添加到我们的内容中。
- en: Because we want to present an overview of projects on the root section of the
    portfolio, we’ll navigate to the folder and create a new entry, but this time,
    we’ll choose `Home`, and we must check the **Define as root for the folder** checkbox
    when creating it. For the content type, we’ll use the default, which is **Page**.
    Storyblok will attempt to open the page, which will result in either the server
    being unavailable if you haven’t started it or a **404 not found** error since
    we have not defined a target for this route. That’s okay – we’ll solve that in
    the *Mapping content to code* section. We need to configure this page using **Entry
    configuration** and check the **Define as root for the folder** checkbox. This
    option removes the slug value, which is precisely what we will need.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们要在投资组合的根部分展示项目概览，我们将导航到文件夹并创建一个新的条目，但这次我们将选择`Home`，并在创建时必须勾选**将文件夹定义为根**复选框。对于内容类型，我们将使用默认设置，即**页面**。Storyblok将尝试打开页面，这可能会导致服务器不可用（如果你还没有启动它）或出现**404未找到**错误，因为我们还没有为这个路由定义目标。没关系
    – 我们将在*将内容映射到代码*部分解决这个问题。我们需要使用**条目配置**来配置这个页面，并勾选**将文件夹定义为根**复选框。这个选项会移除slug值，这正是我们所需要的。
- en: 'Although we added a type page here, we want to restrict the rest of the content
    so that it exclusively has `Portfolio` entries. For that, we’ll move to the root
    of the `Portfolio` folder entry so that we can edit the folder properties once
    more:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这里添加了一个类型页面，但我们希望限制其余内容，使其仅包含`Portfolio`条目。为此，我们将移动到`Portfolio`文件夹条目的根目录，这样我们就可以再次编辑文件夹属性：
- en: '![Figure 10.8 – Updating the settings for the Portfolio folder](img/B19563_10_08.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – 更新投资组合文件夹的设置](img/B19563_10_08.jpg)'
- en: Figure 10.8 – Updating the settings for the Portfolio folder
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 更新投资组合文件夹的设置
- en: 'This opens the same modal as when we created the folder. We’ll use this to
    restrict further additions to the contents of the `Portfolio` folder by checking
    the **Restrict content types** option and selecting the **Portfolio** type:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开与创建文件夹时相同的模态框。我们将使用这个来通过勾选**限制内容类型**选项并选择**投资组合**类型来进一步限制对`Portfolio`文件夹内容的添加：
- en: '![Figure 10.9 – Restricting the content type for the Portfolio folder](img/B19563_10_09.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图10.9 – 限制投资组合文件夹的内容类型](img/B19563_10_09.jpg)'
- en: Figure 10.9 – Restricting the content type for the Portfolio folder
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 – 限制投资组合文件夹的内容类型
- en: This doesn’t affect our previously created home page, but it will affect future
    entries. So, let’s create a couple of portfolio entries. You can choose what you
    want to showcase – I recommend adding *at least two items* for the sake of this
    section. We will add more later to showcase the preview’s capabilities!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会影响我们之前创建的主页，但它将影响未来的条目。所以，让我们创建一些投资组合条目。你可以选择你想要展示的内容 – 我建议为了这个部分至少添加*两项*。我们稍后会添加更多来展示预览的功能！
- en: Mapping content to code
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将内容映射到代码
- en: 'First, we’ll focus on regular pages since we have more than one to deal with
    now. We can remove the `./pages/index.vue` file completely and replace it with
    a file called `./pages/[...slug].vue`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将关注常规页面，因为我们现在要处理的不止一个。我们可以完全删除`./pages/index.vue`文件，并用一个名为`./pages/[...slug].vue`的文件来替换它：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With this code in place, we should be able to render a simplistic page. Let’s
    take a look at the home page for the **portfolio** section. If we open it in Storyblok,
    we’ll see a blank page. In the **Content** panel on the right-hand side, we can
    add a new block – for instance, the **Teaser** block.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里放置了这段代码后，我们应该能够渲染一个简单的页面。让我们看看**投资组合**部分的首页。如果我们打开它，在Storyblok中，我们会看到一个空白页面。在右侧的**内容**面板中，我们可以添加一个新的块
    – 例如，**预告**块。
- en: 'Let’s drag the **Teaser** block in and give it a fitting title for a portfolio
    overview page:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拖入 **预告** 块并为其提供一个适合投资组合概览页的标题：
- en: '![Figure 10.10 – Rendering a Teaser block on the page in preview mode](img/B19563_10_10.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图10.10 – 在预览模式下在页面上渲染预告块](img/B19563_10_10.jpg)'
- en: Figure 10.10 – Rendering a Teaser block on the page in preview mode
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 – 在预览模式下在页面上渲染预告块
- en: Again, the preview we’re seeing is immediately visible when we access the development
    URL in the browser as well!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们在浏览器中访问开发 URL 时，我们看到的预览立即可见！
- en: So, what’s happening here? We’ve used the Nuxt capability of file-based routing
    to land our application on the `[...slug].vue` page. On this page, we’re reading
    the `slug` route parameter to query the Storyblok content using the `useAsyncStoryblok`
    composable. In the template, we’re relying on the `<StoryBlokComponent />` component
    that the Storyblok SDK exposes to dynamically load the corresponding components
    from the `./storyblok` folder to reflect items in the Block library from the CMS.
    Because of the auto-imports by the Nuxt framework, we have a very clean setup
    for our page!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里发生了什么？我们使用了基于文件的 Nuxt 路由功能，使我们的应用程序落在 `[...slug].vue` 页面上。在这个页面上，我们通过 `useAsyncStoryblok`
    可组合函数读取 `slug` 路由参数来查询 Storyblok 内容。在模板中，我们依赖于 Storyblok SDK 提供的 `<StoryBlokComponent
    />` 组件，从 `./storyblok` 文件夹动态加载相应的组件，以反映 CMS 中的区块库中的项目。由于 Nuxt 框架的自动导入，我们为页面提供了一个非常干净的设置！
- en: 'You may have noticed that the `./storyblok` folder’s contents do not match
    the number of blocks in the library. Let’s quickly fix that: you will need to
    make sure these are always aligned to support the different scenarios.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，`./storyblok` 文件夹的内容与库中的区块数量不匹配。让我们快速修复这个问题：您需要确保这些始终对齐以支持不同的场景。
- en: 'We’ll fix this with a minimal setup for the components. First, we’ll create
    a `Feature.vue` component in the `./storyblok` folder with the following contents:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用组件的最小设置来修复这个问题。首先，我们在 `./storyblok` 文件夹中创建一个 `Feature.vue` 组件，内容如下：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, in the same folder, we’ll create a `Grid.vue` file:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在同一个文件夹中，我们将创建一个 `Grid.vue` 文件：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, this file is slightly different from a `Feature.vue` file since
    it can contain nested Storyblok components. We can simply feed those to `<StoryblokComponent
    />` to render the correct component for every possible level of recursiveness.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个文件与 `Feature.vue` 文件略有不同，因为它可以包含嵌套的 Storyblok 组件。我们可以简单地将这些组件传递给 `<StoryblokComponent
    />` 以渲染每个可能递归级别的正确组件。
- en: Presenting the portfolio section
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展示投资组合部分
- en: 'Our **portfolio** section consists of roughly two cases: we want to present
    an overview of all portfolio items on the home page for the section and we want
    to present an individual case on its own page.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 **投资组合** 部分大致由两种情况组成：我们希望在主页上展示所有投资组合项目的概览，并且我们希望在单独的页面上展示单个案例。
- en: 'First, let’s create the overview by creating a new block in `portfolio-all`
    and make it a nestable block. In the field editor, add the following fields:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过在 `portfolio-all` 中创建一个新的区块来创建概览，并将其设置为可嵌套的区块。在字段编辑器中，添加以下字段：
- en: Add a `title` field name of the **Text** type.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 **文本** 类型的 `title` 字段。
- en: Add a `description` field name of the `150` characters.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `description` 的 `150` 字符字段。
- en: Add a `body` field name of the **Richtext** type.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个 **富文本** 类型的 `body` 字段。
- en: 'After saving, we can update the **portfolio** home page. We can remove the
    **Headline** block since we don’t need it anymore. Drag in the new **Portfolio
    All** component and add some sensible text:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 保存后，我们可以更新 **投资组合** 主页。我们可以移除不再需要的 **标题** 块。拖入新的 **投资组合所有** 组件并添加一些合理的文本：
- en: '![Figure 10.11 – Configuring the Portfolio All block](img/B19563_10_11.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图10.11 – 配置投资组合所有区块](img/B19563_10_11.jpg)'
- en: Figure 10.11 – Configuring the Portfolio All block
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 – 配置投资组合所有区块
- en: 'As we’ve learned, we need to make sure we have a counterpart component in our
    `./storyblok` folder. The naming convention follows camel case, so we need to
    create a `PortfolioAll.vue` component in the folder ([https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/10.portfolio/.notes/10.3-PortfolioAll.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/10.portfolio/.notes/10.3-PortfolioAll.vue)):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，我们需要确保在我们的 `./storyblok` 文件夹中有一个对应的组件。命名约定遵循驼峰式，因此我们需要在文件夹中创建一个 `PortfolioAll.vue`
    组件（[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/10.portfolio/.notes/10.3-PortfolioAll.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/10.portfolio/.notes/10.3-PortfolioAll.vue)）：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `<PortfolioAll />` component is a bit more complicated. While it has a lot
    in common with the `Page` component in the sense that it is getting props, we
    also manually request additional data using the `useStoryblokApi` composable (lines
    11-16). We’re getting all the stories on the portfolio path. `is_startpage` signals
    that we want to exclude the home page of the portfolio section. On receiving the
    data, we store it in the `projects` reference (lines 9 and 20) so that we can
    iterate over it in the template and we use Nuxt UI’s `<ULink />` component to
    render a link to the project’s page.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`<PortfolioAll />` 组件稍微复杂一些。虽然它在获取 props 的意义上与 `Page` 组件有很多共同之处，但我们还手动使用 `useStoryblokApi`
    可组合函数（第 11-16 行）请求额外的数据。我们获取了所有在投资组合路径上的故事。`is_startpage` 信号表示我们想要排除投资组合部分的首页。在接收到数据后，我们将其存储在
    `projects` 引用（第 9 和 20 行）中，以便我们可以在模板中遍历它，并使用 Nuxt UI 的 `<ULink />` 组件来渲染指向项目页面的链接。'
- en: 'There’s another addition: since we’ve defined a rich-text field for the *body*
    of the home page, we need to make sure it gets rendered properly. We can use the
    `renderRichText` function from Storyblok (*line 18*) as a computed value.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另外还有一个新增功能：由于我们为首页的 *body* 定义了一个富文本字段，我们需要确保它被正确渲染。我们可以使用 Storyblok 的 `renderRichText`
    函数（*第 18 行*）作为一个计算值。
- en: 'Let’s build the portfolio detail page as well, to close this section for now.
    Again, we need to create the corresponding component in the `./storyblok` folder
    to have it automatically mapped to the URL. Since we’re displaying the `Portfolio.vue`
    component: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/10.portfolio/.notes/10.4-Portfolio.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/10.portfolio/.notes/10.4-Portfolio.vue).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再构建一个投资组合详情页面，以暂时结束这一部分。同样，我们需要在 `./storyblok` 文件夹中创建相应的组件，以便它自动映射到 URL。由于我们正在显示
    `Portfolio.vue` 组件：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/10.portfolio/.notes/10.4-Portfolio.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/10.portfolio/.notes/10.4-Portfolio.vue)。
- en: '`Portfolio.vue /` is a pretty straightforward component. Because we’ve pre-defined
    the fields that are part of the `./pages/[…slug.vue]` component, or more specifically,
    the `useAsyncStoryblok` composable, which feeds `<``StoryblokComponent />`.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Portfolio.vue /` 是一个相当简单的组件。因为我们已经预定义了 `./pages/[…slug.vue]` 组件或更具体地说，是 `useAsyncStoryblok`
    可组合函数中的一部分字段，它为 `<StoryblokComponent />` 提供数据。'
- en: 'For a more visual representation, the following model helps explain how the
    components are rendered:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更直观地展示，以下模型有助于解释组件是如何渲染的：
- en: '![Figure 10.12 – From data in Storyblok to a component in the browser](img/B19563_10_12.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.12 – 从 Storyblok 中的数据到浏览器中的组件](img/B19563_10_12.jpg)'
- en: Figure 10.12 – From data in Storyblok to a component in the browser
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – 从 Storyblok 中的数据到浏览器中的组件
- en: When the data is coming from Storyblok, it bears a description of the component
    type. Using the slug page, we always land on a Storyblok component, which then
    attempts to match the type to the corresponding Vue component in the `./storyblok`
    folder. That component, in turn, could be a nested type, which means it contains
    another instance of the Storyblok component, and so on. Once you get the hang
    of this mental model, it’s pretty straightforward. The amount of automation and
    assumption that Nuxt and the Storyblok module take care of can obfuscate the mechanics
    a bit.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据来自 Storyblok 时，它带有组件类型的描述。使用 slug 页面，我们总是到达一个 Storyblok 组件，然后尝试将类型匹配到 `./storyblok`
    文件夹中相应的 Vue 组件。该组件反过来可能是一个嵌套类型，这意味着它包含 Storyblok 组件的另一个实例，依此类推。一旦你掌握了这种思维模型，它就相当直接。Nuxt
    和 Storyblok 模块处理的自动化程度和假设可能会使机制变得有些模糊。
- en: With our portfolio in place, let’s have a closer look at the content model and
    how we can better tune it to our needs.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的产品组合就绪后，让我们更仔细地看看内容模型以及我们如何更好地调整它以满足我们的需求。
- en: Modifying the content model
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改内容模型
- en: Our headless CMS is now able to present basic layouts and contents to our portfolio.
    It’s still very limited this way, so let’s find out how we can work with the content
    model so that it supports new features.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的无头CMS现在能够向我们的产品组合展示基本的布局和内容。这种方式仍然非常有限，所以让我们找出如何与内容模型合作，以便它支持新功能。
- en: Updating existing types
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新现有类型
- en: 'Let’s assume that our **Teaser** block is a **Heading** block. I would recommend
    trying to keep blocks as static as possible, but let’s see what we need to do
    to change a name. If we navigate to the **Block library** in CMS and hover over
    the **Teaser** block, we can enter edit mode with the context menu. In the **Config**
    tab, we have the option to update the name:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的**预告**区块是一个**标题**区块。我建议尽可能保持区块的静态性，但让我们看看我们需要做什么来更改名称。如果我们导航到CMS中的**区块库**并悬停在**预告**区块上，我们可以通过上下文菜单进入编辑模式。在**配置**选项卡中，我们有更新名称的选项：
- en: '![Figure 10.13 – Updating an existing block’s name](img/B19563_10_13.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图10.13 – 更新现有区块的名称](img/B19563_10_13.jpg)'
- en: Figure 10.13 – Updating an existing block’s name
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13 – 更新现有区块的名称
- en: The next step is simply renaming the `Teaser.vue` component to `Heading.vue`
    in the `./storyblok` folder. To keep stability in mind, I would strongly recommend
    planning ahead with content modeling instead of relying on rewrites of existing
    content types.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步仅仅是将`./storyblok`文件夹中的`Teaser.vue`组件重命名为`Heading.vue`。为了保持稳定性，我强烈建议在内容建模方面提前规划，而不是依赖于现有内容类型的重写。
- en: A rule of thumb
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经验法则
- en: With a growing application, it becomes increasingly risky to introduce model
    updates that require existing components to be renamed or deleted. These are considered
    breaking changes and can cause your application to (momentarily) break. Storyblok
    will warn you that changes can take time to propagate throughout the content and
    that this can affect or prevent the app from generating all the pages. These sorts
    of warnings or errors should be treated with some caution.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用的不断增长，引入需要现有组件重命名或删除的模型更新变得越来越有风险。这些被认为是破坏性变更，可能会暂时导致您的应用程序中断。Storyblok会警告您，更改可能需要时间才能在整个内容中传播，这可能会影响或阻止应用程序生成所有页面。这类警告或错误应谨慎处理。
- en: Changing or removing functionalities always introduces some risks in code. It’s
    much safer to add new features, as we will see next.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 改变或删除功能总会在代码中引入一些风险。添加新功能要安全得多，正如我们接下来将要看到的。
- en: Expanding the block properties
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展区块属性
- en: 'Changes that add functionality are easier to implement, so let’s see how we
    can expand the **Feature** block. Again, we’ll open the edit view. We’re going
    to add a couple of fields:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 添加功能的更改更容易实现，让我们看看我们如何扩展**功能**区块。同样，我们将打开编辑视图。我们将添加几个字段：
- en: 'Add an `image` field name of the **Asset** type:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**资产**类型的`image`字段名称：
- en: After creation, configure the field to only allow **Images**.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建后，配置该字段仅允许**图片**。
- en: Add a `link` field name of the **Link** type.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**链接**类型的`link`字段名称。
- en: 'Once we save these changes, we’ll update the component so that we can experience
    the changes in the preview editor. Let’s open the `./storyblok/Feature.vue` file
    and replace its contents:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 保存这些更改后，我们将更新组件，以便在预览编辑器中体验这些更改。让我们打开`./storyblok/Feature.vue`文件并替换其内容：
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can update the default feature block on the home page of the website to,
    for instance, link to some portfolio items. You can also remove existing features
    if you don’t want to use them. Having updated the component, Storyblok gives you
    a good visualization of what the result will look like.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将网站主页上的默认功能区块更新为，例如，链接到一些产品组合项。如果您不想使用它们，也可以删除现有的功能。更新组件后，Storyblok会为您提供良好的可视化，展示结果将如何呈现。
- en: 'The pages are still a bit empty now, and that’s because we have no means of
    adding text. Let’s create the component first this time, and then implement it
    in the CMS. We’ll create a `RichText.vue` component in the `./storyblok` folder
    with the following contents:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 页面现在仍然有点空，这是因为我们没有添加文本的手段。让我们这次先创建组件，然后再在CMS中实现它。我们将在`./storyblok`文件夹中创建一个`RichText.vue`组件，其内容如下：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Then, in Storyblok, we’ll add a new block called `rich-text` as a nestable block.
    As part of the fields, we’ll only add a single field called `body` of the **Richtext**
    type. Now, you can immediately add the content block and start adding additional
    content to the website!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在Storyblok中，我们将添加一个名为`rich-text`的新块，作为一个可嵌套的块。作为字段的一部分，我们只添加一个名为`body`的**富文本**类型的字段。现在，你可以立即添加内容块并开始向网站添加更多内容！
- en: 'We’ll do a bit of refactoring with our blocks because the individual elements
    don’t allow us to create a good-looking visual representation, especially when
    dealing with text pages. First, we’ll create a Vue component in the `./storyblok`
    folder called `Article.vue`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对我们的块进行一些重构，因为单个元素不允许我们创建一个看起来好的视觉表示，尤其是在处理文本页面时。首先，我们将在`./storyblok`文件夹中创建一个名为`Article.vue`的Vue组件：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we’ll flip over to the CMS to create a new block called `article` as
    a nestable block with the following fields:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将转到CMS创建一个名为`article`的新块，作为一个具有以下字段的嵌套块：
- en: Add a `title` field name of the **Text** type.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**文本**类型的`title`字段名。
- en: Add a `content` field name of the **Block** type.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**块**类型的`content`字段名。
- en: The second field allows us to compose the article type with many different blocks
    that are available. It would be good practice to try and set up something such
    as a contact card block for yourself, for instance!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个字段允许我们使用许多不同的可用块来组合文章类型。尝试为自己设置一个像联系卡块这样的东西将是一个好的实践！
- en: Taking a hint from the layout we’ve set up, we’re still missing a page. With
    Storyblok, you should be able to create a **Me** story at the root of the project.
    You can use this space to introduce yourself and share your journey.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们设置的布局中汲取灵感，我们仍然缺少一个页面。使用Storyblok，你应该能够在项目的根目录下创建一个**Me**故事。你可以使用这个空间来介绍自己并分享你的旅程。
- en: Mapping meta fields
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射元字段
- en: Do you remember the **Description** fields we added to the **Portfolio All**
    and **Portfolio** blocks in the *Presenting the portfolio* section? We haven’t
    mapped those! These fields are meant to provide some metadata to the page for
    **Search Engine Optimisation** (**SEO**) purposes. Using semantic HTML tags, we
    can describe the page contents specifically for indexing by search engines. Nuxt
    offers an out-of-the-box solution for controlling these tags and provides a composable
    ([https://nuxt.com/docs/getting-started/seo-meta#usehead](https://nuxt.com/docs/getting-started/seo-meta#usehead))
    for this.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们在*展示投资组合*部分添加到**投资组合所有**和**投资组合**块的**描述**字段吗？我们还没有映射这些字段！这些字段旨在为页面提供一些用于**搜索引擎优化**（**SEO**）的元数据。使用语义HTML标签，我们可以专门描述页面内容以便搜索引擎索引。Nuxt提供了一个现成的解决方案来控制这些标签，并提供了一个可组合的([https://nuxt.com/docs/getting-started/seo-meta#usehead](https://nuxt.com/docs/getting-started/seo-meta#usehead))。
- en: 'In both cases, since the field name is the same, we can add the `meta` field
    by inserting the following code into the script tags:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，由于字段名相同，我们可以通过在脚本标签中插入以下代码来添加`meta`字段：
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, if you look at the source of the website, you will see the tag and contents
    rendered:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你查看网站的源代码，你会看到标签和内容被渲染：
- en: '![Figure 10.14 – The meta field has been rendered in the source code of the
    HTML](img/B19563_10_14.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图10.14 – 元字段已在HTML源代码中渲染](img/B19563_10_14.jpg)'
- en: Figure 10.14 – The meta field has been rendered in the source code of the HTML
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14 – 元字段已在HTML源代码中渲染
- en: It’s good to remember that we can use the content from the CMS not just for
    the visible parts of the website – we can process any content as a variable in
    our application. We could provide toggles or themes – anything really – where
    we can change the website without deploying new code. That’s what makes a headless
    CMS a powerful tool when developing applications.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这一点是很好的，我们可以使用CMS中的内容不仅限于网站的可见部分 – 我们可以将任何内容作为我们应用程序中的变量进行处理。我们可以提供开关或主题 –
    真的什么都可以 – 这样我们就可以在不部署新代码的情况下更改网站。这就是无头CMS在开发应用程序时成为一个强大工具的原因。
- en: Adding new features
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加新功能
- en: With these steps completed, you could try to add some more features to your
    portfolio. How about a nicely formatted contact sheet? Or a manageable resume
    section? With what we’ve built, you should be able to figure this out by yourself!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，你可以尝试向你的投资组合添加更多功能。比如一个格式良好的联系表？或者一个可管理的简历部分？凭借我们所构建的，你应该能够自己解决这个问题！
- en: Generating a standalone website
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成一个独立的网站
- en: 'We now have a functional portfolio. This type of website has very static content:
    it doesn’t change depending on the visitor and will probably not receive daily
    updates in terms of code! This means that we can optimize the output of what we
    will deploy to the public.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个功能齐全的资料库。这种类型的网站内容非常静态：它不会根据访客而改变，而且代码方面可能不会每天更新！这意味着我们可以优化我们将部署到公共领域的输出。
- en: The portfolio we’ve created is a perfect use case for static site generation.
    Normally, Nuxt would run as an active process on a server, where it can respond
    directly to requests and fetch data in real time. A good example is the *Quiz
    server* we built in [*Chapter 8*](B19563_08.xhtml#_idTextAnchor233). But since
    we don’t need real-time data when publishing, we can leverage another capability
    of Nuxt. When generating a static site, Nuxt runs as an application initially
    and indexes all of the internal links. For every internal link, it will retrieve
    the data from the server once and then write the output to a static collection
    of files.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的资料库是静态网站生成的完美用例。通常，Nuxt会在服务器上作为一个活跃的进程运行，它可以直接响应请求并实时获取数据。一个很好的例子是我们[*第8章*](B19563_08.xhtml#_idTextAnchor233)中构建的*问答服务器*。但由于发布时我们不需要实时数据，我们可以利用Nuxt的另一个功能。在生成静态网站时，Nuxt最初作为一个应用程序运行，并索引所有内部链接。对于每个内部链接，它将从服务器获取一次数据，然后将输出写入静态文件集合。
- en: 'Let’s see this in action! The command is already part of our `package.json`
    scripts, but we need to slightly modify it so that we can pass the API key we
    need to access the data:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个动作！该命令已经是我们`package.json`脚本的一部分，但我们需要稍作修改，以便我们可以传递访问数据的API密钥：
- en: '[PRE21]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can just run the following command in the terminal:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在终端中运行以下命令：
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You will see that the required files for a static site are being generated.
    On completion, the *Nuxt* generation process will return a command you can use
    to test the website as a static site:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到正在生成静态网站所需的文件。完成后，*Nuxt*生成过程将返回一个你可以用来测试网站作为静态网站的命令：
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Running this command will start a simple HTTP web server. There is no Nuxt process
    running! This is just the browser running HTML, CSS, and JavaScript files. All
    of the contents from the CMS are now bundled as part of the website. Well, except
    for the images – they are served from the Storyblok CDN, which is optimized for
    doing just that.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令将启动一个简单的HTTP网络服务器。没有Nuxt进程在运行！这仅仅是浏览器在运行HTML、CSS和JavaScript文件。所有来自CMS的内容现在都作为网站的一部分捆绑在一起。好吧，除了图片——它们由Storyblok
    CDN提供，该CDN专门为此类操作进行了优化。
- en: We’ll see how we can make our static site public in the next section!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中看到如何使我们的静态网站公开。
- en: Publishing the static site
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布静态网站
- en: 'Any web host would be capable of serving these static files now. That’s one
    of the benefits of a static-generated website: the amount of freedom when it comes
    to hosting them. We do have some requirements down the line, however, so we’re
    choosing Netlify ([https://app.netlify.com/](https://app.netlify.com/)) for our
    use case. If you register, you should be able to enter the free tier without any
    cost. While signing up, pick the categories that suit you best and pick a name
    for your team.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 任何网络托管商现在都能提供这些静态文件。这就是静态生成网站的一个好处：在托管它们时拥有很大的自由度。然而，我们还有一些后续要求，因此我们选择了Netlify
    ([https://app.netlify.com/](https://app.netlify.com/))来满足我们的使用案例。如果你注册，你应该能够免费进入免费层。在注册时，选择最适合你的类别，并为你的团队选择一个名称。
- en: 'On the next screen, we’ll go with the Netlify Drop way of deploying:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一屏，我们将采用Netlify Drop的方式进行部署：
- en: '![Figure 10.15 – Choosing your first method of deployment](img/B19563_10_15.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图10.15 – 选择你的第一个部署方法](img/B19563_10_15.jpg)'
- en: Figure 10.15 – Choosing your first method of deployment
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15 – 选择你的第一个部署方法
- en: Choosing `./output/public` folder. Make sure you drop the `public` folder and
    not the separate contents!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`./output/public`文件夹。确保你放下`public`文件夹，而不是单独的内容！
- en: 'Once you’ve finished uploading everything, you will enter the dashboard for
    the first time. Clicking the **Open production deploy** button will send you to
    your published portfolio! The subdomain is generated by Netlify and contains random
    wording. You can opt to change it via the **Domain** **management** section:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成上传，你将第一次进入仪表板。点击**打开生产部署**按钮将带你到你的已发布资料库！子域名由Netlify生成，包含随机词汇。你可以选择通过**域名****管理**部分来更改它：
- en: '![Figure 10.16 – The Netlify dashboard after the first deployment](img/B19563_10_16.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图10.16 – 首次部署后的Netlify仪表板](img/B19563_10_16.jpg)'
- en: Figure 10.16 – The Netlify dashboard after the first deployment
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The free tier of Netlify offers capabilities for processing domain names, pointing
    your own domain to this space.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The drawback of a statically generated site is that the website we deployed
    is completely detached from the content and our Nuxt server. This means that if
    we update the content or change a feature in the code, we need to regenerate the
    website and manually upload the output to Netlify. This works but is not ideal!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, with some extra effort and configuration, we can automate deployments
    when either the content changes or the code changes!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Automating the build and deployment on code change
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our Netlify environment does not know about our application. Netlify is a tool
    for deploying web apps. We can’t connect Netlify to our local development environment.
    We need to host the source online as well.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: GitHub ([https://github.com/](https://github.com/)) has excellent integrations
    with Netlify and is very suitable for hosting and versioning code. Without diving
    into the details, GitHub can detect when code has been updated on the repository
    and can trigger certain actions when that happens.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll set up a repository where we can publish the code. Let’s create
    a new empty repository:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17 – Creating a new repository in GitHub](img/B19563_10_17.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: Figure 10.17 – Creating a new repository in GitHub
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the repository has been created, you can follow the next steps to attach
    our code to the repository using the terminal:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This pushes our code to GitHub, which means we can connect it to Netlify! On
    the dashboard, navigate to **Site Configuration** | **Build & Deploy** and click
    the **Link repository** button. Then, you need to authorize Netlify on your GitHub
    account. Once you’ve done this, you’ll see an overview of your repositories. Select
    the portfolio repository you just created to continue.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'It might automatically detect that it’s a Nuxt repository and Netlify will
    try and make some suggestions. We need to change three settings:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Change `npm` `run generate`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change `./output/public`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to add environment variables to add the contents of our `.env` file,
    with `NUXT_STORYBLOK_ACCESS_TOKEN` and **Value** being what matches your access
    token. Make sure that it’s saved!
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The changes you’ve made should match these settings:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.18 – Our new Netlify deployment settings](img/B19563_10_18.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: Figure 10.18 – Our new Netlify deployment settings
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Deploying this will allow Netlify to read from the repository and pull in the
    latest version on a change. It will do this automatically. Then, it will run the
    `npm run generate` script to do the static site rendering on a virtual environment.
    The final step will be to deploy the contents of the output folder to the web
    domain.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: It’s that easy! If you work on your local code and commit and push the code
    to the repository, the change will automatically be deployed! It is good to note
    that we are not verifying whether our code is functional since we have no tests
    running on our application. It would be best practice to make sure that critical
    features of your code work.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单！如果您在本地代码上工作并提交代码到仓库，更改将自动部署！值得注意的是，我们没有验证我们的代码是否功能正常，因为我们没有在我们的应用程序上运行测试。确保您的代码的关键功能正常工作是一个最佳实践。
- en: Automating the build on content change
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化内容变更时的构建
- en: 'It would be perfect if we could do something similar on a content change rather
    than a code change, right? Luckily, there’s a very convenient way of doing this:
    we can use webhooks to trigger actions. Storyblok will keep track of when content
    is ready to be published and it can trigger an action on the Netlify platform
    that executes a build just like with a code change. This time, however, Nuxt will
    fetch the latest version of the content during the generation process.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能在内容变更而不是代码变更时做类似的事情，那就太完美了，对吧？幸运的是，有一个非常方便的方法来做这件事：我们可以使用 webhook 来触发操作。Storyblok
    会跟踪内容何时准备好发布，并且可以在 Netlify 平台上触发一个操作，执行构建，就像代码变更一样。然而，这次，Nuxt 将在生成过程中获取内容的最新版本。
- en: Let’s see how we can set this up. First, we need to create a webhook in Netlify.
    This webhook is nothing more than a unique URL that triggers an internal action
    when it’s being called.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何设置它。首先，我们需要在 Netlify 中创建一个 webhook。这个 webhook 仅仅是一个在调用时触发内部操作的唯一 URL。
- en: Navigate to `Deploy on Content Change`. The settings default to building the
    *main* branch, which is perfect. After a moment of saving, you will receive a
    unique URL with a pattern such as [https://api.netlify.com/build_hooks/UNIQUE_IDENTIFIER](https://api.netlify.com/build_hooks/UNIQUE_IDENTIFIER).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到 **内容变更时部署**。设置默认为构建 **main** 分支，这是完美的。保存片刻后，您将收到一个具有类似 [https://api.netlify.com/build_hooks/UNIQUE_IDENTIFIER](https://api.netlify.com/build_hooks/UNIQUE_IDENTIFIER)
    模式的唯一 URL。
- en: Now, we can move to Storyblok to configure calling this webhook. If we navigate
    to the **Settings** and **Webhook** sections, we can manage webhooks! We’ll create
    a new one, again with a meaningful name. In the **Endpoint URL** area, we can
    paste the endpoint from Netlify.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以转到 Storyblok 来配置调用此 webhook。如果我们导航到 **设置** 和 **Webhook** 部分，我们可以管理 webhook！我们将创建一个新的，再次使用一个有意义的名称。在
    **端点 URL** 区域，我们可以粘贴 Netlify 的端点。
- en: 'The *triggers* determine which events we want to call the webhook on. You can
    experiment a bit with the settings, but I recommend starting with this set:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**触发器** 决定了我们希望在哪些事件上调用 webhook。您可以尝试调整一下设置，但我建议从以下这个集合开始：'
- en: '![Figure 10.19 – Selecting event triggers to call the webhook](img/B19563_10_19.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.19 – 选择事件触发器以调用 webhook](img/B19563_10_19.jpg)'
- en: Figure 10.19 – Selecting event triggers to call the webhook
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.19 – 选择事件触发器以调用 webhook
- en: Ideally, you want to select as few triggers as possible, simply because every
    build process takes time. Calling the webhook consecutive times just puts requests
    in a queue, which can lead to longer waiting times for your change to be visible.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，您希望选择尽可能少的触发器，因为每次构建过程都需要时间。连续调用 webhook 只是将请求放入队列，这可能导致您的更改可见的等待时间更长。
- en: Let’s save these settings and change some content in our portfolio.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们保存这些设置并更改我们作品集中的某些内容。
- en: Tip
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you’re not running the Nuxt development server, you can still edit the content
    using the panel on the right-hand side. You can even expand it to fill the screen
    using the **Show form** **view** button:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有运行 Nuxt 开发服务器，您仍然可以使用右侧的面板编辑内容。您甚至可以使用 **显示表单视图** 按钮将其扩展以填充屏幕：
- en: '![Figure 10.20 – Expanding the editing capabilities using the form view](img/B19563_10_20.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.20 – 使用表单视图扩展编辑功能](img/B19563_10_20.jpg)'
- en: Figure 10.20 – Expanding the editing capabilities using the form view
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.20 – 使用表单视图扩展编辑功能
- en: Not having the development server just means that you don’t have a live preview.
    It’s not mandatory to access the content.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 没有开发服务器仅仅意味着您没有实时预览。访问内容不是强制性的。
- en: After saving, you can go over to the **Deploys** section on the Netlify dashboard
    to see that it triggered a new build.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 保存后，您可以转到 Netlify 控制面板上的 **部署** 部分，查看它触发了新的构建。
- en: You made it!
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您做到了！
- en: In this chapter, we’ve been working with different platforms and systems to
    connect them into a single application that renders a static website. One of the
    key takeaways is that we can combine the strengths of many specialized solutions
    to build a robust product we can deploy. I highly recommend checking out more
    resources on both Storyblok and Netlify since they work well with this type of
    web stack.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们一直在使用不同的平台和系统，将它们连接成一个可以渲染静态网站的单个应用程序。一个关键收获是我们可以将许多专业解决方案的优势结合起来，构建一个我们可以部署的稳健产品。我强烈推荐您查看更多关于Storyblok和Netlify的资源，因为它们与这种类型的Web堆栈配合得很好。
- en: The combination of the live preview of Storyblok and the developer experience
    of using Nuxt as a framework makes these sorts of projects very easy to get started
    with and build something we can use! We’ve seen that Nuxt doesn’t always have
    to run as a server – it can be used to generate the data from the server once
    and store the output. This approach is more sustainable and offers better performance
    than real-time data fetching.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Storyblok的实时预览功能与使用Nuxt作为框架的开发体验相结合，使得这类项目非常容易上手并构建出我们可以使用的成果！我们注意到，Nuxt不一定要作为服务器运行——它可以用来自动从服务器生成数据并存储输出。这种方法比实时数据获取更可持续，并且性能更优。
- en: With the way we’ve set up Storyblok and integrated it with Nuxt, it’s a very
    accessible way for anybody to build a website. We’ve built a relatively simple
    example, but with an increasing number of blocks, the possibilities you can create
    scale up massively while still being very easy to understand for non-technical
    users.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们设置的Storyblok与Nuxt的集成方式，任何人都可以非常容易地构建一个网站。我们构建了一个相对简单的示例，但随着块的增加，您可以创建的可能性会大幅增加，同时对于非技术用户来说仍然非常易于理解。
- en: Every configuration we’ve set up in this chapter was aimed at managing the website
    as easily as possible. Even the publication mechanisms add to that goal by both
    automating code deployments as well as automatically generating a new version
    when content is changed.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们设定的每一个配置都是为了尽可能容易地管理网站。甚至发布机制也通过自动化代码部署以及在内容更改时自动生成新版本来助力这一目标。
- en: On top of all of this, we’ve created a platform where you can log your journey
    while working through the chapters of this book. I recommend completing the portfolio
    with projects or achievements you’re proud of.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些之上，我们还创建了一个平台，您可以在阅读本书章节的过程中记录您的学习历程。我建议您用您自豪的项目或成就来完善您的作品集。
- en: One of the goals of this book was to present real-world code. Real-world code
    is often pragmatic and may not always be optimized to perfection. Similarly, the
    examples in this book are not flawless. However, they effectively achieve the
    intended goals. Embracing pragmatism enables you to validate features with users
    and shorten feedback loops, which is a very valuable aspect. I’ve illustrated
    that refactoring and optimization are integral parts of a continuous process.
    I want to stress that, as you gain deeper insights into projects, you’ll naturally
    prioritize which aspects require optimization.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的一个目标就是展示现实世界的代码。现实世界的代码通常是实用的，可能并不总是优化到完美。同样，本书中的示例也不是完美的。然而，它们有效地实现了预期的目标。拥抱实用主义使您能够与用户验证功能，并缩短反馈循环，这是一个非常有价值的方面。我说明了重构和优化是持续过程中的重要部分。我想强调，随着您对项目的深入了解，您自然会优先考虑哪些方面需要优化。
- en: Looking back, I hope you are proud of the work you’ve put in with all the different
    types of topics, technologies, and apps we’ve built throughout this book. I have
    tried to paint a broad picture of possible real-world scenarios while continuously
    increasing your level of Vue.js knowledge and experience. I would like to thank
    you for your interest in these topics and for following along during our journey.
    The investigating, building, and documenting process has also been very valuable
    for me, and I am grateful for the opportunity I’ve had to teach and share my knowledge
    and approach when writing code.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾过去，我希望您为在这本书中涉及的不同主题、技术和应用程序所付出的努力感到自豪。我试图描绘出可能的现实世界场景，同时不断增进您的Vue.js知识和经验。我想感谢您对这些主题的兴趣，以及在我们旅程中的陪伴。调查、构建和记录的过程对我来说也非常宝贵，我感激有机会在编写代码时教授和分享我的知识和方法。
