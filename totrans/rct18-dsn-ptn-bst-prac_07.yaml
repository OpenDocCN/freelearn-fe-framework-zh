- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Anti-Patterns to Be Avoided
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要避免的反模式
- en: In this book, you’ve learned how to apply best practices when writing a React
    application. In the first few chapters, we revisited the basic concepts to build
    a solid understanding, and then we took a leap into more advanced techniques in
    the following chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你已经学会了如何在编写React应用程序时应用最佳实践。在前几章中，我们回顾了基本概念以建立坚实的基础，然后在接下来的章节中，我们深入探讨了更高级的技术。
- en: You should now be able to build reusable components, make components communicate
    with each other, and optimize an application tree to get the best performance.
    However, developers make mistakes, and this chapter is all about the common anti-patterns
    we should avoid when using React.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够构建可重用的组件，使组件之间相互通信，并优化应用程序树以获得最佳性能。然而，开发者会犯错误，本章全部关于我们在使用React时应避免的常见反模式。
- en: Looking at common errors will help you to avoid them and will aid your understanding
    of how React works and how to build applications in the React way. For each problem,
    we will see an example that shows how to reproduce and solve it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看常见错误，可以帮助你避免它们，并有助于你理解React的工作原理以及如何以React的方式构建应用程序。对于每个问题，我们将看到一个示例，展示如何重现和解决它。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Initializing the state using properties
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性初始化状态
- en: Using indexes as a key
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用索引作为键
- en: Spreading properties on DOM elements
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在DOM元素上展开属性
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you will need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，你需要以下内容：
- en: Node.js 19+
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 19+
- en: Visual Studio Code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: 'You can find the code for this chapter in the book’s GitHub repository: [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter07).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的GitHub仓库中找到本章的代码：[https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter07)。
- en: Initializing the state using properties
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用属性初始化状态
- en: In this section, we will see how initializing the state using properties received
    from the parent is usually an anti-pattern. I have used the word *usually* because,
    as we will see, once we have it clear in our mind what the problems with this
    approach are, we might still decide to use it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到使用从父组件接收的属性初始化状态通常是一个反模式。我使用“通常”这个词，因为我们将会看到，一旦我们清楚这种方法的弊端，我们仍然可能决定使用它。
- en: One of the best ways to learn something is by looking at the code, so we will
    start by creating a simple component with a + button to increment a counter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 学习某样东西的最好方法之一是查看代码，所以我们将从一个带有+按钮的简单组件开始，用于增加计数器。
- en: 'Let’s create a functional component named `Counter`, as shown in the following
    code snippet:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`Counter`的函数组件，如下代码片段所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let’s set our `count` state:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置我们的`count`状态：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The implementation of the click handler is straightforward – we just add `1`
    to the current `count` value and store the resulting value back in the state:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 点击处理器的实现很简单 - 我们只是将`1`添加到当前的`count`值，并将结果值存储回状态：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we render and describe the output, which is composed of the current
    value of the `count` state and the button to increment it:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们渲染并描述输出，它由`count`状态的当前值和增加它的按钮组成：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let’s render this component, passing `1` as the `count` property:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们渲染这个组件，将`1`作为`count`属性传递：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It works as expected – each click on the `+` button increments the current value.
    So, what’s the problem?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 它按预期工作 - 每次点击`+`按钮都会增加当前值。那么问题是什么？
- en: 'There are two main errors, which are outlined as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 主要有两个错误，如下所述：
- en: We have a duplicated source of truth.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个重复的真实来源。
- en: If the `count` property passed to the component changes, the state does not
    get updated.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果传递给组件的`count`属性发生变化，状态不会更新。
- en: 'If we inspect the `Counter` element using the React DevTools, we notice that
    `Props` and `State` hold a similar value:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用React DevTools检查`Counter`元素，我们会注意到`Props`和`State`持有相似的价值：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This makes it unclear which is the current and trustworthy value to use inside
    the component and to display to the user.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得在组件内部和向用户显示时，不清楚哪个是当前和可信的值。
- en: 'Even worse, clicking `+` once makes the values diverge. An example of this
    divergence is shown in the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，点击`+`一次就会使值发散。以下代码展示了这种发散的例子：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At this point, we can assume that the second value represents the current count,
    but this is not explicit and can lead to unexpected behaviors or wrong values
    down in the tree.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以假设第二个值代表当前的计数，但这并不明确，可能会导致意外的行为或错误的值。
- en: The second problem centers on how the class is created and instantiated by React.
    The `useState` function of the component gets called only once when the component
    is created.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题集中在React如何创建和实例化类。组件的`useState`函数在组件创建时只被调用一次。
- en: In our `Counter` component, we read the value of the `count` property and we
    store it in the state. If the value of that property changes during the life cycle
    of the application (let’s say it becomes 10), the `Counter` component will never
    use the new value because it has already been initialized. This puts the component
    in an inconsistent state, which is not optimal and hard to debug.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Counter`组件中，我们读取`count`属性的值并将其存储在状态中。如果在应用程序的生命周期中该属性的值发生变化（比如说变成10），`Counter`组件将永远不会使用新的值，因为它已经被初始化。这使组件处于不一致的状态，这并不理想且难以调试。
- en: What if we really want to use the prop’s value to initialize the component,
    and we know for sure that the value does not change in the future?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们真的想使用属性的值来初始化组件，并且我们确信该值在将来不会改变呢？
- en: 'In that case, it’s best practice to make it explicit and give the property
    a name that makes your intentions clear, such as `initialCount`. For example,
    let’s say we change the prop declaration of the `Counter` component in the following
    way:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，最好是使其明确，并给属性一个表明你意图的名称，例如`initialCount`。例如，让我们假设我们以以下方式更改`Counter`组件的属性声明：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This usage makes it clear that the parent can only initialize the counter,
    and any subsequent values of the `initialCount` property will be disregarded:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用法清楚地表明，父组件只能初始化计数器，任何随后的`initialCount`属性的值都将被忽略：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the next section, we are going to delve into the concept of keys.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入探讨键的概念。
- en: Using indexes as a key
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用索引作为键
- en: In *Chapter 15*, *Improving the Performance of Your Applications*, which talks
    about performance and the reconciler, we saw how we can help React figure out
    the shortest path to update the DOM by using the `key` prop.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在第15章“提高应用程序的性能”中，我们讨论了性能和协调器，我们看到了如何通过使用`key`属性来帮助React找出更新DOM的最短路径。
- en: The `key` property uniquely identifies an element in the DOM and React uses
    it to check whether the element is new or whether it must be updated when the
    component properties or state change.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`key`属性唯一标识DOM中的元素，React使用它来检查元素是否是新元素，或者当组件属性或状态改变时是否必须更新。'
- en: Using keys is always a good idea and if you don’t do it, React gives a warning
    in the console (in development mode). However, it is not simply a matter of using
    a key; sometimes, the value that we decide to use as a key can make a difference.
    In fact, using the wrong key can give us unexpected behaviors in some instances.
    In this section, we will see one of those instances.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用键总是一个好主意，如果你不这样做，React会在控制台（在开发模式下）发出警告。然而，这不仅仅是使用键的问题；有时，我们决定用作键的值可能会产生影响。实际上，使用错误的键在某些情况下可能会给我们带来意外的行为。在本节中，我们将看到这些情况之一。
- en: 'Let’s again create a `List` component, as shown here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次创建一个`List`组件，如下所示：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then we define our state:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义我们的状态：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The implementation of the click handler is slightly different from the previous
    one because, in this case, we need to insert a new item at the top of the list:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 点击处理器的实现与之前略有不同，因为在这种情况下，我们需要在列表顶部插入一个新项目：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, in the render, we show the list and the `+` button to add the `baz`
    item at the top of the list:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在渲染中，我们显示列表和添加到列表顶部的`baz`项目的`+`按钮：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you run the component inside the browser, you will not see any problems;
    clicking the `+` button inserts a new item at the top of the list. But let’s do
    an experiment.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将组件运行在浏览器中，你将看不到任何问题；点击`+`按钮会在列表顶部插入一个新项目。但让我们做一个实验。
- en: 'Let’s change the render in the following way, adding an input field near each
    item. We then use an input field because we can edit its content, making it easier
    to figure out the problem:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以以下方式更改渲染，在每个项目旁边添加一个输入字段。我们之所以使用输入字段，是因为我们可以编辑其内容，这使得找出问题更容易：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we run this component again in the browser, copy the values of the items
    in the input fields, and then click *+*, we will get unexpected behavior.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中再次运行此组件，复制输入字段中项目的值，然后点击 *+*，我们将得到意外的行为。
- en: 'As shown in the following screenshot, the items shift down while the input
    elements remain in the same position in such a way that their value does not match
    the value of the items anymore:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，项目向下移动，而输入元素保持在相同的位置，这样它们的值就不再与项目的值匹配：
- en: '![Graphical user interface, application  Description automatically generated](img/B18414_07_01.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B18414_07_01.png)'
- en: 'Figure 7.1: Using indexes as a key'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：使用索引作为键
- en: Running the component, clicking **+**, and checking the console should give
    us all the answers we need.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 运行组件，点击 **+**，并检查控制台应该会给我们所有需要的答案。
- en: What we can see is that instead of inserting the new element at the top, React
    swaps the text of the two existing elements, and inserts the last item at the
    bottom as if it was new. The reason it does that is that we are using the index
    of the map function as the key.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，React 不是在顶部插入新元素，而是交换两个现有元素的文本，并将最后一个项目插入底部，仿佛它是新的。这样做的原因是我们正在使用 map
    函数的索引作为键。
- en: In fact, the index always starts from `0`, even if we push a new item to the
    top of the list, so React thinks that we changed the values of the existing two
    and added a new element at index `2`. The behavior is the same as it would have
    been without using the `key` property at all.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，索引始终从 `0` 开始，即使我们将新项目推到列表的顶部，React 也会认为我们更改了现有两个项目的值，并在索引 `2` 处添加了一个新元素。这种行为与完全不使用
    `key` 属性时的行为相同。
- en: This is a very common pattern because we may think that providing any key is
    always the best solution, but it is not like that at all. The key must be unique
    and stable, identifying one, and only one, item.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常常见的模式，因为我们可能会认为提供任何键总是最好的解决方案，但事实并非如此。键必须是唯一的和稳定的，以标识一个、且仅标识一个项目。
- en: 'To solve this problem, we can, for example, use the value of the item if we
    expect it not to be repeated within the list, or create a unique identifier, for
    example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，例如，如果我们预期列表中不会重复该项的值，我们可以使用该项的值，或者创建一个唯一的标识符，例如：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we have understood the importance of unique and stable keys in React
    and explored practical solutions to address this common issue, let’s shift our
    attention to another prevalent practice in React development. The upcoming section
    will focus on the spreading of properties on DOM elements, a technique that has
    recently been labeled as an anti-pattern by Dan Abramov.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了在 React 中唯一和稳定的键的重要性，并探讨了解决这个常见问题的实际解决方案，让我们将注意力转向 React 开发中的另一种普遍做法。接下来的部分将专注于在
    DOM 元素上分配属性，这是一种最近被 Dan Abramov 标记为反模式的技术。
- en: Spreading properties on DOM elements
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 DOM 元素上分配属性
- en: There is a common practice that has recently been described as an anti-pattern
    by Dan Abramov; it also triggers a warning in the console when you do it in your
    React application.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，Dan Abramov 将这种常见的做法描述为反模式；在您的 React 应用程序中执行此操作时，它也会在控制台中触发警告。
- en: 'It is a technique that is widely used in the community, and I have personally
    seen it multiple times in real-world projects. We usually spread the properties
    to the elements to avoid writing every single one manually, which is shown as
    follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种在社区中广泛使用的技巧，我亲自在多个实际项目中看到过。我们通常将属性分配给元素，以避免手动编写每一个，如下所示：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This works very well, and it gets transpiled into the following code by Babel:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这方法非常有效，并且通过 Babel 转译成以下代码：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: However, when we spread properties into a DOM element, we run the risk of adding
    unknown HTML attributes, which is bad practice.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们向 DOM 元素分配属性时，我们面临添加未知 HTML 属性的风险，这是不良实践。
- en: The problem is not related only to the `Spread` operator; passing non-standard
    properties one by one leads to the same issues and warnings. Since the `Spread`
    operator hides the single properties we are spreading, it is even harder to figure
    out what we are passing to the element.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 问题不仅与 `Spread` 操作符有关；逐个传递非标准属性也会导致相同的问题和警告。由于 `Spread` 操作符隐藏了我们正在分配的单个属性，因此更难弄清楚我们传递给元素的内容。
- en: 'To see the warning in the console, a basic operation we can do is render the
    following component:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要在控制台中看到警告，我们可以执行的基本操作是渲染以下组件：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The message we get looks like the following because the `foo` property is not
    valid for a `div` element:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到的消息看起来如下，因为`foo`属性对于`div`元素不是有效的：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this case, as we said, it is easy to figure out which attribute we are passing
    and remove it, but if we use the `Spread` operator, as in the following example,
    we cannot control which properties are passed from the parent:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，正如我们所说的，很容易找出我们传递了哪个属性并移除它，但如果我们使用`Spread`运算符，就像以下示例中那样，我们就无法控制从父组件传递哪些属性：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we use the component in the following way, there are no issues:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以以下方式使用组件，就没有问题：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This, however, is not the case if we do something such as the following. React
    complains because we are applying a non-standard attribute to the DOM element:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们做如下操作，情况就不同了。React会抱怨因为我们正在将非标准属性应用于DOM元素：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: One solution we can use to solve this problem is to create a property called
    `domProps` that we can spread safely to the component because we are explicitly
    saying that it contains valid DOM properties.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用创建一个名为`domProps`的属性来解决这个问题的解决方案，我们可以安全地将其传播到组件中，因为我们明确表示它包含有效的DOM属性。
- en: 'For example, we can change the `Spread` component in the following way:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以这样改变`Spread`组件：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can then use it as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以这样使用它：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As we have seen many times with React, it’s always good practice to be explicit.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们多次在React中看到的那样，明确总是好的实践。
- en: Summary
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Knowing all the best practices is always a good thing, but sometimes, being
    aware of anti-patterns helps us avoid taking the wrong path. Most importantly,
    learning the reasons why some techniques are considered bad practice helps us
    understand how React works, and how we can use it effectively.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 了解所有最佳实践总是好事，但有时，了解反模式可以帮助我们避免走错路。最重要的是，了解为什么某些技术被认为是坏习惯有助于我们理解React是如何工作的，以及我们如何有效地使用它。
- en: In this chapter, we covered four different ways of using components that can
    harm the performance and behavior of our web applications.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了四种可能损害我们Web应用程序性能和行为的使用组件的不同方式。
- en: For each one of those, we used an example to reproduce the problem and supplied
    the changes to apply in order to fix the issue.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一个，我们使用示例来重现问题，并提供了需要应用以修复问题的更改。
- en: We learned why using properties to initialize the state can result in inconsistencies
    between the state and the properties. We also saw how using the wrong `key` attribute
    can produce bad effects on the reconciliation algorithm. Finally, we learned why
    spreading non-standard properties to DOM elements is considered an anti-pattern.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了为什么使用属性初始化状态可能导致状态和属性之间不一致。我们还看到了使用错误的`key`属性如何对协调算法产生不良影响。最后，我们学习了为什么将非标准属性传播到DOM元素被认为是反模式。
- en: In the next chapter, we will look into the new React Hooks.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨新的React Hooks。
