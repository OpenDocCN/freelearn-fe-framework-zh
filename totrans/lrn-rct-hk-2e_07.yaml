- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Implementing React Contexts
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现React上下文
- en: In the previous chapters, we learned about the State Hook, the Reducer Hook,
    and the Effect Hook. We developed a small blog application using these Hooks.
    As we noticed during the development of our blog app, we had to pass down the
    `username` state from the `App` component to the `UserBar` component, and from
    the `UserBar` component to the `Login`, `Register`, and `Logout` components. To
    avoid having to pass down the state like this, we are now going to learn about
    React Context and Context Hooks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了State Hook、Reducer Hook和Effect Hook。我们使用这些Hooks开发了一个小型博客应用程序。正如我们在开发博客应用程序时注意到的那样，我们必须从`App`组件向下传递`username`状态到`UserBar`组件，然后从`UserBar`组件传递到`Login`、`Register`和`Logout`组件。为了避免必须以这种方式传递状态，我们现在将学习React
    Context和Context Hooks。
- en: We are going to begin by learning what React Context is, and what providers
    and consumers are, by implementing themes as an example for contexts. Then, we
    are going to use Hooks as a context consumer and discuss when contexts should
    be used. Finally, we are going to implement global state using contexts.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过实现主题作为上下文的示例来学习React上下文是什么，以及提供者和消费者是什么。然后，我们将使用Hooks作为上下文消费者，并讨论何时应该使用上下文。最后，我们将使用上下文实现全局状态。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing React Context
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍React上下文
- en: Implementing themes via context
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过上下文实现主题
- en: Alternatives to contexts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文的替代方案
- en: Using context for global state
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用上下文进行全局状态管理
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'A fairly recent version of Node.js should already be installed. The Node Package
    Manager (`npm`) also needs to be installed (it should come with Node.js). For
    more information on how to install Node.js, please check out the official website:
    [https://nodejs.org/](https://nodejs.org/).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 应该已经安装了相当新的Node.js版本。Node包管理器（`npm`）也需要安装（它应该与Node.js一起安装）。有关如何安装Node.js的更多信息，请访问官方网站：[https://nodejs.org/](https://nodejs.org/)。
- en: 'We are going to use **Visual Studio Code** (**VS Code**) for the guides in
    this book, but everything should work similarly in any other editor. For more
    information on how to install VS Code, please refer to the official website: [https://code.visualstudio.com](https://code.visualstudio.com).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的指南中使用**Visual Studio Code**（**VS Code**），但任何其他编辑器都应该以类似的方式工作。有关如何安装VS
    Code的更多信息，请参阅官方网站：[https://code.visualstudio.com](https://code.visualstudio.com)。
- en: 'In this book, we use the following versions:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用以下版本：
- en: Node.js v22.14.0
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js v22.14.0
- en: '`npm` v10.9.2'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm` v10.9.2'
- en: VS Code v1.97.2
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VS Code v1.97.2
- en: While installing a newer version should not be an issue, please note that certain
    steps might work differently on a newer version. If you are having an issue with
    the code and steps provided in this book, please try using the mentioned versions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然安装较新版本不应有问题，但请注意，某些步骤在较新版本上可能有所不同。如果您在本书提供的代码和步骤中遇到问题，请尝试使用提到的版本。
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter05).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码：[https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter05)。
- en: It is highly recommended that you write the code on your own. Do not simply
    run the code examples that are provided with the book. It is important to write
    the code yourself to be able to learn and understand it properly. However, if
    you run into any issues, you can always refer to the code example.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议您自己编写代码。不要简单地运行书中提供的代码示例。自己编写代码对于正确学习和理解代码非常重要。然而，如果您遇到任何问题，您始终可以参考代码示例。
- en: Introducing React Context
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍React上下文
- en: In the previous chapters, we passed down the `username` state and `setUsername`
    function from the `App` component to the `UserBar` component; and then from the
    `UserBar` component to the `Logout`, `Login`, and `Register` components. React
    Context provides a solution to this cumbersome way of passing down props over
    multiple levels of components, by allowing us to share values between components
    without having to explicitly pass them down via props. As we are going to see,
    contexts are perfect for sharing global state across the whole application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们将`username`状态和`setUsername`函数从`App`组件传递到`UserBar`组件；然后从`UserBar`组件传递到`Logout`、`Login`和`Register`组件。React
    Context提供了一种解决方案，通过允许我们在组件之间共享值，而无需通过props显式传递它们，从而解决了在多个组件层级之间传递props的繁琐方式。正如我们将要看到的，上下文非常适合在整个应用程序中共享全局状态。
- en: Passing down props
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递props
- en: 'Before learning about React Context in depth, let’s recap what we implemented
    in the earlier chapters to get a feeling for the problem that contexts solve.
    You do not need to edit any code at this point; these steps are just a recap of
    what we have already done. Just read along for the following steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解React Context之前，让我们回顾一下我们在前面的章节中实现的内容，以了解上下文解决的问题。在此阶段，你不需要编辑任何代码；这些步骤只是对我们已经完成的内容的回顾。只需阅读以下步骤：
- en: 'In `src/App.jsx`, we defined the `username` state and `setUsername` function
    using a State Hook:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/App.jsx`中，我们使用State Hook定义了`username`状态和`setUsername`函数：
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we passed the `username` state and `setUsername` function to the `UserBar`
    component:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将`username`状态和`setUsername`函数传递给`UserBar`组件：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `src/user/UserBar.jsx` file, we defined a `UserBar` component that takes
    the `username` state as a prop and then passes it down to the `Logout` component.
    We also passed down the `setUsername` function to the `Logout`, `Login`, and `Register`
    components:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/user/UserBar.jsx`文件中，我们定义了一个`UserBar`组件，它接受`username`状态作为prop，并将其传递给`Logout`组件。我们还向`Logout`、`Login`和`Register`组件传递了`setUsername`函数：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we used the `setUsername` function and the `username` state in the
    `Logout`, `Login`, and `Register` components:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在`Logout`、`Login`和`Register`组件中使用了`setUsername`函数和`username`状态：
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: React Context allows us to skip *steps 2* and *3* and jump straight from *step
    1* to *step 4*. As you can imagine, in larger apps, context becomes even more
    useful because we might have to pass down props over many levels.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: React Context允许我们跳过*步骤 2*和*步骤 3*，直接从*步骤 1*跳到*步骤 4*。正如你可以想象的那样，在更大的应用程序中，上下文变得更加有用，因为我们可能需要在多个层级传递props。
- en: In the next section, we are first going to learn how context works by implementing
    a theme system for our blog. Then, we will use React Context to deal with the
    `username` global state in our blog app.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们首先将通过为我们的博客实现主题系统来学习上下文的工作原理。然后，我们将使用React Context来处理我们的博客应用程序中的`username`全局状态。
- en: Implementing themes via context
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过上下文实现主题
- en: '**React Context** is used to share values across a tree of React components.
    Usually, we want to share global values, such as the `username` state, the theme
    of our app, or the chosen language (if the app supports multiple languages).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**React Context**用于在React组件树中共享值。通常，我们想要共享全局值，例如`username`状态、我们的应用程序的主题或选择的语言（如果应用程序支持多种语言）。'
- en: 'React Context consists of three parts:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: React Context由三个部分组成：
- en: The **context** itself, which defines a default value and allows us to provide
    and consume values
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文**本身，它定义了一个默认值，并允许我们提供和消费值'
- en: The **provider**, which provides (sets) the value
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供者**，它提供（设置）值'
- en: The **consumer**, which consumes (uses) the value
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消费者**，它消费（使用）值'
- en: Defining the context
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义上下文
- en: 'First, we have to define the context. The way this works has not changed since
    Hooks were introduced. We simply use the `createContext(defaultValue)` function
    from React to create a new context object. In this case, we will set the default
    value to `{ primaryColor: ''maroon'' }`, so our default primary color, when no
    provider is defined, will be maroon.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们必须定义上下文。自从引入Hooks以来，这种方式没有改变。我们只需使用React中的`createContext(defaultValue)`函数来创建一个新的上下文对象。在这种情况下，我们将默认值设置为`{
    primaryColor: ''maroon'' }`，因此当没有提供者定义时，我们的默认主颜色将是栗色。'
- en: 'Now, let’s get started defining the context:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始定义上下文：
- en: 'Copy the `Chapter04_2` folder to a new `Chapter05_1` folder by executing the
    following command:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令将`Chapter04_2`文件夹复制到新的`Chapter05_1`文件夹：
- en: '[PRE4]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Open the new `Chapter05_1` folder in VS Code.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开新的`Chapter05_1`文件夹。
- en: To keep our project clean as it grows, we are now extending the folder structure
    by grouping by base primitives first, then grouping by features within that folder.
    Create a new `src/contexts/` folder now.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了保持我们的项目在增长过程中保持整洁，我们现在通过首先按基础原语分组，然后在那个文件夹内按功能分组来扩展文件夹结构。现在创建一个新的`src/contexts/`文件夹。
- en: Also, create a new `src/components/` folder.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，创建一个新的`src/components/`文件夹。
- en: Move the `src/post/` and `src/user/` folders into the `src/components/` folder.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`src/post/`和`src/user/`文件夹移动到`src/components/`文件夹中。
- en: 'Edit `src/App.jsx` and adjust the imports, as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/App.jsx`并调整导入，如下所示：
- en: '[PRE5]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a new `src/contexts/ThemeContext.js` file. Inside it, import the `createContext`
    function:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/contexts/ThemeContext.js`文件。在其内部，导入`createContext`函数：
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, define the context with the aforementioned default value:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用前面提到的默认值定义上下文：
- en: '[PRE7]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When the context is consumed but no provider is defined, then it will return
    this default value.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当上下文被消费但没有定义提供者时，它将返回此默认值。
- en: Note how we are exporting `ThemeContext` here because we are going to need to
    import it later to create the provider and consume it using a Context Hook.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在这里导出`ThemeContext`，因为我们稍后需要导入它来创建提供者，并使用Context Hook来消费它。
- en: That’s all we need to do to define a context with React.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们使用React定义上下文所需做的全部工作。
- en: Quick detour – absolute imports
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速转向——绝对导入
- en: If we were to import the context in a component now, we would have to import
    from `../../contexts/ThemeContext.js`. Besides the fact that it becomes hard to
    read when files are deeply nested, it can cause issues when organizing files into
    subfolders later. To avoid these problems, we can use **absolute imports**. Absolute
    imports allow us to import from the root of a project. They are implemented using
    **resolve aliases** in Vite. Basically, we can tell Vite to resolve a special
    character, such as an `@` symbol, to an absolute path to the `src` folder. This
    means that we can import the context from `@/contexts/ThemeContext.js` instead.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在在组件中导入上下文，我们将不得不从`../../contexts/ThemeContext.js`导入。除了当文件深度嵌套时难以阅读的事实外，它还可能在稍后组织文件到子文件夹时引起问题。为了避免这些问题，我们可以使用**绝对导入**。绝对导入允许我们从项目的根目录导入。它们是通过Vite中的**resolve别名**实现的。基本上，我们可以告诉Vite将一个特殊字符，例如`@`符号，解析到`src`文件夹的绝对路径。这意味着我们可以从`@/contexts/ThemeContext.js`导入上下文。
- en: 'Let’s get started configuring absolute imports now:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在开始配置绝对导入：
- en: 'Edit `vite.config.js` and import the `path` utils:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`vite.config.js`并导入`path`实用工具：
- en: '[PRE8]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the `config` object, add a `resolve` alias, as follows:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`config`对象中，添加一个`resolve`别名，如下所示：
- en: '[PRE9]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Additionally, we can improve autocompletion in our code editor or IDE by creating
    a `jsconfig.json` file. This file will tell the editor about our absolute import
    configuration and let us easily import files from it. Create a new `jsconfig.json`
    file now.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们可以通过创建一个`jsconfig.json`文件来改进代码编辑器或IDE中的自动完成。此文件将告诉编辑器有关我们的绝对导入配置，并使我们能够轻松地从它导入文件。现在创建一个新的`jsconfig.json`文件。
- en: 'Inside it, add the following config:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内部添加以下配置：
- en: '[PRE10]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that we can use absolute imports, let’s continue defining the consumer.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用绝对导入，让我们继续定义消费者。
- en: Defining the consumer
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义消费者
- en: 'To use a context, we need a consumer. Let’s first revisit the traditional way
    of defining a consumer before we get started using Hooks:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用上下文，我们需要一个消费者。在我们开始使用Hooks之前，让我们首先回顾一下定义消费者的传统方式：
- en: 'Edit `src/components/post/Post.jsx` and import `ThemeContext` there:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/components/post/Post.jsx`并在其中导入`ThemeContext`：
- en: '[PRE11]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Wrap the whole component with a `ThemeContext.Consumer` component and a **render
    function** as its `children` prop, to make use of the context value:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将整个组件包裹在一个`ThemeContext.Consumer`组件中，并将其`children`属性设置为**渲染函数**，以使用上下文值：
- en: '[PRE12]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The render function allows us to pass values down to the children of a component.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染函数允许我们将值传递给组件的子组件。
- en: 'Inside the render function, we can now make use of the context value to set
    the color of the title of a blog post, as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在渲染函数内部，我们现在可以利用上下文值来设置博客文章标题的颜色，如下所示：
- en: '[PRE13]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using contexts like this works, but as we have learned in the first chapter,
    using components with render functions in this way clutters the React tree and
    makes our app harder to debug and maintain.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上下文的方式是可行的，但正如我们在第一章中学到的，以这种方式使用具有渲染函数的组件会使得React树变得杂乱，并使得我们的应用更难调试和维护。
- en: Using Hooks to consume a context
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Hooks来消费上下文
- en: A better way to consume contexts is using a Context Hook! That way, we can use
    context values like any other value.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 消费上下文的一个更好的方法是使用Context Hook！这样，我们可以像使用其他任何值一样使用上下文值。
- en: 'Follow these steps to change the consumer to a Context Hook:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将消费者改为上下文钩子：
- en: 'Edit `src/components/post/Post.jsx` and add the following import:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/components/post/Post.jsx`并添加以下导入：
- en: '[PRE14]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, define a Context Hook, as follows:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个上下文钩子，如下所示：
- en: '[PRE15]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, *remove* the following highlighted parts of the code:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，*删除*以下突出显示的代码部分：
- en: '[PRE16]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, using a Context Hook allows us to directly consume the value
    from the context and simply render the post without needing a wrapper component.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用上下文钩子允许我们直接从上下文中消费值，并简单地渲染帖子，而无需使用包装组件。
- en: 'Start the blog app by executing the following command:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令启动博客应用：
- en: '[PRE17]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can see that the title of blog posts is now maroon colored:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，博客帖子的标题现在变成了朱红色：
- en: '![Figure 5.1 – Using a Context Hook to change the theme of our app](img/B31327_05_01.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 使用上下文钩子更改我们的应用主题](img/B31327_05_01.png)'
- en: Figure 5.1 – Using a Context Hook to change the theme of our app
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 使用上下文钩子更改我们的应用主题
- en: As we can see, the theme context successfully provides the color for the post
    title.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，主题上下文成功为帖子标题提供了颜色。
- en: Defining the provider
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义提供者
- en: 'Contexts use the default value that is passed to `createContext` when there
    is no provider defined. For example, let’s imagine our component uses `ThemeContext`
    and is rendered as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有定义提供者时，上下文使用传递给`createContext`的默认值。例如，让我们想象我们的组件使用`ThemeContext`并按以下方式渲染：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Then, `primaryColor` will be set to `maroon` (we defined this earlier). This
    can be used as a fallback, for example, when the component is not embedded in
    the app but instead embedded in an interactive style guide (such as Storybook).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`primaryColor`将被设置为`maroon`（我们之前定义了它）。这可以用作后备，例如，当组件不是嵌入到应用中，而是嵌入到一个交互式样式指南（如Storybook）中时。
- en: 'When there is a provider defined, they will use the value of the provider.
    Let’s render the component like this instead:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义了提供者时，它们将使用提供者的值。让我们这样渲染组件：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Then, `primaryColor` will be set to `black`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`primaryColor`将被设置为`black`。
- en: 'If there are multiple providers in the tree, the components will use the value
    from the closest parent provider. For example, let’s say we render components
    like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果树中有多个提供者，组件将使用最近父提供者的值。例如，假设我们这样渲染组件：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Then, `primaryColor` in the component will be set to `red`, as that is the provider
    closest to the component in the tree. However, `OtherComponent` in this example
    will still have `primaryColor` set to `black`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，组件中的`primaryColor`将被设置为`red`，因为那是树中离组件最近的提供者。然而，在这个例子中，`OtherComponent`的`primaryColor`仍然设置为`black`。
- en: As we can see, a context without a provider is just a static value; the provider
    (especially in combination with other Hooks, such as a State Hook for the value)
    is what allows us to dynamically change the value of a context.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，没有提供者的上下文只是一个静态值；提供者（特别是与其他钩子结合使用时，如用于值的State钩子）允许我们动态地改变上下文的值。
- en: 'Let’s define the provider now. Follow these steps to get started:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义提供者。按照以下步骤开始：
- en: 'Edit `src/App.jsx` and import `ThemeContext`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/App.jsx`并导入`ThemeContext`：
- en: '[PRE21]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, wrap the contents of the `App` component with the `ThemeContext.Provider`
    component, and provide a value:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将`App`组件的内容包裹在`ThemeContext.Provider`组件中，并提供一个值：
- en: '[PRE22]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As we can see, the post titles are now back to being rendered in black. If we
    want to change the value of our context, we can simply adjust the `value` prop
    that is passed to the `provider` component. We could also, for example, use a
    State Hook to dynamically change the value of a context. We will try this later
    when we use a context for the global state.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，帖子标题现在又回到了黑色。如果我们想改变上下文的值，我们可以简单地调整传递给`provider`组件的`value`属性。例如，我们也可以使用状态钩子来动态改变上下文的值。我们将在使用上下文进行全局状态时尝试这一点。
- en: If we do not pass a `value` prop to the provider, the default value of a context
    will *not* be used! If we define a provider without a `value` prop, then the value
    of the context will be `undefined`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不向提供者传递`value`属性，上下文的默认值将*不会*被使用！如果我们定义了一个没有`value`属性的提供者，那么上下文的值将是`undefined`。
- en: Now that we have defined a single provider for the context, let’s move on to
    defining multiple nested providers.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为上下文定义了一个单独的提供者，接下来让我们继续定义多个嵌套提供者。
- en: Nesting providers
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套提供者
- en: 'With React Context, it is also possible to define multiple providers for the
    same context. Using this technique, we can override the context value in certain
    parts of our app. For example, let’s say we want to implement a featured posts
    section for our blog app. Then, we could do the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React Context，我们也可以为同一个上下文定义多个提供者。使用这种技术，我们可以在我们应用的某些部分覆盖上下文值。例如，假设我们想在博客应用中实现一个特色帖子部分。然后，我们可以这样做：
- en: 'Edit `src/App.jsx` and define a new `featuredPosts` array:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/App.jsx`并定义一个新的`featuredPosts`数组：
- en: '[PRE23]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, inside the `App` component, render a new `PostList` component rendering
    the `featuredPosts` array, but wrap it inside another `ThemeContext.Provider`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`App`组件内部，渲染一个新的`PostList`组件，渲染`featuredPosts`数组，但将其包裹在另一个`ThemeContext.Provider`中：
- en: '[PRE24]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You will now see that the featured post has a different color from the other
    posts:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你会发现特色帖子与其他帖子颜色不同：
- en: '![Figure 5.2 – Implementing featured posts by overriding context values with
    nested providers](img/B31327_05_02.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – 通过覆盖嵌套提供者的上下文值来实现特色帖子](img/B31327_05_02.png)'
- en: Figure 5.2 – Implementing featured posts by overriding context values with nested
    providers
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 通过覆盖嵌套提供者的上下文值来实现特色帖子
- en: '**Example code**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例代码**'
- en: The example code for this section can be found in the `Chapter05/Chapter05_1`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的示例代码可以在`Chapter05/Chapter05_1`文件夹中找到。请检查文件夹内的`README.md`文件，以获取设置和运行示例的说明。
- en: Alternatives to contexts
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文替代方案
- en: We should be careful not to use React Context too often, as it makes reusing
    components more difficult. We should only use context when we need to access data
    in many components, which are at different nesting levels. Additionally, we need
    to make sure that we only use contexts for non-frequently changing data. Frequently
    changing values of contexts, especially contexts that are used high up in the
    component tree, may cause large parts of the component tree to re-render, resulting
    in performance problems. That is why, for frequently changing values, we should
    use a state management solution such as Jotai, Redux, or MobX instead. These state
    management solutions allow us to access small parts of the state in a fine-grained
    way and thus reduce the amount of re-renders. Good candidates for contexts are
    features such as theming and translation (i18n) systems.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该小心不要过度使用React Context，因为它会使组件的重用变得更加困难。我们只应该在需要访问不同嵌套级别的多个组件中的数据时使用context。此外，我们需要确保我们只使用上下文来处理非频繁变化的数据。上下文频繁变化的价值，尤其是那些在组件树中位置较高的上下文，可能会导致组件树的大部分重新渲染，从而引起性能问题。这就是为什么对于频繁变化的价值，我们应该使用像Jotai、Redux或MobX这样的状态管理解决方案。这些状态管理解决方案允许我们以细粒度的方式访问状态的小部分，从而减少重新渲染的数量。上下文的好候选包括主题和翻译（i18n）系统等特性。
- en: 'If we only want to avoid having to pass down props, in some cases, we can pass
    down the rendered component instead of the data. For example, let’s say we have
    a `Page` component that renders a `Header` component, which renders a `Profile`
    component, which then renders an `Avatar` component. We get a `headerSize` prop
    passed to the `Page` component, which we need in the `Header` component, but also
    in the `Avatar` component:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想避免传递props，在某些情况下，我们可以传递渲染的组件而不是数据。例如，假设我们有一个`Page`组件，它渲染一个`Header`组件，该组件又渲染一个`Profile`组件，然后该组件再渲染一个`Avatar`组件。我们向`Page`组件传递了一个`headerSize`
    prop，我们不仅需要在`Header`组件中，还需要在`Avatar`组件中使用它：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Instead of passing down props through multiple levels, we could do the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是通过多个层级传递props，我们可以这样做：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, only the `Page` component needs to know about the props, and there is no
    need to pass them down further in the tree. In this case, contexts are not necessary.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只有`Page`组件需要知道props，并且没有必要在树中进一步传递它们。在这种情况下，上下文是不必要的。
- en: Such a pattern is called **inversion of control**, and it can make your code
    much cleaner than passing down props or using a context. However, we should not
    always use this pattern either because it makes the higher-level component more
    complicated.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式被称为**控制反转**，它可以使得你的代码比传递props或使用context更简洁。然而，我们也不应该总是使用这种模式，因为它会使高级组件变得更加复杂。
- en: Now, let’s continue by learning about using context for global state.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续学习如何使用上下文进行全局状态管理。
- en: Using context for global state
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用上下文进行全局状态管理
- en: After learning how to use React Context to implement themes in our blog app,
    we are now going to use a context to avoid having to manually pass down the `username`
    and `setUsername` props. The user state is a global state, which means it is used
    across the whole app. It also does not change frequently. As such, it is a good
    candidate for using a context. Like we did before, we start by defining the context.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了如何在我们的博客应用中使用 React Context 来实现主题之后，我们现在将使用一个上下文来避免手动传递 `username` 和 `setUsername`
    属性。用户状态是一个全局状态，这意味着它在整个应用中都被使用。它也不经常改变。因此，它是一个使用上下文的良好候选者。就像我们之前做的那样，我们首先定义上下文。
- en: Defining the context
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义上下文
- en: 'To define the context, we need to use the `createContext` function again. In
    this case, we set the default value to an array with an empty string and a **no-op
    function** (a function that does nothing). Later, when defining the provider,
    we will provide this array by using the result from the State Hook. Remember,
    the State Hook returns an array like this: `[value, setValue]`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义上下文，我们需要再次使用 `createContext` 函数。在这种情况下，我们将默认值设置为包含空字符串和一个 **no-op 函数**（一个什么也不做的函数）的数组。稍后，在定义提供者时，我们将使用
    State Hook 的结果提供这个数组。记住，State Hook 返回一个这样的数组：`[value, setValue]`。
- en: 'Now, let’s get started defining the context:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始定义上下文：
- en: 'Copy the `Chapter05_1` folder to a new `Chapter05_2` folder by executing the
    following command:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令将 `Chapter05_1` 文件夹复制到新的 `Chapter05_2` 文件夹：
- en: '[PRE27]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Open the new `Chapter05_2` folder in VS Code.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开新的 `Chapter05_2` 文件夹。
- en: 'Create a new `src/contexts/UserContext.js` file. Inside it, import the `createContext`
    function:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `src/contexts/UserContext.js` 文件。在文件内部，导入 `createContext` 函数：
- en: '[PRE28]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, define the context with the aforementioned default value, which imitates
    the return value of a State Hook, but with an empty string and a **no-op function**
    (a function that does nothing):'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用前面提到的默认值定义上下文，这模仿了 State Hook 的返回值，但使用空字符串和一个 **no-op 函数**（一个什么也不做的函数）：
- en: '[PRE29]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When the context is consumed but no provider is defined, then it will return
    this default value.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当上下文被消费但没有定义提供者时，它将返回这个默认值。
- en: Now, let’s continue with defining the context provider.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续定义上下文提供者。
- en: Defining the context provider
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义上下文提供者
- en: We have already created a State Hook for the `username` state. We can now use
    the result from this State Hook and pass it to the context provider so that any
    component in our app can make use of it.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为 `username` 状态创建了一个 State Hook。现在我们可以使用这个 State Hook 的结果并将其传递给上下文提供者，这样我们的应用中的任何组件都可以使用它。
- en: 'Let’s get started defining the context provider now:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始定义上下文提供者：
- en: 'Edit `src/App.jsx` and import `UserContext`, as follows:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/App.jsx` 并按照以下方式导入 `UserContext`：
- en: '[PRE30]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, wrap the result of the `App` component with `UserContext.Provider`:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将 `App` 组件的结果包裹在 `UserContext.Provider` 中：
- en: '[PRE31]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we can *remove* the following props we previously passed down:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以 *移除* 我们之前传递下来的以下属性：
- en: '[PRE32]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Do not forget to add the closing tag for `UserContext.Provider`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记为 `UserContext.Provider` 添加关闭标签：
- en: '[PRE33]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Of course, it is also possible to use a similar pattern to pass the result of
    a Reducer Hook into a context.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也可以使用类似的模式将 Reducer Hook 的结果传递到上下文中。
- en: The context provider now provides the `username` value and the `setUsername`
    function to the rest of our app.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在上下文提供者提供了 `username` 值和 `setUsername` 函数给我们的应用的其他部分。
- en: Refactoring the app to use UserContext
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将应用重构为使用 UserContext
- en: Now that we have a context provider, we can refactor the rest of our app to
    use the context instead of props.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了上下文提供者，我们可以重构应用的其他部分以使用上下文而不是属性。
- en: 'Follow these steps to get started:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤开始：
- en: 'First, edit `src/components/user/UserBar.jsx` and add imports to the `useContext`
    function and `UserContext`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，编辑 `src/components/user/UserBar.jsx` 并向 `useContext` 函数和 `UserContext` 添加导入：
- en: '[PRE34]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, *remove* the props passed to the component:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，*移除* 传递给组件的属性：
- en: '[PRE35]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, define the Context Hook and get the `username` value from it:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义 Context Hook 并从其中获取 `username` 值：
- en: '[PRE36]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can now *remove* the props passed down to the other components:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以 *移除* 传递给其他组件的属性：
- en: '[PRE37]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Edit `src/components/user/Login.jsx` and add an import of `useContext` and
    `UserContext`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/components/user/Login.jsx` 并添加 `useContext` 和 `UserContext` 的导入：
- en: '[PRE38]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, *remove* the props from the component:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，*移除* 组件中的属性：
- en: '[PRE39]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add the Context Hook:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 Context Hook：
- en: '[PRE40]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If we do not need the first element of an array, we can skip it when destructuring
    by simply putting a comma without specifying the name of the first variable.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们不需要数组的第一元素，我们可以在解构时通过简单地放置一个逗号而不指定第一个变量的名称来跳过它。
- en: 'Edit `src/components/user/Logout.jsx` and add an import of `useContext` and
    `UserContext`:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/components/user/Logout.jsx`并添加`useContext`和`UserContext`的导入：
- en: '[PRE41]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, *remove* the props from the component:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，*移除*组件的props：
- en: '[PRE42]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add the Context Hook:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加Context Hook：
- en: '[PRE43]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Edit `src/components/user/Register.jsx` and add an import of `useContext` and
    `UserContext`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/components/user/Register.jsx`并添加`useContext`和`UserContext`的导入：
- en: '[PRE44]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, *remove* the props from the component:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，*移除*组件的props：
- en: '[PRE45]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add the Context Hook:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加Context Hook：
- en: '[PRE46]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Edit `src/components/post/CreatePost.jsx` and add an import of `useContext`
    and `UserContext`:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/components/post/CreatePost.jsx`并添加`useContext`和`UserContext`的导入：
- en: '[PRE47]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, *remove* the `username` prop from the component:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，*移除*组件的`username` prop：
- en: '[PRE48]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Add the Context Hook, as follows:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下步骤添加Context Hook：
- en: '[PRE49]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Start the app, as follows:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下步骤启动应用：
- en: '[PRE50]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, the app works the same way as before, but our code is a lot cleaner and
    more concise, all thanks to React Context and the Context Hook!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个应用的工作方式与之前相同，但我们的代码更加整洁和简洁，这都要归功于React Context和Context Hook！
- en: '**Example code**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例代码**'
- en: The example code for this section can be found in the `Chapter05/Chapter05_2`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的示例代码可以在`Chapter05/Chapter05_2`文件夹中找到。请检查文件夹内的`README.md`文件，以获取设置和运行示例的说明。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we first learned about React Context as an alternative to passing
    down props over multiple levels of React components. We then learned about context
    providers and consumers, and the new way to define consumers via Hooks. We used
    what we learned in practice, by implementing theme support in our blog app. Next,
    we learned when it does not make sense to use contexts, and when we should use
    inversion of control instead. Finally, we used a context for the global `username`
    state in our blog app.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先了解了React Context作为在多个React组件层级传递props的替代方案。然后，我们学习了上下文提供者和消费者，以及通过Hooks定义消费者的新方法。我们通过在我们的博客应用中实现主题支持来实践所学知识。接下来，我们学习了何时不应使用上下文，以及何时应使用控制反转。最后，我们在我们的博客应用中使用了上下文来存储全局`username`状态。
- en: In the next chapter, we are going to learn how to request data from a server,
    using React and Hooks. Then, we are going to learn about React Suspense, so that
    we do not have to wait for the requests to finish before rendering our app.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用React和Hooks从服务器请求数据。然后，我们将学习React Suspense，这样我们就不必等待请求完成后再渲染我们的应用。
- en: Questions
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To recap what we have learned in this chapter, try to answer the following
    questions:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾本章学到的内容，尝试回答以下问题：
- en: What problem do contexts avoid?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上下文避免了什么问题？
- en: What are the three parts that contexts consist of?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上下文由哪三个部分组成？
- en: Are all parts required to be defined in order to use contexts?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用上下文是否需要定义所有部分？
- en: What is the advantage of using Hooks instead of traditional context consumers?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Hooks而不是传统上下文消费者有什么优势？
- en: What is an alternative to contexts and when should we use it?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上下文的替代方案是什么？何时应该使用它？
- en: How can we implement dynamically changing contexts?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何实现动态更改上下文？
- en: When does it make sense to use contexts for state?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下使用上下文来存储状态是有意义的？
- en: Further reading
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If you are interested in more information about the concepts that we have learned
    in this chapter, take a look at the following links:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对本章学到的概念感兴趣，请查看以下链接：
- en: 'Official docs on React Context: [https://react.dev/learn/passing-data-deeply-with-context](https://react.dev/learn/passing-data-deeply-with-context)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Context的官方文档：[https://react.dev/learn/passing-data-deeply-with-context](https://react.dev/learn/passing-data-deeply-with-context)
- en: 'List of HTML color codes (if you want to adjust your theme): [https://www.rapidtables.com/web/color/html-color-codes.html](https://www.rapidtables.com/web/color/html-color-codes.html)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML颜色代码列表（如果您想调整主题）：[https://www.rapidtables.com/web/color/html-color-codes.html](https://www.rapidtables.com/web/color/html-color-codes.html)
- en: 'Example of contexts for local state used by `react-aria`: [https://react-spectrum.adobe.com/react-aria/advanced.html#contexts](https://react-spectrum.adobe.com/react-aria/advanced.html#contexts)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-aria`使用的本地状态上下文示例：[https://react-spectrum.adobe.com/react-aria/advanced.html#contexts](https://react-spectrum.adobe.com/react-aria/advanced.html#contexts)'
- en: 'Example of contexts for global state used by `react-i18next`: [https://react.i18next.com/latest/i18nextprovider](https://react.i18next.com/latest/i18nextprovider)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-i18next` 用于全局状态的上下文示例：[https://react.i18next.com/latest/i18nextprovider](https://react.i18next.com/latest/i18nextprovider)'
- en: Learn more on Discord
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的 Discord 社区——在那里您可以分享反馈、向作者提问，并了解新书发布——请扫描下面的二维码：
- en: '[https://packt.link/wnXT0](Chapter_05.xhtml)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/wnXT0](Chapter_05.xhtml)'
- en: '![](img/image_%283%29.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_%283%29.png)'
