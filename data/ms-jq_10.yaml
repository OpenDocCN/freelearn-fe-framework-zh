- en: Chapter 10. Manipulating Images
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。操纵图像
- en: It is often said that images paint a thousand words – websites are no different.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 常常有人说图像胜过千言万语 – 网站也不例外。
- en: We use images to illustrate a process, help reinforce a message, or apply some
    visual identity to what otherwise might be seen as very plain content. Images
    play a key part of any website; the quality of images will either make or break
    a site.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用图像来说明一个过程，帮助强化信息，或者为原本可能被视为非常普通的内容应用一些视觉身份。图像在任何网站中都起着关键作用；图像的质量会决定一个站点的成败。
- en: 'A small part of using jQuery to manipulate images is how we can apply filters,
    or manipulate the colors within images. In this chapter, we''ll explore how you
    can use jQuery to manipulate images, before exploring a couple of real-world examples
    of capturing images as a basis for further manipulation. In this chapter, we''ll
    cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 jQuery 操纵图像的一小部分是我们如何应用滤镜，或者操纵图像中的颜色。在本章中，我们将探讨如何使用 jQuery 操纵图像，然后探索几个以捕获图像作为进一步操纵基础的真实世界示例。在本章中，我们将涵盖以下主题：
- en: Applying filters using CSS and jQuery
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CSS 和 jQuery 应用滤镜
- en: Using plugins to edit images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用插件编辑图像
- en: Creating a simple signature pad using jQuery and canvas
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 jQuery 和 canvas 创建一个简单的签名板
- en: Capturing and manipulating webcam images
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获和操纵网络摄像头图像
- en: Let's start…!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧…！
- en: Manipulating colors in images
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操纵图像中的颜色
- en: A question – how often have you assumed that the only way to manipulate an image
    is to use the likes of Photoshop, or even GIMP? I'll bet it is more than once
    – what if I said that heavyweight applications such as these well-known applications
    are (in some cases) redundant, and that all you need is a text editor and a little
    jQuery?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题 – 你多久以为操纵图像的唯一方式是使用像 Photoshop 或者 GIMP 这样的软件？我打赌不止一次 – 如果我说这些广为人知的重量级应用程序在某些情况下是多余的，而你只需要一个文本编辑器和一点点
    jQuery 呢？
- en: At this point, you're probably wondering what we can do to manipulate images
    using jQuery. Fear not! There are a few tricks up our sleeve. Over the next few
    pages, we're going to take a look at each, and discover that while we can use
    what is arguably one of the most popular JavaScript libraries available to developers,
    it isn't always the right way to do things.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可能想知道我们可以用 jQuery 如何操纵图像。别担心！我们有几个绝招。在接下来的几页中，我们将逐个看看，发现虽然我们可以使用可能是开发人员最常用的
    JavaScript 库之一，但并不总是正确的做法。
- en: 'To see what I mean, let''s quickly recap the methods we can use, which are:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解我的意思，让我们快速回顾一下我们可以使用的方法，它们是：
- en: Using CSS3 filters, and switching them in or out using jQuery
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CSS3 滤镜，并使用 jQuery 切换它们的使用与否
- en: Using a mix of the HTML5 `<canvas>` element, jQuery, and the `getImageData`
    method handler to manipulate the color elements of each image, before repainting
    it back to the canvas
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HTML5 `<canvas>` 元素，jQuery 和 `getImageData` 方法处理程序的混合方式来操作每个图像的颜色元素，然后将其重新绘制到画布上。
- en: In this chapter, we'll take a look at each in turn, and explore why even though
    we may be able to create complex filters using jQuery, it isn't always the right
    answer. Hopefully, with a few tricks up our sleeve, it will make us better developers.
    Let's begin with a look at using simple CSS3 filters, and how we can easily incorporate
    their use into our jQuery code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将依次看看每一个，并探讨为什么即使我们可以使用 jQuery 创建复杂的滤镜，它也并不总是正确的答案。希望通过我们的一些绝招，能让我们成为更好的开发人员。让我们从简单的
    CSS3 滤镜开始，看看我们如何轻松地将它们应用到我们的 jQuery 代码中。
- en: Adding filters using CSS3
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CSS3 添加滤镜
- en: 'Filter support has been available for some time, at least within the major
    desktop browsers, although we still need to use the `-webkit-` vendor prefix support,
    as we are not yet entirely prefix free:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 至少在主流桌面浏览器中，滤镜支持已经有一段时间了，尽管我们仍然需要使用 `-webkit-` 厂商前缀支持，因为我们还不完全是无前缀的：
- en: '![Adding filters using CSS3](img/image00428.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![使用 CSS3 添加滤镜](img/image00428.jpeg)'
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Information about the preceding image is taken from the CanIUse website, at
    [http://caniuse.com/#feat=css-filters](http://caniuse.com/#feat=css-filters).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面图像的信息来自 CanIUse 网站，网址为 [http://caniuse.com/#feat=css-filters](http://caniuse.com/#feat=css-filters)。
- en: The beauty about using these methods is that they are very simple to apply;
    we're not forced to spend hours reworking images if clients decide to change their
    minds! We can apply and remove the styles using jQuery with ease, which helps
    keep the styles separate from our markup.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些方法的美妙之处在于它们非常简单易行；如果客户决定改变主意，我们不必花费数小时重新制作图像！我们可以轻松地使用jQuery应用和移除样式，这有助于将样式与我们的标记分开。
- en: Manipulating images can get very complex – in fact, to cover the math involved,
    we could probably fill a book in its own right! Instead, we'll begin with a simple
    recap of using CSS3 filters, before moving onto creating more complex filters,
    and finishing with a couple of demos that help capture images from two unlikely
    sources.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 操纵图像可能变得非常复杂 – 实际上，要涵盖所涉及的数学，我们可能需要写一本专门的书！相反，我们将从简单回顾使用CSS3滤镜开始，然后转向创建更复杂的滤镜，并以帮助从两个不太可能的源捕获图像的几个演示结束。
- en: Intrigued? All will become clear towards the end of this chapter, but we will
    first begin with a simple exercise to reacquaint ourselves with applying CSS3
    filters.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 感兴趣吗？在本章末尾一切都会变得清晰起来，但我们首先将从一个简单的练习开始，重新熟悉应用CSS3滤镜。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we get stuck into our exercises, I would strongly recommend using Firefox
    or IE for these demos; if you use Chrome, then some of the demos will show Cross-Origin
    errors if run locally.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始练习之前，我强烈建议您在这些演示中使用Firefox或IE；如果您使用Chrome，那么在本地运行时，某些演示将显示跨源错误。
- en: A good example is the cross-platform application XAMPP (available from [http://www.apachefriends.org](http://www.apachefriends.org)),
    or you can try WAMPServer (for PC, from [http://www.wampserver.com/en](http://www.wampserver.com/en)),
    or MAMP (for Mac, from [http://www.mamp.info](http://www.mamp.info)). I will assume
    that you are running the demos from within a web server.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是跨平台应用程序XAMPP（可从[http://www.apachefriends.org](http://www.apachefriends.org)获取），或者您可以尝试WAMPServer（适用于PC，从[http://www.wampserver.com/en](http://www.wampserver.com/en)获取），或者MAMP（适用于Mac，从[http://www.mamp.info](http://www.mamp.info)获取）。我将假设您是从Web服务器中运行演示。
- en: Creating our base page
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的基页
- en: 'In our first demo for this chapter, we''re going to start with a simple recap
    of using the `addClass` method to apply a specific filter to an image on the page.
    We''ll be using the Polaroid effect, developed by the Canadian developer Nick
    La, and available from [http://webdesignerwall.com/demo/decorative-gallery-2/](http://webdesignerwall.com/demo/decorative-gallery-2/).
    The `.addClass()` method is something you will almost certainly have used countless
    times before; we''re using it here as an introduction to more complex effects
    later in this chapter. Let''s begin:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一个演示中，我们将从简单回顾使用 `addClass` 方法开始，将特定的滤镜应用到页面上的图像。我们将使用加拿大开发者Nick La开发的拍立得效果，并且可以从[http://webdesignerwall.com/demo/decorative-gallery-2/](http://webdesignerwall.com/demo/decorative-gallery-2/)获取。`.addClass()`
    方法是您几乎肯定以前使用过无数次的方法；我们在这里使用它是为了引入本章后面更复杂效果的介绍。让我们开始：
- en: 'Let''s start by downloading and extracting the following files from the code
    download that accompanies this book:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从从伴随本书的代码下载中下载并提取以下文件开始：
- en: '`cssfilters.html`'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cssfilters.html`'
- en: '`cssfilters.css`'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cssfilters.css`'
- en: '`jquery.min.js`'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.min.js`'
- en: '`cssfilters.js`'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cssfilters.js`'
- en: Drop the HTML markup file into the root of our project area, and the JavaScript
    and CSS files into the relevant subfolders in our project area.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将HTML标记文件放入项目区域的根目录，将JavaScript和CSS文件放入项目区域的相关子文件夹中。
- en: 'In a new file, go ahead and add the following simple block of code – this is
    the event handler for the button, which we will use to change the filter state:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新文件中，添加以下简单的代码块 – 这是按钮的事件处理程序，我们将用它来更改滤镜状态：
- en: '[PRE0]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At this stage, try previewing the results in a browser. If all is well, we should
    see a picture of blue flowers, set in a Polaroid effect background. Refer to the
    following image:![Creating our base page](img/image00429.jpeg)
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段，尝试在浏览器中预览结果。如果一切正常，我们应该看到一张蓝色花朵的图片，设置在拍立得效果的背景中。参考以下图片：![创建我们的基页](img/image00429.jpeg)
- en: 'Take a closer look in `cssfilters.css` – near the bottom of the screen. We
    should see the following:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `cssfilters.css` – 屏幕底部附近仔细查看。我们应该看到以下内容：
- en: '[PRE1]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is immediately followed by this block:'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 紧接着这个区块：
- en: '[PRE2]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now click on the **Change filter using CSS** button. If all is well, our image
    should gradually become blurred, as shown in the next image:![Creating our base
    page](img/image00430.jpeg)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击**使用CSS更改滤镜**按钮。如果一切正常，我们的图像应该逐渐变模糊，如下图所示：![创建我们的基页](img/image00430.jpeg)
- en: A nice simple demo – nothing too taxing at this stage, given some of the more
    complex topics we've covered in this book till now!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的演示 - 在目前阶段没有太多困难，考虑到我们在本书中已经涵盖了一些更复杂的主题！
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'A tip – if you find that the filter doesn''t display in some versions of Firefox,
    then check the **layout.css.filters.enabled** property in **about:config**. It
    is not enabled by default in version 34 or earlier; this changed from version
    35:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 - 如果你发现在某些版本的Firefox中滤镜显示不出来，那么请检查**about:config**中的**layout.css.filters.enabled**属性。在34版或更早的版本中，默认情况下未启用；这一点是从35版开始改变的：
- en: '![Creating our base page](img/image00431.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们的基本页面](img/image00431.jpeg)'
- en: The key to this demo is of course the use of the `.addClass()` method handler.
    We're simply applying a new, preset class to the image, when clicking the button.
    The beauty here though is that we have access to a number of quick and easy filters
    that can be used, and which can reduce (or even eliminate) the use of PhotoShop
    or GIMP. To see how really easy it is to swap over, let's make that change now,
    and switch to using the brightness filter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个演示的关键是使用`.addClass()`方法处理程序。当点击按钮时，我们只是将一个新的，预设的类应用于图像。但在这里美妙的是，我们可以访问许多快速、简单的滤镜，可以减少（甚至消除）对PhotoShop或GIMP的使用。为了看到切换有多容易，让我们现在做出这个改变，切换到使用亮度滤镜。
- en: Changing the brightness level
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改亮度级别
- en: 'This next demo is a quick and easy change to the `cssfilters.css` file we''ve
    just been working on. Following is a screenshot of what we will produce:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个演示是对我们刚刚工作过的`cssfilters.css`文件进行快速简单的更改。以下是我们将要制作的屏幕截图：
- en: '![Changing the brightness level](img/image00432.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![更改亮度级别](img/image00432.jpeg)'
- en: 'Make sure you have this file available before continuing with the steps listed
    next:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下面列出的步骤之前，请确保你有这个文件可用：
- en: 'In `cssfilters.css`, look for and amend the `.change-filter` rule as shown:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`cssfilters.css`中，查找并修改`.change-filter`规则如下所示：
- en: '[PRE3]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Click on **Change filter using CSS** now. If all is well, we should find that
    the image has become brighter.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击**使用CSS更改滤镜**。如果一切正常，我们应该会发现图像变得更加明亮。
- en: Again – nothing taxing here; hopefully this is a good point for a breather,
    after some of what we've covered in this book! There are a good handful of CSS3
    filters we can use; space constraints means we can't cover them all here, but
    we can at least look at one more filter. The other filters available for use are
    outlined immediately following this next exercise.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 同样 - 在这里没有太多困难；希望在本书中我们所涵盖的一些内容后，这是一个放松的时刻！我们可以使用一些CSS3滤镜；由于空间限制，我们不能在这里涵盖它们所有，但至少我们可以再看一种滤镜。在接下来的练习后面，我们将介绍可供使用的其他滤镜。
- en: Adding a sepia filter to our image
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向我们的图像添加深褐色滤镜
- en: 'As before, we need to revert back to changing `cssfilters.css`, so make sure
    you have this ready for use. Let''s take a look at what we need to do:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，我们需要恢复更改`cssfilters.css`，所以确保你已经准备好了这个文件。让我们看看我们需要做什么：
- en: 'Revert back to `cssfilters.css`, then alter this line as shown:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恢复到`cssfilters.css`，然后按如下所示修改这一行：
- en: '[PRE4]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Click on **Change filter using CSS** now. If all is well, we should find that
    the image now has a sepia filter applied, as shown in this screenshot:![Adding
    a sepia filter to our image](img/image00433.jpeg)
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击**使用CSS更改滤镜**。如果一切正常，我们应该会发现图像现在应用了一种深褐色滤镜，如此屏幕截图所示：![向我们的图像添加深褐色滤镜](img/image00433.jpeg)
- en: This is what I love about using CSS3 filters – despite what some purists may
    say, it is not always necessary to revert back to using a graphics package; a
    simple change of a value in CSS is all that is required.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我喜欢使用CSS3滤镜的地方 - 尽管有些纯粹主义者可能会说的，但并不总是必要回到使用图形软件包；在CSS中简单更改一个值就足够了。
- en: We could manually change that value if needed, but we now have the flexibility
    to programmatically change it too, with little impact on performance. This last
    point is important – as we will see later in this chapter. Creating complex filters
    to manipulate images using jQuery is a resource hungry process, so it's not one
    to be done too frequently.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们可以手动更改该值，但是现在我们也可以以编程方式灵活地进行更改，对性能几乎没有影响。这一点非常重要，因为我们将在本章后面看到。使用jQuery创建复杂滤镜来操纵图像是一个资源消耗大的过程，因此不宜频繁进行。
- en: Exploring other filters
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索其他滤镜
- en: 'Before we move on and take a look at a different way of manipulating images,
    the following table gives you a flavor of the different filters available; all
    of them can be set using jQuery as outlined in our previous exercises:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续探讨不同的图像处理方法之前，下表展示了不同滤镜的风格；所有这些滤镜都可以使用 jQuery 进行设置，就像我们在之前的练习中所概述的那样：
- en: '| Name of filter | Example of how to use it |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 滤镜名称 | 使用示例 |'
- en: '| --- | --- |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `contrast()` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `contrast()` |'
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `hue-rotate()` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `hue-rotate()` |'
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `grayscale()` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `grayscale()` |'
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `invert()` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `invert()` |'
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Saturate()` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `Saturate()` |'
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: To see examples of these in action, it is worth taking a look online – there
    are plenty of examples available. As a starting point, have a look at the article
    by Johnny Simpson at [http://www.inserthtml.com/2012/06/css-filters/](http://www.inserthtml.com/2012/06/css-filters/);
    although it is a couple of years old, and some of the settings have been tweaked
    since then, it still gives a useful flavor of what is possible with CSS3 filters.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这些滤镜的实际示例，值得上网查看一下——有很多示例可供参考。作为一个起点，可以查看约翰尼·辛普森在[http://www.inserthtml.com/2012/06/css-filters/](http://www.inserthtml.com/2012/06/css-filters/)上的文章；虽然这篇文章已经有几年了，而且有些设置已经进行了调整，但仍然可以对
    CSS3 滤镜的可能性提供有用的了解。
- en: 'Let''s change track for a moment – while we can use simple CSS3 filters to
    manipulate aspects such as contrast and brightness, we can use an alternative
    method: background blending.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们换个方式来思考——虽然我们可以使用简单的 CSS3 滤镜来调整对比度和亮度等方面，但我们也可以使用另一种方法：背景混合。
- en: Blending images using CSS3
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CSS3 合并图像
- en: There may be instances where we prefer not to manipulate the image directly,
    but alter a background image instead. Similar effects are easy to achieve in static
    images within PhotoShop, but are less common on the Internet.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能更喜欢不直接处理图像，而是改变背景图像。在 PhotoShop 中可以很容易地在静态图像中实现类似的效果，但在互联网上较少见。
- en: Thankfully, we can achieve the same effect using the `background-blend` mode
    within CSS – this has the effect of allowing us to merge two images together.
    Using `background-blend` mode (for which browser support is good within desktop
    browsers) removes the need to manually edit each photo, so if any are changed,
    the same effect can easily be applied to their replacements.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以在 CSS 中使用`background-blend`模式来实现相同的效果——这样可以让我们将两张图像合并在一起。使用`background-blend`模式（在桌面浏览器中的浏览器支持良好）可以避免手动编辑每张照片的需求，因此如果任何照片更改了，同样的效果可以轻松应用到它们的替代品上。
- en: 'In the same vein as those filters we''ve already examined, we would apply the
    filters within CSS. We can then switch them on or off using jQuery at will. I
    won''t revisit the jQuery code that would be required, as we''ve already seen
    it earlier in the chapter; suffice to say that we would apply the `background-blend`
    mode, using an example such as the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们已经检查过的那些滤镜一样，我们会在 CSS 中应用这些滤镜。然后我们可以随心所欲地使用 jQuery 打开或关闭它们。我不会重新介绍所需的 jQuery
    代码，因为我们已经在本章的早些时候见过了；简单地说，我们会应用`background-blend`模式，使用以下示例：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this instance, we''ve used the `overlay` filter. This complex filter multiplies
    the colors, depending on the backdrop color value. It has the net effect of making
    lighter colors go lighter, and darker colors go darker, as shown in the next screenshot:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`overlay`滤镜。这个复杂的滤镜会根据背景色值来乘以颜色。它的净效果是让浅色变得更浅，让深色变得更深，如下一个截图所示：
- en: '![Blending images using CSS3](img/image00434.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![使用 CSS3 合并图像](img/image00434.jpeg)'
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There are two examples of this blend mode in the code download that accompanies
    this book – look for the `overlay.html` and `multiply.html` files.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '代码下载包中有两个示例，其中包括`overlay.html`和`multiply.html`文件中的这种混合模式的示例。 '
- en: There are a good number of filter options available, such as multiply, lighten,
    dodge, and color burn – these are intended to produce similar effects to those
    used in PhotoShop, but without the need for expensive applications. All the filters
    follow a similar format. It is worth searching Google for examples of how filters
    appear, such as those shown at [http://www.webdesignerdepot.com/2014/07/15-css-blend-modes-that-will-supercharge-your-images/](http://www.webdesignerdepot.com/2014/07/15-css-blend-modes-that-will-supercharge-your-images/).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多滤镜选项可供选择，比如乘法、变亮、避免和颜色燃烧——这些都旨在产生类似于 PhotoShop 中使用的效果，但不需要昂贵的应用程序。所有滤镜都遵循类似的格式。在谷歌上搜索滤镜的示例很值得，比如在[http://www.webdesignerdepot.com/2014/07/15-css-blend-modes-that-will-supercharge-your-images/](http://www.webdesignerdepot.com/2014/07/15-css-blend-modes-that-will-supercharge-your-images/)上展示的那些。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you would like to learn more, then head over to Mozilla's Developer site
    at [https://developer.mozilla.org/en-US/docs/Web/CSS/back ground-blend-mode](https://developer.mozilla.org/en-US/docs/Web/CSS/back%20ground-blend-mode).
    For a really useful example of this filter (and a source of inspiration for combining
    it with jQuery), check out the 2016 American Presidential Candidates demo at [http://codepen.io/bennettfeely/pen/rxoAc](http://codepen.io/bennettfeely/pen/rxoAc).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多信息，请访问Mozilla的开发者网站[https://developer.mozilla.org/en-US/docs/Web/CSS/background-blend-mode](https://developer.mozilla.org/en-US/docs/Web/CSS/background-blend-mode)。要获取此滤镜的真正有用的示例（以及与jQuery结合的灵感来源），请查看2016年美国总统候选人演示[http://codepen.io/bennettfeely/pen/rxoAc](http://codepen.io/bennettfeely/pen/rxoAc)。
- en: Okay, time to get really stuck into some jQuery, methinks! Let's switch to using
    plugins, and see some of the effects we can achieve with what is available for
    use. We'll start with a look at using CamanJS as our example, following it with
    a more in-depth exploration of creating filters manually, and see why it's not
    always the best way to achieve the desired effect!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，是时候真正投入一些jQuery的时间了！让我们转向使用插件，并看看我们可以使用什么可用的东西来实现一些效果。我们将从使用CamanJS作为示例开始，然后深入探讨手动创建滤镜，并看看为什么这并不总是实现所需效果的最佳方式！
- en: Applying filters with CamanJS
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CamanJS应用滤镜
- en: So far, we've applied filters using CSS3\. This is perfect for lightweight solutions,
    but there may be occasions where we need to do more, and CSS3 won't suffice.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用CSS3应用了滤镜。这对于轻量级解决方案来说是完美的，但在某些情况下，我们可能需要做更多，而CSS3则不够。
- en: Enter jQuery! Over the next few pages, we'll take a brief look at applying filters
    using CamanJS as our example jQuery plugin. We'll then move on and see how easy
    (or complex) it is to create the same effects manually, without needing to rely
    on a third-party plugin.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 进入jQuery！在接下来的几页中，我们将简要介绍如何使用CamanJS作为我们示例jQuery插件来应用滤镜。然后，我们将继续看看如何轻松（或复杂）地手动创建相同的效果，而不需要依赖第三方插件。
- en: Introducing CamanJS as a plugin
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍CamanJS作为插件
- en: CamanJS is one of the several plugins available for jQuery, which allows us
    to apply any number of filters; we can choose from either the preset ones that
    come with the library, or create our own combinations.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: CamanJS是为jQuery提供的几个插件之一，它允许我们应用任意数量的滤镜；我们可以从库中提供的预设滤镜中选择，或者创建我们自己的组合。
- en: The plugin is available from [http://camanjs.com/](http://camanjs.com/), and
    can be downloaded from GitHub at [https://github.com/meltingice/CamanJS](https://github.com/meltingice/CamanJS).
    Else, we can use NodeJS or Bower to install the library. The plugin is also available
    via CDN at [http://www.cdnjs.com](http://www.cdnjs.com) – search for CamanJS to
    get the latest URL to use in your project.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件可以从[http://camanjs.com/](http://camanjs.com/)获得，并可以从GitHub下载[https://github.com/meltingice/CamanJS](https://github.com/meltingice/CamanJS)。另外，我们可以使用NodeJS或Bower来安装该库。该插件还可以通过CDN在[http://www.cdnjs.com](http://www.cdnjs.com)获得
    - 搜索CamanJS以获取在您的项目中使用的最新URL。
- en: 'It is worth noting that filters can be applied using one of two methods – the
    first is as a HTML data- attribute:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，可以使用两种方法之一来应用滤镜 - 第一种是作为HTML数据属性：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The second method is using jQuery, as we will see in the next demo; we'll be
    using this method throughout our examples. With this in mind, let's get cracking,
    and take a look at using CamanJS to apply filters, as shown in our next demo.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是使用jQuery，正如我们将在下一个演示中看到的；我们将在我们的示例中一直使用这种方法。有了这个想法，让我们开始动手，并看看如何使用CamanJS来应用滤镜，就像我们下一个演示中展示的那样。
- en: Building a simple demo
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个简单的演示
- en: In this demo, we'll be using the CamanJS library to apply any one of the three
    filters to our flowers image that we've been using throughout this chapter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示中，我们将使用CamanJS库来对我们在本章节中一直在使用的花朵图像应用三个滤镜中的任何一个。
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember – if you use Chrome, run this demo from within a local webserver, as
    suggested in the *Getting ready* section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 - 如果您使用Chrome，请在本地Web服务器内运行此演示，如“准备就绪”部分所建议的那样。
- en: 'Let''s begin:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始：
- en: 'Start by extracting the following files from the code download that accompanies
    this book. For this demo, we''ll need the following files: `caman.html`, `flowers.jpg`,
    `usecaman.js`, `jquery.min.js,` and `usecaman.css`. Store the JavaScript files
    in the `js` subfolder, the CSS file in the `css` subfolder, the image within the
    `img` subfolder, and the HTML markup within the root area of our project folder.'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从附带本书的代码下载中提取以下文件。对于这个演示，我们需要以下文件：`caman.html`，`flowers.jpg`，`usecaman.js`，`jquery.min.js`和`usecaman.css`。将JavaScript文件存储在`js`子文件夹中，将CSS文件存储在`css`子文件夹中，将图像存储在`img`子文件夹中，并将HTML标记存储在项目文件夹的根目录中。
- en: Run the `caman.html` demo file. If all is well, we should see the following
    image appear:![Building a simple demo](img/image00435.jpeg)
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`caman.html`演示文件。如果一切顺利，我们应该看到以下图片出现：![构建一个简单的演示](img/image00435.jpeg)
- en: Let's explore the jQuery required to operate the demo. If we peek inside `usecaman.js`,
    we'll see the following code. This is used to get a handle on the `<canvas>` element
    in our markup, before drawing the `flowers.jpg` image on it.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们探索操作演示所需的jQuery。如果我们查看`usecaman.js`，我们会看到以下代码。这用于获取我们标记中`<canvas>`元素的句柄，然后在其上绘制`flowers.jpg`图像。
- en: '[PRE12]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Digging a little deeper, we should see the following method – this handles
    the reset of the `<canvas>` element back to its original state; notice how the
    `drawImage()` method is used, which is key to manipulating images with different
    filters:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 深入挖掘一下，我们应该看到以下方法——这个方法处理了`<canvas>`元素恢复到其原始状态的重置；请注意使用的`drawImage()`方法，这是使用不同滤镜操作图像的关键：
- en: '[PRE13]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We then top it off with three different event handlers – these apply the relevant
    CamanJS filter:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们再加上三个不同的事件处理程序——这些应用了相应的CamanJS滤镜：
- en: '[PRE14]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our simple demo only scratches the surface of what is possible with CamanJS.
    It is well worth having a look at the site in more detail, to get a feel for what
    can be achieved using the library. As a source of inspiration, take a look at
    the article by Carter Rabasa, which uses the library to create a Phonestagram
    application, based on the well-known Instagram site; it's available at [https://www.twilio.com/blog/2014/11/phonestagram-fun-with-photo-filters-using-node-hapi-and-camanjs.html](https://www.twilio.com/blog/2014/11/phonestagram-fun-with-photo-filters-using-node-hapi-and-camanjs.html).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的简单演示只是展示了使用CamanJS可能性的冰山一角。详细查看该网站，了解使用该库可以实现的效果是非常值得的。作为灵感的来源，请查看Carter
    Rabasa的文章，他使用该库创建了一个基于著名的Instagram网站的Phonestagram应用程序；该文章位于[https://www.twilio.com/blog/2014/11/phonestagram-fun-with-photo-filters-using-node-hapi-and-camanjs.html](https://www.twilio.com/blog/2014/11/phonestagram-fun-with-photo-filters-using-node-hapi-and-camanjs.html)。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's worth noting that CamanJS is able to handle HiDPI images with ease – all
    we need to do is set the `data-caman-hidpi` attribute in our code. Caman will
    automatically switch to using the hi-res version, if it detects that the device
    supports hi-res images. Note though, that rendering takes longer, due to the additional
    pixels being used.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，CamanJS能够轻松处理HiDPI图像——我们只需在代码中设置`data-caman-hidpi`属性。如果检测到设备支持高分辨率图像，Caman将自动切换到使用高分辨率版本。但要注意，由于使用了额外的像素，渲染时间会更长。
- en: Getting really creative
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Getting really creative
- en: Cast your mind back to the beginning of this chapter, where I mentioned that
    CSS3 filters provide a convenient and lightweight means of manipulating images.
    Their use means that we can reduce the amount of work required when editing the
    images, and that should the images change in size or content, then it is much
    easier to update them.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下本章开头提到的地方，我提到CSS3滤镜提供了一个方便且轻量级的手段来操作图像。它们的使用意味着我们可以减少编辑图像所需的工作量，并且如果图像的大小或内容发生变化，更新它们会更容易。
- en: However, using CSS3 filters can only go so far – this is where jQuery takes
    over. To see why, let's work through another demo. This time, we'll use one of
    the more advanced preset filters that comes with CamanJS, and which would be difficult
    to achieve if we had to use CSS3 filters alone.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用CSS3滤镜只能做到这一点——这就是jQuery接管的地方。要了解原因，请让我们通过另一个演示来进行工作。这一次，我们将使用CamanJS附带的更高级的预设滤镜之一，如果仅使用CSS3滤镜就很难实现。
- en: 'Remember – if you use Chrome, please run this demo from within a local web
    server, as suggested in the *Getting ready* section. Let''s start:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 记住——如果您使用的是Chrome，请从本地Web服务器中运行此演示，如“准备就绪”部分所建议的那样。让我们开始：
- en: 'For this demo, we need some files from the code download that accompanies this
    book. They are: `caman-advanced.css`, `caman-advanced.html`, `caman.full.js`,
    `jquery.min.js`, and `flowers.jpg`. Place each file in the relevant subfolders,
    and the HTML markup file in the root of our project area.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个演示，我们需要从本书配套的代码下载中获取一些文件。它们是：`caman-advanced.css`，`caman-advanced.html`，`caman.full.js`，`jquery.min.js`和`flowers.jpg`。将每个文件放在相关的子文件夹中，而将HTML标记文件放在项目区的根目录。
- en: 'In a new file, add the following code to configure the CamanJS object to use
    the pinhole filter supplied with the library; save this as `caman-advanced.js`
    within the `js` subfolder:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新文件中，添加以下代码以配置CamanJS对象以使用库提供的针孔滤镜；将其保存为`caman-advanced.js`，放在`js`子文件夹中。
- en: '[PRE15]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If we preview the demo, we can see that the image now shows a pinhole camera
    effect when the **Change filter** button is clicked. Refer to the following image:![Getting
    really creative](img/image00436.jpeg)
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们预览演示，可以看到点击**更改滤镜**按钮时，图像现在显示为针孔相机效果。参考下面的图片：![Getting really creative](img/image00436.jpeg)
- en: There are plenty of examples of more unusual filters on the CamanJS site. Head
    over to [http://camanjs.com/examples/](http://camanjs.com/examples/) to view what
    is possible using the library.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在CamanJS网站上有许多更不寻常滤镜的示例。前往[http://camanjs.com/examples/](http://camanjs.com/examples/)查看使用该库可能出现的情况。
- en: 'Although we''ve concentrated on using CamanJS as our example (partially due
    to the breadth of what is possible to do with the library), there are other libraries
    available that offer similar filter functionality, but not all to the same level
    as CamanJS. Here are some examples to explore, to get you started:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们集中在使用CamanJS作为示例（部分是因为这个库的广泛可能性），但是还有其他可用的库，提供类似的滤镜功能，但并非所有库都能达到CamanJS的水平。以下是一些可供探索的例子，让你开始：
- en: '**VintageJS**: [https://github.com/rendro/vintageJS](https://github.com/rendro/vintageJS)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VintageJS**：[https://github.com/rendro/vintageJS](https://github.com/rendro/vintageJS)'
- en: '**Hoverizr**: [https://github.com/iliasiovis/Hoverizr](https://github.com/iliasiovis/Hoverizr)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hoverizr**：[https://github.com/iliasiovis/Hoverizr](https://github.com/iliasiovis/Hoverizr)'
- en: '**PaintbrushJS**: [http://mezzoblue.github.com/PaintbrushJS](http://mezzoblue.github.com/PaintbrushJS)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PaintbrushJS**：[http://mezzoblue.github.com/PaintbrushJS](http://mezzoblue.github.com/PaintbrushJS)'
- en: '**Colorimazer**: [http://colorimazer.tacyniak.fr/](http://colorimazer.tacyniak.fr/)'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Colorimazer**：[http://colorimazer.tacyniak.fr/](http://colorimazer.tacyniak.fr/)'
- en: For those of you who prefer not to use open source, one example that you may
    like to explore is the JSManipulation library, which is available for sale from
    the CodeCanyon site at [http://codecanyon.net/item/jsmanipulate-jquery-image-manipulation-plugin/428234](http://codecanyon.net/item/jsmanipulate-jquery-image-manipulation-plugin/428234).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不喜欢使用开源软件的人，一个你可能喜欢探索的例子是JSManipulation库，这个库可以在CodeCanyon网站上以出售的方式获得，网址为：[http://codecanyon.net/item/jsmanipulate-jquery-image-manipulation-plugin/428234](http://codecanyon.net/item/jsmanipulate-jquery-image-manipulation-plugin/428234)。
- en: Right, let's move on and really get stuck into something. So far, we've used
    plugins which will serve most purposes for us. But in some instances, we may find
    that we need to create our own filters manually, as existing filters are not available
    for our needs. Let's take a look at a couple in action, to see what is involved.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们继续，并且真正投入到一些事情中去。目前为止，我们已经使用了大多数情况下适用的插件。但是在一些情况下，我们可能会发现需要手动创建自己的滤镜，因为现有的滤镜不适用于我们的需求。让我们看看一些例子，以了解涉及到的内容。
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To see what is possible when using Caman, take a look at this article by Martin
    Angelov at [http://tutorialzine.com/2013/02/instagram-filter-app/](http://tutorialzine.com/2013/02/instagram-filter-app/).
    It takes us through building an Instagram filter application, using jQuery, CamanJS,
    and the jQuery Mousewheel.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解使用Caman时可能出现的情况，请查看Martin Angelov在[http://tutorialzine.com/2013/02/instagram-filter-app/](http://tutorialzine.com/2013/02/instagram-filter-app/)的这篇文章。他通过使用jQuery，CamanJS和jQuery
    Mousewheel来构建一个Instagram滤镜应用程序。
- en: Creating simple filters manually
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动创建简单的滤镜
- en: The key to creating our own filters (and as is the case with many prebuilt plugins),
    is to use the `<canvas>` element and familiarize ourselves with the `getImageData`
    method. We can use the latter to manipulate the color channels within each image
    to produce the desired effect.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 创造我们自己的滤镜的关键（也与许多预构建的插件一样）是使用`<canvas>`元素，并熟悉`getImageData`方法。我们可以使用后者来操纵每个图像中的颜色通道，以产生所需的效果。
- en: We could spend time talking about using this method in detail, but I think it
    would be far better to see it in action. So let's dive in and use it to create
    a couple of filters manually, beginning with grayscaling an image.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以花时间详细讨论如何使用此方法，但我认为亲自尝试会更好。所以让我们深入了解并使用它手动创建一些滤镜，首先是将图像转换为灰度。
- en: Grayscaling an image
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将图像转换为灰度
- en: For the first demo of three, we're going to desaturate the colors in a copy
    of the `flowers.jpg` image that we've been using throughout this chapter. This
    will give it a grayscale appearance.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于三个演示中的第一个演示，我们将对我们在本章中一直使用的`flowers.jpg`图像的颜色进行去饱和处理。这将使其呈现出灰度外观。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may get cross-domain errors if running this demo locally. I would recommend
    running it within a local web server, as suggested in the *Getting ready* section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在本地运行此演示，您可能会遇到跨域错误。我建议按照*准备工作*部分的建议在本地 Web 服务器上运行它。
- en: 'Let''s look at what we have to do:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们需要做什么：
- en: Let's start by extracting a copy of `flowers.jpg`, `jquery.min.js`, `manual-grayscale.html,`
    and `manual-grayscale.css` from the code download that accompanies this book.
    Store the image in the `img` subfolder, the JavaScript file in the `js` subfolder,
    and the style sheet in the `css` subfolder; the HTML markup needs to be stored
    at the root of our project folder.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从附带本书代码下载中提取`flowers.jpg`的副本、`jquery.min.js`、`manual-grayscale.html`和`manual-grayscale.css`。将图像存储在`img`子文件夹中，JavaScript
    文件存储在`js`子文件夹中，样式表存储在`css`子文件夹中；HTML 标记需要存储在我们项目文件夹的根目录下。
- en: 'In a new file, go ahead and add the following code, saving it as `manual-grayscale.js`
    – this looks for each image set with a classname of picture, before calling the
    `grayscale` function to perform the magic:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新文件中，继续添加以下代码，并将其保存为`manual-grayscale.js` - 这将查找每个设置了图片类名为 picture 的图像集，然后调用`grayscale`函数执行魔术：
- en: '[PRE16]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following function immediately below the `$(window).load` method –
    this rewrites the image with a grayscale equivalent:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下函数添加到`$(window).load`方法的下方 - 这将用等效的灰度重写图像：
- en: '[PRE17]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If we run the demo at this point, we should see a copy of the image with the
    Polaroid effect border as before, but this time, it has been converted to a grayscale
    equivalent image, followed by the screenshot itself:![Grayscaling an image](img/image00437.jpeg)
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们此时运行演示，我们应该会看到一张带有极化效果边框的图像的副本，但这次，它已经被转换成了灰度等效图像，接着是截图本身：![将图像转换为灰度](img/image00437.jpeg)
- en: 'Before we continue with our next demo, there are a few key points to note,
    relating to the code we''ve just used. So let''s spare a moment to cover these
    in more detail:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进行下一个演示之前，有一些关键点需要注意，与我们刚刚使用的代码相关。所以让我们花点时间详细介绍一下这些：
- en: Most of the work we've done uses the `<canvas>` element – this allows us to
    manipulate the image at a much finer detail than if we were using a plain JPG
    or PNG format image.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们所做的大部分工作都使用了`<canvas>`元素 - 这使我们能够以比使用普通的 JPG 或 PNG 格式图像更细致的细节来操作图像。
- en: In this instance, we've created the canvas element using plain JavaScript with
    the statement `document.createElement('canvas').` Some may argue that mixing vanilla
    JavaScript with jQuery is bad practice. In this instance, I personally feel it
    provides a cleaner solution, as a context is not added automatically to `<canvas>`
    elements that are created dynamically with jQuery.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用纯 JavaScript 使用语句 `document.createElement('canvas')` 创建了 canvas 元素。有些人可能会认为将纯
    JavaScript 与 jQuery 混合使用是不好的做法。在这种情况下，我个人认为它提供了更清洁的解决方案，因为使用 jQuery 动态创建的`<canvas>`元素不会自动添加上下文。
- en: '`getImageData()` as a method is key to manipulating any image using this route.
    We can then work with each of the color channels, namely red, green, and blue,
    to produce the desired effect.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一种方法，`getImageData()`是使用此路由操作任何图像的关键。然后，我们可以处理每个颜色通道，即红色、绿色和蓝色，以产生所需的效果。
- en: We can use this process to produce any number of different filters – how about
    a sepia one, for example? Let's take a look at how we can manually create such
    a filter. In this instance, we'll go one further and turn it into a mini plugin
    for reuse at a later date.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个过程来生成任意数量的不同滤镜 - 比如说一个棕褐色调的滤镜？让我们看看我们如何手动创建这样一个滤镜。在这种情况下，我们将进一步将其转换为一个小插件，以便以后重复使用。
- en: Adding a sepia tone
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加棕褐色调
- en: We've seen how straightforward it is to produce a color filter from the ground
    up – what about creating different types of filters? We can use similar techniques
    for other filters, so let's go ahead and create a sepia-based one, to complement
    the CSS3 version we used earlier in this chapter.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了从头开始制作一个彩色滤镜是多么简单 – 那么创建不同类型的滤镜呢？我们可以使用类似的技术来制作其他滤镜，所以让我们继续创建一个基于棕褐色的滤镜，以补充本章早些时候使用的CSS3版本。
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember – if you use Chrome, please run this demo from within a local web server,
    as suggested in the *Getting ready* section.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 – 如果您使用的是Chrome，请从本地Web服务器中运行此演示，如“准备就绪”部分所建议的那样。
- en: 'Let''s make a start:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'We''ll start, as always, by extracting the relevant files from the code download
    that accompanies this book. For this one, we''ll need the following: `jquery.min.js`,
    `flowers.jpg`, `manual-sepia.css,` and `manual-sepia.html`. Store them in the
    relevant subfolders of our project folder.'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将像往常一样从随书代码下载中提取相关文件。对于这一个，我们需要以下文件：`jquery.min.js`、`flowers.jpg`、`manual-sepia.css`和`manual-sepia.html`。将它们存储在我们项目文件夹的相应子文件夹中。
- en: 'In a new file, we need to create our sepia plugin, so go ahead and add the
    following code, beginning with setting up the call to find all images with a classname
    of `.sepia`:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新文件中，我们需要创建我们的棕褐色插件，所以继续添加以下代码，从设置调用开始，以找到所有类名为`.sepia`的图像：
- en: '[PRE18]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next comes the all-important function – the `grayImage` function takes the
    image, draws it to a canvas, then manipulates each of the color channels in the
    image, before rendering it back to screen:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个非常重要的函数是`grayImage`函数，它接收图像，将其绘制到画布上，然后操纵图像中的每个颜色通道，最后将其渲染回屏幕：
- en: '[PRE19]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let's preview the results in a browser. If all is well, we should see our image
    with a nice sepia tone, as seen in the following image:![Adding a sepia tone](img/image00438.jpeg)
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在浏览器中预览结果。如果一切顺利，我们应该会看到我们的图像具有漂亮的棕褐色调，如下图所示：![添加棕褐色调](img/image00438.jpeg)
- en: This version of the filter may look slightly different in terms of the code
    we've used, but most of this is due to reconfiguring it as a plugin, along with
    some changes in variable names. If we look carefully though, we would see that
    the same principles have been used in both examples, but have produced two different
    versions of the same image.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个滤镜版本在我们使用的代码方面可能看起来略有不同，但其中大部分是由于将其重新配置为插件以及一些变量名称的更改。如果我们仔细观察，就会发现两个示例中都使用了相同的原理，但产生了两个不同版本的同一图像。
- en: Tip
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you would like to learn more about using the `getImageData()` method, then
    take a look at the W3School's tutorial, which is available at [http://www.w3schools.com/tags/canvas_getimagedata.asp](http://www.w3schools.com/tags/canvas_getimagedata.asp).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要了解更多关于使用`getImageData()`方法的信息，请查看W3School的教程，可在[http://www.w3schools.com/tags/canvas_getimagedata.asp](http://www.w3schools.com/tags/canvas_getimagedata.asp)上找到。
- en: Blending images
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像混合
- en: For our third and final demo, and to prove how versatile `getImageData()` can
    be, we're going to add a tint to the same flowers image that we've used throughout
    this chapter.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第三个和最后一个演示，并且为了证明`getImageData()`的多功能性，我们将在本章中一直使用的同一张花朵图像上添加一种色调。
- en: 'This demo is relatively straightforward to implement. We already have the framework
    in place, in the form of a plugin; all we need to do is swap out the nested `for…`
    block, and replace it with our new version. Let''s start:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示相对而言比较简单。我们已经有了一个框架，以插件的形式存在；我们只需要将嵌套的`for…`块替换为我们的新版本即可。让我们开始吧：
- en: 'In a copy of `manual-sepia.js`, look for the following line at or around line
    **17**:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`manual-sepia.js`的副本中，查找大约在第**17**行左右的以下行：
- en: '[PRE20]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Highlight and remove all the way down to line **25.** Replace it with the following
    code:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将高亮显示的内容删除直到第**25**行。用以下代码替换它：
- en: '[PRE21]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: For now, save the file as `manual-sepia.js`, then preview `manual-sepia.html`
    in a browser. If all is well, we should see the image appear, but this time with
    a red tint, as in the following image:![Blending images](img/image00439.jpeg)
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将文件保存为`manual-sepia.js`，然后在浏览器中预览`manual-sepia.html`。如果一切正常，我们应该会看到图像出现，但这次有了红色色调，如下图所示：![图像混合](img/image00439.jpeg)
- en: The math used in this demo looks straightforward, but nonetheless may need a
    little explaining. It is a two-stage process, where we use the `_weight` variables
    to first work out the brightness levels, followed by using the `_intensity` variables
    to work out the relevant intensity level, before reapplying this to the appropriate
    color channel.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示中使用的数学看起来很简单，但可能需要一点解释。这是一个两阶段过程，我们首先使用`_weight`变量来计算亮度级别，然后使用`_intensity`变量来计算相关的强度级别，然后再将其重新应用于适当的颜色通道。
- en: Getting to grips with the math required to build filters using this method can
    take time (and would be outside the scope of this book), but once you've understood
    the math, it opens up some real possibilities!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握使用这种方法构建滤镜所需的数学可能需要一些时间（这超出了本书的范围），但一旦你理解了数学，它就会带来一些真正的可能性！
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For convenience, I've reused the same files in this demo to prove that we can
    apply a specific color tint. In practice, we would need to rename the plugin name
    to better reflect the color being used (and that in this instance, wouldn't be
    sepia!).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我在这个演示中重新使用了相同的文件，以证明我们可以应用特定的颜色色调。在实践中，我们需要重新命名插件名称，以更好地反映正在使用的颜色（而且在这种情况下，不会是sepias！）。
- en: 'We can of course take things even further. To do so can require some hardcore
    math, so won''t be for the faint-hearted! If you fancy the challenge, then a good
    starting point is to learn about using **convolution masks**, which will look
    something like the following (this one being for blurring images):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还可以更进一步。这样做可能需要一些强大的数学，因此不适合胆怯的人！如果你喜欢挑战，那么一个很好的起点是学习使用**卷积掩模**，它看起来类似于以下内容（这个是用于图像模糊的）：
- en: '[PRE22]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will allow us to make some really complex filters, such as a Sobel filter
    ([http://en.wikipedia.org/wiki/Sobel_operator](http://en.wikipedia.org/wiki/Sobel_operator)),
    or even a Laplace filter ([http://en.wikipedia.org/wiki/Discrete_Laplace_operator#Implementation_in_Image_Processing](http://en.wikipedia.org/wiki/Discrete_Laplace_operator#Implementation_in_Image_Processing))
    – be warned: the math is really hardcore! To bring it back down to something a
    little easier, have a look on Google. Following are some useful starting points:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够创建一些非常复杂的滤镜，比如Sobel滤镜（[http://en.wikipedia.org/wiki/Sobel_operator](http://en.wikipedia.org/wiki/Sobel_operator)），甚至是Laplace滤镜（[http://en.wikipedia.org/wiki/Discrete_Laplace_operator#Implementation_in_Image_Processing](http://en.wikipedia.org/wiki/Discrete_Laplace_operator#Implementation_in_Image_Processing)）-
    警告：这数学真的很强大！为了将它变得简单一点，请看看Google。以下是一些有用的起点：
- en: '[http://halfpapstudios.com/blog/2013/01/canvas-convolutions/](http://halfpapstudios.com/blog/2013/01/canvas-convolutions/)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://halfpapstudios.com/blog/2013/01/canvas-convolutions/](http://halfpapstudios.com/blog/2013/01/canvas-convolutions/)'
- en: '[https://thiscouldbebetter.wordpress.com/2013/08/14/filtering-images-with-convolution-masks-in-javascript/](https://thiscouldbebetter.wordpress.com/2013/08/14/filtering-images-with-convolution-masks-in-javascript/)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://thiscouldbebetter.wordpress.com/2013/08/14/filtering-images-with-convolution-masks-in-javascript/](https://thiscouldbebetter.wordpress.com/2013/08/14/filtering-images-with-convolution-masks-in-javascript/)'
- en: '[http://beej.us/blog/data/convolution-image-processing/convolution.js](http://beej.us/blog/data/convolution-image-processing/convolution.js)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://beej.us/blog/data/convolution-image-processing/convolution.js](http://beej.us/blog/data/convolution-image-processing/convolution.js)'
- en: Let's change track! We've applied a number of filters using different means
    to our image, but has anyone noticed how abrupt the effect can be? A more pleasing
    route is to animate the transition process. Let's take a look at how we can achieve
    this, using the **cssAnimate** library.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们换个方式！我们已经使用不同的方法对我们的图像应用了一些滤镜，但有没有人注意到效果有多突然？一个更令人愉悦的路线是动画过渡过程。让我们看看如何使用**cssAnimate**库实现这一点。
- en: Animating images with filters
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用滤镜来实现图像动画
- en: Okay, so we've covered a number of different ways of applying filters to manipulate
    the appearance of images. Before we move on and take a look at some practical
    examples, let's pause for a moment.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经讨论了许多不同的方法来应用滤镜来操作图像的外观。在我们继续并查看一些实际示例之前，让我们停顿一下。
- en: Did anyone notice how when using jQuery, we lose the ability to gradually transition
    from one state to another? Transitioning is just one way of providing a nice touch
    to any change of state – after all, it is far easier on the eye to gradually change
    state, than to see an abrupt switch!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有人注意到，当使用jQuery时，我们失去了逐渐从一个状态过渡到另一个状态的能力？过渡只是提供状态变化的一种方式之一 - 毕竟，逐渐改变状态比看到突然切换更容易接受！
- en: We could spend time crafting a solution from the ground up using jQuery. However,
    a more prudent solution would be to use a plugin for this purpose.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以花时间从头开始使用 jQuery 创造一个解决方案。然而，更明智的解决方案是使用一个专门用于此目的的插件。
- en: Introducing cssAnimate
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入 cssAnimate
- en: Enter cssAnimate! This little gem by Clemens Damke generates the necessary CSS3
    styles to animate a state change, but falls back to using jQuery's `animate()`
    method handler, if support is not available. The plugin is available for download
    from [http://cortys.de/cssAnimate/](http://cortys.de/cssAnimate/). Although the
    site indicates a minimum requirement of jQuery 1.4.3 or above, it works with no
    noticeable issues when used with jQuery 2.1.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 cssAnimate！这个小宝石由 Clemens Damke 制作，它生成了必要的 CSS3 样式来动画地更改状态，但如果不支持，则退回到使用
    jQuery 的 `animate()` 方法处理程序。该插件可从 [http://cortys.de/cssAnimate/](http://cortys.de/cssAnimate/)
    下载。尽管该网站指出了 jQuery 1.4.3 或更高版本的最低要求，但在与 jQuery 2.1 一起使用时，它可以无明显问题地运行。
- en: 'Let''s take a look at a screenshot of what we''re going to produce:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下我们即将产生的截图：
- en: '![Introducing cssAnimate](img/image00440.jpeg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![引入 cssAnimate](img/image00440.jpeg)'
- en: 'Let''s start:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'We''ll begin with extracting the following files from the code download that
    accompanies this book: `cssanimate.html`, `cssanimate.css`, `flowers.jpg`, `jquery.min.js`,
    and `jquery.cssanimate.min.js`.'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从随本书附带的代码下载中提取以下文件开始：`cssanimate.html`、`cssanimate.css`、`flowers.jpg`、`jquery.min.js`
    和 `jquery.cssanimate.min.js`。
- en: Save the JavaScript files to the `js` subfolder, the image to the `img` folder,
    the CSS file to the `css` subfolder, and the HTML markup to the root folder of
    our project area.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 JavaScript 文件保存到 `js` 子文件夹中，将图像保存到 `img` 文件夹中，将 CSS 文件保存到 `css` 子文件夹中，并将 HTML
    标记保存到我们项目区域的根文件夹中。
- en: 'In a separate file, add the following code, which animates a change of `hue-rotate`
    filter:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个单独的文件中，添加以下代码，该代码将动画更改为 `hue-rotate` 滤镜：
- en: '[PRE23]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If all is well, we should see the flowers appear to turn a shade of dark pink
    when clicking on the **Change filter using CSS** button, as shown at the beginning
    of our exercise.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，当点击**使用 CSS 更改滤镜**按钮时，我们应该看到花朵似乎变成深粉色，就像我们练习开始时所示。
- en: 'At first appearance, the only change we will see is the transition to a darker
    shade of pink in our image. However, the real change will show if we inspect our
    code using a DOM Inspector, such as Firebug:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，我们唯一能看到的变化是图像变为深粉色。然而，真正的变化将在我们使用 DOM 检查器（例如 Firebug）检查代码时显示出来：
- en: '![Introducing cssAnimate](img/image00441.jpeg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![引入 cssAnimate](img/image00441.jpeg)'
- en: The beauty about this library is that despite it being a few years old, it still
    appears to work well with modern versions of jQuery. It opens up some real avenues
    that we can explore, in terms of the transition animations that we can use.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库的美妙之处在于，尽管它已经有几年了，但似乎仍然可以很好地与现代版本的 jQuery 配合使用。这为我们开辟了一些真正可以探索的途径，就我们可以使用的过渡动画而言。
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Transition support is almost 100 percent across the main browsers, save for
    Opera Mini. To get an up-to-date picture, it's worth checking the Can I Use site
    at [http://caniuse.com/#feat=css-transitions](http://caniuse.com/#feat=css-transitions).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡支持在主要浏览器中几乎达到了 100%，除了 Opera Mini。要获取最新的情况，值得查看 Can I Use 网站 [http://caniuse.com/#feat=css-transitions](http://caniuse.com/#feat=css-transitions)。
- en: Although the number of built-in animations is limited within cssAnimate, it
    does at least include support for cubic-bezier values. Matthew Lein has produced
    a file that contains a number of cubic-bezier equivalents for well-known easing
    effects; this is available from [https://github.com/matthewlein/Ceaser/blob/master/developer/ceaser-easings.js](https://github.com/matthewlein/Ceaser/blob/master/developer/ceaser-easings.js).
    We can use this to provide the values that can be dropped into our animation to
    produce the desired effect. Alternatively, we can design our own cubic-bezier
    easing effect using a site such as [http://cubic-bezier.com](http://cubic-bezier.com)
    – this provides similar values that can be used in our animation in the same way.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 cssAnimate 中内置的动画数量有限，但至少它包括对 cubic-bezier 值的支持。Matthew Lein 制作了一个文件，其中包含一些著名缓动效果的
    cubic-bezier 等效值；这可以从 [https://github.com/matthewlein/Ceaser/blob/master/developer/ceaser-easings.js](https://github.com/matthewlein/Ceaser/blob/master/developer/ceaser-easings.js)
    获取。我们可以使用这个来提供可以放入我们动画中以产生期望效果的值。或者，我们可以使用像 [http://cubic-bezier.com](http://cubic-bezier.com)
    这样的网站设计自己的 cubic-bezier 缓动效果 - 这提供了可以用于我们动画的类似值。
- en: Note
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'As an aside – I came across this neat little demo when researching for this
    book: [http://codepen.io/dudleystorey/pen/pKoqa](http://codepen.io/dudleystorey/pen/pKoqa).
    I wonder if we could use cssAnimate to produce a similar effect?'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下 - 当我为这本书进行研究时，我发现了这个简洁的演示：[http://codepen.io/dudleystorey/pen/pKoqa](http://codepen.io/dudleystorey/pen/pKoqa)。我想知道我们是否可以使用
    cssAnimate 来产生类似的效果？
- en: Okay – enough of filters for the moment! Let's change focus and dive into something
    a little more practical. How many of you have had to sign for something online,
    using an electronic signature? It's a great effect to incorporate, should the
    circumstances require it. We're going to take a look at how, but extend it further,
    so that we can save the image for later use.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 好了 - 目前足够使用滤镜了！让我们转换焦点，深入一些更实际的内容。你们有多少人曾经在线签署过某物，使用电子签名？如果情况需要，这是一个很棒的效果。我们将看看如何实现，但是扩展它，以便我们可以保存图像供以后使用。
- en: Creating a signature pad and exporting the image
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建签名板并导出图像
- en: Now that we've seen how we can manipulate images, let's turn our attention to
    something more fundamental; capturing images drawn on canvas elements.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何操作图像，让我们把注意力转向更基础的事情；捕捉绘制在画布元素上的图像。
- en: As we move more and more into a digital world, there will be occasions when
    we are asked to "sign" a document electronically, using our computer. It does
    mean that we shouldn't consider signing anything the morning after a heavy night
    out, but worse things can happen…! That in mind, let's take a look at how we can
    capture the image, once the document has been signed.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们越来越多地进入数字化世界，会有一些场合需要我们用电脑电子签署文件。这并不意味着我们不应该在狂欢一晚之后的早晨签署任何文件，但更糟糕的事情可能会发生...！考虑到这一点，让我们看看在文档签署后如何捕捉图像。
- en: For this demo, we're going to use the Signature Pad plugin for jQuery, by Thomas
    Bradley. The plugin is available from [http://thomasjbradley.ca/lab/signature-pad](http://thomasjbradley.ca/lab/signature-pad).
    We're going to take it a step further – instead of just signing our name, we will
    provide an option to save the output as a PNG file, using the `canvas.toDataURL()`
    method.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此演示，我们将使用 Thomas Bradley 的 jQuery Signature Pad 插件。该插件可从[http://thomasjbradley.ca/lab/signature-pad](http://thomasjbradley.ca/lab/signature-pad)获取。我们将进一步进行
    - 不仅仅是签署我们的名字，而且还将提供一个选项，使用`canvas.toDataURL()`方法将输出保存为 PNG 文件。
- en: Note
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember – if you use Chrome, please run this demo from within a local web server,
    as suggested in the *Getting ready* section.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 - 如果你使用 Chrome，请从本地网络服务器中运行此演示，正如 *准备就绪* 部分建议的那样。
- en: 'Let''s start:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始：
- en: We'll begin by downloading the CSS and HTML markup files that are required for
    this demo, from the code download that accompanies this book. Go ahead and extract
    the signature pad folder and save it to the project area.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从附带本书的代码下载中下载所需的 CSS 和 HTML 标记文件，开始这个演示。继续并提取签名板文件夹并将其保存到项目区域。
- en: 'Next, add the following code to a new file – save it as `signaturepad.js`,
    within the `js` subfolder of our demo folder:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将以下代码添加到一个新文件中 - 将其保存为`signaturepad.js`，放在我们演示文件夹的`js`子文件夹中：
- en: '[PRE24]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is a version of this file already in the code download; extract and rename
    `signaturepad-completed.js` to `signaturepad.js`, then store in the same `js`
    folder as outlined in this demo.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码下载中已经有这个文件的一个版本；提取并将`signaturepad-completed.js`重命名为`signaturepad.js`，然后按照本演示中所述的方法将其存储在相同的`js`文件夹中。
- en: If we preview the results in a browser, we should see a signature pad displayed,
    as shown in the following screenshot:![Creating a signature pad and exporting
    the image](img/image00442.jpeg)
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中预览结果，应该会看到一个签名板显示，如下面的屏幕截图所示：![创建签名板并导出图像](img/image00442.jpeg)
- en: 'In this screenshot, I''ve already added my name. Try clicking on **Draw It**
    and then drawing your name – beware, it takes a steady hand! Next, click on the
    link. If all is well, we will be prompted to open or save file named `signature.png`.
    Opening it up in a suitable graphics package confirms that the signature was saved
    correctly. Refer to the following image:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在此屏幕截图中，我已经添加了我的名字。尝试点击**绘制**然后画出你的名字 - 小心，需要手脚稳！接下来，点击链接。如果一切正常，我们将被提示打开或保存名为`signature.png`的文件。在适当的图形软件中打开它确认签名已正确保存。参考以下图像：
- en: '![Creating a signature pad and exporting the image](img/image00443.jpeg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![创建签名板并导出图像](img/image00443.jpeg)'
- en: 'Although this is a relatively simple demo, it opens up some real possibilities.
    Outside of the signature plugin we''ve used, the key to this demo is two-fold:
    the use of a `<canvas>` element to capture the drawn signature, and the `.toDataURL()`
    method used to convert the contents of the canvas element to a data URI, which
    contains a representation of the image in PNG format (by default).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这只是一个相对简单的演示，但它开启了一些真正的可能性。除了我们使用的签名插件之外，这个演示的关键在于两个方面：使用`<canvas>`元素来捕获绘制的签名，以及使用`.toDataURL()`方法将画布元素的内容转换为数据URI，其中包含以PNG格式表示的图像（默认情况下）。
- en: We first get a handle of, then draw out the image onto, a canvas element. As
    soon as the download event handler is fired, it converts the image to a data URI
    representation, then renders it into a format that we can save for later use.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取一个句柄，然后将图像绘制到一个canvas元素上。一旦下载事件处理程序被触发，它就会将图像转换为数据URI表示形式，然后将其呈现为我们可以保存以供以后使用的格式。
- en: Note
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you would like to learn more about the `toDataURL()` method, then Mozilla's
    Developer Labs have a good article, which is available at [https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement.toDataURL](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement.toDataURL).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于`toDataURL()`方法的信息，那么Mozilla的开发者实验室有一篇很好的文章，可以在[https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement.toDataURL](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement.toDataURL)找到。
- en: Let's put this technique to good use and combine it with using the webcam and
    the image manipulation techniques we covered at the start of this chapter. This
    allows us to get really crazy; fancy having some fun with capturing and changing
    webcam images?
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个技术应用到实践，并将其与本章开头涵盖的摄像头和图像操作技术相结合。这使我们可以变得非常疯狂；想要玩一些捕捉和更改网络摄像头图像的有趣内容吗？
- en: Capturing and manipulating webcam images
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获和操作网络摄像头图像
- en: In our second and final demo for this chapter, we're going to have some fun
    with a webcam – one of the ways we can acquire and manipulate images is to source
    them from a laptop or stand-alone webcam.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第二个也是最后一个演示中，我们将通过网络摄像头玩一些有趣的东西 - 我们可以从笔记本电脑或独立摄像头中获取和操作图像的方式之一。
- en: The key to this demo lies in the use of `getUserMedia`, which allows us to control
    audio or video feeds. This is a relatively young API, which requires use of vendor
    prefixes to ensure full support. As with other APIs, the need for them will disappear
    over time, so it is worth checking [http://caniuse.com/#search=getusermedia](http://caniuse.com/#search=getusermedia)
    regularly to see if support has been updated and the need for prefixes removed.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示的关键在于使用`getUserMedia`，它允许我们控制音频或视频源。这是一个相对年轻的API，需要使用供应商前缀来确保完全支持。与其他API一样，它们的需求会随着时间的推移而消失，因此定期检查[http://caniuse.com/#search=getusermedia](http://caniuse.com/#search=getusermedia)是值得的，以查看是否已更新支持并删除了前缀的需求。
- en: This demo will bring together some of the concepts we've explored, such as applying
    filters, saving canvas images to file, and controlling a webcam. To operate this
    demo correctly, we will need to run it from an HTTP protocol address and not `file://.`
    For this, you will either need some web space available, or to use a local webserver
    such as WAMP (for PC – [http://www.wampserver.com/en](http://www.wampserver.com/en)),
    or MAMP (for Mac, and now PC, from [http://www.mamp.info/en/](http://www.mamp.info/en/)).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示将汇集我们探讨过的一些概念，比如应用过滤器、将画布图像保存到文件以及控制网络摄像头。为了正确运行这个演示，我们将需要从HTTP协议地址而不是`file://.`运行它。为此，您将需要一些可用的网络空间，或者使用像WAMP（适用于PC
    - [http://www.wampserver.com/en](http://www.wampserver.com/en)）或MAMP（适用于Mac，现在也适用于PC，来自[http://www.mamp.info/en/](http://www.mamp.info/en/)）。
- en: 'Okay, assuming this is in place, let''s start:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，假设这一切都就绪，让我们开始吧：
- en: We'll start by extracting the `webcam demo` folder from the code download that
    accompanies this book. It contains the styling, markup, and a copy of the jQuery
    library that is needed for this demo.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从与本书附带的代码下载中提取`webcam demo`文件夹开始。它包含了为本演示所需的样式、标记和jQuery库的副本。
- en: Once extracted, upload the whole folder to your web space. I will assume you
    are using WAMPServer, so this will be the `/www` folder; if you are using something
    different, then please alter accordingly.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦提取出来，将整个文件夹上传到您的网络空间。我将假设您正在使用WAMPServer，所以这将是`/www`文件夹；如果您使用的是其他内容，请相应地进行更改。
- en: 'We need to add the jQuery magic that is needed to make this demo work. In a
    new file, go ahead and add the following code; we''ll work through it in sections,
    beginning with assigning variables and a filter array:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要添加使此演示工作所需的jQuery魔法。在一个新文件中，继续添加以下代码；我们将逐节介绍它，从分配变量和过滤器数组开始：
- en: '[PRE25]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The first function handles the paging through of the filters. We cycle through
    the filter names stored within the filter array. If there is a corresponding style
    rule within the style sheet, then the following is applied to the canvas image:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个函数处理通过过滤器的分页。我们循环遍历存储在过滤器数组中的过滤器名称。如果样式表中有相应的样式规则，则将以下内容应用于画布图像：
- en: '[PRE26]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we need to get an instance of `getUserMedia`, which we use to control
    the webcam. As this is still a relatively young API, we are obliged to use the
    vendor prefixes:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要获取`getUserMedia`的实例，我们将用它来控制网络摄像头。由于这仍然是一个相对年轻的API，我们必须使用供应商前缀：
- en: '[PRE27]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The first of several event handlers, the `#startplay` button is the most important.
    Here we capture the webcam source, then assign it to the video object and generate
    the URL that references our content. Once assigned, we start the video feed playing,
    which allows us to view the content on screen:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个事件处理程序中，`#startplay`按钮是最重要的。在这里，我们捕获网络摄像头源，然后将其分配给视频对象，并生成引用我们内容的URL。一旦分配完成，我们开始播放视频，这样我们就可以在屏幕上查看内容：
- en: '[PRE28]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We then need to assign some event handlers. In order, the following handle
    requests to take a snapshot of the image, stop the video, change the filter, and
    download a copy of the snapshot image:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要分配一些事件处理程序。按顺序，以下处理程序处理请求以拍摄图像快照，停止视频，更改过滤器，并下载快照图像的副本：
- en: '[PRE29]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Save the file as `webcam.js` within the `js` subfolder of the `webcam demo`
    folder that we uploaded earlier in this demo.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件保存为`webcam.js`，并放在我们之前在此演示中上传的`webcam demo`文件夹的`js`子文件夹中。
- en: At this point, we can try running the demo within a browser. If all is well,
    we will first get a request to allow the browser access to the webcam (for security
    reasons), as shown in the following image:![Capturing and manipulating webcam
    images](img/image00444.jpeg)
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，我们可以尝试在浏览器中运行演示。如果一切正常，我们将首先收到一个请求，询问浏览器是否可以访问网络摄像头（出于安全原因），如下图所示：![捕捉和操作网络摄像头图像](img/image00444.jpeg)
- en: This is then followed by an initialization of the camera. It starts with a placeholder
    image, as shown next; this will then display the live feed within a few moments:![Capturing
    and manipulating webcam images](img/image00445.jpeg)
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后是摄像头的初始化。它以一个占位符图像开始，如下图所示；几秒钟后，这将显示实时视频：![捕捉和操作网络摄像头图像](img/image00445.jpeg)
- en: 'As this point, we can have all sorts of fun. Try clicking on **Snap Photo**
    to take a snapshot of yourself; this will appear to the right of the live feed.
    If we click on this image, it will cycle through several filters that we''ve set
    up in the style sheet, and reference using the following line in `webcam.js`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以玩得很开心。尝试点击**拍照**以拍摄自己的照片快照；这将显示在实时视频的右侧。如果单击此图像，它将在样式表中设置的几个过滤器之间进行循环，并在`webcam.js`中引用：
- en: '[PRE30]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Hang on – did anyone notice something about the image we get when clicking on
    the **Download Photo** button? The keen-eyed amongst you will soon spot that it
    is a copy of the original image, before filters have been applied.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下 - 有人注意到单击**下载照片**按钮后得到的图像有什么不同吗？你们中敏锐的人很快就会注意到，这是原始图像的副本，在应用过滤器之前。
- en: The reason for this is that the filters are set within CSS – naturally, they
    only have any effect when displayed in the browser window! To fix this, we need
    to alter our download event handler. We can use the CamanJS library that we explored
    earlier to apply some basic filters, such as the Sunrise effect that comes with
    the library.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是这些过滤器在CSS中设置 - 当在浏览器窗口中显示时，它们才会产生任何效果！为了解决这个问题，我们需要修改我们的下载事件处理程序。我们可以使用我们之前探索过的CamanJS库来应用一些基本的过滤器，例如库中提供的日出效果。
- en: 'To do this, alter the `#download` event handler to show the following code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，请修改`#download`事件处理程序以显示以下代码：
- en: '[PRE31]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now try saving a copy of the screenshot. While it doesn't force a download to
    your desktop, it will nonetheless display an image in the browser now that shows
    the Sunrise filter applied to it.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试保存截图的副本。虽然它不会强制下载到您的桌面，但它仍然会在浏览器中显示一个图像，显示应用了日出滤镜的图像。
- en: We've only scratched the surface of what is possible when using `getUserMedia`
    – it is well worth exploring this online to learn more. A good starting point
    is the article on the Mozilla Developer Network, which is available at [https://developer.mozilla.org/en-US/docs/NavigatorUserMedia.getUserMedia](https://developer.mozilla.org/en-US/docs/NavigatorUserMedia.getUserMedia).
    Note – `getUserMedia` is not supported in IE11 or below, so you will need to use
    a polyfill library such as `getUserMedia.js` by Addy Osmani, which is available
    for download at [https://github.com/addyosmani/getUserMedia.js](https://github.com/addyosmani/getUserMedia.js).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`getUserMedia`时，我们只是触及了可能性的表面——在线学习更多是非常值得的。一个很好的起点是 Mozilla 开发者网络上的文章，可在[https://developer.mozilla.org/en-US/docs/NavigatorUserMedia.getUserMedia](https://developer.mozilla.org/en-US/docs/NavigatorUserMedia.getUserMedia)找到。注意——`getUserMedia`不支持
    IE11 或更低版本，因此您需要使用像 Addy Osmani 的`getUserMedia.js`这样的 polyfill 库，可在[https://github.com/addyosmani/getUserMedia.js](https://github.com/addyosmani/getUserMedia.js)下载。
- en: Note
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As an aside, I had considered including something on using the reveal.js library
    to control a simple image gallery using hand gestures in this book, as shown at
    [http://www.chromeexperiments.com/detail/gesture-based-revealjs/](http://www.chromeexperiments.com/detail/gesture-based-revealjs/).
    The unfortunate thing is that the code isn't rock solid, and hasn't been updated
    for some time. I'd be intrigued to hear what your thoughts are. It's a great way
    of showing off a slick means of presenting content, but needs more work!
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，我曾考虑在这本书中加入使用 reveal.js 库来控制一个简单图像画廊的手势控制内容展示，就像在[http://www.chromeexperiments.com/detail/gesture-based-revealjs/](http://www.chromeexperiments.com/detail/gesture-based-revealjs/)中展示的那样。不幸的是，代码不够稳固，而且已经有一段时间没有更新了。我很想听听你的想法。这是展示一种流畅呈现内容的好方法，但需要更多的工作！
- en: Finishing up
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收尾工作
- en: Before we round up this chapter, it's worth pausing for a moment to consider
    the implications of some of the techniques that we've covered in this chapter.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结这一章之前，值得暂停一下，考虑一下我们在本章中涵盖的一些技术带来的影响。
- en: The purists may question the need to use jQuery to apply filters, particularly
    if all we need to do is to use a method such as `.addClass()` or even `.toggleClass()`
    to apply or remove a specific filter. The flip side of this is that this book
    is of course about jQuery, and that this is what we should concentrate on using,
    even at the cost of the apparent delay in showing some of the filter effects we've
    used.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 纯粹主义者可能会质疑使用 jQuery 应用过滤器的必要性，特别是如果我们所需要做的只是使用诸如`.addClass()`或者甚至`.toggleClass()`这样的方法来应用或移除特定的过滤器。另一方面，这本书当然是关于
    jQuery 的，我们应该集中精力使用它，即使这意味着显示我们使用的一些过滤效果的明显延迟。
- en: The short answer to this will depend on you – anyone can write jQuery code to
    a greater or lesser extent, but the difference between an average and a good developer
    is not just in writing code.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的简短答案取决于你——任何人都可以在某种程度上编写 jQuery 代码，但一般和优秀开发者的区别不仅仅在于编写代码。
- en: The real difference lies partially in making the right choices. jQuery is frequently
    seen as the easy option, particularly as it provides the widest range of support.
    We can create any kind of filter to fit our needs, but it is always at the expense
    of processing power – we cannot get away from the fact that manipulating the canvas
    element takes a lot of resources, so is slow to complete. This is no better if
    high definition images are used (as we noted back in the *Applying filters with
    CamanJS* section) – indeed, it's even slower, given that more pixels need to be
    processed!
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的区别部分在于做出正确选择。jQuery 经常被视为简单的选择，特别是因为它提供了最广泛的支持范围。我们可以创建任何类型的过滤器来满足我们的需求，但这总是以处理能力为代价——我们无法摆脱操作画布元素需要大量资源的事实，因此完成速度很慢。如果使用高清图像（正如我们在*使用
    CamanJS 应用过滤器*部分中注意到的那样）——事实上，速度会更慢，因为需要处理更多像素！
- en: The upshot of this is that we need to carefully consider what filters we need
    to apply, and whether we can simply use CSS3 filters to fulfill our needs. It
    is true that these may not provide a solution for all our needs, but support is
    changing. We should really consider using jQuery filters where the delay isn't
    an issue, and the application won't be used on a mobile platform (due to the resources
    required to process each pixel!).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是，我们需要仔细考虑我们需要应用哪些过滤器，以及我们是否可以简单地使用 CSS3 过滤器来满足我们的需求。没错，这些可能无法解决我们所有的需求，但是支持正在变化。我们应该真正考虑在延迟不是问题的情况下使用
    jQuery 过滤器，并且应用程序不会在移动平台上使用（由于处理每个像素所需的资源！）。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Manipulating images is one of the paradoxes within jQuery– we can use CSS3 filters
    to produce concise effects with little effort, but be limited to what CSS3 filters
    can offer; or we can produce any filter we desire, but at the expense of the processing
    resources required to manipulate images at a pixel level! In this chapter, we've
    covered a lot of information, so let's take a moment to recap what we've learnt.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 操纵图像是 jQuery 中的一个悖论——我们可以使用 CSS3 滤镜轻松产生简洁的效果，但受到 CSS3 滤镜能够提供的限制；或者我们可以产生任何我们想要的滤镜，但以像素级别操作图像所需的处理资源为代价！在本章中，我们涵盖了大量信息，让我们花一点时间回顾我们学到的东西。
- en: We kicked off with a look at adding filters using CSS3, and saw how easy it
    is to apply these to an image. We then moved onto examining a different technique
    of blending images using CSS3, before turning our attention to examining jQuery
    image plugins.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以添加 CSS3 滤镜开始，看到了将这些应用到图像上是多么容易。然后，我们转而研究了使用 CSS3 混合图像的不同技术，然后将注意力转向了检查 jQuery
    图像插件。
- en: We spent a little time exploring some of the basic options to apply filters,
    and then created our own jQuery based filters. We then switched to looking at
    how we can animate the transition into using a filter, to help provide a smoother
    crossover, before finishing with a look at creating basic demos using a signature
    pad and a webcam, as a means of capturing images using jQuery.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花了一些时间探索一些应用滤镜的基本选项，然后创建了我们自己的基于 jQuery 的滤镜。然后我们转而研究如何通过动画过渡到使用滤镜，以帮助提供更流畅的过渡，最后看一下使用签名板和网络摄像头创建基本演示的方法，作为使用
    jQuery 捕获图像的手段。
- en: We then rounded up the chapter with some final thoughts on when we should be
    using CSS3 filters or jQuery, as a means of emphasizing that anyone can write
    code, but that good developers know which tool to use at the right time in their
    development process.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们总结了本章关于何时应该使用 CSS3 滤镜或 jQuery 的一些最终想法，强调任何人都可以编写代码，但好的开发人员知道在开发过程中何时使用正确的工具。
- en: In the next chapter, we're going to expand on the use of plugins, with a look
    at taking our plugin development skills to the next level.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将扩展插件的使用，并探讨将插件开发技能提升到下一个水平。
