- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Working with REST and GraphQL APIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与REST和GraphQL API一起工作
- en: In *Chapter 1*, *Angular’s Architecture and Concepts*, I introduced you to the
    wider architecture in which web applications exist, and in *Chapter 3*, *Architecting
    an Enterprise App*, we discussed various performance bottlenecks that can impact
    the success of your app. However, your web app can only perform as well as your
    full-stack architecture performs. If you’re working with an inadequate API design
    or a slow database, you will spend your time implementing band-aid solutions instead
    of addressing the root cause of the issues. The moment we move away from the minimalist
    mindset and start patching holes, we are on our way to constructing a fragile
    tower that is at risk of collapsing or very expensive to maintain. In short, the
    choices made in full-stack architecture can profoundly impact the success of your
    web application. You and your team simply cannot afford to be ignorant of how
    APIs are designed. Often, the correct way to implement a new feature or fix a
    performance issue is by redesigning an API endpoint. The **MEAN** stack, using
    **MongoDB**, **Express**, **Angular**, and **Node.js**, is a popular set of technologies
    aligned around similar technologies that should ease adoption by web developers.
    My take on the MEAN stack is minimal MEAN, which prioritizes ease of use, well-being,
    and effectiveness, the main ingredients for a great **DevEx**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第一章*，*Angular的架构和概念*中，我向您介绍了网络应用存在的更广泛的架构，而在*第三章*，*构建企业应用*中，我们讨论了可能影响您应用成功的一系列性能瓶颈。然而，您的网络应用的表现只能与您的全栈架构的表现相匹配。如果您正在使用不充分的API设计或缓慢的数据库，您将花费时间实施临时解决方案，而不是解决问题的根本原因。当我们摆脱最小化思维并开始修补漏洞时，我们就在构建一个可能崩溃或维护成本极高的脆弱塔楼的道路上。简而言之，全栈架构中做出的选择可以深刻影响网络应用的成功。您和您的团队根本无法忽视API的设计方式。通常，实现新功能或修复性能问题的正确方法是通过重新设计API端点。使用**MongoDB**、**Express**、**Angular**和**Node.js**的**MEAN**栈是一套围绕类似技术构建的流行技术集合，这些技术应该有助于网络开发者的采用。我对MEAN栈的看法是“最小化MEAN”，它优先考虑易用性、健康和有效性，这些都是构建出色的**DevEx**的主要成分。
- en: In the past two chapters, we designed and implemented a **Role-Based Access
    Control** (**RBAC**) mechanism for our app. In *Chapter 5*, *Designing Authentication
    and Authorization*, we dove into security considerations, covered how JWT authentication
    works, learned how to safely handle data with TypeScript, and tapped into **Object
    Oriented Programming** (**OOP**) design with inheritance and abstraction to build
    an extendable auth service. In *Chapter 6*, *Implementing Role-Based Navigation*,
    we designed a conditional navigation experience using our auth service and implemented
    auth providers for custom APIs and Google Firebase.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去两章中，我们为我们的应用设计并实现了一个**基于角色的访问控制**（**RBAC**）机制。在*第五章*，*设计身份验证和授权*中，我们深入探讨了安全考虑因素，介绍了JWT身份验证的工作原理，学习了如何使用TypeScript安全地处理数据，并利用面向对象编程（**OOP**）的设计，通过继承和抽象来构建一个可扩展的认证服务。在*第六章*，*实现基于角色的导航*中，我们使用我们的认证服务设计了一个条件导航体验，并实现了针对自定义API和Google
    Firebase的认证提供者。
- en: In this chapter, I’ll introduce you to the LemonMart server, which implements
    JWT auth, REST, and GraphQL APIs. We will use these APIs to implement two custom
    auth providers in Angular. This will allow you to make authenticated calls to
    support recipes I will cover in *Chapter 8*, *Recipes – Reusability, Forms, and
    Caching, and Caching*, and *Chapter 9*, *Recipes – Master/Detail, Data Tables,
    and NgRx*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将向您介绍LemonMart服务器，该服务器实现了JWT身份验证、REST和GraphQL API。我们将使用这些API在Angular中实现两个自定义认证提供者。这将允许您对*第八章*，*食谱
    – 可重用性、表单和缓存*和*第九章*，*食谱 – 主/详细、数据表和NgRx*中将要介绍的食谱进行身份验证调用。
- en: This chapter covers a lot of ground. It is designed to serve as a roadmap to
    the GitHub repository ([https://github.com/duluca/lemon-mart-server](https://github.com/duluca/lemon-mart-server)).
    I cover the architecture, design, and major components of the implementation.
    I highlight important pieces of code to explain how the solution comes together
    but avoid going into implementation details. It is more important that you understand
    why we are implementing various components rather than having a strong grasp of
    the implementation details. For this chapter, I recommend that you read and understand
    the server code versus trying to recreate it on your own.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了大量的内容。它旨在作为GitHub仓库的路线图。[GitHub仓库](https://github.com/duluca/lemon-mart-server)。我涵盖了架构、设计和实现的主要组件。我强调了一些重要的代码片段来解释解决方案是如何组合在一起的，但避免深入到实现细节。更重要的是，你需要理解我们为什么要实现各种组件，而不是对实现细节有深刻的掌握。对于本章，我建议你阅读并理解服务器代码，而不是试图自己重新创建它。
- en: We begin by covering full-stack architecture, the LemonMart server’s monorepo
    design, and how to use Docker Compose to run a three-tier application with a web
    app, server, and database. Then, we will review REST and GraphQL API design, implementation,
    and documentation. For REST, we will leverage the **OpenAPI** specification with
    **SwaggerUI**. For GraphQL, we will leverage **GraphQL schemas** with **Apollo
    Studio**. Both APIs will be implemented using Express.js and TypeScript. Then,
    we will cover the implementation of a MongoDB **Object Document Mapper** (**ODM**)
    using the DocumentTS library to store users with login credentials. Finally, we
    will implement a token-based auth function to secure our APIs and the corresponding
    auth providers in Angular.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍全栈架构、LemonMart服务器的monorepo设计以及如何使用Docker Compose运行具有Web应用、服务器和数据库的三层应用程序。然后，我们将回顾REST和GraphQL
    API的设计、实现和文档。对于REST，我们将利用**OpenAPI**规范和**SwaggerUI**。对于GraphQL，我们将利用**GraphQL
    schemas**和**Apollo Studio**。这两个API都将使用Express.js和TypeScript实现。然后，我们将介绍使用DocumentTS库实现MongoDB的**对象文档映射器（ODM**）以存储具有登录凭证的用户。最后，我们将实现基于令牌的身份验证功能来保护我们的API和Angular中的相应身份验证提供者。
- en: 'In this chapter, you will learn about the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Full-stack architecture
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全栈架构
- en: Working with monorepos
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与monorepos一起工作
- en: Designing APIs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计API
- en: Implementing APIs with Express.js
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Express.js实现API
- en: A MongoDB ODM with DocumentTS
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DocumentTS的MongoDB ODM
- en: Implementing JWT auth
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现JWT身份验证
- en: A custom server auth provider
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义服务器身份验证提供者
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The most up-to-date versions of the sample code for the book can be found on
    GitHub at the following linked repository. The repository contains the final and
    completed state of the code. This chapter requires the Docker Desktop and Postman
    applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍示例代码的最新版本可以在GitHub上的以下链接仓库中找到。[链接仓库](https://github.com/duluca/lemon-mart-server)。该仓库包含代码的最终和完成状态。本章需要Docker
    Desktop和Postman应用程序。
- en: It is critical that you get **lemon-mart-server** up and running on your development
    environment and have **lemon-mart** communicate with it. Refer to the instructions
    documented here or in the `README` on GitHub to get your server up and running.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你在开发环境中启动**lemon-mart-server**并且**lemon-mart**能够与之通信至关重要。请参考此处或GitHub上的`README`中的说明来启动你的服务器。
- en: 'For server-side implementation in *Chapter 7*:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第7章的服务端实现：
- en: 'Clone the `lemon-mart-server` repository using the `--recurse-submodules` option:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`--recurse-submodules`选项克隆`lemon-mart-server`仓库：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the VS Code terminal, execute `cd web-app; git checkout master` to ensure
    the submodule from [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
    is on the master branch.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在VS Code终端中，执行`cd web-app; git checkout master`以确保从[https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)克隆的子模块位于master分支。
- en: Later, in the *Git submodules* section, you can configure the `web-app` folder
    to pull from your `lemon-mart` server.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在后面的*Git子模块*部分，你可以配置`web-app`文件夹以从你的`lemon-mart`服务器拉取。
- en: Execute `npm install` in the `root` folder to install dependencies.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`root`文件夹中执行`npm install`以安装依赖项。
- en: Note that running the `npm install` command in the root folder triggers a script,
    which also installs dependencies under the `server` and `web-app` folders.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在根目录中运行`npm install`命令会触发一个脚本，该脚本还会在`server`和`web-app`文件夹下安装依赖项。
- en: Execute `npm run init:env` in the root folder to configure environment variables
    in `.env` files.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在根目录中执行`npm run init:env`以配置`.env`文件中的环境变量。
- en: This command will create two `.env` files, one in the root folder and the other
    under the `server` folder, to contain your private configuration information.
    The initial files are generated based on the `example.env` file. You can modify
    these files later and set your own secure secrets.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将在根目录和 `server` 文件夹下创建两个 `.env` 文件，以包含您的私有配置信息。初始文件基于 `example.env` 文件生成。您可以在以后修改这些文件并设置自己的安全密钥。
- en: Execute `npm run build` in the root folder, which builds the server and the
    web app.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在根目录中执行 `npm run build` 以构建服务器和网页应用。
- en: Note that the web app is built using a new configuration named `--configuration=lemon-mart-server`,
    which uses `src/environments/environment.lemon-mart-server.ts`.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，网页应用使用名为 `--configuration=lemon-mart-server` 的新配置构建，该配置使用 `src/environments/environment.lemon-mart-server.ts`。
- en: Execute `docker compose up --build` to run containerized versions of the server,
    web app, and a MongoDB database.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 `docker compose up --build` 以运行服务器、网页应用和MongoDB数据库的容器化版本。
- en: Note that the web app is containerized using a new file named `nginx.Dockerfile`.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，网页应用使用名为 `nginx.Dockerfile` 的新文件进行容器化。
- en: Navigate to `http://localhost:8080` to view the web app.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到 `http://localhost:8080` 查看网页应用。
- en: To log in, click the **Fill** button to populate the email and password fields
    with the default demo credentials.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要登录，单击**填写**按钮以使用默认的演示凭据填写电子邮件和密码字段。
- en: Navigate to `http://localhost:3000` to view the server landing page:![A screenshot
    of a phone  Description automatically generated](img/B20960_07_01.png)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到 `http://localhost:3000` 查看服务器着陆页面：![手机截图  自动生成的描述](img/B20960_07_01.png)
- en: 'Figure 7.1: LemonMart Server landing page'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.1：LemonMart服务器着陆页面
- en: Navigate to `http://localhost:3000/api-docs` to view interactive API documentation.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到 `http://localhost:3000/api-docs` 查看交互式API文档。
- en: You can use `npm run start:database` to only start the database, and `npm start`
    on the `server` folder for debugging.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `npm run start:database` 仅启动数据库，并在 `server` 文件夹中使用 `npm start` 进行调试。
- en: You can use `npm run start:backend` to only start the database and the server,
    and `npm start` on the `web-app` folder for debugging.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `npm run start:backend` 仅启动数据库和服务器，并在 `web-app` 文件夹中使用 `npm start` 进行调试。
- en: 'For client-side implementations in *Chapter 7*:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第7章中的客户端实现：
- en: 'Clone the repository: [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克隆仓库：[https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)。
- en: Execute `npm install` in the root folder to install dependencies.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在根目录中执行 `npm install` 以安装依赖项。
- en: 'The beginning state of the project is reflected at:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目的初始状态反映在：
- en: '[PRE1]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The end state of the project is reflected at:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目的最终状态反映在：
- en: '[PRE2]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the stage name to any `ng` command to act only on that stage:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将阶段名称添加到任何 `ng` 命令中，以仅对该阶段执行操作：
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the `dist/stage10` folder at the root of the repository will contain
    the compiled result.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，仓库根目录下的 `dist/stage10` 文件夹将包含编译结果。
- en: Beware that the source code provided in the book and the version on GitHub are
    likely to be different. The ecosystem around these projects is ever-evolving.
    Between changes in how Angular CLI generates new code, bug fixes, new versions
    of libraries, and side-by-side implementations of multiple techniques, there are
    a lot of variations that are impossible to account for. If you find errors or
    have questions, please create an issue or submit a pull request on GitHub.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，书中提供的源代码和GitHub上的版本可能不同。这些项目周围的生态系统不断演变。由于Angular CLI生成新代码的方式、错误修复、库的新版本以及多种技术的并行实现，存在许多难以计数的变体。如果您发现错误或有疑问，请在GitHub上创建问题或提交拉取请求。
- en: With your LemonMart server up and running, we are ready to explore the architecture
    of the MEAN stack. By the end of this section, you should have your own version
    of LemonMart communicating with the server.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的LemonMart服务器启动并运行时，我们准备探索MEAN栈的架构。到本节结束时，您应该有自己的LemonMart版本与服务器通信。
- en: Full-stack architecture
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全栈架构
- en: '**Full-stack** refers to the entire stack of software that makes an application
    work, from databases to servers, APIs, and the web and/or mobile apps that leverage
    them. The mythical full-stack developer is all-knowing and can comfortably operate
    in all verticals of the profession. It is next to impossible to specialize in
    all things *software-related* and to be considered an expert in every given topic.
    However, to be considered an expert in a single topic, you must also be well-versed
    in related topics. When learning about a new topic, it is very helpful to keep
    your tooling and language consistent to absorb new information without additional
    noise.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**全栈**指的是使应用程序工作的整个软件堆栈，从数据库到服务器、API以及利用它们的Web和/或移动应用程序。传说中的全栈开发者无所不知，可以轻松地在职业的各个垂直领域操作。在所有与软件相关的事物上专长并被认为是每个给定主题的专家几乎是不可能的。然而，要被认为是某个主题的专家，你也必须对相关主题有深入的了解。在了解一个新主题时，保持你的工具和语言一致非常有帮助，这样你就可以在没有额外噪音的情况下吸收新信息。'
- en: For these reasons, I opted to introduce you to the MEAN stack, rather than Spring
    Boot using Java or ASP.NET using C#. By sticking to familiar tools and languages
    such as TypeScript, VS Code, npm, GitHub, Jasmine/Jest, Docker, and CircleCI,
    you can better understand how a full-stack implementation comes together and become
    a better web developer.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我选择向你介绍MEAN堆栈，而不是使用Java的Spring Boot或使用C#的ASP.NET。通过坚持熟悉的工具和语言，如TypeScript、VS
    Code、npm、GitHub、Jasmine/Jest、Docker和CircleCI，你可以更好地理解全栈实现是如何结合在一起的，并成为一个更好的Web开发者。
- en: Minimal MEAN
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小化MEAN
- en: 'Choosing the **ideal stack** for your project is difficult. First and foremost,
    your technical architecture should be adequate to meet business needs. For example,
    if you’re trying to deliver an artificial intelligence project with Node.js, you’re
    likely using the wrong stack. Our focus will be on delivering web applications,
    but beyond that, we have other parameters to consider, including the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的项目选择**理想的堆栈**是困难的。首先，你的技术架构应该足够满足业务需求。例如，如果你试图使用Node.js交付一个人工智能项目，你很可能会使用错误的堆栈。我们的重点将是交付Web应用程序，但除此之外，我们还有其他参数需要考虑，包括以下内容：
- en: Ease of use
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易用性
- en: Happiness
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幸福
- en: Effectiveness
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效率
- en: If your development team will be working on your application for an extended
    period, it is very important to consider factors beyond compatibility. Your stack,
    choice of tool, and coding style can have a significant impact if your codebase
    is easy to use, keeps your developers happy, or makes them feel like effective
    contributors to the project.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的开发团队将长期从事你的应用程序开发，考虑兼容性以外的因素非常重要。如果你的代码库易于使用，让你的开发者保持愉快，或者让他们觉得自己是项目的有效贡献者，你的堆栈、工具选择和编码风格可以产生重大影响。
- en: A well-configured stack is key for a great DevEx. This can be the difference
    between a towering stack of dried-out pancakes or a delicious short stack, with
    the right amount of butter and syrup.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好配置的堆栈对于优秀的DevEx至关重要。这可能是干燥的煎饼堆和美味的小份煎饼之间的区别，适量的黄油和糖浆。
- en: By introducing too many libraries and dependencies, you can slow down your progress,
    make your code difficult to maintain, and find yourself in a feedback loop of
    introducing more libraries to resolve the issues of other libraries. The only
    way to win this game is to simply not play it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入过多的库和依赖项，你可以减慢你的进度，使你的代码难以维护，并发现自己陷入引入更多库以解决其他库问题的反馈循环。赢得这场游戏的唯一方法就是简单地不参与。
- en: 'If you take your time to learn how to work with a few fundamental libraries,
    you can become a far more effective developer. In essence, you can do more with
    less. My advice would be to:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你花时间学习如何使用几个基本的库，你可以成为一个更有效的开发者。本质上，你可以用更少的资源做更多的事情。我的建议是：
- en: '**Think** before you write a single line of code and apply the 80-20 rule.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写任何一行代码之前**思考**，并应用80-20规则。
- en: '**Wait** for libraries and tools to mature, skipping the betas.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**等待**库和工具成熟，跳过测试版。'
- en: '**Fast** by reducing your gluttony for new packages and tools, mastering the
    fundamentals instead.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速**通过减少对新包和工具的贪婪，掌握基础知识。'
- en: Watch my 2017 Ng conference talk entitled *Do More with Less JavaScript* on
    YouTube at [https://www.youtube.com/watch?v=Sd1aM8181kc](https://www.youtube.com/watch?v=Sd1aM8181kc).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在YouTube上观看我2017年Ng会议的演讲，标题为*用更少的JavaScript做更多的事情*，链接为[https://www.youtube.com/watch?v=Sd1aM8181kc](https://www.youtube.com/watch?v=Sd1aM8181kc)。
- en: 'This minimalist mindset is the design philosophy behind minimal MEAN. You can
    review a reference implementation on GitHub at [https://github.com/duluca/minimal-mean](https://github.com/duluca/minimal-mean).
    Refer to the following diagram for the overall architecture:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这种极简主义思维是最小化MEAN的设计哲学。您可以在GitHub上查看参考实现：[https://github.com/duluca/minimal-mean](https://github.com/duluca/minimal-mean)。请参考以下图表以了解整体架构：
- en: '![](img/B20960_07_02.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B20960_07_02.png)'
- en: 'Figure 7.2: Minimal MEAN software stack and tooling'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：最小化MEAN软件栈和工具
- en: 'Let’s go over the components of the architecture:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下架构的组件：
- en: '**Angular**: You know this one. Angular is the presentation layer. The output
    of an Angular build is a set of static files that can be hosted using the minimal
    Docker container, `duluca/minimal-nginx-web-server,` or `duluca/minimal-node-web-server`.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular**: 您应该知道这个。Angular是表示层。Angular构建的输出是一组静态文件，可以使用最小化的Docker容器`duluca/minimal-nginx-web-server`或`duluca/minimal-node-web-server`托管。'
- en: '**Express.js**: This is our API layer. Express is a fast, unopinionated, and
    minimalist web framework for Node.js. Express has a vast plugin ecosystem that
    is almost guaranteed to meet every need. NestJS is built on Express and is a good
    alternative for well-established teams. In minimal MEAN, we leverage a few Express
    middleware:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Express.js**: 这是我们的API层。Express是一个快速、无偏见、极简的Node.js网络框架。Express拥有庞大的插件生态系统，几乎可以满足每一个需求。NestJS建立在Express之上，是成熟团队的不错替代品。在最小化MEAN中，我们利用了一些Express中间件：'
- en: '`cors`: configures cross-origin resource-sharing settings'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cors`: 配置跨源资源共享设置'
- en: '`compression`: zips packets sent across the wire to lower bandwidth use'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compression`: 压缩通过网络发送的数据包以降低带宽使用'
- en: '`morgan`: logs HTTP requests'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`morgan`: 记录HTTP请求'
- en: '`express.static:` function to serve the content of the `public` folder'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`express.static:` 用于提供`public`文件夹内容的函数'
- en: '`graphql:` to host GraphQL endpoint'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`graphql:` 用于托管GraphQL端点'
- en: You can read more about Express.js at [https://expressjs.com/](https://expressjs.com/)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://expressjs.com/](https://expressjs.com/)了解更多关于Express.js的信息
- en: '**Node.js**: This is the server runtime; Express runs on Node so that the business
    layer will be implemented in Node. Node is a lightweight and efficient JavaScript
    runtime that uses an event-driven, non-blocking I/O model that suits high-performance
    and real-time applications. You can increase the reliability of your Node applications
    by using TypeScript to develop your application.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js**: 这是服务器运行时；Express在Node上运行，因此业务层将在Node上实现。Node是一个轻量级且高效的JavaScript运行时，它使用事件驱动的、非阻塞的I/O模型，适用于高性能和实时应用。您可以通过使用TypeScript开发应用程序来提高Node应用程序的可靠性。'
- en: Node runs everywhere, from fridges to smartwatches. Refer to the blog post by
    Frank Rosner on non-blocking I/O for a more in-depth explanation of the topic
    at [https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/](https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/).
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Node可以在任何地方运行，从冰箱到智能手表。请参阅Frank Rosner的博客文章，深入了解非阻塞I/O主题：[https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/](https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/)。
- en: '**MongoDB**: This is the persistence layer. MongoDB is a document-oriented
    database with dynamic JSON-like schemas. Read more about MongoDB at [https://www.mongodb.com/](https://www.mongodb.com/).'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MongoDB**: 这是持久化层。MongoDB是一个具有动态JSON类似模式的文档型数据库。有关MongoDB的更多信息，请参阅[https://www.mongodb.com/](https://www.mongodb.com/)。'
- en: The MEAN stack is preferred because it leverages the major benefit of using
    a JSON-based database, which means that you don’t need to transform your data
    from one format to another, as it crosses the layers of your stack – a major pain
    point when dealing with .NET, Java, and SQL servers. You can retrieve, display,
    edit, and update the data using only JSON. In addition, the MongoDB native driver
    for Node is mature, performant, and capable. I have developed a library called
    `document-ts`, which aims to simplify interacting with MongoDB by introducing
    rich document objects that are easy to code. DocumentTS is a very thin TypeScript-based
    MongoDB helper with optional, rich ODM convenience features. Read more about DocumentTS
    at [https://github.com/duluca/document-ts](https://github.com/duluca/document-ts).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: MEAN堆栈更受欢迎，因为它利用了使用基于JSON的数据库的主要好处，这意味着你不需要将数据从一种格式转换到另一种格式，因为它跨越了你的堆栈层——在处理.NET、Java和SQL服务器时这是一个主要痛点。你可以仅使用JSON来检索、显示、编辑和更新数据。此外，Node的MongoDB原生驱动程序成熟、性能良好且功能强大。我开发了一个名为`document-ts`的库，旨在通过引入易于编码的丰富文档对象来简化与MongoDB的交互。DocumentTS是一个非常薄的基于TypeScript的MongoDB助手，具有可选的丰富ODM便利功能。更多关于DocumentTS的信息请参阅[https://github.com/duluca/document-ts](https://github.com/duluca/document-ts)。
- en: Minimal MEAN leverages most of the same tooling and languages we use for Angular
    development. This enables developers to switch between frontend and backend development
    with minimal context switching.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Minimal MEAN利用了我们用于Angular开发的相同工具和语言，这使得开发者可以在前端和后端开发之间进行最小化的上下文切换。
- en: NestJS
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NestJS
- en: Minimal MEAN intentionally sticks to the basics, so you can learn more about
    the underlying technologies. While I have delivered production systems using minimal
    MEAN for larger teams with varying skill levels, this barebones development experience
    may not be appropriate. In this case, you may consider NestJS, a popular framework
    for implementing full-stack Node.js apps. NestJS has a rich feature set with an
    architecture and coding style resembling Angular.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Minimal MEAN有意坚持基本原理，这样你可以更多地了解底层技术。虽然我使用Minimal MEAN为具有不同技能水平的大型团队交付了生产系统，但这种基础的开发体验可能并不合适。在这种情况下，你可能考虑NestJS，这是一个用于实现全栈Node.js应用的流行框架。NestJS具有丰富的功能集，其架构和编码风格类似于Angular。
- en: 'Feeling adventurous? Create a NestJS app by executing:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 想要冒险吗？通过执行以下命令创建一个NestJS应用：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Nest is built on Express and provides syntactic sugar and concepts to build
    a scalable backend solution. The framework heavily borrows ideas from Angular
    to implement dependency injection, guards, interceptors, pipes, modules, and providers.
    The built-in resource generator can scaffold entity classes, **CRUD** (**Create**,
    **Retrieve**, **Update**, **Delete**) controllers, **Data Transfer Objects** (**DTOs**),
    and services.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Nest建立在Express之上，并提供了构建可扩展后端解决方案的语法糖和概念。该框架大量借鉴了Angular的思想来实现依赖注入、守卫、拦截器、管道、模块和提供者。内置的资源生成器可以生成实体类、**CRUD**（**创建**、**检索**、**更新**、**删除**）控制器、**数据传输对象**（**DTOs**）和服务。
- en: 'For example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When creating a resource, you can choose between creating a REST, GraphQL,
    microservice, or WebSocket endpoint:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建资源时，你可以选择创建REST、GraphQL、微服务或WebSocket端点：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Nest supports OpenAPI for REST documentation, and GraphQL also supports schema-first
    and code-first development for GraphQL. For a library with so many features, Nest’s
    explicit Microservice support is welcome, where a fast boot-up time and small
    framework size are critical for operations. All these features are supported by
    detailed documentation at [https://docs.nestjs.com/](https://docs.nestjs.com/).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Nest支持OpenAPI用于REST文档，GraphQL也支持GraphQL的schema-first和code-first开发。对于具有如此多功能的库，Nest的显式微服务支持是受欢迎的，快速启动时间和小框架大小对于操作至关重要。所有这些功能都由详细的文档在[https://docs.nestjs.com/](https://docs.nestjs.com/)中支持。
- en: Kudos to Kamil Mysliwiec and Mark Pieszak for creating a great tool and fostering
    a vibrant community around NestJS. Should you ever need it, you can solicit consulting
    services at [https://trilon.io/](https://trilon.io/).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 向Kamil Mysliwiec和Mark Pieszak致敬，他们创建了一个伟大的工具，并在NestJS周围培养了一个充满活力的社区。如果你需要，可以在[https://trilon.io/](https://trilon.io/)寻求咨询服务。
- en: If you visit the documentation site, you may be overwhelmed with the many options
    on offer. This is why I recommend using a feature-rich library like this after
    you have mastered the basics with minimal MEAN.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问文档网站，可能会被提供的众多选项所淹没。这就是为什么我在你用最少的MEAN掌握了基础知识之后，推荐使用功能丰富的库的原因。
- en: You can read more about NestJS at [https://nestjs.com/](https://nestjs.com/).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://nestjs.com/](https://nestjs.com/)了解更多关于NestJS的信息。
- en: Next, let’s learn about monorepos, their benefits, and their downsides. I will
    share how you can combine Nx, Nest, and Angular in a monorepo, and then cover
    how LemonMart server uses Git submodules to create a monorepo.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们了解monorepo、它们的优点和缺点。我将分享如何在monorepo中结合Nx、Nest和Angular，然后介绍LemonMart服务器如何使用Git子模块创建monorepo。
- en: Working with monorepos
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在VS Code中使用多根工作区
- en: A **monorepo** (**monolithic repository**) is a software development strategy
    to host code from multiple projects in a single repository. This allows for unified
    versioning, simplified dependency management, and easier code sharing across projects.
    In a monorepo, developers can jump between projects within the same IDE window
    and reference code more easily across projects, such as sharing TypeScript interfaces
    between the frontend and the backend, ensuring that data objects line up every
    time.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**monorepo**（**单体仓库**）是一种软件开发策略，用于在单个仓库中托管多个项目的代码。这允许统一版本控制、简化依赖关系管理，以及更容易地在项目之间共享代码。在monorepo中，开发者可以在同一个IDE窗口中跳转项目，并更容易地在项目之间引用代码，例如在前端和后端之间共享TypeScript接口，确保数据对象每次都保持一致。'
- en: You can enable access to multiple projects in the same IDE window using multi-root
    workspaces in VS Code, where you can add multiple projects to display in the *Explorer*
    window. However, a monorepo combines projects at the source control level, allowing
    us to build them together on our CI server. Read more about multi-root workspaces
    at [https://code.visualstudio.com/docs/editor/multi-root-workspaces](https://code.visualstudio.com/docs/editor/multi-root-workspaces).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用VS Code中的多根工作区在同一个IDE窗口中启用对多个项目的访问，你可以在*资源管理器*窗口中添加多个项目进行显示。然而，monorepo在源代码控制级别将项目组合在一起，允许我们在CI服务器上一起构建它们。有关多根工作区的更多信息，请参阅[https://code.visualstudio.com/docs/editor/multi-root-workspaces](https://code.visualstudio.com/docs/editor/multi-root-workspaces)。
- en: Having access to code from multiple projects makes it possible to commit atomic
    changes, meaning changes made across projects can be combined into a single commit.
    This brings a distinct advantage by making it easy to push changes that may otherwise
    require coordination across multiple repos, deployments, and systems in one place.
    All processes around maintaining code quality and standards also become simplified.
    There’s one **Pull Request** (**PR**) to review, one deployment to verify, and
    one set of checks to enforce.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 能够访问多个项目的代码使得提交原子更改成为可能，这意味着跨项目所做的更改可以合并为一个单独的提交。这通过将可能需要在多个仓库、部署和系统中协调的更改集中在一个地方，带来明显的优势。所有围绕维护代码质量和标准的过程也变得简化。只有一个**Pull
    Request**（**PR**）需要审查，一个部署需要验证，以及一组需要执行的检查。
- en: So why is every project not a monorepo? In large applications, having too many
    files in the project can become a significant issue. It would require every developer
    to have top-of-the-line hardware and CI/CD servers to run on expensive, high-performance
    hardware. In addition, automating the deployment of such a project can become
    a very complex task. Finally, a new team member joining the team can find it overwhelming.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么每个项目都不是monorepo呢？在大型的应用程序中，项目中的文件过多可能成为一个重大问题。它要求每个开发者都拥有顶级的硬件和CI/CD服务器，以便在昂贵的、高性能的硬件上运行。此外，自动部署这样的项目可能成为一个非常复杂的任务。最后，新加入团队的新成员可能会感到不知所措。
- en: While monorepos at least date back to the early 2000s, they were impractical
    to leverage as a strategy for most, except the top tech companies worldwide. In
    2019, when Google released the open-source Bazel build tool, itself based on a
    2015 internal project called Blaze, the idea became feasible for smaller-scale
    projects. In the JavaScript, TypeScript, and web app development world, Nx, developed
    by ex-Googlers, has risen to prominence. In terms of managing, building, and publishing
    packages, Lerna is a cousin of Nx.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 monorepos 至少可以追溯到2000年代初，但对于大多数公司来说，除了全球顶尖的科技公司外，它们并不实用。2019年，当谷歌发布了开源的Bazel构建工具，该工具基于2015年的内部项目Blaze时，这个想法对于小规模项目来说变得可行。在JavaScript、TypeScript和Web应用程序开发领域，由前谷歌员工开发的Nx已经崭露头角。在管理、构建和发布包方面，Lerna是Nx的近亲。
- en: Nx monorepo
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Nx monorepo
- en: As mentioned in *Chapter 3*, *Architecting an Enterprise App*, Nx is a next-generation
    build system with first-class monorepo support and powerful integrations. Nx offers
    an opinionated architecture, which is welcome for large teams and enterprises.
    Nx also has a cloud offering, where it’ll leverage a distributed cache and parallelization
    to optimize builds without your team investing in complicated infrastructure work.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在*第 3 章*中提到的，*构建企业级应用架构*，Nx 是一个下一代构建系统，具有一流的单一代码仓库支持和强大的集成功能。Nx 提供了一种有见地的架构，这对于大型团队和企业来说是非常受欢迎的。Nx
    还提供云服务，它将利用分布式缓存和并行化来优化构建，而无需你的团队投资复杂的底层基础设施工作。
- en: 'You can set up a new Nx workspace by executing:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过执行以下命令来设置一个新的 Nx 工作空间：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternatively, you can migrate an existing project by executing the following
    command in the project folder:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在项目文件夹中执行以下命令来迁移现有项目：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By default, this will give you a monorepo configuration with one app. You can
    use Nx generators to add libraries that can be shared across components and other
    modules. By separating code into distinct libraries, multiple people working on
    the project simultaneously are less likely to have merge conflicts. However, if
    you follow the router-first architecture and segregate duties between feature
    modules, you can get similar results. There’s more at [https://nx.dev/getting-started](https://nx.dev/getting-started).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这将为你提供一个包含一个应用的单一代码仓库配置。你可以使用 Nx 生成器添加可以在组件和其他模块之间共享的库。通过将代码分离到不同的库中，同时参与项目工作的多个人不太可能遇到合并冲突。然而，如果你遵循先路由架构并在功能模块之间划分职责，你也能得到类似的结果。更多内容请参阅[https://nx.dev/getting-started](https://nx.dev/getting-started)。
- en: The question is, is it worth it? Many experts use it as a standard tool; however,
    in my pursuit of minimalism, I’m not a fan of bringing a tank to a knife fight.
    There’s a cost to introducing a sophisticated piece of tech like this to a team.
    There’s a steep learning curve to adopt such a tool.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，这值得吗？许多专家将其用作标准工具；然而，在我追求简约的过程中，我不喜欢在刀战中带来坦克。引入这样复杂的技术对团队来说是有成本的。采用这样的工具需要克服陡峭的学习曲线。
- en: When you layer JavaScript, TypeScript, Git, Nx, Angular, libraries, Node, npm,
    and other server-side tech on top of each other, the cognitive load required to
    navigate these tools goes through the roof. Furthermore, each one of these tools
    requires expertise to correctly configure, maintain, and upgrade them over time.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 JavaScript、TypeScript、Git、Nx、Angular、库、Node、npm 和其他服务器端技术之上层层叠加时，导航这些工具所需的认知负荷会急剧增加。此外，这些工具中的每一个都需要专业知识来正确配置、维护和随着时间的推移进行升级。
- en: On modern hardware (at least ones not addled by enterprise-grade *slow-everything-down-so-we-can-make-extra-sure-you-don’t-have-a-virus*
    software installed on it), Angular apps with several hundred components build
    fast enough. With the adoption of esbuild and Vite, this should improve even further.
    Nx’s distributed cache and centralized dependency management features may tip
    the scales for you. Always assess your needs carefully before starting a new project;
    running on autopilot, it’s easy to either under- or overestimate your needs.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代硬件上（至少不是被企业级*慢速一切以便我们可以额外确保你没有病毒*软件搞砸的硬件），拥有数百个组件的 Angular 应用构建速度足够快。随着 esbuild
    和 Vite 的采用，这应该会进一步改善。Nx 的分布式缓存和集中式依赖管理功能可能会对你产生决定性影响。在开始一个新项目之前，务必仔细评估你的需求；自动运行时，很容易低估或高估你的需求。
- en: I want to make one thing crystal clear. If you are working with thousands of
    components, then Nx is a requirement.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我要明确一点。如果你正在处理数千个组件，那么 Nx 是必需的。
- en: 'Most Angular monorepos only contain frontend code. To configure a full-stack
    monorepo using NestJS in an existing Angular workspace, install the Nest schematic
    and generate a new project within the Nx workspace:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Angular 单一代码仓库只包含前端代码。要在现有的 Angular 工作空间中使用 NestJS 配置一个全栈单一代码仓库，请安装 Nest
    脚本并在 Nx 工作空间内生成一个新项目：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can read more about this at [https://www.thisdot.co/blog/nx-workspace-with-angular-and-nest/](https://www.thisdot.co/blog/nx-workspace-with-angular-and-nest/).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处了解更多信息[https://www.thisdot.co/blog/nx-workspace-with-angular-and-nest/](https://www.thisdot.co/blog/nx-workspace-with-angular-and-nest/)。
- en: Next, let’s see how LemonMart server’s monorepo is configured.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 LemonMart 服务器的单一代码仓库是如何配置的。
- en: Git submodules
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git 子模块
- en: Git submodules help you share code between multiple repositories while keeping
    the commits separate. Frontend developers may choose to only work using the frontend
    repository, whereas full-stack developers will prefer access to all code. Git
    submodules also provide a convenient way for existing projects to be combined.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Git子模块帮助您在多个仓库之间共享代码，同时保持提交的分离。前端开发者可能选择仅使用前端仓库进行工作，而全栈开发者将更喜欢访问所有代码。Git子模块还为现有项目的合并提供了一个方便的方法。
- en: 'Observe the overall structure of the `lemon-mart-server` project, where you
    are going to have three main folders, as shown here:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 观察一下`lemon-mart-server`项目的整体结构，您将拥有三个主要文件夹，如图所示：
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `bin` folder contains helper scripts or tools, the `web-app` folder represents
    your frontend, and `server` contains the source code for the backend. In our case,
    the `web-app` folder is the `lemon-mart` project. Instead of copying and pasting
    the code from the existing project, we leverage Git submodules to link two repositories
    together. The `package.json` file contains scripts that assist in the initialization,
    updating, and cleaning up of Git submodules, like `modules:update` to fetch the
    latest version of the web app.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`bin`文件夹包含辅助脚本或工具，`web-app`文件夹代表您的前端，而`server`包含后端源代码。在我们的案例中，`web-app`文件夹是`lemon-mart`项目。我们不是复制粘贴现有项目的代码，而是利用Git子模块将两个仓库链接在一起。`package.json`文件包含帮助初始化、更新和清理Git子模块的脚本，如`modules:update`用于获取web应用的最新版本。'
- en: I recommend that you perform the following actions on the version of `lemon-mart-server`
    that you cloned from GitHub. Otherwise, you will need to create a new project
    and execute `npm init -y` to get things started.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您在从GitHub克隆的`lemon-mart-server`版本上执行以下操作。否则，您将需要创建一个新的项目并执行`npm init -y`以开始操作。
- en: 'To initialize the web-app folder with your project:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用您的项目初始化web-app文件夹：
- en: Update `webAppGitUrl` with the URL to your own project.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`webAppGitUrl`更新为您自己的项目的URL。
- en: Execute `webapp:clean` to remove the existing `web-app` folder.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`webapp:clean`以删除现有的`web-app`文件夹。
- en: 'Finally, execute the `webapp:init` command to initialize your project in the
    `web-app` folder:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，执行`webapp:init`命令以初始化`web-app`文件夹中的项目：
- en: '[PRE11]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Going forward, execute the `modules:update` command to update the code in the
    submodule. To pull the submodules after cloning the repo in another environment,
    execute `npm modules:init`. If you ever need to reset the environment and restart,
    then execute `webapp:clean` to clean Git’s cache and remove the folder.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续前进时，执行`modules:update`命令以更新子模块中的代码。在另一个环境中克隆仓库后，要拉取子模块，请执行`npm modules:init`。如果您需要重置环境并重新启动，请执行`webapp:clean`以清理Git的缓存并删除文件夹。
- en: Note that you can have multiple submodules in your repository. The `modules:update`
    command will update all the submodules.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您可以在您的仓库中拥有多个子模块。`modules:update`命令将更新所有子模块。
- en: 'Your web application code is now available in the folder named `web-app`. Additionally,
    you should be able to see both projects under VS Code’s **SOURCE CONTROL** pane,
    as shown here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Web应用程序代码现在可在名为`web-app`的文件夹中找到。此外，您应该能够在VS Code的**源代码控制**面板下看到这两个项目，如图所示：
- en: '![](img/B20960_07_03.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B20960_07_03.png)'
- en: 'Figure 7.3: VS Code source control providers'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：VS Code源代码控制提供者
- en: Using VS Code’s source control, you can independently perform Git actions on
    either repository.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用VS Code的源代码控制，您可以对任一仓库独立执行Git操作。
- en: If things get messy with your submodule, simply `cd` into the submodule directory,
    execute `git pull`, and then `git checkout main` to restore the main branch. Using
    this technique, you may check out any branch from your project and submit PRs.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的子模块变得混乱，只需`cd`到子模块目录，执行`git pull`，然后`git checkout main`以恢复主分支。使用此技术，您可以从项目中的任何分支检出并提交PR。
- en: Now that our submodule is ready, let’s see how the server project is configured
    so that we can configure our CI server.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在子模块已经准备好了，让我们看看服务器项目是如何配置的，这样我们就可以配置我们的CI服务器。
- en: CircleCI config
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CircleCI配置
- en: 'One of the benefits of using Git submodules is that we can verify that our
    frontend and backend work in the same CI pipeline. The `config.yml` file implements
    two jobs, part of the workflow shown here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Git子模块的一个好处是我们可以验证我们的前端和后端是否在同一个CI管道中工作。`config.yml`文件实现了两个作业，这是这里显示的工作流程的一部分：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The pipeline checks out the code, verifies the security of the packages we’re
    using with `audit-ci`, installs dependencies, checks for styling and linting errors,
    runs tests, and checks for code coverage levels.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The test commands implicitly build the server code, which is stored under the
    `dist` folder. In the final step, we move the `dist` folder into the workspace
    so that we can use it at a later stage.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: The CI pipeline will build the server and the web app in parallel, with an option
    to run the `deploy` job if the jobs succeed on the main branch. There are more
    details on CI/CD in *Chapter 10, Releasing to Production* *with CI/CD*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s see the difference between RESTful and GraphQL APIs.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Designing APIs
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 3*, *Architecting an Enterprise App*, I cover the importance of
    a stateless, data-driven design as part of Router-first architecture. As part
    of this goal, I highlight identifying major data entities that your app will operate
    around as an important activity. It’s no mistake that API design also greatly
    benefits by designing around major data entities.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: In full-stack development, nailing down the API design early on is important.
    If your frontend and backend teams can agree on major data entities and the shape
    of those entities, then both teams can agree on a contract to go off and build
    their own respective pieces of software. In Router-first architecture, I highlight
    the importance of leveraging TypeScript interfaces to quickly stub out the architecture
    of your app. Backend teams can conduct similar activities.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: A little bit of early design work and agreement ensures integration between
    these components can be established very early on, and with CI/CD pipelines, we
    can ensure it doesn’t disintegrate.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: CI is critical to success. One of the most infamous cases where teams didn’t
    integrate critical systems until too late was the disastrous launch of HealthCare.gov
    in 2013\. Even though 300 people worked on it, and $300,000,000 was spent on this
    project, it failed. In total, 1.7 billion dollars had to be spent to rescue the
    project and make it successful. The US federal government can afford to do this.
    Your enterprise won’t be as accepting.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: There are further considerations in designing your API, and if frontend and
    backend developers collaborate closely to achieve shared design goals, the chance
    of project success is greatly improved.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Some high-level goals are listed as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Minimize data transmitted between the client and server.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stick to well-established design patterns (e.g., pagination API design).
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design to reduce business logic implementation on the client.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design around major data entities.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flatten data structures when crossing boundaries.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not expose database keys or foreign key relationships.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version endpoints from the get-go.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should aim to implement all the business logic behind your API surface.
    The frontend should only contain presentation logic. Any `if` statement implemented
    by the frontend should also be verified in the backend.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该旨在实现API表面背后的所有业务逻辑。前端应仅包含展示逻辑。任何由前端实现的`if`语句也应由后端验证。
- en: As discussed in *Chapter 1*, *Angular’s Architecture and Concepts*, it is critical
    to aim for a stateless design in both the backend and frontend. Every request
    should utilize non-blocking I/O methods and not rely on existing sessions. This
    is the key to seamlessly scaling your web application code on cloud platforms.
    Sessions are notorious for scaling out and using a lot of memory.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如在第1章*Angular的架构和概念*中讨论的那样，在后台和前端实现无状态设计至关重要。每个请求都应该利用非阻塞I/O方法，并且不依赖于现有的会话。这是在云平台上无缝扩展你的Web应用程序代码的关键。会话因其扩展和占用大量内存而臭名昭著。
- en: Whenever you’re implementing a project, it is important to limit, if not eliminate,
    experimentation. This is especially true in full-stack projects. The downstream
    effect of missteps in API design can be profound and impossible to correct once
    your application goes live. Proofs of concept are ideal places to experiment and
    validate ideas and new technologies. Their one great feature is how disposable
    they are.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你在实施一个项目，限制，如果可能的话，消除实验是非常重要的。这在全栈项目中尤其如此。一旦你的应用程序上线，API设计中的失误可能会产生深远的影响，并且难以纠正。概念验证是实验和验证想法以及新技术理想的地方。它们的一个显著特点是它们的可丢弃性。
- en: Next, let’s go over designing REST and GraphQL APIs around major data entities.
    In this case, we’ll review the implementation of an API surrounding users, including
    authentication. In both cases, we will rely on an API specification language.
    For REST, we will use the OpenAPI specification, and for GraphQL, the schemas
    specification, to document the design so that we can concretely communicate the
    intent of the API to team members. Later, these specs become interactive tools,
    reflecting the capability of our APIs.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来讨论围绕主要数据实体设计REST和GraphQL API。在这种情况下，我们将回顾围绕用户和认证的API实现。在两种情况下，我们将依赖API规范语言。对于REST，我们将使用OpenAPI规范，对于GraphQL，我们将使用模式规范，以记录设计，以便我们可以具体地向团队成员传达API的意图。稍后，这些规范将成为交互式工具，反映我们API的能力。
- en: REST APIs
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST API
- en: '**REST** (**representational state transfer**) is commonly used to create stateless,
    reliable web applications leveraging HTTP methods (verbs) like **GET**, **POST**,
    **PUT**, and **DELETE**. REST APIs are well defined and static. Like any public
    API, once released, it is very difficult, if not impossible, to change their interface.
    It is always possible to extend but hard to optimize for emergent use cases, like
    mobile or purpose-built apps that need to use the API differently. This usually
    leads to a great expansion of the API surface as teams implement specific APIs
    to match new needs. This can lead to maintainability challenges if there are a
    half-dozen separate codebase to access the same piece of data.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST**（**表示状态转移**）通常用于创建利用HTTP方法（动词）如**GET**、**POST**、**PUT**和**DELETE**的无状态、可靠的Web应用程序。REST
    API定义良好且静态。像任何公开API一样，一旦发布，就很难，如果不是不可能的，改变它们的接口。总是可以扩展，但很难针对新兴用例进行优化，例如需要以不同方式使用API的移动或专用应用程序。这通常会导致API表面的巨大扩展，因为团队实施特定的API来满足新的需求。如果有多个独立的代码库需要访问相同的数据，这可能会导致可维护性挑战。'
- en: From a frontend developer’s perspective, working with APIs they didn’t write
    can be a perplexing experience. Most public APIs and businesses that publish APIs
    usually resolve this by publishing high-quality documentation and examples. This
    takes time and money. However, a fast-moving team in an enterprise environment
    can’t afford to wait for such documentation to be manually created.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从前端开发者的角度来看，使用他们没有编写过的API可能是一种令人困惑的经历。大多数公开API和发布API的企业通常通过发布高质量的文档和示例来解决这个问题。这需要时间和金钱。然而，在企业环境中，一个快速发展的团队无法等待这样的文档被手动创建。
- en: Enter OpenAPI, aka Swagger. OpenAPI specs can document API names, routes, input
    and return parameter types, encoding, authentication, request headers, and expected
    HTTP status codes. This level of detail leaves little room for interpretation
    of how an API should be consumed, reducing friction and buggy code – all critical
    ingredients to avoid late-stage integration challenges.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'The OpenAPI spec can be defined in the YAML or JSON format. Using this spec
    file, you can render an interactive UI for your API. Install the Swagger Viewer
    VS Code extension and preview the `swagger.yaml` file under the `server` folder:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: There’s also the OpenAPI (Swagger) Editor extension, which is a feature-rich
    alternative. At the time of publishing, this extension doesn’t support OpenAPI
    version 3.1.0.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_07_04.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Swagger.yaml preview'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Using the Swagger UI view, you can try out commands and execute them against
    your server environment once it’s implemented.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: OpenAPI Spec
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are using the OpenAPI spec version `openapi: 3.1.0`. The OpenAPI spec can
    document metadata about your server, various components of your API, like security
    schemes, responses, data schemas, and input parameters, and finally, the paths
    that define your HTTP endpoints.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go over the major components of the `swagger.yaml` file located under
    the `server` folder:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'The YAML file starts with general information and target servers:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Under `components`, we define common `securitySchemes` and responses, which
    define the authentication scheme we intend to implement and how the shape of our
    error message response will appear:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note the usage of `$ref` to reuse repeating elements. You can see `ServerMessage`
    being defined here.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Under `components`, we define shared data `schemas`, which declare the data
    entities that we either take in as input or return to the client:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Under `components`, we define shared `parameters`, making it easy to reuse
    common patterns such as paginated endpoints:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Under `paths`, we define REST endpoints, such as a `post` endpoint for the
    `/login` path:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that `requestBody` defines input variables that are required with a type
    of `string`. Under `responses`, we can define how a successful `200` response
    and an unsuccessful `401` response to a request appear. In the former case, we
    return an `accessToken`, while in the latter case, we return an `UnauthorizedError`,
    as defined in *step 2*.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Under `paths`, we define the remaining paths:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The OpenAPI spec is powerful, allowing you to define intricate requirements
    on how users should be able to interact with your API. The OpenAPI spec can be
    found at [https://spec.openapis.org/oas/latest.html](https://spec.openapis.org/oas/latest.html).
    It is an invaluable resource while developing your own API definition.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Our overarching goal is to integrate this interactive documentation with our
    Express.js APIs. Now, let’s see how you can implement such an API.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: OpenAPI spec with Express
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Configuring Swagger with Express is a manual process. But this is a good thing.
    Forcing yourself to manually document endpoints has a positive side effect. By
    slowing down, you will get the opportunity to consider your implementation from
    the perspective of the consumer of the API. This perspective will help you resolve
    potential issues with your endpoints during development, avoiding annoying, if
    not costly, rework.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how you can directly embed the OpenAPI spec alongside
    your code in chunks:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, we use the `JSDoc` documentation syntax that starts with `/**`
    and then define the relevant part of the OpenAPI spec right after the `@openapi`
    identifier. We can still reference components defined elsewhere, as shown with
    the `$ref` statements to the `User` and `UnauthorizedError` objects.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The major benefit of integrating the spec alongside your code is that the developer
    knows exactly how the server should respond to a `/me GET` request. If a user
    exists, we respond with a `User` object; if not, we throw a `401` error that adheres
    to the shape of the `UnauthorizedError` object. Using some automated tools, we
    can still generate the same interactive Swagger UI covered earlier, so testers
    and developers can discover or test the API directly from a web interface.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: As the API implementation evolves, this setup makes it easy for developers to
    keep the spec up to date. By making it easy, we incentivize everyone involved
    with the desire to keep Swagger UI working because all team members benefit from
    it. By creating a virtuous cycle, we achieve the ideal of **living documentation**.
    Normally, initial designs become useless as they grow stale, but instead, we can
    have an automated and interactive solution that delivers ongoing value.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use two helper libraries to help us integrate the inline spec
    into the codebase:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '`swagger-jsdoc`: This allows us to implement OpenAPI specs right on top of
    the relevant code by using the `@openapi` identifier in a `JSDoc` comment block,
    generating a `swagger.json` file as output.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`swagger-ui-express`: This consumes the `swagger.json` file to display the
    interactive Swagger UI web interface.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s explore how Swagger is configured to work with Express.js:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'The dependencies and type information for TypeScript are shown here:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s explore the `docs-config.ts` file, which configures the base OpenAPI
    definition:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Modify the `servers` property to include the location of your testing, staging,
    or production environments. This allows consumers of your API to test the API
    using the web interface without additional tooling. Note that the `apis` property
    informs the code files that `swaggerJsdoc` should parse when constructing the
    `swagger.json` file. This routine runs during the bootstrapping of the server,
    which is why we reference the transpiled `.js` files instead of `.ts` files.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Bootstrap the `swagger` config in `app.ts`:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Specs contain the content of the `swagger.json` file, which is then passed to
    `swaggerUi`. Then, using the `server` middleware, we can configure `swaggerUi`
    to host the web interface at `/api-docs`. We can also serve the JSON file from
    an endpoint to consume it in another tool, at `/swagger`, as shown above.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Even after integrating the spec file alongside the code, developers must manually
    ensure that the spec and the code match. This process can be automated, including
    generating TypeScript-based API handlers to prevent coding mistakes.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: A community-driven list of high-quality and modern tools for OpenAPI can be
    found at [https://openapi.tools/](https://openapi.tools/).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand how we can design a REST API and create living documentation
    around it, it’s time to learn about GraphQL, which bakes these ideas into its
    core design.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL APIs
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**GraphQL** (**Graph Query Language**), invented at Facebook, is a modern query
    language for APIs that offers a more flexible, robust, and efficient alternative
    to the traditional REST API. In GraphQL, instead of HTTP verbs, you write a query
    to GET data, a mutation to POST, PUT, or DELETE data, and subscriptions to push
    data in the style of WebSockets. Unlike REST, which exposes a fixed set of endpoints
    for each resource, GraphQL allows clients to request exactly the data they need,
    no more and no less. This means clients can shape the responses according to their
    requirements, leading to fewer over-fetching and under-fetching issues. We no
    longer need to design the perfect API surface to get optimal results.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: In the realm of full-stack development, as touched upon in the *Designing APIs*
    section, the importance of designing around major data entities cannot be overstated.
    GraphQL shines in this aspect. Its type system ensures the API shapes around these
    major data entities, providing a clear contract between the frontend and backend
    teams. This type system, defined in the GraphQL schema, acts as the contract,
    specifying the data types that can be fetched and the set of operations available.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: For frontend developers, diving into a GraphQL API can be a refreshing experience.
    The introspective nature of GraphQL means that the schema can be queried for details
    about itself.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: This self-documenting feature ensures that developers always have an up-to-date
    reference, eliminating the need for separate, manually maintained documentation.
    This is especially beneficial for agile teams in enterprise settings where waiting
    for documentation isn’t always feasible.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Enter the GraphQL Playground or GraphiQL interactive environments, where developers
    can test and explore GraphQL queries in real time. Much like Swagger UI for OpenAPI,
    these tools provide immediate feedback, allowing developers to understand the
    structure, types, and operations of the API. This hands-on approach reduces the
    learning curve and fosters a deeper understanding of the API’s capabilities.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s explore how to design GraphQL APIs around major data entities, ensuring
    that they align with the principles laid out in our Router-first architecture
    and other best practices.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL schema
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The GraphQL schema is at the heart of any GraphQL API, acting as the contract
    between the client and the server. It describes the structure and capabilities
    of the API by defining types and the relationships between the types. These types
    model the major data entities that the API operates on.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by exploring the `graphql.schema` file located under `server/graphql`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `type` keyword, we can define data objects:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This `User` type has scalar fields like the `id` and `email` fields, representing
    primitive value types like `ID`, `String`, `Int`, `Float`, and `Boolean`. The
    bang symbol `!` indicates these fields are required. We can also define relationships
    between types, such as `Name` or `Phone`. The square brackets `[]` indicate that
    `phones` is an array of `Phone` objects.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can also define enums and use them like a scalar type:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Using the reserved type `Query`, we can define how data can be retrieved:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can define acceptable arguments and the return type.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using the reserved type `Mutation`, we can define how the state can be modified:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We can define a login or a `createUser` method. Note that `createUser` takes
    an input object, which is required if we want to pass a whole object as an argument.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Input objects are declared with the `input` keyword:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that any related object must also use the input declaration. Output types
    and input data can’t be mixed.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have noticed, we can also add descriptions to document our API using
    the # symbol or, optionally, the triple quote `"""` syntax.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The schema is defined using the GraphQL **Schema Definition Language** (**SDL**).
    You can access the SDL specification at [https://graphql.org/](https://graphql.org/).
    It’s an essential resource for anyone crafting a well-defined GraphQL API.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the schema provides a strict contract between the client and the server.
    It makes explicit the data shapes and capabilities available. Frontend and backend
    teams can build features in parallel against this contract, and tooling like GraphQL
    Playground makes the schema interactive.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: We will use the Apollo GraphQL library to help construct the schema programmatically
    in our Express server.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Apollo with Express
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Apollo GraphQL is a comprehensive and widely adopted suite of tools and services
    designed to help developers build, manage, and scale GraphQL applications with
    ease. Developed by the Meteor Development Group, Apollo has become synonymous
    with GraphQL development for many developers, due to its robust features and developer-friendly
    approach. Here’s a breakdown of Apollo GraphQL:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '**Apollo Client**: A state-of-the-art GraphQL client that manages local and
    remote data. It integrates seamlessly with any JavaScript frontend framework,
    such as React, Vue, or Angular. Apollo Client provides features like caching,
    optimistic UI updates, and real-time subscriptions, making it easier to fetch,
    cache, and modify application data.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apollo Server**: A community-driven, open-source GraphQL server that works
    with any GraphQL schema. Apollo Server provides performance tracing and error
    tracking and supports schema stitching, allowing for the merging of multiple GraphQL
    APIs into one unified API.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apollo Client Developer Tools**: Browser extensions offering rich in-browser
    development experience. Developers can view their GraphQL store, inspect active
    queries, and interact with their GraphQL server using the built-in GraphiQL IDE.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apollo provides more advanced dev tools with Apollo Studio as part of its cloud
    offering. Apollo Federation allows organizations to divide their monolithic GraphQL
    API into smaller, more maintainable microservices. It provides a means to compose
    multiple GraphQL services into a single data graph. Apollo Link allows developers
    to create chainable “links” to handle tasks like logging, request retries, and
    even offline caching.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: In essence, Apollo GraphQL provides a holistic approach to GraphQL development,
    offering tools and services catering to beginners and advanced users. Whether
    you’re building a small application or scaling a large enterprise system, Apollo’s
    tools ensure great DevEx.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: The GraphQL schema and the GraphQL library are inseparable, so we don’t have
    to take extra steps to configure the schema definition to work with the codebase,
    as we did with OpenAPI.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: To generate types from a GraphQL schema, follow the guidance provided at [https://www.apollographql.com/docs/apollo-server/workflow/generate-types/](https://www.apollographql.com/docs/apollo-server/workflow/generate-types/).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s see how you can configure your schema and Apollo with Express.js:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the Apollo server:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Open the `api.graphql.ts` file, which configures the Apollo server:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using `node:fs`, we read the schema file into the `typeDefs` object and pass
    it into a new `ApolloServer` instance along with a reference to the resolvers.
    Finally, we call `server.start()` and export the `useGraphQL` function.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Bootstrap the Apollo server in `index.ts`:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In `index.ts`, right after we create an instance of the Express server, which
    is defined by the app variable, we call the `useGraphQL` function to start it
    up. This configuration allows us to implement REST and GraphQL APIs side by side.
    GraphQL APIs and the interactive Explorer tools can be accessed at `/graphql`,
    as shown below:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_07_05.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: GraphQL Explorer'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the differences between REST and GraphQL APIs and how
    we can configure them equivalently with Express.js, let’s take a look at the overall
    architecture of the server.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Implementing APIs with Express.js
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s go over the architecture and file structure of our backend so that we
    get an understanding of how the server is bootstrapped, how routing is configured
    for API endpoints, how public resources are served, and how services are configured.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Review the file structure of our Express server:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we’ll review the purpose and the interaction between these files by looking
    at a component diagram, giving us an overview of the architecture and the dependency
    tree:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_07_06.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: Express server architecture'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '`index.ts` contains a `start` function, which bootstraps the application, leveraging
    four major helpers:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '`config.ts`: Manages environment variables and settings.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.ts`: Configures Express.js and defines all API paths, and then routers
    implement the paths and leverage services that contain the business logic. Services
    use models, such as `user.ts`, to access the database.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`api.graphql.ts`: Configures GraphQL, resolvers implement queries, and mutators
    leverage the same services and then resolvers implement queries and mutators and
    leverage the same services to access the database.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`document-ts`: Establishes a connection to the database, configures it, and
    leverages `user.ts` to configure a seed user during startup.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see that the components at the top of the diagram are responsible for
    startup and configuration chores, including configuring API paths, which represent
    the **API** layer. The **Business** layer should contain most of the business
    logic for the app, while data access is handled in the **Persistence** layer.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following implementation of `index.ts`, which shows a simplified
    version showing all major components in sequence:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that the last line of code shown, `start()`, is the function call that
    triggers the server’s initialization.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s investigate how the Express server is set up.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping the server
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`app.ts` configures Express.js, along with serving static assets, routing,
    and versioning. Express.js leverages middleware functions to integrate with libraries
    or your code. Middleware are functions that execute during the lifecycle of a
    request to the Express server. Middleware functions have access to the request
    and response objects and the following middleware function in the application’s
    request-response cycle. This access allows them to execute any code, make changes,
    end the request-response cycle, and call the next middleware in the stack. In
    the code below, cors, logger, and compression are library functions, and later
    in the chapter, we will go over the implementation of a custom authenticate middleware:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, note that configuring Express is straightforward with
    the `use()` method. First, we configure `cors`, and then `express` parsers, `logger`,
    and `compression`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Next, using the `express.static` function, we serve the `public` folder at the
    root’s route, `/`, so that we can display some useful information about our server,
    as shown in *Figure 7.1* at the beginning of this chapter.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we configure the router, which is defined in `api.ts`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: REST routes and versioning
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`api.ts` configures the Express router. Refer to the following implementation:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this case, we have two child routes for `v1` and `v2`. It is critical to
    always version the APIs you implement. Once an API becomes public, it can be tricky,
    even impossible sometimes, to simply phase out an API for a newer version. Even
    minor code changes or slight differences in the API can cause clients to break.
    You must pay careful attention to only making backward-compatible changes to your
    API.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: At some point, you will need to completely rewrite the endpoint to meet new
    requirements, performance, and business needs, at which point, you can simply
    implement a `v2` version of your endpoint while leaving the `v1` implementation
    unchanged. This allows you to innovate at the pace you need to while keeping legacy
    consumers of your app functional.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: In short, you should version every API you create. By doing this, you force
    your consumers to version their HTTP calls to your API. Over time, you can transition,
    duplicate, and retire APIs under different versions. Consumers then have a choice
    to call whichever version of the API works for them.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuring a route is trivial. Let’s see the configuration for `v2`, as shown:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The question mark at the end of `/users?` means that both `/user` and `/users`
    will work against operations implemented in `userRouter`. This is a great way
    to avoid typos while allowing the developer to choose the plurality that makes
    sense for the operation.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'In `userRouter`, you can implement the GET, POST, PUT, and DELETE operations.
    Refer to the following implementation:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding code, you can observe the use of route parameters. You can
    consume route parameters through a request object, such as `req.params.userId`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Note that all routes in the sample code are tagged as `async` because they will
    all make a database call, which we are going to await. If your route is synchronous,
    then you don’t require the `async` keyword.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s investigate GraphQL resolvers.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL resolvers
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GraphQL resolvers are implemented in `resolvers.ts`. The GraphQL server performs
    a breadth-first traversal of the query and recursively calls resolvers to generate
    the response.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Let me elaborate – when a GraphQL server gets a query, it processes the request
    layer by layer, starting from the top-level fields and moving horizontally across
    the structure, like a search that moves across each level of a tree before going
    deeper, known as breadth-first traversal. For each field it encounters, the server
    invokes a specific function called a resolver, designed to fetch the data for
    that field. If a field is complex and contains nested subfields, the resolver
    for that field will, in turn, call upon other resolvers for each of these subfields.
    This process repeats itself, descending into the query’s hierarchy as needed until
    all the data for the query is retrieved and can be assembled into the structured
    response that matches the original query layout.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following implementation:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: For non-scalar types, arrays, or enums, we may need to provide a transformation
    so that GraphQL can appropriately unpack the data retrieved from the database.
    The good part is we only need to provide a resolver for specific properties of
    objects that need such manipulation.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Resolvers may seem simple, but they can fulfill very complex needs, e.g., a
    simple request from a client may involve making multiple service and database
    calls and collating the results into an efficient response, just so the client
    can display it.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: The atomic nature of resolvers means we only need to implement them once. Next,
    let’s explore how services are configured.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Services
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We don’t want to implement our business logic in the router files, which represent
    our API layer. The API layer should largely consist of transforming data and making
    calls to the business logic layer.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: You can implement services using Node.js and TypeScript features. No fancy dependency
    injection is necessary. The sample application implements two services – `authService`
    and `userService`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in `userService.ts`, you can implement a function called `createNewUser`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`createNewUser` accepts `userData` in the shape of `IUser`, and when it is
    done creating the user, it returns an instance of `User`. We can then use this
    function in our router as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We can await the result of `createNewUser` and, if successful, return the created
    object as a response to the POST request.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Note that even though we cast `req.body` as `IUser`, this is only a development
    time comfort feature. At runtime, the consumer may pass any number of properties
    to the body. Careless handling of request parameters is one of the primary ways
    your code can be maliciously exploited.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! Now, you have a good understanding of how our Express server
    works. Next, let’s look at how to connect to MongoDB.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB ODM with DocumentTS
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DocumentTS acts as an **ODM**, implementing a layer of models to enable rich
    and customizable interaction with database objects. ODM is the document-based
    database equivalent of an **Object Relational Mapper** (**ORM**) in relational
    databases. Think of Hibernate or Entity Framework. If you’re not familiar with
    these concepts, I recommend that you do further research before moving on.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: To get started, you can check out the following article, *MongoDB ORMs, ODMs,
    and Libraries*, at [https://www.mongodb.com/developer/products/mongodb/mongodb-orms-odms-libraries](https://www.mongodb.com/developer/products/mongodb/mongodb-orms-odms-libraries).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'At its core, DocumentTS leverages the Node.js driver for MongoDB. The makers
    of MongoDB implement this driver. It guarantees the best performance and feature
    parity with new MongoDB releases, whereas third-party libraries often lag in supporting
    new features. By using the `database.getDbInstance` method, you can access the
    native driver directly. Otherwise, you will access Mongo through the models that
    you implement. Refer to the following diagram for an overview:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_07_07.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: DocumentTS overview'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about MongoDB’s Node.js driver at [https://mongodb.github.io/node-mongodb-native/](https://mongodb.github.io/node-mongodb-native/).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: For more details on how DocumentTS works and the configuration details, refer
    to the project wiki on GitHub at [https://github.com/duluca/document-ts/wiki](https://github.com/duluca/document-ts/wiki).
    The wiki covers connecting to the database, defining models that implement `IDocument`,
    and configuring serialization and deserialization of data. Models allow calculated
    properties like `fullName` to be included in client responses while excluding
    fields like passwords. Passwords are also prevented from being saved to the database
    in clear text.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: The overview continues by demonstrating how to create indexes and query the
    database with aggregation. It creates a unique index on email, so duplicate emails
    cannot be registered. A weighted text index assists in filtering query results.
    DocumentTS aims to provide a convenient yet optional layer on top of the native
    MongoDB driver to help build fully async web applications. Developers are directly
    exposed to the MongoDB driver, so they learn how to work with the database instead
    of just the library.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how you can fetch data using the new user model.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Implementing JWT auth
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 5*, *Designing Authentication and Authorization*, we discussed implementing
    a JWT-based authentication mechanism. In LemonMart, you implemented a base auth
    service that can be extended for custom authentication services.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll leverage three packages for our implementation:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '`jsonwebtoken`: Used to create and encode JWTs'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bcryptjs`: Used to hash and salt a user’s password before saving it in the
    database, so we never store a user’s password in plain text'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uuid`: A generated universally unique identifier that is useful when resetting
    a user’s password to a random value'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hash function is a consistently repeatable, one-way encryption method, which
    means you get the same output every time you provide the same input, but even
    if you have access to the hashed value, you cannot readily figure out what information
    it stores. We can, however, compare whether the user has entered the correct password
    by hashing the user’s input and comparing the hash of their input to that of the
    stored hash of their password.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: The auth service hashes user passwords before storing them and compares hashed
    passwords on login. The `createJwt` function generates a JWT access token upon
    successful login. The authenticate middleware decodes the JWT and loads the user
    into the response stream for authenticated endpoints.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Note the vagueness of the incorrect email/password messages in the code. This
    is done so that bad actors cannot fish the system to exploit the authentication
    system.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: For password hashing, the `User` model’s `setPassword` method uses bcrypt’s
    `genSalt` and `hash` functions. The `comparePassword` method compares the hashed
    stored password with the hashed user input. This ensures passwords are never stored
    in plain text.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'The login API endpoint finds the user by email, calls `comparePassword` to
    validate the password, and, on success, calls `createJwt` to generate a signed
    JWT with user details like email, role, etc. The JWT is returned to the client
    as the `accessToken`:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The authenticate middleware decodes the JWT, finds the user by the encoded
    `id`, and injects the user into `res.locals.currentUser`. Authenticated endpoints
    like `/me` can conveniently access the user’s info. It also handles role-based
    access by checking options like `requiredRole`:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When retrieving a user by email, remember that emails are case-insensitive,
    so you should always convert the input to lowercase. You can improve this implementation
    further by validating the email and stripping any white space, script tags, or
    even rogue Unicode characters. Consider using libraries such as `express-validator`
    or `express-sanitizer`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating middleware
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `authenticate` function is a middleware we can use in our API implementations
    to ensure that only authenticated users with appropriate permissions can access
    an endpoint. Remember that real security is achieved in your backend implementation,
    and this `authenticate` function is your gatekeeper.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '`authenticate` takes a nullable `options` object to verify the current user’s
    role with the `requiredRole` property, so if an API is configured as shown below,
    only a manager can access that API:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In certain cases, we want a user to be able to update their own records but
    also allow managers to update everyone else’s records. In this case, we leverage
    the `permitIfSelf` property, as shown here:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this case, if the `_id` of the updated record matches the current user’s
    `_id`, then the user can update their own record. Since `requiredRoleCanOverride`
    is set to `true`, a manager can update any record. If it were set to `false`,
    this wouldn’t be allowed. By mixing and matching these properties, you can cover
    a vast majority of your gatekeeping needs.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Note that `idGetter` is a function delegate so that you can specify how the
    `_id` property should be accessed when the `authenticate` middleware executes.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following example implementation of a simplified `authenticate` middleware
    and its usage:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: The full implementation can be found at `server/src/services/auth.service.ts`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `authenticate` method is implemented as Express.js middleware. It can read
    the request header for an authorization token, verify the validity of the JWT
    provided, load the current user, and inject it into the response stream, so an
    authenticated API endpoint can conveniently access the current user’s information.
    This is shown by the `me` API above. If successful, the middleware calls the `next()`
    function to yield control back to Express. If unsuccessful, then the API can’t
    be called.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Note that `authenticateHelper` returns useful error messages, so users aren’t
    confused if they try to execute an action they’re not permitted to execute.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'In GraphQL, authentication and authorization are handled separately. At the
    Express.js level, we apply the `authenticate` middleware to the `/graphql` route.
    However, for explorer, introspection, and login functions to work, we must create
    exceptions to the rule. See the code below, which implements this logic:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: See `server/src/graphql/resolvers.ts` to see the full implementation of the
    auth in action.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: The `authOverridingOperations` property signals to `authenticate` that it should
    permit calls for introspection and the `Login` function. All other calls to other
    GraphQL functions will now be authenticated with the authentication context available
    in resolvers. In the resolvers, we can use the `authorize` method (located at
    `server/src/graphql/helpers.ts`) to check if the requestor can see the resource
    they’re trying to access. The `contextValue` stores the session context similar
    to how `res.local` works in Express.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s implement two custom auth providers, one for REST and another for
    GraphQL.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Custom server auth provider
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you understand the auth implementation in our server, we can implement
    a custom auth provider in LemonMart, as covered in *Chapter 6*, *Implementing
    Role-Based Navigation*:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: You must implement this custom auth provider in your Angular app.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: The code sample for this section is in the `projects/stage10` folder in the
    `lemon-mart-app` `app` or `web-app` folder.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a `baseUrl` variable in `environment.ts` so that we can connect
    to your server.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `environment.ts` and `environment.prod.ts`, implement a `baseUrl` variable.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, select `authMode` as `AuthMode.CustomServer`:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Install a helper library to programmatically access TypeScript enum values:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Implement the RESTful custom authentication provider using `HttpClient`, as
    shown here:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `authProvider` method calls our `/v1/auth/login` method, and `getCurrentUser`
    calls `/v1/auth/me` to retrieve the current user.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that calls to `login` methods always happen on HTTPS. Otherwise, you
    will send user credentials on the open internet. This is ripe for eavesdroppers
    on public Wi-Fi networks to steal user credentials.
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the GraphQL custom authentication provider using Apollo Client, as
    shown here:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note that the `LOGIN` mutation and `Me` query are implemented in `auth.graphql.queries.ts`.
    Otherwise, they take up too much space for the service code to be readable.
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update `authFactory` to return the new provider for the `AuthMode.CustomServer`
    option:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Start your web app to make sure that things are working.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations! You now grasp how code works across the entire software stack,
    from the database to the front and back ends.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered full-stack architecture. You learned about building
    a minimal MEAN stack. You now know how to create a monorepo for a full-stack application
    and configure a Node.js server with TypeScript. You learned about monorepos, containerizing
    a Node.js server, and declaratively defining infrastructure with Docker Compose.
    Using Docker Compose with CircleCI, we saw how you can verify your infrastructure
    in a CI environment.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to design a RESTful API using OpenAPI and GraphQL using Apollo,
    set up an Express.js app, and configure it such that you can generate interactive
    documentation for your APIs. You learned about the benefits of using DocumentTS
    with MongoDB.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: You then implemented a JWT-based authentication service with an `authenticate`
    middleware to secure API endpoints and allow for RBAC. Finally, you implemented
    two custom authentication providers in Angular. For REST, we used `HttpClient`,
    and for GraphQL, Apollo Client.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: The next two chapters will explore Angular recipes to create forms and data
    tables. In *Chapter 8*, *Recipes – Reusability, Forms, and Caching*, and *Chapter
    9*, *Recipes – Master/Detail, Data Tables, and NgRx*, we will tie everything together
    by sticking to a decoupled component architecture, smartly choosing between creating
    user controls and components and maximizing code reuse, with various TypeScript,
    RxJS, NgRx, and Angular coding techniques.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of the book, you will want your LemonMart server and MongoDB instance
    up and running to verify the correct functionality of your forms and tables as
    you implement them.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You secured your endpoints using the `authenticate` middleware. You configured
    Postman to send a valid token so that you can communicate with your secured endpoints.
    By way of an exercise, try removing the `authenticate` middleware and calling
    the same endpoint with and without a valid token. Re-add the middleware, and then
    try the same thing again. Observe the different responses you get from the server.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*What is DX? (Developer Experience)*, Albert Cavalcante, 2019, [https://medium.com/@albertcavalcante/what-is-dx-developer-experience-401a0e44a9d9](https://medium.com/@albertcavalcante/what-is-dx-developer-experience-401a0e44a9d9
    )'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Overview of Blocking versus Non-Blocking*, 2023, [https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/](https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/)'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Explain Non-Blocking I/O like I’m Five, Frank Rosner*, 2019, [https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/](https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/)'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*OpenAPI Specification*, 2023, [https://swagger.io/docs/specification](https://swagger.io/docs/specification)'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Serialization*, 2023, [https://en.wikipedia.org/wiki/Serialization](https://en.wikipedia.org/wiki/Serialization)'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JSON*, 2023, [https://en.wikipedia.org/wiki/JSON](https://en.wikipedia.org/wiki/JSON)'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Aggregation in MongoDB*, 2023, [https://docs.mongodb.com/manual/aggregation](https://docs.mongodb.com/manual/aggregation)'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Apollo Authentication*, 2023, [https://www.apollographql.com/docs/react/networking/authentication](https://www.apollographql.com/docs/react/networking/authentication)'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting Up Authentication and Authorization with Apollo Federation*, 2023,
    [https://www.apollographql.com/blog/backend/auth/setting-up-authentication-and-authorization-apollo-federation/](https://www.apollographql.com/blog/backend/auth/setting-up-authentication-and-authorization-apollo-federation/)'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Apollo Built-in error codes*, 2023, [https://www.apollographql.com/docs/apollo-server/data/errors#built-in-error-codes](https://www.apollographql.com/docs/apollo-server/data/errors#built-in-error-codes)'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Apollo Router & Gateway architecture*, 2023, [https://www.apollographql.com/docs/federation/building-supergraphs/router](https://www.apollographql.com/docs/federation/building-supergraphs/router
    )'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to ensure you’ve understood the key concepts
    from this chapter without googling anything. Do you know if you got all the answers
    right? Visit [https://angularforenterprise.com/self-assessment](https://angularforenterprise.com/self-assessment)
    for more:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: What are the main components that make for a great developer experience?
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a `.env` file?
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `authenticate` middleware?
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does Docker Compose differ from using the Dockerfile?
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an ODM? How does it differ from an ORM?
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is middleware?
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the uses of the OpenAPI spec?
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you refactor code for the `/v2/users/{id} PUT` endpoint in `userRouter.ts`
    so that the code is reusable?
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the major differentiators between REST and GraphQL?
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the similarities between OpenAPI and the GraphQL schema?
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our community on Discord
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/AngularEnterpise3e](Chapter_7.xhtml)'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1116411172100421421.png)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
