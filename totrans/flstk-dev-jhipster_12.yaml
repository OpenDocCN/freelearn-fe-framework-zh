- en: Deploying to the Cloud with Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes, also known as the container orchestration tool. As we have seen
    in the previous chapter, it comes with many additional features and is much easier
    to configure and manage. This makes Kubernetes a default choice for any container
    orchestration. The ability to mask the lower-level details and provide out-of-the-box
    service discovery, self-healing, and health checks attracted many companies and
    organizations to switch to Kubernetes. Aside from that, Kubernetes is the evolution
    of Google's internal orchestration tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating Kubernetes configuration files with JHipster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Walking through the generated files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the application to Google Cloud with Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating Kubernetes configuration files with JHipster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knowing the components of Kubernetes and how it works is beyond the scope of
    this book. However, we will look at how JHipster simplifies microservices deployment
    with Kubernetes. Let's go ahead and generate the Kubernetes configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the `docker-compose` sub-generator, JHipster also comes bundled with
    a Kubernetes sub-generator. In order to use it, just like with `docker-compose`,
    we will create a new folder and name it Kubernetes. Then, we will go inside the
    folder to create the configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create Kubernetes configuration files with the following command and
    then answer the questions that the sub-generator asks us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To install kubectl, please follow the instructions at Kubernetes' website ([https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)).
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes sub-generator needs kubectl (v1.2 or later) to be installed on your
    computer. kubectl is the command line interface for Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also install Cloud SDK from Google Cloud, which will also install kubectl.
    To set up gcloud:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the binary (based on your operating system) from[ https://cloud.google.com/sdk/](https://cloud.google.com/sdk/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, install the application by following the steps given on the website (make
    sure that you have python installed).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once installed, set up Google Cloud. In order to set up Google Cloud, run `gcloud
    init`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will then ask you to log in to your Google account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we have seen already, Kubernetes needs separate tools for running locally
    (that is for development purposes). Therefore, if you need to do things locally,
    please install minikube from Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first question the sub-generator asks is which type of application we''d
    like to deploy. It provides two options, which are monolithic and microservices. 
    We will choose the microservices option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6acdbc99-a5b2-4686-90cc-b9ab1a8e011d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, it asks us to enter the root directory. We will select the default option
    since our directories are present as the siblings of the Kubernetes folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ae09d92-e019-4a61-97f1-46a76474ed2e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, the sub-generator will list all the folders with our JHipster generated
    application. Here, it will list all three applications that we need—gateway, invoice,
    and notification. Select all three applications and hit enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67486104-8c87-44f7-9e81-9a43cfae4c46.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, it will ask us to provide the password for the registry service. In our
    case, it is JHipster Registry. We will select the default one for now, but it
    is generally advisable to use a strong password here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3eef9433-a527-413c-ad49-fa4112840d75.png)'
  prefs: []
  type: TYPE_IMG
- en: Afterward, it will ask us for the namespace that we need to use in Kubernetes.
    So, what is a namespace?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can consider namespaces as a group within which resources should be named
    uniquely. When the cluster is shared between different users or teams, namespaces
    can provide resource quotas for them. Ideally, namespaces should be used only
    for a larger team. For smaller teams, it is better to go with default options.
    Kubernetes, by default, provides three namespaces, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Default`: When you start a container or pod without providing any namespaces,
    they will end up in the default namespace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Kube-system`: This namespace contains Kubernetes system-based objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Kube-admin`: This is a public namespace, which will be shown to all the users
    publically without any authentication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will select the default namespace here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8ac9f07-0185-4e74-af39-0d9169146467.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, the sub-generator will ask for our Docker repository name so that Kubernetes
    can use this Docker repository to pull the images (the login username of the Docker
    repository):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/790e7e6e-b79a-4597-b13c-bf30de057917.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, the sub-generator will ask for our command so that we can push the image
    to the Docker repository. We will select the default command here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88656422-6281-4981-b5bd-97288393c255.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, it will ask whether we need the JHipster-console for log aggregation,
    and we will select Yes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce7f95fc-1224-4c69-a2f7-7795416c4b4a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'JHipster also comes with Prometheus integration, so the next question will
    be whether we would like to export our services to Prometheus. It needs a Prometheus
    operator in general to work. We will select No for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/567e9a6b-7e7f-4da7-a5d1-b3bc246ad0a5.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, the generator will ask us to choose the Kubernetes service type. So, what
    is the service type?
  prefs: []
  type: TYPE_NORMAL
- en: In Kubernetes, everything that we deploy is a pod. These pods are managed by
    replication controllers, which can create and destroy any pods. Each pod needs
    an identifier, so they are tagged with an IP address. This dynamic nature of pods
    will lead to a lot of problems for other pods that depend on them. To come up
    with a solution for this problem, Kubernetes introduced services. Services are
    nothing but a logical grouping of unique pods which have policies attached to
    them. These policies are applicable for all the pods inside the services, but
    we need to publish these services to the external world to access them.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most powerful features of Kubernetes is that they help to maintain
    the number of replicas of pods consistently.  The replication controller helps
    to maintain the pods count by automatically shutting down and booting up the pods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes gives us four different service types, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Cluster IP`: This is the default type. This will assign the cluster''s internal
    IP and make it visible within the cluster itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NodePort`: This will expose the service to a static port in the Node''s IP.
    The port will be random and will be chosen between `30000`-`32767`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoadBalancer`: This will expose the service externally. Kubernetes will assign
    an IP automatically. This will create a route to the NodePort and Cluster IP internally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ingress`: An Ingress is a special option that Kubernetes provides. This will
    provide load-balancing, SSL termination, and name-based virtual hosting to the
    services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will select the `LoadBalancer` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dce399ad-02ea-4fdc-9036-2275152bb2f0.png)'
  prefs: []
  type: TYPE_IMG
- en: That's it. This will generate the necessary configuration files for us to deploy
    the application with Kubernetes. Next up, we will check the files that have been
    generated.
  prefs: []
  type: TYPE_NORMAL
- en: Walking through the generated files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The files generated by JHipster are in the following structure. That is, each
    application will have its own folder and the files related to that service will
    be present inside it.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with the gateway application. There will be three generated files,
    which will be the `gateway-service`, `gateway-mysql`, and `gateway-deployment.yml`
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `gateway-service.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first line defines the API version of Kubernetes, followed by the kind of
    template or object that this template carries. This template will have a service
    inside of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we will have the metadata information. Kubernetes uses this metadata
    information to group certain services together. In the metadata, we can define:'
  prefs: []
  type: TYPE_NORMAL
- en: The service name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The namespace it belongs to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The labels, which are key and value pairs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we will define the spec. The spec in the Kubernetes object will provide
    the state of the service. In the spec, we can define the number of replicas we
    need. We can also define the selector, within which we can specify the service
    with identifiers. We can also specify the type of the service. Kubernetes will
    take the information from this spec and then maintain the application in the state
    provided (we will have a look at the spec gateway in a while), followed by the
    ports in which port the application should run. This is similar to the Dockerfile,
    so we are exposing the `8080` port for the gateway service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have the `gateway-mysql.yml` file, where we have defined our MySQL
    server for the gateway application. The difference here is that the spec points
    to `gateway-mysql`, which is defined in the same file and is exposed on port `3306`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the `gateway-mysql` app declaration, we have specified the database and environment
    properties that are needed for our application to run. Here, the `kind` is mentioned
    as **deployment**. The job of the deployment object is to change the state of
    the services to the state that is defined in the deployment object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have defined a single replica of the MySQL server, followed by the
    spec, where we have mentioned the version of MySQL that we need (the container).
    This is then followed by the username, password, and then the database schema.
    We can also specify the volume information with volume mounts for persistent storage:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: we can also define a spec inside a spec object (as shown in the following
    code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we have `gateway-deployment.yml`, in which we have defined the gateway
    application and its environment properties along with the other details like ports,
    probes and so on.
  prefs: []
  type: TYPE_NORMAL
- en: A similar approach is done for both the invoice and notification services. You
    can find them in their respective folders.
  prefs: []
  type: TYPE_NORMAL
- en: In `JHipster-registry`, alongside `Service` and `Deployment`, we have defined
    Secret and StatefulSet.
  prefs: []
  type: TYPE_NORMAL
- en: The secret is used to handle passwords. It will be an opaque type and the password
    is base64 encoded.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have the StatefulSet, which are similar to pod except they have a sticky
    identity. Pods are dynamic in nature. These pods have a persistent identifier
    that is maintained throughout. It makes sense for a registry server to be defined
    as a StatefulSet, since it is essential that the registry server should be identified
    by a persistent identifier. This enables all services to connect to that single
    endpoint and get the necessary information. If the registry server is down, then
    communication between the services will also have problems, since the services
    connect to other services via the registry server.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various options that are available to set the controller, which are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Replica Set**: Provides a replica of pods at any time with selectors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Replica Controller**: Provides a replica of pods without any selectors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**StatefulSet**: Makes the pod unique by providing it with a persistent identifier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DaemonSet**: Provides a copy of the pod which is going to be run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JHipster Registry is configured in a cluster and with high availability.
    The UI access to the JHipster Registry is also restricted to the cluster for better
    security.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, configuration files are generated for the JHipster Console, and they
    are placed in a console folder, which is `jhipster-console.yml`, where the JHipster
    Console is also defined.
  prefs: []
  type: TYPE_NORMAL
- en: The JHipster Console runs on an ELK stack, so we need Elasticsearch, which is
    defined in `jhipster-elasticsearch.yml`, followed by Logstash in the `jhipster-logstash.yml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the application to Google Cloud with Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created Kubernetes configuration files with the `jhipster kubernetes` command.
    The next step is to build the artifacts and deploy them into Google Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes will use the image from the Docker Registry. We configured the Docker
    username when we generated the application, so the first step will be to tag those
    images and then push them to our Docker repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will open the terminal and go to the Kubernetes folder that we have generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And we will push this image into the Docker repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: you have to log in to the Docker Hub before pushing the image. You can
    login to Docker using the `docker login` command followed by your username and
    password. If you don''t have an account, you can create one at the following link: [https://cloud.docker.com/](https://cloud.docker.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, push the invoice application to the Docker repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Do the same for notification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will push gateway, invoice, and notification to the Docker repository.
    We can check this in the Docker console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87c9e9ec-e51d-4afd-babb-c1516fb83679.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we can connect to gcloud and deploy our containers with Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: This assumes that you have set up gcloud SDK and kubectl on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will log in to the gcloud via the Terminal. In order to do that,
    open your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Then, gcloud will ask you to log in to your google account. Once validated,
    this will list the projects that you might already have.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can choose [31] Create a new projectby entering the number before creating
    a new project. Then, press enter. It will ask you to enter the project information
    and then configure a few Google services for that project. Then, gcloud will list
    all the available regions and you can choose a region that suits you.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have already logged in to the console and used it for other projects,
    then you can switch projects using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will set the project, region, and the setting chosen as the default.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you have to enable Kubernetes in our application. We can do this by logging
    in to our Google Cloud console via the browser. Then, select the project that
    we have just created and go to [https://console.cloud.google.com/kubernetes/list](https://console.cloud.google.com/kubernetes/list).
  prefs: []
  type: TYPE_NORMAL
- en: 'This will create a cluster for your project. Instead, you can create a cluster
    using the `gcloud` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cdb14c70-6bc6-4eb2-b6f6-453e482c0ef0.png)'
  prefs: []
  type: TYPE_IMG
- en: Thus, the cluster is created with 3 nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can go to our Kubernetes folder and start deploying the services using
    kubectl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d26a63b8-7c32-4fe8-9aab-f8ccb30161ab.png)'
  prefs: []
  type: TYPE_IMG
- en: This will create all the applications in the Google Cloud environment, under
    your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check the `pods` deployment process using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This will list down the `pods` that are spinning up and shutting down:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4332800-c6e5-4cba-b901-dcd6ff5c92e7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also get the logs of the application using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f2ffa96-cec5-443b-9835-f62b3f23f5fb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can get the application''s external IP using this piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will list the application''s name, type, IP address, external address,
    ports, and uptime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b2ec1cb-3981-4381-9115-a3f4d12a4920.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can find the same information on the Google Cloud console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f39f95d-c307-48c9-b277-f4e69cf3d4bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The application can be accessed at the preceding External-IP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bfe0972c-578b-462a-8f83-d56110c76a89.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also scale the application by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The JHipster-registry is deployed in headless mode. In order to check the JHipster
    registry, we can explicitly expose the service by using this command—`**kubectl
    expose service jhipster-registry --type=NodePort --name=exposed-registry**`—and
    then we can access the application via `exposed-registry`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Orchestrating your containers is the most difficult task to perform in the microservices
    environment. Kubernetes, as a container orchestrator, stands out in solving this.
    We have seen how to generate the configuration file for Kubernetes with JHipster,
    followed by deploying the application to the Google Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've seen how we can develop and deploy an e-commerce application using
    JHipster. We started with a monolith and we successfully scaled it into a microservice
    architecture, all with the help of JHipster and the various tools and technologies
    it supports. With this chapter, our journey of developing the e-commerce web application
    comes to an end and we hope you had a wonderful experience following it though.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how you can use JHipster further to create
    an application with a React client-side application, so stay tuned.
  prefs: []
  type: TYPE_NORMAL
