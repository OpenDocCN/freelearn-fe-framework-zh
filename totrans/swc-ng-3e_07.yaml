- en: Working with the Angular Router and Forms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Angular 路由和表单进行工作
- en: By now, we're already familiar with the core of the framework. We know how to
    define components and directives in order to develop the view of our applications.
    We also know how to encapsulate business-related logic into services and wire
    everything together with the DI mechanism of Angular.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经熟悉了框架的核心。我们知道如何定义组件和指令来开发我们应用程序的视图。我们还知道如何将业务逻辑封装到服务中，并使用 Angular
    的 DI 机制将一切连接起来。
- en: 'In this chapter, we''ll explain a few more concepts that will help us build
    real-life Angular applications. They are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释一些将帮助我们构建真实 Angular 应用程序的概念。它们如下：
- en: The component-based router of the framework
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架的基于组件的路由
- en: Using Angular's forms module
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Angular 的表单模块
- en: Developing custom form validators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发自定义表单验证器
- en: Developing template-driven forms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发模板驱动表单
- en: Let's begin!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Developing the "Coders repository" application
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发 "Coders repository" 应用程序
- en: Throughout the process of explaining the listed concepts, we'll develop a sample
    application that contains a repository of developers. Before we start coding,
    let's discuss the structure of the application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释列出的概念的过程中，我们将开发一个包含开发者库的示例应用程序。在我们开始编码之前，让我们讨论应用程序的结构。
- en: The "Coders repository" will allow its users to add developers, either by filling
    a form with details about them or by providing the GitHub handle for the developer
    and importing their profile from GitHub.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '"Coders repository" 将允许其用户通过填写包含他们详细信息的表单或提供开发者的 GitHub 处理程序并从 GitHub 导入他们的资料来添加开发者。'
- en: For the purpose of this chapter, we will store information about the developers
    in memory, which means that after the page is refreshed, we'll lose all the data
    stored during the session.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本章的目的，我们将把开发者的信息存储在内存中，这意味着在页面刷新后，我们将丢失会话期间存储的所有数据。
- en: 'The application will have the following views:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将具有以下视图：
- en: A list of all the developers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有开发者的列表
- en: A view for adding or importing new developers
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于添加或导入新开发者的视图
- en: 'A view that shows the given developer''s details. This view has two subviews:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显示给定开发者详细信息的视图。这个视图有两个子视图：
- en: '**Basic details**: Shows the name of the developer and their GitHub avatar
    if available'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本详情**：显示开发者的姓名以及如果有的话他们的 GitHub 头像'
- en: '**Advanced profile**: Shows all the details known of the developer'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级资料**：显示开发者所知的所有详细信息'
- en: 'The end result of the application''s home page will look as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序主页的最终结果将如下所示：
- en: '![](img/eb477887-300a-486a-8df1-e49671acc949.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eb477887-300a-486a-8df1-e49671acc949.png)'
- en: Figure 1
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1
- en: In this chapter, we will build only a few of the listed views. The rest of the
    application will be explained in [Chapter 8](503e1c1c-afb1-4dd4-98e2-657ceb32cc59.xhtml),
    *Explaining Pipes and Communicating with RESTful Services*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将只构建列出的几个视图。应用程序的其余部分将在 [第 8 章](503e1c1c-afb1-4dd4-98e2-657ceb32cc59.xhtml)
    中解释，*解释管道和与 RESTful 服务通信*。
- en: 'Each developer will be an instance of the following class:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个开发者都将是一个以下类的实例：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'All the developers will reside within the `DeveloperCollection` class:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所有开发者都将位于 `DeveloperCollection` 类中：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The classes mentioned here encapsulate a simple business logic and don't have
    anything Angular-specific, so we won't get into any details.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提到的类封装了简单的业务逻辑，没有 Angular 特定的内容，所以我们不会深入细节。
- en: Now, let's continue with the implementation by exploring the new router.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续通过探索新的路由来继续实现。
- en: Exploring the Angular router
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Angular 路由
- en: As we already know, in order to bootstrap any Angular application, we need to
    develop a root NgModule and a bootstrap component. The "Coders repository" application
    is not any different; the only addition in this specific case is that we will
    have multiple pages that need to be connected together with the Angular router.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，为了启动任何 Angular 应用程序，我们需要开发一个根 NgModule 和一个启动组件。 "Coders repository" 应用程序并没有什么不同；在这个特定情况下，唯一的增加是我们将有多页需要通过
    Angular 路由连接在一起。
- en: 'Let''s start with the imports required for the router''s configuration and
    define the root component right after this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从路由配置所需的导入开始，并在下面定义根组件：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding snippet, we import `RouterModule` directly from `@angular/router`;
    as we can see, the router is externalized outside the framework's core. This module
    declares all the routing-specific directives, as well as all the routing-related
    providers, which means that, if we import it, we'll get access to all of them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们直接从 `@angular/router` 导入 `RouterModule`；正如我们所见，路由器被外部化到框架的核心之外。此模块声明了所有与路由相关的指令，以及所有路由相关的提供者，这意味着如果我们导入它，我们将能够访问所有这些。
- en: The `LocationStrategy` class is an abstract class that defines the common logic
    between `HashLocationStrategy`—used for hash-based routing, and `PathLocationStrategy`—used
    for HTML5-based routing by taking advantage of the history API.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocationStrategy` 类是一个抽象类，它定义了 `HashLocationStrategy`（用于基于哈希的路由）和 `PathLocationStrategy`（通过利用历史API用于基于HTML5的路由）之间的共同逻辑。'
- en: '`HashLocationStrategy` does not support server-side rendering, because the
    hash of the page does not get sent to the server. Since the hash is our application''s
    view identifier, the server will not be aware of the page that needs to be rendered.
    Fortunately, all modern browsers except IE9 support the HTML5 history API. You
    can find more about server-side rendering in the final chapter of this book.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashLocationStrategy` 不支持服务器端渲染，因为页面的哈希值不会发送到服务器。由于哈希是应用程序的视图标识符，服务器将不会知道需要渲染的页面。幸运的是，除了
    IE9 之外的所有现代浏览器都支持 HTML5 历史API。你可以在本书的最后一章中找到更多关于服务器端渲染的信息。'
- en: 'Now, let''s define a bootstrap component and configure the application''s root
    module:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个启动组件并配置应用程序的根模块：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding snippet, we can notice a syntax we're already familiar with,
    from [Chapter 5](1b60c28e-5f34-493d-8371-c69968f09020.xhtml), *Getting Started
    with Angular Components and Directives* and [Chapter 6](3ad730a8-f797-4fc1-b908-5a20eeffac23.xhtml),
    *Dependency Injection in Angular*. We define a component with an `app` selector,
    `template`, which we will take a look at later, and sets of providers and directives.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以注意到一个我们已熟悉的语法，来自第 5 章 [入门 Angular 组件和指令](1b60c28e-5f34-493d-8371-c69968f09020.xhtml)和第
    6 章 [Angular 中的依赖注入](3ad730a8-f797-4fc1-b908-5a20eeffac23.xhtml)。我们定义了一个具有 `app`
    选择器的组件，`template`，我们将在稍后查看它，以及提供者和指令的集合。
- en: The `App` component declares a single provider associated with the `DeveloperCollection`
    token. This is the class that contains all of the developers stored by the application.
    Later, we invoke the `forRoot` method of `RouterModule`; this method allows us
    to configure the router by declaring the root routes of the application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`App` 组件声明了一个与 `DeveloperCollection` 标记关联的单个提供者。这是包含所有由应用程序存储的开发者的类。稍后，我们将调用
    `RouterModule` 的 `forRoot` 方法；此方法允许我们通过声明应用程序的根路由来配置路由器。'
- en: Once we have imported the module, returned as a result of the invocation of
    `forRoot`, we already have access to a set of directives. These directives can
    help us link to the other routes defined as part of the router's configuration
    (the `routerLink` directive) and declare the place where the components associated
    with the different routes should be rendered (`router-outlet`). We'll explain
    how we can use them later in this section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们导入了模块，它作为 `forRoot` 方法调用的结果返回，我们就已经可以访问一组指令。这些指令可以帮助我们将链接到路由器配置中定义的其他路由（`routerLink`
    指令）以及声明与不同路由关联的组件应该渲染的位置（`router-outlet`）。我们将在本节稍后解释如何使用它们。
- en: 'Now, let''s take a look at the configuration of our `AppModule` class:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的 `AppModule` 类的配置：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We add a single declaration—the `App` component—that we use for bootstrapping
    the application. Note that, here, we import not only `BrowserModule`, but also
    the result returned from the invocation of the `forRoot` method of `RouterModule`.
    In the `providers` array, we configure the provider for `LocationStrategy`. The
    default `LocationStrategy` implementation, which Angular uses, is `PathLocationStrategy`
    (that is, the HTML5-based one); however, in this case, we will use the hash-based
    one.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个单独的声明——用于启动应用的 `App` 组件。注意，在这里，我们不仅导入了 `BrowserModule`，还导入了 `RouterModule`
    的 `forRoot` 方法的返回结果。在 `providers` 数组中，我们配置了 `LocationStrategy` 的提供者。Angular 使用的默认
    `LocationStrategy` 实现是 `PathLocationStrategy`（即基于 HTML5 的一个）；然而，在这种情况下，我们将使用基于哈希的。
- en: When we have to choose between the two location strategies, we should bear in
    mind that the default location strategy (`PathLocationStrategy`) is supported
    by the server-rendering module of Angular, and the URL of the application looks
    more natural to the end user (there's no `#` used). On the other hand, if we use
    `PathLocationStrategy`, we may need to configure our application server in order
    to work with the HTML5 history API, which is not necessary for `HashLocationStrategy`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不得不在两种位置策略之间进行选择时，我们应该记住，默认的位置策略（`PathLocationStrategy`）由Angular的服务器端渲染模块支持，并且应用程序的URL对最终用户来说看起来更自然（没有使用`#`）。另一方面，如果我们使用`PathLocationStrategy`，我们可能需要配置我们的应用程序服务器以与HTML5历史API一起工作，这对于`HashLocationStrategy`是不必要的。
- en: Using PathLocationStrategy
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PathLocationStrategy
- en: 'The `PathLocationStrategy` class uses `APP_BASE_HREF`, which, by default, has
    the `"/"` string as a value. This means that, in case the base pathname of our
    application is different, we must set it explicitly in order to have a properly
    functioning routing. For instance, in our case, the configuration should look
    as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`PathLocationStrategy`类使用`APP_BASE_HREF`，默认情况下其值为`"/"`。这意味着，如果我们的应用程序的基本路径名不同，我们必须明确设置它，以便正确地实现路由功能。例如，在我们的情况下，配置应如下所示：'
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, `APP_BASE_HREF` represents the base path of the application. For instance,
    in our case, the "Coders repository" will be located under the `/dist/dev/ch7/multi-page-template-driven/`
    directory (or, if we include the schema and the host, `http://localhost:5555/dist/dev/ch7/multi-page-template-driven/`).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`APP_BASE_HREF`代表应用程序的基本路径。例如，在我们的情况下，“Coders repository”将位于`/dist/dev/ch7/multi-page-template-driven/`目录下（或者，如果我们包括方案和主机，`http://localhost:5555/dist/dev/ch7/multi-page-template-driven/`）。
- en: We will need to provide the value of `APP_BASE_HREF` in order to hint to Angular,
    which part of the path is an application route (that is, meaningful for the router).
    For instance, for the `http://localhost:5555/dist/dev/ch7/multi-page-template-driven/home` URL,
    by having `APP_BASE_HREF` equal to `/dist/dev/ch7/multi-page-template-driven/`,
    Angular will know that it needs to provide the component associated with the `home`
    path since the rest of the URL is not relevant to the declared routes within the
    application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提供`APP_BASE_HREF`的值，以便向Angular提示路径的哪一部分是应用程序路由（即对路由器有意义的）。例如，对于`http://localhost:5555/dist/dev/ch7/multi-page-template-driven/home`
    URL，如果`APP_BASE_HREF`等于`/dist/dev/ch7/multi-page-template-driven/`，Angular将知道它需要提供与`home`路径关联的组件，因为URL的其余部分与应用程序中声明的路由无关。
- en: Configuring routes
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置路由
- en: 'As the next step, let''s update the declarations of the routes. Open `ch7/step-0/app.ts`
    and update the invocation of the `forRoot` method of `RouteModule`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，让我们更新路由的声明。打开`ch7/step-0/app.ts`并更新`RouteModule`的`forRoot`方法的调用：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As the preceding snippet shows, the `forRoot` method accepts an array of route
    declarations as an argument. We define two redirects and two routes with components
    associated with them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，`forRoot`方法接受一个路由声明数组作为参数。我们定义了两个重定向和两个与组件关联的路由。
- en: 'Each nonlazy-loaded route must define the following properties:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每个非懒加载的路由都必须定义以下属性：
- en: '`component`: The component associated with the given route'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`component`：与给定路由关联的组件'
- en: '`path`: The path to be used for the route—it will be visible in the browser''s
    location bar'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：用于路由的路径——它将在浏览器的地址栏中可见'
- en: 'On the other hand, the redirect''s definition should contain these properties:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，重定向的定义应包含以下属性：
- en: '`path`: The path to be used for the redirection'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：用于重定向的路径'
- en: '`redirectTo`: The path the user will be redirected to'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redirectTo`：用户将被重定向到的路径'
- en: '`pathMatch`: This defines the matching strategy'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pathMatch`：这定义了匹配策略'
- en: In the previous example, we declare that when the user navigates to `/add-dev`,
    we want them to be redirected to `/dev-add`. As we mentioned, `pathMatch` defines
    the path matching strategy. By default, it has the `"prefix"` value, which means
    that the router will try to match the beginning of the current route with the
    `path` property declared in the redirect. In contrast, when we set the `pathMatch`
    property to the `"full"` value, the router will redirect to the `redirectTo` path
    only when the entire path has been matched. It's important to explicitly set `pathMatch`
    to `"full"` in the first redirect, otherwise, every route will match the `""`
    path in case of a match by prefix.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们声明当用户导航到`/add-dev`时，我们希望他们被重定向到`/dev-add`。正如我们提到的，`pathMatch`定义了路径匹配策略。默认情况下，它具有`"prefix"`值，这意味着路由器将尝试将当前路由的开始部分与重定向中声明的`path`属性匹配。相比之下，当我们将`pathMatch`属性设置为`"full"`值时，只有当整个路径匹配时，路由器才会重定向到`redirectTo`路径。在第一个重定向中显式设置`pathMatch`为`"full"`是很重要的，否则，在以前缀匹配的情况下，每个路由都将匹配到`""`路径。
- en: 'Now, in order to make everything work, we will need to define the `AddDeveloper`
    and `Home` components, which are referenced in the router''s configuration. First,
    we will provide a basic implementation that we''ll incrementally extend over time,
    through the course of this chapter. In `ch7/step-0`, let''s create a file called
    `home.ts` and enter the following content:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使一切正常工作，我们需要定义`AddDeveloper`和`Home`组件，这些组件在路由器的配置中被引用。首先，我们将提供一个基本的实现，我们将在本章的进程中逐步扩展它。在`ch7/step-0`中，让我们创建一个名为`home.ts`的文件，并输入以下内容：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, open the file called `add_developer.ts`, and enter the following content
    in it:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开名为`add_developer.ts`的文件，并在其中输入以下内容：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Do not forget to import the `Home` and `AddDeveloper` components in `app.ts`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在`app.ts`中导入`Home`和`AddDeveloper`组件。
- en: Using routerLink and router-outlet
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用routerLink和router-outlet
- en: We have the declarations of the routes and all the components associated with
    them. The only thing left is to define the template of the root `App` component
    in order to link everything together.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有路由和所有与之相关的组件的声明。唯一剩下的事情就是定义根`App`组件的模板，以便将一切连接起来。
- en: 'Add the following content to the `template` property inside the `@Component`
    decorator in `ch7/step-0/app.ts`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到`ch7/step-0/app.ts`中`@Component`装饰器的`template`属性内：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the template, there are two Angular-specific directives:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，有两个Angular特定的指令：
- en: '`routerLink`: This allows us to add a link to a specific route'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routerLink`：这允许我们向特定路由添加链接'
- en: '`router-outlet`: This defines the container where the components associated
    with the currently selected route should be rendered'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`router-outlet`：这定义了当前选中路由相关组件应该渲染的容器'
- en: Let's take a look at the `routerLink` directive. As value, it accepts an array
    of route paths and parameters. In our case, we provide only a single route path.
    Note that the route name used by `routerLink` is declared by the `path` property
    of the route declaration inside `forRoot`. Later in this book, we'll see how we
    can link to nested routes and pass route parameters.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`routerLink`指令。作为值，它接受一个路由路径和参数的数组。在我们的情况下，我们只提供了一个路由路径。请注意，`routerLink`使用的路由名称是由`forRoot`内部的路由声明中的`path`属性声明的。在本书的后面部分，我们将看到如何链接到嵌套路由并传递路由参数。
- en: This directive allows us to declare links independently from `LocationStrategy`
    that we configured. For instance, imagine we are using `HashLocationStrategy`;
    this means that we will need to prefix all the routes in our templates with `#`.
    In case we switch to `PathLocationStrategy`, we'll need to remove all the hash
    prefixes. This is only a partial benefit of the neat abstraction that `routerLink`
    creates on top of path references.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令允许我们独立于我们配置的`LocationStrategy`声明链接。例如，假设我们正在使用`HashLocationStrategy`；这意味着我们需要在我们的模板中为所有路由添加前缀`#`。如果我们切换到`PathLocationStrategy`，我们需要删除所有的哈希前缀。这仅仅是`routerLink`在路径引用之上创建的整洁抽象的部分好处。
- en: 'The next directive that is new to us from the previous template is `router-outlet`.
    It has a similar responsibility to the `ng-view` directive in AngularJS. Basically,
    they both have the same role: to point out where the target component should be
    rendered. This means that, according to the definition, when the user navigates
    to `/`, the `Home` component will be rendered at the position pointed out by `router-outlet`,
    the same for the `AddDeveloper` component once the user navigates to `dev-add`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一个模板中引入的下一个新指令是`router-outlet`。它具有与AngularJS中的`ng-view`指令相似的责任。基本上，它们都扮演着相同的角色：指出目标组件应该渲染的位置。这意味着根据定义，当用户导航到`/`时，`Home`组件将在`router-outlet`指出的位置渲染，同样，当用户导航到`dev-add`时，`AddDeveloper`组件也会在相同的位置渲染。
- en: 'Now, we have these two routes up and running! Open `http://localhost:5555/dist/dev/ch7/step-0/`,
    and you should see a page which looks similar to the following screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经启动了这两个路由！打开`http://localhost:5555/dist/dev/ch7/step-0/`，你应该会看到一个类似于以下截图的页面：
- en: '![](img/6e3d8485-a8e6-4311-9e6f-6c6cbe4056ec.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e3d8485-a8e6-4311-9e6f-6c6cbe4056ec.png)'
- en: Figure 2
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图2
- en: If you don't, just take a look at `ch7/step-1` that contains the result.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不这样做，只需查看包含结果的`ch7/step-1`。
- en: Lazy-loading with loadChildren
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用loadChildren进行懒加载
- en: AngularJS modules allow us to group together logically-related building units
    of the application. However, by default, they need to be available during the
    initial bootstrap of the application and do not allow deferred loading. This requires
    downloading the entire code base of the application during the initial page load
    that, in case of large single-page apps, can be an unacceptable performance hit.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS模块允许我们将应用中逻辑相关的构建单元组合在一起。然而，默认情况下，它们需要在应用的初始引导阶段可用，并且不允许延迟加载。这意味着在初始页面加载时需要下载整个应用代码库，这在大型单页应用的情况下可能会导致不可接受的性能影响。
- en: In a perfect scenario, we would want to load only the code associated with the
    page the user is currently viewing or to prefetch bundled modules based on heuristics
    related to the user's behavior, which is beyond the scope of this book. For instance,
    open the application from the first step of our example, `http://localhost:5555/dist/dev/ch7/step-1/`.
    Once the user is at `/`, we only need the `Home` component to be available, and
    once they navigate to `dev-add`, we want to load the `AddDeveloper` component.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个完美的场景中，我们希望只加载用户当前查看的页面的代码，或者根据与用户行为相关的启发式方法预取捆绑模块，但这超出了本书的范围。例如，从我们的示例的第一个步骤打开应用，`http://localhost:5555/dist/dev/ch7/step-1/`。一旦用户到达`/`，我们只需要`Home`组件可用，一旦他们导航到`dev-add`，我们希望加载`AddDeveloper`组件。
- en: 'Let''s inspect what is actually going on in Chrome DevTools:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Chrome DevTools中检查实际发生的情况：
- en: '![](img/72667ce4-8def-4017-a66a-249b40950eaf.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72667ce4-8def-4017-a66a-249b40950eaf.png)'
- en: Figure 3
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图3
- en: We can notice that during the initial page load, Angular downloads the components
    associated with all the routes, even `AddDeveloper`, which is not required. This
    happens because, in `app.ts`, we explicitly require both the `Home` and `AddDeveloper`
    components, and use them in the declarations of the routes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注意到，在初始页面加载期间，Angular下载了与所有路由关联的组件，甚至包括不需要的`AddDeveloper`组件。这是因为，在`app.ts`中，我们明确地要求了`Home`和`AddDeveloper`组件，并在路由的声明中使用它们。
- en: In this specific case, loading both components may not seem like a big problem
    because, at this step, they are pretty lean and do not have any dependencies.
    However, in real-life applications, they will have imports of other directives,
    components, pipes, services, or even third-party libraries. Once any of the components
    is required, its entire dependency graph will be downloaded, even if the component
    is not needed at that point.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定情况下，加载这两个组件可能看起来不是什么大问题，因为在这个阶段，它们非常精简，没有任何依赖。然而，在实际应用中，它们将导入其他指令、组件、管道、服务，甚至第三方库。一旦任何组件被要求，它的整个依赖图都将被下载，即使此时该组件并不需要。
- en: 'The router of Angular comes with a solution to this problem:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的路由器提供了一个解决方案来解决这个问题：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The declaration of the lazy-loaded routes is an object with the following properties:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载路由的声明是一个具有以下属性的对象：
- en: '`loadChildren`: A string that points to the path of the lazy-loaded module'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadChildren`: 一个指向懒加载模块路径的字符串'
- en: '`path`: The path of the route'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`: 路由的路径'
- en: Once the user navigates to a route that matches any of the definitions of the
    lazy-routes, a module loader (by default, SystemJS) will download the module from
    the location provided by `loadChildren`. When the promise returned by the loader
    is resolved with a value of the target module, the module will be cached and its
    bootstrap component will be rendered. The next time the user navigates to the
    same route, the cached module will be used, so the routing module won't download
    the same component twice.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户导航到与任何懒加载路由定义匹配的路由，模块加载器（默认为 SystemJS）将从 `loadChildren` 提供的位置下载模块。当加载器返回的承诺解析为目标模块的值时，模块将被缓存，其引导组件将被渲染。下次用户导航到相同的路由时，将使用缓存的模块，因此路由模块不会下载相同的组件两次。
- en: Note the `#` symbol in the value of the `loadChildren` property. If we split
    the string by the `#` symbol, its first part will be the module's URL and its
    second part will be the name of the export that represents the Angular module
    the router will use for the route. If we don't provide a module name, Angular
    will use the default export.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `loadChildren` 属性值中的 `#` 符号。如果我们通过 `#` 符号拆分字符串，其第一部分将是模块的 URL，其第二部分将是代表路由器将用于路由的
    Angular 模块的导出名称。如果我们不提供模块名称，Angular 将使用默认导出。
- en: The previous example uses `loadChildren`, which, by default, loads modules with
    SystemJS. You can use a more advanced configuration and a custom module loader.
    For further information, take a look at the Angular documentation at [http://angular.io](http://angular.io).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例使用 `loadChildren`，默认情况下，使用 SystemJS 加载模块。您可以使用更高级的配置和自定义模块加载器。有关更多信息，请参阅
    Angular 文档[http://angular.io](http://angular.io)。
- en: Prefetching of the lazy-loaded routes
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒加载路由的预取
- en: As we have already mentioned, in the perfect scenario, we would want to download
    only the minimum set of resources that the user needs at a given time. For instance,
    if the user visits the home page, we'd want to download only the bundle that corresponds
    to the home module (that is, `HomeModule`).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，在理想情况下，我们希望下载用户在特定时间需要的最小资源集。例如，如果用户访问主页，我们只想下载对应于主页模块（即 `HomeModule`）的包。
- en: Later, when the user navigates to `dev-add`, the router will need to download
    `AddDeveloperModule`. Although, this way, the user will consume network bandwidth
    only for the assets they use, the user experience will be far from perfect because
    of the slowdown that happens while navigating to as yet unvisited pages.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，当用户导航到 `dev-add` 时，路由器将需要下载 `AddDeveloperModule`。尽管如此，由于导航到尚未访问的页面时发生的减速，用户将只消耗他们使用的网络带宽，用户体验将远非完美。
- en: 'In order to handle this problem, we can add a route preloading strategy:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个问题，我们可以添加一个路由预加载策略：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding snippet, we declare that we want to use the default `preloadingStrategy`
    abstract class that Angular provides. As a result, when the user opens `home`
    and `HomeModule` is successfully downloaded, the router will automatically start
    prefetching all the other routes. So, next time, when the user navigates to a
    different page, it will most likely be already available in-memory. This will
    introduce a neat improvement to the user experience at almost no cost.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们声明我们想要使用 Angular 提供的默认 `preloadingStrategy` 抽象类。因此，当用户打开 `home`
    并且 `HomeModule` 成功下载后，路由器将自动开始预取所有其他路由。所以，下次用户导航到不同的页面时，它很可能已经在内存中可用。这将几乎不花费任何成本地提高用户体验。
- en: By providing a custom implementation of the `PreloadingStrategy` abstract class
    (located in the `@angular/router` package), we can introduce a custom mechanism
    for the prefetching of lazy-loaded modules.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供 `PreloadingStrategy` 抽象类（位于 `@angular/router` 包中）的自定义实现，我们可以为懒加载模块的预取引入自定义机制。
- en: RouterModule.forRoot versus RouterModule.forChild
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RouterModule.forRoot 与 RouterModule.forChild
- en: There are two methods we can invoke using `RouterModule` in order to register
    routes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `RouterModule` 调用两种方法来注册路由。
- en: In case we declare the top-level routes of our application, we need to use `RouterModule.forRoot`.
    This method will register the top-level routes and return the routing module that
    should be imported by the root module of the application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们声明应用程序的顶级路由，我们需要使用 `RouterModule.forRoot`。此方法将注册顶级路由，并返回应该由应用程序的根模块导入的路由模块。
- en: If we want to define routes in a lazy-loaded module and import the module returned
    by the invocation of the `forRoot` method, we'll get a runtime error. This is
    because the `forRoot` method will return a module with providers, which should
    be imported only once, by the top-level module. In order to register nested routes
    in a lazy-loaded module, we will need to use the `forChild` method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在懒加载模块中定义路由并导入 `forRoot` 方法调用的模块，我们将得到一个运行时错误。这是因为 `forRoot` 方法将返回一个包含提供者的模块，这些提供者应该只由顶级模块导入一次。为了在懒加载模块中注册嵌套路由，我们需要使用
    `forChild` 方法。
- en: We'll take a further look at how we can define nested routes in [Chapter 8](503e1c1c-afb1-4dd4-98e2-657ceb32cc59.xhtml),
    *Explaining Pipes and Communicating with RESTful Services.*
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 8 章 [解释管道和与 RESTful 服务通信](503e1c1c-afb1-4dd4-98e2-657ceb32cc59.xhtml)中进一步探讨如何定义嵌套路由。
- en: As a rule of thumb, we can remember that `RouterModule.forRoot` is meant for
    the registration of top-level routes, and `RouterModule.forChild` should be used
    only for the registration of nested routes in a lazy-loaded module.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项经验法则，我们可以记住 `RouterModule.forRoot` 是用于注册顶级路由的，而 `RouterModule.forChild`
    应仅用于在懒加载模块中注册嵌套路由。
- en: Using Angular's forms module
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Angular 的表单模块
- en: Now, let's continue with the implementation of the application. For the next
    step, we'll work on the `AddDeveloper` and `Home` components. You can continue
    your implementation by extending what you currently have in `ch7/step-0`, or if
    you haven't reached step 1 yet, you can keep working on the files in `ch7/step-1`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续应用程序的实现。对于下一步，我们将处理 `AddDeveloper` 和 `Home` 组件。你可以通过扩展当前在 `ch7/step-0`
    中的内容来继续你的实现，或者如果你还没有达到步骤 1，你可以继续在 `ch7/step-1` 中的文件上工作。
- en: 'Angular offers two ways of developing forms with validation:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 提供了两种带有验证的开发表单的方式：
- en: '**A template-driven approach**: This provides a declarative API where we declare
    the validations into the template of the component'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板驱动方法**：这提供了一个声明式 API，其中我们将验证声明到组件的模板中'
- en: '**A model-driven approach (also known as reactive forms)**: This provides an
    imperative, reactive API'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型驱动方法（也称为响应式表单）**：这提供了一个命令式、响应式的 API'
- en: Let's start with the template-driven approach for now and explore the model-driven
    approach in the next chapter.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从模板驱动方法开始，并在下一章中探索模型驱动方法。
- en: Developing template-driven forms
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发模板驱动表单
- en: Forms are essential for each **Create Retrieve Update and Delete** (**CRUD**)
    application. In our case, we want to build a form for entering the details of
    the developers we want to store.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 表单对于每个 **创建、检索、更新和删除**（**CRUD**）应用程序都是必不可少的。在我们的案例中，我们想要构建一个表单来输入我们想要存储的开发者的详细信息。
- en: 'By the end of this section, we''ll have a form that allows us to enter the
    real name of a given developer, to add their preferred technology, enter their
    email, and declare whether they are popular in the community or not yet. The end
    result will look as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，我们将有一个表单，允许我们输入指定开发者的真实姓名，添加他们偏好的技术，输入他们的电子邮件，并声明他们是否在社区中受欢迎或尚未。最终结果如下所示：
- en: '![](img/d99fcff0-d7ba-4a13-89d3-64a803b03b09.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d99fcff0-d7ba-4a13-89d3-64a803b03b09.png)'
- en: Figure 4
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4
- en: 'Add the following import to `app.ts`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下导入添加到 `app.ts` 文件中：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The next thing we need to do is import `FormsModule` in our `AppModule` class.
    The `FormsModule` class contains a set of predefined directives for managing Angular
    forms, such as the `form` and `ngModel` directives. The `FormsModule` class also
    declares an array with a predefined set of form-related providers that we can
    use in our application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要做的是在 `AppModule` 类中导入 `FormsModule`。`FormsModule` 类包含一组用于管理 Angular 表单的预定义指令，例如
    `form` 和 `ngModel` 指令。`FormsModule` 类还声明了一个数组，其中包含一组预定义的与表单相关的提供者，我们可以在应用程序中使用这些提供者。
- en: 'After the import of the `FormsModule` class, our `app.ts` file will look like
    this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入 `FormsModule` 类之后，我们的 `app.ts` 文件将看起来像这样：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, update the `AddDeveloper` implementation to the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更新 `AddDeveloper` 的实现如下：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `developer` property contains the information associated with the current
    developer that we're adding with the form. The last two properties, `errorMessage`
    and `successMessage`, will be used to display the current form's error or success
    messages, respectively, once the developer has been successfully added to the
    developers collection, or when an error has occurred.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`developer`属性包含与我们通过表单添加的当前开发者的相关信息。最后两个属性，`errorMessage`和`successMessage`，将用于在开发者成功添加到开发者集合或发生错误时显示当前表单的错误或成功消息。'
- en: Digging into the markup of the template-driven form
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解模板驱动的表单的标记
- en: 'As the next step, let''s create the template for the `AddDeveloper` component
    (`step-1/add_developer.html`). Add the following content to the file:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，让我们为`AddDeveloper`组件创建模板（`step-1/add_developer.html`）。将以下内容添加到文件中：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These two elements are intended to display the error and success messages when
    we add a new developer. They will be visible when `errorMessage` or `successMessage`
    have nonfalsy values (that is, something different from the empty string, `false`,
    `undefined`, `0`, `NaN`, or `null`).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个元素旨在在我们添加新开发者时显示错误和成功消息。当`errorMessage`或`successMessage`具有非空值（即，不同于空字符串、`false`、`undefined`、`0`、`NaN`或`null`）时，它们将是可见的。
- en: 'Now, let''s develop the actual form:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来开发实际的形式：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We declare a new form using the HTML `form` tag. Once Angular finds such tags
    in a template with an included form directive in the parent component, it will
    automatically enhance its functionality in order to be used as an Angular form.
    Once the form is processed by Angular, we can apply form validation and data bindings.
    After this, using `#f="ngForm"`, we define a local variable in template, which
    allows us to reference to the form using the `f` identifier. The last thing left
    from the form element is the submit event handler. We use a syntax that we're
    already familiar with, `(ngSubmit)="expr"`; in this case, the value of the expression
    is the call of the `addDeveloper` method defined in the component's controller.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用HTML `form`标签声明一个新的表单。一旦Angular在模板中找到这样的标签，并且父组件中包含了一个表单指令，它将自动增强其功能，以便用作Angular表单。一旦表单被Angular处理，我们就可以应用表单验证和数据绑定。之后，使用`#f="ngForm"`，我们在模板中定义一个局部变量，这允许我们使用`f`标识符引用表单。表单元素最后剩下的就是提交事件处理器。我们使用我们已熟悉的语法，`(ngSubmit)="expr"`；在这种情况下，表达式的值是调用组件控制器中定义的`addDeveloper`方法。
- en: Now, let's take a look at the `div` element with the `control-group` class name.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看具有`control-group`类名的`div`元素。
- en: Note that this is not an Angular-specific class; it is a CSS class defined by
    Bootstrap that we use in order to provide a better look and feel to the form.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这并不是一个Angular特定的类；这是一个由Bootstrap定义的CSS类，我们使用它来为表单提供更好的外观和感觉。
- en: Inside the `div` element, we can find a `label` element that doesn't have any
    Angular-specific markup and an input element that allows us to set the real name
    of the current developer. We set the control to be of a type text and declare
    its identifier and name equal to `realNameInput`. The `required` attribute is
    defined by the HTML5 specification and is used for validation. Using it on the
    element, we declare that this element is required to have a value. Although the
    `required` attribute is not Angular-specific, Angular will extend its semantics
    by including an Angular-specific validation behavior. This behavior includes setting
    specific CSS classes on the control when its status changes and managing its state,
    which the framework keeps internally.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在`div`元素内部，我们可以找到一个没有Angular特定标记的`label`元素和一个允许我们设置当前开发者的真实姓名的输入元素。我们将控件设置为文本类型，并声明其标识符和名称等于`realNameInput`。`required`属性由HTML5规范定义，用于验证。在元素上使用它，我们声明此元素必须有值。尽管`required`属性不是Angular特定的，但Angular将通过包括Angular特定的验证行为来扩展其语义。这种行为包括在控件状态改变时设置特定的CSS类，并管理其状态，这些状态框架内部保持。
- en: The behavior of the form controls will be enhanced by running validation over
    them when their values change and applying specific classes during the controls
    life cycles. You may be familiar with this from AngularJS, where the form controls
    are decorated with the `ng-pristine`, `ng-invalid`, and `ng-valid` classes and
    so on.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单控件值发生变化时，通过运行验证来增强其行为，并在控件的生命周期中应用特定的类。您可能已经从AngularJS中熟悉了这一点，其中表单控件被装饰了`ng-pristine`、`ng-invalid`和`ng-valid`等类。
- en: 'The following table summarizes the CSS classes that the framework adds to the
    form controls during their life cycle:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了框架在其生命周期中添加到表单控件的CSS类：
- en: '| **Classes** | **Description** |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| **类** | **描述** |'
- en: '| `ng-untouched` | The control hasn''t been visited |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `ng-untouched` | 控件尚未被访问 |'
- en: '| `ng-touched` | The control has been visited |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `ng-touched` | 控件已被访问 |'
- en: '| `ng-pristine` | The control''s value hasn''t been changed |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `ng-pristine` | 控件的值尚未更改 |'
- en: '| `ng-dirty` | The control''s value has been changed |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `ng-dirty` | 控件的值已更改 |'
- en: '| `ng-valid` | All the validators attached to the control detected that the
    value is valid |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `ng-valid` | 控件上附加的所有验证器都检测到值是有效的 |'
- en: '| `ng-invalid` | Any of the validators attached to the control detected that
    the value is invalid |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `ng-invalid` | 控件上附加的任何验证器都检测到值是无效的 |'
- en: 'According to this table, we can define that we want all the input controls
    with an invalid value to have a red border in the following way:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 根据此表，我们可以定义我们希望所有具有无效值的输入控件在以下方式下具有红色边框：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The exact semantics behind the preceding CSS in the context of Angular is that
    we use a red border for all the input elements whose values were changed and are
    invalid according to the validators attached to them.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular的上下文中，上述CSS的确切语义是，我们使用红色边框表示所有值已更改且根据附加的验证器无效的输入元素。
- en: Now, let's explore how we can attach validation behavior to our controls.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索如何将验证行为附加到我们的控件上。
- en: Using the built-in validators
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内置验证器
- en: 'We have already seen that we can alter validation behavior to any control using
    the `required` attribute. Angular provides two more built-in validators, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，我们可以使用`required`属性更改任何控件的验证行为。Angular提供了两个更多内置验证器，如下所示：
- en: '`minlength`: This allows us to specify the minimum length of the value that
    a given control should have'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minlength`：这允许我们指定给定控件应具有的最小值长度'
- en: '`maxlength`: This allows us to specify the maximum length of the value that
    a given control should have'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxlength`：这允许我们指定给定控件应具有的最大值长度'
- en: 'These validators are defined with Angular directives and can be used in the
    following way:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些验证器是用Angular指令定义的，可以按以下方式使用：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This way, we specify that we want the value of the input to be between `2` and
    `30` characters.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们指定输入的值应在`2`到`30`个字符之间。
- en: Defining custom validators
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义自定义验证器
- en: 'Another data property defined in the `Developer` class is `email`. Let''s add
    an input field for it. Above the Add button in the preceding form, add the following
    markup:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Developer`类中定义的另一个数据属性是`email`。让我们为它添加一个输入字段。在上一个表单的添加按钮上方，添加以下标记：
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can think of the `[(ngModel)]` attribute as an alternative to the `ng-model`
    directive from AngularJS. We will explain it in detail in the *Two-way data binding
    with Angular* section.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`[(ngModel)]`属性视为AngularJS中`ng-model`指令的替代。我们将在*使用Angular进行双向数据绑定*部分中详细解释它。
- en: 'Although Angular provides a set of predefined validators, they are not enough
    for all the various formats our data can live in. Sometimes, we''ll need custom
    validation logic for our application-specific data. For instance, in this case,
    we want to define an email validator. A typical regular expression, which works
    in general cases (but does not cover the entire specification that defines the
    format of the email addresses), looks as follows: `/^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$/`.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Angular提供了一套预定义的验证器，但它们不足以满足我们数据可能存在的所有各种格式。有时，我们需要为特定于应用程序的数据定义自定义验证逻辑。例如，在这种情况下，我们想要定义一个电子邮件验证器。一个典型的正则表达式，在一般情况下有效（但并不涵盖定义电子邮件地址格式的整个规范），如下所示：`/^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$/`。
- en: 'In `ch7/step-1/email_validator.ts`, define a function that accepts an instance
    of Angular control as an argument and returns `null` if the control''s value is
    empty or matches the regular expression mentioned earlier, and `{ ''invalidEmail'':
    true }` otherwise:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '在`ch7/step-1/email_validator.ts`中，定义一个函数，该函数接受Angular控件实例作为参数，如果控件值是空的或与前面提到的正则表达式匹配，则返回`null`，否则返回`{
    ''invalidEmail'': true }`：'
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, from the `@angular/common` and `@angular/core` modules, import `NG_VALIDATORS`
    and `Directive`, and wrap this validation function within the following directive:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从`@angular/common`和`@angular/core`模块中导入`NG_VALIDATORS`和`Directive`，并将此验证函数包裹在以下指令中：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code, we defined a multiprovider for the `NG_VALIDATORS` token.
    Once we inject the value associated with this token, we'll get an array with all
    the validators attached to the given control (for reference, take a look at the
    section for multiproviders in [Chapter 6](3ad730a8-f797-4fc1-b908-5a20eeffac23.xhtml),
    *Dependency Injection in Angular*).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们为 `NG_VALIDATORS` 令牌定义了一个多提供者。一旦我们注入与该令牌关联的值，我们将得到一个包含所有附加到给定控件（作为参考，请参阅第
    6 章[3ad730a8-f797-4fc1-b908-5a20eeffac23.xhtml]，*Angular 中的依赖注入*）的验证器的数组。
- en: 'There are only two steps left in order to make our custom validation work.
    First, add the `email-input` attribute to the email control:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们的自定义验证生效只剩两个步骤。首先，将 `email-input` 属性添加到电子邮件控件：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, add the directive to the declarations in the `AppModule` class:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将指令添加到 `AppModule` 类的声明中：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We're using an external template for the `AddDeveloper` control. There's no
    ultimate answer to whether a given template should be externalized or inlined.
    Best practice states that we should inline the short templates and externalize
    the longer ones. However, there's no specific definition as to which templates
    are considered short and which are considered long. The decision of whether the
    template should be used inline or put into an external file depends on the developer's
    personal preferences or common conventions within the organization.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用一个外部模板来定义 `AddDeveloper` 控件。关于一个给定的模板是否应该外部化或内联，没有最终的答案。最佳实践表明，我们应该内联短模板，并将长模板外部化。然而，没有具体的定义来说明哪些模板被认为是短的，哪些被认为是长的。模板是否应该内联使用或放入外部文件，取决于开发者的个人偏好或组织内的通用惯例。
- en: Using select inputs with Angular
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Angular 选择输入
- en: As the next step, we should allow the user of the application to enter the technology
    in which the input developer has the most proficiency. We can define a list of
    technologies and show them in the form as a select input.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，我们应该允许应用程序的用户输入输入开发者最擅长的技术。我们可以定义一个技术列表，并在表单中以选择输入的形式显示它们。
- en: 'In the `AddDeveloper` class, add the `technologies` property:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AddDeveloper` 类中，添加 `technologies` 属性：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, in the template, just above the Add button, add the following markup:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在模板中，在添加按钮上方，添加以下标记：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Just like for the input elements we declared earlier, Angular will add the
    same classes depending on the state of the select input. In order to show a red
    border around the select element when its value is invalid, we will need to alter
    the CSS rules:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前声明的输入元素一样，Angular 会根据选择输入的状态添加相同的类。为了在选择元素值无效时显示红色边框，我们需要修改 CSS 规则：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that inlining all the styles in our components' declaration could be a
    bad practice because, this way, they won't be reusable. What we can do is extract
    all the common styles across our components into separate files. The `@Component`
    decorator has a property called `styleUrls` of the `string[]` type where we can
    add a reference to the extracted styles used by the given component. This way,
    we can inline only the component-specific styles, if required.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，将所有样式内联到我们的组件声明中可能是一种不良做法，因为这样它们就不会是可重用的。我们可以做的是将我们组件之间的所有通用样式提取到单独的文件中。`@Component`
    装饰器有一个名为 `styleUrls` 的属性，其类型为 `string[]`，我们可以添加一个引用，指向给定组件使用的提取样式。这样，如果需要，我们只可以内联组件特定的样式。
- en: Right after this, we declare the name of the control to be equal to `"technology"`
    using `name="technology"`. Using the `required` attribute, we declare that the
    user of the application must specify the technology in which the current developer
    is proficient. Let's skip the `[(ngModel)]` attribute for now and see how we can
    define the options of the `select` element.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们使用 `name="technology"` 声明控件的名称等于 `"technology"`。使用 `required` 属性，我们声明应用程序的用户必须指定当前开发者擅长的技术。现在让我们跳过
    `[(ngModel)]` 属性，看看我们如何定义 `select` 元素的选项。
- en: 'Inside the `select` element, we define the different options using the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `select` 元素内部，我们使用以下方式定义不同的选项：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is a syntax we're already familiar with. We simply iterate over all the
    technologies defined within the `AddDeveloper` class, and for each technology
    we show an `option` element with a value for the technology name.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个我们已经很熟悉的语法。我们只是遍历 `AddDeveloper` 类中定义的所有技术，并为每个技术显示一个具有技术名称值的 `option` 元素。
- en: Using the NgForm directive
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 NgForm 指令
- en: 'We have already mentioned that the form directive enhances the HTML5 form''s
    behavior by adding some additional Angular-specific logic. Now, let''s take a
    step back and take a look at the form that surrounds the input elements:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到，表单指令通过添加一些额外的 Angular 特定逻辑来增强 HTML5 表单的行为。现在，让我们退一步，看看围绕输入元素的表单：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this snippet, we define a new identifier called `f`, which references to
    the form. We can think of the form as a composition of controls; we can access
    the individual controls through the `controls` property of the form. On top of
    this, the form has the **touched**, **untouched**, **pristine**, **dirty**, **invalid**,
    and **valid** properties, which depend on the individual controls defined within
    the form. For example, if none of the controls within the form have been `touched`,
    then the form itself will show `untouched` as its status. However, if any of the
    controls in the form have been `touched` at least once, the form will show its
    status as `touched`. Similarly, the form will be valid only if all its controls
    are valid.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们定义了一个新的标识符 `f`，它引用了表单。我们可以将表单视为控制的一个组合；我们可以通过表单的 `controls` 属性访问单个控制。在此基础上，表单还具有
    **touched**、**untouched**、**pristine**、**dirty**、**invalid** 和 **valid** 属性，这些属性取决于表单内定义的各个控制。例如，如果表单内的控制都没有被
    `touched`，那么表单本身将显示为 `untouched` 状态。然而，如果表单中的任何控制至少被 `touched` 一次，表单将显示其状态为 `touched`。同样，只有当表单的所有控制都有效时，表单才是有效的。
- en: 'In order to illustrate the usage of the `form` element, let''s define a component
    with the `control-errors` selector, which shows the current errors for a given
    control. We can use it in the following way:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 `form` 元素的用法，让我们定义一个具有 `control-errors` 选择器的组件，该组件显示给定控制的当前错误。我们可以按以下方式使用它：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that we've also added the `maxlength` validator to the `realName` control.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还向 `realName` 控制添加了 `maxlength` 验证器。
- en: 'The `control-errors` element has the following attributes:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`control-errors` 元素具有以下属性：'
- en: '`control`: This declares the name of the control we want to show errors for'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`control`：这声明了我们想要显示错误的控制的名称'
- en: '`errors`: This creates a mapping between control error and an error message'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`errors`：这创建了一个控制错误与错误消息之间的映射'
- en: 'Now, create a new file called `control_errors.ts` and add the following imports
    to it:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `control_errors.ts` 的新文件，并将以下导入添加到其中：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In these imports, `NgForm` represents the Angular forms, and `Host` is a parameter
    decorator related to the DI mechanism, which we have already covered in [Chapter
    6](3ad730a8-f797-4fc1-b908-5a20eeffac23.xhtml), *Dependency Injection in Angular*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些导入中，`NgForm` 代表 Angular 表单，而 `Host` 是与 DI 机制相关的参数装饰器，我们已经在 [第 6 章](3ad730a8-f797-4fc1-b908-5a20eeffac23.xhtml)
    中介绍过，即 *Angular 中的依赖注入*。
- en: 'Here is a part of the component''s definition:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是组件定义的一部分：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `ControlErrors` component defines two inputs: `control`, the name of the
    control (the value of the `name` attribute) and `errors`, the mapping between
    an error identifier and an error message; they can be specified by the `control`
    and `errors` attributes of the `control-errors` element, respectively.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`ControlErrors` 组件定义了两个输入：`control`，控制的名称（`name` 属性的值）和 `errors`，错误标识符与错误消息之间的映射；它们分别可以通过
    `control-errors` 元素的 `control` 和 `errors` 属性指定。'
- en: 'For instance, let''s suppose we have the following input:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有以下输入：
- en: '[PRE32]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can declare its associated `control-errors` component using the following
    markup:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下标记来声明其关联的 `control-errors` 组件：
- en: '[PRE33]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Inside the `currentError` getter, in the declaration of the preceding `ControlErrors`
    class, we need to do the following two things:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `currentError` 访问器中，在前面 `ControlErrors` 类的声明中，我们需要做以下两件事：
- en: Find a reference to the component declared with the `control` attribute
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到具有 `control` 属性声明的组件引用
- en: Return the error message associated with any of the errors that make the current
    control invalid
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回与任何使当前控制无效的错误相关的错误消息
- en: 'Here is a snippet that implements this behavior:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个实现此行为的代码片段：
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the first line of the implementation of `currentError`, we get the target
    control using the `controls` property of the injected form. The `controls` property
    is of the `{[key: string]: AbstractControl}` type, where `key` is the name of
    the control we''ve declared with the `name` attribute. Once we have a reference
    to the instance of the target control, we can check whether its status is `touched`
    (that is, whether it has been focused), and if it is, we can loop over all the
    errors within the `errors` property of the instance of `ControlErrors`. The `map`
    function will return an array with either an error message or a `null` value.
    The only thing left to do is to filter all the `null` values and get only the
    error messages. Once we get the error messages for each error, we will return
    the last one by popping it from the `errorMessages` array.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '在`currentError`实现的第 一行，我们使用注入表单的`controls`属性获取目标控件。`controls`属性是`{[key: string]:
    AbstractControl}`类型，其中`key`是我们使用`name`属性声明的控件的名称。一旦我们有了目标控件实例的引用，我们可以检查其状态是否为`touched`（即是否已被聚焦），如果是，我们可以遍历`ControlErrors`实例的`errors`属性中的所有错误。`map`函数将返回一个包含错误消息或`null`值的数组。剩下要做的就是过滤掉所有的`null`值，只获取错误消息。一旦我们获取了每个错误的错误消息，我们将通过从`errorMessages`数组中弹出最后一个来返回它。'
- en: 'The end result should look as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果应该如下所示：
- en: '![](img/623d00e4-2a81-4766-9997-395ed4ad1d12.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/623d00e4-2a81-4766-9997-395ed4ad1d12.png)'
- en: Figure 5
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图5
- en: If you experience any problems during the implementation of the `ControlErrors`
    component, you can take a look at its implementation at `ch7/step-2/control_errors.ts`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在实现`ControlErrors`组件的过程中遇到任何问题，你可以查看其实现，位置在`ch7/step-2/control_errors.ts`。
- en: 'The `hasError` method of every control accepts as an argument an error message
    identifier, which is defined by the corresponding validator. For instance, in
    our example, where we defined the custom email validator, we return the `{ ''invalidEmail'':
    true }` object literal when the input control has an invalid value. If we apply
    the `ControlErrors` component to the email control, its declaration should look
    as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '每个控件的`hasError`方法接受一个错误消息标识符作为参数，该标识符由相应的验证器定义。例如，在我们的例子中，我们定义了自定义的电子邮件验证器，当输入控件具有无效值时，我们返回`{
    ''invalidEmail'': true }`对象字面量。如果我们将`ControlErrors`组件应用于电子邮件控件，其声明应该如下所示：'
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Two-way data binding with Angular
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular的双向数据绑定
- en: 'One of the most famous rumors about Angular was that the two-way data binding
    functionality was removed because of the enforced unidirectional data flow. This
    is not exactly true; the Angular''s form module implements a directive with the
    `[(ngModel)]` selector (we''ll also refer to this directive as `NgModel`, because
    of the name of its controller), which allows us to easily achieve data binding
    in two directions: from the view to the model and from the model to the view.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Angular最著名的谣言之一是双向数据绑定功能被移除，因为强制单向数据流。这并不完全正确；Angular的表单模块实现了一个带有`[(ngModel)]`选择器的指令（我们也将这个指令称为`NgModel`，因为它控制器的名字），这使我们能够轻松实现双向数据绑定：从视图到模型，以及从模型到视图。
- en: 'Let''s take a look at the following simple component:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下简单的组件：
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding example, we import `FormsModule` from the `@angular/common`
    package. Later, in the template, we set the `[(ngModel)]` attribute to `name`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们从`@angular/common`包中导入`FormsModule`。稍后，在模板中，我们将`[(ngModel)]`属性设置为`name`。
- en: At first, the `[(ngModel)]` syntax might seem a little bit unusual. From [Chapter
    5](1b60c28e-5f34-493d-8371-c69968f09020.xhtml), *Getting Started with Angular
    Components and Directives*, we know that the `(eventName)` syntax is used for
    binding to events (or outputs) triggered by a given component. On the other hand,
    we use the `[propertyName]="foobar"` syntax to achieve one-way data binding by
    setting the value of the property (or, in the terminology of the Angular components,
    the input) with the `propertyName` name to the result of the evaluation of the `foobar` expression.
    The `[(ngModel)]` syntax combines both in order to achieve data binding in two
    directions. That's why we can think of it more like a syntax sugar, rather than
    a new concept. One of the main advantages of this syntax compared to AngularJS
    is that we can tell which bindings are one way and which are two way by just looking
    at the template.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`[(ngModel)]`语法可能看起来有点不寻常。从[第5章](1b60c28e-5f34-493d-8371-c69968f09020.xhtml)，《Angular组件和指令入门》，我们知道`(eventName)`语法用于绑定由给定组件触发的事件（或输出）。另一方面，我们使用`[propertyName]="foobar"`语法通过将`propertyName`名称与`foobar`表达式的评估结果设置到属性（或，在Angular组件的术语中，输入）的值来实现单向数据绑定。`[(ngModel)]`语法结合了两者，以实现双向数据绑定。这就是为什么我们可以将其视为一种语法糖，而不是一个新概念。与AngularJS相比，这种语法的主要优势之一是，我们只需查看模板就可以知道哪些绑定是单向的，哪些是双向的。
- en: Another name of the `[(foo)]` syntax is the *banana in a box* or *banana brackets*
    syntax. Inspiration for this name is this paper: *Functional Programming with
    Bananas, Lenses, Envelopes and Barbed Wire* by *Erik Meijer*, *Maarten Fokkinga*,
    and *Ross Paterson* ([http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf](http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf)).
    Just like `(click)` has its canonical syntax `on-click`, and `[propertyName]`
    has its own `bind-propertyName`, the alternative syntax of `[(ngModel)]` is `bindon-ngModel`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`[(foo)]`语法的另一个名称是“盒子里的香蕉”或“香蕉括号”语法。这个名称的灵感来源于这篇论文：Erik Meijer、Maarten Fokkinga和Ross
    Paterson的《Bananas, Lenses, Envelopes and Barbed Wire：Functional Programming》（[http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf](http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf)）。就像`(click)`有它的规范语法`on-click`，`[propertyName]`有自己的`bind-propertyName`，`[(ngModel)]`的替代语法是`bindon-ngModel`。'
- en: 'If you open `http://localhost:5555/dist/dev/ch7/simple-two-way-data-binding/`,
    you will see the following result:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开`http://localhost:5555/dist/dev/ch7/simple-two-way-data-binding/`，你会看到以下结果：
- en: '![](img/a3797fa6-0885-49ff-becd-bf024e5176a8.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a3797fa6-0885-49ff-becd-bf024e5176a8.png)'
- en: Figure 6
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图6
- en: Once the value of the input box is changed, the label below it will be updated
    automatically.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦输入框的值发生变化，其下方的标签将自动更新。
- en: 'We have already used the `[(ngModel)]` directive in the previous snippets.
    For example, we bound to the developer''s email using the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的代码片段中使用了`[(ngModel)]`指令。例如，我们使用以下方式将开发者的电子邮件绑定：
- en: '[PRE37]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This way, the value of the email property of the developer object defined in
    the `AddDeveloper` component's instance will be updated once we change the value
    of the text input.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，一旦我们更改文本输入的值，定义在`AddDeveloper`组件实例中的开发者对象的电子邮件属性值就会更新。
- en: Storing the form data
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储表单数据
- en: 'Let''s have a peek at the interface of the `AddDeveloper` component''s controller
    again:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次浏览一下`AddDeveloper`组件控制器的界面：
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This interface has a field of the `Developer` type, and we bind the form controls
    to its properties using the `NgModel` directive. The class also has a method called
    `addDeveloper`, which is being invoked on the submission of the form. We declare
    this by binding to the `ngSubmit` event using the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此界面有一个`Developer`类型的字段，我们使用`NgModel`指令将其表单控件绑定到其属性。该类还有一个名为`addDeveloper`的方法，该方法在表单提交时被调用。我们通过以下方式绑定到`ngSubmit`事件来声明它：
- en: '[PRE39]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding snippet, we should notice two more things. We got a reference
    to the form using `#f="ngForm"` and bound the disabled property of the button
    to the `!f.form.valid` expression. We have already described the `NgForm` control
    in the previous section; its `valid` property will have a `true` value once all
    the controls within the form have valid values.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们应该注意两个额外的事项。我们通过`#f="ngForm"`获取表单的引用，并将按钮的禁用属性绑定到`!f.form.valid`表达式。我们已经在上一节中描述了`NgForm`控制；一旦表单中的所有控件都具有有效的值，其`valid`属性将具有`true`值。
- en: 'Now, let''s suppose we''ve entered valid values for all the input controls
    in the form. This means that its `submit` button will be enabled. Once we press
    *Enter* or click on the `submit` button, the `addDeveloper` method will be invoked.
    The following is a sample implementation of this method:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们已经为表单中的所有输入控件输入了有效的值。这意味着其`submit`按钮将被启用。一旦我们按下*Enter*或点击`submit`按钮，`addDeveloper`方法将被调用。以下是这个方法的示例实现：
- en: '[PRE40]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Initially, we set the `id` property of the current developer equal to the total
    number of developers in `DeveloperCollection`, plus one. Later, we add the developer
    to the collection and set the value of the `successMessage` property. Right after
    this, we set the property submitted equal to `true`, which will result in hiding
    the form.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们将当前开发者的`id`属性设置为`DeveloperCollection`中开发者的总数加一。稍后，我们将开发者添加到集合中并设置`successMessage`属性的值。紧接着，我们将`submitted`属性设置为`true`，这将导致隐藏表单。
- en: Listing all the stored data
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出所有存储的数据
- en: Now that we can add a new entry to the developers' collection, let's show a
    list of all the developers on the front page of the "Coders repository."
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们可以向开发者集合中添加新条目，那么让我们在“Coders repository”的前页上展示所有开发者的列表。
- en: 'Open the `ch7/step-1/home.ts` file (or step-2, depending on your progress during
    the past section), and enter the following content:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`ch7/step-1/home.ts`文件（或根据上一节中的进度，可能是step-2），并输入以下内容：
- en: '[PRE41]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There is nothing new to us here. We extend the functionality of the `Home` component
    by providing an external template and implementing the `getDevelopers` method,
    which delegates its call to the instance of `DeveloperCollection` that is injected
    in the constructor.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这里对我们来说没有什么新东西。我们通过提供一个外部模板并实现`getDevelopers`方法来扩展`Home`组件的功能，该方法将调用委托给在构造函数中注入的`DeveloperCollection`实例。
- en: 'The template itself uses directives we''re already familiar with:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 模板本身使用我们已经熟悉的指令：
- en: '[PRE42]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We list all the developers as rows within an HTML table. For each developer,
    we check the status of its `popular` flag. If its value is `true`, then for the
    Popular column, we show a span with the text `Yes`, otherwise we set the text
    to `No`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有开发者作为HTML表格中的行列出。对于每个开发者，我们检查其`popular`标志的状态。如果其值为`true`，则在“热门”列中显示带有文本`Yes`的span，否则将文本设置为`No`。
- en: 'When you enter a few developers in the Add developer page and then navigate
    to the home page, you should see a result similar to the following screenshot:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在“添加开发者”页面中输入一些开发者并导航到主页时，你应该看到以下截图类似的结果：
- en: '![](img/cee62104-8348-47cc-94d9-0dc72017e256.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cee62104-8348-47cc-94d9-0dc72017e256.png)'
- en: Figure 7
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图7
- en: You can find the complete implementation of the application at `ch7/multi-page-template-driven`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`ch7/multi-page-template-driven`中找到应用程序的完整实现。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So far, we have explained the basics of routing in Angular. We took a look at
    how we can define different routes and implement the components associated with
    them that are displayed on route change. In order to link to the different routes,
    we introduced `routerLink`, and we also used the `router-outlet` directives for
    pointing out where the components associated with the individual routes should
    be rendered.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经解释了Angular中路由的基础。我们查看如何定义不同的路由并实现与之关联的组件，这些组件在路由更改时显示。为了链接到不同的路由，我们引入了`routerLink`，我们还使用了`router-outlet`指令来指出与单个路由关联的组件应该在哪里渲染。
- en: Another thing we took a look at was the functionality of the Angular forms with
    built-in and custom validation. After this, we explained the `NgModel` directive,
    which provides us with two-way data binding.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还查看了一下Angular表单的内置和自定义验证功能。在此之后，我们解释了`NgModel`指令，它为我们提供了双向数据绑定。
- en: In the next chapter, we will cover how we can develop model-driven forms and
    child and parameterized routes, use the `Http` module, and transform data with
    custom pipes.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何开发模型驱动的表单和子以及参数化路由，使用`Http`模块，以及使用自定义管道转换数据。
