- en: '*Chapter 2*: Using Local and Global States'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：使用局部和全局状态'
- en: React components form a tree structure. In the tree structure, creating a state
    in a whole subtree is straightforward; you would simply create a local state in
    a higher component in a tree and use the state in the component and its child
    components. This is good in terms of locality and reusability and is why it's
    generally recommended to follow this strategy.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: React组件形成一个树结构。在树结构中，在整个子树中创建状态是直接的；您只需在树中的较高组件中创建一个局部状态，并在该组件及其子组件中使用该状态。这在局部性和可重用性方面是好的，这也是为什么通常推荐遵循这种策略的原因。
- en: However, in some scenarios, we have a state in two or more components that are
    far apart in the tree. In such cases, this is where global states come in. Unlike
    local states, global states do not conceptually belong to a specific component,
    and so where we store a global state is an important point to consider.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些场景中，我们在树中相隔甚远的两个或多个组件中有一个状态。在这种情况下，这就是全局状态发挥作用的地方。与局部状态不同，全局状态在概念上不属于特定的组件，因此我们存储全局状态是一个需要考虑的重要点。
- en: In this chapter, we will learn about local states, including some lifting-up
    patterns that may be worth considering. Lifting up is a technique to put information
    higher in the component tree. Then, we will dive into global states and consider
    when to use them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习关于局部状态的知识，包括一些值得考虑的提升模式。提升是一种将信息放在组件树更高的位置的技巧。然后，我们将深入研究全局状态，并考虑何时使用它们。
- en: 'We are going to cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Understanding when to use local states
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解何时使用局部状态
- en: Effectively using local states
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效使用局部状态
- en: Using global states
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用全局状态
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To run the code snippets in this chapter, you need a React environment—for example,
    Create React App ([https://create-react-app.dev](https://create-react-app.dev))
    or CodeSandbox ([https://codesandbox.io](https://codesandbox.io)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码片段，您需要一个React环境——例如，Create React App ([https://create-react-app.dev](https://create-react-app.dev))
    或 CodeSandbox ([https://codesandbox.io](https://codesandbox.io))。
- en: You are expected to have basic knowledge of React and React hooks, especially
    the concept around the component tree ([https://reactjs.org/docs/components-and-props.html](https://reactjs.org/docs/components-and-props.html))
    and the `useState` hook ([https://reactjs.org/docs/hooks-reference.html#usestate](https://reactjs.org/docs/hooks-reference.html#usestate)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 预期您对React和React hooks有基本了解，特别是关于组件树 ([https://reactjs.org/docs/components-and-props.html](https://reactjs.org/docs/components-and-props.html))
    和 `useState` 钩子 ([https://reactjs.org/docs/hooks-reference.html#usestate](https://reactjs.org/docs/hooks-reference.html#usestate))
    的概念。
- en: The code in this chapter is available on GitHub at [https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_02](https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_02).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可在GitHub上找到，地址为 [https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_02](https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_02)。
- en: Understanding when to use local states
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解何时使用局部状态
- en: Before we consider React, let's see how JavaScript functions work. JavaScript
    functions can either be pure or impure. A pure function depends only on its arguments
    and returns the same value as long as the arguments are the same. A state holds
    a value outside arguments, and functions that depend on the state become impure.
    React components are also functions and can be pure. If we use a state in a React
    component, it will be impure. However, if the state is local to the component,
    it doesn't affect other components, and we call this characteristic "contained."
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们考虑React之前，让我们看看JavaScript函数是如何工作的。JavaScript函数可以是纯函数或不纯函数。纯函数只依赖于其参数，只要参数相同，就返回相同的值。状态持有参数之外的价值，依赖于状态的函数变为不纯。React组件也是函数，可以是纯函数。如果我们在一个React组件中使用状态，它将是不纯的。然而，如果状态是组件本地的，它不会影响其他组件，我们称这种特性为“封装”。
- en: In this section, we learn JavaScript functions, and how similar React components
    are to JavaScript functions. We then discuss how a local state is conceptually
    implemented.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习JavaScript函数，以及React组件与JavaScript函数的相似之处。然后，我们将讨论局部状态的概念实现方式。
- en: Functions and arguments
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数和参数
- en: "In JavaScript, a function takes an argument and returns a value. For example,\
    \ here's \La simple function:"
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，一个函数接受一个参数并返回一个值。例如，这里有一个简单的函数：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a pure function that always returns the same value for the same argument.
    It is often the case that pure functions are preferred because their behavior
    is predictable.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个总是为相同的参数返回相同值的纯函数。通常情况下，纯函数更受欢迎，因为它们的行为是可预测的。
- en: 'A function can depend on global variables, such as the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以依赖于全局变量，如下所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `addBase` function works exactly the same as `addOne`, as long as `base`
    isn't changed. However, if at some point we change `base` to `base=2`, it behaves
    differently. This is not a bad thing at all, and it's actually a powerful feature
    as you can change the function behavior from outside. The downside is that you
    can't simply grab the `addBase` function and use it arbitrarily somewhere else
    without knowing it depends on an outside variable. As you can tell, it's a trade-off.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 只要`base`没有改变，`addBase`函数的工作方式与`addOne`完全相同。然而，如果在某个时刻我们将`base`改为`base=2`，它的行为就会不同。这根本不是一件坏事，实际上这是一个强大的特性，因为你可以从外部改变函数的行为。缺点是，如果你不知道它依赖于外部变量，就不能简单地抓取`addBase`函数并在其他地方随意使用。正如你所看到的，这是一个权衡。
- en: 'This is not a preferred pattern if `base` is a **singleton** (a single value
    in memory) because the code becomes less reusable. To avoid the singleton and
    mitigate the downside a little, a more modular approach would be to create a container
    object, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`base`是一个单例（内存中的单个值），则这不是一个首选模式，因为代码的可重用性会降低。为了避免单例并稍微减轻其缺点，可以采用更模块化的方法来创建一个容器对象，如下所示：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is no longer a singleton, and you can create as many containers as you
    want. Unlike having a `base` global variable as a singleton, containers are isolated
    and are more reusable. You can use a container in one part of your code without
    affecting other parts of your code with a different container.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这不再是一个单例，你可以创建任意数量的容器。与使用作为单例的`base`全局变量不同，容器是隔离的，并且更易于重用。你可以在代码的一部分使用一个容器，而不会影响到使用不同容器的代码的其他部分。
- en: 'A small note: although `addBase` in a container is not a mathematically pure
    function, you can get the same result by calling `addBase` if `base` is not changed
    (this characteristic is sometimes called **idempotent**).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 简短说明：尽管容器中的`addBase`不是一个数学上纯函数，但如果`base`没有改变，你可以通过调用`addBase`得到相同的结果（这个特性有时被称为**幂等**）。
- en: React components and props
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React组件和props
- en: React is conceptually a function that converts a state to a **user interface**
    (**UI**). When you code with React, the React component is literally a JavaScript
    function, and its arguments are called props.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: React在概念上是一个将状态转换为**用户界面**（**UI**）的函数。当你用React编码时，React组件实际上是一个JavaScript函数，其参数被称为props。
- en: 'A function component that shows a number will look like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 显示数字的函数组件看起来如下：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This component takes a `number` argument and returns a `number` on screen.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件接受一个`number`参数，并在屏幕上返回一个`number`。
- en: What Is a JSX Element?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是JSX元素？
- en: JSX is a syntax with angle brackets to produce React elements. A React element
    is a data structure to represent a part of the UI. We may refer to React elements
    as JSX elements, especially when React elements are in JSX syntax.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: JSX是一种带有尖括号的语法，用于生成React元素。React元素是一个数据结构，用于表示UI的一部分。我们可能将React元素称为JSX元素，尤其是在React元素使用JSX语法时。
- en: 'Now, let''s make another component that shows a `number + 1`, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建另一个组件，它显示`number + 1`，如下所示：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This component takes `number` and returns the `number + 1`. This behaves exactly
    like `addOne` in the previous section, and this is a pure function. The only differences
    are that the argument is a props object and the return value is in JSX format.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件接受`number`并返回`number + 1`。这与上一节中的`addOne`行为完全相同，这是一个纯函数。唯一的区别是参数是一个props对象，返回值是JSX格式。
- en: Understanding useState for local states
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解useState用于局部状态
- en: 'What if we use `useState` for a local state? Let''s make `base` a state and
    display a `number` that we can add to it, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`useState`来处理局部状态会怎样？让我们将`base`设为状态，并显示一个可以添加到其中的`number`，如下所示：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This function is not technically pure as it depends on `base`, which is not
    in the function arguments.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数在技术上不是纯函数，因为它依赖于`base`，而`base`不在函数参数中。
- en: What does `useState` in `AddBase` do? Let's remind ourselves of `createContainer`
    in the previous section. As `createContainer` returns `base` and `changeBase`,
    `useState` returns `base` and `changeBase` in a tuple (meaning a structure of
    two or more values—in this case, two). We don't explicitly see how `base` and
    `changeBase` are created in this code, but it's conceptually similar.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddBase` 中的 `useState` 做了什么？让我们回顾一下上一节中的 `createContainer`。由于 `createContainer`
    返回 `base` 和 `changeBase`，`useState` 返回一个元组（意味着两个或更多值的结构——在这种情况下，两个）。我们在这个代码中并没有明确看到
    `base` 和 `changeBase` 是如何创建的，但从概念上讲是相似的。'
- en: If we assume the `useState` behavior, meaning it returns `base` unless changed,
    the `AddBase` function is idempotent, as we saw with `createContainer`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设 `useState` 的行为，即除非更改，否则返回 `base`，那么 `AddBase` 函数是幂等的，就像我们看到的 `createContainer`
    一样。
- en: This `AddBase` function with `useState` is contained because `changeBase` is
    only available within the scope of the function declaration. It's impossible to
    change `base` outside the function. This usage of `useState` is a local state,
    and because it's contained and doesn't affect anything outside the component,
    it ensures locality; this usage is preferred whenever appropriate.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个使用 `useState` 的 `AddBase` 函数被包含在内，因为 `changeBase` 只在函数声明的范围内可用。在函数外部无法更改 `base`。这种
    `useState` 的用法是本地状态，因为它被包含并且不影响组件外部的内容，这确保了局部性；在适当的时候，这种用法是首选的。
- en: Limitation of local states
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地状态的限制
- en: When is a local state not appropriate? It isn't appropriate when we want to
    break the locality. In the `AddBase` component example, it's when we want to change
    `base` from a totally different part of the code. If you need to change `state`
    from outside the function component, that's when a global state comes in.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 何时本地状态不合适？当我们想要打破局部性时，它就不合适。在 `AddBase` 组件示例中，这是当我们想要从完全不同的代码部分更改 `base` 时。如果你需要从函数组件外部更改
    `state`，那么全局状态就出现了。
- en: The state variable is conceptually a global variable. A global variable is useful
    to control a JavaScript function's behavior from outside the function. Likewise,
    a global state is useful to control React component behavior from outside the
    component. However, using a global state makes the component behavior less predictable.
    It's a trade-off. We shouldn't use global states more than we need to. Consider
    using local states as a primary means and only use global states for a secondary
    mean. In this sense, it's important to learn how many use cases local states can
    cover.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 状态变量在概念上是一个全局变量。全局变量对于从函数外部控制 JavaScript 函数的行为是有用的。同样，全局状态对于从组件外部控制 React 组件的行为也是有用的。然而，使用全局状态会使组件行为变得不那么可预测。这是一个权衡。我们不应该比需要的时候更多地使用全局状态。考虑将本地状态作为主要手段，并且仅将全局状态作为次要手段。在这种情况下，了解本地状态可以覆盖多少使用案例是很重要的。
- en: In this section, we learned about a local state in React, alongside JavaScript
    functions. Coming up, we will learn some patterns to use local states.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了 React 中的本地状态，以及 JavaScript 函数。接下来，我们将学习一些使用本地状态的模式。
- en: Effectively using local states
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有效使用本地状态
- en: There are some patterns you should know to be able to use a local state effectively.
    In this section, we will learn how to lift states up, which means defining a state
    higher in the component tree, and lifting content up, which means defining a content
    higher in the component tree.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够有效地使用本地状态，你应该知道一些模式。在本节中，我们将学习如何提升状态，这意味着在组件树中定义一个更高的状态，以及提升内容，这意味着在组件树中定义一个更高的内容。
- en: Lifting state up
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升状态
- en: 'Let''s suppose we have two counter components, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个计数器组件，如下所示：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Because there are two separate local states defined in the two components, these
    two counters work separately. In case we want to share the state and make it work
    for a single shared counter, we can create a parent component and lift the state
    up.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在两个组件中定义了两个单独的本地状态，这两个计数器是独立工作的。如果我们想共享状态并使其为一个共享计数器工作，我们可以创建一个父组件并将状态提升上去。
- en: 'Here is an example with a single parent component that contains both `Component1`
    and `Component2` as children and passes props to them:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个包含 `Component1` 和 `Component2` 作为子组件的单个父组件示例，并将属性传递给它们：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Because the count state is defined just once in `Parent`, the state is shared
    between `Component1` and `Component2`. This is still a local state in a component;
    its child components can use the state from the parent component.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于计数状态在 `Parent` 中只定义了一次，因此状态在 `Component1` 和 `Component2` 之间是共享的。这仍然是在组件中的本地状态；其子组件可以使用父组件的状态。
- en: This pattern would work in most use cases with a local state; however, there's
    a slight concern about performance. If we lift up the state, `Parent` will render
    as well as the entire subtree, including all its child components. This may be
    a performance issue in some use cases.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在大多数使用局部状态的场景中都会有效；然而，有一点关于性能的担忧。如果我们提升状态，`Parent` 将会重新渲染，以及整个子树，包括所有子组件。在某些用例中，这可能会成为性能问题。
- en: Lift content up
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升内容向上
- en: With complex component trees, we may have a component that doesn't depend on
    the state we are lifting up.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的组件树中，我们可能有一个不依赖于我们提升的状态的组件。
- en: 'In the following example, we add a new `AdditionalInfo` component to `Component1`
    from the previous example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们向前面示例中的 `Component1` 添加一个新的 `AdditionalInfo` 组件：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If the count is changed, the `Parent` re-renders, and then `Component1`, `Component2`,
    and `AdditionalInfo` re-render too. However, `AdditionalInfo` doesn't have to
    re-render in this case because it doesn't depend on `count`. This is an extra
    re-render that should be avoided if it has an impact on performance.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计数发生变化，`Parent` 会重新渲染，然后 `Component1`、`Component2` 和 `AdditionalInfo` 也会重新渲染。然而，在这种情况下，`AdditionalInfo`
    不必重新渲染，因为它不依赖于 `count`。这是一个额外的重新渲染，如果它对性能有影响，应该避免。
- en: 'To avoid extra re-renders, we can lift up content. In this case, `Parent` re-renders
    with `count`, hence, we create `GrandParent`, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免额外的重新渲染，我们可以提升内容。在这种情况下，`Parent` 组件会随着 `count` 的变化而重新渲染，因此，我们创建 `GrandParent`，如下所示：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `GrandParent` component has `additionalInfo` (a JSX element), which is passed
    down to the children. By doing this, `AdditionalInfo` doesn't re-render when `count`
    changes. This is a technique we should consider not only for performance but also
    for organizing your component tree structure.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`GrandParent` 组件有 `additionalInfo`（一个 JSX 元素），它被传递给子组件。通过这样做，当 `count` 变化时，`AdditionalInfo`
    不会重新渲染。这是一种我们不仅应该考虑性能，还应该考虑组织组件树结构的技巧。'
- en: 'A variant of this is to use `children` props. The following example using `children`
    props is equivalent to the previous example, but with a different coding style:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的变体是使用 `children` 属性。以下使用 `children` 属性的示例与前面的示例等效，但具有不同的编码风格：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`children` is a special prop name that is represented as nested children elements
    in JSX format. If you have several elements to pass, naming your props would fit
    better. It''s mostly a stylistic choice, and developers can take whichever approach
    they prefer.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`children` 是一个特殊的属性名，在 JSX 格式中表示为嵌套的子元素。如果你有多个元素要传递，给属性命名会更好。这主要是一个风格选择，开发者可以采取他们喜欢的任何方法。'
- en: In this section, we learned some patterns to effectively use local states. If
    we lift up states and content properly, we should be able to solve various use
    cases with only local states. Coming up, we will learn how to use global states.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何有效地使用局部状态的一些模式。如果我们正确地提升状态和内容，我们应该能够仅使用局部状态解决各种用例。接下来，我们将学习如何使用全局状态。
- en: Using global states
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用全局状态
- en: In this section, we will learn what a global state is again and when we should
    use it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将再次学习什么是全局状态以及何时应该使用它。
- en: What is a global state?
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是全局状态？
- en: In this book, a global state simply means that it's *not* a local state. If
    a state conceptually belongs to a single component and is encapsulated by the
    component, it is a local state. Hence, if a state doesn't belong to a single component
    and can be used by multiple components, it is a global state.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，全局状态仅仅意味着它**不是**局部状态。如果一个状态在概念上属于单个组件并且被该组件封装，那么它是一个局部状态。因此，如果一个状态不属于单个组件并且可以被多个组件使用，那么它是一个全局状态。
- en: There could be an application-wide local state that all components depend on.
    In this case, the application-wide local state can be seen as a global state.
    In this sense, we can't clearly divide local states and global states. In most
    cases, if you consider where a state conceptually belongs, you can work out whether
    it's local or global.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在一个应用范围内的局部状态，所有组件都依赖于它。在这种情况下，应用范围内的局部状态可以被视为全局状态。从这个意义上说，我们无法清楚地划分局部状态和全局状态。在大多数情况下，如果你考虑状态在概念上属于哪里，你可以确定它是局部还是全局。
- en: 'There are two aspects when people talk about a global state, as outlined here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们谈论全局状态时，有两个方面，如下所述：
- en: One is a singleton, meaning that in some contexts, the state has one value.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中一个是单例，意味着在某些上下文中，状态只有一个值。
- en: The other is a shared state, which means that the state value is shared among
    different components, but it doesn't have to be the single value in JavaScript
    memory. A global state that is not a singleton can have multiple values.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个是共享状态，这意味着状态值在多个组件之间共享，但不必是JavaScript内存中的单个值。非单例的全局状态可以有多个值。
- en: 'To illustrate how a non-singleton global state works, here is an example to
    show a non-singleton variable in JavaScript:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明非单例全局状态的工作原理，这里有一个例子来展示JavaScript中的非单例变量：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, `base` is a scoped variable in a container. As `base` is isolated
    in each container, changing `base` in `container1` doesn't affect `base` in `container2`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`base`是一个容器中的局部变量。由于`base`在每个容器中都是隔离的，所以在`container1`中更改`base`不会影响`container2`中的`base`。
- en: In React, the concept is similar. If a global state is a singleton, we have
    only one value in memory. If a global state is non-singleton, we may have multiple
    values for different parts (subtrees) of a component tree.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，概念是相似的。如果全局状态是一个单例，我们在内存中只有一个值。如果全局状态不是单例，我们可能为组件树的不同部分（子树）有多个值。
- en: When to use global states
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用全局状态
- en: 'There are two guidelines for when we need a global state in React, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要在React中使用全局状态时，有两个指导原则，如下：
- en: When passing a prop is not desirable
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当传递属性不希望时
- en: When we already have a state outside of React
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们已经在React外部有一个状态时
- en: Let's discuss each of them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论每一个。
- en: Prop passing is not desirable
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性传递是不希望的
- en: If you need a state in two components that are far away in the component tree,
    it would not be desirable to have a state in the common root component and then
    pass the state all the way down to the two components.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在组件树中相距较远的两个组件中使用状态，在公共根组件中放置状态并将状态传递到这两个组件可能不是最佳选择。
- en: 'For example, if our tree is three levels deep and we need to lift up the state
    to the top, it would look like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们的树有三层深，并且需要将状态提升到顶部，它看起来会是这样：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is totally fine and recommended for locality; however, it could be too
    tedious to have your intermediate components used to pass props. Passing props
    through multi-level intermediate components might not result in a good developer
    experience, because it could seem like unnecessary extra work. Furthermore, the
    intermediate components re-render when the state is updated, which may impact
    performance.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全没问题，并且推荐用于局部性；然而，让你的中间组件用于传递属性可能会变得过于繁琐。通过多层中间组件传递属性可能不会带来良好的开发者体验，因为这可能看起来像是额外的不必要工作。此外，当状态更新时，中间组件会重新渲染，这可能会影响性能。
- en: In such cases, having a global state is more appropriate, and no intermediate
    components need to take care of passing the state.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，拥有全局状态更为合适，并且不需要中间组件处理状态传递。
- en: 'Here is some pseudo code showing how a global state would work with the previous
    example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些伪代码展示了如何使用上一个例子中的全局状态：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, the only component that uses a global state is `Component1`.
    Unlike with local states and prop passing, no intermediate components, `Parent`
    and `GrandParent`, know about a global state.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，唯一使用全局状态的组件是`Component1`。与局部状态和属性传递不同，中间组件`Parent`和`GrandParent`并不知道全局状态。
- en: Already have a state outside of React
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 已经在React外部有一个状态
- en: In some cases, you would already have a global state outside of React, as having
    a global state outside is more straightforward. For example, your app might have
    user-authenticated information that you obtained without React somehow. In such
    an example, a global state should exist outside React, and the authentication
    information could be stored in a global state.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你已经在React外部有一个全局状态，因为在外部拥有全局状态更直接。例如，你的应用可能有一些通过某种方式获得的用户认证信息，而不是通过React。在这种情况下，全局状态应该存在于React外部，认证信息可以存储在全局状态中。
- en: 'Here is some pseudo code showing such an example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些伪代码展示了这样的例子：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, `globalState` exists and is defined outside React. `useGlobalState`
    is a hook that would connect to `globalState` and that could provide `authInfo`
    in `Component1`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`globalState`存在并且是在React外部定义的。`useGlobalState`是一个钩子，它会连接到`globalState`，并且可以在`Component1`中提供`authInfo`。
- en: 'In this section, we learned that a global state is a state that can''t be a
    local state. Global state is mainly used secondary to local states, and there
    are two patterns where using a global state works well: one is in a case where
    prop passing doesn''t make sense, and the other is where a global state already
    exists in an app.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解到全局状态是一种不能是局部状态的状态。全局状态主要作为局部状态的补充使用，并且有两种情况下使用全局状态效果良好：一种是在属性传递没有意义的情况下，另一种是在应用中已经存在全局状态的情况下。
- en: Summary
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed local states and global states. Local states are
    preferable whenever possible, and we learned some techniques to use local states
    effectively. However, global states play a role where local states do not, which
    is why we looked at when you should use global states instead.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了局部状态和全局状态。尽可能情况下，局部状态是首选的，并且我们学习了一些有效使用局部状态的技术。然而，全局状态在局部状态无法发挥作用的地方扮演着角色，这就是为什么我们要探讨何时应该使用全局状态而不是局部状态。
- en: In the next three chapters, we will learn three patterns to implement a global
    state in React; in the next chapter specifically, we will start with utilizing
    React context.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的三章中，我们将学习三种在React中实现全局状态的模式；在下一章中，我们将具体从利用React上下文开始。
