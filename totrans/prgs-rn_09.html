<html><head></head><body>
		<div id="_idContainer042">
			<h1 id="_idParaDest-139" class="chapter-number"><a id="_idTextAnchor282"/>9</h1>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor283"/>Essential Tools for Improving React Native Development</h1>
			<p><strong class="bold"><a id="_idTextAnchor284"/>R<a id="_idTextAnchor285"/>eact Native</strong> is a framework <a id="_idIndexMarker512"/>with a very strong developer community. During the last year, there was an evolutionary growth of a large variety of tools and libraries, making the development of React Native apps a lot easier and a lot more comfortable.</p>
			<p>Besides the tools and libraries developed especially for React Native, you can also use a lot of things in the plain React ecosystem. This is because most of these things are compatible with the JavaScript/React part of any React Native app.</p>
			<p>Being aware of the best tools and libraries and how to use them is really useful because it saves you a lot of time and can greatly improve the quality of your code and product.</p>
			<p>Especially when you are working on bigger projects, some tools are an absolute must-have to ensure good collaboration in a bigger team.</p>
			<p>In this chapter, you will learn about the following topics:</p>
			<ul>
				<li>How to improve code quality with type safety, linters, and code formatters</li>
				<li>Why and when you should use boilerplate solutions and how to leverage them</li>
				<li>How to find and use high-quality UI libraries</li>
				<li>Why and when you should use Storybook and how to use it</li>
			</ul>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor286"/>Technical requirements</h1>
			<p>To be able to run the code in this chapter, you have to set up the following things: </p>
			<ul>
				<li>A working React Native environment (<a href="https://reactnative.dev/docs/environment-setup">https://reactnative.dev/docs/environment-setup</a>) – React Native CLI Quickstart</li>
			</ul>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor287"/>Improving code quality with type safety, linters, and code formatters</h1>
			<p>As already <a id="_idIndexMarker513"/>mentioned i<a id="_idTextAnchor288"/>n<a id="_idTextAnchor289"/> <a href="B16694_02.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding the Essentials of JavaScript and TypeScript</em>, it is necessary to use typed <a id="_idIndexMarker514"/>JavaScript alongside some tools to ensure a certain <a id="_idIndexMarker515"/>level of quality in bigger projects.</p>
			<p>In the following section, you will learn how to do this. Let’s start with type safety using TypeScript or Fl<a id="_idTextAnchor290"/>o<a id="_idTextAnchor291"/>w.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor292"/>Ensuring type safety with TypeScript or Flow</h2>
			<p><strong class="bold">Type safety</strong> is standard <a id="_idIndexMarker516"/>in most programming languages such as Java or C#, and this is for good reason. In contrast, JavaScript is dynamically typed. This is <a id="_idIndexMarker517"/>because of the history of JavaScript. Remember, JavaScript was created as a scripting language to write small chunks <a id="_idIndexMarker518"/>of code very quickly. For this scenario, dynamic typing is fine, but when a project grows, static typing with all its advantages is a must-have.</p>
			<p>Using typed JavaScript creates some overhead for creating your types at the beginning, but it gives you a lot of advantages at the end. Also, today, most libraries come with defined types, which you can use out of the box.</p>
			<p>In <a href="B16694_02.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding the Essentials of JavaScript and TypeScript</em>, you already learned how to use and write TypeScript. This subsection focuses on the advantages of TypeScript and what errors you can prevent when using it. </p>
			<h3>Dynamic typing can lead to serious and hard-to-find errors</h3>
			<p>Let’s start this section with a real-world example, which I experienced in one of my projects. While working on a React Native project, we used JavaScript without static typing. We fetched questions with a unique ID from a remote database (Google Firebase) and stored them locally on the device (<strong class="source-inline">AsyncStorage</strong>).</p>
			<p>Based on <a id="_idIndexMarker519"/>the ID of the questions, we also stored user answers and marked the questions as answered in the app. After an update, all the answers seemed to be gone from the users’ devices, and nobody understood why. It turned out that the update changed the unique IDs from <strong class="source-inline">number</strong> to <strong class="source-inline">string</strong>, which made the comparison between the stored user answers and the questions fail.</p>
			<p>The debugging of this error was very hard because it didn’t occur when answers were created with the updated version of the app. It only occurred when questions were answered in an older version of the app; following this, the app was then updated, and the questions were synced.</p>
			<p>In addition to that, the error never threw an error message. It just happened silently. So, it took quite some time to find and fix the bug. This is just one example of an error that happens because of dynamic typing and why it is hard to deal with these errors. They can lead to hard errors, which you notice directly, but in a lot of cases, they don’t.</p>
			<p>This is especially severe in the case of app development, where you store a lot of data on the users’ devices. When you don’t realize that you have problems with your data types, this can lead to corrupt data on millions of different devices, which is really hard to recognize, debug, and fix.</p>
			<p>Most of these errors can be prevented with static type checking using TypeScript or Flow. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">When using TypeScript or Flow, don’t use <strong class="source-inline">any</strong> or <strong class="source-inline">Object</strong> to make your life easier while writing your types. Type checking and all its advantages only really work when using it in the whole project. So, you should explicitly type all your properties.</p>
			<p>Typed JavaScript doesn’t only prevent bugs, it can also boost your productivity. </p>
			<h3>Enhancing your IDE with code completion</h3>
			<p>When you have statically defined types, it is easy for your IDE to help you with code completion. Most modern IDEs such as Visual Studio Code or JetBrains WebStorm have excellent <a id="_idIndexMarker520"/>support for TypeScript and Flow. </p>
			<p>While WebStorm has most of the support built in for TypeScript and Flow, there are a lot of useful plugins for VS Code. Especially when working with Flow, you must install an extension for code completion and code navigation to work correctly. To do so, go to <strong class="bold">Extensions</strong> and search for <strong class="source-inline">Flow Language <a id="_idTextAnchor293"/>Support</strong>.</p>
			<p>Additi<a id="_idTextAnchor294"/>onally, I would recommend running type checks in every commit with your CI pipeline. You can read more about this in <a href="B16694_11.xhtml#_idTextAnchor376"><em class="italic">Chapter 11</em></a>, <em class="italic">Creating and Automating Workflows</em>.</p>
			<p>While typed JavaScript prevents a lot of errors and boosts productivity, there are many more areas where you can prevent errors from happening. Most of them are covered by linters. In the next section, you learn what they are and how the<a id="_idTextAnchor295"/>y<a id="_idTextAnchor296"/> work. </p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor297"/>Getting rid of the most common bugs with linters</h2>
			<p>Linters are tools that watch your code and enforce certain rules. When it comes to JavaScript/TypeScript, ESLint is, by far, the most popular and mature linter on the market, so this subsection will focus on ESLint. It analyzes your code and finds problems by checking your code against a predefined ruleset.</p>
			<p>These problems <a id="_idIndexMarker521"/>can be errors, non-efficient code, or even code styling errors. I would recommend using ESLint because it comes at no cost and can ensure a certain level of code quality.</p>
			<p>If you use the React Native CLI to set up your project, you will find ESLint preinstalled with a working ruleset. If you want to add it to an existing project, you can install it with the following commands: either use <strong class="source-inline">npm install –-save-dev eslint</strong> or <strong class="source-inline">yarn add –-dev eslint</strong>. In the next step, you have to set up a configuration. This can be done automatically with the <strong class="source-inline">npm init @eslint/config</strong> or <strong class="source-inline">yarn create @eslint/config</strong> commands.</p>
			<p>Now you can use ESLint to check your code against your ruleset with <strong class="source-inline">npx eslint file.js</strong> or <strong class="source-inline">yarn run eslint file.js</strong>. ESLint even comes with a <strong class="source-inline">--fix</strong> option, which automatically tries to fix as many errors as possible.</p>
			<p>You can also integrate ESLint in most modern IDEs, to highlight and automatically fix problems found by ESLint. I would recommend doing so. </p>
			<p>Additionally, I would <a id="_idIndexMarker522"/>recommend running ESLint checks in every commit with your CI<a id="_idTextAnchor298"/> <a id="_idTextAnchor299"/>pipeline. You can read more about that in <a href="B16694_11.xhtml#_idTextAnchor376"><em class="italic">Chapter 11</em></a>, <em class="italic">Creating and Automating Workflows</em>.</p>
			<p>ESLint is an awesome tool to find common errors, and even though it also supports code styling rules, there is another tool that does a better job in this area.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor300"/>Enforcing a common code style with prettier</h2>
			<p><strong class="bold">Prettier</strong> is a code <a id="_idIndexMarker523"/>formatter that was created in 2016. Essentially, it automatically rewrites your code based on a set of rules. This ensures that it follows standards <a id="_idIndexMarker524"/>and enforces a common code style for the whole development team of a project. </p>
			<p>To use prettier, you can simply install it as a development dependency with the following commands. Either use <strong class="source-inline">npm install --save-dev prettier</strong> or <strong class="source-inline">yarn add --dev prettier</strong>.</p>
			<p>It can be a bit challenging to integrate prettier with linters such as ESLint. This is because – as you learned in the previous subsection – these linters also have rules to format code. When you use both and have specified conflicting rules, this won’t work. Fortunately, prettier comes with premade configs for ESLint, which prevent exactly that. You can download them from the prettier home page.</p>
			<p>After the installation is complete, you can run prettier from the command line. To check whether your code styling follows the prettier rules, you can use the <strong class="source-inline">prettier</strong> command, followed by the path of a file or folder you want to check. In practice, you often want to make prettier format your files for you. This can be achieved with <strong class="source-inline">prettier --write</strong> followed by a path of a file<a id="_idTextAnchor301"/> <a id="_idTextAnchor302"/>or folder. </p>
			<p class="callout-heading">Important tip</p>
			<p class="callout">You can use a <strong class="source-inline">.prettierignore</strong> file to exclude files from getting rewritten by prettier. You should use this file to prevent rewriting of files that are not written by you, config files, or others.</p>
			<p>Prettier brings a lot of value to your project, and you will not want to develop without it, especially when you are not working alone. The most important advantages of using prettier are <a id="_idIndexMarker525"/>liste<a id="_idTextAnchor303"/>d<a id="_idTextAnchor304"/> as follows:</p>
			<ul>
				<li><strong class="bold">Easier code reviews</strong>: When doing code reviews, most editors highlight the changes that have been made. By far, the most annoying thing in a code review is when a developer has another autoformatting setting, resulting in all the code being marked as changed for the review. While this makes total sense because all the code has been changed due to autoformatting, it makes the review process a lot harder. It takes more time and makes it more vulnerable to errors in the review. Prettier prevents this by enforcing a common code style.</li>
				<li><strong class="bold">Easier code readability</strong>: When you add developers to your team, code readability is an important factor. The easier the code readability is, the less time a new developer will need to be a productive part of your team. Prettier guarantees a common code style, which makes the code easier to read and understand.</li>
			</ul>
			<p>Prettier is <a id="_idIndexMarker526"/>available as a command-line tool and as an IDE extension/plugin for all common IDEs. To ensure that it is used, you should include it in the following parts of your project: </p>
			<ul>
				<li><strong class="bold">IDE</strong>: All developers should add prettier to their IDE and configure their autoformatting shortcut to use prettier.</li>
				<li><strong class="bold">Before Commit</strong>: A before commit hook should ensure that prettier does not throw any errors.</li>
				<li><strong class="bold">CI/CD</strong>: When creating a pull request/merge request, prettier should be run to ensure that the manual review can be done in an efficient manner. You can read more about this in <a href="B16694_11.xhtml#_idTextAnchor376"><em class="italic">Chapter 11</em></a>, <em class="italic">Creating and Automating Workflows</em>.</li>
			</ul>
			<p>If you implement this process with prettier, you will save a lot of time in the long run.</p>
			<p>So, you learned about the most important tools while working with React Native projects. Now you will get to know some tools to successfully start new React Native projects. There are different open source <strong class="bold">boilerplate solutions</strong> on the market, all with their own advantages. A boilerplate solution means either a template you can use to start with or a CLI tool to generate your start project.</p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor305"/>Using boilerplate solutions</h1>
			<p>Boilerplate <a id="_idIndexMarker527"/>solutions make it easy to set up a project with a solid architecture. This can be very helpful, but you should be aware of the trade-offs that come with these boilerplate solutions. Additionally, you should know exactly what you want because there are completely different solutions out there. </p>
			<p>First, a boilerplate solution in this context is everything that creates code for you to start without having to configure everything on your own. This can be anything, from a simple template that has built-in TypeScript support but nothing else to a complete CLI solution that brings you solutions for navigation, state management, fonts, animations, connection, and more such as the Ignite CLI by Infinite Red. </p>
			<p>Because there is such a wide range of what a boilerplate solution consists of, it’s hard to make general assumptions about them. Nevertheless, what can be said is that the more that is packed into the boilerplate solution, the bigger the risk that anything inside is broken. Therefore, in this section, you will learn about the most common ones, every single solution with advantages, trade-offs, and how to use them.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor306"/>Using the React Native TypeScript template</h2>
			<p>React Native <a id="_idIndexMarker528"/>comes with <a id="_idIndexMarker529"/>an integrated template engine. When you are using the React Native CLI to set up your project, you can work with a <strong class="source-inline">template</strong> flag. This is how you can use the React Native TypeScript template:</p>
			<p class="source-code">npx react-native init App </p>
			<p class="source-code">    --template react-native-template-typescript</p>
			<p>This template does not come with any solution for navigation, state management, or anything else. It is the plain React Native Starter template, but with support for TypeScript. I like it very much because it is very simple, has nearly no dependencies, and lets you decide on what you need, while it does all the TypeScript compiler <a id="_idTextAnchor307"/>conf<a id="_idTextAnchor308"/>i<a id="_idTextAnchor309"/>guration for you.</p>
			<p><strong class="bold">Advantages</strong> of <a id="_idIndexMarker530"/>this include the following:</p>
			<ul>
				<li>TypeScript support</li>
				<li>No unwanted dependencies</li>
				<li>Easy to maintain</li>
			</ul>
			<p><strong class="bold">Trade-offs</strong> include <a id="_idIndexMarker531"/>the following:</p>
			<ul>
				<li>None</li>
			</ul>
			<p>While <a id="_idIndexMarker532"/>the React Native <a id="_idIndexMarker533"/>TypeScript template is a no-brainer to use when starting a new project, the following boilerplate solutions are not that easy to decide on. This is because they come with mor<a id="_idTextAnchor310"/>e<a id="_idTextAnchor311"/> libr<a id="_idTextAnchor312"/>a<a id="_idTextAnchor313"/>ries attached.</p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor314"/>Using React Native Boilerplate by thecodingmachine</h2>
			<p>This <a id="_idIndexMarker534"/>boilerplate also uses the built-in React Native template engine to work. But compared to the React Native TypeScript template, it already makes decisions on many things for you. It comes with Redux, Redux Persist, and the redux toolkit for state management, Axios <a id="_idIndexMarker535"/>for API calls, React Navigation, and Flipper integration. Additionally, it creates a good directory structure for your project. You can create a project based on this template with the following call:</p>
			<p class="source-code">npx react-native init MyApp </p>
			<p class="source-code">    --template @thecodingmachine/react-native-boilerplate</p>
			<p>Because this template comes with a lot of predefined libraries, you should take a look at whether it is actively maintained and has been updated recently. Otherwise, you could start with very old versions of all the libraries that would need a potentially time-consu<a id="_idTextAnchor315"/>m<a id="_idTextAnchor316"/>ing update very soon.</p>
			<p><strong class="bold">Advantages</strong> of <a id="_idIndexMarker536"/>this include the following:</p>
			<ul>
				<li>TypeScript support</li>
				<li>Good libraries</li>
				<li>Good project structure</li>
			</ul>
			<p><strong class="bold">Trade-offs</strong> of this <a id="_idIndexMarker537"/>include the following:</p>
			<ul>
				<li>It uses Redux for State Management, so you might have to stick to that</li>
				<li>At the time of writing, it was already three versions behind the most recent React Native release, so you will miss the most recent features and bug fixes</li>
			</ul>
			<p>For <a id="_idIndexMarker538"/>more information on this boilerplate, please visit the official documentation at <a href="https://thecodingmachine.github.io/react-native-boilerplate/">https://thecodingmachine.github.io/react-native-boilerplate/</a>.</p>
			<p>While these are good solutions, you should have a look to see whether they really fit your project. The next template comes with a slightl<a id="_idTextAnchor317"/>y<a id="_idTextAnchor318"/> diff<a id="_idTextAnchor319"/>e<a id="_idTextAnchor320"/>rent configuration.</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor321"/>Using React Native Starter Kit by mcnamee</h2>
			<p>This <a id="_idIndexMarker539"/>boilerplate does <a id="_idIndexMarker540"/>not use any template engine or CLI. It is just a GitHub repository that you can download or clone and start with. Additionally, it comes with a useful structure and brings a lot of libraries.</p>
			<p>It uses Redux and Rematch for state management, React Native Router Flux for navigation, and it also comes with Native Base as the UI library and Fastlane for deployment. Essentially, it brings you all you need to get your first result shipped in hours. </p>
			<p>But again, please have a look at how well-maintained the template is. At the time of writing, the last release of React Native Router Flux was more than a year ago, which means one core library of the templ<a id="_idTextAnchor322"/>a<a id="_idTextAnchor323"/>te is essentially unusable. </p>
			<p><strong class="bold">Advantages</strong> of <a id="_idIndexMarker541"/>this include the following:</p>
			<ul>
				<li>Good project structure</li>
				<li>Adds everything to get you going</li>
			</ul>
			<p><strong class="bold">Trade-offs</strong> of <a id="_idIndexMarker542"/>this include the following:</p>
			<ul>
				<li>It uses Redux for State Management, so you might have to stick to that</li>
				<li>It uses Native Base as UI Toolkit, so you might have to stick to that</li>
				<li>It has an outdated navigation library, so you will have problems with the most re<a id="_idTextAnchor324"/>c<a id="_idTextAnchor325"/>ent versions of React Native</li>
			</ul>
			<p>You can <a id="_idIndexMarker543"/>find more information about this template from the official GitHub page at <a href="https://github.com/mcnamee/react-native-starter-kit">https://github.com/mcnamee/react-native-starter-kit</a>.</p>
			<p>After looking at two boilerplate templates, we’ll have a look at two really extensive CLI tools to set up your project. </p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor326"/>Working with Ignite CLI</h2>
			<p>Ignite is a boilerplate solution developed and maintained by Infinite Red, an awesome React Native <a id="_idIndexMarker544"/>company, doing awesome <a id="_idIndexMarker545"/>open source work. It is much more than a simple template. It is a complete CLI, replacing the built-in React Native <strong class="source-inline">init</strong> command. </p>
			<p>With the following c<a id="_idTextAnchor327"/>o<a id="_idTextAnchor328"/>mmand, you can create a new app: </p>
			<p class="source-code">npx ignite-cli new YourAppName</p>
			<p>This creates an application with a good folder structure, React Navigation for navigation, MobX-State-Tree for state management, apisauce for API calls, and, of course, TypeScript support. In addition to that, your project automatically supports Flipper and Reactotron for debugging, Detox for end-to-end tests, and Expo, including Expo web. </p>
			<p>On top of all that, Ignite CLI <a id="_idIndexMarker546"/>comes with a feature called <strong class="bold">generators</strong>. With these generators, you can generate your models, components, screens, and navigators via the Ignite CLI. This means you can customize your project to your needs, without having to write these files from scratch. If you want to create a new component, you can use the following command:</p>
			<p class="source-code">npx ignite-cli generate component MyNewComponent</p>
			<p>This command creates a component based on a template stored in the <strong class="source-inline">ignite/templates</strong> folder, which was created with your project. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">When working with the Ignite generators, you can edit the templates that are used to generate your files. Just edit the templates in <strong class="source-inline">ignite/templates</strong>, and the generated files will include your changes. This means you can adapt the templates to your needs and standards, and then use the generators to ensure that everyone sticks to those standards.</p>
			<p>While this <a id="_idIndexMarker547"/>setup is great for professional projects, it comes with a lot of library decisions built in. In particular, MobX-State-Tree for State Management is one you might want to have a look at. It is a great solution for state management, but it isn’t as popular as Redux or React Context, which means the community support is quite poor. </p>
			<p><strong class="bold">Advantages</strong> of this <a id="_idIndexMarker548"/>include the following:</p>
			<ul>
				<li>Good project structure</li>
				<li>Good debugging integration</li>
				<li>Integration for Detox end-to-end testing</li>
				<li>Localization integration</li>
				<li>Generators</li>
			</ul>
			<p><strong class="bold">Trade-offs</strong> of this <a id="_idIndexMarker549"/>include the following:</p>
			<ul>
				<li>It uses MobX-State-Tree for State Management, which isn’t as popular as Redux or React Context.</li>
				<li>It has Expo integration out of the box. This will grow your app bundle size and adds another dependency.</li>
				<li>It adds a lot of overhead for smaller projects</li>
			</ul>
			<p>For more information on Ignite, please visit the GitHub page at <a href="https://github.com/infinitered/ignite">https://github.com/infinitered/ignite</a>.</p>
			<p>Now you know different boilerplate solutions along with their advantages and trade-offs. Even <a id="_idIndexMarker550"/>if you don’t use a boilerplate solution for creating your projects, I would recommend having a look at the structure they create. This kind of structure is something you can build on.</p>
			<p>After looking at these boilerplate solutions, next, we’ll focus on the UI part. There are also a lot of useful open source solutions out there, which will make your life a lot easier. </p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor329"/>Finding and using high-quality UI libraries</h1>
			<p><strong class="bold">UI libraries</strong> provide <a id="_idIndexMarker551"/>a predefined UI for the most common use cases. There are a lot of different UI libraries you can use for your project. But some are better <a id="_idIndexMarker552"/>than others. This section not only names the most popular ones, but it <a id="_idIndexMarker553"/>also gives you an idea of what you must look for when doing your own research. </p>
			<p>A good UI library <a id="_idIndexMarker554"/>should meet the following criteria: </p>
			<ul>
				<li><strong class="bold">Well maintained</strong>: As with all libraries, it has to be well maintained. This means there are multiple contributors, there is good code quality, and there are regular releases. This is important to ensure that future version upgrades of React Native are supported.</li>
				<li><strong class="bold">Component-based</strong>: A React Native UI library should provide a set of components, which you can use out of the box. </li>
				<li><strong class="bold">Theming</strong>: The library should include theming options and be easily adaptable to your colors, fonts, paddings, and margins. </li>
				<li><strong class="bold">Type declarations</strong>: A good UI library should have type declarations for components and themes.</li>
			</ul>
			<p>There are a lot of different UI libraries out there. I will introduce you to two of them in the following subsection, but since they don’t have to be the best fit for your project, please do your own research based on the criteria mentioned here before using either of them. </p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor330"/>Working with React Native Paper</h2>
			<p><strong class="bold">React Native Paper</strong> is a <a id="_idIndexMarker555"/>UI library based on <strong class="bold">Material Design</strong>. It is <a id="_idIndexMarker556"/>created and maintained <a id="_idIndexMarker557"/>by Callstack, a React Native company that is also working a lot on the React Native core, so these folks know what they are doing. This means the library sets<a id="_idTextAnchor331"/> <a id="_idTextAnchor332"/>a very high standard regarding code quality.</p>
			<p>React Native Paper meets all the criteria defined in the previous subsection. The following <a id="_idIndexMarker558"/>features are included in React Native Paper: </p>
			<ul>
				<li><strong class="bold">Excellent theming support</strong>: Paper comes with integrated theming. You can easily change and extend the default themes and use them all over your app. </li>
				<li><strong class="bold">Type declarations</strong>: All of the components and themes come with type declarations.</li>
				<li><strong class="bold">Icons</strong>: Paper uses <strong class="source-inline">react-native-vector-icons</strong> and <strong class="source-inline">MaterialCommunityIcons</strong> to provide you with icons.</li>
				<li><strong class="bold">Over 30 pre-built components</strong>: All components are highly customizable and easy to use. </li>
				<li><strong class="bold">Excellent React Navigation integration</strong>: Paper integrates very well in the React Navigation library. This means you can use components such as <strong class="source-inline">Appbar</strong> as a custom navigation bar in React Navigation. </li>
			</ul>
			<p>While React Native Paper is possibly the best UI library out there from a technical point of view, you must keep in mind that it is completely based on Google’s Material Design. This means you might not want to use it on iOS, since it makes your app look different than the iOS standards. </p>
			<p>For more information <a id="_idIndexMarker559"/>about React Native Paper, its installation, and its usage, please visit the official documentation at <a href="https://callstack.github.io/react-native-paper/">https://callstack.github.io/react-native-paper/</a>.</p>
			<p>Another high-quality UI library is NativeBase. In the next subsection, you will learn about this library.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor333"/>Working with NativeBase</h2>
			<p><strong class="bold">NativeBase</strong> is a UI library <a id="_idIndexMarker560"/>that works for React Native alongside <a id="_idIndexMarker561"/>plain React. This means it not only works within <a id="_idIndexMarker562"/>your iOS and Android app, but it also works on your web app if you have one. For products with Android, iOS, and web support, this can be very useful because you can primarily use the same code base for all platforms.</p>
			<p>Additionally, NativeBase <a id="_idIndexMarker563"/>meets all of the criteria defined in the first subsection of this section. The following features are included in NativeBase:</p>
			<ul>
				<li><strong class="bold">Excellent theming support</strong>: NativeBase also has very good theming support. Essentially, it works quite similarly to React Native Paper. You can easily change and extend the default themes and use them all over your app. It also supports light and dark modes out of the box.</li>
				<li><strong class="bold">Type declarations</strong>: All components and themes come with type declarations. You also have excellent documentation on how to extend these types when it comes to customizing themes or components.</li>
				<li><strong class="bold">Icons</strong>: NativeBase comes with its own icons, which are based on <strong class="source-inline">react-native-vector-icons</strong> for plain React Native projects or <strong class="source-inline">@expo/vector-icon</strong> for Expo projects.</li>
				<li><strong class="bold">Over 30 pre-built components</strong>: All<a id="_idTextAnchor334"/> <a id="_idTextAnchor335"/>components are highly customizable and easy to use. </li>
				<li><strong class="bold">Responsive support</strong>: NativeBase has excellent responsive design support. This means you can adapt your views to different screen sizes with just a few additional properties on your components. </li>
				<li><strong class="bold">Accessibility</strong>: Based on React Native ARIA, NativeBase provides accessibility support for all components. This means you can easily provide support for screen readers, ensure a good contrast ratio, and enable keyboard interactions for your app. </li>
			</ul>
			<p>Additionally, NativeBase comes with a Figma file, which makes it an ideal starting point for creating your own design system with a design expert. All in all, it is a very good solution for creating a beautiful UI in record time. </p>
			<p>For more <a id="_idIndexMarker564"/>information on NativeBase, please visit the official documentation at <a href="https://docs.nativebase.io/">https://docs.nativebase.io/</a>.</p>
			<p>As already mentioned, there are a lot more open source UI libraries out there. Please check this list for the most popular ones: </p>
			<ul>
				<li>React Native UI Kitten</li>
				<li>React Native Elements</li>
				<li>Material Kit Pro React Native by creative-tim</li>
				<li>Nachos UI Kit for React Native</li>
			</ul>
			<p>These UI libraries <a id="_idIndexMarker565"/>can save you a lot of time. But as you want to create an individual app experience for your users, you should only use them as a starting point. Fortunately, most of them are adaptive enough that you can use them to create your own design while using the battle-proven structure of the library.</p>
			<p>As your projects grow, I would recommend extending the library of your choice with your own components. If you like and think you have something that can be interesting for others too, you can even give something back to the community by creating pull requests and extending the official library.</p>
			<p>After looking at the UI libraries, in the next subsection, you’ll get to know another useful tool. This is especially useful when working on large applications, where UI components are shared <a id="_idIndexMarker566"/>between different repositories and where some developers only work on the UI components. It is called <strong class="bold">Storybook</strong>.</p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor336"/>Using Storybook for React Native</h1>
			<p>Storybook <a id="_idIndexMarker567"/>is very popular in the plain React world. It is <a id="_idIndexMarker568"/>a tool that renders all your components in predefined states, so you can have a look at them without having to start your real app and navigate to the location where they are used. </p>
			<p>With Storybook, you write stories, which are then packed into a storybook. Each of these stories contains a component. It also defines the location within the storybook. The <a id="_idIndexMarker569"/>followin<a id="_idTextAnchor337"/>g<a id="_idTextAnchor338"/> code example shows what a story can <a id="_idIndexMarker570"/>look like: </p>
			<pre class="source-code">
import {PrimaryButton} from '@components/PrimaryButton;
export default {
  title: 'c<a id="_idTextAnchor339"/>o<a id="_idTextAnchor340"/>m<a id="_idTextAnchor341"/>p<a id="_idTextAnchor342"/>onents/Prim<a id="_idTextAnchor343"/>a<a id="_idTextAnchor344"/>ryButton,
      component: PrimaryButton,
};
export const Standard = args =&gt; (
  &lt;PrimaryButton {...args} /&gt;
);
Standard.args = {
  text: 'Primary Button',
      size: 'large',
          color: 'orange',
};
export const Alert = args =&gt; (
  &lt;PrimaryButton {...args} /&gt;
);
Alert.args = {
  text: 'Alert Button',
      size: 'large',
          color: 'red',
};</pre>
			<p>In the first line, the <strong class="source-inline">PrimaryButton</strong> component is imported. The following default export <a id="_idIndexMarker571"/>defines the location in the storybook and which <a id="_idIndexMarker572"/>component the story is related to. The <strong class="source-inline">Standard</strong> const and the <strong class="source-inline">Alert</strong> const are different states, and the <strong class="source-inline">PrimaryButton</strong> component will be rendered and shown in the storybook. The corresponding <strong class="source-inline">args</strong> define this state: </p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B16694_09_01.jpg" alt="Figure 9.1 – Storybook running in a browser&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Storybook running in a browser</p>
			<p>Storybook on React Native either works on the iOS or Android simulator, a real device, or you can use React Native Web to create a web version of your components and render them into any browser. This is shown in <em class="italic">Figure 9.1</em> and can be especially useful when working with designers. </p>
			<p>Storybook makes it possible to develop your components isolated from the rest of the application. It not only shows you the component, but it also lets you change the properties within a storybook. So, you can see how your component will behave in your real application under different circumstances. </p>
			<p>I wouldn’t use Storybook for small projects, but when your project and your team grow, Storybook <a id="_idIndexMarker573"/>can be a useful tool to increase your development <a id="_idIndexMarker574"/>speed on the UI part. This is especially the case when you have UI components that you share between different repositories. I would recommend this when you have multiple applications in your company that should all share the same look and feel.</p>
			<p>In this case, a central repository for your components could be a good solution. With Storybook, this repository can be maintained by a developer and designer, without needing access to all your applications. You can read more about this in <a href="B16694_10.xhtml#_idTextAnchor347"><em class="italic">Chapter 10</em></a>, <em class="italic">Structuring Large-Scale, Multi-Platform Projects</em>, in the <em class="italic">Writing own libraries </em>section.</p>
			<p>For more <a id="_idIndexMarker575"/>information on Storybook, please visit the official documentation at <a href="https://storybook.js.org/">https://storybook.js.org/</a>.</p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor345"/>Summary</h1>
			<p>In this chapter, you learned about useful tools for increasing code quality, catching the most common errors automatically, and speeding up the project setup along with the development process. You understood why type definitions are important and how to use ESLint and prettier to ensure your code meets certain criteria.</p>
			<p>Additionally, you got to know the most popular React Native boilerplate solutions to start a project, and you learned what advantages and trade-offs each of these solutions have. At the end of the chapter, you learned about Storybook for React Native, how to use it, and in which scenarios it is a useful tool. </p>
			<p>After learning about all these useful tools, it is time to dive deeper into large-scale projects. In the next chapter, you will learn how to set up and maintain a project structure, which will work for large-scale projects. Additionally, you will learn what options you have, to share code between different platforms, and which of these solutions works best in which scenario.</p>
		</div>
	

		<div id="_idContainer043" class="Content">
			<h1 id="_idParaDest-156"><a id="_idTextAnchor346"/>Part 3: React Native in Large-Scale Projects and Organizations</h1>
			<p>You will learn how to use React Native in large organizations or large-scale projects. This includes structuring large applications, setting up good processes, using automation wherever possible, and starting to write your own libraries. </p>
			<p>The following chapters are in this section:</p>
			<ul>
				<li><a href="B16694_10.xhtml#_idTextAnchor347"><em class="italic">Chapter 10</em></a>, <em class="italic">Structuring Large-Scale, Multiplatform Projects</em></li>
				<li><a href="B16694_11.xhtml#_idTextAnchor376"><em class="italic">Chapter 11</em></a>, <em class="italic">Creating and Automating Workflows </em></li>
				<li><a href="B16694_12.xhtml#_idTextAnchor410"><em class="italic">Chapter 12</em></a>, <em class="italic">Automated Testing of React Native Apps</em></li>
				<li><a href="B16694_13.xhtml#_idTextAnchor462"><em class="italic">Chapter 13</em></a>, <em class="italic">Tips and Outlook</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer044">
			</div>
		</div>
	</body></html>