- en: Feature Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to continue building the foundation of our app by scaffolding the
    core feature modules our app will need, the player and recorder. We will also want
    to keep in mind that the recording features will only be loaded and available when
    a user authenticates. Lastly, we will finish the implementation of our services
    from the `CoreModule` we created in [Chapter 1](part0023.html#LTSU0-289fe2426d594f99a90e4363b2c9c34d), *Get
    Into Shape with @NgModule*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating feature modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separation of concerns with app features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the `AppModule` to bootstrap efficiently, only loading upfront the
    feature modules we need for our first view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the NativeScript `application-settings` module as our key/value store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing the ability to control our app's debug logs at one spot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new service that will use other services to demonstrate our scalable
    architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Player and recorder modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create the shell of our two main feature modules. Take note that we
    also add `NativeScriptModule` to the imports of both of the following modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PlayerModule`: It will provide player-specific services and components that
    will be usable whether the user is authenticated or not.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s create `app/modules/player/player.module.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`RecorderModule`: This will provide recording-specific services and components
    that will only be loaded if the user is authenticated and enters the record mode
    for the first time.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s create `app/modules/recorder/recorder.module.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A shared model for our data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we go about creating our services, let''s create an interface and model
    implementation for the core piece of data our app will be using. The `TrackModel`
    will represent a single track with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filepath`: (to the local file)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: (for our view)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`order`: Position (for the view listing of tracks)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`volume`: We want our player to be able to mix different tracks together with
    different volume level settings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`solo`: Whether we want to hear just this track in our mix'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also add a convenient constructor to our model, which will take an object
    to initialize our model with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `app/modules/core/models/track.model.ts`, since it will be shared across
    both our player and recorder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Scaffolding out the service APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s create the API our services will provide to our app. Starting with
    `PlayerService`, we could imagine the following API might be useful to manage
    tracks and control playback. Most of it should be fairly self-explanatory. We
    may refactor this later but this is a great start:'
  prefs: []
  type: TYPE_NORMAL
- en: '`playing: boolean;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tracks: Array<ITrack>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`play(index: number): void;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pause(index: number): void;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addTrack(track: ITrack): void;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeTrack(track: ITrack): void;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reorderTrack(track: ITrack, newIndex: number): void;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create `app/modules/player/services/player.service.ts` and stub out a few of
    the methods; some of them we could go ahead and implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's apply our standard by exporting this service for our module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `app/modules/player/services/index.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, modify our `PlayerModule` to specify the correct providers so our final
    module should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, we can design `RecorderService` to provide a simple recording API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `app/modules/recorder/services/recorder.service.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`record(): void`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stop(): void`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, apply our standard by exporting this service for our module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `app/modules/recorder/services/index.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, modify our `RecorderModule` to specify the correct providers so our
    final module should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With our two primary feature modules scaffolded and ready to go, let's revisit
    the two low-level services we created in Chapter 1, *Get Into Shape with @NgModule*, and
    provide implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing LogService
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging is an important ally that you want during the development lifecycle
    of your app as well as in production. It can help you debug as well as gain important
    insights into how your app is used. Having a single pathway to run all logging
    through also provides an opportunity to reroute all the app logs somewhere else
    with the flip of a switch. For example, you could use a third-party debug tracking
    service, such as TrackJS ([https://trackjs.com](https://trackjs.com)), via Segment
    ([https://segment.com](https://segment.com)). You will want to run a lot of important
    aspects of your app through logging and it serves as a great place to have a lot
    of control and flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open `app/modules/core/services/log.service.ts` and get to work. Let''s
    start by defining a static boolean that will serve as a simple flag we can toggle
    in our `AppModule` to enable/disable. Let''s also add a few helpful methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`debug`: This will serve as our most commonly used output API for logging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error`: When we know a certain condition is an error, this will help identify
    those spots in our log.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inspect`: There are times when viewing an object can help find a bug or help
    us understand the state of our app at any given moment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With our `LogService` implemented, we will now use it throughout our app and
    the rest of this book instead of using the console directly.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing DatabaseService
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `DatabaseService` needs to provide several things:'
  prefs: []
  type: TYPE_NORMAL
- en: A persistent store to save and retrieve any data our app needs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should allow any type of data to be stored; however, we will specifically
    want it to handle JSON serialization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static keys of all the data we will want to store.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A static reference to a saved user? Well, yes it could. However, this brings
    up a point that we will address in a moment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Regarding the first item, we can use NativeScript''s `application-settings`
    module. Under the hood, this module provides a consistent API to work with two
    native mobile APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**iOS**: `NSUserDefaults`: [https://developer.apple.com/reference/foundation/userdefaults](https://developer.apple.com/reference/foundation/userdefaults)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Android**: `SharedPreferences`: [https://developer.android.com/reference/android/content/SharedPreferences.html](https://developer.android.com/reference/android/content/SharedPreferences.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regarding serializing JSON data, the `application-settings` module provides
    a `setString` and `getString` method, which will allow us to use it in conjunction
    with `JSON.stringify` and `JSON.parse`.
  prefs: []
  type: TYPE_NORMAL
- en: Using string values throughout your codebase in several different spots to refer
    to the same key that should remain constant can become error prone. Because of
    this, we will keep a typed (for type safety) static hash of valid keys that our
    app will use. We may only know one at this point in time (authenticated user as
    `'current-user'`) but creating this will provide a single spot to scale these
    out over time.
  prefs: []
  type: TYPE_NORMAL
- en: Four? We will address four in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `app/modules/core/services/database.service.ts` and modify it to provide
    a similar API to the web''s `localStorage` API for simplicity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This service now provides a way to store an object via `setItem`, which ensures
    the object is properly stored as a string via `JSON.stringify`. It also provides
    a way to retrieve values via `getItem`, which also handles the serialization back
    to an object for us via `JSON.parse`. We also have the `remove` API to simply
    remove values from our persisted store. Lastly, we have a nice static reference
    to all the valid keys that our persistent store will keep track of.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what about that static reference to the saved user?
  prefs: []
  type: TYPE_NORMAL
- en: We want to be able to easily access our authenticated user from anywhere in
    the app. We could provide a static reference in our `DatabaseService` for simplicity,
    but our aim here is to have a clear separation of concerns. Since we know we will
    want the ability to show a modal asking the user to register and unlock those
    recording features, a new service to manage this makes sense. Since we have designed
    scalable architecture, we can easily add another service into the mix, so let's
    do that now!
  prefs: []
  type: TYPE_NORMAL
- en: Create AuthService to help handle the authenticated state of our app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One important consideration for our `AuthService` is to understand that certain
    components in our app may benefit from getting notified when the authenticated
    state changes. This is a perfect use case to utilize RxJS. RxJS is a very powerful
    library that is used to simplify dealing with changing data and events using observables.
    An observable is a data type that you can use not only to listen to events, but
    filter, map, reduce, and run sequences of code against anytime something occurs.
    By using observables, we can simplify our asynchronous development dramatically.
    We will use a specific type of observable called the `BehaviorSubject` to emit
    changes that our components could subscribe to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `app/modules/core/services/auth.service.ts` and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We have a few interesting things going on here. We are putting two other services
    we designed to work right away, `LogService` and `DatabaseService`. They are helping
    us check whether a user was saved/authenticated as well as log that result.
  prefs: []
  type: TYPE_NORMAL
- en: We are also calling on a `private _init` method when our service gets constructed
    via Angular's dependency injection system. This allows us to immediately check
    whether an authenticated user exists in our persistent store. Then, we call a
    private reusable method `_notifyState`, which will emit `true` or `false` on our
    `authenticated$` observable. This will provide a nice way for other components
    to easily get notified when the auth state changes by subscribing to this observable.
    We have made `_notifyState` reusable because our login and register methods (to
    be implemented in the future) will be able to use it when the results are returned
    from modals we may display in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: We can now easily add `AuthService` to our `PROVIDERS` and we don't need to
    do anything else to ensure it's added to our `CoreModule` because our `PROVIDERS`
    are already added to the `CoreModule`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do is modify `app/modules/core/services/index.ts` and add our
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: WAIT! There is one important thing we want to do to ensure our AuthService initializes!
  prefs: []
  type: TYPE_NORMAL
- en: Angular's dependency injection system will only instantiate a service that is
    injected somewhere. Although we have all our services specified as providers in
    our `CoreModule`, they will not actually be constructed until they are injected
    somewhere!
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `app/app.component.ts` and replace its contents with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We inject our `AuthService` by specifying it as an argument to our component's
    constructor. This will cause Angular to construct our service. All subsequent
    injects throughout our code will all receive the same singleton.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare to bootstrap the AppModule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a good setup for our feature modules and it's time to bring them
    all together in our root `AppModule` responsible for bootstrapping our app.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap only what is needed for your initial view. Lazy load the rest.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to keep the bootstrap of our app as fast as possible. To achieve
    that, we only want to bootstrap the app with the main features needed for our
    initial view and lazy load the rest when needed. We know we want our low-level
    services to be available and ready to use anywhere in the app, so we will definitely
    want `CoreModule` upfront.
  prefs: []
  type: TYPE_NORMAL
- en: Our initial view from our sketch is going to start with the player and 2-3 tracks
    on the list, so the user can immediately playback a mix of pre-recorded tracks
    we will ship with the app for demonstration purposes. For this reason, we will
    specify the `PlayerModule` to load upfront when our app bootstraps, since it will
    be a primary feature we want to immediately engage with.
  prefs: []
  type: TYPE_NORMAL
- en: We will set up a routing configuration, which will lazy load our `RecorderModule`
    when the user taps the record button at the top right of our initial view to begin
    a recording session.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, we can set up our `AppModule` located at `app/app.module.ts`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout, we have been working hard creating a solid foundation to build our
    app on. We created a `CoreModule` to provide some low-level services, such as
    logging, and a persistent store and designed the module to easily scale in more
    services as needed . Plus, this module is portable and can be dropped into other
    projects with your own company's special sauce intact.
  prefs: []
  type: TYPE_NORMAL
- en: In typical app development, you may want to run your app on the iOS and/or Android
    simulator along the way, during this process to double-check some of your design/architecture
    choices and that would be advisable! We just haven't done that yet, since we have
    an app pre-planned here and want you to stay focused on the choices we are making
    and why.
  prefs: []
  type: TYPE_NORMAL
- en: We also created the two primary feature modules that our app needs for its core
    competency, `PlayerModule` and `RecorderModule`. The player will be pre-setup
    with 2-3 recorded tracks loaded and ready to play right upon launch, so we will
    be bootstrapping our app with the `PlayerModule` features.
  prefs: []
  type: TYPE_NORMAL
- en: We will provide a simple way to allow a user to register an account, which will
    allow them to record their own tracks to throw in the mix. Once they are logged
    in, they will be able to enter the record mode via a route, which will lazily
    load the `RecorderModule`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will create our first view, configure our routes, and
    finally, get our first glimpse at our app.
  prefs: []
  type: TYPE_NORMAL
