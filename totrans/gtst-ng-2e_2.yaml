- en: Chapter 2. The Building Blocks of an Angular Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at the drivers for the design decisions behind
    the new Angular. We described the main reasons that led to the development of
    a brand new framework; Angular takes advantage of the newest Web standards while
    keeping the past lessons in mind. Although we are familiar with the main drivers,
    we still haven't described the core Angular concepts. The last major release of
    the framework took a different path from AngularJS and introduced a lot of changes
    in the fundamental building blocks used for the development of single-page applications.
  prefs: []
  type: TYPE_NORMAL
- en: The mission of this chapter is to describe the framework's core and make a brief
    introduction to its main concepts. In the next couple of pages, we will also make an
    overview of how these concepts can be put together to help us build professional
    user interfaces for our Web applications. The subsequent sections will give us
    an overview of everything that we will learn in more detail later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A conceptual overview of the framework, showing how different concepts relate
    to each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How we can build a user interface as a composition of components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What path the directives took in the new versions of Angular, and how their
    interface changed compared to the previous major version of the framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reasons for the enforced separation of concerns, which led to the decomposition
    of the directives into two different concepts. In order to get a better sense
    of them, we will demonstrate basic syntax for their definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of the improved change detection, and how it involves the context
    that directives provide.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What zones are, and how they can make our daily development process easier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What pipes are, and how they are related to the AngularJS filters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to the brand new **dependency injection** (**DI**) mechanism in
    Angular and how it is related to the services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A conceptual overview of Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we dive into the different parts of Angular, let''s get a conceptual
    overview of how everything fits together. Let''s take a look at the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A conceptual overview of Angular](img/5081_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 1* to *Figure 4* show the main Angular concepts and the connections
    between them. The main purpose of these diagrams is to illustrate the core blocks
    for building single-page applications with Angular, and their relations.'
  prefs: []
  type: TYPE_NORMAL
- en: The **Component** is the main building block we will use to create the user
    interface of our applications with Angular. The **Component** is a direct successor
    of the **Directive**, which is the primitive for attaching behavior to the DOM.
    Components extend **Directives** by providing further features, such as a template,
    which can be used to render composition of directives. Inside the template of
    the view can reside different expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '![A conceptual overview of Angular](img/5081_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram conceptually illustrates the **Change Detection** mechanism
    of Angular. It performs dirty checking, which evaluates the registered expressions
    in the context of specific UI components. Since the concept of scope has been removed
    from Angular, the execution context of the expressions are the instances of the
    controllers of the components associated with them.
  prefs: []
  type: TYPE_NORMAL
- en: The **Change Detection** mechanism can be enhanced using **Differs**; that's
    why there's a direct relation between these two elements on the diagram.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pipes** are another component of Angular. We can think of Pipes as the filters
    from AngularJS. Pipes can be used together with components. We can include them
    in the expressions, which are defined in the context of any component.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A conceptual overview of Angular](img/5081_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3
  prefs: []
  type: TYPE_NORMAL
- en: Now let's take a look at the preceding diagram. **Directives** and **Components**
    delegate the business logic to **Services**. This enforces better separation of
    concerns, maintainability, and code reusability. **Directives** receive references
    to instances of specific services declared as dependencies using the **DI** mechanism
    of the framework, and delegate the execution of the business-related logic to
    them. Both **Directives** and **Components** may use the **DI** mechanism, not
    only to inject services but also to inject DOM elements and/or other **Components**
    or **Directives**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Modules** (also known as **NgModules**) are a core concept which combines the
    building blocks into separate, logically related, groups. NgModules are quite
    similar to the AngularJS modules but bring more semantics on top. Note that NgModules
    are different from the ES2015 modules that we described in [Chapter 3](ch03.html
    "Chapter 3. TypeScript Crash Course"), *TypeScript Crash Course*. The Angular
    modules are a framework feature, in contrast to ES2015 modules which are a language
    construct.'
  prefs: []
  type: TYPE_NORMAL
- en: 'NgModules have the following responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide context of the Angular template compiler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a level of encapsulation where we can have components or directives,
    which are used only within the boundaries of a given module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In NgModules, we can configure the providers for the DI mechanism of the framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![A conceptual overview of Angular](img/5081_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the new router is used to define the routes in our application. Since
    **Directives** do not own a template, only the **Components** can be rendered
    by the router, representing the different views in our application. The router
    also uses a set of predefined directives, which allow us to define hyperlinks
    between the different views and the container where they should be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will look more closely at these concepts, see how they work together
    to make Angular applications, and how they've changed from their AngularJS predecessors.
  prefs: []
  type: TYPE_NORMAL
- en: Changing directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AngularJS introduced the concept of directives in the development of single-page
    applications. The purpose of directives is to encapsulate the DOM-related logic
    and allow us to build user interfaces by composing them. This way, we are able
    to extend the syntax and the semantics of HTML. Initially, like most innovative
    concepts, directives were viewed controversially because they predispose us to
    write invalid HTML when using custom elements or attributes without the `data-`
    prefix. However, over time, this concept has gradually been accepted and has proved
    that it is here to stay.
  prefs: []
  type: TYPE_NORMAL
- en: Another drawback of the implementation of directives in AngularJS is the different
    ways we can use them. This requires an understanding of the attribute values,
    which can be literals, expressions, callbacks, or microsyntax. This makes tooling
    essentially impossible.
  prefs: []
  type: TYPE_NORMAL
- en: The latest versions of Angular keep the concept of directives, but take the
    best parts from AngularJS and add some new ideas and syntax to it. The main purpose
    of Angular's directives is to attach behavior to the DOM by extending it with
    custom logic defined in an ES2015 class. We can think of these classes as controllers
    associated to the directives and think of their constructors as similar to the
    linking function of the directives from AngularJS. However, the new directives
    have limited configurability. They do not allow to associate a template with them,
    which makes most of the already known properties for defining directives unnecessary.
    The simplicity of the API does not limit directives' behavior, but only enforces
    stronger separation of concerns. To complement this simpler API, Angular 2 introduced
    a richer interface for the definition of UI elements, called components. Components
    extend the functionality of directives by allowing them to own a template, through
    the** component metadata**. We will take a further look at components later in
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax used for Angular directives involves ES2016 decorators. We can use
    TypeScript, ES2015, or even **ECMAScript** **5** (**ES5**) in order to achieve
    the same result with a little bit more typing. This code defines a simple directive,
    written in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The directive can be used with the following markup in our template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once the user points over the label, **Tell me the answer!**, Angular will invoke
    the method defined under the `@HostListener` decorator in the directive's definition.
    In the end, the `open` method of the overlay manager will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we can have multiple directives on a single element, the best practices
    state that we should use an attribute as a selector.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative ECMAScript 5 syntax for the definition of this directive is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding ES5 syntax demonstrates the internal JavaScript DSL that Angular
    provides in order to allow us to write our code without the syntax, which is not
    yet supported by modern browsers.
  prefs: []
  type: TYPE_NORMAL
- en: We can summarize that Angular kept the concept of directives by maintaining
    the idea of attaching behavior to the DOM. The core differences with AngularJS
    are the new syntax, and the further separation of concerns introduced by bringing
    the components. In [Chapter 4](ch04.html "Chapter 4. Getting Started with Angular
    Components and Directives"), *Getting Started with Angular Components and Directives*,
    we will take a further look at directives' API. We'll also compare the directives'
    definition syntax using ES2016 and ES5\. Now, let's take a look at the big change to
    Angular components.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know Angular components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Model View Controller** (**MVC**) is a micro-architectural pattern initially
    introduced for the implementation of user interfaces. As Angular developers, we
    use different variations of this pattern on a daily basis, most often **Model
    View ViewModel** (**MVVM**). In MVC, we have the model, which encapsulates the
    business logic of our application, and the view, which is responsible for rendering
    the user interface, accepting user input, and delegating the user interaction
    logic to the controller. The view is represented as composition of components,
    which is formally known as the **composite design pattern**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following structural diagram, which shows the composite
    design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting to know Angular components](img/5081_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have three classes:'
  prefs: []
  type: TYPE_NORMAL
- en: An abstract class called `Component`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two concrete classes called `Leaf` and `Composite`. The `Leaf` class is a simple
    terminal component in the component tree that we will build soon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Component` class defines an abstract operation called `operation`. Both
    `Leaf` and `Composite` inherit from the `Component` class. However, the `Composite`
    class also owns references to it. We can take this even further and allow `Composite`
    to own a list of references to instances of `Component`, as shown in the diagram.
    The components list inside `Composite` can hold references to different `Composite`
    or `Leaf` instances, or instances of other classes, which extend the `Component`
    class or any of its successors. We can have a different behavior of the `operation`
    methods of the individual `Component` instances invoked within the implementation
    of the `operation` method of `Composite`. This is because of the late-binding
    mechanism used for the implementation of polymorphism in object-oriented programming
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: Components in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enough of theory! Let''s build a component tree based on the class hierarchy
    illustrated in the preceding diagram. This way, we will demonstrate how we can
    take advantage of the composite pattern for building user interface using simplified
    syntax. We will take a look at a similar example in the context of Angular in
    [Chapter 4](ch04.html "Chapter 4. Getting Started with Angular Components and
    Directives"), *Getting Started with Angular Components and Directives*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding pseudo-code creates three instances of the `Composite` class
    and three instances of the `Leaf` class. The `c1` instance holds references to
    `c2` and `c3` inside the components list. The `c2` instance holds references to
    `l1` and `l2`, and `c3` holds reference to `l3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Components in action](img/5081_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram is a graphical representation of the component tree we
    built in the snippet. This is a simplified version of what the view in the modern
    JavaScript frameworks looks similar to. However, it illustrates the very basics
    of how we can compose directives and components. For instance, in the context
    of Angular, we can think of directives as instances of the `Leaf` class (since
    they don't own view and, thus, cannot compose other directives and components)
    and components as instances of the `Composite` class.
  prefs: []
  type: TYPE_NORMAL
- en: If we think more abstractly for the user interface in AngularJS, we can notice
    that we used quite a similar approach. The templates of our views compose different
    directives together in order to deliver a fully functional user interface to the
    end user of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Components in Angular
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular took this approach by introducing new building blocks called components.
    Components extend the directive concept we described in the previous section and
    provide a broader functionality. Here is the definition of a basic "Hello world"
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use it by inserting the following markup in our view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: According to the best practices, we should use a selector of type element for
    components since we may have only a single component per DOM element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The alternative ES5 syntax Angular provides using the DSL is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We will take a look at the preceding syntax in more detail later in this book.
    Now let's briefly describe the functionality that this component provides. Once
    the Angular application is bootstrapped, it will look at all the elements in the DOM
    tree and process them. When it finds an element called `hello-world`, it will
    invoke the logic associated with its definition, which means that the template
    of the component will be rendered and the expression between the curly brackets
    will be evaluated. This will result in the markup, `<h1>Hello, world!</h1>`.
  prefs: []
  type: TYPE_NORMAL
- en: So, to summarize, the Angular core team separated out the directives from AngularJS
    into two different parts-components and directives. Directives provide an easy
    way to attach behavior to DOM elements without defining a view. Components in
    Angular provide a powerful, and yet simple-to-learn API, which makes it easier
    to define the user interface of our applications. Angular components allow us
    to do the same amazing things as AngularJS directives, but with less typing and
    fewer things to learn. Components extend the Angular directive concept by adding
    a view to it. We can think of the relation between Angular components and directives
    the same way as the relation between `Composite` and `Leaf` from the diagram we
    saw in *Figure 5*.
  prefs: []
  type: TYPE_NORMAL
- en: Conceptually, we can present the relation between Directive and Component as
    inheritance. [Chapter 4](ch04.html "Chapter 4. Getting Started with Angular Components
    and Directives"), *Getting Started with Angular Components and Directives*, describes
    these two concepts in further detail.
  prefs: []
  type: TYPE_NORMAL
- en: Angular modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In AngularJS, we have the concept of modules. Modules there are responsible
    for grouping pieces of related functionality together and registering it internally during
    the bootstrap process. Unfortunately, they didn't provide features such as encapsulation and
    lazy loading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular introduced the NgModules as part of the fifth release candidate of
    the framework. The main purpose of the new modules is to give a context for the
    Angular compiler and achieve a good level of encapsulation. For instance, if we
    are building a library with NgModules, we can have a number of declarations, which
    are used internally but not exported as part of the public interface. Let''s take
    a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Do not worry if you're not familiar with the TypeScript syntax in the preceding
    example; we will take a deep dive into the language in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code snippet, using the `@NgModule` decorator, we declare `TabModule`.
    Note that in the list of `declarations`, we include both `TabComponent` and `TabItemComponent`,
    but in the list of `exports`, we have only `TabComponent`. This way, we can achieve
    a level of encapsulation for our library. The users of the module will be able
    to use only `TabComponent`, so we don't have to worry about backward compatibility
    of the API of `TabItemComponent` since it's accessible only internally, within
    the boundaries of our module. Finally, by setting the `imports` property of the
    object literal passed to `@NgModule`, we can list modules that we want to use
    inside of the current module. This way, we will be able to take advantage of all
    the `exports` and `providers` (we'll discuss providers in [Chapter 5](ch05.html
    "Chapter 5. Dependency Injection in Angular"), *Dependency Injection in Angular*)
    declared by them.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping an Angular application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to AngularJS, before our application gets rendered, it goes through the
    bootstrap process. In the new Angular, we can bootstrap an application in different
    ways, depending on the used platform (for instance, web, NativeScript, with JiT
    or AoT compilation enabled, and so on). Let''s take a look at a simple example,
    of how we can bootstrap a Web app, in order to get a better understanding of how
    the new Angular modules can be used in the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the `@NgModule` decorator in the preceding example, we declare `AppComponent`
    and we also import `BrowserModule`. Note that this time, we provide value to the
    `bootstrap` property where we explicitly declare that we want `AppComponent` to
    be used for bootstrapping our application.
  prefs: []
  type: TYPE_NORMAL
- en: On the last line of the file, we invoke the `bootstrapModule` method of the
    object returned by the invocation of `platformBrowserDynamic` with argument `AppModule`.
  prefs: []
  type: TYPE_NORMAL
- en: In recap, the modules in Angular have an important role-they not only group
    the building blocks of our application logically but also provide a way we can
    achieve encapsulation. Last, but not least, NgModules are heavily used in the
    application's bootstrap process.
  prefs: []
  type: TYPE_NORMAL
- en: Pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In business applications, we often need to have different visual representations
    of the same piece of data. For example, if we have the number 100,000 and we want
    to format it as currency, most likely we won't want to display it as plain data;
    more likely, we'll want something like $100,000.
  prefs: []
  type: TYPE_NORMAL
- en: The responsibility for formatting data in AngularJS was assigned to filters.
    Another example for a data formatting requirement is when we use collections of
    items. For instance, if we have a list of items, we may want to filter it based
    on a predicate (a boolean function); in a list of numbers, we may want to display
    only the prime numbers. AngularJS has a filter called `filter`, which allows us
    to do this. However, the duplication of the names often leads to confusion. That's
    another reason the core team renamed the filter component to a **pipe**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The motivation behind the new name is the syntax used for pipes and filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we apply the pipes, `decimal`, and `currency`, to
    the value returned by the `expression`. The entire expression between the curly
    braces looks like Unix pipe syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Defining pipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The syntax for defining pipes is similar to the one used for the definition
    of modules, directives, and components. In order to create a new pipe, we can
    use the ES2015 decorator, `@Pipe`. It allows us to add metadata to a class, declaring
    it as a pipe. All we need to do is provide a name for the pipe and define the
    data formatting logic. There's also an alternative ES5 syntax, which can be used
    if we want to skip the process of transpilation.
  prefs: []
  type: TYPE_NORMAL
- en: During runtime, once the Angular expression interpreter finds out that a given
    expression includes a call of a pipe, it will retrieve it out of the pipes' collection
    allocated within the component and invoke it with appropriate arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates how we can define a simple pipe called `lowercase1`,
    which transforms the given string, passed as argument to its lowercase representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to be consistent, let''s show the ECMAScript 5 syntax for defining
    pipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Using the TypeScript syntax, we implement the `PipeTransform` interface and
    define the `transform` method declared inside it. However, in ECMAScript 5, we
    do not have support for interfaces, but we still need to implement the `transform`
    method in order to define a valid Angular pipe. We will explain the TypeScript
    interfaces in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s demonstrate how we can use the `lowercase1` pipe inside a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the alternative ECMAScript 5 syntax for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `App` component with the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The result we will see on the screen is the text sample within an `h1` element.
    Note that we're including a reference to the `LowerCasePipe1` in the `declarations`
    property of the `@NgModule` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: By keeping the data formatting logic as a separate component, Angular keeps
    the strong separation of concerns that can be seen throughout. We will take a
    look at how we can define stateful and stateless pipes for our application in
    [Chapter 7](ch07.html "Chapter 7. Explaining Pipes and Communicating with RESTful
    Services"), *Explaining Pipes and Communicating with RESTful Services*.
  prefs: []
  type: TYPE_NORMAL
- en: Improving change detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw earlier, the view in MVC updates itself, based on change events it
    receives from the model. A number of **Model View Whatever** (**MVW**) frameworks
    took this approach and embedded the observer pattern in the core of their change
    detection mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Classical change detection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at a simple example, which doesn''t use any framework. Suppose,
    we have a model called `User`, which has a property called `name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet again uses TypeScript. Do not worry if the syntax does
    not look familiar to you, we will make an introduction to the language in the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `user` class extends the `EventEmitter` class. This provides primitives
    for emitting and subscribing to events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define a view, which displays the `name` of an instance of the
    `User` class, passed as an argument to its `constructor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can initialize the `view` element by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As the end result, the user will see a label with the content **foo**. However,
    changes in user will not be reflected by the view. In order to update the view
    when the `name` of the user changes, we need to subscribe to the `change` event
    and then update the content of the DOM element. We need to update the `View` definition
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is how most frameworks used to implement their change detection before
    the era of AngularJS.
  prefs: []
  type: TYPE_NORMAL
- en: Change detection in AngularJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most beginners are fascinated by the data binding mechanism in AngularJS. The
    basic "Hello world" example looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this, **Hello world!** magically appears on the screen. However,
    that is not the only most impressive thing! If we add a text input and we bind
    it to the `label` property of the scope, each change will reflect in the content
    displayed by the interpolation directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How awesome is that! This is one of the main selling points of AngularJS-the
    extreme ease of achieving data binding. We add a few attributes in our markup,
    interpolation directive, the `label` property to a mystical object called `$scope`,
    which is magically passed to a custom function we define, and everything simply
    works!
  prefs: []
  type: TYPE_NORMAL
- en: The more experienced Angular developer has a better understanding of what is
    actually going on behind the scenes. In the preceding example, inside the directives,
    `ng-model` and `ng-bind` (in our case, the interpolation directive, `{{}}`), Angular
    adds watchers with different behavior associated with the same expression - `label`.
    These watchers are quite similar to the observers in the classical MVC pattern.
    On some specific events (in our case, change of the content of the text input),
    AngularJS will loop over all such watchers, evaluate the expressions associated
    with them in the context of a given scope, and store their results. This loop
    is known as the **digest loop**.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding examples, the evaluation of the expression, `label`, in the
    context of the scope will return the text, **Hello world!**. On each iteration,
    AngularJS will compare the current result of the evaluation with the previous
    result and will invoke the associated callback in case the values differ. For
    instance, the callback added by the interpolation directive will set the content
    of the element to be the new result of the expression's evaluation. This is an
    example of the dependency between the callbacks of the watchers of two directives.
    The callback of the watcher added by `ng-model` modifies the result of the expression
    associated with the watcher added by the interpolation directive.
  prefs: []
  type: TYPE_NORMAL
- en: This approach has its own drawbacks. We said that the digest loop will be invoked
    on some specific events, but what if these events happen outside the framework;
    for example, what if we use `setTimeout`, and inside the callback, passed as the
    first argument, we change properties attached to the scope that we're watching?
    AngularJS will be unaware of the change and won't invoke the digest loop, so we
    need to do that explicitly using `$scope.$apply`. But, what if the framework knew
    about all the asynchronous events happening in the browser, such as user events,
    the `XMLHttpRequest` events, the `WebSocket`-related events, and others? In such
    a case, Angular would be able to intercept the event's handling and could invoke
    the digest loop without forcing us to do so!
  prefs: []
  type: TYPE_NORMAL
- en: In the zone.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: That's exactly the case in the new versions of Angular. This functionality is
    implemented with zones using `zone.js`.
  prefs: []
  type: TYPE_NORMAL
- en: At ng-conf in 2014, Brian Ford gave a talk about zones. Brian presented zones
    as meta-monkey patching of browser APIs. Zone.js is a library developed by the
    Angular team, which implements zones in JavaScript. They represent an execution
    context, which allows us to intercept asynchronous browser calls. Basically, using
    zones, we are able to invoke a piece of logic just after the given `XMLHttpRequest`
    completes or when we receive a new `WebSocket` event. Angular took advantage of
    `zone.js` by intercepting asynchronous browser events and invoking the digest
    loop just at the right time. This totally eliminates the need for explicit calls
    of the digest loop by the developer using Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Simplified data flow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The cross-watcher dependencies may create a tangled data flow in our application,
    which is hard to follow. This may lead to unpredictable behavior and bugs, which
    are hard to find. Although Angular kept the dirty checking as a way to achieve
    change detection, it enforced unidirectional data flow. This happened by disallowing
    dependencies between the different watchers, which allows the digest loop to be
    run only once. This strategy increases the performance of our applications dramatically
    and reduces the complexity of the data flow. Angular also made improvements to
    memory efficiency and the performance of the digest loop. Further details on Angular's
    change detection and the different strategies used for its implementation can
    be found in [Chapter 4](ch04.html "Chapter 4. Getting Started with Angular Components
    and Directives"), *Getting Started with Angular Components and Directives*.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing AngularJS's change detection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's take a step back and again think about the change detection mechanism
    of the framework.
  prefs: []
  type: TYPE_NORMAL
- en: We said that inside the digest loop, Angular evaluates registered expressions
    and compares the evaluated values with the values associated with the same expressions
    in the previous iteration of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: The most optimal algorithm used for the comparison may differ depending on the
    type of the value returned from the expression's evaluation. For instance, if
    we get a mutable list of items, we need to loop over the entire collection and
    compare the items in the collections one by one in order to verify if there is
    a change or not. However, if we have an immutable list, we can perform a check
    with a constant complexity, only by comparing references. This is the case because
    the instances of immutable data structures cannot change. Instead of applying
    an operation, which intends to modify such instances, we'll get a new reference
    with the modification applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'In AngularJS, we can add watchers using a few methods. Two of them are `$watch(exp,
    fn, deep)` and `$watchCollection(exp, fn)`. These methods give us some level of
    control over the way the change detection will perform the equality check. For
    example, adding a watcher using `$watch` and passing a `false` value as a third
    argument will make AngularJS perform a reference check (that is, compare the current
    value with the previous one using `===`). However, if we pass a truthy (any `true`
    value), the check will be deep (that is, using `angular.equals`). This way, depending
    on the expected type of the return by the expression value, we can add listeners
    in the most appropriate way in order to allow the framework to perform equality
    checks with the most optimal algorithm available. This API has two limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: It does not allow you to choose the most appropriate equality check algorithm
    at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not allow you to extend the change detection to third parties for their
    specific data structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Angular core team assigned this responsibility to differs, allowing them
    to extend the change detection mechanism and optimize it, based on the data we
    use in our applications. Angular defines two base classes, which we can extend
    in order to define custom algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`KeyValueDiffer`: This allows us to perform advanced diffing over key value-based
    data structures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IterableDiffer`: This allows us to perform advanced diffing over list-like
    data structures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular allows us to take full control over the change detection mechanism by
    extending it with custom algorithms, which wasn't possible in the previous version
    of the framework. We'll take a further look into the change detection and how
    we can configure it in [Chapter 4](ch04.html "Chapter 4. Getting Started with
    Angular Components and Directives"), *Getting Started with Angular Components
    and Directives*.
  prefs: []
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Services are the building blocks that Angular provides for the definition of
    the business logic of our applications. In AngularJS, we had three different ways
    of defining services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Although the first two syntactical variations provide similar functionality,
    they differ in the way the registered service will be instantiated. The third
    syntax allows further configuration of the registered provider during configuration
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having three different methods for defining services is quite confusing for
    the AngularJS beginners. Let''s think for a second what necessitated the introduction
    of these methods for registering services. Why can''t we simply use JavaScript
    constructor functions, object literals, or ES2015 classes instead, which Angular
    will not be aware of? We could encapsulate our business logic inside a custom
    JavaScript constructor function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is completely valid. However, it doesn''t take advantage of one of
    the key features that AngularJS provides: the DI mechanism. The `MainCtrl` function
    uses the constructor function, `UserTransaction`, which is visible in its body.
    The preceding code has two main pitfalls:'
  prefs: []
  type: TYPE_NORMAL
- en: We're coupled with the logic used for the service's instantiation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code is not testable. In order to mock `UserTransactions`, we need to monkey
    patch it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does AngularJS deal with these two things? When a given service is required,
    through the DI mechanism of the framework, AngularJS resolves all of its dependencies
    and instantiates it by passing it to a factory function, which encapsulates the
    logic for its creation. The factory function is passed as the second argument
    to the `factory` and `service` methods. The `provider` method allows the definition
    of a service on a lower level; the factory method there is the one under the `$get`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like AngularJS, the new versions of Angular tolerates this separation
    of concerns as well, so the core team kept the services. In contrast to AngularJS,
    the last major version of the framework provides a much simpler interface for
    their definition by allowing us to use plain ES2015 classes or ES5 constructor
    functions. We cannot escape from the fact that we need to explicitly state the
    services that should be available for injection and somehow specify instructions
    for their instantiation. In contrast to AngularJS, now the framework uses the
    ES2016 decorator''s syntax for this purpose, instead of the methods familiar to
    us from AngularJS. This allows us to define the services in our applications as
    simple as ES2015 classes, with decorators for configuration of the DI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the alternative ECMAScript 5 syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Services are related to the components and the directives described in the previous
    sections. For developing highly coherent and reusable UI components, we need to
    move all the business-related logic to inside our services. Also, in order to
    develop testable components, we need to take advantage of the DI mechanism to
    resolve all their dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: A core difference with the services in AngularJS is the way their dependencies
    are being resolved and represented internally. AngularJS uses strings to identify
    the different services and the associated factories used for their instantiation.
    On the other hand, now Angular uses keys instead. Usually, the keys are the types
    of the distinct services. Another core difference in the instantiation is the
    hierarchical structure of injectors, which encapsulate different dependency providers
    with different visibility.
  prefs: []
  type: TYPE_NORMAL
- en: Another distinction between the services in the last two major versions of the
    framework is the simplified syntax. Although the new versions of Angular use ES2015
    classes for the definition of our business logic, we can use the ECMAScript 5
    `constructor` functions as well or use the DSL provided by the framework. The
    DI in the latest versions of Angular has a completely different syntax and has
    improved behavior by providing a consistent way of injecting dependencies. The
    syntax used in the preceding example uses ES2016 decorators, and in [Chapter 5](ch05.html
    "Chapter 5. Dependency Injection in Angular"), *Dependency Injection in Angular*,
    we'll take a look at alternative syntax, which uses ECMAScript 5\. You can also
    find a more detailed explanation of Angular services and DI in [Chapter 5](ch05.html
    "Chapter 5. Dependency Injection in Angular"), *Dependency Injection in Angular*.
  prefs: []
  type: TYPE_NORMAL
- en: The new router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In traditional Web applications, all the page changes are associated with a
    full-page reload, which fetches all of the referenced resources and data and renders
    the entire page onto the screen. However, requirements for Web applications have
    evolved over time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Single-page applications** (**SPAs**) that we build with Angular simulate
    desktop user experiences. This often involves incremental loading of the resources
    and data required by the application, and no full-page reloads after the initial
    page load. Often, the different pages or views in SPAs are represented by different
    templates, which are loaded asynchronously and rendered on a specific position
    on the screen. Later, when the template with all the required resources is loaded
    and the route is changed, the logic attached to the selected page is invoked and
    populates the template with data. If the user presses the refresh button after
    the given page in our SPA is loaded, the same page needs to be re-rendered after
    the refresh of the view completes. This involves similar behavior: finding the
    requested view, fetching the required template with all referenced resources,
    and invoking the logic associated with that view.'
  prefs: []
  type: TYPE_NORMAL
- en: The template that needs to be fetched, and the logic that should be invoked
    after the page reloads successfully, depends on the view selected before the user
    pressed the refresh button. The framework determines this by parsing the page
    URL, which contains the identifier of the currently selected page, represented
    in a hierarchical structure.
  prefs: []
  type: TYPE_NORMAL
- en: All the responsibilities related to the navigation, changing the URL, loading
    the appropriate template, and invoking specific logic when the view is loaded
    are assigned to the router component. These are some quite challenging tasks,
    and support for different navigation APIs required for cross-browser compatibility
    makes the implementation of routing in modern SPAs a nontrivial problem.
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS introduced the router in its core, which was later externalized into
    the `ngRoute` module. It allows a declarative way for defining the different views
    in our SPA, by providing a template for each page and a piece of logic that needs
    to be invoked when a page is selected. However, the functionality of the router
    is limited. It does not support essential features, such as nested view routing.
    That's one of the reasons most developers preferred to use `ui-router`, developed
    by the community. Both AngularJS's router, and `ui-router`, route-definitions
    include a route configuration object, which defines a template and a controller
    associated with the page.
  prefs: []
  type: TYPE_NORMAL
- en: As described in the previous sections, Angular changed the building blocks it
    provides for the development of SPAs. Angular removes the floating controllers
    and instead represents views as a composition of components. This necessitates
    the development of a brand new router, which empowers these new concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The core differences between the AngularJS router and the new Angular router
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The new router is component based, `ngRoute` is not. The new Angular router
    associates a component with the individual routes or a module in case of lazy-loaded
    routes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is now support for nested views.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular route definition syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a brief look at the new syntax used by the Angular router to define
    routes in our applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We won't go into too much detail here since [Chapter 6](ch06.html "Chapter 6. Working
    with the Angular Router and Forms"), *Working with the Angular Router and Forms,* and
    [Chapter 7](ch07.html "Chapter 7. Explaining Pipes and Communicating with RESTful
    Services"), *Explaining Pipes and Communicating with RESTful Services*, are dedicated
    to the new router, but let's mention the main points in the preceding code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: The router lives in `@angular/router`. Since `AppModule` is the root module
    of our application, we use the `forRoot` method of `RouterModule` in order to
    import all the required directives and services exported by the router.
  prefs: []
  type: TYPE_NORMAL
- en: The parameter passed to the `RouterModule.forRoot` decorator shows how we define
    the routes in our application. We use an array with objects, which defines the
    mappings between routes and the components associated with them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a quick overview of the main building blocks for developing
    SPAs provided by Angular. We pointed out the main differences with the core concepts
    from AngularJS.
  prefs: []
  type: TYPE_NORMAL
- en: Although we can use ES2015, or even ES5, to build Angular applications, the
    recommendation from Google is to take advantage of the language used for the development
    of the framework-TypeScript. This way we can use advanced features such as Ahead-of-Time
    compilation that we're going to describe in [Chapter 8](ch08.html "Chapter 8. Tooling
    and Development Experience"), *Tooling and * *Development Experience*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take a look at TypeScript and how we can start using
    it in our next application. We will also explain how with ambient type definitions we
    can take advantage of the static typing in the JavaScript libraries and frameworks
    written in vanilla JavaScript.
  prefs: []
  type: TYPE_NORMAL
