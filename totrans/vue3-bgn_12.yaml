- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Achieving Client-Side Validation with VeeValidate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A website is not complete until it has a form of some sort. Contact Us, feedback,
    and comment forms are just a few examples that we may be required to develop and
    validate in our Vue.js application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explain what makes a semantically correct form, introduce
    the available fields, and talk through its accessibility needs. We will then update
    our `CreatePost` component and learn how to handle form fields and manage two-way
    binding using `v-model`. Next, we will move on to creating a new form called `contactUs`.
    This will be used to introduce a new package called **VeeValidate**. Finally,
    we will learn how to develop custom validation rules and how to simplify our validation
    by using VeeValidate preset rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two-way binding with `v-model`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling your form using VeeValidate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining your form validation with VeeValidate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you should have gained a good understanding of forms
    and how to handle them in Vue.js. You will be able to define well-structured and
    accessible forms, handle user input with `v-model`, and define complex forms with
    validation using VeeValidate.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the branch is called `CH12`. To pull this branch, run the
    following command or use your GUI of choice to support you in this operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether you are new to development or you already have some experience, it is
    important to spend a bit of time looking at what makes a good form and how to
    best define forms.
  prefs: []
  type: TYPE_NORMAL
- en: I started to learn forms over 10 years ago but still, for me, there was something
    new to learn while I completed my research for this chapter. HTML5 enhancement
    and accessibility requirements have modified the way we define forms. In this
    section, we are going to understand what makes a good form, and then, in later
    sections, we will use this knowledge to define some forms in our Companion App.
  prefs: []
  type: TYPE_NORMAL
- en: In most static sites, such as brochure sites or blogs, forms are the only time
    in which a user interacts with your site, and as such, they need to offer a great
    user experience (UX) and be as accessible as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good form includes three different aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: It is semantically correct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is accessible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is validated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will have covered all three aspects, and you
    will be able to create great forms.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the first point and see what makes a good HTML structure. Using
    the correct HTML is not only going to improve our UX but it is also going to set
    the foundation for the accessibility work that will be covered later in the section.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that this book is not about basic HTML and JavaScript but it focuses
    on Vue.js. For this reason, this section is just going to be a very quick introduction
    to forms; we will not spend too much time going into the details but will cover
    the main topics so that you can follow the rest of the chapter at ease and ensure
    that your form is well structured.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping your form within the <form> element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start with the basics that are often overlooked. All forms need to be
    wrapped within a `<form>` element. This is not just something nice to do but it
    also has some very important meaning behind it.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `<form>` element has three benefits. First, it informs the browser
    about the presence of a form (important for browser extension). Second, it improves
    the UX for visually impaired users who use a screen reader (software that reads
    the page for users) by supporting **Form** mode (a specific mode used by screen
    readers to complete forms on websites). Next, it helps to handle validation.
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself how the use of the `<form>` element improves UX.
    Well, have you ever wondered why, sometimes, a form can be submitted by pressing
    the *Enter* key and sometimes it can’t? Well, this is driven by the `<form>` element.
    When a form is wrapped in a `<form>` element, if the user clicks the *Enter* key
    while completing it, the form will trigger its `submit` method.
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget labels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The topic of the `<label>` element holds a special place in my heart. Many developers
    and designers miss the importance of this element and either remove it from the
    UI or misuse it. There was a trend a few years ago to develop compact form designs
    in which the placeholder replaced the label. These forms seemed very clear and
    started to be used everywhere, but they were a big failure from a UX perspective.
    Even if they look great, they can be hard to use because the placeholder disappears
    as soon as the user (or the browser) types something in the field and cannot be
    seen again until the user removes the entry.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with labels is the fact that they are essential from an accessibility
    perspective. In fact, without them, a visually impaired user would not be able
    to know what the field is about and, therefore, would be unable to fill in the
    form completely.
  prefs: []
  type: TYPE_NORMAL
- en: 'A label can be used in two different ways. It can either be used as a standalone
    element, using the ID to link it to an input field, or it can wrap the input field
    to which it belongs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Both methods are semantically correct, and their use is usually driven by the
    design that you may need to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: There is more than just type=”text”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I mentioned before, I started using forms a long time ago, and one thing
    that has progressed over time is the different types of input available nowadays
    and supported in all major browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the list of all available input types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`button`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`checkbox`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`date`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`datetime-local`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hidden`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`month`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`radio`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`range`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reset`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`search`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`submit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`week`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browsers offer fields for telephone numbers, dates, and even for email. But
    what would be the benefit of using them? Why not just use a simple `text` field?
    Well, the difference may not be in the way the field looks but, rather, in the
    way the field works.
  prefs: []
  type: TYPE_NORMAL
- en: Different fields may trigger different UIs. For example, a `date` field will
    open a calendar when clicked, a `number` field might show little toggles, and
    so on. This improvement in UX is even more noticeable on mobile phones where handsets
    can provide well-defined native components to support users in completing their
    forms.
  prefs: []
  type: TYPE_NORMAL
- en: Setting your form to be autocompleted
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Who doesn’t love a form that is completely autocompleted by the browser? Luckily
    for us, browsers are working very hard to complete as much of the form as possible
    out of the box. There are a couple of things that we can do to help browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'First and foremost, we need to inform the browser that we would like the form
    to be autocompleted. This is not done automatically but requires the `<form>`
    element to receive an `autocomplete` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next is ensuring that we describe the field with the correct name, as browsers
    can read the name and assign the correct field. So, if a field is an address,
    you should give it the proper name of `address` and not use shorthand such as
    `addr` or something else that the browser cannot understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least is defining the correct value to assign to the autocomplete
    attribute. Setting `autocomplete` on the main form may not be all that is needed.
    Sometimes, as in the case of browser extension used to autocomplete your passwords,
    the browser requires further information, and this can be passed using the `autocomplete`
    attribute directly on the field. `autocomplete` can accept different values depending
    on the role of the input. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a username:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For a sign-up form:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For signing in:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As shown by the username example, the type and name of the input do not have
    to match their `autocomplete` value. In fact, in the case of the username, even
    if the browser sees and uses the field as an email, a password tool would fill
    the field with the username.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned how to define a good form. Wrapping the form
    in `<form>`, setting `autocomplete`, defining the correct labels for each field,
    and using the correct input type are just a few steps that we can take to ensure
    that our users have a great experience in filling out our form.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to define and use forms in Vue.js and
    how the framework can help us improve the UX further.
  prefs: []
  type: TYPE_NORMAL
- en: Two-way binding with v-model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned how our form should be defined, and it is
    now time to put this learning into practice by enhancing our Companion App with
    a couple of forms. In this section, we will learn how to use `v-model` to enable
    our input field to accomplish two-way binding, which is a term used to describe
    when a field can emit change events and update values simultaneously (hence two-way).
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we mentioned that the solution used to manage the value
    in the `CreatePost` component was suboptimal, and it is now time to align it to
    use the best industry standards.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by rephrasing what two-way binding really achieves. Let’s consider
    an input field, for example. Until now, we have learned how to set the value of
    this field using `ref`. The use of `ref` allows us to set the value of a specific
    input field at load, but this is not very useful when it comes to forms, as we
    want the value to be set by the visitor’s input. In the previous chapter, we learned
    how to use events to emit change, so in the case of an input field, we could emit
    a change event that changes the R`ef` variable and, in turn, updates the value
    of the field.
  prefs: []
  type: TYPE_NORMAL
- en: 'This would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Even if the preceding code does achieve two-way binding, it does not really
    look clean, and adding this all over our forms would make the HTML very hard to
    read.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily for us, the Vue.js framework has a nice shortcut that will make our
    HTML clean, called `v-model`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the preceding to use `v-model` would result in the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Behind the scenes, `v-model` and the `event`/`value` syntax produce the same
    code, but due to the clean and concise code of `v-model`, it is the suggested
    option to achieve two-way binding when possible (there may be cases in which we
    would need to handle events manually to handle specific side effects; in these
    scenarios, the `event`/`value` syntax may be preferred).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have learned about the syntax and how to define the form, let’s
    go back and apply our learning to the `CreatePost` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let’s break down all the changes we applied to our form. First, we removed the
    R`ef` initialization of `createPostForm`. This reference was made to hold the
    value of the HTML form, but this is no longer needed after the refactor. Next,
    we created a reference called `postText` that will hold the value of our input
    field. We then added `v-model` within our input field, assigning it to the newly
    created `postText`.
  prefs: []
  type: TYPE_NORMAL
- en: At the first load, the input field is going to be an empty string (`const postText
    = ref("");)`, but this value is going to be automatically updated by `v-model`
    as the user types into the input field. Behind the scenes, `v-model` assigns the
    value on the first load and then automatically updates it every time the input
    field emits a change event.
  prefs: []
  type: TYPE_NORMAL
- en: While refactoring the form, we also introduced a small enhancement by adding
    a `.prevent` modifier to the `@submit` event. Doing so automatically calls `event.preventDefault()`
    when submitting our form.
  prefs: []
  type: TYPE_NORMAL
- en: The last change is in the payload of the `addPost` method. This method is now
    using `postText.value` instead of using the input reference to get the value.
  prefs: []
  type: TYPE_NORMAL
- en: Quick reminder
  prefs: []
  type: TYPE_NORMAL
- en: Just a quick reminder that using Template Ref to get an input value was just
    used for teaching purposes and should not be used in real life. Using Template
    R`ef` to access the HTML object should just be used for methods and actions that
    cannot be achieved with basic Vue.js features such as directives, computed properties,
    and events.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, the form is fully working using Vue.js two-way binding supported
    by `v-model`. If we try to use the form, this will work as expected and either
    create a post or show the browser native validation on incorrect input, as shown
    in *Figure 12**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1: Native validation message shown in the Create a Post form](img/B21130_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: Native validation message shown in the Create a Post form'
  prefs: []
  type: TYPE_NORMAL
- en: With the knowledge you have gained in this section, you will be able to create
    forms and handle user input within your application. In many scenarios, the validation
    offered by the native browser is either not “pretty” enough or does not fulfill
    the validation requirement of the form.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, in the next section, we are going to learn how to use an external
    package called VeeValidate to control the validation of our forms.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling your form using VeeValidate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned how to handle user input such as form fields
    using `v-model`, but in real life, handling forms is a little more complicated
    than just setting two-way binding.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, a complete form will include complex validation and error handling,
    just to name a couple. Even if we could achieve this feature manually using Vue.js,
    we would probably end up investing a lot of time and effort in something that
    is well handled by an external package. For this reason, in this section, we are
    going to introduce **VeeValidate**, which is a package aimed at making form development
    easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the official website ([https://vee-validate.logaretm.com/](https://vee-validate.logaretm.com/)),
    VeeValidate is described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: “VeeValidate is the most popular Vue.js form library. It takes care of value
    tracking, validation, errors, submissions and more.”
  prefs: []
  type: TYPE_NORMAL
- en: Using an external package is not required for every single form you will ever
    write, but it is useful if you want to create a well-written form, as the package
    provides you with a consistent way to define and handle logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step when dealing with a Node package is its installation. To install
    VeeValidate, we will have to open the terminal at the root of our project and
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This command will add the package to our repository for us to import and use.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we will create a form and learn how to use this package to
    make form development easy and consistent. We could have reused the **Create a
    Post** form, but we will create a new one so that you have both examples to look
    at in the future within your code base.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the scaffolding for this new form is already in place. We have a new
    button on the sidebar with the label `router` object, and a Vue.js component called
    `ContactView.vue` that uses the static template we defined in a previous chapter.
    Last but not least, we also have a basic page scaffolding with a component called
    `ContactUs` that is going to be our playground for the creation of this new form.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand VeeValidate, we are going to build our form in steps,
    starting from the basic form creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We created a `<form>` element with a `submit` event attached to a method called
    `handleSubmit`. We then defined two labels, one for `email` and the other for
    `message`, and finally, a button that will be used to submit the form.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we do not have any input fields yet. These were omitted
    on purpose because they are going to use built-in components offered by VeeValidate.
  prefs: []
  type: TYPE_NORMAL
- en: Using VeeValidate will take full control of the form, including its state, meaning
    that we will not have to define or manage the individual values as we did in the
    previous example with `v-model`.
  prefs: []
  type: TYPE_NORMAL
- en: The way in which VeeValidate can make this happen is with the use of built-in
    components that are purposely built to handle and manage the form for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we are going to look at three components: `Form`, `Field`,
    and `ErrorMessage`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Form` component is going to replace the native <form> element available
    in HTML. `Field` is going to take the place of the `<input>` field, and finally,
    `ErrorMessage` is going to be used to display a custom message if the field enters
    an `error` state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go back to our form and update it to use the new built-in components
    and then talk through how they got used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Our form is now updated to use VeeValidate. The first change may not be very
    noticeable, but it includes the change of the `<form>` element to the VeeValidate
    custom element, `<Form>`. The custom `<Form>` element is used by VeeValidate to
    handle the form values’ state.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we accompanied each label with a `Field` component. This component is
    imported from the `vee-validate` package.
  prefs: []
  type: TYPE_NORMAL
- en: The `Field` component is very similar to native form elements such as `<input>`
    and `<radio>` and accepts most of the attributes that you would use in a native
    input, such as placeholder and name type.
  prefs: []
  type: TYPE_NORMAL
- en: 'We created two fields. The first field is used for the email and has three
    attributes: `id`, `type` (which is `email`), and `name`, which is going to be
    used to connect the field with its error messages.'
  prefs: []
  type: TYPE_NORMAL
- en: The second field is associated with `message`; it is similar to the previous
    field used for the email, with the only difference being an extra attribute called
    `as`. This property is used to specify which form element the field should be
    rendered as. When using the `Field` component without using the `as` property,
    it defaults to an `<input>` element. In fact, for our message, we want the field
    to be a text area, and we achieved this by using the `as` property and assigning
    it a value of `textarea`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, the form has the HTML and the logic required to function. If
    we open our application at `http://localhost:5173/contact` and fill in the form,
    we will be able to see the form being submitted in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2: Console message triggered by the Contact Us form](img/B21130_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: Console message triggered by the Contact Us form'
  prefs: []
  type: TYPE_NORMAL
- en: Even if we have not finished yet with VeeValidate, you should be able to see
    the benefits that it brings. You may have realized that we never had to declare
    any references for the email and message or define any two-way binding with `v-model`.
    All of this is handled behind the scenes by the package with the `Form` and `Field`
    custom fields.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have added VeeValidate to our form and learned what benefits
    this will bring to our application. We then refactored our `Field` and `Form`
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have just one more modification to apply to our form before we can complete
    this chapter: validation. The preceding example shows that I was able to submit
    a form with incorrect values such as a fake email and a very short message. In
    the next section, we are going to learn how to use form validation with VeeValidate.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining your form validation with VeeValidate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A form is never complete until there is some sort of validation. The values
    of the form are sent to our servers, and we want to make sure that our forms can
    help the user with immediate feedback if any of the field values are incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the form we used in *Figure 12**.2* would have failed backend validation
    as the email was not in the correct format. In this section, we are going to learn
    how to create custom validation and introduce another supporting package offered
    by VeeValidate that includes a preset group of validation rules to speed up our
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Frontend validation is not enough
  prefs: []
  type: TYPE_NORMAL
- en: Remember that frontend validation like the one performed by VeeValidate is just
    going to improve the UX but it is not secure enough as it can easily be bypassed.
    When working with forms, you should also define validation on the backend. Using
    validation schemas that work on both the frontend and backend, such as Zod, can
    help.
  prefs: []
  type: TYPE_NORMAL
- en: VeeValidate offers the possibility to define its rules using either a declarative
    approach or by using composition functions (a set of composable functions offered
    by VeeValidate that can used to create your own form components). For the scope
    of this book, we are going to use the declarative method.
  prefs: []
  type: TYPE_NORMAL
- en: To validate our input fields, we need to define some validation rules. These
    rules are going to be methods that run a specific condition on one or more input
    fields. An example could be a `required` validation that would check whether the
    value of an input is defined, or a *minimum characters* rule that would check
    whether the number of characters is equal to or greater than the limit set.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first rule we are going to define is a simple `required` rule. To define
    a rule, we use a VeeValidate method called `defineRule`. This method accepts two
    arguments. The first is the name of the rule and the second is the function that
    will run to assess the validation. We can add the following code within the `ContactUs.vue`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Declaring a rule validation is not any different from a method that you would
    have defined natively in Vue. In the case of our required rule, we are checking
    whether the value is set and whether it has at least one character by using `!value`
    and `value.length`, respectively. Then, we are either returning `true` (if the
    validation passes successfully) or we are returning a string as an error message.
  prefs: []
  type: TYPE_NORMAL
- en: After declaring the rule, all that is left is to use it within a form field.
    Validation rules can be assigned to the `<Field>` element that we used before.
    The `Field` component expects a property called `rules`. This property can either
    accept a string or an object. I prefer the string notation as it is like the native
    validation in HTML but also because it has a shorter syntax that helps keep the
    `<template>` section clear and readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying the `required` rule to our `email` field would produce the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: At this stage, our form will not be submitted anymore unless the validation
    passes successfully. In fact, VeeValidate will just trigger our `submit` method
    if all fields in the form are valid. The next step required is to display an error
    message to the user when the form is invalid. This can be achieved with another
    component offered by VeeValidate, called `ErrorMessage`. The error message itself
    has already been defined in our validation rule, and VeeValidate is going to take
    care of the logic required to display and hide the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ErrorMessage` component accepts a property of `name` that is used to connect
    it with a specific input field. So, in our case, it is going to be `name="email"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When trying to submit the form, we will now be presented with an error message,
    as shown in *Figure 12**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3: Form displaying a validation error](img/B21130_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: Form displaying a validation error'
  prefs: []
  type: TYPE_NORMAL
- en: Even if our error is displayed successfully, it does not really stand out as
    it uses the same color as the rest of the text on the page. This is happening
    because the `ErrorMessage` component provided by VeeValidate is just a utility
    component, meaning that it does not actually provide any HTML markup but it is
    used to provide some additional functionality such as handling the error placement
    and visibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve our UI, we can use the `as` property to define an HTML element that
    will be used to wrap the error message, just like we did with `textarea`, we can
    use the attribute "as" to define what HTML field the component should be rendered
    as and add some classes. The code base already has some styles for a class named
    `error`. So, let’s go and modify our `ErrorMessage` component to use this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: After adding the `as` property and `class` attribute, our component is now going
    to be more prominent on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4: Form showing a red error message](img/B21130_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.4: Form showing a red error message'
  prefs: []
  type: TYPE_NORMAL
- en: The form is starting to take shape. The form fields and labels are set, the
    `submit` handler is in place (even if just a dummy one), and the validation rules
    are defined and working.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and last section of this chapter, we are going to learn about preset
    validation rules offered by VeeValidate. Declaring a simple rule such as `required`
    is simple, but this is not always the case.
  prefs: []
  type: TYPE_NORMAL
- en: I personally love to use preset rules as they help me keep components small
    and readable while still being able to provide complex validation rules.
  prefs: []
  type: TYPE_NORMAL
- en: Using VeeValidate rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have just applied a simple validation to the `email` field that checks
    whether it is set, but this would still break as the field is currently going
    to pass validation with just a single character.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to validate the email (to ensure it is written
    in a valid format) and the message text area (to ensure that we receive a message
    that is at least 100 characters).
  prefs: []
  type: TYPE_NORMAL
- en: Instead of declaring the validation manually by defining its rules, we are going
    to use the `@vee-validate/rules` package and use two of its preset rules to achieve
    our validation requirements.
  prefs: []
  type: TYPE_NORMAL
- en: VeeValidate offers over 25 rules ([https://vee-validate.logaretm.com/v4/guide/global-validators#vee-validaterules](https://vee-validate.logaretm.com/v4/guide/global-validators#vee-validaterules)),
    including simple rules such as `required`, `numeric`, and `emails`, as well as
    complex ones such as `one_of`, `not_one_of`, and `regex`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before learning the syntax required to use these rules, we need to install
    the package in our application. We can do this by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The power of VeeValidate and its validation is that it allows us to use more
    than one validation for a single field, allowing us to define complex rules, such
    as the one defined by `password` fields, without the need to write a single line
    of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve our validation needs, we are going to use the `email` and `min`
    rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Let’s analyze our latest code snippets and see how to use validation rules from
    VeeValidate.
  prefs: []
  type: TYPE_NORMAL
- en: First, we manually imported the validation from the `@vee-validate/rules`package.
    We could have imported all rules globally, but I prefer to do it within each component.
    This not only helps me understand the validation used within the component’s scope
    but also helps keep the built size small by ensuring we import the rules that
    we use within the code base.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we removed the `required` rule that we defined previously and replaced
    it with the ones offered by VeeValidate. We then declared two new rules called
    `email` and `min`. We did so using the `defineRule` method with the imported rules
    from `@vee-validate/rules`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have added our validation within the `<template>` section of our component.
    The `rules` property can accept multiple entries separated by the character `|`.
    In the case of `email`, the rules are `"required|email"`, but for `textarea`,
    they are `"required|min:100"`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we added `ErrorMessage` to our message text area.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the rules used in the `message` field are a little
    different from the ones used in `email`. This is because the `min` rule requires
    an argument that is equal to the number of characters required before the field
    can be marked as valid. To set a specified parameter for a rule, we add a colon
    (`:`) followed by one or more values separated by a comma. For example, to define
    a `max` rule of `164` characters, we would write `rules="max:164"`, while to define
    a rule that allows a number between `10` and `20`, we would write `rules="between:10,20"`.
  prefs: []
  type: TYPE_NORMAL
- en: Rules can be defined as an object
  prefs: []
  type: TYPE_NORMAL
- en: 'As I mentioned before, the `rules` property can be defined as an object. What
    you choose is personal preference and there is no right or wrong. If we wanted
    to replace the `message` field rule to be an object, we would write `rules="{
    required: true,` `min: 100}"`.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned how to validate our form. We first learned
    how to define and use validation rules by creating a simple `required` validation,
    and then we introduced the preset validation rules and used them to fully validate
    our form.
  prefs: []
  type: TYPE_NORMAL
- en: Your turn
  prefs: []
  type: TYPE_NORMAL
- en: Continue to work on the `handleSubmit` method to send a `fetch` request (to
    a fake endpoint) with the form input.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to handle user interaction by introducing two-way
    binding using `v-model` and form validation and handling using VeeValidate. During
    the chapter, we redefined what makes a semantically correct form, learned how
    to use the `v-model` syntax to define two-way binding, and then moved into the
    form territory by introducing VeeValidate and saw how it can be used to define,
    handle, and validate our forms.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a step back from coding and learn how to investigate
    and solve issues by introducing debugging techniques and using the exquisite Vue
    debugger browser extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 4: Conclusion and Further Resources'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final part of the book, we are going to explore reading materials, resources,
    and topics that will take your knowledge of the Vue.js framework further. In this
    part, we are also going to learn how to debug our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B21130_13.xhtml#_idTextAnchor177)*, Unveiling Application Issues
    with the Vue Devtools*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B21130_14.xhtml#_idTextAnchor187)*, Advanced Resources for Future
    Reading*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
