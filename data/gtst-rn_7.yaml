- en: Chapter 7. Integrating Native Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章。集成原生模块
- en: So far you've seen that React Native contains a large amount of functionality
    right out of the box. It provides an easy way for you to use a wide variety of
    native features via JavaScript, but sometimes you may need something that isn't
    yet covered by the built-in React Native components. Luckily, React Native is
    fully extensible via Native Modules. Thanks to a very active community, there
    is a growing list of custom components that are filling in the gaps. In this chapter,
    we'll use one of those third-party Native Modules to add camera support to our
    React Notes application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了 React Native 提供了大量开箱即用的功能。它通过 JavaScript 为你提供了一种简单的方法来使用各种原生功能，但有时你可能需要一些内置
    React Native 组件尚未覆盖的功能。幸运的是，React Native 通过原生模块完全可扩展。多亏了一个非常活跃的社区，有一长串自定义组件正在填补这些空白。在本章中，我们将使用这些第三方原生模块之一来为我们的
    React Notes 应用程序添加相机支持。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Installing the custom React Native camera module using `npm`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `npm` 安装自定义 React Native 相机模块
- en: Adding a `CameraScreen` and camera component
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 `CameraScreen` 和相机组件
- en: Saving captured images to disk
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将捕获的图像保存到磁盘
- en: Displaying the captured images in the `NoteImageScreen`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `NoteImageScreen` 中显示捕获的图像
- en: Adding images to notes
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将图像添加到笔记
- en: 'Our note-taking application is shaping up nicely, but a picture is worth a
    thousand words, so wouldn''t it be nice if we could take a photo and store it
    with a note? Since React Native does not ship with a camera component, we''ll
    need to use a very popular component created by *Lochlan Wansbrough*. The source
    code can be found at: [https://github.com/lwansbrough/react-native-camera](https://github.com/lwansbrough/react-native-camera).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的笔记应用正在逐步完善，但一张图片胜过千言万语，所以如果我们能拍照并和笔记一起保存，那岂不是很好？由于 React Native 没有内置相机组件，我们需要使用由
    *Lochlan Wansbrough* 创建的一个非常流行的组件。源代码可以在以下位置找到：[https://github.com/lwansbrough/react-native-camera](https://github.com/lwansbrough/react-native-camera)。
- en: 'At this point, you are most likely familiar with the addition of new screens
    to our navigation. Let''s quickly write the navigation code for the `CameraScreen`
    before we include the Native Module. In the `NavigationBarRouteMapper`, add the
    `camera` route to the `LeftButton` and `Title` attributes:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你很可能已经熟悉了向我们的导航中添加新屏幕。在我们包含原生模块之前，让我们快速编写 `CameraScreen` 的导航代码。在 `NavigationBarRouteMapper`
    中，将 `camera` 路由添加到 `LeftButton` 和 `Title` 属性：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, in the `ReactNotes` component update the `renderScene` method:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `ReactNotes` 组件中更新 `renderScene` 方法：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We pass in another prop called `showCameraButton` to the `NoteScreen`, which
    we will use later to hide the camera button from the android version.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递另一个名为 `showCameraButton` 的属性到 `NoteScreen`，我们将在稍后使用它来隐藏 Android 版本的相机按钮。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The same `showCameraButton` prop, except of value `false`, should be passed
    from the `renderScene` method for the Android version of ReactNotes: `showCameraButton={false}`.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Android 版本的 ReactNotes 中的 `showCameraButton` 属性相同，除了值为 `false`，应从 `renderScene`
    方法传递给 Android 版本：`showCameraButton={false}`。
- en: Installing react-native-camera on iOS
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 iOS 上安装 react-native-camera
- en: 'There are three steps to install react-native-camera and to include it in our
    `CameraScreen`. From the command line, navigate to the `ReactNotes` directory
    and run the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 react-native-camera 并将其包含在 `CameraScreen` 中有三个步骤。从命令行导航到 `ReactNotes` 目录，并运行以下命令：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you take a look at the `node_modules` directory in the `ReactNotes` project
    you''ll see a new directory named `react-native-camera`, which contains both the
    JavaScript and native source code of the module. In the `ios` subdirectory, you''ll
    notice a file called `RCTCamera.xcodeproj`, as shown in the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `ReactNotes` 项目的 `node_modules` 目录，你会看到一个名为 `react-native-camera` 的新目录，其中包含模块的
    JavaScript 和原生源代码。在 `ios` 子目录中，你会注意到一个名为 `RCTCamera.xcodeproj` 的文件，如下面的截图所示：
- en: '![Installing react-native-camera on iOS](img/B05162_07_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![在 iOS 上安装 react-native-camera](img/B05162_07_01.jpg)'
- en: 'We need to add this file to our Xcode project''s library. In the Xcode project
    navigator, right-click on **Libraries** and choose **Add Files to ReactNotes**:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将此文件添加到我们的 Xcode 项目的库中。在 Xcode 项目导航器中，右键单击 **库** 并选择 **将文件添加到 ReactNotes**：
- en: '![Installing react-native-camera on iOS](img/B05162_07_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![在 iOS 上安装 react-native-camera](img/B05162_07_02.jpg)'
- en: 'In the Finder window that appears, navigate to **ReactNotes** | **node_modules**
    | **react-native-camera** | **ios**, select **RCTCamera.xcodeproj** and click
    **Add**:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现的Finder窗口中，导航到**ReactNotes** | **node_modules** | **react-native-camera**
    | **ios**，选择**RCTCamera.xcodeproj**并点击**Add**：
- en: '![Installing react-native-camera on iOS](img/B05162_07_03.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![在iOS上安装react-native-camera](img/B05162_07_03.jpg)'
- en: Take a look at the **Libraries** folder in the project navigator and you should
    see **RCTCamera.xcodeproj** in the list.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 查看项目导航器中的**库**文件夹，您应该在列表中看到**RCTCamera.xcodeproj**。
- en: 'Next, select **ReactNotes** in the project navigator, click on **Build Phases**
    and expand the **Link Binary With Libraries** section:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在项目导航器中选择**ReactNotes**，点击**构建阶段**并展开**链接二进制库**部分：
- en: '![Installing react-native-camera on iOS](img/B05162_07_04.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![在iOS上安装react-native-camera](img/B05162_07_04.jpg)'
- en: 'Click the plus sign at the bottom of the **Link Binary with Libraries section**,
    select **libRCTCamera.a** from the list and click **Add**:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**链接二进制库**部分底部的加号，从列表中选择**libRCTCamera.a**，然后点击**Add**：
- en: '![Installing react-native-camera on iOS](img/B05162_07_05.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![在iOS上安装react-native-camera](img/B05162_07_05.jpg)'
- en: We're now ready to use the camera component in our application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始在应用程序中使用相机组件了。
- en: Searching for Native Modules
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索原生模块
- en: A brief note before we start using the camera component is how you can find
    these modules on your own. The two best places to look for open source Native
    Modules are either on GitHub ([https://github.com](https://github.com)) or NPM
    ([https://www.npmjs.com](https://www.npmjs.com)). A search on either of these
    sites will give you plenty of third-party modules created by the React Native
    community to use in your projects.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用相机组件之前，简要说明一下如何自己找到这些模块。寻找开源原生模块的两个最佳位置是GitHub ([https://github.com](https://github.com))
    或 NPM ([https://www.npmjs.com](https://www.npmjs.com))。在这两个网站上的搜索将为您提供大量由React
    Native社区创建的第三方模块，您可以在项目中使用。
- en: Using the camera component
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用相机组件
- en: 'The hard part is over! Importing the camera module is as simple as including
    any other React component:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 困难的部分已经结束！导入相机模块就像包含任何其他React组件一样简单：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Using the Camera component is quite simple, as well. Here''s the `render` function
    of the `CameraScreen`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相机组件相当简单。以下是`CameraScreen`的`render`函数：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The Camera module exposes a number of props that you can use to customize its
    behavior but most of the default values work well for our purpose. However, you'll
    note that we set the `captureTarget` property to `Camera.constants.CaptureTarget.disk`.
    This setting will place the saved images into a directory on the device that only
    our `ReactNotes` application has access to. The default value for the `captureTarget`
    property is `Camera.constants.CaptureTarget.cameraRoll`, which will put the image
    in the shared location used by the native camera when you're taking pictures.
    Although that will normally be acceptable, at the time of this writing there is
    a bug that prevents ReactNative from loading images from that location.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 相机模块公开了一些props，您可以使用它们来自定义其行为，但大多数默认值对我们的目的来说都很适用。然而，您会注意到我们设置了`captureTarget`属性为`Camera.constants.CaptureTarget.disk`。此设置将保存的图像放置在设备上的一个目录中，只有我们的`ReactNotes`应用程序可以访问。`captureTarget`属性的默认值是`Camera.constants.CaptureTarget.cameraRoll`，这将图像放置在您拍照时原生相机使用的共享位置。虽然这通常是可以接受的，但在撰写本文时，存在一个阻止ReactNative从该位置加载图像的bug。
- en: 'Take a look at the code listing above. Notice that we''ve added child components
    to the camera component. It behaves just like a `View` component; you''re now
    familiar with laying out children using the `Flexbox` attribute. In our example,
    we''ve added a `View` and a `SimpleButton` with an `onPress` handler that will
    capture the image:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 看看上面的代码列表。注意我们已经向相机组件添加了子组件。它表现得就像一个`View`组件；你现在熟悉使用`Flexbox`属性来布局子组件。在我们的例子中，我们添加了一个`View`和一个带有`onPress`处理器的`SimpleButton`，该处理器将捕获图像：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Recall that we added `ref="cam"` to the camera component declaration; thus,
    allowing us to refer to it in our handler. When we call the `capture()` function,
    we pass in a callback that takes two arguments, `err` (which should be null unless
    the user doesn't permit `ReactNotes` to use the camera) and data, which will include
    the full path to the image once it is saved to disk.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们在相机组件声明中添加了`ref="cam"`；因此，我们可以通过处理器来引用它。当我们调用`capture()`函数时，我们传递一个回调函数，该函数接受两个参数，`err`（除非用户不允许`ReactNotes`使用相机，否则应为null）和数据，其中将包括图像保存到磁盘后的完整路径。
- en: 'In order to save the path to the image along with the note, we''ll need to
    pass the data up using `this.props.onPicture(data)`. We''ll need to update our
    top-level `ReactNotes` component, but before we do that, here''s the complete
    code for the `CameraScreen`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将图片路径与笔记一起保存，我们需要使用`this.props.onPicture(data)`将数据向上传递。我们需要更新我们的顶级`ReactNotes`组件，但在我们这样做之前，这里是`CameraScreen`的完整代码：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Return to `index.ios.js` and add the `onPicture` callback to the `CameraScreen`
    props:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到`index.ios.js`并在`CameraScreen`的props中添加`onPicture`回调：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We''re passing in a callback that takes an `imagePath` and then calls `this.saveNoteImage(imagePath,
    route.note)`. Let''s add that function just above `renderScene`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递一个回调函数，该函数接受一个`imagePath`并调用`this.saveNoteImage(imagePath, route.note)`。让我们在`renderScene`上方添加该函数：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This function simply takes the `imagePath`, adds it to the note object, and
    passes the modified note to our `updateNote()` function.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数只是接受`imagePath`，将其添加到笔记对象中，并将修改后的笔记传递给我们的`updateNote()`函数。
- en: Now you can run the application in the simulator, click the **Take Picture**
    button and the screen becomes black! Don't worry, there's nothing wrong with your
    code; the iOS simulator doesn't have access to a camera, so it displays a black
    screen. However, if you click the **Capture** button, an image will be saved to
    your file system and when you return to view the image you'll actually see a white
    screen.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在模拟器中运行应用程序，点击**拍照**按钮，屏幕会变黑！别担心，你的代码没有问题；iOS模拟器无法访问相机，因此显示一个黑色屏幕。然而，如果你点击**捕获**按钮，图片将被保存到你的文件系统中，当你返回查看图片时，你实际上会看到一个白色屏幕。
- en: To verify if this works, you can `console.log` the `imagePath`, navigate to
    the image, modify the image, and then return to the `NoteImageScreen` to see your
    changes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这行是否有效，你可以使用`console.log`输出`imagePath`，导航到图片，修改图片，然后返回到`NoteImageScreen`查看你的更改。
- en: Viewing images
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看图片
- en: 'With images, it is important that they are getting saved to the `imagePath`
    attribute correctly, we want to be able to view them again. We will add another
    screen called `NoteImageScreen` that displays the image captured by the camera
    component. In the `App/Components/` directory, create the `NoteImageScreen.js`
    file. Same as before, we are going to include this in the navigation as shown:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用图片时，重要的是它们被正确地保存到`imagePath`属性中，我们希望能够再次查看它们。我们将添加另一个名为`NoteImageScreen`的屏幕，用于显示相机组件捕获的图片。在`App/Components/`目录中创建`NoteImageScreen.js`文件。和之前一样，我们将将其包含在导航中，如下所示：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You might notice that in the title code for the `noteImage` route we use another
    ES6 feature known as string interpolation. This allows us to format a string directly
    between the back ticks `` `${variable}` `` with the value of a variable, in this
    case its `route.note.title`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，在`noteImage`路由的标题代码中，我们使用了另一个ES6特性，称为字符串插值。这允许我们在反引号`` `${variable}`
    ``之间直接格式化字符串，其中变量的值是`route.note.title`。
- en: The image component
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图片组件
- en: 'The Image component is provided by React Native to display images from various
    sources, such as the local disk or over a network. To render our image, all we
    have to do is pass in the `imagePath` from our note to the source prop. In the
    `ImageNoteScreen` add:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Image组件由React Native提供，用于显示来自各种来源的图片，如本地磁盘或通过网络。要渲染我们的图片，我们只需将笔记中的`imagePath`传递给source属性。在`ImageNoteScreen`中添加：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we specify an object with an `uri` attribute to pass in the path. You
    can also use a `url` from the internet to render images this way also:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定一个带有`uri`属性的对象来传递路径。你也可以使用互联网上的`url`以这种方式渲染图片：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To require images locally just specify the path to the image:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地要求图片，只需指定图片的路径：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For more information on the Image component, see the React Native documentation
    at [https://facebook.github.io/react-native/docs/image.html](https://facebook.github.io/react-native/docs/image.html).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Image组件的更多信息，请参阅React Native文档[https://facebook.github.io/react-native/docs/image.html](https://facebook.github.io/react-native/docs/image.html)。
- en: Deleting images
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除图片
- en: 'In case the user takes the wrong picture, we need a way to be able to remove
    the image from a note. Similar to the navigation of the `NoteScreen`, we are going
    to `add` a `delete` button to the right-hand side. In the `ReactNotes` component,
    we are going to add the `deleteNoteImage` method to remove the `imagePath` attribute
    from the note:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户拍错了照片，我们需要一种方法来从笔记中删除图片。类似于`NoteScreen`的导航，我们将在右侧添加一个`delete`按钮。在`ReactNotes`组件中，我们将添加`deleteNoteImage`方法来从笔记中移除`imagePath`属性：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This looks similar to our `saveNoteImage` function, except that we are setting
    the value to `null`. Next, to add the button, we once again add the `noteImage`
    attribute to the `RightButton` function in `NavigationBarRouteMapper` and pass
    the `deleteNoteImage` function to the Navigator component:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与我们的 `saveNoteImage` 函数类似，除了我们将值设置为 `null`。接下来，为了添加按钮，我们再次将 `noteImage`
    属性添加到 `NavigationBarRouteMapper` 中的 `RightButton` 函数，并将 `deleteNoteImage` 函数传递给
    Navigator 组件：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Connecting the final pieces
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接最终部分
- en: 'Now that we have `CameraScreen` and `ImageScreen`, we need to be able to navigate
    to them via the `NoteScreen`. We are going to add a button that will change the
    state based on the `imagePath` of the note. If it does not exist, then we want
    the user to transition to the `CameraScreen` and the `ImageScreen` when it does.
    Visually we are going to place the button in-line with the title input:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `CameraScreen` 和 `ImageScreen`，我们需要能够通过 `NoteScreen` 导航到它们。我们将添加一个按钮，该按钮将根据笔记的
    `imagePath` 更改状态。如果它不存在，则希望用户在它存在时过渡到 `CameraScreen` 和 `ImageScreen`。在视觉上，我们将按钮放置在标题输入旁边：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that if the `showCameraButton` prop is enabled, we render a different button
    to indicate the next step to the user based on the existence of the `imagePath`.
    Each of the corresponding functions on the `SimpleButtons` will push the camera
    or `noteImage` route onto the navigator stack.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果 `showCameraButton` 属性被启用，我们将根据 `imagePath` 的存在渲染不同的按钮，以向用户指示下一步。`SimpleButtons`
    上的每个相应函数都将将相机或 `noteImage` 路由推送到导航器堆栈。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: '`blurInputs` is a function that we defined to disable the focus on the `TextInputs`
    and to hide the keyboard when transitioning to the next screen.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`blurInputs` 是我们定义的一个函数，用于在切换到下一屏幕时禁用 `TextInputs` 的焦点并隐藏键盘。'
- en: 'The styles for the button are similar to what we have had before. The main
    difference is the padding around the text:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮的样式与我们之前使用的类似。主要区别在于文本周围的填充：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can place the button in the same line as the `TextInput` since the `inputContainer`
    style we defined earlier has a `flexDirection` of row, as shown:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们之前定义的 `inputContainer` 样式具有 `flexDirection` 为 row，因此我们可以将按钮放置在与 `TextInput`
    相同的行上，如下所示：
- en: '![Connecting the final pieces](img/B05162_07_06.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![连接最终部分](img/B05162_07_06.jpg)'
- en: Summary
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned that even if React Native lacks a feature you need,
    you'll be able to find a Native Module that suits your needs. In our case, we
    need camera support for our note taking the application and we showed you how
    to install a great third-party module via `npm`. We created a new screen for our
    Camera component and wired it up to our note saving mechanism to store the path
    of the image that is captured. We then created a `NoteImage` screen to view the
    captured image and added a way to delete the images we captured.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解到即使 React Native 缺少你需要的功能，你也能找到适合你需求的 Native Module。在我们的案例中，我们需要为我们的笔记应用提供相机支持，我们展示了如何通过
    `npm` 安装一个出色的第三方模块。我们为我们的相机组件创建了一个新屏幕，并将其连接到我们的笔记保存机制以存储捕获的图像路径。然后我们创建了一个 `NoteImage`
    屏幕来查看捕获的图像，并添加了一种删除我们捕获的图像的方法。
- en: 'Facebook exposes native device functionality in exactly the same way that react-native-camera
    does. If you''re curious, you can take a look at the very simple vibration module
    that ships with React Native: [https://github.com/facebook/react-native/tree/master/Libraries/Vibration](https://github.com/facebook/react-native/tree/master/Libraries/Vibration).
    Even if you do not consider yourself an Objective-C, Swift, or Java programmer,
    don''t be afraid to try creating a Native Module yourself—you might be surprised
    by how easy it is!'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook 以与 react-native-camera 完全相同的方式公开原生设备功能。如果你好奇，可以查看随 React Native 一起提供的非常简单的振动模块：[https://github.com/facebook/react-native/tree/master/Libraries/Vibration](https://github.com/facebook/react-native/tree/master/Libraries/Vibration)。即使你不认为自己是一位
    Objective-C、Swift 或 Java 程序员，也不要害怕尝试自己创建 Native Module——你可能会惊讶于它是多么简单！
