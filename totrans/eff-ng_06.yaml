- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applying Code Conventions and Design Patterns in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore code conventions, best practices, and design
    patterns commonly used within Angular applications. You will also create a generic
    HTTP service and mock API responses using an HTTP interceptor.
  prefs: []
  type: TYPE_NORMAL
- en: Following good code conventions allows you to write code consistently. Whether
    you write your code solo or in a team, conventions ensure that you use similar
    syntax for common occurrences and follow best practices. Using good design patterns
    helps you to write code implementations that scale well and are battle-tested.
  prefs: []
  type: TYPE_NORMAL
- en: Code conventions and best practices focus more on processes and style-related
    aspects such as using the CLI, naming, using types, or preventing nested observables.
    Design patterns, on the other hand, focus on how you set up, handle, and implement
    common occurrences, problems, and flows within your code base.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know all about code conventions, best practices,
    and commonly used design patterns within Angular applications. Some patterns and
    principles you will learn about in this chapter are inheritance, facade services,
    observables, reactive programming, and anti-patterns. This chapter will provide
    a good foundation for the following chapters, where we dive deep into reactive
    programming and state management. The chapter will help you understand the benefits
    of good design patterns and code conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring commonly used code conventions and best practices in Angular applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring commonly used design patterns in Angular applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a generic HTTP service containing a model adapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring commonly used code conventions and best practices in Angular applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter’s first section, you will learn about **code conventions** and
    best practices within Angular applications. Using code conventions ensures that
    everyone working on your project uses similar naming for variables, files, and
    folders. Good code conventions also make code more readable and allow you to recognize
    certain features, implementations, or data types quickly. In addition, code conventions
    make your code consistent and easier to debug, refactor, and understand. Setting
    up good code conventions for your project promotes the usage of best practices.
    Code conventions also make it easier for new developers to be onboarded into the
    code base, as they have a set of rules they can follow that allows them to write
    code in a similar way to the rest of the people working on the code base.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I think it’s a good practice to create a document with all code
    conventions and best practices you adopt within your project. This way, new people
    have something to go off of besides what they see in the code. What code conventions
    your company adopts is entirely up to the people writing and maintaining the code
    base. However, some commonly used conventions and best practices within the Angular
    community exist.
  prefs: []
  type: TYPE_NORMAL
- en: For starters, Angular has a *style guide* in which it declares everything it
    considers a good practice and why. You can find the style guide on the official
    Angular website at [https://angular.io/guide/styleguide](https://angular.io/guide/styleguide).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we learn about common conventions and best practices for Angular applications.
    We will start with naming and structural conventions and follow this up with best
    practices.
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Naming is the main focus of conventions. **Naming conventions** are essential
    to ensuring maintainability and readability. Good naming conventions allow you
    to navigate the code base easily and find content quickly. Naming conventions
    apply to several aspects of the code, so we will divide them up, starting with
    folders and files.
  prefs: []
  type: TYPE_NORMAL
- en: Naming folders and files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: File and folder names should clearly describe the intent of the folder or file.
    This way, you can quickly locate files and folders you need even when the project
    grows. For folders, you should use single words, but if you do use multiple words,
    you can separate them with a dash (`-`). For file names, you can use the format
    of `feature.type.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: The feature describes what the file entails and the type refers to things such
    as components, services, directives, pipes, and so on (some examples include `expenses-list.component.ts`,
    `expenses.service.ts`, and `unit.directive.ts`). Use conventional names for the
    file types (`.component`, `.directive`, `.service`, `.pipe`, `.module`, `.directive`,
    `.store`, `.actions`, `.stories`). For unit tests, use `.spec` for the type. Lastly,
    it’s wise to prevent duplicate folder or file names. As your monorepo grows, avoiding
    duplicate file or folder names might not always be possible, but try to prevent
    it for as long as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Besides naming conventions for files and folders, adhering to naming conventions
    within your code is vital. It would be best to keep naming consistent for your
    classes, properties, functions, selectors, and other aspects of your code. Having
    good naming conventions within your code helps you to quickly identify different
    parts of your code, improving readability and making refactoring and maintaining
    your code easier.
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions within your code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Angular is predominantly a class-based framework, so let’s start by naming classes.
    All classes should use upper camel case. Upper camel case is when you start every
    word with an uppercase letter. The class names should equal the file feature combined
    with the file type. So, `expenses-list.component.ts` becomes `ExpensesListComponent`
    and `expenses.service.ts` becomes `ExpensesService`.
  prefs: []
  type: TYPE_NORMAL
- en: Another important part of Angular applications is the selectors of components,
    directives, and pipes. For components and directives, it’s a convention to prefix
    the selectors. Make the selector prefix unique so you can distinguish it from
    selectors from any third-party libraries you might use.
  prefs: []
  type: TYPE_NORMAL
- en: Component selectors are all lowercase and words are separated with dashes. For
    directive selectors, you use regular camel case. With regular camel case, the
    first word is in lowercase and all subsequent words start with a capital letter.
    With selectors for pipes, you should use a single word in all lowercase without
    a prefix. For pipes, use regular camel case if you have to use multiple words
    for the pipe selector.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also some common conventions when we look at the code within classes
    (or function files):'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we use camel case to declare properties, functions, and methods. Using
    descriptive names for your properties, functions, and methods is also important.
    When you handle events or component outputs with functions, you should prefixed
    these functions with `on` (`onClick`, `onAddExpense`, `onHover`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@Output() saved = new EventEmitter<boolean>();   // Good'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Output() $):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that you know about naming conventions for files and naming conventions
    for your code, let’s look at some conventions for structuring your files and projects.
  prefs: []
  type: TYPE_NORMAL
- en: Structural conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides naming conventions, you can have conventions for structuring your files
    and projects. Like good naming, having a predictable and good structure inside
    your files and projects helps with readability and maintainability. With a good
    file structure, you can easily recognize and find the parts of code that you need.
  prefs: []
  type: TYPE_NORMAL
- en: First, it’s a good convention to use the **rule of one**. Each file should serve
    a single purpose. Having a single purpose for each file makes it easier to read
    and maintain them, and it keeps the files small. A single purpose for each file
    also makes it easy to locate bugs. It would be best if you also tried to limit
    files to a maximum of 400 lines. When a file exceeds 400 lines of code, it’s a
    good indicator that you might need to split it up and move some methods to a separate
    file.
  prefs: []
  type: TYPE_NORMAL
- en: You should watch the size of your file and also the size of your functions.
    Ideally, functions should not be more than 50 lines, and it’s best to keep them
    under 25 lines. Some exceptions might exist, but splitting them into separate
    functions when they grow larger is better. When functions grow too large, they
    become hard to read, test, and debug.
  prefs: []
  type: TYPE_NORMAL
- en: In Angular, you can write the template, CSS, and logic in a single file, but
    extracting the template and CSS into their own files is recommended. Using a separate
    file for the template and CSS promotes the rule of one, where each file has a
    single purpose, and it also helps with readability and maintainability. If your
    template consists of one or two HTML tags without additional styling, you can
    make an exception and place everything in a single file. However, I would still
    separate the template and component class. Besides separating your files into
    dedicated HTML, CSS, and TypeScript files, a good folder structure also helps
    with maintaining a clear overview, so let’s look at some conventions for our folder
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: Try to maintain a flat folder structure for as long as possible. Having a lot
    of nested folders makes it easier to find the folders and files you need and can
    make your overview of the folder and file structure clearer. Create a folder or,
    better yet, a library for each domain in your project. You should split your code
    inside these libraries into `data-access`, `features`, `UI`, and `utils`. Each
    element inside your `data-access`, `features`, `UI`, and `utils` libraries should
    also be its own library.
  prefs: []
  type: TYPE_NORMAL
- en: Using libraries promotes an API-driven architecture and ensures good separation
    of concerns. By having an API-driven architecture, you also start to write more
    reusable code. Inside each library, you have an `index.ts` file to export what
    you need to consume elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Next, it’s recommended to use the **DRY principle**. DRY stands for “Don’t repeat
    yourself.” When your mono repository grows larger, sometimes you can’t help repeating
    yourself, but in general, you should try to write code only once and share it
    where you need it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, you need a way to order your code within your files. A common way to
    order your code is by using the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@``Input()` decorators'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@``Output()` decorators'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Public properties and private properties
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Constructor
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getters and setters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lifecycle hooks
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Public methods and private methods
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sort properties and methods alphabetically (after dividing them into public
    and private properties and methods). Initialize `@Input()` directives whenever
    possible, and when using lifecycle hooks, implement the interface as well.
  prefs: []
  type: TYPE_NORMAL
- en: You can extend the before-mentioned conventions to make your project more robust
    and uniform. The number of conventions you should come up with and try to use
    is unlimited, but for now, you have a good starting point and idea of what your
    conventions should look like and focus on. Next, we will discuss some best practices
    within Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: Using best practices in Angular applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using best practices ensures that you do things properly and your code stays
    robust, maintainable, and scalable.
  prefs: []
  type: TYPE_NORMAL
- en: The first best practice is to use the Angular CLI (or the Nx CLI when using
    Nx) as much as possible. Using the CLI to generate components, services, directives,
    projects, libraries, and other elements ensures consistency. When using the Nx
    CLI, you’re also assured that all dependencies and settings are configured properly.
  prefs: []
  type: TYPE_NORMAL
- en: Use the new standalone components, directives, and pipes as much as possible.
    Using the new standalone API helps better isolate your logic, making debugging
    and testing your components, pipes, and directives easier. Using the standalone
    API also helps to reduce your bundle sizes, resulting in faster load times. You
    should also use the new `inject` function over constructor injection for dependency
    injection. The `inject` function provides more flexibility and is no hindrance
    when you use inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Always use access modifiers on your properties and methods. In Angular, we
    have three access modifiers: `public`, `private`, and `protected`. Using the correct
    access modifiers makes it easy to identify what can be used where and helps to
    prevent bugs and unintended behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: Performance-related best practices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a bunch of best practices related to performance. First, always use
    the `trackBy` function on the `*ngFor` directive. When you use the new control
    flow syntax introduced in Angular 17, you are required to use the `track` function.
    Using the new control flow syntax is recommended as it improves readability, and
    you don’t need to import the common module to use them, so it will reduce your
    bundle sizes a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you should use *lazy loading* as much as possible as this ensures that
    you only download what your user requests. With the new standalone components,
    you can easily lazy load every route, and with new defer blocks introduced in
    Angular 17, you can even lazy load different parts of the HTML templates.
  prefs: []
  type: TYPE_NORMAL
- en: You should try to use the `OnPush` change detection strategy inside your components
    as much as possible. Using `OnPush` change detection reduces the number of times
    Angular renders your template. For even better change detection and performance,
    you should also utilize Angular signals as much as possible to manage the synchronous
    state in your application (we will discuss signals in detail in [*Chapter 7*](B21625_07.xhtml#_idTextAnchor129)).
  prefs: []
  type: TYPE_NORMAL
- en: For asynchronous data flows, you should use `async` pipe as much as possible.
    The `async` pipe unsubscribes automatically for you when the component is destroyed
    or the property is assigned with a new observable; this prevents memory leaks
    and improves the performance of your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t use function calls or getters in your HTML templates. Calling functions
    or using getters in the template negatively impacts the performance of your application.
    Use **CDK virtual scroll** to display large lists. The CDK virtual scroll will
    only render the elements displayed inside the view instead of the entire list.
    Use pure pipes as much as possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For example, when using the `ngOnChanges` lifecycle to assign a property based
    on the newly received input values, there is a big chance you can handle the same
    using a pipe. Using pure pipes is better for performance and promotes reusability.
    Don’t use `filter`, `forEach`, `reduce`, or `map` on arrays inside pipes, as this
    negatively affects the performance.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you should cache API requests for as long as feasible and do the same
    with resource-intensive methods.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing bugs with best practices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides performance-related best practices, there are some best practices to
    prevent bugs and improve testability and maintainability. Avoid `any` types in
    your code. Having everything strongly typed prevents bugs, improves suggestions,
    and makes debugging and testing easier.
  prefs: []
  type: TYPE_NORMAL
- en: When you have observables inside component classes that aren’t used within the
    template, use the RxJS `takeUntilDestroyed`, `takeUntil`, or `take` operators.
    These three operators ensure that your subscriptions on observables are unsubscribed
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Also, don’t use nested observables; instead, use RxJS operators such as `combineLatest`
    and `withLatestFrom` to handle scenarios where you need nested observables. Nested
    observables can quickly lead to memory leaks and bugs that are difficult to debug.
    Nested observables are also hard to write tests for.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, avoid using multiple `ng-container` elements with an `async` pipe
    when you must await multiple observables before rendering a piece of HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, map both observables into a single observable inside your component
    class and use the single observable in the template with the `async` pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Combining the observables will prevent bugs, make your template more readable,
    and ensure everything is updated correctly when an observable receives new values.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know some best practices that prevent bugs, let’s explore best
    practices regarding your setup and architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for your project setup and architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A good setup helps with better maintainability and standards throughout your
    codebase. We already discussed how to set up a project in [*Chapter 1*](B21625_01.xhtml#_idTextAnchor014),
    but to recap, use smart and dumb components.
  prefs: []
  type: TYPE_NORMAL
- en: '*Smart components* connect with your state management and *dumb components*
    only receive data through inputs and output changes to the parents. This ensures
    you don’t have unintended dependencies and your component focuses on a single
    responsibility. Use `export default` on your components as much as possible to
    auto unwrap when lazy loading. Using default exports with automated unwraps keeps
    your routing files clean and readable.'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `canMatch` route guard over the `canActivate` and `canLoad` guards.
    The `canMatch` guard will not download the code if the guard returns false. Lastly,
    you need to use lint rules to enforce your conventions and best practices.
  prefs: []
  type: TYPE_NORMAL
- en: You have learned about naming and structural conventions. You also learned about
    best practices you can use within your Angular applications. Going forward, I
    will mention other best practices as we go, but first, we will learn about common
    design patterns in Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring commonly used design patterns in Angular applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design patterns help solve common software development problems in a predefined
    approach. Design patterns are like blueprints for building your application. Design
    patterns tell you how your code should behave and how to create a structure or
    separate parts of your code base. Using design patterns ensures that you have
    battle-tested solutions for common problems with a good level of abstraction so
    your code can scale without becoming a mess, entangled with dependencies all over
    the place, which is commonly referred to as “spaghetti code.”
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstraction** in software development means you separate the details and
    behavior of your system from the implementation logic. For example, if you have
    a state management solution in your Angular application, you should separate the
    implementation of your state management from your component layer. By separating
    the component layer and state management solution, you can change your state management
    solution without touching your component layer. This provides extra flexibility
    and can save you some severe refactoring down the road as your application grows
    and its needs change.'
  prefs: []
  type: TYPE_NORMAL
- en: To stay with the state management example, in the beginning, you might manage
    your state using a simple approach with RxJS `Subject` and `BehaviorSubject`,
    but when the application grows and your state becomes more complex, you might
    want to change it for something such as **NgRx** or **NgXs** as they offer a safer,
    more robust and flexible approach for handling complex application state.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose your component layer is entangled with your state management. In that
    case, you have to refactor your entire application to switch the state management
    implementation. In contrast, if you have a good level of abstraction between the
    component layer and the state management solution, you can change the state management
    implementation without touching your components.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns are a good starting point for solving common problems in software
    development, but they are no holy grail or a one-size-fits-all solution. You should
    always consider what is useful for your application; don’t overdo it by using
    design patterns where none are needed. When it makes sense to follow design patterns
    to the letter, you can do so, but when it doesn’t, adapt the patterns to fit your
    specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: Now, without further ado, let’s explore some commonly used design patterns in
    Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: Creational design patterns in Angular
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Creational design patterns** form the foundation of how we create classes
    and objects within our applications. Within Angular applications, creational patterns
    are used by the framework for the creation of components, services, and other
    essential building blocks of the application. Developers can ensure modular, reusable,
    and maintainable code by implementing creational patterns, such as factory and
    singleton patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: Singleton pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **singleton pattern** is used to create a single instance of an object
    or class. Using the singleton pattern ensures that all code interacting with the
    singleton uses the same instance. Another advantage of the singleton pattern is
    good memory usage, as you only have to allocate memory for the object or the class
    once. In *Figure 6**.1*, you can see a visual representation of the singleton
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: Singleton pattern](img/B21625_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Singleton pattern'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 6**.1*, there is one single instance of a class used
    by different consumers. When you don’t use the singleton pattern, you have multiple
    instances of the global configuration class, where each consumer uses its own
    instance. Now that you know what the singleton pattern is, let’s explore how the
    pattern is commonly used in the context of Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Within the context of Angular, the singleton pattern is mostly used in combination
    with dependency injection. When you create a service or provide other dependencies
    in your Angular applications, it’s generally done as a singleton, meaning only
    one instance of the dependency is created and shared by all consumers throughout
    the application. Because there is only one instance, you can safely use singleton
    services and classes to manage the state within your Angular application or handle
    other logic where each consumer needs access to the same instance, such as configurations
    and caching.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide a dependency as a singleton, you must provide it within your application’s
    *root providers array*. When working on an Angular application without modules,
    the root providers array is located in the `ApplicationConfig` object you provide
    to the `bootstrapApplication` method. If you use `ngModules` in your Angular application,
    you make a dependency a singleton by providing it in the app module. You can also
    use the `providedIn` root configuration object when it comes to services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In general, you can really only create a single instance of objects utilizing
    the singleton pattern. In the case of Angular dependencies, a singleton is created
    within the context of the provider array where the dependency is provided. We
    already explained the providers array and creation of dependencies in more detail
    in [*Chapter 2*](B21625_02.xhtml#_idTextAnchor033).
  prefs: []
  type: TYPE_NORMAL
- en: 'To further clarify the singleton pattern, let’s look at some real-world examples
    of when the pattern is useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Managing the logged-in user**: If you have a class to manage the logged-in
    user, you want there to be a single instance of that class so that there is a
    single source of truth. If there are multiple copies of the class, the user data,
    login state, and other properties could vary amongst the different instances of
    the class, resulting in unintended behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State management**: When you have a class to manage the global application
    state, the singleton pattern is also a good fit. You want to ensure that everyone
    who needs the global application state receives the same value and can update
    it in the same source. If there are many instances of the state class, these instances
    can hold different values, resulting in a corrupted state. Keeping different instances
    synchronized can be a hard task, so using a single source of truth makes sense
    and uses less memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you know about the singleton pattern and when it’s used within the
    Angular application, let’s explore the factory pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Factory pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **factory pattern** serves as a versatile blueprint for object creation.
    The factory pattern is beneficial in scenarios where the exact type of object
    needed is determined at runtime, allowing for dynamic instantiation based on certain
    conditions or parameters. By encapsulating object creation, the factory pattern
    prevents tight coupling between client code and specific classes, promoting maintainability,
    scalability, and easier modifications. *Figure 6**.2* shows a visual representation
    of the factory pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: Factory pattern](img/B21625_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Factory pattern'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 6**.2*, we send the factory some information (in the
    figure, it’s a list of product details) and the factory creates what we want it
    to create and returns the result. In the figure, the factory creates and returns
    a product to the component using the factory. Now that you have a better idea
    of what the factory pattern is, let’s see how it is commonly used in the context
    of an Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the context of Angular, the factory pattern is also mainly used in combination
    with dependency injection. You can create a provider with the `useFactory` property
    and provide a factory method for creating the dependency value. Using the `useFactory`
    property in a provider can be useful when you want to provide different classes
    based on a condition or when you want to provide a value to the created class
    that is only accessible upon runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Another place where you commonly use factory methods within Angular applications
    is in services. Oftentimes, services are used to create specific objects; this
    can be done with a factory method so you have a concise way to create the objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now you know the factory pattern is used to create objects and classes in a
    predictable manner. Next, we will talk about the dependency injection pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Dependency injection** (**DI**) stands at the core of the Angular framework.
    Strictly speaking, DI falls under the umbrella of the **inversion of control**
    (**IoC**) principle. IoC essentially delegates control of certain aspects of a
    program to an external framework or container, allowing it to manage the flow
    and connections between components. But because DI is in charge of the creation
    and distribution of dependencies within your Angular application, we can place
    it under the category of creational design patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: DI promotes modularity by decoupling components and services, making them more
    reusable across the application. By facilitating the management of dependencies,
    DI makes it easier to scale applications by adding or modifying functionality
    without needing to make significant code changes.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular DI system helps identify and prevent circular dependencies, which
    can lead to runtime errors and hard-to-debug issues. Dependency injection also
    enforces type safety, reducing the risk of errors related to incorrect data types
    being injected.
  prefs: []
  type: TYPE_NORMAL
- en: We already discussed Angular DI in great detail in [*Chapter 2*](B21625_02.xhtml#_idTextAnchor033),
    so for now we will move on to structural design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Structural design patterns in Angular
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Structural design patterns** are fundamental in shaping the architecture
    of your Angular applications. Structural design patterns help organize components,
    services, and modules, defining how they interact and collaborate within your
    applications. Angular leverages these patterns to establish a clear structure,
    facilitating the development of scalable, modular, and maintainable applications.'
  prefs: []
  type: TYPE_NORMAL
- en: For instance, patterns such as component-based architecture and module structure
    are inherent in Angular applications. The decorator pattern is also heavily used
    in Angular (e.g., `@Component`, `@Injectable`). The facade pattern is often used
    in Angular applications to provide abstraction between the services and component
    layer of your Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, using structural design patterns in Angular guides developers in creating
    well-organized, scalable, and adaptable applications by defining how components,
    services, and modules interconnect and collaborate within the framework’s architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Component-based architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Component-based architecture** **(CBA)** is a design pattern where we build
    applications by composing individual, self-contained, and reusable components.
    It’s obvious where CBA comes into play within Angular applications. When building
    components, it’s important to keep them as self-contained and reusable as possible.
    Because we want to build reusable components, it’s important to use the smart/dumb
    principle within your Angular components.'
  prefs: []
  type: TYPE_NORMAL
- en: We already talked about smart and dumb components in [*Chapter 1*](B21625_01.xhtml#_idTextAnchor014)
    and [*Chapter 2*](B21625_02.xhtml#_idTextAnchor033), but to reiterate, smart components
    are mainly pages or large feature components and have a connection with your business
    logic and state management (or the facade services).
  prefs: []
  type: TYPE_NORMAL
- en: Dumb components are UI elements that are used to build up the smart components.
    Dumb components receive their data through inputs and notify other components
    of changes with outputs. Using this smart/dumb approach enforces good architecture
    and reusability of your components.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have briefly reiterated the CBA pattern, let’s move on and learn
    about the decorator pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Decorator pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **decorator pattern** is a structural design pattern that enables you to
    modify the behavior of classes, functions, and properties without altering the
    object itself. The most commonly used decorators within the Angular framework
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Component`: This decorates a class as an Angular component, providing metadata
    for Angular’s compiler. It includes information about the component’s template,
    styles, and other configurations such as the standalone flag, imports, the component
    selector, and directive decomposition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Injectable`: This decorates a class as an injectable service, allowing it
    to be injected into other components or services through Angular’s DI system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@NgModule`: This decorates a class as an Angular module, providing metadata
    that defines the module’s dependencies, components, directives, services, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Input` and `@Output`: These are decorators used in component properties to
    define inputs and outputs for communication between components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@HostListener`: This decorates a class method to declare a DOM event listener.
    It’s used within directives to listen for events on the host element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@HostBinding`: This decorates a class property to bind it to a host element
    property within a directive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ViewChild` and `@ViewChildren`: These are decorators used to query and obtain
    references to child components or DOM elements within a parent component or directive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also create your own custom decorators. We can, for example, make a
    custom decorator that will log when a function is called and include the provided
    function parameters in the log. To start, you need to set `experimentalDecorators`
    to true inside your `tsconfig.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of Angular, the `experimentalDecorators` property is set to `true`
    by default because Angular already uses decorators within the framework. To create
    a decorator, you have to create a function that takes three arguments: `target`
    (class prototype), `propertyKey` (name of the method), and `descriptor` (property
    descriptor of the method). Within the decorator, you modify the behavior of the
    decorated method by wrapping its original logic inside a new function. This new
    function logs a message before invoking the original method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to use the decorator, you simply add it above a method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now call the `test` method, the decorator makes sure it is logged, including
    the `a` and `b` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can place the custom decorator in a new `custom-decorators` library of type
    util in the shared domain. I created a `func-logger.decorator.ts` file inside
    the `custom-decorators` library and placed the logic of the decorator in that
    file.
  prefs: []
  type: TYPE_NORMAL
- en: You now know where Angular uses the decorator pattern and how you can use it
    yourself to extend or modify the behavior of objects, functions, and classes without
    modifying the objects themselves. Next, you will learn about the facade pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Facade pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We mentioned the **facade pattern** a couple of times throughout this book.
    Now it’s time to explain what the facade pattern is. The facade pattern is a structural
    design pattern that provides a simplified interface to a larger, more complex
    system of classes, subsystems, or APIs. In the context of Angular applications,
    the facade pattern is commonly used to create a simple interface for and an abstraction
    layer between the component layers and your services where you implement your
    state management solution and business logic. In *Figure 6**.3*, you’ll find a
    visual representation of the facade pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: Facade pattern](img/B21625_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Facade pattern'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 6**.3*, to get the data needed in the component, three different
    services need to be called. If you have to do this for all your components, you
    create a lot of dependencies and you need to create a lot of logic inside your
    components. Instead of directly calling the services from the components, we place
    a facade in between the components and services. The facade provides a simple
    `get data` method to retrieve the data we need inside the components. Instead
    of having dependencies inside the components, the facade has all the dependencies
    to the services. By using the façade, you can keep your components simple and
    clean without dependencies. Furthermore, you create a level of abstraction, and
    because of that, you can change the how you retrieve the data without changing
    the component layer; you simply change how the facade gets the data and the component
    still calls the `get data` method from the facade service. In most cases, you
    have your state management on the right side of the facade and your components
    on the left side of the facade.
  prefs: []
  type: TYPE_NORMAL
- en: In large applications and monorepos, the state management layer can become large
    and complex to handle. For something as simple as getting all expenses in a large
    monorepo of business tool applications, you can find yourself accessing multiple
    state files (commonly named stores) and selectors of these stores. Because the
    pieces of the state can live in different files or even different libraries, it’s
    not as easy as creating a function that combines the parts inside the state itself.
    You need another place, and that would be the facade service. The same goes for
    updating; in large systems, this can involve updating multiple stores and handling
    multiple callbacks or effects.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say you create an expenses facade. In this facade, you create methods
    that are simple to call and give you access to everything you need in your component
    layer. Think of things such as getting all expenses, getting filtered expenses,
    updating a single expense, or updating expenses in bulk. The facade helps keep
    things simple in your component layers and ensures that you only have to call
    a single function to get or do what you need to make your components work and
    update your state accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The facade makes accessing and updating your state easy and provides an extra
    level of abstraction, decoupling your state management implementation from your
    component layer. This abstraction layer allows you to change your state management
    solution without touching your component layer. You only have to change your state
    management and update the facade and your component layer will keep working as
    if nothing changes.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not have the facade in between, you need to go into every component
    where you use the state and update them all independently, resulting in more work
    and a higher chance of you missing something. So, even if you have a simple state
    where you can access and update most things with a single method, adding a facade
    between your component layer and state management is still wise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple example of how a facade service might look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we made a façade service that exposes two methods:
    one to get all expenses and one to update expenses. If the implementation in the
    state management now changes, you only have to change it in the facade instead
    of everywhere you get or update the expenses in your components. The preceding
    code is just an example; you don’t have to add this in the monorepo. In [*Chapter
    8*](B21625_08.xhtml#_idTextAnchor150), we will create a facade in our monorepo.
    For now, you just need to know what the facade pattern is and why it’s useful.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will take a look at the inheritance pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Model adapter pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **model adapter pattern** is an implementation of the adapter pattern. The
    model adapter pattern is commonly used to map objects received from the API to
    a representation of those models used within the frontend (not specifically into
    models used within the view layer). You might ask yourself, why is this useful?
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you receive an object from the API with a `title` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let’s say you use this `title` property in 100 different places throughout your
    application. If, for some reason, the backend has to change the property name
    from `title` to `subject`, you need to go to all 100 places within your application
    to change them from `title` to `subject`. If you have a model adapter, you can
    change them in one place and map the new `subject` property to the `title` property
    of your frontend model.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **inheritance pattern**, a foundational concept in object-oriented programming,
    establishes a hierarchical relationship between classes, enabling one class (the
    subclass or derived class) to inherit properties, methods, and behaviors from
    another class (the superclass or base class). In Angular applications, services
    and components can utilize inheritance to form hierarchical relationships and
    share generic functionalities and properties. The base class exposes the shared
    functionalities and properties with the child class.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance is a powerful and useful design pattern, but it should be used in
    moderation, especially within the component layer of your Angular applications.
    Excessive use of inheritance can create tight coupling between the base and child
    components. Changes in the base component might inadvertently impact multiple
    derived components, making the system fragile and harder to maintain. Deep hierarchies
    with multiple levels of inheritance can introduce complexity, making the codebase
    harder to understand and maintain. Over-engineering by creating overly complex
    inheritance structures might hinder rather than aid development.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in the context of the component layer, you can often create pipes and
    directives to share common functionalities. For example, you can have a base class
    where you add common logic for handling disabled states, handling some commonly
    used component stylings such as `primary`, `alert`, and `danger`, and adding the
    option to change this styling when clicked or double-clicked.
  prefs: []
  type: TYPE_NORMAL
- en: This might seem like a valid solution, but you might only need one or two of
    the options in some scenarios. Some components might have different styling types
    but should not be able to change the styling type based on a click, and others
    should not be able to be disabled. It’s generally a bad practice to expose behavior
    to a component that does not apply to the component. So, in this scenario, it
    would be better to create three directives that handle disabling, styling, and
    styling change behaviors and apply them using directive composition.
  prefs: []
  type: TYPE_NORMAL
- en: So, inheritance can be used to share common functionalities, but make sure it
    is the right solution for the problem so that you don’t create base classes that
    expose a lot of functionalities and behaviors that most child classes will not
    use. One way I like to use the inheritance pattern is for creating a generic HTTP
    service. We will create a generic HTTP service with a model adapter in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned about the most used structural design patterns within
    Angular applications, we will start learning about common behavioral design patterns
    within Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral design patterns in Angular
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Behavioral design patterns** focus on how objects and classes communicate
    and delegate responsibilities to each other. Using behavioral patterns ensures
    that your code remains flexible, modular, and maintainable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common behavioral pattern within Angular applications is the observer
    pattern, but others, such as the interceptor, redux, and strategy patterns, are
    also commonly used. Let’s start with the most commonly used: the observer pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: Observer pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have ever used Angular, you know the framework heavily relies on **observables**.
    The Angular framework integrated RxJS to manage observables and handle asynchronous
    data streams effectively and in a reactive manner. RxJS is a library focused on
    handling observable data streams. The **observer pattern** allows you to create
    one-to-many relationships so that when one object changes, all the dependent elements
    within your code are notified and updated automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Within the observer pattern, you have the **observable** and the **observers**,
    which are more commonly referred to as the subscribers. I like to explain the
    Observer pattern with a magazine subscription analogy.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say there is a magazine that releases a new issue weekly. The magazine
    is the observable and the people subscribing to the magazine are the observers
    or subscribers. Each time the magazine releases a new issue, all subscribers are
    notified and receive the new issue automatically in their mailboxes. The subscribers
    to the magazine will receive the magazine for as long as they are subscribed,
    and when they unsubscribe, they will no longer receive the magazine.
  prefs: []
  type: TYPE_NORMAL
- en: The magazine can be subscribed to by all people who want to receive it. There
    is one magazine issue and many readers of the issue, hence the one-to-many relationship,
    as we have in the observer pattern. There are also observers and an observable,
    just as with the observer pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Observables come in two types, hot and cold observables, and within the context
    of Angular applications and RxJS, there are a couple of ways you can set up observables;
    we will dive deeper into observable types, RxJS, and handling observable streams
    in [*Chapter 7*](B21625_07.xhtml#_idTextAnchor129).
  prefs: []
  type: TYPE_NORMAL
- en: Interceptor pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **interceptor pattern** allows you to intercept communications and perform
    some logic on the data that is being transferred and either stop or continue the
    intercepted communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the context of Angular applications, you commonly see the interceptor
    pattern in two different places:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Route guards** intercept route changes and either allow or block the route
    change based on some logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP interceptors** intercept HTTP requests and responses. The HTTP interceptor
    is commonly used to add authorization headers to HTTP requests and handle retry
    logic or logging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will create a route guard in [*Chapter 9*](B21625_09.xhtml#_idTextAnchor170).
    For now, we will only create an HTTP interceptor.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an HTTP interceptor can be done through a class-based or functional
    approach. We will use the functional approach, as this is the newer method and
    requires less boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an HTTP interceptor, you first need to make some adjustments to your
    `ApplicationConfig` object. Start by adding the `provideHttpClient` function inside
    your `providers` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'provideHttpClient(withInterceptors function, you will register your HTTP interceptors.
    You create an interceptor by creating a function that implements the HttpInterceptorFn
    interface. The function takes an HttpRequest and an HttpHandlerFn as function
    parameters. The HttpRequest gives you access to the request and the HttpHandlerFn
    is called to continue the request after you perform your logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is just a simple example; we add a string as our authorization
    token. In reality, you should store your token in a safe place, such as in your
    environment variables, and retrieve it from there. You can also add more logic
    to the interceptor; this is just a simple example to illustrate how you create
    an interceptor. To activate the interceptor, you need to add it to the array of
    the `withInterceptors` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: export interface ModelAdapter<T, S> {
  prefs: []
  type: TYPE_NORMAL
- en: 'fromDto(dto: T): S;'
  prefs: []
  type: TYPE_NORMAL
- en: 'toDto(model: S): T;'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '@Injectable({'
  prefs: []
  type: TYPE_NORMAL
- en: 'providedIn: ''root'''
  prefs: []
  type: TYPE_NORMAL
- en: '})'
  prefs: []
  type: TYPE_NORMAL
- en: export abstract class GenericHttpService<T, S> {
  prefs: []
  type: TYPE_NORMAL
- en: protected url;
  prefs: []
  type: TYPE_NORMAL
- en: defaultHeaders = new HttpHeaders();
  prefs: []
  type: TYPE_NORMAL
- en: protected readonly httpClient = inject(HttpClient);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: constructor(
  prefs: []
  type: TYPE_NORMAL
- en: 'private endpoint: string,'
  prefs: []
  type: TYPE_NORMAL
- en: 'private baseUrl: string,'
  prefs: []
  type: TYPE_NORMAL
- en: 'private adapter: ModelAdapter<T, S>'
  prefs: []
  type: TYPE_NORMAL
- en: ) {
  prefs: []
  type: TYPE_NORMAL
- en: this.url = this.baseUrl + '/api' + this.endpoint;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'public get(extraHttpRequestParams?: Partial<HttpHeaders>): Observable<S[]>
    {'
  prefs: []
  type: TYPE_NORMAL
- en: return this.httpClient.get<T[]>(`${this.url}`, this.prepareRequestOptions(extraHttpRequestParams)).pipe(
  prefs: []
  type: TYPE_NORMAL
- en: 'map((data: T[]) => data.map(item => this.adapter.fromDto(item) as S)));'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'public post(body: S, extraHttpRequestParams?: Partial<HttpHeaders>): Observable<S>
    {'
  prefs: []
  type: TYPE_NORMAL
- en: return this.httpClient.post(`${this.url}`, this.adapter.toDto(body), this.prepareRequestOptions(extraHttpRequestParams)).pipe(map(data
    => this.adapter.fromDto(data as T) as S)) as Observable<S>;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: public prepareRequestOptions(extraHttpRequestParams = {}) {
  prefs: []
  type: TYPE_NORMAL
- en: return {
  prefs: []
  type: TYPE_NORMAL
- en: 'headers: Object.assign(this.defaultHeaders, extraHttpRequestParams)'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '@Injectable({ providedIn: ''root'' })'
  prefs: []
  type: TYPE_NORMAL
- en: 'export class models inside the lib folder of the finance data-access library
    and added a expenses.interfaces.ts file in the models folder. In this expenses.interfaces.ts
    file, I will create the expense model and DTO interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you can create a new folder named `adapters`. The `adapters` folder is
    located in the same place as the `models` and `HTTP` folders. Inside the `adapters`
    folder, create an `expense.adapter.ts` file, which will contain the model adapter
    for the expense DTO and model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the model adapter maps the expense DTO to the expense model
    and the expense model to the expense DTO. We will provide this model adapter to
    the constructor of the generic HTTP service so that our models will automatically
    be mapped when we receive them from or send them to the API. The last step is
    to inherit the generic HTTP service in your expenses HTTP service. You inherit
    by using the `extends` keyword and adding the class name of the generic HTTP service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we also call a `super()` method and provide it with some arguments.
    The `super()` method is used to call the `constructor` method of the inherited
    class – in our case, `GenericHttpService`. You provide the `super()` method with
    the properties that the constructor of the `GenericHttpService` expects to receive,
    the `endpoint`, `baseUrl`, and model adapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might also notice we use the `arrow` syntax after the `GenericHttpService`
    and provide the `ExpenseDto` and `ExpenseModel` inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the before-mentioned syntax provides the generic HTTP service with the
    generic types we added in the `GenericHttpService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: By using generic types, we make sure the generic HTTP service remains type-safe,
    and we receive typed objects when we use the methods of our HTTP services. After
    inheriting the generic HTTP service inside the expenses HTTP service, you are
    ready to use the expenses HTTP service. All the methods, such as `get`, `get by
    id`, `post`, `delete`, and so forth, are inherited by the generic HTTP service
    and don’t have to be implemented again.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use the expenses HTTP service, you `inject` it as you would
    with any other HTTP service or dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'After injecting the HTTP service, you can call any method the service exposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When we make the `get` request, you might notice the request is failing; this
    is because we don’t have an actual API running and the request to `/api/expenses`
    returns a `404 not found` error code. Let’s resolve this issue and provide some
    mock data when we make our API requests.
  prefs: []
  type: TYPE_NORMAL
- en: Providing mock data for our API requests
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to provide mock data; we will use an HTTP interceptor to
    get our mock data from the assets folder. This is just a simple implementation,
    and it has some flaws, but for demonstration purposes, it works very well, and
    it doesn’t take much effort to set up.
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating an interceptors folder with a `mock.interceptor.ts` file
    inside the `generic-http` library in our Nx monorepo. Inside the `mock.interceptor.ts`
    file, we will create an interceptor that returns the HTTP request untouched if
    we are not in development mode.
  prefs: []
  type: TYPE_NORMAL
- en: If we are in development mode, the interceptor will adjust the request URL and
    request method so that all requests are `GET` requests, and it will try to get
    a JSON file to place in the `assets` folder of our applications (in our case,
    the *expenses-registration application*).
  prefs: []
  type: TYPE_NORMAL
- en: We will also intercept the HTTP response, and if we do not make a `GET` request,
    we will return the request body instead of the data from our JSON file in the
    assets folder of the project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we first check that we are not in development mode, and if that
    is the case, we directly return the request. If we are in development mode, we
    clone the request and adjust the request URL and method. The method is set to
    a `GET`, regardless of what request we try to make. The URL is prefixed with `assets`,
    so we target the `assets` folder of our application and postfix it with `.json`
    because we will fetch a JSON file from the `assets` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the URL in this manner makes sure that a request to the following
    API URL `/api/expenses` will be transformed to `/assets/api/expenses.json`. Next,
    we use the RxJS pipe and map operator to listen for the HTTP response and simply
    return the request body if the original request method wasn’t a `GET` request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you have to create an `api` folder inside the assets folder of the *expenses-registration
    application*, and in this `api` folder, you need to create an `expenses.json`
    file with your mock data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, you need to register the interceptor in your `ApplicationConfig` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
