<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer031">
<h1 class="ch pter-number" id="_idParaDest-101"><a id="_idTextAnchor173"/>7</h1>
<h1 id="_idParaDest-102"><a id="_idTextAnchor174"/>Server-Side Rendering with Next.js or Remix</h1>
<p>Not all of our applications are rendered on the client side. Using frameworks that leverage <strong class="bold">server-side rendering</strong> (<strong class="bold">SSR</strong>) is common nowadays. These frameworks have helped improve <a id="_idIndexMarker358"/>application performance, and their adoption is <span class="No-Break">growing daily.</span></p>
<p>Now, when using these frameworks, most of the time, we tend to perform data fetching or mutations on the server side, which leads to <span class="No-Break">the question:</span></p>
<p>Do I still need React Query with an <span class="No-Break">SSR framework?</span></p>
<p>In this chapter, you’ll <a id="_idIndexMarker359"/>understand how React Query fits with frameworks such as <strong class="bold">Next.js</strong> and <strong class="bold">Remix</strong> and helps <a id="_idIndexMarker360"/>improve your user experience. You will also learn about the two patterns you can apply to React Query with these frameworks: <strong class="source-inline">initialData</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">hydrate</strong></span><span class="No-Break">.</span></p>
<p>Once you are familiar with these patterns, you will see how to apply them to your Next.js and <span class="No-Break">Remix applications.</span></p>
<p>In this chapter, we’ll cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Why should I use React Query with server-side <span class="No-Break">rendering frameworks?</span></li>
<li>Using the <span class="No-Break"><strong class="source-inline">initialData</strong></span><span class="No-Break"> pattern</span></li>
<li>Using the <span class="No-Break"><strong class="source-inline">hydrate</strong></span><span class="No-Break"> pattern</span></li>
</ul>
<h1 id="_idParaDest-103"><a id="_idTextAnchor175"/>Technical requirements</h1>
<p>All the code examples for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_7"><span class="No-Break">https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_7</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor176"/>Why should I use React Query with server-side rendering frameworks?</h1>
<p>SSR has proven <a id="_idIndexMarker361"/>to be a good ally to web <a id="_idIndexMarker362"/>developers. With an increase in the popularity of full-stack frameworks such as Next.js and, most recently, Remix, the React ecosystem has changed, leading to new patterns <span class="No-Break">being applied.</span></p>
<p class="c llout-he ding">What is server-side rendering (SSR)?</p>
<p class="c llout">SSR is a process that <a id="_idIndexMarker363"/>allows you to render your application on the server instead of the browser. During this process, the server sends the rendered page to the client. The client then makes the page fully interactive through a process <span class="No-Break">called hydration.</span></p>
<p>Owing to the possibility of using SSR, one of the things that might make sense to do is fetch your data on the server. This has many advantages, but one of the best is giving your users their pages <a id="_idIndexMarker364"/>with the initial data already loaded. Now, just because you are loading data on the server side doesn’t invalidate the scenarios in which you might need to fetch your data on the client side. If your page contains frequently updated data on the client side, React Query continues to be your <span class="No-Break">best friend.</span></p>
<p>But how does React Query fit within our code using frameworks such as Next.js or Remix? Will we fetch data on the server and then on the <span class="No-Break">client again?</span></p>
<p>The short answer is no. If we did that, we would just be wasting memory on the server and not leveraging the advantages of SSR. What we can do instead is prefetch our data on the server side and feed it to React Query so that it can manage it on the client side. That way, when the user gets the page, the page will already have the data the user needs, and from that point on, React Query takes care <span class="No-Break">of everything.</span></p>
<p>We can apply two patterns to prefetch data on the server and send it to React Query on the client side. They are <span class="No-Break">as follows:</span></p>
<ul>
<li>The <span class="No-Break"><strong class="source-inline">initialData</strong></span><span class="No-Break"> pattern</span></li>
<li>The <span class="No-Break"><strong class="source-inline">hydrate</strong></span><span class="No-Break"> pattern</span></li>
</ul>
<p>In the next section, we will learn how to leverage the <strong class="source-inline">initialData</strong> pattern and apply it to the frameworks mentioned: Next.js <span class="No-Break">and Remix.</span></p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor177"/>Using the initialData pattern</h1>
<p>The <strong class="source-inline">initialData</strong> pattern is an <a id="_idIndexMarker365"/>option you can set in your <strong class="source-inline">useQuery</strong> hook. With this option, you can feed <strong class="source-inline">useQuery</strong> with the data that it will use to initialize a <span class="No-Break">specific query.</span></p>
<p>This is the process of how to leverage the best of your server-side framework and React Query with the <span class="No-Break"><strong class="source-inline">initialData</strong></span><span class="No-Break"> option:</span></p>
<ol>
<li>The first thing you do is prefetch your data on the server side and send it to <span class="No-Break">your component.</span></li>
<li>Inside your component, you render your query using the <span class="No-Break"><strong class="source-inline">useQuery</strong></span><span class="No-Break"> hook.</span></li>
<li>Inside this hook, you add the <strong class="source-inline">initialData</strong> option and pass the data you prefetched on the server <span class="No-Break">to it.</span></li>
</ol>
<p>Let’s now see how to use this pattern <span class="No-Break">in Next.js.</span></p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor178"/>Applying the initialData pattern in Next.js</h2>
<p>In the following <a id="_idIndexMarker366"/>snippet, we will fetch some data on <a id="_idIndexMarker367"/>the server using Next.js <strong class="source-inline">getServerSideProps</strong> and then leverage the <strong class="source-inline">initialData</strong> pattern to feed the data to <span class="No-Break">React Query:</span></p>
<pre class="source-code">
import axios from "axios";
import { useQuery } from "@tanstack/react-query";
const fetchData = async ({ queryKey }) =&gt; {
  const { username } = queryKey[0];
  const { data } = await axios.get(
    `https://danieljcafonso.builtwithdark.com/
      react-query-api/${username}`
  );
  return data;
};
export async function getServerSideProps() {
  const user = await fetchData({ queryKey: [{ username:
    "danieljcafonso" }] });
  return { props: { user } };
}
export default function InitialData (props) {
  const { data } = useQuery({
    queryKey: [{ queryIdentifier: "api", username:
      "danieljcafonso" }],
    queryFn: fetchData,
    initialData: props.user,
  });
  return &lt;div&gt;This page is server side generated
    {data.hello}&lt;/div&gt;;
}</pre>
<p>In the preceding <a id="_idIndexMarker368"/>snippet, we apply the <strong class="source-inline">initialData</strong> pattern to <a id="_idIndexMarker369"/>a Next.js application. Here, we have a component that will be server-side-generated. This is what we <span class="No-Break">are doing:</span></p>
<ol>
<li>We do the necessary imports for this component. In this scenario, it’s <strong class="source-inline">axios</strong> and our <span class="No-Break"><strong class="source-inline">useQuery</strong></span><span class="No-Break"> hook.</span></li>
<li>We create our query function. In this function, we get access to our query key and destructure our username from the query key to perform our <strong class="source-inline">GET</strong> request. We then return our <span class="No-Break">query data.</span></li>
<li>Since we want this page to be server-side-rendered, we include the <strong class="source-inline">getServerSideProps</strong> function in it. This function will run on the server side, and in it, we call our <strong class="source-inline">fetchData</strong> function to get our server state data and return it as props, which will be sent to our <span class="No-Break"><strong class="source-inline">InitialData</strong></span><span class="No-Break"> component.</span></li>
<li>In our <strong class="source-inline">InitialData</strong> component, we get access to our <strong class="source-inline">props</strong>. In these <strong class="source-inline">props</strong>, we can access <a id="_idIndexMarker370"/>the data returned from <a id="_idIndexMarker371"/>our <strong class="source-inline">getServerSideProps</strong> function. We then pass this data to our created <strong class="source-inline">useQuery</strong> instance as the <strong class="source-inline">initialData</strong> option. This means this hook will have the data we fetched at build time as its initial data before <span class="No-Break">refetching it.</span></li>
</ol>
<p>Now that you know how to apply this pattern in Next.js, let us do it <span class="No-Break">in Remix.</span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor179"/>Applying the initialData pattern in Remix</h2>
<p>In the following <a id="_idIndexMarker372"/>snippet, we will fetch some data on the <a id="_idIndexMarker373"/>server using the Remix <strong class="source-inline">loader</strong> and then leverage the <strong class="source-inline">initialData</strong> pattern to feed the data to <span class="No-Break">React Query:</span></p>
<pre class="source-code">
import axios from "axios";
import { useQuery } from "@tanstack/react-query";
import { useLoaderData } from "@remix-run/react";
import { json } from "@remix-run/node";
const fetchData = async ({ queryKey }) =&gt; {
  const { username } = queryKey[0];
  const { data } = await axios.get(
    `https://danieljcafonso.builtwithdark.com/
      react-query-api/${username}`
  );
  return data;
};
export async function loader() {
  const user = await fetchData({ queryKey: [{ username:
    "danieljcafonso" }] });
  return json({ user });
}
export default function InitialData() {
  const { user } = useLoaderData();
  const { data } = useQuery({
    queryKey: [{ queryIdentifier: "api", username:
      "danieljcafonso" }],
    queryFn: fetchData,
    initialData: user,
  });
  return &lt;div&gt;This page is server side rendered
    {data.hello}&lt;/div&gt;;
}</pre>
<p>In the preceding snippet, we apply the <strong class="source-inline">initialData</strong> pattern to a Remix application. This is what we are <span class="No-Break">doing here:</span></p>
<ol>
<li>We do the necessary imports for this component. In this scenario, it’s <strong class="source-inline">axios</strong>, our <strong class="source-inline">useQuery</strong> hook, Remix’s <strong class="source-inline">useLoaderData</strong> hook, and a <span class="No-Break"><strong class="source-inline">json</strong></span><span class="No-Break"> function.</span></li>
<li>We create our <a id="_idIndexMarker374"/>query function. In this function, we get <a id="_idIndexMarker375"/>access to our query key and destructure our username from the query key to perform our <strong class="source-inline">GET</strong> request. We then return our <span class="No-Break">query data.</span></li>
<li>We then create our <strong class="source-inline">loader</strong> function. This is the function Remix uses to allow you to load the data on the server side that will be needed in your components. Inside it, we fetch our data and then use the <strong class="source-inline">json</strong> function to send an <strong class="source-inline">HTTP</strong> response with <strong class="source-inline">application/json content-type</strong> as the header and our data included <span class="No-Break">in it.</span></li>
<li>In our <strong class="source-inline">InitialData</strong> component, we leverage <strong class="source-inline">useLoaderData</strong> to get access to the data returned by <strong class="source-inline">loader</strong>. We then pass this data to our created <strong class="source-inline">useQuery</strong> instance as the <strong class="source-inline">initialData</strong> option. This means this hook will have the data we fetched at build time as its initial data before <span class="No-Break">refetching it.</span></li>
</ol>
<p>By now, you should be able to use the <strong class="source-inline">initialData</strong> pattern. There are a couple of things you need to be aware of to use it <span class="No-Break">more effectively:</span></p>
<ul>
<li>If you have multiple instances of the same query in different places, you must always pass <strong class="source-inline">initialData</strong> to them. This means that even if you leverage your query at the top level and on a child component, you will have to prop-drill your <strong class="source-inline">initialData</strong> until it reaches the desired component that needs <span class="No-Break">the data.</span></li>
<li>Since you fetch the data on the server and pass it to your hook, React Query will base the information it needs to identify when your query was rendered on the initial page load instead of the time at which it was fetched on <span class="No-Break">the server.</span></li>
</ul>
<p>Let us now see the second pattern you can leverage when using React Query with server-side-rendered frameworks: the <span class="No-Break"><strong class="source-inline">hydrate</strong></span><span class="No-Break"> pattern.</span></p>
<h1 id="_idParaDest-108"><a id="_idTextAnchor180"/>Using the hydrate pattern</h1>
<p>With the <strong class="source-inline">hydrate</strong> pattern, you can dehydrate your <strong class="source-inline">QueryClient</strong> with a previously prefetched query <a id="_idIndexMarker376"/>and send it to your client. On the client side, as soon as the page loads and JavaScript is available, React Query will hydrate your <strong class="source-inline">QueryClient</strong> with the existing data. After this process, React Query will also ensure your queries are up <span class="No-Break">to date.</span></p>
<p>This is the process of how to leverage the best of your server-side framework and React Query with the <span class="No-Break"><strong class="source-inline">hydrate</strong></span><span class="No-Break"> pattern:</span></p>
<ol>
<li>The first thing you do is create a <span class="No-Break"><strong class="source-inline">QueryClient</strong></span><span class="No-Break"> instance.</span></li>
<li>Using the previously created <strong class="source-inline">QueryClient</strong> instance, you leverage its <strong class="source-inline">prefetchQuery</strong> method to prefetch the data for that given <span class="No-Break">query key.</span></li>
<li>You dehydrate your <strong class="source-inline">QueryClient</strong> and send it to the <span class="No-Break">client side.</span></li>
<li>Your client receives the dehydrated state, hydrates it, and merges it with the <strong class="source-inline">QueryClient</strong> <span class="No-Break">in use.</span></li>
<li>Inside your component, you render your query using the <strong class="source-inline">useQuery</strong> hook with the same query key you added in <em class="it lic">step 2</em>. Your query will already have <span class="No-Break">its data.</span></li>
</ol>
<p>In the next section, we will learn how to leverage the <strong class="source-inline">hydrate</strong> pattern and apply it to the frameworks mentioned: Next.js <span class="No-Break">and Remix.</span></p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor181"/>Applying the hydrate pattern in Next.js</h2>
<p>Next.js <a id="_idIndexMarker377"/>uses the <strong class="source-inline">_app</strong> component to initialize all <a id="_idIndexMarker378"/>your pages and allows you to keep some shared state or persist layouts between page changes. Due to this, we can leverage it to wrap all our components with <strong class="source-inline">Hydrate</strong>. The <strong class="source-inline">Hydrate</strong> wrapper is responsible for receiving <strong class="source-inline">dehydratedState</strong> and <span class="No-Break">hydrating it.</span></p>
<p>Let us now see how to apply <span class="No-Break">this wrapper:</span></p>
<pre class="source-code">
import { useState } from "react";
import {
  Hydrate,
  QueryClient,
  QueryClientProvider,
} from "@tanstack/react-query";
export default function App({ Component, pageProps }) {
  const [queryClient] = useState(() =&gt; new QueryClient());
  return (
    &lt;QueryClientProvider client={queryClient}&gt;
      &lt;Hydrate state={pageProps.dehydratedState}&gt;
        &lt;Component {...pageProps} /&gt;{" "}
      &lt;/Hydrate&gt;
    &lt;/QueryClientProvider&gt;
  );
}</pre>
<p>In the preceding snippet, we do <span class="No-Break">the following:</span></p>
<ol>
<li>We do all the <a id="_idIndexMarker379"/>necessary imports to set up our <a id="_idIndexMarker380"/>components. In this scenario, we get the <strong class="source-inline">useState</strong> function from React and <strong class="source-inline">Hydrate</strong>, <strong class="source-inline">QueryClient</strong>, and <strong class="source-inline">QueryClientProvider</strong> from <span class="No-Break">React Query.</span></li>
<li>Inside our <strong class="source-inline">App</strong> component, we do <span class="No-Break">the following:</span><ol><li>We start by creating a new <strong class="source-inline">QueryClient</strong> instance and assigning it as a <strong class="source-inline">state</strong> variable by using the <strong class="source-inline">useState</strong> hook. This is because we need to make sure this data is not shared by different users of our application and requests. This will also make sure we only create <span class="No-Break"><strong class="source-inline">QueryClient</strong></span><span class="No-Break"> once.</span></li><li>We then pass our <strong class="source-inline">queryClient</strong> to <strong class="source-inline">QueryClientProvider</strong> to initiate it and allow it to be accessed by our React Query hooks. <strong class="source-inline">QueryClientProvider</strong> will also wrap <span class="No-Break">our </span><span class="No-Break"><strong class="source-inline">Component</strong></span><span class="No-Break">.</span></li><li>Finally, we <a id="_idIndexMarker381"/>also wrap our <strong class="source-inline">Component</strong> with <strong class="source-inline">Hydrate</strong>. Since <strong class="source-inline">Hydrate</strong> needs to receive <strong class="source-inline">dehydratedState</strong> whenever it exists, we get <strong class="source-inline">pageProps</strong> from our <strong class="source-inline">App</strong> and pass <a id="_idIndexMarker382"/>it to our <strong class="source-inline">Hydrate</strong> state property. This means that for every component that receives <strong class="source-inline">dehydratedState</strong> as <strong class="source-inline">props</strong>, these <strong class="source-inline">props</strong> will be passed to our <span class="No-Break"><strong class="source-inline">Hydrate</strong></span><span class="No-Break"> wrapper.</span></li></ol></li>
</ol>
<p>Now, we are all set to start dehydrating data. Let us see how we can <span class="No-Break">do it:</span></p>
<pre class="source-code">
import axios from "axios";
import { dehydrate, QueryClient, useQuery } from
  "@tanstack/react-query";
const fetchData = async ({ queryKey }) =&gt; {
  const { username } = queryKey[0];
  const { data } = await axios.get(
    `https://danieljcafonso.builtwithdark.com/
      react-query-api/${username}`
  );
  return data;
};
export async function getServerSideProps() {
  const queryClient = new QueryClient();
  await queryClient.prefetchQuery(
    [{ queryIdentifier: "api", username: "danieljcafonso" }],
    fetchData
  );
  return { props: { dehydratedState: dehydrate(queryClient) } };
}
export default function SSR() {
  const { data } = useQuery({
    queryKey: [{ queryIdentifier: "api", username:
      "danieljcafonso" }],
    queryFn: fetchData,
  });
  return &lt;div&gt;This page is server-side-rendered
    {data.hello}&lt;/div&gt;;
}</pre>
<p>In the preceding <a id="_idIndexMarker383"/>snippet, we prefetch some data, which will be <a id="_idIndexMarker384"/>dehydrated and then hydrated by React Query. Here is what we <span class="No-Break">are doing:</span></p>
<ol>
<li>We do the necessary imports for this component. In this scenario, it’s <strong class="source-inline">axios</strong>, and from the React Query side, the <strong class="source-inline">dehydrate</strong> function, <strong class="source-inline">QueryClient</strong>, and the <span class="No-Break"><strong class="source-inline">useQuery</strong></span><span class="No-Break"> hook.</span></li>
<li>We create our query function. In this function, we get access to our query key, and destructure our username from the query key to perform our <strong class="source-inline">GET</strong> request. We then return our <span class="No-Break">query data.</span></li>
<li>In <strong class="source-inline">getServerSideProps</strong>, we do <span class="No-Break">the following:</span><ol><li>We create a new <span class="No-Break"><strong class="source-inline">QueryClient</strong></span><span class="No-Break"> instance.</span></li><li>We then <a id="_idIndexMarker385"/>leverage the previously created instance <a id="_idIndexMarker386"/>to prefetch a query that will be cached under the <strong class="source-inline">[{ queryIdentifier: "api", username: "danieljcafonso" }]</strong> query key and use <strong class="source-inline">fetchData</strong> as the <span class="No-Break">query function.</span></li><li>We use <strong class="source-inline">dehydrate</strong> on <strong class="source-inline">queryClient</strong> and return it as <strong class="source-inline">props</strong> so it can be picked up in our <span class="No-Break"><strong class="source-inline">App</strong></span><span class="No-Break"> component.</span></li></ol></li>
<li>In our <strong class="source-inline">SSR</strong> component, we create a <strong class="source-inline">useQuery</strong> hook with <strong class="source-inline">[{ queryIdentifier: "api", username: "danieljcafonso" }]</strong> as the query key and <strong class="source-inline">fetchData</strong> as the <span class="No-Break">query function.</span></li>
</ol>
<p>Given that we returned <strong class="source-inline">dehydratedState</strong> from our <strong class="source-inline">getServerSideProps</strong> function, this will be passed as <strong class="source-inline">pageProps</strong> and picked up by the <strong class="source-inline">Hydrate</strong> wrapper wrapping our component. This means that React Query will pick up our dehydrated state, hydrate it, and merge this new data with the current data in <strong class="source-inline">QueryClient</strong>. This means that when the hook inside <strong class="source-inline">SSR</strong> first runs, it will already have the data prefetched <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">getServerSidePros</strong></span><span class="No-Break">.</span></p>
<p>Now that you know how to apply this pattern to Next.js, let us do it <span class="No-Break">in Remix.</span></p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor182"/>Applying the hydrate pattern in Remix</h2>
<p>Remix uses <a id="_idIndexMarker387"/>the <strong class="source-inline">root</strong> component to define the root layout of all <a id="_idIndexMarker388"/>your pages and to allow you to keep some shared state between page changes. The way this is done is by using the <strong class="source-inline">Outlet</strong> component. Due to this component and <strong class="source-inline">Outlet</strong> at the root level, we can leverage it to wrap all our components <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">Hydrate</strong></span><span class="No-Break">.</span></p>
<p>Now, unlike Next.js, there is no way to access <strong class="source-inline">pageProps</strong> to access <strong class="source-inline">dehydratedState</strong> at the root level. Therefore, we need to install a third-party package <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">use-dehydrated-state</strong></span><span class="No-Break">.</span></p>
<p>Here is how to add <strong class="source-inline">use-dehydrated-state</strong> to <span class="No-Break">your project:</span></p>
<ul>
<li>If you are running npm in your project, run the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">npm i use-dehydrated-state</strong></pre></li>
<li>If you are using Yarn, run the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">yarn add use-dehydrated-state</strong></pre></li>
<li>If you are using pnpm, run the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">pnpm add use-dehydrated-state</strong></pre></li>
</ul>
<p><strong class="source-inline">use-dehydrated-state</strong> allows <a id="_idIndexMarker389"/>us to access our dehydrated state at our <span class="No-Break">root-level component.</span></p>
<p>Now, we can do the <a id="_idIndexMarker390"/>necessary setup to leverage the <strong class="source-inline">Hydrate</strong> and <span class="No-Break"><strong class="source-inline">QueryClientProvider</strong></span><span class="No-Break"> wrappers:</span></p>
<pre class="source-code">
import {
  ...
  Outlet,
} from "@remix-run/react";
import { useState } from "react";
import {
  Hydrate,
  QueryClient,
  QueryClientProvider,
} from "@tanstack/react-query";
import { useDehydratedState } from "use-dehydrated-state";
export default function App() {
  const [queryClient] = useState(() =&gt; new QueryClient());
  const dehydratedState = useDehydratedState();
  return (
    ...
       &lt;QueryClientProvider client={queryClient}&gt;
         &lt;Hydrate state={dehydratedState}&gt;
           &lt;Outlet /&gt;
         &lt;/Hydrate&gt;
       &lt;/QueryClientProvider&gt;
     ...
  );
}</pre>
<p>In the preceding snippet, we do <span class="No-Break">the following:</span></p>
<ol>
<li>We do all the <a id="_idIndexMarker391"/>necessary imports to set up our <a id="_idIndexMarker392"/>components. In this scenario, we get <span class="No-Break">the following:</span><ol><li><span class="No-Break">Remix’s </span><span class="No-Break"><strong class="source-inline">Outlet</strong></span></li><li>The <strong class="source-inline">useState</strong> function <span class="No-Break">from React</span></li><li><strong class="source-inline">Hydrate</strong>, <strong class="source-inline">QueryClient</strong>, and <strong class="source-inline">QueryClientProvider</strong> from <span class="No-Break">React Query</span></li><li>The <strong class="source-inline">useDehydratedState</strong> hook <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">use-dehydrated-state</strong></span></li></ol></li>
<li>Inside our <strong class="source-inline">App</strong> component, we do <span class="No-Break">the following:</span><ol><li>We start by creating a new <strong class="source-inline">QueryClient</strong> instance and assigning it as a <strong class="source-inline">state</strong> variable by using the <strong class="source-inline">useState</strong> hook. This is because we need to make sure this data is not shared by different users of our application and requests. This will also make sure we only create <span class="No-Break"><strong class="source-inline">QueryClient</strong></span><span class="No-Break"> once.</span></li><li>We then pass our <strong class="source-inline">queryClient</strong> to <strong class="source-inline">QueryClientProvider</strong> to initiate it and allow it to be accessed by our React Query hooks. <strong class="source-inline">QueryClientProvider</strong> will also wrap the component rendered <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">Outlet</strong></span><span class="No-Break">.</span></li><li>Finally, we also wrap <strong class="source-inline">Outlet</strong> with <strong class="source-inline">Hydrate</strong>. Since <strong class="source-inline">Hydrate</strong> needs to receive <strong class="source-inline">dehydratedState</strong> whenever it is received from the server, we get it from the <strong class="source-inline">useDehydratedState</strong> hook. This means that for every component that receives <strong class="source-inline">dehydratedState</strong> from its <strong class="source-inline">loader</strong>, this data will be passed to our <span class="No-Break"><strong class="source-inline">Hydrate</strong></span><span class="No-Break"> wrapper.</span></li></ol></li>
</ol>
<p>Now, we are all <a id="_idIndexMarker393"/>set to start dehydrating data. Let us see <a id="_idIndexMarker394"/>how to <span class="No-Break">do it:</span></p>
<pre class="source-code">
import axios from "axios";
import { dehydrate, QueryClient, useQuery } from "@tanstack/react-query";
import { json } from "@remix-run/node";
const fetchData = async ({ queryKey }) =&gt; {
  const { username } = queryKey[0];
  const { data } = await axios.get(
    `https://danieljcafonso.builtwithdark.com/
      react-query-api/${username}`
  );
  return data;
};
export async function loader() {
  const queryClient = new QueryClient();
  await queryClient.prefetchQuery(
    [{ queryIdentifier: "api", username: "danieljcafonso" }],
    fetchData
  );
  return json({ dehydratedState: dehydrate(queryClient) });
}
export default function Index() {
  const { data } = useQuery({
    queryKey: [{ queryIdentifier: "api", username:
      "danieljcafonso" }],
    queryFn: fetchData,
  });
  return &lt;div&gt;This page is server side rendered
    {data.hello}&lt;/div&gt;;
}</pre>
<p>In the preceding snippet, we <a id="_idIndexMarker395"/>are prefetching some data, which will be <a id="_idIndexMarker396"/>dehydrated and then hydrated by React Query. Here is what we <span class="No-Break">are doing:</span></p>
<ol>
<li>We do the necessary imports for this component. In this scenario, they are <span class="No-Break">as follows:</span><ol><li>The <span class="No-Break"><strong class="source-inline">axios</strong></span><span class="No-Break"> client</span></li><li>The <strong class="source-inline">dehydrate</strong> function, <strong class="source-inline">QueryClient</strong>, and the <strong class="source-inline">useQuery</strong> hook from the React <span class="No-Break">Query side</span></li><li>The <strong class="source-inline">json</strong> function <span class="No-Break">from Remix</span></li></ol></li>
<li>We create our query function. In this function, we get access to our query key and destructure our username from the query key to perform our <strong class="source-inline">GET</strong> request. We then return our <span class="No-Break">query data.</span></li>
<li>In <strong class="source-inline">loader</strong>, we do <span class="No-Break">the following:</span><ol><li>We create a new <span class="No-Break"><strong class="source-inline">QueryClient</strong></span><span class="No-Break"> instance.</span></li><li>We then leverage the previously created instance to prefetch a query that will be cached under the <strong class="source-inline">[{ queryIdentifier: "api", username: "danieljcafonso" }]</strong> query key and use <strong class="source-inline">fetchData</strong> as the <span class="No-Break">query function.</span></li><li>We then use <strong class="source-inline">dehydrate</strong> for <strong class="source-inline">queryClient</strong> and return it as an <span class="No-Break"><strong class="source-inline">HTTP</strong></span><span class="No-Break"> response.</span></li></ol></li>
<li>In our <strong class="source-inline">Index</strong> component, we create a <strong class="source-inline">useQuery</strong> hook with <strong class="source-inline">[{ queryIdentifier: "api", username: "danieljcafonso" }]</strong> as the query key and <strong class="source-inline">fetchData</strong> as the <span class="No-Break">query function.</span></li>
</ol>
<p>Given that we <a id="_idIndexMarker397"/>returned <strong class="source-inline">dehydratedState</strong> from our <strong class="source-inline">loader</strong> function, this <a id="_idIndexMarker398"/>will be picked up by <strong class="source-inline">useDehydratedState</strong> and passed to our <strong class="source-inline">Hydrate</strong> wrapper, wrapping our component. This means that React Query will pick up <strong class="source-inline">dehydratedState</strong>, hydrate it, and merge this new data with the current data in <strong class="source-inline">QueryClient</strong>. Due to this process, when the hook inside <strong class="source-inline">Index</strong> first runs, it will already have the data that we prefetched <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">loader</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor183"/>Summary</h1>
<p>This chapter taught us how React Query can complement our <span class="No-Break">server-side-rendered applications.</span></p>
<p>You learned how React Query enables you to prefetch data on the server and send it to React Query on the client side. To do this, you got to know two patterns, <strong class="source-inline">initialData</strong> and <strong class="source-inline">hydrate</strong>. In the <strong class="source-inline">initialData</strong> pattern, you prefetch the data on the server and pass it to the <strong class="source-inline">initialData</strong> option in the <strong class="source-inline">useQuery</strong> hook on the client side. In the <strong class="source-inline">hydrate</strong> pattern, you prefetch your query on the server, dehydrate the query cache, and hydrate it on the <span class="No-Break">client side.</span></p>
<p>In <a href="B18501_08.xhtml#_idTextAnchor184"><span class="No-Break"><em class="it lic">Chapter 8</em></span></a>, <em class="it lic">Testing React Query Hooks and Components</em>, we will focus on one of the things that will help you sleep better at night: testing. You will get to know how you can test your component, that is, using React Query, as well as some custom hooks for improving your <span class="No-Break">developer experience.</span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer032">
</div>
</div>
</div></body></html>