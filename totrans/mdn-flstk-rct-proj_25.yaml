- en: '20'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '20'
- en: Diving Deeper into Full-Stack Development
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入全栈开发
- en: After learning how to build and deploy Next.js apps, we are done with our journey
    into full-stack development with React. In this final chapter, I want to give
    you an overview and briefly cover various advanced topics that have been left
    out in this book. This includes concepts such as maintaining large-scale projects,
    optimizing the bundle size, an overview of **user interface** (**UI**) libraries,
    and advanced state management solutions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何构建和部署Next.js应用后，我们就完成了使用React的全栈开发之旅。在本章的最后，我想为您概述并简要介绍本书中未涉及的各种高级主题。这包括维护大型项目、优化包大小、**用户界面**（**UI**）库概述以及高级状态管理解决方案等概念。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主要内容：
- en: Overview of other full-stack frameworks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他全栈框架概述
- en: Overview of UI libraries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI库概述
- en: Overview of advanced state management solutions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级状态管理解决方案概述
- en: Pointers on maintaining large-scale projects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护大型项目的要点
- en: Note
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As this chapter only gives an overview of advanced topics in full-stack development
    with links for further reading, there are no code examples, and as such also no
    technical requirements for this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章仅概述了全栈开发中的高级主题并提供进一步阅读的链接，因此没有代码示例，因此本章也没有技术要求。
- en: Overview of other full-stack frameworks
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他全栈框架概述
- en: In this book, we learned about Next.js, the most popular full-stack framework
    for React. However, other full-stack frameworks might be of interest to you, each
    coming with its own pros and cons.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们学习了Next.js，这是最受欢迎的React全栈框架。然而，其他全栈框架可能对您也很有兴趣，每个框架都有其自身的优缺点。
- en: 'Before we can compare the frameworks, though, let’s recap the different methods
    of rendering in React:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们比较框架之前，让我们回顾一下React中不同的渲染方法：
- en: '**Client-side rendering** (**CSR**): Renders components in the browser'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端渲染**（**CSR**）：在浏览器中渲染组件'
- en: '**Server-side rendering** (**SSR**): Renders components on the server and serves
    the result'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器端渲染**（**SSR**）：在服务器上渲染组件并提供服务结果'
- en: '**Static site generation** (**SSG**): Renders components on the server and
    stores them as static HTML, then serves the static HTML'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态站点生成**（**SSG**）：在服务器上渲染组件并将它们存储为静态HTML，然后提供静态HTML'
- en: '**Incremental static generation** (**ISR**): Does SSG on the fly and caches
    the result for a certain amount of time'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增量静态生成**（**ISR**）：动态执行SSG并缓存结果一段时间'
- en: '**Deferred site generation** (**DSG**): Caches all data upon build time and
    when pages are re-rendered, makes use of that cached data'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟站点生成**（**DSG**）：在构建时间和页面重新渲染时缓存所有数据，并利用这些缓存数据'
- en: Additionally, many frameworks (and cloud providers) support the **Edge Runtime**,
    a subset of standard web APIs that are used to run code on the “edge.” The “edge”
    in this case refers to serverless compute environments that can be deployed in
    many locations as close to the customer as possible. For example, if someone accesses
    your website from Austria, the code will run on the closest server, which may
    be in Austria or Germany. For someone from the United States, however, the code
    will run on a server in the United States. This reduces network latency and makes
    our app load faster.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，许多框架（和云服务提供商）支持**Edge运行时**，这是标准Web API的一个子集，用于在“边缘”运行代码。这里的“边缘”指的是可以部署在尽可能靠近客户的位置的无服务器计算环境。例如，如果有人从奥地利访问您的网站，代码将在奥地利或德国的最近的服务器上运行。然而，对于来自美国的人来说，代码将在美国的某个服务器上运行。这减少了网络延迟并使我们的应用加载更快。
- en: Now, let’s have a look at the different full-stack frameworks.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看不同的全栈框架。
- en: Next.js
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Next.js
- en: We have already learned about Next.js in this book – it is the most popular
    full-stack web framework at the time of writing, supporting CSR, SSR, SSG, and
    ISR. Lately, Next.js defaults to SSG to keep your app as performant as possible,
    but it still offers the ability to revalidate cached pages and provide SSR when
    necessary.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中已经学习了Next.js——它是撰写本书时最受欢迎的全栈Web框架，支持CSR、SSR、SSG和ISR。最近，Next.js默认使用SSG以保持应用尽可能高效，但它仍然提供重新验证缓存页面并在必要时提供SSR的能力。
- en: Next.js also supports the Edge Runtime, but you have to specifically opt into
    using it instead of the (default) Node.js runtime. Certain features are also not
    available on the Edge Runtime.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js也支持Edge运行时，但您必须明确选择使用它而不是（默认的）Node.js运行时。某些功能在Edge运行时也不可用。
- en: 'You can check out Next.js here: [https://nextjs.org/](https://nextjs.org/).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里查看 Next.js：[https://nextjs.org/](https://nextjs.org/)。
- en: Remix
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Remix
- en: Remix is a full-stack framework that focuses on web standards.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 是一个全栈框架，专注于 Web 标准。
- en: Unlike Next.js, it does not offer SSG and instead focuses on improving dynamic
    rendering performance and integration with web infrastructure via SSR. As Remix
    is fully built on web standards, it does not require Node.js to run, so it can
    run natively on edge runtimes, such as Cloudflare Workers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Next.js 不同，它不提供静态站点生成（SSG），而是专注于提高动态渲染性能和通过服务器端渲染（SSR）与 Web 基础设施的集成。由于 Remix
    完全基于 Web 标准，它不需要 Node.js 来运行，因此可以在边缘运行时（如 Cloudflare Workers）本地运行。
- en: Currently, Remix does not support **React Server Components** (**RSCs**), but
    it has its own patterns that result in the same advantages as using RSCs.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Remix 不支持 **React 服务器组件**（**RSCs**），但它有自己的模式，可以带来与使用 RSCs 相同的优势。
- en: Like Next.js, it supports nested routes (with nested layouts), dynamic routing,
    and parallel rendering on the server. The Remix router is based on React Router,
    which makes it easy to understand if you have already worked with React Router.
    It also supports loading/error states, and a form of Server Actions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Next.js 类似，它支持嵌套路由（带有嵌套布局）、动态路由和服务器端并行渲染。Remix 路由基于 React Router，如果你已经使用过
    React Router，那么它很容易理解。它还支持加载/错误状态，以及一种服务器端操作的形式。
- en: Overall, Remix is a really good alternative to Next.js, especially if you prefer
    working with standard web APIs and care about edge runtime support. Its goal is
    to make web development simple again by relying on standards as much as possible.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，Remix 是 Next.js 的一个非常好的替代品，特别是如果你更喜欢使用标准 Web API 并关心边缘运行时支持。它的目标是尽可能依赖标准，使
    Web 开发再次变得简单。
- en: 'You can check out Remix here: [https://remix.run/](https://remix.run/).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里查看 Remix：[https://remix.run/](https://remix.run/)。
- en: Gatsby
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gatsby
- en: Gatsby mainly focuses on SSG. While it can now also do SSR, the framework authors
    encourage using SSG as much as possible. Instead of ISR, Gatsby offers DSG, which
    makes data more consistent on big websites, but at the cost of potentially serving
    stale data.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Gatsby 主要关注 SSG。虽然现在它也可以进行 SSR，但框架作者鼓励尽可能多地使用 SSG。而不是增量静态化（ISR），Gatsby 提供了数据同步生成（DSG），在大网站上使数据更加一致，但代价是可能提供过时的数据。
- en: Gatsby has recently started offering RSC support and also supports the Edge
    Runtime. However, like Next.js, it also depends on Node.js APIs and as such only
    offers a subset of its features for the Edge Runtime.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，Gatsby 开始提供 RSC 支持，并支持边缘运行时。然而，与 Next.js 一样，它也依赖于 Node.js API，因此只为边缘运行时提供其功能的一个子集。
- en: One advantage of Gatsby is its vast plugin ecosystem, allowing developers to
    easily integrate new features.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Gatsby 的一个优点是其庞大的插件生态系统，允许开发者轻松集成新功能。
- en: However, one downside of Gatsby is that it does not support nested routes with
    nested layouts.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Gatsby 的一个缺点是它不支持带有嵌套布局的嵌套路由。
- en: While both Next.js and Remix offer support for REST and GraphQL, Gatsby focuses
    mainly on GraphQL, supporting REST APIs only as a second-class citizen. However,
    this allows Gatsby to offer plugins that easily integrate various data sources.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Next.js 和 Remix 都提供了对 REST 和 GraphQL 的支持，但 Gatsby 主要关注 GraphQL，仅将 REST API
    作为第二类公民支持。然而，这使 Gatsby 能够提供易于集成各种数据源的插件。
- en: Overall, Gatsby can be a great framework if you mainly want SSG, the ability
    to integrate data from various sources, and an easy-to-learn tool. Instead of
    throwing all the complexity of a framework at you at once, Gatsby progressively
    discloses complexity through its plugin ecosystem.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，如果你主要想使用 SSG、集成来自各种来源的数据以及一个易于学习的工具，Gatsby 可以成为一个很好的框架。Gatsby 不是一次性向你展示框架的所有复杂性，而是通过其插件生态系统逐步揭示复杂性。
- en: 'You can check out Gatsby here: [https://www.gatsbyjs.com/](https://www.gatsbyjs.com/).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里查看 Gatsby：[https://www.gatsbyjs.com/](https://www.gatsbyjs.com/)。
- en: Next, we’ll provide an overview of a few selected UI libraries.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将概述一些选定的 UI 库。
- en: Overview of UI libraries
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI 库概述
- en: In this book, I have purposefully left out UI libraries as they are very opinionated,
    constantly changing, and would make the code examples significantly longer. In
    this section, I would like to provide an overview of some selected UI libraries.
    Feel free to explore them on your own and keep an eye out for other options and
    new releases in this field!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我故意省略了 UI 库，因为它们具有强烈的个人观点，不断变化，并且会使代码示例显著变长。在本节中，我想提供一些选定 UI 库的概述。请随意自行探索，并关注该领域的其他选项和新版本！
- en: Material UI (MUI)
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Material UI (MUI)
- en: MUI is one of the most popular component libraries for React. It supports a
    wide range of components, including complex components such as data tables. It
    also has a very extensible theming system, allowing you to adjust it to your style.
    However, its styling engine, at the time of writing, is incompatible with RSCs,
    which is something that will be improved in upcoming versions. Use MUI if you
    generally like its style but want to customize the colors, typography, and spacings
    to make it your own.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: MUI 是 React 最受欢迎的组件库之一。它支持广泛的组件，包括数据表等复杂组件。它还拥有一个非常可扩展的主题系统，允许你调整它以适应你的风格。然而，截至写作时，它的样式引擎与
    RSC 不兼容，这是未来版本中将得到改进的地方。如果你通常喜欢它的风格但想自定义颜色、字体和间距以使其成为你自己的，请使用 MUI。
- en: 'You can check out MUI here: [https://mui.com/](https://mui.com/).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里查看 MUI：[https://mui.com/](https://mui.com/)。
- en: Tailwind CSS
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tailwind CSS
- en: Tailwind CSS is a utility-first CSS framework and does not require React. However,
    it plays well together with React, allowing you to easily style your custom components.
    As it is CSS-only, you can tailor the React components exactly to your needs.
    It also means that RSCs are fully supported because Tailwind is simply a set of
    CSS classes. Use Tailwind if you want to implement a fully custom style for your
    apps quickly and simply compared to directly using CSS.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Tailwind CSS 是一个以实用工具为主的 CSS 框架，不需要 React。然而，它与 React 协作良好，允许你轻松地为自定义组件添加样式。由于它仅使用
    CSS，你可以根据需要精确地调整 React 组件。这也意味着 RSC 完全受支持，因为 Tailwind 只是一组 CSS 类。如果你想快速简单地实现应用的完全自定义样式，而不是直接使用
    CSS，请使用 Tailwind。
- en: 'You can check out Tailwind CSS here: [https://tailwindcss.com/](https://tailwindcss.com/).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里查看 Tailwind CSS：[https://tailwindcss.com/](https://tailwindcss.com/)。
- en: Tailwind UI
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tailwind UI
- en: 'The makers of Tailwind CSS also provide a set of pre-made style-only components
    that use Tailwind CSS, called Tailwind UI. Check it out if you need inspiration
    for creating components with Tailwind here: [https://tailwindui.com/](https://tailwindui.com/).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Tailwind CSS 的制作者还提供了一套使用 Tailwind CSS 的预制作仅样式组件，称为 Tailwind UI。如果你需要灵感来创建使用
    Tailwind 的组件，请查看它：[https://tailwindui.com/](https://tailwindui.com/)。
- en: React Aria
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React Aria
- en: React Aria is a simple set of components that have great support for accessibility
    and internationalization out of the box. By default, the components are style-free,
    allowing you to build a custom design. You can also use it in combination with
    Tailwind. Use React Aria if you want to create a design system but do not want
    to deal with the challenges of creating accessible components.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: React Aria 是一套具有出色的可访问性和国际化支持的简单组件。默认情况下，组件是无样式的，允许你构建自定义设计。你还可以将其与 Tailwind
    结合使用。如果你想创建一个设计系统但又不想处理创建可访问性组件的挑战，请使用 React Aria。
- en: 'You can check out React Aria here: [https://react-spectrum.adobe.com/react-aria/](https://react-spectrum.adobe.com/react-aria/).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里查看 React Aria：[https://react-spectrum.adobe.com/react-aria/](https://react-spectrum.adobe.com/react-aria/)。
- en: NextUI
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NextUI
- en: NextUI is an upcoming UI library using the style of Vercel (the company behind
    Next.js). It is built on top of Tailwind CSS but offers various components built
    on top of React Aria, ensuring first-class accessibility support. Like MUI, it
    also offers many components and is very customizable through themes. Additionally,
    it supports RSC because it is based on Tailwind CSS. Use NextUI if you like the
    style and want to customize it a bit, especially if you are developing with a
    framework that has RSC support.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: NextUI 是一个使用 Vercel（Next.js 背后的公司）风格的即将推出的 UI 库。它建立在 Tailwind CSS 之上，但提供了基于
    React Aria 的各种组件，确保了一流的可访问性支持。像 MUI 一样，它也提供了许多组件，并且可以通过主题进行高度定制。此外，它支持 RSC，因为它基于
    Tailwind CSS。如果你喜欢这种风格并想稍作定制，尤其是如果你正在使用具有 RSC 支持的框架进行开发，请使用 NextUI。
- en: 'You can check out NextUI here: [https://nextui.org/](https://nextui.org/).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里查看 NextUI：[https://nextui.org/](https://nextui.org/)。
- en: Next, we’ll provide an overview of advanced state management solutions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将提供高级状态管理解决方案的概述。
- en: Overview of advanced state management solutions
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级状态管理解决方案概述
- en: In this book, we focused on simple state management solutions in React, such
    as `useState` and contexts. However, in large-scale projects, it might make sense
    to use advanced state management libraries to deal with complex state. I will
    give an overview of some selected state management libraries here, but keep in
    mind that there are many more libraries out there, so feel free to check them
    out and decide which one fits your project best.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们专注于React中的简单状态管理解决方案，如`useState`和上下文。然而，在大型项目中，使用高级状态管理库来处理复杂状态可能是有意义的。在这里，我将概述一些选定的状态管理库，但请记住，还有许多其他库，所以请随意查看它们并决定哪个最适合你的项目。
- en: Recoil
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Recoil
- en: Recoil is a state management library for React built by Facebook Open Source.
    As such, it shares many of the principles of React. It is a very simple but powerful
    system, where state is stored in atoms, and then derived via selectors. This allows
    us to, for example, store only the user input of a form in atoms, and a resulting
    payload in a selector, which derives its state from the atoms.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Recoil是一个由Facebook Open Source构建的React状态管理库。因此，它共享了许多React的原则。它是一个非常简单但强大的系统，其中状态存储在原子中，然后通过选择器派生。这使得我们能够，例如，仅在原子中存储表单的用户输入，并在选择器中存储结果的有效负载，该选择器从原子中派生其状态。
- en: 'You can check out Recoil here: [https://recoiljs.org/](https://recoiljs.org/).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里查看Recoil：[https://recoiljs.org/](https://recoiljs.org/).
- en: Jotai
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jotai
- en: Jotai takes a similar approach to Recoil but simplifies the system by getting
    rid of selectors and only dealing with atoms. Atoms can then derive state from
    other atoms. If you want a state management solution that is still simple, but
    more powerful than `useState`, Jotai is a great solution.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Jotai采取与Recoil类似的方法，但通过消除选择器并仅处理原子来简化系统。原子可以从其他原子派生状态。如果你需要一个仍然简单但比`useState`更强大的状态管理解决方案，Jotai是一个很好的选择。
- en: 'You can check out Jotai here: [https://jotai.org](https://jotai.org).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里查看Jotai：[https://jotai.org](https://jotai.org).
- en: Redux
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Redux
- en: Redux takes a different approach, offering a central store where all your state
    is contained, and then only allowing you to change it through actions. This ensures
    your application behaves consistently, and that the same user actions always result
    in the same state changes. Redux can be great for applications where actions are
    essential and when undo/redo functionality is needed (such as certain editors).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Redux采取了一种不同的方法，提供了一个中心存储，其中包含你所有的状态，然后只允许你通过操作来更改它。这确保了你的应用程序表现一致，并且相同的用户操作总是导致相同的状态变化。Redux对于操作至关重要且需要撤销/重做功能的应用程序来说非常出色（例如某些编辑器）。
- en: 'You can check out Redux here: [https://redux.js.org](https://redux.js.org).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里查看Redux：[https://redux.js.org](https://redux.js.org).
- en: MobX
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MobX
- en: MobX is a signal-based state management library that uses observables to track
    state changes. When a value is made observable, it can be mutated directly, just
    like a regular JavaScript variable, but all changes to it trigger observers of
    the state to execute and re-render components.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: MobX是一个基于信号的州管理库，它使用可观察性来跟踪状态变化。当一个值被设置为可观察的，它可以被直接修改，就像一个常规的JavaScript变量一样，但对其的所有更改都会触发状态观察者的执行和组件的重渲染。
- en: 'You can check out MobX here: [https://mobx.js.org/](https://mobx.js.org/).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里查看MobX：[https://mobx.js.org/](https://mobx.js.org/).
- en: xstate
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: xstate
- en: xstate is a state machine library, which can be very useful when you have complex
    user interfaces with various states that need to be kept track of.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: xstate是一个状态机库，当你有复杂用户界面和需要跟踪的各种状态时，它非常有用。
- en: 'You can check out xstate here: [https://stately.ai/docs/xstate](https://stately.ai/docs/xstate).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里查看xstate：[https://stately.ai/docs/xstate](https://stately.ai/docs/xstate).
- en: Zustand
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Zustand
- en: Zustand is a small state management library with a hook-based API that combines
    values and functions that change the values in stores. Each store then exposes
    a hook where its values and functions can be used.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Zustand是一个小型状态管理库，具有基于hook的API，它结合了存储中的值和更改这些值的函数。每个存储都暴露一个hook，其中可以使用其值和函数。
- en: 'You can check out Zustand here: [https://docs.pmnd.rs/zustand/getting-started/introduction](https://docs.pmnd.rs/zustand/getting-started/introduction).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里查看Zustand：[https://docs.pmnd.rs/zustand/getting-started/introduction](https://docs.pmnd.rs/zustand/getting-started/introduction).
- en: Now, let’s wrap up by learning about some pointers on maintaining large-scale
    projects.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过学习一些维护大型项目的要点来结束。
- en: Pointers on maintaining large-scale projects
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维护大型项目的要点
- en: To keep this book as short and to the point as possible, as well as available
    to a wide audience, I intentionally left out some topics and technologies. However,
    these are still very important to get to know when maintaining large-scale projects,
    so I want to cover them briefly here.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这本书尽可能简短、直接，并且面向更广泛的受众，我故意省略了一些主题和技术。然而，当维护大规模项目时，了解这些内容仍然非常重要，因此我想在这里简要介绍它们。
- en: Using TypeScript
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 TypeScript
- en: TypeScript is JavaScript extended with syntax for types. A type system can be
    very useful in catching bugs early and give confidence when refactoring a large
    code base. While it can take some time to get used to typing everything, it becomes
    a blessing when you realize all problems appear as type errors in your code editor
    instead of runtime errors for your users.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 是在 JavaScript 中扩展了类型语法的语言。类型系统可以在早期捕获错误，并在重构大型代码库时提供信心。虽然适应所有类型的输入可能需要一些时间，但当你意识到所有问题都作为类型错误出现在你的代码编辑器中，而不是用户的运行时错误时，它就会变成一种祝福。
- en: I would recommend using TypeScript for all new projects. It is easy to learn
    when you already know JavaScript and integrates well with frameworks such as Next.js.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议所有新的项目都使用 TypeScript。当你已经了解 JavaScript 时，它很容易学习，并且与 Next.js 等框架很好地集成。
- en: 'You can learn more about TypeScript here: [https://www.typescriptlang.org](https://www.typescriptlang.org).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于 TypeScript 的信息：[https://www.typescriptlang.org](https://www.typescriptlang.org).
- en: Setting up a Monorepo
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Monorepo
- en: In this book, we were always dealing with a single app at a time. However, large-scale
    projects often consist of multiple apps, with potentially multiple internal libraries
    shared between them. For example, you might have two apps, which share UI components
    in a common UI library. Having all those libraries and apps in separate git repositories
    can often lead to organizational overhead.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们一直是在处理单个应用程序。然而，大规模项目通常由多个应用程序组成，它们之间可能共享多个内部库。例如，你可能有两个应用程序，它们在公共 UI
    库中共享 UI 组件。将这些库和应用程序放在单独的 git 仓库中，往往会导致组织上的开销。
- en: To keep things simple, development teams often decide to set up a Monorepo,
    which contains all apps and libraries in a single repository. This also makes
    it easier to keep the code base consistent and keep track of large-scale refactorings.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，开发团队通常会决定设置一个 Monorepo，其中包含所有应用程序和库。这也使得保持代码库的一致性和跟踪大规模重构变得更加容易。
- en: 'You can learn more about Monorepos here: [https://monorepo.tools](https://monorepo.tools).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于 Monorepos 的信息：[https://monorepo.tools](https://monorepo.tools).
- en: To set up a Monorepo, use a package manager that supports workspaces, such as
    pnpm ([https://pnpm.io](https://pnpm.io)) or yarn ([https://yarnpkg.com](https://yarnpkg.com)).
    Certain tools make creating and maintaining Monorepos easier, such as Turborepo.
    Check out the guides on [https://turbo.build](https://turbo.build) to learn how
    to set up a Monorepo with Turborepo.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置 Monorepo，请使用支持工作区的包管理器，例如 pnpm ([https://pnpm.io](https://pnpm.io)) 或 yarn
    ([https://yarnpkg.com](https://yarnpkg.com))。某些工具使创建和维护 Monorepos 更加容易，例如 Turborepo。查看
    [https://turbo.build](https://turbo.build) 上的指南，了解如何使用 Turborepo 设置 Monorepo。
- en: Optimizing the bundle size
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化包大小
- en: As your project grows, the JavaScript bundle that’s sent to the browser also
    grows. This can be problematic for devices on slower connections or with slower
    processors. Sometimes, certain dependencies add a lot to the bundle size, so it
    is a good idea to regularly check how changes in your project affect the bundle
    size.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的项目增长，发送到浏览器的 JavaScript 包也会增长。这可能会对连接速度较慢或处理器较慢的设备造成问题。有时，某些依赖项会增加包的大小，因此定期检查项目中的更改如何影响包大小是一个好主意。
- en: 'For Vite, you can use `vite-bundle-visualizer` to find out which dependencies
    are increasing your bundle size: [https://github.com/KusStar/vite-bundle-visualizer](https://github.com/KusStar/vite-bundle-visualizer).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Vite，你可以使用 `vite-bundle-visualizer` 来找出哪些依赖项增加了你的包大小：[https://github.com/KusStar/vite-bundle-visualizer](https://github.com/KusStar/vite-bundle-visualizer).
- en: 'For Next.js, you can use the official `@next/bundle-analyzer` plugin: [https://nextjs.org/docs/app/building-your-application/optimizing/bundle-analyzer](https://nextjs.org/docs/app/building-your-application/optimizing/bundle-analyzer).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Next.js，你可以使用官方的 `@next/bundle-analyzer` 插件：[https://nextjs.org/docs/app/building-your-application/optimizing/bundle-analyzer](https://nextjs.org/docs/app/building-your-application/optimizing/bundle-analyzer).
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this book, we started with the motivation to become a full-stack developer.
    Then, we set up our development environment and learned about tools that make
    our lives easier. Next, we got to know Node.js and MongoDB, taking our first steps
    as backend developers. Then, we implemented a backend for a blog application using
    Express and Mongoose, and we wrote unit tests for it using Jest. Afterward, we
    integrated a frontend with our backend using React and TanStack Query, and as
    such, created our first full-stack web application. Next, we learned how to deploy
    our application with Docker, and we learned how to set up CI/CD. Then, we added
    authentication to our application using JWT. We learned how to improve the load
    time of our app using SSR and developed our own (simple) SSR solution in the process.
    We then learned how search engines work, and how to make sure customers can find
    our web application by facilitating SEO and providing metadata for social media
    embeds. Next, we implemented end-to-end tests using Playwright, making sure that
    our app always works as expected. Then, we learned how to aggregate and visualize
    statistics using MongoDB and Victory.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们以成为全栈开发者的动机开始。然后，我们搭建了我们的开发环境，并学习了使我们的生活更轻松的工具。接下来，我们了解了Node.js和MongoDB，作为后端开发者迈出了第一步。然后，我们使用Express和Mongoose为博客应用实现了后端，并使用Jest为其编写了单元测试。之后，我们使用React和TanStack
    Query将前端与后端集成，从而创建了我们的第一个全栈Web应用。接下来，我们学习了如何使用Docker部署我们的应用，以及如何设置CI/CD。然后，我们使用JWT为我们的应用添加了身份验证。我们学习了如何使用SSR提高我们应用的加载时间，并在过程中开发了自己的（简单的）SSR解决方案。然后，我们学习了搜索引擎的工作原理，以及如何通过促进SEO和为社交媒体嵌入提供元数据，确保客户可以找到我们的Web应用。接下来，我们使用Playwright实现了端到端测试，确保我们的应用始终按预期工作。然后，我们学习了如何使用MongoDB和Victory聚合和可视化统计数据。
- en: Afterward, we took a detour from REST APIs and developed a backend with a GraphQL
    API, learning what GraphQL is and what its benefits are. We then developed a frontend
    that consumes this GraphQL API. Next, we took a break from our blog application
    and built an event-based chat app using Socket.IO. While doing so, we learned
    how to create a backend and a frontend, and how to add persistence, in the event-based
    paradigm. In the last few chapters of this book, we learned about Next.js, a full-stack
    web development framework. We introduced the app router, a new way to structure
    your apps, and RSCs, which allowed us to merge the backend and frontend even more,
    reducing the need for boilerplate code to create APIs, and instead allowing us
    to directly access code from a data layer inside RSCs. We also learned about advanced
    concepts and optimizations in Next.js, such as caching, SEO, and optimized font
    and image loading. Finally, we learned how to deploy a Next.js app using Vercel,
    a cloud platform provided by the makers of Next.js, and we created a custom deployment
    setup using Docker so that we can deploy our app on any other cloud provider (or
    our own servers).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们偏离了REST API，使用GraphQL API开发了一个后端，学习了GraphQL是什么以及它的好处。然后，我们开发了一个前端来消费这个GraphQL
    API。接下来，我们暂时放下了博客应用，使用Socket.IO构建了一个基于事件的聊天应用。在这个过程中，我们学习了如何创建后端和前端，以及如何在基于事件的范式下添加持久性。在本书的最后几章中，我们学习了Next.js，一个全栈Web开发框架。我们介绍了应用路由，这是一种新的应用程序结构方式，以及RSCs，它允许我们将后端和前端合并得更紧密，减少了创建API的样板代码需求，并允许我们直接从RSCs内部的数据层访问代码。我们还学习了Next.js中的高级概念和优化，如缓存、SEO和优化的字体和图像加载。最后，我们学习了如何使用Vercel部署Next.js应用，Vercel是由Next.js的制作者提供的云平台，我们还创建了一个自定义的部署设置，使用Docker，这样我们就可以在任何其他云服务提供商（或我们自己的服务器）上部署我们的应用。
- en: It has been a long journey. But, as we have seen in this chapter, there are
    still many more topics to dive deeper into, and the web development ecosystem
    is changing fast. New technologies keep coming out all the time, especially in
    terms of RSCs and Server Actions, which, at the time of writing, are still new
    and upcoming. I expect many more features to be released in this space, so keep
    an eye out for ground-breaking announcements in the React world!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经是一条漫长的道路。然而，正如我们在本章中看到的，还有更多的话题需要我们深入研究，Web开发生态系统也在快速发展。新技术不断涌现，尤其是在RSCs和Server
    Actions方面，在撰写本文时，这些技术仍然新颖且正在兴起。我预计这个领域将推出更多功能，所以请密切关注React世界中的突破性公告！
- en: “Stay hungry. Stay foolish. Never let go of your appetite to go after new ideas,
    new experiences, and new adventures.” – Steve Jobs
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: “求知若饥，虚心若愚。永远不要放弃对新想法、新体验和新冒险的渴望。” —— 史蒂夫·乔布斯
