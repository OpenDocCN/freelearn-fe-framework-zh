- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Angular Services and the Singleton Pattern
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular服务和单例模式
- en: One of the great differences between a static web page and a single-page application
    is the processing capacity and interaction in the user’s browser, giving the feeling
    of an application installed on the device. In the Angular framework, the elements
    for this processing and interaction, not only with the backend but with the user,
    are the **services**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 静态网页和单页应用之间的一大区别是用户浏览器中的处理能力和交互，给人一种在设备上安装了应用程序的感觉。在Angular框架中，进行这种处理和交互的元素，不仅与后端，而且与用户，是**服务**。
- en: This element is so important to Angular that the team created a dependency management
    system, which allows a simplified way of creating, composing, and using services
    in components.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这个元素对Angular来说非常重要，以至于团队创建了一个依赖管理系统，它允许以简化的方式在组件中创建、组合和使用服务。
- en: In this chapter, we will explore this element and learn about the design patterns
    it uses and the best practices to use in your project.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨这个元素，了解它使用的模式以及在你的项目中应遵循的最佳实践。
- en: 'Here we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将涵盖以下主题：
- en: Creating services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建服务
- en: Understanding the dependency injection pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解依赖注入模式
- en: Communication between components using services
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务在组件之间进行通信
- en: REST API consumption
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费REST API
- en: By the end of the chapter, you will be able to create reusable and maintainable
    services, in addition to understanding practices that will improve your productivity.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够创建可重用和可维护的服务，同时了解将提高你生产力的实践。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the instructions in this chapter, you’ll need the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章的说明，你需要以下内容：
- en: Visual Studio Code ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))
- en: Node.js 18 or higher ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 18或更高版本 ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
- en: The code files for this chapter are available at [https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch5](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch5).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可在[https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch5](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch5)找到。
- en: Creating services
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务
- en: '**Services** in Angular are TypeScript classes that aim to implement business
    logic for our interfaces. Business logic in a frontend project can seem like a
    controversial issue because ideally, all logic and processing should take place
    on the backend, which is correct.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Angular中的**服务**是TypeScript类，旨在实现我们接口的业务逻辑。在前端项目中，业务逻辑可能是一个有争议的问题，因为理想情况下，所有逻辑和处理都应该在后台进行，这是正确的。
- en: Here we are using business rules; these rules are generic behaviors that do
    not depend on a visual component and can be reused in other components.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用的是业务规则；这些规则是通用的行为，不依赖于视觉组件，可以在其他组件中重用。
- en: 'Examples of frontend business rules could be as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 前端业务规则的例子可能如下所示：
- en: Application state control
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用状态控制
- en: Communication with the backend
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与后端的通信
- en: Information validations with a fixed rule, such as the number of digits in a
    telephone number
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用固定规则（如电话号码中的数字数量）进行信息验证
- en: 'We are going to put this concept into practice, and in our gym diary application,
    we are going to create the first service. In the command line we will use the
    Angular CLI:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个概念付诸实践，并在我们的健身房日记应用程序中创建第一个服务。在命令行中，我们将使用Angular CLI：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Unlike the component, we can see that the element created by the Angular CLI
    is composed only of a TypeScript file (and its corresponding unit test file).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与组件不同，我们可以看到Angular CLI创建的元素仅由一个TypeScript文件（及其相应的单元测试文件）组成。
- en: 'In this file, we will see the boilerplate that the Angular CLI generated:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们将看到Angular CLI生成的样板代码：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here we have a TypeScript class called `ExerciseSetsService` with a decorator
    called `@Injectable`. It is this decorator that characterizes a service in Angular;
    we will see more details about it later in this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个名为`ExerciseSetsService`的TypeScript类，它有一个名为`@Injectable`的装饰器。正是这个装饰器定义了Angular中的服务；我们将在本章后面了解更多关于它的细节。
- en: Let’s refactor our project and place the initial series of sets for our diary
    in this service.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构我们的项目，并将日记的初始系列设置放在这个服务中。
- en: 'First, we’ll create the methods that will get the initial list and refresh
    it in the backend:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建获取初始列表并在后端刷新它的方法：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the service, we move the initialization and refresh of the journal component
    into the service, using the `getInitialList` and `refreshList` methods.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务中，我们将日记组件的初始化和刷新操作移动到服务中，使用 `getInitialList` 和 `refreshList` 方法。
- en: These methods will be improved when we see the communication with the backend,
    but here, we are already decoupling the exercise list management business rule
    from the component that renders the user interface, creating a specific service.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看到与后端的通信时，这些方法将得到改进，但在这里，我们已经在将管理练习列表的业务规则从渲染用户界面的组件中解耦，创建了一个特定的服务。
- en: 'Let’s now consider the method that adds an item to the exercise list:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑向练习列表添加项的方法：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `setList` attribute of the service can be null, so here we use the TypeScript
    type guard concept (more details in [*Chapter 3*](B19562_03.xhtml#_idTextAnchor112),
    *TypeScript Patterns for Angular*) to manipulate the array. Here, we also use
    the concept of immutability by returning a new array after adding the new element.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的 `setList` 属性可以是 null，因此在这里我们使用 TypeScript 类型守卫概念（更多详情见 [*第 3 章*](B19562_03.xhtml#_idTextAnchor112)，*Angular
    的 TypeScript 模式*）来操作数组。在这里，我们也使用不可变性的概念，在添加新元素后返回一个新的数组。
- en: 'In the `DiaryComponent` component, we will use the service we created:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DiaryComponent` 组件中，我们将使用我们创建的服务：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the component, the first thing we can observe is the use of the class constructor,
    declaring an `exerciseSetsService` private attribute of type `ExerciseSetsService`.
    With this declaration, we have an object instantiated and we refactor our component,
    replacing the initialization of the list and the refresh action with service methods.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件中，我们首先可以观察到的是类构造函数的使用，声明了一个类型为 `ExerciseSetsService` 的私有属性 `exerciseSetsService`。通过这个声明，我们实例化了一个对象，并重构了我们的组件，用服务方法替换了列表的初始化和刷新操作。
- en: From now on, it is no longer a concern of the component how the exercise list
    is obtained and managed; this is the responsibility of the service, and we can
    now use this service in other components if necessary. In this piece of code,
    you may be wondering why we are using the `ExerciseSetsService` service if we
    did not instantiate an object of that class.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，组件不再关心如何获取和管理练习列表；这是服务的责任，如果需要，我们现在可以在其他组件中使用这个服务。在这段代码中，你可能想知道为什么我们使用了
    `ExerciseSetsService` 服务，如果我们没有实例化该类的对象。
- en: Here, we have a great feature of Angular, which is the dependency injection
    mechanism, and we will delve into this topic next.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，Angular 有一个很好的特性，即依赖注入机制，我们将在下一节深入探讨这个话题。
- en: Understanding the dependency injection pattern
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解依赖注入模式
- en: In object-oriented software development, it is good practice to prioritize composition
    over inheritance, meaning that a class should be composed of other classes (preferably
    interfaces).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的软件开发中，优先考虑组合而非继承是一个好的实践，这意味着一个类应该由其他类（最好是接口）组成。
- en: 'In our previous example, we can see that the `service` class comprises the
    `DiaryComponent` component. Another way to use this service would be as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们可以看到 `service` 类包含了 `DiaryComponent` 组件。另一种使用此服务的方法如下：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here we modify our code, leaving the creation of the service class object expressly
    in the component’s constructor method. Running our code again, we can see that
    the interface remains the same.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们修改我们的代码，明确地将服务类对象的创建留在了组件的构造函数方法中。再次运行我们的代码，我们可以看到界面保持不变。
- en: 'This approach, although functional, has some problems, such as the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法虽然功能齐全，但存在一些问题，例如以下内容：
- en: High coupling between the component and the service, which means that we may
    encounter problems if we need to change the implementation of the service, for
    example, for the construction of unit tests
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件和服务之间的高耦合，这意味着如果我们需要更改服务的实现，例如构建单元测试，我们可能会遇到问题。
- en: If the service depends on another class, as we will see with Angular’s HTTP
    request service, the `HttpClient` class, we will have to implement this dependency
    in our component, increasing its complexity
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务依赖于另一个类，正如我们将要在 Angular 的 HTTP 请求服务 `HttpClient` 类中看到的那样，我们将在我们的组件中实现这个依赖，从而增加其复杂性。
- en: To simplify development and solve the problems we’ve described, Angular has
    a dependency injection mechanism. This feature allows us to compose a class just
    by declaring the object we need in its constructor.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化开发并解决我们所描述的问题，Angular有一个依赖注入机制。这个特性允许我们仅通过在构造函数中声明所需的对象来组合一个类。
- en: Angular, leveraging TypeScript, will use the types defined in this declaration
    to assemble the dependency tree of the class we need and create the object we
    require.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Angular利用TypeScript，将使用在此声明中定义的类型来组装我们所需的类的依赖树，并创建所需的对象。
- en: 'Let’s return to our code and analyze how this mechanism works:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的代码，分析这个机制是如何工作的：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the code, we declare the dependency of our class in the constructor, creating
    the `exerciseSetsService` attribute. With this, we can initialize the `exerciseList`
    attribute in its declaration.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们在构造函数中声明了我们类的依赖，创建了`exerciseSetsService`属性。有了这个，我们就可以在它的声明中初始化`exerciseList`属性。
- en: 'In [*Chapter 10*](B19562_10.xhtml#_idTextAnchor264), *Design for Tests: Best
    Practices*, we will replace the implementation of this service in the test runtime.
    All this is possible thanks to Angular’s dependency injection feature.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B19562_10.xhtml#_idTextAnchor264)，*为测试而设计：最佳实践*中，我们将替换测试运行时中此服务的实现。所有这一切都得益于Angular的依赖注入功能。
- en: From version 14 of Angular, we have an alternative for dependency injection
    that we can use, which we will see next.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从Angular的14版开始，我们有了一个依赖注入的替代方案，我们将在下一节中看到。
- en: Using the inject() function
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用inject()函数
- en: The `inject()` function allows you to use the same dependency injection feature
    but in a simpler way.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`inject()`函数允许你以更简单的方式使用相同的依赖注入功能。'
- en: 'Let’s refactor our component’s code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构我们的组件代码：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here we remove the constructor declaration for the dependency injection and
    directly declare the `exerciseSetsService` service. For the creation of the object,
    we use the `inject` function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们移除了依赖注入的构造函数声明，并直接声明了`exerciseSetsService`服务。对于对象的创建，我们使用`inject`函数。
- en: A point of note is that we are using the `inject` function of the `@angular/core`
    module and not the function present in the `@angular/core/testing` module, which
    will be used for another purpose.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们使用的是`@angular/core`模块中的`inject`函数，而不是`@angular/core/testing`模块中存在的函数，后者将用于其他目的。
- en: This method, in addition to being simpler and clearer (the service is being
    injected by the function), allows the simplification of development, if it is
    necessary to use inheritance for a specific component. Remembering that good practice
    says we should prefer composition over inheritance, but especially in libraries,
    this feature can be interesting.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法，除了更简单、更清晰（服务是通过函数注入的）之外，如果需要为特定组件使用继承，还可以简化开发。记住，良好的实践建议我们应优先选择组合而非继承，但在库中，这个特性可能很有趣。
- en: A point of note for the use of the `inject` function is that it can only be
    used in the component’s construction phase, that is, in the declaration of the
    method’s property or in the class’s constructor method.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`inject`函数的一个需要注意的点是其只能在组件的构造阶段使用，即在方法的属性声明或类的构造方法中。
- en: 'Any use in another context will generate the following compilation error:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他上下文中的任何使用都将生成以下编译错误：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let’s now delve into another aspect of Angular services, which is the use of
    the singleton design pattern, and how we can use this capability for communication
    between components.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入探讨Angular服务的另一个方面，即单例设计模式的使用，以及我们如何利用这种能力在组件之间进行通信。
- en: Communication between components using services
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务进行组件间的通信
- en: A characteristic that we must understand about Angular services is that, by
    default, every service instantiated by the dependency injection mechanism has
    the same reference; that is, a new object is not created, but reused.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Angular服务，我们必须理解的一个特点是，默认情况下，由依赖注入机制实例化的每个服务都有相同的引用；也就是说，不会创建新的对象，而是重用。
- en: This is because the dependency injection mechanism implements the singleton
    design pattern to create and deliver the objects. The **singleton pattern** is
    a design pattern of the creational type and allows the creation of objects whose
    access will be global in the system.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为依赖注入机制实现了单例设计模式来创建和传递对象。**单例模式**是一种创建型设计模式，允许创建在系统中具有全局访问权限的对象。
- en: This characteristic is important for the service because, as the service deal
    with reusable business rules, we can use the same instance between components,
    without having to rebuild the entire object. In addition, we can take advantage
    of this characteristic and use services as an alternative for communication between
    components.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性对于服务很重要，因为服务处理可重用的业务规则，我们可以在组件之间使用相同的实例，而无需重建整个对象。此外，我们可以利用这个特性，将服务用作组件之间通信的替代方案。
- en: 'Let’s change our gym diary so that the `ListEntriesComponent` component receives
    the initial list by service instead of `@Input`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的健身房日记，使`ListEntriesComponent`组件通过服务而不是`@Input`接收初始列表：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the `DiaryComponent` component, we will remove the list from the input:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DiaryComponent`组件中，我们将从输入中删除列表：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Running it again we can see that the list continues to appear. This is because
    the instance of the service used in both components is the same. However, this
    form of communication requires us to use RxJS to update the values with the buttons
    on the diary screen. We will go deeper into this topic in [*Chapter 9*](B19562_09.xhtml#_idTextAnchor242),
    *Exploring Reactivity* *with RxJS*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行它，我们可以看到列表继续出现。这是因为两个组件中使用的服务实例是相同的。然而，这种通信形式需要我们使用RxJS通过日记屏幕上的按钮来更新值。我们将在[*第9章*](B19562_09.xhtml#_idTextAnchor242)中更深入地探讨这个主题，*使用RxJS探索反应性*。
- en: We saw that, by default, the services are singleton, but in Angular, it is possible
    to change this configuration for another service if you need to solve some corner
    cases in your application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，默认情况下，服务是单例的，但在Angular中，如果需要解决应用程序中的某些边缘情况，可以更改此配置以用于其他服务。
- en: 'When we create a service, it has an `@Injectable` decorator, as in our example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个服务时，它有一个`@Injectable`装饰器，就像我们的例子一样：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `provideIn` metadata determines the scope of the service. The value `'root'`
    means that the instance of the service will be unique for every application; that’s
    why, by default, Angular services are singleton.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`provideIn`元数据决定了服务的范围。值`''root''`表示每个应用程序都将有一个唯一的服务实例；这就是为什么默认情况下，Angular服务是单例的。'
- en: 'To change this behavior, let’s first return to the `ListEntriesComponent` component
    to receive `@``Input`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改此行为，让我们首先回到`ListEntriesComponent`组件以接收`@Input`：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s go back to inform the attribute in the `DiaryComponent` component:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`DiaryComponent`组件中通知属性：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the `ExerciseSetsService` service, we will remove the `provideIn` metadata:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ExerciseSetsService`服务中，我们将删除`provideIn`元数据：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we run our application now, the following error will occur:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行我们的应用程序，将发生以下错误：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This error happens when we inform Angular that the service should not be instantiated
    in the application scope. To resolve this error, let’s declare the use of the
    service directly in the `DiaryComponent` component:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误发生在我们通知Angular服务不应该在应用程序范围内实例化时。为了解决这个问题，让我们直接在`DiaryComponent`组件中声明对服务的使用：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So, our system works again, and the component has its own instance of the service.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的系统再次工作，并且组件有自己的服务实例。
- en: This technique, however, must be used in specific cases where the component
    must have its own instance of the services it uses; it is recommended to leave
    the `provideIn` in the services.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种技术必须在特定情况下使用，其中组件必须使用它自己的服务实例；建议在服务中保留`provideIn`。
- en: Let’s now start exploring our application’s communication with the backend using
    Angular.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始使用Angular探索我们的应用程序与后端之间的通信。
- en: REST API consumption
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST API消费
- en: One of the main uses of Angular services is undoubtedly communication with the
    backend of the application, using the **Representational State Transfer** (**REST**)
    protocol.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，Angular服务的主要用途之一是与应用程序的后端通信，使用**表示状态传输**（**REST**）协议。
- en: Let’s learn about this feature in practice by preparing our project to consume
    its backend.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过准备我们的项目以使用其后端来实际了解这个功能。
- en: 'First, let’s upload the backend locally by accessing the `gym-diary-backend`
    folder and using the following command in your command-line prompt:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过访问`gym-diary-backend`文件夹并在您的命令行提示符中使用以下命令来本地上传后端：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can leave this command running and can now create the services for the consumption
    of the API.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以保留这个命令运行，并现在可以创建用于消费API的服务。
- en: 'To carry out this consumption, Angular has a specialized service – `HttpClient`.
    To use it, we will first import its module into the `app.module.ts` file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行这种消费，Angular有一个专门的服务——`HttpClient`。要使用它，我们首先将其模块导入到`app.module.ts`文件中：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Our project’s backend API returns some JSON, containing the list of exercises
    for the day. As good practice, we should create an interface to facilitate typing
    and the manipulation of the results in our frontend application. In the `exercise-set.ts`
    file, we will add the following interface:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的后端API返回一些JSON，包含当天的练习列表。作为良好的实践，我们应该创建一个界面来简化我们在前端应用程序中输入和操作结果。在`exercise-set.ts`文件中，我们将添加以下接口：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we can refactor our `ExerciseSetsService` service to use `HttpClient`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以重构我们的`ExerciseSetsService`服务以使用`HttpClient`：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, we inject the `HttpClient` service into our class using the `inject`
    function. We then create the `url` variable to contain the endpoint of this service
    that will be used in the service’s methods.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`inject`函数将`HttpClient`服务注入到我们的类中。然后我们创建`url`变量来包含该服务将用于其方法的端点。
- en: Finally, we refactor the `getInitialList` and `refreshList` methods to consume
    the project’s API. Initially, they have the same implementation, but we will improve
    this code throughout the book.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`getInitialList`和`refreshList`方法重构为消费项目的API。最初，它们有相同的实现，但我们将在整个书中改进这段代码。
- en: An important change was made so that the method does not return the list of
    exercises, but an Observable that contains the list of exercises. This occurs
    because the operation involving consuming a REST API happens asynchronously, and
    through the use of RxJS and its Observables, Angular handles this asynchronicity.
    We will go deeper into this topic in [*Chapter 9*](B19562_09.xhtml#_idTextAnchor242),
    *Exploring Reactivity* *with RxJS*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 进行了一个重要的更改，使得该方法不返回练习列表，而是一个包含练习列表的Observable。这是因为涉及消费REST API的操作是异步的，通过使用RxJS及其Observables，Angular处理这种异步性。我们将在[*第9章*](B19562_09.xhtml#_idTextAnchor242)中更深入地探讨这个主题，*使用RxJS探索反应性*。
- en: Using the `HttpClient` service to consume a *GET-type* API, we declare the return
    type represented here by the `ExerciseSetListAPI` type and the service’s `get`
    method, passing the URL of the endpoint that we are going to consume as a parameter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`HttpClient`服务消费*GET类型*API，我们声明由`ExerciseSetListAPI`类型表示的返回类型和服务的`get`方法，将我们要消费的端点的URL作为参数传递。
- en: 'Let’s now add the other methods to complete our service:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们添加其他方法以完善我们的服务：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: For the inclusion of a new set, we are using the `POST` method of the service
    that calls the API with the verb of the same name. We always pass the URL and,
    in this case, the body of the request will be a new set of exercises.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于包含一个新的集合，我们使用服务中的`POST`方法，该方法使用同名的动词调用API。我们始终传递URL，在这种情况下，请求正文将是新的练习集合。
- en: To update the set, we use the `PUT` method passing the body, and for the URL,
    we use the string interpolation to pass the `id` value that the API demands in
    your contract. Finally, to delete, we use the `DELETE` method, and also using
    interpolation, we pass the `id` value of the element we want to delete.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新集合，我们使用带有正文的`PUT`方法，并使用字符串插值传递API合同中要求的`id`值。最后，为了删除，我们使用`DELETE`方法，并使用插值传递我们想要删除的元素的`id`值。
- en: Let’s tailor our `DiaryComponent` component to consume the refactored service.
    Our challenge here is to deal with the asynchrony of consuming a REST API via
    an HTTP request.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调整我们的`DiaryComponent`组件以消费重构后的服务。我们的挑战是如何处理通过HTTP请求消费REST API的异步性。
- en: 'First, let’s adjust the initialization of the list of exercises:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们调整练习列表的初始化：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the `DiaryComponent` class, we will implement the `OnInit` interface and
    create the `onInit` method. This method is one of the lifecycle events of Angular
    components, which means that it will be called at some point by Angular when building
    and rendering the interface.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DiaryComponent`类中，我们将实现`OnInit`接口并创建`onInit`方法。这是Angular组件的生命周期事件之一，这意味着Angular将在构建和渲染界面时在某个时刻调用它。
- en: The `onInit` method is called after building the component, but before rendering
    the component. We need to implement this method because the filling of the list
    of exercises will occur asynchronously. Implementing this initialization in the
    `onInit` method will ensure that the data will be there when Angular starts rendering
    the screen.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`onInit`方法在构建组件后、渲染组件之前被调用。我们需要实现这个方法，因为练习列表的填充将异步发生。在`onInit`方法中实现这个初始化将确保当Angular开始渲染屏幕时数据已经存在。'
- en: 'In this method, we are using the service, but as it now returns an Observable,
    we need to call the `subscribe` method and, within it, implement the initialization
    of the list. As we are using the smart and presentation component architecture,
    we can implement the button methods in the `DiaryComponent` smart component as
    follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们正在使用该服务，但由于它现在返回一个 Observable，我们需要调用 `subscribe` 方法，并在其中实现列表的初始化。由于我们正在使用智能和展示组件架构，我们可以在
    `DiaryComponent` 智能组件中实现按钮方法如下：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the `newList` method, we refactored this to fetch the list elements through
    the `refreshList` method.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `newList` 方法中，我们将它重构为通过 `refreshList` 方法获取列表元素。
- en: In the `addExercise`, `deleteItem`, and `newRep` methods, we refactored the
    previous logic to use the `exerciseSetsService` service.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `addExercise`、`deleteItem` 和 `newRep` 方法中，我们将之前的逻辑重构为使用 `exerciseSetsService`
    服务。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about Angular services and how to correctly isolate
    the business rule from our applications in a simple and reusable way, as well
    as how Angular services use the singleton pattern for memory and performance optimization.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Angular 服务以及如何以简单和可重用的方式从我们的应用程序中正确隔离业务规则，以及 Angular 服务如何使用单例模式进行内存和性能优化。
- en: We worked with and studied Angular’s dependency injection mechanism and noticed
    how important it is to be able to organize and reuse services between components
    and other services. We also learned how to use the `inject` function for Angular
    services as an alternative to dependency injection via Angular’s constructor.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与 Angular 的依赖注入机制进行了合作并研究，注意到能够组织和重用组件和其他服务之间的服务是多么重要。我们还学习了如何使用 `inject`
    函数作为 Angular 服务的替代，以通过 Angular 的构造函数进行依赖注入。
- en: Finally, we worked with one of the main uses of services, communication with
    the backend, and in this chapter, we began to explore the integration of our frontend
    applications with the backend.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们与服务的其中一个主要用途——与后端通信——进行了合作，并在本章中，我们开始探索将我们的前端应用程序与后端集成的过程。
- en: In the next chapter, we will study the best practices for using forms, the main
    way that our users enter information into our systems.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究使用表单的最佳实践，这是用户将信息输入到我们系统中的主要方式。
- en: 'Part 2: Leveraging Angular’s Capabilities'
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：利用 Angular 的功能
- en: In this part, you will work with more advanced aspects of Angular and see how
    you can use the features of this framework for the most common tasks in your applications.
    You will learn about best practices for forms, how to correctly use Angular’s
    routing mechanism, and finally, how to optimize API consumption using the Interceptor
    design pattern and the RxJS library.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，你将使用 Angular 的更高级功能，并了解你如何使用此框架的常见任务。你将了解表单的最佳实践，如何正确使用 Angular 的路由机制，以及最后如何使用拦截器设计模式和
    RxJS 库优化 API 消费。
- en: 'This part has the following chapters:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 6*](B19562_06.xhtml#_idTextAnchor186)*, Handling User Inputs: Forms*'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B19562_06.xhtml#_idTextAnchor186)*，处理用户输入：表单*'
- en: '[*Chapter 7*](B19562_07.xhtml#_idTextAnchor207)*, Routes and Routers*'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B19562_07.xhtml#_idTextAnchor207)*，路由和路由器*'
- en: '[*Chapter 8*](B19562_08.xhtml#_idTextAnchor225)*, Improving Backend Integrations:
    the Interceptor Pattern*'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B19562_08.xhtml#_idTextAnchor225)*，改进后端集成：拦截器模式*'
- en: '[*Chapter 9*](B19562_09.xhtml#_idTextAnchor242)*, Exploring Reactivity with
    RXJS*'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B19562_09.xhtml#_idTextAnchor242)*，使用 RXJS 探索响应性*'
