- en: Routing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: In the previous chapters, we did a great job separating concerns in our applications
    and adding different layers of abstraction to increase the maintainability of
    the app. However, we have neglected the visual side of things, as well as the
    user experience part.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们在应用程序中分离关注点并添加不同的抽象层，以增加应用程序的可维护性做得很好。然而，我们忽视了视觉方面，以及用户体验部分。
- en: At this moment, our UI is bloated with components and stuff scattered across
    a single screen, and we need to provide a better navigational experience and a
    logical way to change the application's state intuitively.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此刻，我们的用户界面中充斥着组件和各种东西，散布在单个屏幕上，我们需要提供更好的导航体验和一种直观地改变应用程序状态的逻辑方式。
- en: This is the moment where routing acquires special relevance and gives us the
    opportunity to build a navigational narrative for our applications, allowing us
    to split the different areas of interest into different pages that are interconnected
    by a grid of links and URLs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这是路由变得特别重要的时刻，它给了我们建立应用程序导航叙事的机会，允许我们将不同的兴趣领域分割成不同的页面，这些页面通过一系列链接和URL相互连接。
- en: However, our application is only a set of components, so how do we deploy a
    navigation scheme between them? The Angular router was built with componentization
    in mind. We will see how can we create our custom links and make components react
    to them in the following pages.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的应用程序只是一组组件，那么我们如何在它们之间部署导航方案呢？Angular路由器是以组件化为目标而构建的。我们将看到如何创建自定义链接，并在接下来的页面中让组件对其做出反应。
- en: 'In this chapter, we will:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Discover how to define routes to switch components on and off, and redirect
    them to other routes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何定义路由以在组件之间切换，并将它们重定向到其他路由
- en: Trigger routes and load components in our views, depending on the requested
    route
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据请求的路由触发路由并在我们的视图中加载组件
- en: Handle and pass different types of parameters
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理和传递不同类型的参数
- en: Dive into more advanced routing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解更高级的路由
- en: Look at different ways of securing our routes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看不同的保护路由的方式
- en: Uncover how to improve the response time by looking at different async strategies
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 揭示如何通过查看不同的异步策略来改善响应时间
- en: Adding support for the Angular router
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Angular路由器添加支持
- en: 'Having routing in your application means you want to navigate between different
    topics in your navigation. You usually use a top menu or left menu and press on
    links to get where you want. This causes the URL in the browser to change. In
    a **Single-Page Application** (**SPA**), this doesn''t cause a page reload. To
    get set up with the Angular router is quite easy, but there are some things we
    need in place for it to be considered set up:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中使用路由意味着您希望在导航中在不同主题之间进行切换。通常会使用顶部菜单或左侧菜单，并点击链接以到达目的地。这会导致浏览器中的URL发生变化。在**单页应用程序**（**SPA**）中，这不会导致页面重新加载。要设置Angular路由器非常容易，但我们需要一些准备工作才能被认为已经设置好：
- en: Specify a base element in `index.html`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`index.html`中指定基本元素
- en: Import the `RouterModule` and tell the root module about it
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入`RouterModule`并告知根模块
- en: Set up a routing dictionary
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置路由字典
- en: Decide on where to place the viewport of your application, that is, decide where
    in the page your content should be placed
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定应用程序视口的放置位置，即确定内容应放置在页面的哪个位置
- en: Interact with a routing service if you want to investigate things such as routing
    or query parameters, or if you need to programmatically route the user to another
    page in your application
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想要调查诸如路由或查询参数之类的事情，或者如果您需要以编程方式将用户路由到应用程序中的另一页，则与路由服务进行交互。
- en: Specifying the base element
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定基本元素
- en: 'We need to inform Angular about the base path we want to use, so it can properly
    build and recognize the URLs as the user browses the website, as we will see in
    the next section. Our first task will be to insert a base `href` statement within
    our `<HEAD>` element. Append the following line of code at the end of your code
    statement inside the `<head>` tag:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要告诉Angular我们想要使用的基本路径，这样它才能在用户浏览网站时正确构建和识别URL，正如我们将在下一节中看到的那样。我们的第一个任务将是在`<HEAD>`元素内插入一个基本`href`语句。在`<head>`标签内的代码语句的末尾添加以下代码行：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The base tag informs the browser about the path it should follow while attempting
    to load external resources, such as media or CSS files, once it goes deeper into
    the URL hierarchy.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 基础标签告诉浏览器在尝试加载外部资源（如媒体或CSS文件）时应该遵循的路径，一旦它深入到URL层次结构中。
- en: Importing and setting up the router module
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入和设置路由模块
- en: 'Now, we can start playing around with all the goodies existing in the router
    library. First things first, we need to import the `RouterModule`, we do this
    in the root module of our application. So, we open a file called `app.module.ts`
    and insert the following line at the top of the file:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始玩转路由库中存在的所有好东西。首先，我们需要导入`RouterModule`，我们在应用程序的根模块中执行此操作。因此，我们打开一个名为`app.module.ts`的文件，并在文件顶部插入以下行：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once we have done so, it's time to add the `RouterModule` as a dependency of
    the `AppModule` class.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们这样做了，就该将`RouterModule`添加为`AppModule`类的依赖项了。
- en: '`RouterModule` is a little bit of a different module, though; it needs to be
    initialized at the same time as it is added as a dependant module. It looks like
    the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouterModule`是一个有点不同的模块；它需要在添加为依赖模块的同时进行初始化。它看起来像这样：'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can see here that it points to variable routes that we have yet to define.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这里指向了我们尚未定义的变量路由。
- en: Defining the routes
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义路由
- en: 'The `routes` is a list of route entries that specifies what routes exist in
    the application and what components should respond to a specific route. It can
    look like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes`是一个路由条目列表，指定了应用程序中存在哪些路由以及哪些组件应该响应特定路由。它可以看起来像这样：'
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Every item in the route list is an object with a number of properties. The two
    most important properties are `path` and `component`. The path property is the
    routing path, note that you should specify the path value without a leading `/`.
    So, setting it to `products`, as with the preceding code, means that we define
    what would happen if the user navigates to `/products`. The `component` property
    points to the component that should respond to this route. The pointed-out components,
    template and data is what the user will see when navigating to the route.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 路由列表中的每个项目都是一个带有多个属性的对象。最重要的两个属性是`path`和`component`。path属性是路由路径，注意，您应该指定不带前导`/`的路径值。因此，将其设置为`products`，与前面的代码一样，意味着我们定义了用户导航到`/products`时会发生什么。`component`属性指向应该响应此路由的组件。指出的组件、模板和数据是用户在导航到该路由时将看到的内容。
- en: The first specified route defines the path `/products`, and the last route item
    specifies `**`, which means it matches any path. Order matters. Had we defined
    the route item `**` first, then `products` would never have been hit. The reason
    `**` was defined last was that we wanted a route that would take care of the case
    when a user enters an unknown route. Rather than showing the user a blank page,
    we can now show them a nice page defined by the `PageNotFound` components template.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个指定的路由定义了路径`/products`，最后一个路由项指定了`**`，这意味着它匹配任何路径。顺序很重要。如果我们首先定义了路由项`**`，那么`products`将永远不会被命中。最后定义`**`的原因是，我们希望有一个路由来处理用户输入未知路由的情况。现在，我们可以向用户展示一个由`PageNotFound`组件模板定义的漂亮页面，而不是向用户显示空白页面。
- en: There are a ton more properties you can define on a route item, and also more
    complex routes you can set up. This will suffice for now, so we gain a basic understanding
    of routing setup.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在路由项上定义更多属性，也可以设置更复杂的路由。现在这就够了，这样我们就可以对路由设置有一个基本的理解。
- en: Defining a viewport
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个视口
- en: 'Once we have come this far, it''s time to define a viewport where the routed
    content should be rendered. Normally, we would build an application where part
    of the content is static and part of it can be switched out, like so:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们走到这一步，就是定义一个视口，路由内容应该在其中呈现。通常，我们会构建一个应用程序，其中一部分内容是静态的，另一部分可以被切换，就像这样：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'At this point, we involve the `router-outlet` element. It is an element that
    tells the router that this is where you should render the content. Update your
    `app.component.html` to look like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们涉及`router-outlet`元素。这是一个告诉路由器这是你应该呈现内容的元素。更新您的`app.component.html`看起来像这样：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now we have the `router` module imported and initialized. We also have a router
    list defined for two routes, and we have defined where the routed content should
    be rendered. This is all we need for a minimal setup of the router. In the next
    section, we will look at a more realistic example and further expand our knowledge
    of the routing module and what it can help us with.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入并初始化了`router`模块。我们还为两个路由定义了一个路由列表，并且已经定义了路由内容应该呈现的位置。这就是我们建立路由器的最小设置所需的一切。在下一节中，我们将看一个更现实的例子，并进一步扩展我们对路由模块的了解以及它可以帮助我们的知识。
- en: Building a practical example – setting up the router service
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个实际的例子-设置路由服务
- en: 'Let''s describe the problem domain. Through the course of this book, we have
    been dealing with `Tasks` within the context of Pomodoro sessions. So far we have
    been creating all the components and other constructs that we needed in one big
    visual pile. It''s a visual pile in the sense that everything has been visible
    in one page. A more natural approach to this is to imagine that we have dedicated
    views that we navigate between. Here are the options from a user standpoint:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述一下问题领域。在本书的过程中，我们一直在处理番茄钟会话的上下文中的`任务`。到目前为止，我们一直在一个大的可视堆中创建所有需要的组件和其他构造。从用户的角度来看，更自然的方法是想象我们有专门的视图可以在之间导航。以下是用户的选择：
- en: The user reaches our app and checks the current listing of the pending tasks.
    The user can schedule the tasks to be done in order to get the required time estimation
    for the next Pomodoro session.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户到达我们的应用程序并检查待办任务的当前列表。用户可以安排任务按顺序完成，以获得下一个番茄钟会话所需的时间估计。
- en: If desired, the user can jump onto another page and see a create task form (we
    will create the form, but will not implement its editing features until the next
    chapter).
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，用户可以跳转到另一个页面并查看创建任务表单（我们将创建表单，但直到下一章才实现其编辑功能）。
- en: The user can choose any task at any time and begin the Pomodoro session required
    to accomplish it.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以随时选择任何任务并开始完成它所需的番茄钟会话。
- en: The user can move back and forth across the pages they have already visited.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以在已经访问过的页面之间来回移动。
- en: 'Let''s take the preceding user interactions and translate what this means in
    terms of different views that we should support:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面的用户交互，并翻译一下这意味着我们应该支持哪些不同的视图：
- en: There needs to be a page listing all the tasks
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要有一个列出所有任务的页面
- en: There should be a page with a create task form
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该有一个包含创建任务表单的页面
- en: Lastly, there should be a way to navigate back and forth between the pages
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，应该有一种方法在页面之间来回导航
- en: Building a new component for demonstration purposes
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为演示目的构建一个新组件
- en: So far, we have built two well-differentiated components we can leverage to
    deliver a multi-page navigation. But in order to provide a better user experience,
    we might need a third one. We will now introduce the form component we will be
    exploring more thoroughly in [Chapter 10](19502d3a-f6dd-4811-9a2f-5dcc82f3c03c.xhtml),
    *Forms in Angular*, as a way to have more navigation options in our example.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经构建了两个明确定义的组件，我们可以利用它们来提供多页面导航。但为了提供更好的用户体验，我们可能需要第三个。我们现在将介绍表单组件，我们将在[第10章](19502d3a-f6dd-4811-9a2f-5dcc82f3c03c.xhtml)中更详细地探讨，作为我们示例中更多导航选项的一种方式。
- en: 'We will create a component in our tasks feature folder, anticipating the form
    we will use in the next chapter to publish new tasks. Create the following files
    in the locations pointed out for each one:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在任务特性文件夹中创建一个组件，预期在下一章中使用该表单来发布新任务。在每个位置指出的位置创建以下文件：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is the most basic definition of a component. We need to expose this new
    component from our feature module. Finally, we need to enter the route item for
    this component in a route list and configure the routes. Add the following code
    snippet in the `app/tasks/task.module.ts` file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是组件的最基本定义。我们需要从我们的特性模块中公开这个新组件。最后，我们需要在路由列表中为这个组件输入路由项并配置路由。在`app/tasks/task.module.ts`文件中添加以下代码片段：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now the time has come to configure the routes. We do this in two steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候配置路由了。我们需要分两步完成：
- en: Creating the `routes.ts`, a module that contains our routes
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建包含我们路由的模块`routes.ts`
- en: Setting up the routes in the root module
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在根模块中设置路由
- en: 'The first order of business is defining the routes:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首要任务是定义路由：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The second order of business is initializing the routes. We do this in the
    root module. To initialize the routes, we need to call `RouteModule` and its static
    method,`forRoot`, and provide it with the routes list as an argument:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个任务是初始化路由。我们在根模块中完成这个任务。要初始化路由，我们需要调用`RouteModule`及其静态方法`forRoot`，并将路由列表作为参数提供给它：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Cleaning up the routes
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理路由
- en: At this point, we have set up the routes so they work the way they should. However,
    this approach doesn't scale so well. As your application grows, more and more
    routes will be added to the `routes.ts` file. Just like we moved the components
    and other constructs into their respective feature directory, so should we move
    the routes to where they belong. Our routing list so far consists of one route
    item belonging to the timer feature, two items to the task feature, and one route
    that points to the default route `/`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经设置了路由，使它们按照应该的方式工作。然而，这种方法并不那么容易扩展。随着应用程序的增长，将会有越来越多的路由添加到`routes.ts`文件中。就像我们将组件和其他结构移动到它们各自的特性目录中一样，我们也应该将路由移动到它们应该属于的地方。到目前为止，我们的路由列表包括一个属于计时器特性的路由项，两个属于任务特性的路由项，以及一个指向默认路由`/`的路由项。
- en: 'Our cleanup work will consist of:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的清理工作将包括：
- en: Creating one dedicated `routes.ts` file per feature directory
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个特性目录创建一个专用的`routes.ts`文件
- en: Calling `RouteModule.forChild` in each feature module that has routes
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个具有路由的特性模块中调用`RouteModule.forChild`
- en: Removing routes from any root module that isn't strictly application-wide, for
    example `** = route not found`
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从任何不严格适用于整个应用程序的根模块中删除路由，例如`** = route not found`
- en: 'This means that the application structure now looks something like the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着应用程序结构现在看起来像以下内容：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After the creation of a few more files, we are ready to initialize our feature
    routes. Essentially, the initialization is the same for both `/timer/routes.ts`
    as `/task/routes.ts`. For that reason, let''s look at one of the `routes.ts` files
    and the intended change:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一些文件后，我们准备初始化我们的功能路由。基本上，对于`/timer/routes.ts`和`/task/routes.ts`，初始化是相同的。因此，让我们看一下`routes.ts`文件和预期的更改：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The point here is that moving routes from `app/routes.ts` to `<feature>/routes.ts`
    means we set up the routes in their respective module file instead, namely `<feature>/<feature>.module.ts`.
    Also, we call `RouteModule.forChild`, and not `RouteModule.forRoot`, when setting
    up feature routes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重点是，将路由从`app/routes.ts`移动到`<feature>/routes.ts`意味着我们在各自的模块文件中设置路由，即`<feature>/<feature>.module.ts`。此外，当设置功能路由时，我们调用`RouteModule.forChild`，而不是`RouteModule.forRoot`。
- en: The router directives – RouterOutlet, RouterLink, and RouterLinkActive
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由指令 - RouterOutlet、RouterLink和RouterLinkActive
- en: 'We already mentioned in the *Adding support for the Angular router *section, that
    to set up a router there were some essential basic steps to make routing work.
    Let''s remind ourselves of what they were:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在*为Angular路由添加支持*部分提到，为了设置路由，有一些基本的必要步骤使路由工作。让我们回顾一下它们是什么：
- en: Define a routes list
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义路由列表
- en: Initialize the `Route` module
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化`Route`模块
- en: Add a viewport
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加视口
- en: For the intents and purposes of this practical example, we have done the top two items,
    what remains is to add the viewport. A directive handles the viewport for Angular;
    it is called the `RouterOutlet` and just needs to be placed in the template for
    the component that sets up routing. So essentially, by opening up `app.component.html`
    and adding `<router-outlet></router-outlet>`, we sort out the last bullet item
    on our list.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个实际示例的目的和目的，我们已经完成了前两项，剩下的是添加视口。一个指令处理Angular的视口；它被称为`RouterOutlet`，只需要放置在设置路由的组件模板中。因此，通过打开`app.component.html`并添加`<router-outlet></router-outlet>`，我们解决了列表上的最后一个项目。
- en: 'There is a lot more to routing, of course. One interesting thing, which is
    expected of every router, is the ability to generate clickable links given a defined
    route. The `routerLink` directive handles that for us and is used in the following
    way:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，路由还有很多内容。一个有趣的事情，这是每个路由器都期望的，就是能够在定义的路由给定的情况下生成可点击的链接。`routerLink`指令为我们处理这个，并且以以下方式使用：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `routerLink` points to the route path, note the leading slash. This will
    look up which route item is defined in our routes list that corresponds to the
    route path `/`. After some investigation in our code, we find a route item that
    looks like the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`routerLink`指向路由路径，注意前导斜杠。这将查找我们的路由列表中定义的与路由路径`/`对应的路由项。经过对我们的代码的一些调查，我们找到了一个看起来像下面这样的路由项：'
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Take extra notice here that when defining the route; we should not have a leading
    slash, but when creating a link with said route item and using the `routerLink`
    directive, we should have a trailing slash.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意在定义路由时，我们不应该有前导斜杠，但是在使用该路由项创建链接并使用`routerLink`指令时，我们应该有一个尾随斜杠。
- en: 'This has produced the following element:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了以下元素：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: That looks interesting, the key take away is that `href` is set to `/` and the
    class has been set to active.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很有趣，关键是`href`设置为`/`，类已设置为active。
- en: 'The last bit was interesting, why would the class be set to active? That''s
    what the `routerLinkActive="active"` does for us. It investigates whether the
    current route we are on corresponds to the `routerLink` element we are currently
    on. If so, it gets awarded the active CSS class. Consider the following markup:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分很有趣，为什么类会被设置为活动状态？这就是`routerLinkActive="active"`为我们做的。它调查当前路由是否与我们当前所在的`routerLink`元素相对应。如果是，它将被授予活动CSS类。考虑以下标记：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Only one of the elements will get the active class set. If the browser URL points
    to `/tasks`, it will be the second item, instead of the first. The fact that the
    active class is being added gives you, as developer, the opportunity to style
    the active menu element, because a menu is what we are creating by defining a
    list of links, such as the preceding code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个元素会被设置为活动类。如果浏览器的URL指向`/tasks`，那么它将是第二项，而不是第一项。添加活动类的事实给了你作为开发者的机会，可以为活动菜单元素设置样式，因为我们正在创建一个链接列表，就像前面的代码所定义的那样。
- en: Triggering routes imperatively
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令式地触发路由
- en: There are more ways to navigate than to click on an element that has the `routerLink`
    directive on it. We can handle navigation in code or imperatively, as it is also
    called. To do so, we need to inject a navigation service that has the capacity
    to navigate.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 导航的方式不仅仅是点击具有`routerLink`指令的元素。我们也可以通过代码或命令式地处理导航。为此，我们需要注入一个具有导航能力的导航服务。
- en: 'Let''s inject the navigation service, also called the `Router`, into a component:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将导航服务，也称为`Router`，注入到一个组件中：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, we set up a `goToTimer` method and associate that to the click
    event of the button. Inside of this method, we call `router.navigate()`, whichtakes
    an array. The first item in the array is our route; note the use of the trailing
    slash. That is how simple it can be to navigate imperatively.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们设置了一个`goToTimer`方法，并将其与按钮的点击事件关联起来。在这个方法中，我们调用了`router.navigate()`，它接受一个数组。数组中的第一项是我们的路由；请注意末尾斜杠的使用。这就是命令式导航的简单方式。
- en: Handling parameters
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理参数
- en: We have configured pretty basic paths in our routes so far, but what if we want
    to build dynamic paths with support for parameters or values created at runtime?
    Creating (and navigating to) URLs that load specific items from our data stores
    is a common action we need to address on a daily basis. For instance, we might
    need to provide a master-detail browsing functionality, so each generated URL
    living in the master page contains the identifiers required to load each item
    once the user reaches the detail page.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在路由中配置了相当基本的路径，但是如果我们想要构建支持在运行时创建参数或值的动态路径呢？创建（和导航到）从我们的数据存储中加载特定项目的URL是我们每天需要处理的常见操作。例如，我们可能需要提供主细节浏览功能，因此主页面中的每个生成的URL都包含在用户到达细节页面时加载每个项目所需的标识符。
- en: 'We are basically tackling a double trouble here: creating URLs with dynamic
    parameters at runtime, and parsing the value of such parameters. No problem; the
    Angular router has got our back and we will see how by using a real example.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上在这里解决了一个双重问题：在运行时创建具有动态参数的URL，并解析这些参数的值。没问题；Angular路由已经帮我们解决了这个问题，我们将通过一个真实的例子来看看。
- en: Building detail pages – using route parameters
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建详细页面 - 使用路由参数
- en: 'First, let''s get back to the tasks list component template. We have a router
    that takes us to that list of tasks, but what if we wanted to a look at specific
    task, and what if we wanted that task on a specific page? We can easily solve
    that by doing the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回到任务列表组件模板。我们有一个路由，可以带我们到任务列表，但是如果我们想要查看特定的任务，或者想要将任务显示在特定的页面上呢？我们可以通过以下方式轻松解决：
- en: Update the tasks component to add a navigation capability per item that lets
    us navigate to a task detail view.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新任务组件，为每个项目添加导航功能，让我们能够导航到任务详细视图。
- en: Set up routing for one task, the URL path to it will be `tasks/:id`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为一个任务设置路由，其URL路径将是`tasks/:id`。
- en: Create a `TaskDetail` component that shows just one task.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`TaskDetail`组件，只显示一个任务。
- en: 'Let''s start with the first bullet point: updating `tasks.component.ts`.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个要点开始：更新`tasks.component.ts`。
- en: 'It should be said that we can solve this in two ways:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 应该说的是，我们可以用两种方式解决这个问题：
- en: Navigate imperatively
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行命令式导航
- en: Build a route using `routerLink` that adds a parameter to the route
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`routerLink`构建一个带有参数的路由
- en: 'Let''s try to show how to navigate imperatively first:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先尝试展示如何进行命令式导航：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s highlight the following piece of code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们强调以下代码片段：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This produces a link that looks like `/tasks/13` or `/tasks/99`. In this case, `13`
    and `99` are just made-up numbers to show what the route path might look like.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生一个看起来像`/tasks/13`或`/tasks/99`的链接。在这种情况下，`13`和`99`只是编造的数字，用来展示路由路径可能是什么样子的。
- en: 'The second way of navigating is to use the `routerLink` directive. To accomplish
    this, our preceding template will look slightly different:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 导航的第二种方式是使用`routerLink`指令。为了实现这一点，我们的前面的模板将略有不同：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Both these ways work, just use the one that's best for you.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方式都可以，只需选择最适合你的方式。
- en: 'Now for the second item in the list, which is to set up routing, this will
    match the route path described previously. We open `task/routes.ts` and add the
    following entry to our list:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对于列表中的第二项，即设置路由，这将匹配先前描述的路由路径。我们打开`task/routes.ts`并向列表中添加以下条目：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With this route in place, we have the last item in our list to fix, which is
    defining the `TaskDetailComponent`. Let''s start with a simple version of it:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个路由，我们列表中的最后一项需要修复，即定义`TaskDetailComponent`。让我们从一个简单版本开始：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With all this in place, we are able to click a task in the list and navigate
    to a `TaskDetailComponent`. However, we are not satisfied here. The real reason
    for doing this was so we can do a more detailed lookup of a task. So, we are missing
    a data call from the `TaskDetail` component to our `TaskService`, where we ask
    for just one task. Remember how our route to `TaskDetail` was `/tasks/:id`? For
    us to make a correct call to our `TaskService`, we need to dig out the ID parameter
    from the route and use that as a parameter when calling our `TaskService`. If
    we route to `/tasks/13`, we need to call `TaskService` with a `getTask(13)` and
    expect one `Task` back.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一切，我们能够点击列表中的任务并导航到`TaskDetailComponent`。然而，我们在这里并不满意。这样做的真正原因是为了更详细地查找任务。因此，我们在`TaskDetail`组件中缺少一个数据调用到我们的`TaskService`，在那里我们要求只获取一个任务。记得我们到`TaskDetail`的路由是`/tasks/:id`吗？为了正确调用我们的`TaskService`，我们需要从路由中提取出ID参数，并在调用我们的`TaskService`时使用它作为参数。如果我们路由到`/tasks/13`，我们需要使用`getTask(13)`调用`TaskService`，并期望得到一个`Task`。
- en: 'So, we have two things to do:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有两件事要做：
- en: Dig out the router parameter ID from the route.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从路由中提取出路由参数ID。
- en: Add a `getTask(taskId)` method to `TaskService`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TaskService`中添加一个`getTask(taskId)`方法。
- en: 'To succeed with the first mission, we can inject something called `ActivatedRoute`
    and talk to its `params` property, which is an Observable. The data coming from
    that Observable is an object where one of the properties is our route parameter:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功完成第一个任务，我们可以注入一个叫做`ActivatedRoute`的东西，并与它的`params`属性交谈，这是一个Observable。来自该Observable的数据是一个对象，其中一个属性是我们的路由参数：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Okay, so this only solves half the problem. We are able to dig out the value
    of our ID parameter this way, but we don't do anything with it. We should be performing
    a data fetch as well.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这只解决了问题的一半。我们能够以这种方式提取出ID参数的值，但我们并没有对它做任何处理。我们也应该进行数据获取。
- en: 'If we add a `switchMap` statement, then we can get hold of the data, carry
    out a data call, and return the result of the data instead, like so:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加`switchMap`语句，那么我们可以获取数据，进行数据调用，并返回数据的结果，如下所示：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The last step is to add the `getTask` method to the `TaskService`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是向`TaskService`添加`getTask`方法：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Filtering your data – using query parameters
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤您的数据-使用查询参数
- en: 'So far we have been dealing with routing parameters on the format of `tasks/:id`.
    Links formed like that tell us that the context is tasks and to get to one particular
    task, we need to specify which one, by specifying its number. It''s about narrowing
    down to the specific data we are interested in. Query parameters have a different
    job, they aim to either sort your data or narrow down the size of your data set:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在处理`tasks/:id`格式的路由参数。像这样形成的链接告诉我们上下文是任务，并且要到达特定任务，我们需要指定其编号。这是关于缩小到我们感兴趣的特定数据的。查询参数有不同的作用，它们旨在对数据进行排序或缩小数据集的大小：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Query parameters are recognized as everything happening after the `?` character
    and are separated by an and (`&`) sign. To get to those values, we can work with
    the `ActivatedRoute`, just like we did with routing parameters but we look at
    a different collection on the `ActivatedRouter` instance:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 查询参数被识别为`?`字符之后发生的一切，并且由`&`符号分隔。要获取这些值，我们可以使用`ActivatedRoute`，就像我们处理路由参数一样，但是我们要查看`ActivatedRouter`实例上的不同集合：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Advanced features
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级功能
- en: 'So far we have covered basic routing, with route parameter as well as query
    parameters. The Angular router is quite capable though, and able to do much more,
    such as :'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了基本的路由，包括路由参数和查询参数。不过，Angular路由器非常强大，能够做更多的事情，比如：
- en: Defining child routes, every component can have their own viewport
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义子路由，每个组件都可以有自己的视口
- en: Relative navigation
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对导航
- en: Named outlets, the possibility to have different viewports in the same template
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名出口，同一个模板中可以有不同的视口
- en: Debugging, you can easily enable debugging to showcase how the routing works
    based on your routing list
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试，您可以轻松启用调试，展示基于您的路由列表的路由工作方式
- en: Child routes
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子路由
- en: 'What is a child route? A child route is a concept where we say that a route
    has children. We could write the routes for a feature like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是子路由？子路由是一个概念，我们说一个路由有子路由。我们可以像这样为一个功能编写路由：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'What happens, though, if we want to have a products container component and
    in that component, we would like to have a product list or a product detail showing?
    For that case, we want to group our routes differently. We have clearly said that
    the `Product` container is the parent component that you should route to. So,
    it would be the first responder when going to the route `/products`. Let''s start
    by setting up the `products` route. It should listen to `/products` URL and have
    the `ProductsContainerComponent` responding, like so:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想要有一个产品容器组件，并且在该组件中，我们想要显示产品列表或产品详细信息会发生什么？对于这种情况，我们希望以不同的方式分组我们的路由。我们已经明确表示`Product`容器是您应该路由到的父组件。因此，当转到路由`/products`时，它将是第一个响应者。让我们从设置`products`路由开始。它应该监听`/products`
    URL，并且有`ProductsContainerComponent`做出响应，如下所示：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Our other routes can be added as its children, like so:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的其他路由可以作为其子路由添加，如下所示：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, this might make more sense from an organizational viewpoint but there
    is a bit of a technical difference; the `ProductsContainer` will need to have
    its own `router-outlet` for this to work. So, a quick overview of our app so far
    would look like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从组织的角度来看，这可能更有意义，但在技术上有一些区别；`ProductsContainer`将需要有自己的`router-outlet`才能工作。因此，到目前为止，我们应用的快速概述如下：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The main driver for doing it this way is so that we can create a container
    to give that some header or footer information and render replaceable content,
    much like we can do with the template for the app component:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的主要原因是我们可以创建一个容器，为其提供一些页眉或页脚信息，并呈现可替换的内容，就像我们可以为应用程序组件的模板做的那样：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In summary the benefits to a container approach is the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，容器方法的好处如下：
- en: Creating child routes means we can treat a feature landing page like a page
    view or a viewport, thereby we can define things such as a header, a footer, and
    a part of the page as a piece of content that can be replaced
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建子路由意味着我们可以将功能着陆页视为页面视图或视口，因此我们可以定义诸如页眉、页脚和页面的一部分作为可以替换的内容
- en: We need to write less when defining the route path, the parent's route is already
    assumed
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在定义路由路径时，我们需要写得更少，因为父路由已经被假定
- en: Absolute versus relative navigation
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绝对导航与相对导航
- en: 'There are two ways to navigate: either we use absolute routes or relative routes.
    An absolute route is specifying its route all the way from the route root, such
    as `/products/2/orders`, whereas a relative route is aware of its context. A relative
    route might therefore look like `/orders`, given that it is aware of it already
    being at `/products/2`, so the full route would read as `/products/2/orders`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种导航方式：绝对路由和相对路由。绝对路由是从路由根目录指定其路由，例如`/products/2/orders`，而相对路由则知道其上下文。因此，相对路由可能看起来像`/orders`，因为它已经知道自己在`/products/2`，所以完整的路由将读作`/products/2/orders`。
- en: 'You might be fine using only absolute paths; there is an upside to using relative
    paths, though: it gets easier to refactor. Imagine moving a bunch of components
    around, and suddenly all your hardcoded paths points are wrong. You might argue
    that you should have created a typed version of the route, such as `routes.ProductList`,
    so that you only have to change in one place anyway. That might be so, and then
    you are in a good place. If, however, youdon''t employ those ways of working,
    relative routes are for you. So, let''s have a look at an example usage:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能只使用绝对路径就可以了；但是使用相对路径也有好处：重构变得更容易。想象一下移动一堆组件，突然所有硬编码的路径都是错误的。您可能会认为您应该创建路由的类型化版本，例如`routes.ProductList`，这样您只需要在一个地方进行更改。这可能是这样，那么您就处于一个良好的状态。然而，如果您不采用这些工作方式，那么相对路由就适合您。因此，让我们看一个示例用法：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here, we are going one level up. Imagine we are on `/products`. This would
    take us back to `/`. The important part here is to include the second parameter
    and specify the `relativeTo: this.route` bit.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们向上走了一级。想象一下，我们在`/products`。这会把我们带回到`/`。这里的重要部分是包括第二个参数并指定`relativeTo:
    this.route`部分。'
- en: Named outlets
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名出口
- en: 'We can have more that one outlet directive in a component template, if you
    just keep adding them, like so:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只是不断地添加它们，那么我们可以在组件模板中有多个出口指令。
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We will have the content rendered out four times. That''s not really why we
    add multiple outlets. We add more than one `router-outlet` so we can put different
    names on it. What is the business case for doing that, though? Imagine we wanted
    to show a header portion and a body portion; depending on what router portion
    we are on, these would differ. It can look like the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将内容呈现出四次。这并不是我们添加多个出口的真正原因。我们添加多个`router-outlet`是为了能够给它们取不同的名称。然而，这样做的商业案例是什么呢？想象一下，我们想要显示一个页眉部分和一个正文部分；根据我们所在的路由部分不同，它们会有所不同。它可能看起来像这样：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we are able to target a specific `router-outlet` when routing. So how
    do we:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们能够在路由时针对特定的`router-outlet`进行定位。那么我们该如何：
- en: Define a route that should target a specific named outlet?
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义应该定位到特定命名出口的路由？
- en: Navigate to a named outlet?
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到命名出口？
- en: Clear a named outlet?
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除命名的出口？
- en: 'The following code shows how we set up the route:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了我们如何设置路由：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding code shows how we set up a shell page, it''s called a shell as
    it acts like a shell for named outlets. That means our shell component looks like
    this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码显示了我们如何设置一个外壳页面，它被称为外壳，因为它充当了命名出口的外壳。这意味着我们的外壳组件看起来像这样：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We also set up two child routes pointing to one named outlet each. The idea
    is that when we route to `/tasks`, the `TaskHeaderComponent` will be rendered
    to the header outlet and the  `TaskComponent` will be rendered to the body outlet.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还设置了两个子路由，分别指向一个命名的出口。想法是当我们路由到`/tasks`时，`TaskHeaderComponent`将被渲染到头部出口，`TaskComponent`将被渲染到主体出口。
- en: 'There is an entirely different way of using routes, namely as pop-up outlets.
    This means we can render content to an outlet and also take it away. To accomplish
    this, we need to set up the route like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种完全不同的使用路由的方式，即作为弹出出口。这意味着我们可以将内容渲染到一个出口，然后再将其移走。为了实现这一点，我们需要设置路由如下：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This needs to go along with a named outlet being defined, like so:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要与一个命名的出口一起定义，就像这样：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Starting off by surfing to a page, this `PopupComponent` will not be visible,
    but we can make it visible by setting up a method wherein we navigate to it, like
    so:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先浏览到一个页面，这个`PopupComponent`将不可见，但我们可以通过设置一个方法来使其可见，比如这样：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The interesting part here is the argument to `router.navigate` being`{ outlets
    : { <name-of-named-outlet> : <name-of-route> } }`.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '这里有趣的部分是`router.navigate`的参数是`{ outlets : { <name-of-named-outlet> : <name-of-route>
    } }`。'
- en: 'With this kind of syntax, it becomes apparent that we can render anything in
    there as long as the route is correctly set up. So, let''s say the routing looked
    like this instead:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种语法，我们可以看到只要路由正确设置，就可以在其中渲染任何内容。所以，假设路由看起来像这样：
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, we have two candidates that could possibly be rendered at the `popup`
    outlet. To render the error component, simply write the following instead:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有两个可能被渲染到`popup`出口的候选者。要渲染错误组件，只需写入以下内容：
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'There is one final thing we need to cover, and that is how to remove the content
    of the named outlet. To do so, we amend the following to our component:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事情我们需要解决，那就是如何移除命名出口的内容。为此，我们需要修改我们的组件如下：
- en: '[PRE42]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We added the `closePopup()` method, and what we do inside of there is target
    our named `popup` outlet and provide it with a null argument, like so:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`closePopup()`方法，里面我们要做的是针对我们命名的`popup`出口并提供一个空参数，就像这样：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Debugging
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试
- en: 'Why do we want to debug the router? Well, sometimes the route doesn''t do what
    we think it should do; when that is the case, it is good to know more about how
    the routing acts and why. To enable debugging, you need to provide a configuration
    object that enables debugging, like so:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要调试路由？嗯，有时路由不会按我们的想法工作；在这种情况下，了解更多关于路由的行为和原因是很有帮助的。要启用调试，您需要提供一个启用调试的配置对象，就像这样：
- en: '[PRE44]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Attempting to route to, say, `/products` from our start page will look like
    this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试从我们的起始页面路由到，比如，`/products`将会是这样：
- en: '![](assets/96742ff5-3a12-4f7f-8ac7-a443481f356f.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/96742ff5-3a12-4f7f-8ac7-a443481f356f.png)'
- en: 'What we can see here is that several events are triggered:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这里触发了几个事件：
- en: '`NavigationStart`: When the navigation starts'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NavigationStart：导航开始时
- en: '`RoutesRecognized`: Parsing of the URL and recognizing the URL'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RoutesRecognized：解析URL并识别URL
- en: '`RouteConfigLoadStart`: Triggered when reading a lazy load configuration'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由配置加载开始：在读取延迟加载配置时触发
- en: '`RouteConfigLoadEnd`: After the route has been lazy loaded'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RouteConfigLoadEnd：路由已经延迟加载完成
- en: '`GuardsCheckStart`: Evaluating the router guard, that is, can we go to this
    route'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GuardsCheckStart：评估路由守卫，也就是说，我们能否前往这个路由
- en: '`GuardsCheckEnd`: Router guard check done'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GuardsCheckEnd：路由守卫检查完成
- en: '`ResolveStart`: Attempting to fetch data that we need before routing to a path'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResolveStart`: 尝试在路由到路径之前获取我们需要的数据'
- en: '`ResolveEnd`: Done resolving the data it was relying on'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResolveEnd`: 完成解析它所依赖的数据'
- en: '`NavigationCancel`: Someone or something canceled the routing'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NavigationCancel`: 有人或某物取消了路由'
- en: '`NavigationEnd`: Done routing'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NavigationEnd`: 完成路由'
- en: There are a lot of events that can happen. As you can see from the preceding
    image, our bullet list covers more events than the image showed. This is due to
    us not having any modules that are lazy loaded, so those events aren't triggered,
    and also that we haven't set up any resolve guards, for example. Also, `NavigationCancel`doesn't
    occur unless the routing fails for some reason. It's important what events are
    triggered and when, so that you know what part of the code might be wrong. We
    will look closely at the events, `GuardsCheckStart` and `GuardsCheckEnd`, in our
    next section on determining whether you are authorized to visit a specific route.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多可能发生的事件。正如您从前面的图像中所看到的，我们的项目列表涵盖的事件比图像显示的更多。这是因为我们没有任何懒加载的模块，因此这些事件不会被触发，而且我们也没有设置任何解析守卫，例如。此外，`NavigationCancel`只有在某种原因导致路由失败时才会发生。了解触发了哪些事件以及何时触发是很重要的，这样您就会知道代码的哪一部分可能出错。我们将在下一节中仔细研究事件`GuardsCheckStart`和`GuardsCheckEnd`，以确定您是否有权限访问特定路由。
- en: Fine-tuning our generated URLs with location strategies
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过位置策略微调我们生成的URL
- en: As you have seen, whenever the browser navigates to a path by command of a `routerLink`
    or as a result of the execution of the navigate method of the `Router` object,
    the URL showing up in the browser's location bar conforms to the standardized
    URLs we are used to seeing, but it is in fact a local URL. No call to the server
    is ever made. The fact that the URL shows off a natural structure is because of
    the `pushState` method of the HTML5 history API that is executed under the folds,
    and allows the navigation to add and modify the browser history in a transparent
    fashion.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，每当浏览器通过`routerLink`的命令或通过`Router`对象的navigate方法的执行导航到一个路径时，显示在浏览器位置栏中的URL符合我们习惯看到的标准化URL，但实际上是一个本地URL。从不会向服务器发出调用。URL显示自然结构的事实是由于HTML5历史API的`pushState`方法在幕后执行，并允许导航以透明的方式添加和修改浏览器历史记录。
- en: 'There are two main providers, both inherited from the `LocationStrategy` type,
    for representing and parsing state from the browser''s URL:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个主要的提供者，都是从`LocationStrategy`类型继承而来，用于表示和解析浏览器URL中的状态：
- en: '`PathLocationStrategy`: This is the strategy used by default by the location
    service, honoring the HTML5 `pushState` mode, yielding clean URLs with no hash-banged
    fragments (`example.com/foo/bar/baz`).'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PathLocationStrategy`: 这是位置服务默认使用的策略，遵循HTML5 `pushState`模式，产生没有哈希碎片的清晰URL（`example.com/foo/bar/baz`）。'
- en: '`HashLocationStrategy`: This strategy makes use of hash fragments to represent
    state in the browser URL (`example.com/#foo/bar/baz`).'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HashLocationStrategy`: 此策略利用哈希片段来表示浏览器URL中的状态（`example.com/#foo/bar/baz`）。'
- en: Regardless of the strategy chosen by default by the `Location` service, you
    can fall back to the old hashbang-based navigation by picking the `HashLocationStrategy`as
    the `LocationStrategy` type of choice.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 无论`Location`服务默认选择的策略是什么，您都可以通过选择`HashLocationStrategy`作为首选的`LocationStrategy`类型，回退到基于旧的哈希导航。
- en: In order to do so, go to `app.module.ts` and tell the router, from now on, any
    time the injector requires binding to the`LocationStrategy` type for representing
    or parsing state (which internally picks `PathLocationStrategy`), it should use
    not the default type, but use `HashLocationStrategy` instead.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，请转到`app.module.ts`并告诉路由器，从现在开始，每当注入器需要绑定到`LocationStrategy`类型以表示或解析状态（内部选择`PathLocationStrategy`），它应该不使用默认类型，而是使用`HashLocationStrategy`。
- en: 'You just need to provide a second argument in the `RouterModule.forRoot()` method
    and make sure the `useHash`is set to `true`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需要在`RouterModule.forRoot()`方法中提供第二个参数，并确保`useHash`设置为`true`：
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Securing the routes with AuthGuard and CanActivate hook
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AuthGuard和CanActivate hook来保护路由
- en: 'We can use `CanActivate` in two ways:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`CanActivate`有两种方式：
- en: Restricting access to data you need to be logged in for
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制需要登录的数据访问
- en: Restricting access to data you need to have the correct role for
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制需要具有正确角色的数据访问
- en: 'So essentially, it is about potentially both authentication and authorization.
    What we need to do to make this happen is:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这实质上涉及潜在的身份验证和授权。我们需要做的是：
- en: Create a service that needs to evaluate whether you have permission
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个需要评估您是否有权限的服务
- en: Add said service to the route definition
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将该服务添加到路由定义中
- en: 'This is just any service you create, but it needs to implement the `CanActivate`interface.
    So, let''s create it:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是您创建的任何服务，但它需要实现`CanActivate`接口。所以，让我们创建它：
- en: '[PRE46]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: What we have done is implement the `CanActivate` interface by declaring the `canActivate()`method.
    We also injected an `AuthService`instance that we pretend exists. The point is
    that the `canActivate()`method should return `true` if navigation should continue
    and `false` if it should be stopped.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是通过声明`canActivate()`方法来实现`CanActivate`接口。我们还注入了一个我们假装存在的`AuthService`实例。关键是`canActivate()`方法应该在导航应该继续时返回`true`，在应该停止时返回`false`。
- en: 'Now, on to the next step of adding this service to the routing config; we do
    that by adding to the list that the `canActivate` property holds:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，下一步是将此服务添加到路由配置；我们通过添加到`canActivate`属性保存的列表来实现：
- en: '[PRE47]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s try this out and see how our route debug changes if we return `true`
    from the`canActivate()` method, or `false`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下，看看如果我们从`canActivate()`方法返回`true`或`false`，我们的路由调试会发生什么变化：
- en: '![](assets/b77201f7-767c-4f22-8993-6d0f1152b53d.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b77201f7-767c-4f22-8993-6d0f1152b53d.png)'
- en: 'In `GuardsCheckEnd` we see that the `shouldActivate : true` property is emitted.
    This is because our `canActivate` method currently returns `true`, that is, we
    allow the routing to happen.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '在`GuardsCheckEnd`中，我们看到`shouldActivate: true`属性被发出。这是因为我们的`canActivate`方法当前返回`true`，也就是说，我们允许路由发生。'
- en: 'Let''s see what happens if we change `canActivate` to return `false`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们将`canActivate`更改为返回`false`会发生什么：
- en: '![](assets/78c39be8-e946-4454-8fe8-dd95aaa514fe.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/78c39be8-e946-4454-8fe8-dd95aaa514fe.png)'
- en: Here, we can see that in the `GuardsCheckEnd` event the `shouldActivate`now
    has the value `false`. We can also see that the `NavigationCancel`event has been
    emitted. The end result is that we weren't allowed to change route based on the `canActivate()` 
     method returning `false`. Now it is up to you to implement an authentication/authorization
    method and make it work for real.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到在`GuardsCheckEnd`事件中，`shouldActivate`现在的值为`false`。我们还可以看到发出了`NavigationCancel`事件。最终结果是，基于`canActivate()`方法返回`false`，我们不被允许改变路由。现在轮到您实现一个真正的身份验证/授权方法并使其真正起作用。
- en: Resolve<T> – fetching and resolving data before routing
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Resolve<T> - 在路由之前获取和解析数据
- en: The reason for using this hook is so we can delay the routing to happen after
    we have fetched all the necessary data. You should not have anything long-running
    happening though. A more real case is that you have navigated to a product route,
    such as `/products/114`, and want to look up in the database what that product
    is and provide that to the route.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此钩子的原因是，我们可以延迟路由发生，直到我们获取了所有必要的数据。但是，您不应该有任何长时间运行的操作。更真实的情况是，您已经导航到了一个产品路由，比如`/products/114`，并且想要在数据库中查找该产品并将其提供给路由。
- en: 'You''ll need the following to implement this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要以下内容来实现这一点：
- en: Implement the `Resolve<T>` interface
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`Resolve<T>`接口
- en: Return a `Promise` from the`resolve()` method
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`resolve()`方法返回一个`Promise`
- en: Set the service as a provider to the module
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将服务设置为模块的提供者
- en: Set the service in the resolve property of the route it is providing data to
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在提供数据的路由的resolve属性中设置服务
- en: 'Let''s implement said service:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现这个服务：
- en: '[PRE48]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: At this point, we have implemented the `Resolve<T>` interface and we also ensure
    that a `Promise` is returned from the `resolve()` method. We also have some logic
    saying we will redirect the user if the data we get back is not what we expect
    or if an error happens.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经实现了`Resolve<T>`接口，并确保从`resolve()`方法返回一个`Promise`。我们还有一些逻辑，如果我们得到的数据不是我们期望的，或者发生错误，我们将重定向用户。
- en: 'As a next step, we need to add the service to the `providers` keyword of our
    module:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，我们需要将服务添加到我们模块的`providers`关键字中：
- en: '[PRE49]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For the last step, we need to add the service to the route:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一步，我们需要将服务添加到路由中：
- en: '[PRE50]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The CanDeactivate – handling cancel and save
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CanDeactivate - 处理取消和保存
- en: 'Okay, so we have the following situation: the user is on a page, they have
    filled in a lot of data when they decide to press a navigation link that takes
    them away from the page. At this point, you, as a developer, want to establish
    the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们有以下情况：用户在一个页面上，他们填写了很多数据，然后决定按下一个导航链接离开页面。在这一点上，作为开发者，你想建立以下内容：
- en: If the user has filled in all data, they should then continue with navigation
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户填写了所有数据，他们应该继续导航
- en: If the user has not filled in all data, they should have the option of leaving
    the page anyway or remaining to complete the data entry
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户没有填写所有数据，他们应该有离开页面的选项，或者留下来继续填写数据
- en: 'To support these scenarios, we need to do the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这些情景，我们需要做以下事情：
- en: Create a service that implements the  `CanDeactivate` interface.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个实现`CanDeactivate`接口的服务。
- en: Inject the target component into the service.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目标组件注入到服务中。
- en: Set said service up as a provider to the module.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该服务设置为模块的提供者。
- en: Set service as `canDeactivate` responder in the route.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在路由中将服务设置为`canDeactivate`响应器。
- en: Make the target component injectable and set it up as a provider to the module.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使目标组件可注入，并将其设置为模块的提供者。
- en: Write logic to handle the case that all fields are filled in – keep routing,
    if fields are missing show a confirm that lets the user decide whether to continue
    to route away or not.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写逻辑来处理所有字段都填写的情况 - 如果字段缺失，则保持路由，如果字段缺失，则显示一个确认消息，让用户决定是否继续路由或不继续。
- en: 'Starting with the service, it should look like this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务开始，它应该是这样的：
- en: '[PRE51]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Worth highlighting here is how we define the logic in the `canDeactivate` method
    to have a return type that is either `Boolean` or a `Promise<boolean>`. This gives
    us the freedom to short circuit the method early if all valid fields are filled
    in. If they are not, we show the user a confirm message that freezes on the confirm
    until the user has decided what to do.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 值得强调的是，我们如何在`canDeactivate`方法中定义逻辑，使其返回类型要么是`Boolean`，要么是`Promise<boolean>`。这使我们有自由在所有有效字段都填写的情况下提前终止方法。如果没有，我们向用户显示一个确认消息，直到用户决定该做什么。
- en: 'The second step is telling the module about this service:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是告诉模块关于这个服务：
- en: '[PRE52]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, to perform a change in the route:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要改变路由：
- en: '[PRE53]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'For the next step, we are going to do something we don''t usually do, namely,
    set up the component as an injectable; this is needed so it can be injected into
    the service:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要做一些我们通常不做的事情，即将组件设置为可注入的；这是必要的，这样它才能被注入到服务中：
- en: '[PRE54]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This means we need to add the component as a provider in the module:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要将组件作为模块中的提供者添加：
- en: '[PRE55]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Async routing – improving response time
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步路由 - 提高响应时间
- en: Eventually, your application will grow in size and the amount of data you put
    into it will also grow. The net result of this is that the application takes a
    long time to start initially, or certain parts of your application take a long
    time to start. There are ways around this, such as lazy loading and preloading.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，您的应用程序将会变得越来越庞大，您放入其中的数据量也会增长。这样做的结果是，应用程序在初始启动时需要很长时间，或者应用程序的某些部分需要很长时间才能启动。有一些方法可以解决这个问题，比如懒加载和预加载。
- en: Lazy loading
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒加载
- en: Lazy loading means we don't start with all of the application loaded initially.
    Parts of our application can be cordoned off into chunks that are only loaded
    when you ask for them. Today, this is centered around routes, this means that
    if you ask for a specific route you have not visited before, the module and all
    its constructs will be loaded. This is not something that is there by default
    but something you can quite easily set up.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载意味着我们不会一开始就加载整个应用程序。我们的应用程序的部分可以被隔离成只有在需要时才加载的块。今天，这主要集中在路由上，这意味着如果您请求一个以前没有访问过的特定路由，那么该模块及其所有构造将被加载。这不是默认情况下存在的东西，但是您可以很容易地设置它。
- en: 'Let''s have a look at an existing module and its routes, and see how we can
    turn that into a lazy-loaded module. We will have to make changes in the following
    places :'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个现有模块及其路由，看看我们如何将其变成一个懒加载模块。我们将不得不在以下地方进行更改：
- en: The routes list for our feature module
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们特性模块的路由列表
- en: Add a route entry in our application routes, with a specific lazy-load syntax
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们应用程序的路由中添加一个路由条目，使用特定的懒加载语法
- en: Remove all references to the feature module in other modules
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除其他模块中对特性模块的所有引用
- en: 'First, a quick look at our feature modules routing list, prior to the change:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们快速查看一下我们特性模块在更改之前的路由列表：
- en: '[PRE56]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Our first order of business is to change the path for the first route entry
    from lazy to `''`, an empty string. It sounds a bit counterintuitive, but it has
    an explanation.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一项任务是将第一个路由条目的路径从lazy更改为`''`，一个空字符串。听起来有点违反直觉，但有一个解释。
- en: 'The second thing we do is to remedy the first thing; we need to add a lazy
    route entry to our app module routing, like so:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第二件事是纠正第一件事；我们需要在我们的应用程序模块路由中添加一个懒加载路由条目，就像这样：
- en: '[PRE57]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As you can see, we add the `loadChildren` property and this property expects
    a string as a value. This string value should point to where the module can be
    found, so essentially it looks like `<path to the module from the root>#<Module
    class name>`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们添加了`loadChildren`属性，该属性期望一个字符串作为值。这个字符串值应该指向模块的位置，因此它看起来像`<从根目录到模块的路径>#<模块类名>`。
- en: 'The last step is to remove all references to this module in other modules,
    for a very natural reason: if you haven''t navigated to `/lazy`, a service or
    component and so on doesn''t really exist yet, as its bundle hasn''t been loaded
    to the application.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是删除其他模块中对该模块的所有引用，原因很自然：如果您还没有导航到`/lazy`，那么服务或组件等实际上还不存在，因为它的捆绑包还没有加载到应用程序中。
- en: 'Finally, let''s have a look at what this looks like in the debug mode. The
    first image will show what it looked like before we navigated to our lazy module:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看这在调试模式下是什么样子。第一张图片将展示在我们导航到懒加载模块之前的样子：
- en: '![](assets/50f37b7f-b0af-49d7-8077-14dc222d1c25.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/50f37b7f-b0af-49d7-8077-14dc222d1c25.png)'
- en: 'Here, we have our normal bundles that our project setup produces. Let''s now
    navigate to our lazy route:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有我们项目设置生成的正常捆绑包。现在让我们导航到我们的懒加载路由：
- en: '![](assets/927c9c75-d6ec-4527-867d-f7e20f182797.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/927c9c75-d6ec-4527-867d-f7e20f182797.png)'
- en: We can see that a bundle has been added called `5.chunk.js`, and it contains
    our newly loaded module and all its constructs.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一个名为`5.chunk.js`的捆绑包已经被添加，它包含了我们新加载的模块及其所有构造。
- en: A little word of caution though, is to not place constructs in lazy-loaded modules
    that you think you will use elsewhere. Conversely, you can let your `lazy` module
    depend on services and constructs found in other modules, as long as those are
    not lazy loaded. A good practice is therefore, to make as many modules as possible
    lazy loaded but shared functionality can't be lazy loaded, for the above mentioned
    reason.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，需要小心的是，不要在想要在其他地方使用的延迟加载模块中放置构造。相反，你可以让你的`lazy`模块依赖于其他模块中的服务和构造，只要它们不是延迟加载的。因此，一个很好的做法是尽可能多地将模块延迟加载，但共享功能不能延迟加载，出于上述原因。
- en: CanLoad – don't lazy load unless the user has access
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CanLoad - 除非用户有权限，否则不要延迟加载
- en: Lazy loading is a great feature that can drastically reduce the loading time
    of your application by ensuring your application only starts with the bundles
    it absolutely needs. However, even if you ensure that most of your modules are
    lazy loaded, you need to take it a step further, especially if your application
    has any authentication or authorization mechanisms in place.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟加载是一个很棒的功能，可以通过确保应用程序只启动绝对需要的捆绑包来大大减少加载时间。然而，即使你确保大多数模块都是延迟加载的，你需要更进一步，特别是如果你的应用程序有任何身份验证或授权机制。
- en: 'Consider the following, let us say that more than one of your modules needs
    the user to be authenticated or to have the role of admin. It would make no sense
    to load those modules when a user routes to their path if they are not allowed
    in that area anyway. To remedy this scenario, we can use a guard called `CanLoad`.
    `CanLoad` ensures we first validate whether it makes sense to lazy load a certain
    module based on a condition. You need to do the following to use this:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下情况，假设你的多个模块需要用户进行身份验证或具有管理员角色。如果用户在这些区域不被允许，那么当用户路由到它们的路径时加载这些模块是没有意义的。为了解决这种情况，我们可以使用一个叫做`CanLoad`的守卫。`CanLoad`确保我们首先验证是否根据条件延迟加载某个模块是有意义的。你需要做以下事情来使用它：
- en: Implement the `CanLoad` interface and the `canLoad()` method, in a service.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务中实现`CanLoad`接口和`canLoad()`方法。
- en: Add the preceding service to the `CanLoad` property of your route.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前述服务添加到路由的`CanLoad`属性中。
- en: 'The following creates a service that implements the `CanLoad` interface:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 以下创建了一个实现`CanLoad`接口的服务：
- en: '[PRE58]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see from the code, the `canLoad()`method returns a Boolean. In this
    case, we have made it return `false`, which means the module will not be loaded.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码中可以看出，`canLoad()`方法返回一个布尔值。在这种情况下，我们让它返回`false`，这意味着模块不会被加载。
- en: 'The second thing we needed to do was to update the route to use this service
    as a `canLoad` guard:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第二件事是更新路由以使用这个服务作为`canLoad`守卫：
- en: '[PRE59]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If we attempt to surf to `localhost:4200/lazy`, we go nowhere as our `canLoad`,
    by returning `false`, tells us that we can''t. Having a look at our console, we
    also see the following:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试浏览到`localhost:4200/lazy`，我们无法前往，因为我们的`canLoad`通过返回`false`告诉我们不能。查看控制台，我们还看到以下内容：
- en: '![](assets/43f0e34b-fe70-4ef0-a1a8-255074bce43c.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/43f0e34b-fe70-4ef0-a1a8-255074bce43c.png)'
- en: Here, it says it cannot load children due to the guard, so the guard is working.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，它说由于守卫，无法加载子级，所以守卫起作用。
- en: Notice how everything works fine and loads like it should when you update the `CanLoadService` and `canLoad()`method
    to return `true`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 注意当你更新`CanLoadService`和`canLoad()`方法来返回`true`时，一切都像应该的那样正常加载。
- en: Don't forget to add `CanLoadService` to the providers array of the root module.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将`CanLoadService`添加到根模块的providers数组中。
- en: Preloading
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预加载
- en: 'So far, we have been discussing eager loading and lazy loading. Eager loading,
    in this case, has meant that we load the entire application at once. Lazy loading
    has been about us identifying certain modules as modules that we only load on
    demand, that is, they are lazy loaded. There is, however, something in between:
    preloaded modules. Why do we need something in between, though? Well, imagine
    that we know with a good certainty that a normal user will want to access the
    products module within 30 seconds after logging in. It makes sense to mark the
    products module as a module that should be lazy loaded. It would be even better
    if it could be loaded in the background right after login so that it is ready
    to go when the user navigates to it. That is exactly what preloading does for
    us.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在讨论急加载和懒加载。在这种情况下，急加载意味着我们一次性加载整个应用程序。懒加载是指我们将某些模块标识为只在需要时加载的模块，也就是说，它们是懒加载的。然而，在这两者之间还有一些东西：预加载模块。但是，为什么我们需要介于两者之间的东西呢？嗯，想象一下，我们可以非常肯定地知道，普通用户在登录后30秒内会想要访问产品模块。将产品模块标记为应该懒加载的模块是有道理的。如果它可以在登录后立即在后台加载，那么当用户导航到它时，它就已经准备好了。这正是预加载为我们做的事情。
- en: 'We enable preloading by issuing the following command:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过发出以下命令来启用预加载：
- en: '[PRE60]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This `PreloadAllModules` value preloads each and every lazy-loaded route, except
    for the ones guarded by the `canLoad`guard. This makes sense: the `canLoad` only
    loads if we are authenticated/authorized, or based on some other condition that
    we set up.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`PreloadAllModules`值预加载每个懒加载的路由，除了那些由`canLoad`守卫保护的路由。这是有道理的：`canLoad`只有在我们经过身份验证/授权或者基于我们设置的其他条件时才加载。'
- en: 'So, if we had a bunch of modules that were all set up as lazy, such as products,
    admin, categories, and so on, all of those would be loaded right after the initial
    boot based on `PreloadAllModules`. That might be good enough on a desktop. However,
    if you are on a mobile connection such as 3G, this might be way too heavy. At
    this point, we want better, more fine-grained control. What we can do is implement
    our own custom strategy for this. We need to do the following to do that:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们有一堆模块都被设置为懒加载，比如产品、管理员、类别等等，所有这些模块都会根据`PreloadAllModules`在初始启动后立即加载。这在桌面上可能已经足够了。然而，如果你使用的是3G等移动连接，这可能会太重了。在这一点上，我们需要更好、更精细的控制。我们可以实现自己的自定义策略来做到这一点。我们需要做以下几件事来实现这一点：
- en: Create a service that implements `PreloadingStrategy` and the `preload` method.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个实现`PreloadingStrategy`和`preload`方法的服务。
- en: The `preload()` method must call the`load()` method, if it should be preloaded,
    or should return an empty Observable otherwise.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果应该预加载，`preload()`方法必须调用`load()`方法，否则应该返回一个空的Observable。
- en: Define whether a route should be preloaded, by using the data attributed on
    a route, or by using a service.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在路由上使用数据属性或使用服务来定义路由是否应该预加载。
- en: Set the create strategy service as the value of `preloadingStrategy`.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将创建策略服务设置为`preloadingStrategy`的值。
- en: 'For the first order of business, defining our service, we create it like this:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义我们的服务，我们可以这样创建它：
- en: '[PRE61]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We can see how we invoke the load method if our `route.data` contains the preload
    Boolean.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，如果我们的`route.data`包含预加载布尔值，我们会调用load方法。
- en: 'Now, for setting up the route correctly:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了正确设置路由：
- en: '[PRE62]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The data property has been set to an object containing our `preload` property.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 数据属性已设置为包含我们的`preload`属性的对象。
- en: 'Now for the last step. Let''s make the `RouterModule.forRoot()` aware that
    this service exists:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是最后一步。让我们让`RouterModule.forRoot()`意识到这个服务的存在：
- en: '[PRE63]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In short, this is a very efficient way of ensuring the user has the best possible
    experience without succumbing to either eager loading, or having to wait for a
    lazy load.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这是一种非常有效的方式，可以确保用户在不陷入急切加载或等待懒加载的情况下获得最佳体验。
- en: Summary
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have now uncovered the power of the Angular router and we hope you have enjoyed
    the journey into the intricacies of this library. One of the things that definitely
    shines in the Router module is the vast number of options and scenarios we can
    cover with such a simple but powerful implementation.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经揭示了 Angular 路由器的强大功能，希望您喜欢探索这个库的复杂性。在路由器模块中，绝对闪亮的一点是我们可以通过简单而强大的实现涵盖大量选项和场景。
- en: We have learned the basics of setting up routing and handling different types
    of parameters. We have also learned more advanced feature such as child routing.
    Furthermore, we have learned how to protect our routes from unauthorized access.
    Finally, we have shown the full power of async routing and how you can really
    improve response time with lazy loading and preloading.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了设置路由和处理不同类型参数的基础知识。我们还学习了更高级的功能，比如子路由。此外，我们还学习了如何保护我们的路由免受未经授权的访问。最后，我们展示了异步路由的全部功能，以及如何通过延迟加载和预加载来真正提高响应时间。
- en: In the next chapter, we will beef up our task-editing component to showcase
    the mechanisms underlying web forms in Angular and the best strategies to grab
    users' input with form controls.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将加强我们的任务编辑组件，展示 Angular 中 Web 表单的基本原理以及使用表单控件获取用户输入的最佳策略。
