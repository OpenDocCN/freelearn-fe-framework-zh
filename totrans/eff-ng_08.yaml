- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Handling Application State with Grace
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以优雅的方式处理应用状态
- en: In this chapter, you’ll learn about application state. Understanding and handling
    the state of your application is one of the most essential parts of frontend development.
    If the state of your applications becomes messy, entangled, and hard to understand,
    your development process and the quality of your application will suffer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解应用状态。理解和处理应用状态是前端开发中最基本的部分之一。如果应用的状态变得混乱、纠缠且难以理解，你的开发过程和应用的品质都将受到影响。
- en: To help you better manage your application state, we will talk about the different
    state levels you’ll find within your applications. You will learn how to partition
    and divide your state for maximum efficiency. You will also create a state management
    solution using RxJS and Signals and build a facade service to access your state
    from the component layer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你更好地管理应用状态，我们将讨论你将在应用中找到的不同状态层级。你将学习如何划分和分割你的状态以实现最大效率。你还将创建一个使用RxJS和Signals的状态管理解决方案，并构建一个外观服务以从组件层访问状态。
- en: Next, you will learn how to handle more complex states with the NgRx library.
    NgRx is the most commonly used state management library within the Angular community
    and uses the Redux pattern to manage state. Since the introduction of Angular
    Signals, NgRx also provides different approaches to working with Signals while
    using the tools we love from NgRx.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何使用NgRx库处理更复杂的状态。NgRx是Angular社区中最常用的状态管理库，它使用Redux模式来管理状态。自从Angular
    Signals引入以来，NgRx也提供了不同的方法来使用Signals，同时使用我们喜爱的NgRx工具。
- en: By the end of this chapter, you will have implemented state management solutions
    using different methods. You’ll have learned how easy it is to change your state
    management solution when using a facade service and seen how Angular Signals has
    changed the way we handle state within Angular applications.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将使用不同的方法实现了状态管理解决方案。你将了解到在使用外观服务时更改状态管理解决方案是多么容易，并看到Angular Signals如何改变了我们在Angular应用中处理状态的方式。
- en: 'This chapter will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding application state
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解应用状态
- en: Handling global application state using RxJS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RxJS处理全局应用状态
- en: Handling global application state using Signals
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Signals处理全局应用状态
- en: Handling global application state with NgRx
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NgRx处理全局应用状态
- en: Understanding application state
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解应用状态
- en: In simple terms, **application state** is a snapshot of the current condition
    (or state) of your data, configurations, and views at a specific point in time.
    Application state is the sum of all actions that are performed within your application
    from the moment it is loaded in the browser. The state is a dynamic landscape
    that influences your application’s view, user interactions, data flow, and overall
    functionality.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，**应用状态**是在特定时间点你的数据、配置和视图当前条件（或状态）的快照。应用状态是从浏览器加载应用的那一刻起，在应用中执行的所有动作的总和。状态是一个动态的景观，它影响着应用视图、用户交互、数据流和整体功能。
- en: It’s essential to have good state management within your application so that
    all your components can display the correct data to the end user and you have
    accurate data to work with within your application code. Good state management
    prevents unintended data changes, resulting in incorrect views and operations
    being performed within your application code that you did not intend to perform.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用中拥有良好的状态管理至关重要，这样所有组件都能向最终用户显示正确的数据，你也能在应用代码中有准确的数据进行操作。良好的状态管理可以防止意外的数据更改，从而避免在应用代码中执行你未打算执行的不正确视图和操作。
- en: Now that you have an idea of what application state is and why you need it,
    let’s dive deeper, starting with the different levels of application state.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了应用状态是什么以及为什么你需要它，那么让我们更深入地探讨，从应用状态的不同层级开始。
- en: Different levels of application state
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用状态的层级
- en: 'In the realm of frontend development, we can distinguish between two levels
    of state: global and local state. In this section, we’ll delve into the nuanced
    distinction between global and local application states within the context of
    Angular, shedding light on their roles in crafting robust and maintainable frontend
    applications.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端开发的领域，我们可以区分两个层面的状态：全局状态和局部状态。在本节中，我们将深入探讨Angular上下文中全局和局部应用状态之间的细微差别，阐明它们在构建健壮和可维护的前端应用中的作用。
- en: As their names imply, **local state** is localized to a file, component, or
    element within your application, whereas **global state** is shared through your
    entire application. The global application state serves as the central repository
    for shared information across various components, ensuring coherence and synchronicity
    in the application’s behavior. On the other hand, the local application state
    encapsulates the internal data and configuration specific to individual Angular
    components and services.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如它们的名称所暗示的，**局部状态**是局部化到文件、组件或应用程序中的元素，而**全局状态**是通过整个应用程序共享的。全局应用程序状态作为共享信息在各个组件之间的中央存储库，确保应用程序行为的一致性和同步性。另一方面，局部应用程序状态封装了特定于单个Angular组件和服务的内部数据和配置。
- en: By understanding the dual nature of global and local states, your Angular applications
    can strike a harmonious balance between reusability, encapsulation, and shared
    data integrity. Let’s start by diving a bit deeper into the local application
    state within Angular applications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解全局和局部状态的二重性，你的Angular应用程序可以在可重用性、封装性和共享数据完整性之间达到和谐的平衡。让我们先深入了解一下Angular应用程序中的局部应用程序状态。
- en: Local application state
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 局部应用程序状态
- en: When we refer to local state, we’re talking about properties that have been
    localized to a component or service that determine how that component or service
    behaves and presents data to your application’s user.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提到局部状态时，我们指的是那些被局部化到组件或服务中的属性，这些属性决定了该组件或服务如何行为以及如何向应用程序的用户展示数据。
- en: 'A simple example of a local state would be a `Counter` component with a `count`
    state:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个局部状态的简单例子是一个具有`count`状态的`Counter`组件：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `count` property is used to display the current count to the user. The declaration
    and update behavior of the `count` property is handled locally within the current
    component.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`属性用于向用户显示当前计数。`count`属性的声明和更新行为在当前组件内部处理。'
- en: Within components, you can consider the state as local when the stateful property
    isn’t shared between multiple smart components and doesn’t need to be persisted
    when you navigate from one page to another.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件内部，你可以将状态视为局部状态，当状态属性不是在多个智能组件之间共享，并且在你从一个页面导航到另一个页面时不需要持久化时。
- en: Within services, the state can be considered local whenever it entails a private
    property that isn’t shared with the outside world, and the property doesn’t have
    to persist longer than the life cycle of the service file. If the property doesn’t
    meet these criteria, you probably need to locate it somewhere within your global
    application state.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务内部，当状态涉及一个不与外界共享的私有属性，并且该属性不需要比服务文件的生命周期更长的时间来持久化时，可以将其视为局部状态。如果属性不符合这些标准，你可能需要将其定位在全局应用程序状态中的某个位置。
- en: 'Here are some common examples of local state within Angular applications:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些Angular应用程序中局部状态的常见例子：
- en: Disabled button state
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用按钮状态
- en: Form validity state
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形式有效性状态
- en: Modal visibility
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模态可见性
- en: Sorting and filtering
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序和过滤
- en: Accordion state
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手风琴状态
- en: Selected tab state
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选定的标签页状态
- en: You now have a good understanding of local state. You know what local state
    is, how you can recognize it, and what the preferred tool is to handle local state
    within your Angular applications. You also learned about some common examples
    of local state. Next, you will learn about global application state.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在对局部状态有了很好的理解。你知道什么是局部状态，如何识别它，以及处理Angular应用程序中局部状态的首选工具是什么。你还了解了一些局部状态的常见例子。接下来，你将学习关于全局应用程序状态的内容。
- en: Global application state
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局应用程序状态
- en: In contrast to local state, global application state refers to the data and
    configurations you share across multiple components and services within an Angular
    application. You can think of your global application state as a centralized repository
    for your data. This centralized repository of information is pivotal in ensuring
    consistency, synchronization, and efficient communication between various application
    parts.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与局部状态相对，全局应用程序状态指的是在Angular应用程序中跨多个组件和服务共享的数据和配置。你可以将你的全局应用程序状态视为一个数据集中式存储库。这个信息集中式存储库对于确保应用程序各个部分之间的一致性、同步性和高效通信至关重要。
- en: Unlike local state, which is confined to a specific component or service, global
    application state persists throughout the entire application, making it particularly
    useful for scenarios where data needs to be shared and synchronized across different
    components and services, as well as during the whole user session.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与局限于特定组件或服务的局部状态不同，全局应用状态在整个应用程序中持续存在，这使得它在需要在不同组件和服务之间共享和同步数据，以及在整个用户会话期间特别有用。
- en: Within Angular application, global state is commonly handled inside services.
    By creating a service dedicated to managing global state, developers can ensure
    that components have a centralized access point to crucial information. Services
    that contain global application state are often named *stores*. For example, you
    can call the service to store global user state `user.store.ts` with a `UserStore`
    class.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular应用程序中，全局状态通常在服务中处理。通过创建一个专门用于管理全局状态的服务，开发者可以确保组件有一个集中的访问点来获取关键信息。包含全局应用状态的服务通常被称为*存储*。例如，您可以使用名为`UserStore`的类调用服务来存储全局用户状态`user.store.ts`。
- en: Within smaller Angular applications, state is commonly managed using `Subjects`.
    More specifically, `BehaviorSubject` stores and distributes stateful properties,
    and the regular `Subject` distributes global events. With the introduction of
    Signals, some `BehaviorSubject` classes can be replaced with Signals. We will
    see this in detail in the *Handling global application state using RxJS* section
    when we start building global state management.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在较小的Angular应用程序中，状态通常使用`Subjects`进行管理。更具体地说，`BehaviorSubject`存储和分发状态属性，而常规的`Subject`分发全局事件。随着Signals的引入，一些`BehaviorSubject`类可以被Signals替换。我们将在开始构建全局状态管理时，在*使用RxJS处理全局应用状态*部分详细看到这一点。
- en: For larger Angular applications, libraries such as NgRx, NgXs, Akita, and Angular
    Query are the preferred methods for handling global state. These libraries enhance
    your capabilities to manage the states gracefully and implement structured and
    battle-tested design patterns for managing and updating the global state in a
    predictable and scalable manner.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较大的Angular应用程序，NgRx、NgXs、Akita和Angular Query等库是处理全局状态的首选方法。这些库增强了您优雅地管理状态的能力，并实现了结构化和经过实战检验的设计模式，以可预测和可扩展的方式管理和更新全局状态。
- en: Understanding when to utilize the global application state is crucial. A global
    state might be more appropriate if a stateful property needs to be shared across
    multiple smart components or persists beyond a single component’s life cycle.
    Now that you know what local and global state are, when to use which, and what
    tools are available to manage both gracefully, let’s learn about some important
    concepts within state management.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 理解何时利用全局应用状态至关重要。如果需要将状态属性在多个智能组件之间共享或超出单个组件的生命周期，则全局状态可能更为合适。现在您已经了解了局部和全局状态是什么，何时使用哪一个，以及有哪些工具可以优雅地管理它们，让我们来学习一些状态管理中的重要概念。
- en: Fundamental concepts within state management
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态管理中的基本概念
- en: To build a robust state management system within your Angular applications,
    you need to understand the fundamental concepts of state management. You need
    to know these concepts, why they are essential, and the dangers of not using them.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的Angular应用程序中构建一个健壮的状态管理系统，您需要了解状态管理的基本概念。您需要知道这些概念，为什么它们是必要的，以及不使用它们的危险。
- en: In this section, we will learn about unidirectional data flow, immutability,
    and side effects. Other important fundamentals for state management include reactivity
    and design patterns such as the Redux pattern, but we already discussed both in
    *Chapters 6* and *7*, so we won’t dive deeper into this.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习单向数据流、不可变性和副作用。状态管理的一些其他重要基础包括响应性和设计模式，如Redux模式，但我们已经在第6章和第7章中讨论过，所以我们将不会深入探讨这一点。
- en: Unidirectional data flow
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单向数据流
- en: '**Unidirectional data flow** is the first concept of state management we will
    discuss. As its name suggests, the concept states that data should only flow in
    one direction throughout your application. Changes to the data occur through well-defined
    actions or events, ensuring a clear and predictable flow of information. Unidirectional
    data flow simplifies debugging, makes code more predictable, and enhances maintainability.
    It prevents unexpected side effects by enforcing a clear flow of data through
    the application.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**单向数据流**是我们将要讨论的第一个状态管理概念。正如其名称所暗示的，这个概念表明数据应该在整个应用程序中单向流动。数据的变化通过定义良好的动作或事件发生，确保信息流清晰且可预测。单向数据流简化了调试，使代码更可预测，并提高了可维护性。它通过强制应用程序中的数据清晰流动来防止意外的副作用。'
- en: Without unidirectional data flow, tracing the origin of state changes becomes
    challenging, leading to debugging difficulties and potential issues with data
    consistency. Uncontrolled data flow can result in unpredictable behavior, especially
    in large and complex applications.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 没有单向数据流，追踪状态变化的原因会变得具有挑战性，导致调试困难以及数据一致性的潜在问题。不受控制的数据流可能导致不可预测的行为，尤其是在大型和复杂的应用程序中。
- en: The concept of unidirectional data flow is important throughout your entire
    application and for both local and global application state. For the global application
    state, I recommend always having a unidirectional data flow. Within the local
    component state, you can sometimes make an exception by using Angular two-way
    data binding.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 单向数据流的概念在整个应用程序中都很重要，无论是局部还是全局应用程序状态。对于全局应用程序状态，我建议始终使用单向数据流。在局部组件状态中，有时你可以通过使用Angular双向数据绑定来做出例外。
- en: 'To help you understand how unidirectional data flow looks in an Angular application,
    here’s an example of flow:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你理解单向数据流在Angular应用程序中的样子，这里有一个流示例：
- en: The state is passed from the store to the facade service.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态从存储传递到外观服务。
- en: The state is passed from the facade service to the smart component.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态从外观服务传递到智能组件。
- en: The smart component passes the data to the (dumb) child components.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 智能组件将数据传递给（无状态的）子组件。
- en: The view is rendered based on the state of the smart component and its child
    components.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图根据智能组件及其子组件的状态进行渲染。
- en: An action can be triggered in the view.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图中可以触发一个动作。
- en: The event of the action and the related data move from the (dumb) child component
    up to the smart component.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动作的事件和相关信息从（无状态的）子组件向上移动到智能组件。
- en: The smart component or facade dispatches an action to the store.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 智能组件或外观向存储派发一个动作。
- en: The store updates the state based on the dispatched action.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储根据派发的动作更新状态。
- en: The state is passed from the store to the facade.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态从存储传递到外观。
- en: As you can see, the data starts in the store and flows in one direction until
    the view can be rendered. When the user triggers an action within the view, the
    data flows in one direction and in a predictable manner back into the store until
    we reach full circle. Now that you know what unidirectional data flow is and why
    it’s important in state management, let’s learn about immutability.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，数据从存储开始，单向流动直到视图可以被渲染。当用户在视图中触发一个动作时，数据会以单向和可预测的方式流回存储，直到形成一个完整的循环。现在你已经了解了单向数据流是什么以及为什么它在状态管理中很重要，让我们来学习不可变性的概念。
- en: Immutability
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变性
- en: '**Immutability** involves the practice of not modifying existing data structures
    directly. Instead, new copies are created with the desired changes, preserving
    the integrity of the original data. Immutability simplifies state management by
    providing a single place to mutate your state. It helps prevent unintended state
    changes and side effects and is particularly valuable when you’re tracking and
    managing complex state in Angular applications.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可变性**涉及不直接修改现有数据结构的实践。相反，会创建带有所需更改的新副本，以保持原始数据的完整性。不可变性通过提供一个单一的位置来修改你的状态，简化了状态管理。它有助于防止意外的状态更改和副作用，在跟踪和管理Angular应用程序中的复杂状态时尤其有价值。'
- en: With immutability, you may find it easier to track state changes and keep your
    state synchronized. Directly modifying state objects can lead to bugs and unexpected
    behavior. Immutability was mainly used within global state management, but with
    the introduction of Signals, it’s now also applied within the local state of Angular
    applications.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过不可变性，你可能发现跟踪状态变化和保持状态同步更容易。直接修改状态对象可能导致错误和意外的行为。不可变性主要在全局状态管理中使用，但随着Signals的引入，现在它也应用于Angular应用程序的本地状态。
- en: Side effects
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 副作用
- en: '**Side effects** refer to an operation or changes you perform when a specific
    piece of your state changes. Side effects can include things such as the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**副作用**指的是当你的状态中的某个特定部分发生变化时，你执行的操作或更改。副作用可能包括以下内容：'
- en: Fetching data
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取数据
- en: Updating the local storage
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新本地存储
- en: Dispatching additional actions
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发额外的动作
- en: Setting local variables
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置局部变量
- en: By isolating side effects, you can maintain a clear separation of concerns in
    your application. The core application logic (reducers, actions, and selectors)
    remains focused on state changes, while side effects are handled separately. Side
    effects are natively introduced in the Angular framework within the Signals API,
    and they are used in popular state management libraries such as NgRx and NgXs.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过隔离副作用，你可以在你的应用程序中保持关注点的清晰分离。核心应用程序逻辑（reducers、actions和selectors）专注于状态变化，而副作用则单独处理。副作用在Angular框架的Signals
    API中自然引入，并在像NgRx和NgXs这样的流行状态管理库中使用。
- en: So, to summarize, there is local and global state within your applications.
    Local state is localized to components or services, whereas global state affects
    the entire application. Some of the fundamental concepts of state management are
    unidirectional data flow, immutability, and side effects. You learned about the
    advantages of these concepts and why they are important for a state management
    solution. You also learned what state management is and why you need it within
    your applications.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，在你的应用程序中存在本地和全局状态。本地状态局限于组件或服务，而全局状态影响整个应用程序。状态管理的一些基本概念包括单向数据流、不可变性和副作用。你了解了这些概念的优势以及为什么它们对于状态管理解决方案很重要。你还了解了状态管理是什么以及为什么你需要在应用程序中使用它。
- en: In the next section, you will start building a global state management solution
    and create a facade service to access the state from within your smart components.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将开始构建一个全局状态管理解决方案，并创建一个门面服务以从你的智能组件内部访问状态。
- en: Handling global application state using RxJS
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RxJS处理全局应用程序状态
- en: In this section, you will create a simple state management solution using RxJS.
    At the core of this state management solution lies the RxJS `BehaviorSubject`
    class. You will also create a facade service to interact with the state management
    solution.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将创建一个简单的状态管理解决方案，使用RxJS。这个状态管理解决方案的核心是RxJS的`BehaviorSubject`类。你还将创建一个门面服务以与状态管理解决方案交互。
- en: The facade will do all the communication with the state management solution
    and the smart components. This decouples our smart components from the state management
    solution, making it easy to swap our state management implementation when needed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 门面将负责与状态管理解决方案和智能组件的所有通信。这使我们的智能组件与状态管理解决方案解耦，便于在需要时轻松交换我们的状态管理实现。
- en: Once we’ve created the RxJS state management solution and connected it with
    the component layer of the application, we can change the state management and
    facade to use Signals where it is possible and makes sense.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了RxJS状态管理解决方案并将其与应用程序的组件层连接起来，我们就可以将状态管理和门面更改为在可能且合理的地方使用Signals。
- en: By converting the state management solution from RxJS into Signals, you’ll be
    able to understand both concepts and learn about the differences. Building both
    approaches will also serve you best so that you can recognize and work with both
    systems when you encounter them in a project you join. Let’s start by building
    the RxJS state management solution.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将状态管理解决方案从RxJS转换为Signals，你将能够理解这两个概念并了解它们之间的区别。构建这两种方法也将为你提供最佳服务，以便你在加入的项目中遇到它们时能够识别并与之合作。让我们从构建RxJS状态管理解决方案开始。
- en: Building a state management solution using RxJS
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用RxJS构建状态管理解决方案
- en: To start building the state management solution, create a folder named `stores`
    in the `data-access` library of the finance domain. The `stores` folder should
    be located inside the `lib` folder, at the same level as the `adapters`, `HTTP`,
    `models`, and `services` folders.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始构建状态管理解决方案，在财务域的`data-access`库中创建一个名为`stores`的文件夹。`stores`文件夹应位于`lib`文件夹内部，与`adapters`、`HTTP`、`models`和`services`文件夹处于同一级别。
- en: Creating a service
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个服务
- en: First, you can create a service by using the *Nx generator* in the newly created
    `stores` folder. Name the new service `expenses.store`. Because we’re using the
    Nx generator, it will create a file named `expenses.store.service.ts`; you can
    remove the `.service` part manually and do the same for the `spec` file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以通过在新建的`stores`文件夹中使用*Nx生成器*来创建一个服务。将新服务命名为`expenses.store`。因为我们使用的是Nx生成器，它将创建一个名为`expenses.store.service.ts`的文件；你可以手动删除`.service`部分，并对`spec`文件做同样的处理。
- en: 'Next, rename the class `ExpensesStore` instead of `ExpensesStoreService` and
    remove `constructor`; this should be in your file when you’re ready:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将类名从`ExpensesStore`改为`ExpensesStoreService`并移除`constructor`；当你准备好时，这应该在你的文件中：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, you need something that can hold the state for your list of expenses.
    We will use a `BehaviorSubject` class that will emit an array of `ExpenseModel`.
    The `BehaviorSubject` class will be a private property, so you cannot directly
    mutate the state from outside our `ExpensesStore` class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要一个可以保存你支出列表状态的东西。我们将使用一个`BehaviorSubject`类，该类将发出一个`ExpenseModel`数组。`BehaviorSubject`类将是一个私有属性，因此你无法直接从我们的`ExpensesStore`类外部修改状态。
- en: Only the `ExpenseStore` class should be able to mutate the state directly; all
    other parts of the application should mutate it through `ExpenseStore` and, more
    precisely, through the facade, which will call `ExpenseStore`. Allowing the state
    to be directly mutated from other parts of your application can lead to unintended
    state mutations, breaking your application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 只有`ExpenseStore`类应该能够直接修改状态；应用程序的其他部分应该通过`ExpenseStore`以及更精确地说，通过外观（facade），来修改状态。允许应用程序的其他部分直接修改状态可能导致意外的状态修改，破坏你的应用程序。
- en: 'Because the `BehaviorSubject` class is private, you also need a public property
    that exposes the `BehaviorSubject` class to the outside world as an Observable:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`BehaviorSubject`类是私有的，你还需要一个公共属性，该属性将`BehaviorSubject`类暴露给外部世界作为一个可观察对象（Observable）：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, we first defined the `expenses` `BehaviorSubject` class, and
    we created the public `expenses$` Observable by taking the `expenses` `BehaviorSubject`
    class and calling the `asObservable()` method on the `BehaviorSubject` class.
    We gave the `expenses` `BehaviorSubject` class an empty array as its default value.
    Next, let’s add some logic to fetch and distribute our data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们首先定义了`expenses` `BehaviorSubject`类，并通过在`BehaviorSubject`类上调用`asObservable()`方法创建了公共的`expenses$`可观察对象（Observable）。我们给`expenses`
    `BehaviorSubject`类提供了一个空数组作为其默认值。接下来，让我们添加一些逻辑来获取和分发我们的数据。
- en: Fetching and distributing data in our store
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在我们的存储中获取和分发数据
- en: 'Next, we’ll add some logic to make an API request that retrieves the expenses
    and emits the received expenses through the `BehaviorSubject` class. To achieve
    this, start by injecting the `ExpensesHttpService` class we created in [*Chapter
    6*](B21625_06.xhtml#_idTextAnchor115):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一些逻辑来执行API请求以检索支出，并通过`BehaviorSubject`类发出接收到的支出。为了实现这一点，首先注入我们在[*第6章*](B21625_06.xhtml#_idTextAnchor115)中创建的`ExpensesHttpService`类：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, you need to create a method to make the API request and update the `BehaviorSubject`
    class:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要创建一个方法来执行API请求并更新`BehaviorSubject`类：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, we made a method named `fetchExpenses`, and inside this method,
    we used `expensesApi` to make a `get` request. We subscribed to the `get` request
    and handled the `next` and `error` events of the subscription. The `next` error
    is handled when the subscription of the `get` request receives a response, and
    the `error` event is handled whenever the `get` request fails and returns with
    an error status.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们创建了一个名为`fetchExpenses`的方法，并在该方法内部使用`expensesApi`来执行`get`请求。我们订阅了`get`请求并处理了订阅的`next`和`error`事件。当`get`请求的订阅收到响应时，处理`next`事件；当`get`请求失败并返回错误状态时，处理`error`事件。
- en: If the API request responds successfully, we call the `next()` method on the
    `expenses` `BehaviorSubject` class and give it the received `expenses` as a parameter.
    If the API responds with an error, we simply log the error. In a production application,
    you should handle this better and alert the user with a toaster message or something
    similar.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果API请求成功响应，我们在`expenses` `BehaviorSubject`类上调用`next()`方法，并给它传递接收到的`expenses`作为参数。如果API返回错误，我们简单地记录错误。在生产应用程序中，你应该更好地处理这种情况，并使用托盘消息或类似的方式提醒用户。
- en: Adding additional expense methods
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加额外的费用方法
- en: 'Next, you’ll want to add methods to get an expense by ID, as well as update,
    delete, and add expenses. Before you create these methods, `MockInterceptor` must
    be adjusted to handle the `delete` and `getByID` requests. You can modify the
    interceptor yourself or get the adjusted `MockInterceptor` from this book’s GitHub
    repository: [https://github.com/PacktPublishing/Effective-Angular](https://github.com/PacktPublishing/Effective-Angular).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将想要添加通过ID获取费用、更新、删除和添加费用的方法。在创建这些方法之前，必须调整`MockInterceptor`以处理`delete`和`getByID`请求。你可以自己修改拦截器，或者从本书的GitHub仓库中获取调整后的`MockInterceptor`：[https://github.com/PacktPublishing/Effective-Angular](https://github.com/PacktPublishing/Effective-Angular)。
- en: 'After adjusting `MockInterceptor`, you can start to implement the `add`, `delete`,
    `update`, and `getByID` methods in our expenses store. Inside all these methods,
    we need access to the current list of expenses. You can access the current list
    of expenses through the `value` property of the `expenses` `BehaviorSubject` class.
    Let’s create a getter that retrieves the current expenses from our state:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在调整`MockInterceptor`后，你可以在我们的费用存储中实现`add`、`delete`、`update`和`getByID`方法。在这些方法内部，我们需要访问当前的费用列表。你可以通过`expenses`
    `BehaviorSubject`类的`value`属性访问当前的费用列表。让我们创建一个获取器，从我们的状态中检索当前的费用：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, we can start adding the methods.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始添加方法。
- en: Adding expenses
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加费用
- en: 'Let’s start by creating a method to add an expense:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个添加费用的方法：
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the `addExpense` code takes `expense` as a function parameter.
    This `expense` parameter is used to call the `POST` request on `expenseApi`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`addExpense`代码将`expense`作为函数参数。这个`expense`参数用于在`expenseApi`上调用`POST`请求。
- en: When the API returns with the response, we update the `ID` property (we’re only
    updating the `ID` property because we don’t have an actual backend. Normally,
    `ID` would be populated by the backend). After updating the `ID` property, we
    add the newly created `expense` to the `expenses` state.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当API返回响应时，我们更新`ID`属性（我们只更新`ID`属性，因为我们没有实际的后端。通常，`ID`会由后端填充）。更新`ID`属性后，我们将新创建的`expense`添加到`expenses`状态中。
- en: Deleting expenses
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 删除费用
- en: 'After creating the `addExpense` method, you can make a method to delete an
    expense:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`addExpense`方法后，你可以创建一个删除费用的方法：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `delete` method is pretty straightforward. We make the API request, and
    when the API responds, we update the `expenses` state with the new list of expenses
    by calling the `next()` method. As a parameter for the `next()` method, we use
    the current list of `expenses` and `filter` out the deleted expenses. If the API
    responds with an error, we log the error, again in a production application, and
    we show some sort of message to the user.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`方法相当直接。我们发起API请求，当API响应时，我们通过调用`next()`方法更新`expenses`状态，以获取新的费用列表。作为`next()`方法的参数，我们使用当前的`expenses`列表并使用`filter`过滤掉已删除的费用。如果API返回错误，我们记录错误，同样在生产应用程序中，我们向用户显示某种消息。'
- en: Fetching, getting, and selecting expenses
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取、获取和选择费用
- en: After adding the `delete` method, we will add the `getExpense`, `selectExpense`,
    and `fetchExpenseById` methods. The `getExpense` and `selectExpense` methods will
    be public methods, while the `fetchExpenseById` will be private. We will also
    create an `expense` `Subject` class and a `selectedExpense` state using a `BehaviorSubject`
    class.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加`delete`方法后，我们将添加`getExpense`、`selectExpense`和`fetchExpenseById`方法。`getExpense`和`selectExpense`方法将是公共方法，而`fetchExpenseById`将是私有方法。我们还将创建一个`expense`
    `Subject`类和一个`selectedExpense`状态，使用`BehaviorSubject`类。
- en: 'Let’s start by adding the `Subject` class and the `selectedExpense` state:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加`Subject`类和`selectedExpense`状态：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `expense` `Subject` class and `selectedExpense` state can be used to retrieve
    the selected expense reactively. The `selectedExpense` state is used when you
    need to persist the selection in your global application state. In contrast, the
    `expense Subject` class can be used to emit an expense as an event that is only
    received by Observers who are subscribed when the event is emitted. After adding
    the `expense Subject` class and the `selectedExpense` state, we will continue
    with the private `fetchExpenseById` method:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`expense` `Subject` 类和 `selectedExpense` 状态可以用来响应式地检索选定的费用。当您需要将选择持久化到全局应用程序状态时，使用
    `selectedExpense` 状态。相比之下，`expense Subject` 类可以用来发出一个事件，该事件只被在事件发出时订阅的观察者接收。在添加了
    `expense Subject` 类和 `selectedExpense` 状态之后，我们将继续使用私有的 `fetchExpenseById` 方法：'
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `fetchExpenseById` method has `id` and `select` parameters. The `id` parameter
    is required, and the `select` property is optional with a default value of `false`.
    The method starts by making an API call to retrieve an expense by ID. When the
    API responds with an expense, we emit a new value using `expense Subject` or emit
    a value and set the `selectedExpense` state using the `BehaviorSubject` class.
    Depending on the needs of your application, you can also add the fetched expense
    to the `expenses` state, but for our demo application, this isn’t necessary.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchExpenseById` 方法有 `id` 和 `select` 参数。`id` 参数是必需的，而 `select` 属性是可选的，默认值为
    `false`。该方法首先通过 API 调用来通过 ID 获取费用。当 API 响应费用时，我们将使用 `expense Subject` 发出一个新值，或者使用
    `BehaviorSubject` 类发出一个值并设置 `selectedExpense` 状态。根据您应用程序的需求，您还可以将获取的费用添加到 `expenses`
    状态中，但对我们这个演示应用程序来说，这不是必需的。'
- en: 'Now, to finish up the get expense by `id` logic, we need to implement the public
    `getExpense` and `selectExpense` methods:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了完成通过 `id` 获取费用的逻辑，我们需要实现公共的 `getExpense` 和 `selectExpense` 方法：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, the `getExpense` and `selectExpense` methods are very similar.
    Both methods receive `id` as a parameter and check if the expense with the provided
    `id` parameter can be found inside the current `expenses` state.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`getExpense` 和 `selectExpense` 方法非常相似。两种方法都接收 `id` 作为参数，并检查提供的 `id` 参数是否可以在当前的
    `expenses` 状态中找到。
- en: When the expense is found in the current state, the `next()` method is called
    on the `expense Subject` class or the `selectedExpense` `BehaviorSubject` class.
    When no expense is found in the current `expenses` state, the `fetchExpenseById`
    method is called to get the expense from the backend; in that case, the `fetchExpenseById`
    method will call the `expense Subject` or `selectedExpense BehaviorSubject` class.
    Now that we’ve added everything to get or select an expense reactively, let’s
    add the `updateExpense` method.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当在当前状态中找到费用时，会在 `expense Subject` 类或 `selectedExpense` `BehaviorSubject` 类上调用
    `next()` 方法。当在当前的 `expenses` 状态中没有找到费用时，会调用 `fetchExpenseById` 方法从后端获取费用；在这种情况下，`fetchExpenseById`
    方法将调用 `expense Subject` 或 `selectedExpense BehaviorSubject` 类。既然我们已经添加了获取或选择费用的响应式方法，让我们添加
    `updateExpense` 方法。
- en: Updating expenses
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新费用
- en: 'The `update` method will receive `expense` as a function parameter. Next, it
    will make a `PUT` request using `expensesApi` to update the request in the backend.
    After the API responds successfully, the method will update the `expenses` state:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`update` 方法将接收 `expense` 作为函数参数。接下来，它将使用 `expensesApi` 发起 `PUT` 请求来更新后端中的请求。在
    API 成功响应后，该方法将更新 `expenses` 状态：'
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, we make the API request and use the `next()` method on `expenses
    BehaviorSubject` to update the `expenses` state. As an argument for the `next()`
    method, we take the `currentExpenses` getter and use the `map()` function to replace
    the updated expense.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们发起 API 请求并在 `expenses BehaviorSubject` 上使用 `next()` 方法来更新 `expenses`
    状态。作为 `next()` 方法的参数，我们使用 `currentExpenses` 获取器并使用 `map()` 函数来替换更新的费用。
- en: Now that we’ve added the methods to add, update, delete, and get expenses, let’s
    finish up the store with some additional state and methods to reset the state.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了添加、更新、删除和获取费用的方法，让我们通过添加一些额外的状态和重置状态的方法来完成这个存储。
- en: Extending ExpensesStore
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展 ExpensesStore
- en: 'We will start by adding an additional piece of state to manage whether we show
    prices, including or excluding VAT. We can do this by creating a new `BehaviorSubject`
    class and a method to adjust the `BehaviorSubject` class’ value:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先添加一个额外的状态来管理是否显示价格，包括或排除增值税。我们可以通过创建一个新的 `BehaviorSubject` 类和一个调整 `BehaviorSubject`
    类值的方法来实现这一点：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, the VAT state is just a simple Boolean indicating whether we
    show the prices, including or excluding VAT.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，增值税状态只是一个简单的布尔值，表示我们是否显示包含或不含增值税的价格。
- en: 'Lastly, we need some logic to reset our application state and clear the selected
    product state. We will create two different methods for this `resetState` to reset
    all the states to the default values. We’ll use a `clearExpenseSelection` method
    to clear the `selectedExpense` state:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一些逻辑来重置我们的应用程序状态并清除所选产品状态。我们将为`resetState`创建两个不同的方法来将所有状态重置为默认值。我们将使用`clearExpenseSelection`方法来清除`selectedExpense`状态：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This was the last piece of the puzzle for our expense store. You created a simple
    yet effective state management solution to handle the global application state
    of the expenses. You did so using the RxJS `Subject` and `BehaviorSubject` classes.
    This `ExpensesStore` can now be used as the single source of truth for all your
    expense data throughout your application.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们费用存储的最后一部分。您创建了一个简单而有效的状态管理解决方案来处理费用的全局应用程序状态。您这样做使用了RxJS的`Subject`和`BehaviorSubject`类。现在，`ExpensesStore`可以成为您应用程序中所有费用数据的单一事实来源。
- en: If a component needs the current state of some expense data, it will come from
    this `ExpensesStore`. When your application grows, and you have other entities
    with a state besides the expenses, such as users, reports, or settings, each entity
    will have a store file to manage the state of that entity.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个组件需要某些费用数据的当前状态，它将来自这个`ExpensesStore`。当您的应用程序增长，并且您有除了费用之外的其他实体具有状态，例如用户、报告或设置时，每个实体都将有一个存储文件来管理该实体的状态。
- en: Now that you’ve created a state management solution using RxJS, we will start
    building the facade service and connect the view layer with the store through
    the facade.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经使用RxJS创建了一个状态管理解决方案，我们将开始构建门面服务，并通过门面将视图层与存储连接起来。
- en: Connecting your state management and view layer with a facade service
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用门面服务连接您的状态管理和视图层
- en: 'Now that you have a state management solution in place, it’s time to connect
    it to the view layer of your application. As mentioned several times in this book,
    the best approach is to create a facade service for this. This facade provides
    an additional layer of abstraction, providing a simple interface for your view
    layer to interact with the application state. *Figure 8**.1* provides a visual
    representation of the facade service and how data flows from your state through
    the facade into your components:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有一个状态管理解决方案，是时候将其连接到您应用程序的视图层了。正如本书中多次提到的，最佳方法是为此创建一个门面服务。这个门面提供了一层额外的抽象，为您的视图层提供了一个简单的接口来与应用程序状态交互。*图8.1*展示了门面服务以及数据如何从您的状态通过门面流入组件：
- en: '![Figure 8.1: Data flow with a facade, components, and state](img/B21625_08_001.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1：使用门面、组件和状态的数据流](img/B21625_08_001.jpg)'
- en: 'Figure 8.1: Data flow with a facade, components, and state'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：使用门面、组件和状态的数据流
- en: As you can see, your components make a simple request to the facade service,
    and the facade will collect the data from your different state services and send
    it back to the component in the format that the component needs. This ensures
    your components only have one dependency and your facade will host all other necessary
    dependencies to retrieve the data you need in your components.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您的组件向门面服务发出一个简单的请求，门面将从您的不同状态服务中收集数据，并以组件所需格式将其发送回组件。这确保了您的组件只有一个依赖项，而门面将托管所有其他必要的依赖项以检索您组件所需的数据。
- en: Creating a facade service
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建门面服务
- en: Start by creating a `facades` folder inside the `lib` folder of your `expenses`
    `data-access` library. The new `facades` folder will be located in the same folder
    as the `store` folder.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在您的`expenses` `data-access`库的`lib`文件夹内创建一个`facades`文件夹。新的`facades`文件夹将位于与`store`文件夹相同的文件夹中。
- en: Inside the new `facades` folder, you must create a file named `expenses.facade.ts`
    with an injectable class called `ExpensesFacade`. You can use the Nx generator
    to create a service and rename it or create the facade manually. Also, add an
    export inside the `index.ts` file so that you can consume the facade outside the
    library.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的`facades`文件夹内，您必须创建一个名为`expenses.facade.ts`的文件，并包含一个名为`ExpensesFacade`的可注入类。您可以使用Nx生成器创建一个服务并重命名它，或者手动创建门面。此外，在`index.ts`文件中添加一个导出，以便您可以在库外部使用门面。
- en: 'When you’re finished, you should have the following in the `expenses.facade.ts`
    file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成时，您应该在`expenses.facade.ts`文件中有以下内容：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Creating the facade interface
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建外观接口
- en: Next, create a file next to the `expenses.facade.ts` file named `expensesFacade.interface.ts`.
    In this interface, we will declare the blueprint of our facade. So long as your
    facade implements this interface, you can switch the implementation of the state
    without touching the component layer. If you change the interface, you also need
    to adjust the component layer.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `expenses.facade.ts` 文件旁边创建一个名为 `expensesFacade.interface.ts` 的文件。在这个接口中，我们将声明外观的蓝图。只要你的外观实现了这个接口，你就可以在不接触组件层的情况下切换状态实现。如果你更改了接口，你也需要调整组件层。
- en: 'In the interface file, declare the following interface:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在接口文件中，声明以下接口：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After defining the interface, we can start with the facade service. Start by
    implementing the interface:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了接口之后，我们可以开始实现外观服务。首先实现接口：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, you want to inject `ExpensesStore` inside the facade service:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你想要在外观服务内部注入 `ExpensesStore`：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that we’ve injected the store, we will add a method to fetch the expenses.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经注入了存储库，我们将添加一个获取费用的方法。
- en: Connecting the facade with the store
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将外观与存储库连接
- en: 'Let’s add a simple method to the facade that simply calls the `fetch` method
    inside the store:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在外观中添加一个简单的方法，该方法简单地调用存储库中的 `fetch` 方法：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we will create a method to get the fetched expenses. But before we do
    this, we will create a new interface called `ExpensesViewModel`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个获取已获取费用的方法。但在我们这样做之前，我们将创建一个新的接口，称为 `ExpensesViewModel`：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can also adjust `ExpenseModel` a bit and rename the `amountExclVat` property
    to `value`. If you’re using VS Code, you can select the property and press *F2*
    to rename it. When you rename using the *F2* key, the property will be renamed
    in every instance (besides the HTML templates).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以稍微调整 `ExpenseModel` 并将 `amountExclVat` 属性重命名为 `value`。如果你使用 VS Code，你可以选择属性并按
    *F2* 键来重命名它。当你使用 *F2* 键重命名时，属性将在每个实例中重命名（除了 HTML 模板之外）。
- en: 'Now that you’ve created `ExpensesViewModel` and adjusted `ExpenseModel`, let’s
    create the `getExpenses` method inside the facade:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了 `ExpensesViewModel` 并调整了 `ExpenseModel`，让我们在外观内部创建 `getExpenses` 方法：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, there is quite a lot going on in this method. This is one of
    the reasons why using a facade service is beneficial.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个方法中有很多事情在进行。这是使用外观服务有益的原因之一。
- en: 'In a large application, the chances are high that you need this `ExpensesViewModel`
    in multiple components. Instead of having to define this chunk of logic in multiple
    component classes, you can define it inside the facade, and inside the component
    layer, you can use a simple function call, keeping your components simple and
    clean. Also, when you need to adjust the logic, you only have to do it in this
    single place instead of in multiple component classes. Now, to better understand
    what we did inside the function, let’s break it down line by line:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型应用程序中，你需要在多个组件中使用这个 `ExpensesViewModel` 的可能性很高。你不需要在多个组件类中定义这块逻辑，你可以在外观内部定义它，在组件层内部，你可以使用简单的函数调用，保持你的组件简单和干净。此外，当你需要调整逻辑时，你只需要在这个单一位置进行调整，而不是在多个组件类中。现在，为了更好地理解我们在函数内部做了什么，让我们逐行分解：
- en: We started by naming the method `getExpenses` and specified that it would return
    an `ExpensesViewModel` Observable.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先命名了方法为 `getExpenses` 并指定它将返回一个 `ExpensesViewModel` 可观察对象。
- en: Inside the `getExpenses()` method, we returned an Observable using the `combineLatest()`
    method.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `getExpenses()` 方法内部，我们使用 `combineLatest()` 方法返回了一个可观察对象。
- en: Inside `combineLatest()`, we combined the `expenses$` and `inclVat$` Observables
    from the store and applied the RxJS `pipe()` function to `combineLatest()`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `combineLatest()` 内部，我们将存储库中的 `expenses$` 和 `inclVat$` 可观察对象组合起来，并应用了 RxJS
    的 `pipe()` 函数到 `combineLatest()`。
- en: Inside the `pipe()` function, we applied two operators, starting with the `distinctUntilChanged()`
    operators, so that we only emitted a new value when the values changed.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `pipe()` 函数内部，我们应用了两个操作符，从 `distinctUntilChanged()` 操作符开始，这样我们只有在值发生变化时才发出新的值。
- en: Next, we used the `map()` operator to map the two Observable streams into `ExpensesViewModel`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用了 `map()` 操作符将两个可观察对象流映射到 `ExpensesViewModel`。
- en: Depending on the state of the `inclVat$` Observable, we returned the expense
    value properties and the total property, including or excluding VAT.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据 `inclVat$` 可观察对象的状态，我们返回费用值属性和总属性，包括或排除增值税。
- en: Now that you’ve created the `fetch-` and `getExpenses` methods inside the facade,
    let’s adjust the expenses overview page.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在外观内部创建了 `fetch-` 和 `getExpenses` 方法，让我们调整费用概览页面。
- en: Adjusting the expenses overview page
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调整支出概览页面
- en: 'Inside the page component, start by injecting the facade service:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面组件内部，首先注入外观服务：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After injecting the facade, you can fetch the expenses inside the `ngOnInit()`
    method of the page component:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在注入外观后，你可以在页面组件的`ngOnInit()`方法中获取支出：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, you can clean up the component. In [*Chapter 7*](B21625_07.xhtml#_idTextAnchor129),
    we used a Signal with mocked data for `expenses`; in this section, we will use
    the expenses we receive from the `getExpenses` method inside the facade. Start
    by reassigning the `expenses` property, like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以清理组件。在[*第7章*](B21625_07.xhtml#_idTextAnchor129)中，我们使用模拟数据为`expenses`创建了一个信号；在本节中，我们将使用外观内部`getExpenses`方法接收到的支出。首先，像这样重新分配`expenses`属性：
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After reassigning the `expenses` property, you will get some errors inside the
    component and template file of the expenses overview page because you don’t have
    the `expenses` Signal anymore. Go ahead and remove the `totalInclVat` computed
    Signal; you can also remove the Signal effect in the component and clear out the
    logic inside the `onAddExpense` method.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新分配`expenses`属性后，由于你不再拥有`expenses`信号，你将在支出概览页面的组件和模板文件中遇到一些错误。继续移除`totalInclVat`计算信号；你还可以移除组件中的信号效果，并在`onAddExpense`方法内部清除逻辑。
- en: Next, we need to make some adjustments to the HTML template.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要对HTML模板做一些调整。
- en: 'Start by adding an `if-else` block around the HTML table:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在HTML表格周围添加一个`if-else`块：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Inside the `if` block, you will use the `expenses` property with an `async`
    pipe so that you can retrieve `expenses` from the facade and use those values
    within the template.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`块内部，你将使用带有`async`管道的`expenses`属性，以便从外观中检索`expenses`并使用这些值在模板中。
- en: 'After adding the `if` block, you need to adjust the `for` block inside the
    HTML template and switch the `expenses` Signal for the `expenses` property you
    retrieved from the facade:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加`if`块后，你需要调整HTML模板内部的`for`块，并将`expenses`信号切换为你从外观中检索到的`expenses`属性：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After adjusting the `for` block, you need to adjust the table rows to correctly
    reflect the new model structure and to improve the UI. Do this by rounding the
    value to two decimals, and then adding a `currency` pipe and percentage (`%`)
    sign:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 调整`for`块后，你需要调整表格行以正确反映新的模型结构并改进UI。通过将值四舍五入到两位小数，然后添加`currency`管道和百分比（`%`）符号来完成此操作：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Lastly, you need to switch the `totalInclVat` computed Signal we used inside
    the template for the `total` property on `expensesVm`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要将模板中使用的`totalInclVat`计算信号切换为`expensesVm`上的`total`属性：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we adjusted the text to `total` because we now show the total, including
    or excluding VAT, depending on the global state. After making these adjustments,
    you should see the total amount and expenses inside the table again, only now
    using RxJS and the global state instead of the Signals with mocked `expenses`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将文本调整为`total`，因为我们现在显示包括或排除增值税的总金额。在做出这些调整后，你应该再次在表格中看到总金额和支出，但现在使用RxJS和全局状态而不是带有模拟`expenses`的信号。
- en: Next, you want something to toggle the VAT so that you can see the expenses
    and total amount being automatically updated when the VAT status changes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你想要一个可以切换增值税的选项，以便在增值税状态改变时自动更新显示的支出和总金额。
- en: 'Start by adding a new method inside the facade service:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在组件服务内部添加一个新方法：
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, this is just a simple method calling the `adjustVat` method
    inside the store. This will change the `inclVat` `BehaviorSubject` class inside
    the store. This, in turn, will trigger the `combineLatest()` method we used inside
    the `getExpenses` method inside the facade.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这只是一个调用存储中`adjustVat`方法的简单方法调用。这将改变存储中`inclVat` `BehaviorSubject`类。这反过来将触发我们在外观内部的`getExpenses`方法中使用的`combineLatest()`方法。
- en: So, when you change the VAT status, `ExpensesViewModel`, which we retrieved
    through the `getExpenses` method, will automatically be updated and show the total
    and expense amounts, including or excluding VAT, depending on the state.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你更改增值税状态时，通过`getExpenses`方法检索到的`ExpensesViewModel`将自动更新并显示总金额和支出金额，包括或排除增值税，具体取决于状态。
- en: 'Once you’ve added the method to adjust the VAT, you also need something to
    retrieve the `inclVat` status inside the facade. You can simply create a property
    for this and assign it with the `inclVat$` Observable from the store:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你添加了调整增值税的方法，你还需要在组件内部检索`inclVat`状态。你可以简单地创建一个属性并使用存储中的`inclVat$`可观察对象来分配它：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After adding the method and property to adjust and retrieve the VAT status,
    let’s add a toggle inside the HTML template of the expenses overview page to adjust
    the VAT state:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了调整和检索增值税状态的方法和属性后，让我们在费用概述页面的HTML模板中添加一个切换来调整增值税状态：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: I’ve added the VAT toggle next to the `inclVatSelector$` from the facade combined
    with an `async` pipe to set the `checked` property of the VAT toggle.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`inclVatSelector$`旁边添加了增值税切换，并结合了`async`管道来设置增值税切换的`checked`属性。
- en: We’ve also added a `click` event to the `input` value of the toggle to call
    the `adjustVat` method in the facade. If you click on the toggle, you will see
    the expense amounts in the table and the total amount in the table summary change
    to include or exclude the VAT amount, depending on the VAT state.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还向切换按钮的`input`值添加了一个`click`事件，以便在门面中调用`adjustVat`方法。如果你点击切换按钮，你将看到表格中的费用金额和表格摘要中的总金额根据增值税状态的变化而包含或排除增值税金额。
- en: As you might have noticed, this is a very reactive approach because everything
    reacts upon the state changes automatically. The code is also very performant
    because the updates are performed in a non-blocking manner, allowing all your
    code to keep running.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，这是一个非常响应式的方法，因为所有内容都会在状态变化时自动做出反应。代码也非常高效，因为更新是以非阻塞方式执行的，允许所有代码继续运行。
- en: Now that we’ve implemented the `getExpenses` method and the VAT status, let’s
    finish up the facade service.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了`getExpenses`方法和增值税状态，让我们完成门面服务的开发。
- en: Finishing up the facade service
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完成门面服务的开发
- en: For all the other methods exposed by the store, you can add simple methods inside
    the facade service that call them from the store, similar to what we did with
    the `fetchExpenses` and `adjustVat` methods.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于存储公开的所有其他方法，你可以在门面服务中添加简单的方法来调用它们，类似于我们处理`fetchExpenses`和`adjustVat`方法的方式。
- en: 'For the `selectedExpense` and `expense` properties inside the store, you need
    to add a selector property inside the facade service. Because we will also map
    the expenses emitted by `selectedExpense` and `expense`, we will abstract the
    mapping behavior into a new function so that we can reuse it:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于存储中的`selectedExpense`和`expense`属性，你需要在门面服务中添加一个选择器属性。因为我们还将映射由`selectedExpense`和`expense`发出的费用，所以我们将映射行为抽象到一个新的函数中，以便我们可以重用它：
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, you can adjust the mapping of the expenses inside the `getExpenses` method
    like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以像这样调整`getExpenses`方法内部的费用映射：
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Lastly, we will add the selector properties for `selectedExpense` and `expense`,
    starting with `expenseSelector$`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将为`selectedExpense`和`expense`添加选择器属性，从`expenseSelector$`开始：
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, for `expenseSelector$`, we used the `withLatestFrom()` operator
    and didn’t use `combineLatest()`. We did this because `expenseSelector$` will
    only emit a value as an event using the `Subject` class instead of `BehaviorSubject`.
    There is no state here, and we don’t want the selector to emit a new value when
    the VAT toggle changes. We only want it to respond when the `expense` `Subject`
    class emits a value, and when that happens, take the current value of the `inclVat$`
    Observable to map the expense.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，对于`expenseSelector$`，我们使用了`withLatestFrom()`运算符而没有使用`combineLatest()`。我们这样做是因为`expenseSelector$`将只使用`Subject`类而不是`BehaviorSubject`作为事件发出值。这里没有状态，我们不希望选择器在增值税切换变化时发出新值。我们只想在`expense`
    `Subject`类发出值时做出反应，并且当这种情况发生时，使用当前`inclVat$` Observable的值来映射费用。
- en: 'The `selector` property for `selectedExpense` will use the `combineLatest()`
    function to combine the `selectedExpense$` Observable and the `inclVat$` Observable,
    like so:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`selectedExpense`的选择器属性将使用`combineLatest()`函数将`selectedExpense$` Observable和`inclVat$`
    Observable结合起来，如下所示：'
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: For `selectedExpenseSelector$`, we used the `combineLatest()` function because
    the selected expense is stateful and persists in our store. We might use the selected
    expense in our view while we can change the VAT, and because of that, we want
    it to react when the VAT status changes and update the amount in the view. Because
    we want `selectedExpense` to be reactive on the VAT status as well, we used the
    `combineLatest()` operator, which triggers whenever one of the combined Observables
    emits a new value.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`selectedExpenseSelector$`，我们使用了`combineLatest()`函数，因为选定的费用是状态性的，并且持续存在于我们的存储中。当我们可以更改增值税时，我们可以在视图中使用选定的费用，因此我们希望它在增值税状态变化时做出反应，并更新视图中的金额。因为我们希望`selectedExpense`对增值税状态也是响应式的，所以我们使用了`combineLatest()`运算符，它在组合的任何一个Observables发出新值时都会触发。
- en: This was the last part of implementing the state management solution using RxJS.
    This approach to state management is commonly used within smaller Angular applications
    where the state isn’t used in many different components and services. The solution
    offers good reactivity and is easy to build and understand.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用RxJS实现状态管理解决方案的最后一部分。这种状态管理方法通常用于较小的Angular应用程序中，其中状态在许多不同的组件和服务中不被使用。该解决方案提供了良好的响应性，并且易于构建和理解。
- en: Now, let’s learn how to convert this state management solution so that it uses
    Signals instead of RxJS. Using Signals will simplify your facade service and component
    layer. It also allows Angular to perform better change detection. If you need
    to combine many data streams with tailored logic and apply modifications to them,
    the RxJS approach will fit your application better.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何将这个状态管理解决方案转换为使用信号（Signals）而不是RxJS。使用信号将简化你的外观服务（facade service）和组件层。它还允许Angular进行更好的变更检测。如果你需要组合许多数据流并应用定制逻辑，RxJS方法将更适合你的应用程序。
- en: That said, using Signals is much simpler for simple state and data streams.
    Even if you need to combine some data streams without needing to have too much
    control over how this happens, the Signal approach will be best suited for you.
    Signals are the way to go for your state if you find yourself only using `combineLatest()`
    and `withLatestFrom()` and some basic operators such as `map()` and `filter()`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，对于简单的状态和数据流，使用信号（Signals）要简单得多。即使你需要组合一些数据流而不需要过多控制这个过程，信号方法也将最适合你。如果你发现自己只使用`combineLatest()`和`withLatestFrom()`以及一些基本操作符，如`map()`和`filter()`，那么信号将是你的状态管理方式。
- en: Handling global application state using Signals
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用信号处理全局应用程序状态
- en: To convert your state management solution so that it uses Signals instead of
    RxJS, you must change the `BehaviorSubject` classes in the `ExpensesStore` to
    Signals. You still want to ensure that the state only emits a new value when it’s
    set in the store; you don’t want to be able to set the state outside of the store.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将你的状态管理解决方案转换为使用信号而不是RxJS，你必须将`ExpensesStore`中的`BehaviorSubject`类更改为信号。你仍然想要确保状态仅在存储库中设置时才发出新值；你不想能够在存储库外部设置状态。
- en: 'To achieve this, we will create a private `WritableSignal` and a public Signal
    that is read-only. You can change all the `BehaviorSubject` classes to Signals
    using the following syntax:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将创建一个私有的`WritableSignal`和一个公共的只读`Signal`。你可以使用以下语法将所有`BehaviorSubject`类更改为信号：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we declared a private Signal using the `signal()` function. Declaring
    a Signal in this manner will create `WritableSignal`. In the line after, we created
    a public property and assigned it with `WritableSignal` but cast it to a `Signal`
    type with the `as` keyword; here, the `Signal` type is read-only. After adjusting
    all your `BehaviorSubject` classes, you need to change the references you had
    to them inside the store.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`signal()`函数声明了一个私有信号（Signal）。以这种方式声明信号将创建`WritableSignal`。在下一行，我们创建了一个公共属性，并将其分配给`WritableSignal`，但使用`as`关键字将其转换为`Signal`类型；这里的`Signal`类型是只读的。在调整所有`BehaviorSubject`类之后，你需要更改在存储库内部对它们的引用。
- en: 'Start by removing the `currentExpenses` getter and change all instances of
    `this.current` **Expenses** to the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先移除`currentExpenses`获取器，并将所有`this.current` **Expenses**实例更改为以下内容：
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, inside the `adjustVat()` function, change `!this.incluVat.value` to the
    following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`adjustVat()`函数内部，将`!this.incluVat.value`更改为以下内容：
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Lastly, you need to adjust all instances where you used the `next()` method
    on one of your `BehaviorSubject` classes.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要调整所有使用`next()`方法在某个`BehaviorSubject`类上的实例。
- en: 'Here’s an example of how to convert the `resetState()` function:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个如何转换`resetState()`函数的示例：
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, change all other instances of the `next()` method to the `Subject` class
    and the `set()` method. That’s all we need to do for `ExpensesStore`; you now
    have state management that uses Signals instead of RxJS `BehaviorSubject` classes.
    After adjusting the state, we need to change `ExpensesFacade` so that it can work
    with Signals instead of Observables.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将所有其他`next()`方法实例更改为`Subject`类和`set()`方法。这就是我们为`ExpensesStore`需要做的所有事情；你现在拥有使用信号而不是RxJS
    `BehaviorSubject`类的状态管理。在调整状态后，我们需要调整`ExpensesFacade`，使其能够与信号而不是观察者（Observables）一起工作。
- en: Normally speaking, one of the advantages of a facade service is that it is an
    abstraction layer, and we don’t need to touch the component layer when changing
    the state management solution. But in this situation, we need to adjust both the
    facade service and the component layer; this is because we will be changing the
    interface of the facade service.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，外观服务的一个优点是它是一个抽象层，在改变状态管理解决方案时我们不需要触及组件层。但在这个情况下，我们需要调整外观服务和组件层；这是因为我们将要改变外观服务的接口。
- en: In theory, we could maintain the interface and still return Observables by converting
    the Signals back into Observables in the service; doing so would allow you to
    leave the component layer untouched. However, we want to utilize the full power
    of these Signals and also implement them in our components so that Angular can
    perform better change detection and we can make our templates synchronous. To
    achieve this, we need to return Signals from our facade service instead of Observables,
    changing the interface of the facade.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，我们可以保持接口不变，并在服务中将信号转换回可观察对象，这样就可以不触及组件层。然而，我们想要充分利用这些信号的力量，并在我们的组件中实现它们，以便
    Angular 可以执行更好的变更检测，我们也可以使我们的模板同步。为了实现这一点，我们需要从我们的外观服务返回信号而不是可观察对象，改变外观服务的接口。
- en: 'We will start changing the facade by changing the interface. Replace the `getExpenses`
    method inside the interface with an `expenses` property and adjust the `selectedExpenseSelector$`
    and `inclVatSelector$` properties like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过改变接口来开始改变外观。将接口内部的 `getExpenses` 方法替换为 `expenses` 属性，并像这样调整 `selectedExpenseSelector$`
    和 `inclVatSelector$` 属性：
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After making the preceding adjustments in the interface, you can start implementing
    the interface inside the facade service. To implement the changes in the interface,
    remove the `getExpenses` method. Instead of the `getExpenses` method, you must
    create a computed Signal that returns the same value as the `getExpenses` method
    did:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在接口中做出上述调整后，你就可以开始在外观服务内部实现接口。为了在接口中实现更改，删除 `getExpenses` 方法。而不是 `getExpenses`
    方法，你必须创建一个计算信号，它返回与 `getExpenses` 方法相同的价值：
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, the computed Signal is very similar to the `getExpenses` method.
    The main difference is that we no longer need the `combineLatest()` and `map()`
    operators. We can now use the `inclVat` and `expenses` Signals inside the computed
    Signals.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，计算信号与 `getExpenses` 方法非常相似。主要区别是我们不再需要 `combineLatest()` 和 `map()` 操作符。现在我们可以在计算信号中使用
    `inclVat` 和 `expenses` 信号。
- en: When one of the two Signals receives a new value, the computed Signal will automatically
    compute a new one. The computed Signals can be seen as `combineLatest()` of the
    Signals realm. The equivalent of `withLatestFrom()` would be using a Signal inside
    the computed Signal and wrapping the Signal using the `untracked()` function,
    as we discussed in [*Chapter 7*](B21625_07.xhtml#_idTextAnchor129).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个信号中的任何一个接收到新值时，计算信号将自动计算一个新的值。计算信号可以看作是信号领域的 `combineLatest()`。`withLatestFrom()`
    的等价物将是在计算信号中使用信号并使用 `untracked()` 函数包装信号，正如我们在 [*第7章*](B21625_07.xhtml#_idTextAnchor129)
    中讨论的那样。
- en: 'After adding the computed Signal, we need to implement the `inclVat` and `selectedExpense`
    Signals inside the facade service. This is pretty straightforward – you simply
    define the property and assign it with the Signal from `ExpensesStore`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了计算信号之后，我们需要在外观服务内部实现 `inclVat` 和 `selectedExpense` 信号。这很简单——你只需定义属性，并用从
    `ExpensesStore` 获取的信号分配给它：
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we assign the property with the Signal from the store; we do not call
    the Signal by adding function brackets, `()`. We don’t add these function brackets
    because we want to use the actual Signal inside the component layer, not the `Signal`
    value. If you were to call the Signal here and retrieve the value inside the component
    layer, the update behavior wouldn’t work as expected, and the view wouldn’t be
    updated when your state changes.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过从存储中获取的信号来分配属性；我们不是通过添加函数括号 `()` 来调用信号。我们不添加这些函数括号是因为我们想在组件层中使用实际的信号，而不是
    `Signal` 值。如果你在这里调用信号并检索组件层内的值，更新行为将不会按预期工作，并且当你的状态改变时视图不会更新。
- en: 'The last thing to do is adjust `ExpensesOverviewPageComponent` and its template.
    Inside the component class, you can adjust the `expenses` property and assign
    it with the `expenses Subject` class from the facade instead of the `getExpenses()`
    function:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的事情是调整 `ExpensesOverviewPageComponent` 及其模板。在组件类内部，你可以调整 `expenses` 属性，并用外观服务中的
    `expenses Subject` 类代替 `getExpenses()` 函数分配给它：
- en: '[PRE42]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, inside the HTML template, you need to change `inclVatSelector$` to `inclVat()`,
    remove the `async` pipe, and change `expenses` with the `async` pipe to `expenses()`
    without the `async` pipe:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 HTML 模板内部，你需要将 `inclVatSelector$` 改为 `inclVat()`，移除 `async` 管道，并将带有 `async`
    管道的 `expenses` 改为不带 `async` 管道的 `expenses()`：
- en: '[PRE43]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: With the preceding changes, you’ve adjusted the component class and the HTML
    template to use Signals instead of Observables. As you can see, using the Signal
    approach is slightly simpler and needs fewer lines of code. It also makes your
    HTML template synchronous and helps Angular to perform better change detection,
    leading to better performance.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的更改中，你已经调整了组件类和 HTML 模板以使用 Signals 而不是 Observables。正如你所见，使用 Signal 方法稍微简单一些，并且需要更少的代码行。它还使你的
    HTML 模板同步，并帮助 Angular 进行更好的变更检测，从而提高性能。
- en: The flip side is that you have less control over the data streams, and it’s
    not as easy to modify the stream before it reaches your application logic. Compared
    to RxJS, Signals also offers less control when you want to combine different streams
    of data, so depending on your needs, you can decide whether to use Signals or
    RxJS.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你对数据流的控制较少，在数据流到达你的应用程序逻辑之前修改流并不容易。与 RxJS 相比，当你想要组合不同的数据流时，Signals 也提供了较少的控制，因此根据你的需求，你可以决定是否使用
    Signals 或 RxJS。
- en: You can also make a hybrid solution and convert Observables into Signals, giving
    you the best of both worlds. In that case, you can use the RxJS operators you
    need and still consume the values as Signals in your component classes and HTML
    templates.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以创建一个混合解决方案，将 Observables 转换为 Signals，这样你就可以兼得两者之优。在这种情况下，你可以使用你需要的 RxJS
    操作符，并且仍然可以在组件类和 HTML 模板中将值作为 Signals 消费。
- en: With that, you’ve learned how to create a state management solution using RxJS
    and Signals. You made a facade service as an additional abstraction layer and
    learned when you have to change the component layer and when you only have to
    change the state management layer when working with a facade service.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你已经学会了如何使用 RxJS 和 Signals 创建状态管理解决方案。你创建了一个外观服务作为额外的抽象层，并学习了在与外观服务一起工作时，何时需要更改组件层，何时只需要更改状态管理层。
- en: Both state management solutions we’ve created work well for small applications
    with relatively simple global states. The RxJS method is implemented a lot, and
    with the popularity of Signals, I imagine the Signal approach will be implemented
    a lot as well. But when you have a larger application where the state is used
    in a lot of components and services, you will run into issues with our current
    implementation. In the next section, you will learn about these issues and how
    to resolve them.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的两个状态管理解决方案对于具有相对简单全局状态的小型应用程序都表现良好。RxJS 方法得到了广泛实现，随着 Signals 的普及，我想 Signal
    方法也将得到广泛实现。但是，当你有一个较大的应用程序，其中状态在许多组件和服务中使用时，你将遇到我们当前实现的问题。在下一节中，你将了解这些问题以及如何解决它们。
- en: The problem with using RxJS or Signals for global state management
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 RxJS 或 Signals 进行全局状态管理的问题
- en: 'While our current state management solution is used in many applications and
    works well for our current application, there’s a huge problem: our current global
    state management solution isn’t immutable.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们当前的状态管理解决方案被用于许多应用程序并且对我们的当前应用程序表现良好，但存在一个巨大的问题：我们当前的全局状态管理解决方案不是不可变的。
- en: You cannot modify your `BehaviorSubject` classes or Signals from outside the
    store, so in that sense, it is immutable. Also, when using primitive values for
    your state, the state itself is immutable. However, when you’re using reference
    objects as values for your `BehaviorSubject` classes or Signals, the state itself
    isn’t immutable.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能从存储外部修改你的 `BehaviorSubject` 类或 Signals，因此从这个意义上说，它是不可变的。此外，当使用原始值作为状态时，状态本身也是不可变的。然而，当你使用引用对象作为
    `BehaviorSubject` 类或 Signals 的值时，状态本身并不是不可变的。
- en: When you use an array or object for your state and retrieve the state through
    `BehaviorSubject` or `Signal`, you can modify the value of the state unintentionally.
    When you adjust the retrieved state object within a component or service class,
    the value of `BehaviorSubject` or `Signal` is also modified!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用数组或对象作为你的状态，并通过 `BehaviorSubject` 或 `Signal` 检索状态时，你可能会无意中修改状态值。当你在一个组件或服务类中调整检索到的状态对象时，`BehaviorSubject`
    或 `Signal` 的值也会被修改！
- en: This is also the reason why we used the `structuredClone()` function inside
    our `mapExpenses()` function. If you remove `structuredClone()` and toggle the
    VAT a couple of times in the view, you will notice that the amounts keep increasing
    instead of adding and removing the VAT. This happens because we modify the object
    inside `Signal` or `BehaviorSubject` whenever we adjust it inside the facade service.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是我们在 `mapExpenses()` 函数内部使用 `structuredClone()` 函数的原因。如果你移除 `structuredClone()`
    并在视图中切换增值税几次，你会注意到金额持续增加，而不是添加和移除增值税。这是因为我们每次在门面服务内部调整对象时，都会在 `Signal` 或 `BehaviorSubject`
    内部修改对象。
- en: The next time we retrieve the state, it still has the adjusted values instead
    of the real state we expect. Relying on developers to always clone the object
    when it’s modified is risky and not how you want it to be.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 下次我们检索状态时，它仍然具有调整后的值，而不是我们期望的真实状态。依赖开发者始终在修改对象时进行克隆是危险的，这不是你想要的方式。
- en: Allowing your state to be modified outside the store and without calling the
    `next()` or `set()` method on `BehaviorSubject` or `Signal` opens the door for
    unintended state changes, resulting in a corrupted state. When your state is not
    what you expect it to be, you can display incorrect values to the user and perform
    actions within your code that aren’t intended.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 允许你的状态在商店外部被修改，且没有在 `BehaviorSubject` 或 `Signal` 上调用 `next()` 或 `set()` 方法，这为意外的状态变化打开了大门，导致状态损坏。当你的状态不是你所期望的那样时，你可能会向用户显示错误的数据，并在你的代码中执行非预期的操作。
- en: For small applications where the state isn’t used in many places, this might
    be a manageable problem, but when your application grows, your state is used in
    multiple places and often the retrieved state is modified locally, so the problem
    will surface quickly.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些状态在多处不常被使用的小型应用来说，这可能是一个可管理的问题，但当你的应用增长，状态在多个地方被使用，并且经常在本地修改检索到的状态时，问题会迅速显现。
- en: 'To have a state management system that is truly immutable, reactive, and can
    handle the state of any application no matter how large it becomes, your best
    bet is to go with a good library that focuses on state management. Some popular
    choices within the Angular community are as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要有一个真正不可变、响应式且可以处理任何应用状态（无论它变得多大）的状态管理系统，你的最佳选择是选择一个专注于状态管理的优秀库。Angular 社区中的一些流行选择如下：
- en: NgRx
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NgRx
- en: NgXs
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NgXs
- en: RxAngular
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxAngular
- en: Akita
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 狗
- en: Angular Query
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular Query
- en: All of these libraries have their advantages and disadvantages. My personal
    favorites are RxAngular, NgXs, and NgRx. NgRx is by far the most commonly used
    state management solution within the community and offers support for Observable
    and Signal-based state management. RxAngular is gaining a lot of popularity and
    has a very intuitive approach for reactively managing state with little to no
    boilerplate code; it also enables you to ditch ZoneJS and boost the performance
    of your application.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些库都有它们的优缺点。我个人的最爱是 RxAngular、NgXs 和 NgRx。NgRx 是社区中最常用的状态管理解决方案，它提供了基于 Observable
    和 Signal 的状态管理支持。RxAngular 正在获得越来越多的关注，它以非常直观的方式管理状态，几乎不需要样板代码；它还允许你放弃 ZoneJS，提高你应用的性能。
- en: In the next section, we will convert our state management solution into an NgRx
    state management solution. I’ve picked NgRx because this is the most commonly
    used solution, but I recommend that you investigate some of the other solutions.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将把我们的状态管理解决方案转换为 NgRx 状态管理解决方案。我选择 NgRx 是因为它是最常用的解决方案，但我建议你调查一些其他解决方案。
- en: Handling global application state with NgRx
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 NgRx 处理全局应用状态
- en: When working on enterprise software or an application with extensive or complex
    state management, you should use a battle-tested state management solution that
    provides true immutability, unidirectional data flow, and good tools to perform
    side effects and modify the state securely. The best way forward is to use a battle-tested
    library that focuses on state management.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在开发企业软件或具有广泛或复杂状态管理的应用程序时，您应该使用经过实战检验的状态管理解决方案，该解决方案提供真正的不可变性、单向数据流以及良好的工具来执行副作用并安全地修改状态。最佳做法是使用专注于状态管理的经过实战检验的库。
- en: 'The most commonly used library for state management within the Angular community
    is **NgRx**; it has a huge community and all the tools you might need to handle
    even the most complex state. NgRx implements the Redux pattern and consists of
    four main building blocks: actions, reducers, selectors, and effects.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 社区中，最常用的状态管理库是 **NgRx**；它拥有庞大的社区和您可能需要的所有工具来处理最复杂的状态。NgRx 实现了 Redux
    模式，并包含四个主要构建块：actions、reducers、selectors 和 effects。
- en: In this section, we will change our custom-made state management solution so
    that it uses NgRx. We will keep the store file we made in the previous section
    for reference purposes and build the NgRx state management in new files.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将修改我们自定义的状态管理解决方案，使其使用 NgRx。我们将保留上一节中创建的存储文件作为参考，并在新文件中构建 NgRx 状态管理。
- en: In a production environment, you should remove the old unused store file. Inside
    the facade service, we will simply replace the current implementation with the
    NgRx implementation, and this time, we will not adjust the `IExpensesFacade` interface,
    meaning we do not have to change our component layer. Let’s go over the step-by-step
    process of implementing NgRx state management.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，您应该删除旧的未使用存储文件。在门面服务中，我们将简单地用 NgRx 实现替换当前实现，这次我们不会调整 `IExpensesFacade`
    接口，这意味着我们不需要更改我们的组件层。让我们回顾一下实现 NgRx 状态管理的逐步过程。
- en: Installing the @ngrx/store and @ngrx/effects packages
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 @ngrx/store 和 @ngrx/effects 包
- en: 'To start implementing NgRx state management, you need to install some packages
    by running the following `npm` commands in the root of your *Nx monorepo*:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始实现 NgRx 状态管理，您需要通过在您的 *Nx monorepo* 根目录中运行以下 `npm` 命令来安装一些包：
- en: '[PRE44]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: After installing the `@ngrx/store` and `@ngrx/effects` packages, you need to
    create some folders and files. There is an Nx generator to create the initial
    setup for your NgRx store, but we will set up everything manually so that you
    get a better understanding of how everything works and what’s needed when using
    NgRx.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了 `@ngrx/store` 和 `@ngrx/effects` 包之后，您需要创建一些文件夹和文件。有一个 Nx 生成器可以为您创建 NgRx
    存储的初始设置，但我们将手动设置一切，以便您更好地理解一切是如何工作的，以及在使用 NgRx 时需要什么。
- en: 'Start by creating a folder named `state` inside the `lib` folder of the expenses
    data-access library (next to the `stores` folder). Inside the newly created `state`
    folder, create another folder named `expenses`. Now, inside the newly created
    `expenses` folder, create these five files:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 expenses 数据访问库的 `lib` 文件夹内创建一个名为 `state` 的文件夹（位于 `stores` 文件夹旁边）。在新建的 `state`
    文件夹内，创建另一个名为 `expenses` 的文件夹。现在，在新建的 `expenses` 文件夹内，创建以下五个文件：
- en: '`expenses.actions.ts`'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expenses.actions.ts`'
- en: '`expenses.reducers.ts`'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expenses.reducers.ts`'
- en: '`expenses.selectors.ts`'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expenses.selectors.ts`'
- en: '`expenses.effects.ts`'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expenses.effects.ts`'
- en: '`index.ts`'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.ts`'
- en: When you’re done creating the folders and files, you can start adding some actions
    inside the `expenses.actions.ts` file.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成文件夹和文件的创建后，您可以在 `expenses.actions.ts` 文件内添加一些动作。
- en: Defining your first NgRx actions
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义您的第一个 NgRx 动作
- en: '`createAction()` function, which the `@ngrx/store` package exposes to you.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`createAction()` 函数，这是 `@ngrx/store` 包向您暴露的。'
- en: You must provide the `createAction()` function with a description of the action
    and, optionally, with a `props()` function to define the properties you have to
    provide the action with to perform the action.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须向 `createAction()` 函数提供动作的描述，并且可选地提供一个 `props()` 函数来定义您必须提供给动作以执行动作的属性。
- en: 'Alternatively, you can use the `createActionGroup()` function to create multiple
    events and group them under a single constant. We won’t use the `createActionGroup()`
    function, but you can always read about it yourself in the official NgRx documentation:
    [https://ngrx.io/docs](https://ngrx.io/docs).'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用 `createActionGroup()` 函数来创建多个事件并将它们组合成一个单独的常量。我们不会使用 `createActionGroup()`
    函数，但您始终可以在官方 NgRx 文档中阅读有关它的信息：[https://ngrx.io/docs](https://ngrx.io/docs)。
- en: 'We’ll start with a simple task: defining an action to fetch the expenses from
    the API. You don’t have to provide any argument to fetch the expenses, so the
    action will only contain a description. The descriptions of NgRx actions commonly
    use the following naming conventions:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一项简单的任务开始：定义一个从 API 获取费用的动作。你不需要提供任何参数来获取费用，因此该动作将只包含一个描述。NgRx 动作的描述通常使用以下命名约定：
- en: '[PRE45]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Inside the `expenses.actions.ts` file, define the action to fetch expenses,
    like so:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `expenses.actions.ts` 文件内，定义获取费用的动作，如下所示：
- en: '[PRE46]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Commonly, when defining NgRx actions that include API requests, you also define
    a success and failure action. So, go ahead and define an action for when fetching
    the expenses succeeds or fails:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当定义包含 API 请求的 NgRx 动作时，你也会定义一个成功和失败的动作。所以，继续定义一个在获取费用成功或失败时的动作：
- en: '[PRE47]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, we declared two actions; both received a description, and the `fetchExpensesSuccess`
    action also received the `props()` function. Inside the arrow brackets, we defined
    the type of the `props()` function – in this case, an object with an `expenses`
    property containing an `ExpenseModel` array. The `fetchExpensesSuccess` action
    needs `expenses` as `props()` because we will use the `fetchExpensesSuccess` action
    to update the state with the expenses that are retrieved from the API request.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了两个动作；它们都接收了一个描述，而 `fetchExpensesSuccess` 动作还接收了 `props()` 函数。在箭头括号内，我们定义了
    `props()` 函数的类型——在这种情况下，一个包含 `expenses` 属性的 `ExpenseModel` 数组的对象。`fetchExpensesSuccess`
    动作需要 `expenses` 作为 `props()`，因为我们将使用 `fetchExpensesSuccess` 动作来更新状态，以包含从 API 请求中检索到的费用。
- en: 'Now that you’ve added the `fetchExpenses`, `fetchExpensesSuccess`, and `fetch`
    **ExpensesFailed** actions, let’s update the `index.ts` file inside the `state/expenses`
    folder by defining an export for our expense actions:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经添加了 `fetchExpenses`、`fetchExpensesSuccess` 和 `fetch ExpensesFailed` 动作，让我们更新
    `state/expenses` 文件夹内的 `index.ts` 文件，通过定义我们的费用动作的导出：
- en: '[PRE48]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: After adding the export to the `index.ts` file, we can move on to the next piece
    of the puzzle. The next step is to create an NgRx effect that will make an API
    request to fetch the expenses and dispatch the success of the failed action accordingly.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在将导出添加到 `index.ts` 文件后，我们可以继续下一个难题。下一步是创建一个 NgRx 效果，该效果将向 API 发送请求以获取费用，并相应地分发成功或失败的动作。
- en: Creating your first NgRx effect
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建你的第一个 NgRx 效果
- en: You will create your `expenses.effects.ts` file. Effects allow you to perform
    side effects when an action is dispatched. Effects are commonly used for tasks
    such as fetching data, dispatching other events, or updating local storage. Side
    effects isolate some logic away from your components, allowing you to keep the
    component classes as simple as possible.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建你的 `expenses.effects.ts` 文件。效果允许你在动作分发时执行副作用。效果通常用于执行数据获取、分发其他事件或更新本地存储等任务。副作用将一些逻辑从组件中隔离出来，使组件类尽可能简单。
- en: The first effect you will create is the `fetchExpeses$` effect. This effect
    will run whenever the `fetchExpenses` action is dispatched. The effect will then
    make an API request to fetch the expenses and map the result of the API call into
    a newly dispatched action – the `fetchExpensesSuccess` or `fetchExpensesFailed`
    action.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建的第一个效果是 `fetchExpeses$` 效果。每当 `fetchExpenses` 动作被分发时，此效果将会运行。然后，该效果将向 API
    发送请求以获取费用，并将 API 调用的结果映射到一个新分发的动作——`fetchExpensesSuccess` 或 `fetchExpensesFailed`
    动作。
- en: 'To get started, create an injectable class inside the `expenses.effects.ts`
    file named `ExpensesEffects`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，在 `expenses.effects.ts` 文件内创建一个名为 `ExpensesEffects` 的可注入类：
- en: '[PRE49]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'After creating the `ExpensesEffects` class, you need to inject the `Actions`
    class from `@ngrx/effects` and `ExpensesHttpService` inside your `ExpensesEffects`
    class:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `ExpensesEffects` 类之后，你需要在 `ExpensesEffects` 类中注入来自 `@ngrx/effects` 的 `Actions`
    类和 `ExpensesHttpService`：
- en: '[PRE50]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, use the `createEffect()` function that’s exposed by `@ngrx/effects` to
    create your first effect:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 `@ngrx/effects` 提供的 `createEffect()` 函数创建你的第一个效果：
- en: '[PRE51]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the preceding code snippet, you created your first effect named `fetchExpenses$`.
    As you can see, there is quite a lot going on there, so let’s break it down line
    by line.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你创建了第一个名为 `fetchExpenses$` 的效果。正如你所见，那里有很多事情在进行，所以让我们逐行分析。
- en: We started by defining a property named `fetchExpenses$` and assigned it with
    the `createEffect()` function. Inside the `createEffect()` function, we defined
    a `callback` function that returns the `this.actions.pipe()` method. The `this.actions`
    instance refers to the `Actions` class we injected in the previous code block.
    The `Actions` class emits the actions we dispatched and extends the Observable
    class, meaning you can use the RxJS `pipe()` function on the class.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了一个名为 `fetchExpenses$` 的属性，并将其分配给 `createEffect()` 函数。在 `createEffect()`
    函数中，我们定义了一个返回 `this.actions.pipe()` 方法的 `callback` 函数。`this.actions` 实例指的是我们在前面的代码块中注入的
    `Actions` 类。`Actions` 类发出我们派发的动作，并扩展了 Observable 类，这意味着你可以在类上使用 RxJS 的 `pipe()`
    函数。
- en: Inside the `pipe()` function’s chained-on actions, we defined a couple of operators,
    starting with the `ofType()` operator. The `ofType()` operator is a filter operator
    that filters out actions by the action type. Inside the function brackets of the
    `ofType()` operator, you defined the type of an action. In our case, we provided
    it with the type of our `fetchExpenses` action. Here, `ExpenseAction` is used
    to export and import our actions, `fetchExpenses` is the property name we gave
    our action, and `type` is a property that’s exposed on all the actions we created
    with the `createAction()` function.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `pipe()` 函数的链式动作中，我们定义了一些操作符，从 `ofType()` 操作符开始。`ofType()` 操作符是一个过滤器操作符，它通过动作类型过滤动作。在
    `ofType()` 操作符的函数括号内，你定义了动作的类型。在我们的例子中，我们向它提供了 `fetchExpenses` 动作的类型。在这里，`ExpenseAction`
    用于导出和导入我们的动作，`fetchExpenses` 是我们赋予动作的属性名，而 `type` 是一个属性，它暴露在我们使用 `createAction()`
    函数创建的所有动作上。
- en: Whenever the `fetchExpenses` action is dispatched, we will move on to the next
    operator inside the `pipe()` function of our effect. The next operator is the
    `switchMap()` operator, which is used to flatten the additional Observable stream
    that was created by the HTTP request to fetch the expenses.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 每当派发 `fetchExpenses` 动作时，我们将继续在效果函数的 `pipe()` 函数中的下一个操作符。下一个操作符是 `switchMap()`
    操作符，它用于平铺由 HTTP 请求获取费用所创建的附加 Observable 流。
- en: Inside the callback of the `switchMap()` operator, we made the HTTP request
    and added an additional `pipe()` function to the HTTP request. Inside the `pipe()`
    function of the HTTP request, we used the `map()` operator to map a successful
    HTTP response to the `fetchExpensesSuccess` action, and we provided the `fetchExpensesSuccess`
    action with the expenses that were retrieved from the API response. If the API
    request fails, we use the `catchError` operator to map it to the `fetchExpensesFailed`
    action.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `switchMap()` 操作符的回调中，我们进行了 HTTP 请求，并将一个额外的 `pipe()` 函数添加到 HTTP 请求中。在 HTTP
    请求的 `pipe()` 函数中，我们使用了 `map()` 操作符将成功的 HTTP 响应映射到 `fetchExpensesSuccess` 动作，并将从
    API 响应中检索到的费用提供给 `fetchExpensesSuccess` 动作。如果 API 请求失败，我们使用 `catchError` 操作符将其映射到
    `fetchExpensesFailed` 动作。
- en: The `createEffect()` function will automatically dispatch the returned action;
    this is why we don’t have to call the `dispatch()` function explicitly but simply
    return an Observable with the action we want to dispatch. In our case, this is
    the `fetchExpensesSuccess` or `fetchExpensesFailed` action.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`createEffect()` 函数将自动派发返回的动作；这就是为什么我们不需要显式调用 `dispatch()` 函数，只需返回一个包含我们想要派发动作的
    Observable 即可。在我们的例子中，这是 `fetchExpensesSuccess` 或 `fetchExpensesFailed` 动作。'
- en: 'Lastly, you need to export the effects inside the `index.ts` file inside the
    `state/expenses` folder:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要将 `index.ts` 文件中的效果导出，该文件位于 `state/expenses` 文件夹内：
- en: '[PRE52]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now that we’ve defined the actions and created an effect to handle the `fetchExpenses`
    action and dispatch the `fetchExpensesSuccess` and `fetchExpensesFailed` actions,
    let’s cover the next building block of our NgRx state by creating our state and
    reducer functions.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了动作并创建了一个处理 `fetchExpenses` 动作并派发 `fetchExpensesSuccess` 和 `fetchExpensesFailed`
    动作的效果，让我们通过创建我们的状态和还原函数来覆盖我们 NgRx 状态的下一个构建块。
- en: Creating your initial state and first reducer functions
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建你的初始状态和第一个还原函数
- en: Now that you’ve created some actions and your first effect, you need a state
    to perform these actions on and `expenses.reducer.ts` file, you will define your
    initial state object and reducers to adjust the state when actions are dispatched.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了一些动作和第一个效果，你需要一个状态来执行这些动作，并在 `expenses.reducer.ts` 文件中，你将定义你的初始状态对象和还原器，以便在派发动作时调整状态。
- en: 'Start by creating a new interface for your state object inside the `expenses.interface.ts`
    file:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 `expenses.interface.ts` 文件中为你的状态对象创建一个新的接口：
- en: '[PRE53]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'After creating the interface, you can create your initial state object inside
    the `expenses.reducer.ts` file:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建接口之后，你可以在`expenses.reducer.ts`文件中创建你的初始状态对象：
- en: '[PRE54]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: After defining the interface and initial state object, you can create the reducer
    by using the `createReducer()` function. The `createReducer()` function takes
    in your initial state as a parameter and reduces your state based on dispatched
    actions.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了接口和初始状态对象之后，你可以使用`createReducer()`函数创建reducer。`createReducer()`函数接受你的初始状态作为参数，并根据分发动作来减少你的状态。
- en: 'Let’s start by defining the reducer function and providing it with the initial
    state:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义reducer函数并给它提供初始状态：
- en: '[PRE55]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the preceding code snippet, we created a property named `expensesReducer`
    and assigned it to the `createReducer()` function. Inside the arrow brackets,
    we provided the type the reducer will modify; in our case, this is the `ExpensesState`
    interface. Inside the function brackets, we provided the initial state object,
    `initialExpensesState`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了一个名为`expensesReducer`的属性，并将其分配给`createReducer()`函数。在箭头括号内，我们提供了reducer将修改的类型；在我们的例子中，这是`ExpensesState`接口。在函数括号内，我们提供了初始状态对象，`initialExpensesState`。
- en: 'Next, you need to add functions inside the `createReducer()` function to update
    the state when an action is dispatched, starting with the `fetchExpenses` action.
    To update the state, you must define an `on()` function and provide the `on()`
    function with a reference to the action it needs to react on, as well as a `callback`
    function to modify the state:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要在`createReducer()`函数内部添加函数，以便在分发动作时更新状态，从`fetchExpenses`动作开始。为了更新状态，你必须定义一个`on()`函数，并给`on()`函数提供它需要响应的动作的引用，以及一个`callback`函数来修改状态：
- en: '[PRE56]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here, we’ve added an `on()` function underneath the initial state object inside
    the `createReducer()` function. We provided the `on()` function with `ExpenseActions.fetchExpenses`
    so that it reacts when `fetchExpenses` actions are dispatched.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`createReducer()`函数内部初始状态对象下面添加了一个`on()`函数。我们给`on()`函数提供了`ExpenseActions.fetchExpenses`，以便在分发`fetchExpenses`动作时做出反应。
- en: After the reference to the action, we declare a `callback` function to modify
    the state. Inside the function brackets of the `callback` function, you can define
    a parameter that will be populated with the current state object for you; it’s
    the convention to name this parameter `state`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在动作引用之后，我们声明了一个`callback`函数来修改状态。在`callback`函数的函数括号内，你可以定义一个参数，它将填充当前状态对象供你使用；按照惯例，将此参数命名为`state`。
- en: Lastly, we return a new state object by spreading the current state into the
    object and setting the state properties we want to change. In the case of the
    `fetchExpenses` action, we only want to set the `isLoading` state property to
    `true`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过将当前状态扩展到对象中并设置我们想要更改的状态属性来返回一个新的状态对象。在`fetchExpenses`动作的情况下，我们只想将`isLoading`状态属性设置为`true`。
- en: 'Next, we can add the reducer function for the `fetchExpensesSuccess` and `fetch`
    **ExpensesFailed** actions underneath the `reducer` function for the `fetchExpenses`
    action:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在`fetchExpenses`动作的`reducer`函数下面添加`fetchExpensesSuccess`和`fetch ExpensesFailed`动作的reducer函数：
- en: '[PRE57]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, we’ve declared two more `on()` functions and provided them with the `fetchExpensesSuccess`
    and `fetchExpensesFailed` actions. Inside the function brackets of the `callback`
    function of the `fetchExpensesSuccess` action reducer, we used destructuring to
    extract the `expenses` object from the dispatched action. As you might remember,
    you defined the `fetchExpensesSuccess` action to take the expenses that were fetched
    from the API request as a parameter.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了两个额外的`on()`函数，并给它们提供了`fetchExpensesSuccess`和`fetchExpensesFailed`动作。在`fetchExpensesSuccess`动作reducer的`callback`函数的函数括号内，我们使用了解构来从分发动作中提取`expenses`对象。你可能还记得，你定义了`fetchExpensesSuccess`动作，以便将API请求获取的支出作为参数。
- en: Next, inside the `callback` function, we updated the `expenses` property of
    the state, set `isLoading` to `false`, and set `error` to `null`. If we fetch
    the `expenses` property successfully, there will be no errors to show to the user.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`callback`函数内部，我们更新了状态中的`expenses`属性，将`isLoading`设置为`false`，并将`error`设置为`null`。如果我们成功获取`expenses`属性，将不会向用户显示任何错误。
- en: For `fetchExpensesFailed`, we don’t provide parameters when we dispatch the
    action, so we only provide the state object in the callback, just like we did
    with the `fetchExpenses` action reducer. Inside the callback of the `fetchExpensesFailed`
    reducer, we set `isLoading` to `false` and set an error message.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`fetchExpensesFailed`，我们在分发动作时没有提供参数，所以我们只提供状态对象到回调中，就像我们在`fetchExpenses`动作reducer中所做的那样。在`fetchExpensesFailed`reducer的回调中，我们将`isLoading`设置为`false`并设置一个错误消息。
- en: With that, you’ve created your initial state and a `reducer` function for each
    of the actions you defined. When the `fetchExpenses` action is dispatched, you
    use a `reducer` function to set the `isLoading` state to `true`. When you’re done
    fetching, and the `fetchExpensesSuccess` or `fetchExpensesFailed` action is dispatched,
    you use a `reducer` function to set the `isLoading` state to `false` and update
    the `expenses` or `error` state accordingly. You can use the `isLoading` state
    to show a spinner, the `error` state to show an error message, and `expenses`
    to display your list of expenses.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您已经创建了初始状态，并为您定义的每个动作创建了一个`reducer`函数。当`fetchExpenses`动作被分发时，您使用`reducer`函数将`isLoading`状态设置为`true`。当您完成获取后，并且`fetchExpensesSuccess`或`fetchExpensesFailed`动作被分发时，您使用`reducer`函数将`isLoading`状态设置为`false`，并相应地更新`expenses`或`error`状态。您可以使用`isLoading`状态来显示加载指示器，使用`error`状态来显示错误消息，以及使用`expenses`来显示您的费用列表。
- en: 'Now, underneath `expensesReducer`, you need to define a unique key for the
    expenses state:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`expensesReducer`下面，您需要为`expenses`状态定义一个唯一的键：
- en: '[PRE58]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As a last step, you need to add the reducer file inside the `index.ts` file:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，您需要在`index.ts`文件内添加reducer文件：
- en: '[PRE59]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'After exporting the file inside the `index.ts` file, your reducer file is ready.
    Before moving on to the last building block of NgRx state management, which is
    selectors, we will add our reducer to the `ApplicationConfig` object of our `expenses-registration`
    app. Inside the `app.config.ts` file, add the following inside the `providers`
    array:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在导出`index.ts`文件内部之后，您的reducer文件就准备好了。在继续到NgRx状态管理的最后一个构建块——选择器之前，我们将我们的reducer添加到`expenses-registration`应用的`ApplicationConfig`对象中。在`app.config.ts`文件中，在`providers`数组内添加以下内容：
- en: '[PRE60]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the preceding code, we added the `provideStore()` function and the `provideState()`
    function inside the `providers` array. Inside the `provideState()` function, we
    added an object with a name and a `reducer` property. The name receives the unique
    key we provided inside the reducer file and the `reducer` property receives the
    `expensesReducer` function.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在`providers`数组内添加了`provideStore()`函数和`provideState()`函数。在`provideState()`函数内部，我们添加了一个包含名称和`reducer`属性的对象。名称接收我们在reducer文件内部提供的唯一键，而`reducer`属性接收`expensesReducer`函数。
- en: 'Now that you’ve created the reducer and added the configuration inside the
    `ApplicationConfig` object, it’s time to move on to the last part of our NgRx
    state: selectors.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经创建了reducer并在`ApplicationConfig`对象中添加了配置，现在是时候继续我们的NgRx状态的最后部分：选择器。
- en: Defining NgRx selectors
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义NgRx选择器
- en: '`expenses` state:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`expenses`状态：'
- en: '[PRE61]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here, we used a `createFeatureSelector()` function and provided it with the
    key we declared inside the `expenses.reducer.ts` file. Next, we can define additional
    selectors with the `createSelector()` function to retrieve specific parts of the
    `expenses` state:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了一个`createFeatureSelector()`函数，并向它提供了我们在`expenses.reducer.ts`文件内部声明的键。接下来，我们可以使用`createSelector()`函数定义额外的选择器，以检索`expenses`状态的具体部分：
- en: '[PRE62]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In the preceding code snippet, we declared three additional selectors – one
    to retrieve the `expenses` state, one to retrieve the `error` state, and one to
    retrieve the `isLoading` state. To finish the selectors, let’s export the file
    inside the `index.ts` file:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们声明了三个额外的选择器——一个用于检索`expenses`状态，一个用于检索`error`状态，还有一个用于检索`isLoading`状态。为了完成选择器，让我们在`index.ts`文件内部导出文件：
- en: '[PRE63]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'After adding this `export`, also export the `index.ts` file from your `state`
    folder; this can be found in the `index.ts` file of the `data-access` library:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加此`export`之后，还需要从您的`state`文件夹中导出`index.ts`文件；这个文件可以在`data-access`库的`index.ts`文件中找到：
- en: '[PRE64]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Now that we have all the parts of our NgRx state management system in place,
    it’s time to adjust the facade services.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将NgRx状态管理系统的所有部分都设置好了，是时候调整外观服务了。
- en: Adjusting the facade service so that they use NgRx state management
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整外观服务以使用NgRx状态管理
- en: 'We will adjust the `fetchExpenses` method and the `expenses` Signal inside
    the facade service. We haven’t created actions, effects, reducers, and selectors
    for all the other properties yet. To convert the facade service, we need to start
    by injecting the `Store` class, which is exposed to you by the `@``ngrx/store`
    package:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调整门面服务中的`fetchExpenses`方法和`expenses`信号。我们尚未为所有其他属性创建动作、效果、还原器和选择器。为了转换门面服务，我们需要首先注入`Store`类，该类由`@ngrx/store`包暴露给你：
- en: '[PRE65]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'After injecting the `Store` class, we can adjust the `fetchExpenses` function
    in the facade service. Simply remove `this.expensesStore.fetchExpenses()` inside
    the `fetchExpenses` function and dispatch the `fetchExpenses` action:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在注入`Store`类后，我们可以调整门面服务中的`fetchExpenses`函数。只需在`fetchExpenses`函数内部移除`this.expensesStore.fetchExpenses()`并分发`fetchExpenses`动作：
- en: '[PRE66]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Here, you used the `Store` class and called the `dispatch()` function on it
    to dispatch an action. After adjusting the `fetchExpenses()` method, it’s time
    to adjust the `expenses` computed Signal.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你使用了`Store`类，并在其上调用`dispatch()`函数来分发一个动作。调整`fetchExpenses()`方法后，是时候调整`expenses`计算信号了。
- en: Inside this computed Signal, we’re using the `expenses` `Subject` class from
    the store. We need to change this for a Signal based on `expenses` from your NgRx
    state.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个计算信号内部，我们使用来自存储的`expenses` `Subject`类。我们需要将其更改为基于你的NgRx状态的`expenses`信号。
- en: To adjust the `expenses` computed Signal, you need to create a new property
    to retrieve the `expenses` state from the NgRx state and transform it into a Signal.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调整`expenses`计算信号，你需要创建一个新的属性来从NgRx状态中检索`expenses`状态并将其转换为信号。
- en: 'We can retrieve `expenses` from the NgRx state through the `selectExpenses`
    selector using the `select()` method on the `Store` class. Using the `select()`
    method on the `Store` class combined with our selector will return the `expenses`
    state as an Observable, so we need to use the `toSignal()` function to transform
    it into a Signal:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`Store`类上使用`selectExpenses`选择器并调用`select()`方法来从NgRx状态中检索`expenses`。使用`Store`类上的`select()`方法和我们的选择器将返回`expenses`状态作为Observable，因此我们需要使用`toSignal()`函数将其转换为信号：
- en: '[PRE67]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now that we have the `expenses` state from the NgRx state as a Signal inside
    the facade service, we can adjust the `expenses` computed Signal so that it uses
    `expenses` from the NgRx state instead of `expenses` from the store. Simply replace
    the `this.expensesStore.expenses()` instances inside the computed Signal with
    `this.expensesSignal()` and that’s it.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从NgRx状态中获取了`expenses`状态，并在门面服务中作为一个信号，我们可以调整`expenses`计算信号，使其使用NgRx状态的`expenses`而不是存储中的`expenses`。只需将计算信号内部的`this.expensesStore.expenses()`实例替换为`this.expensesSignal()`即可。
- en: With that, you’ve changed everything you need to change and are fetching and
    retrieving the `expenses` state through the NgRx actions and state. Before moving
    on, let’s add one more piece of NgRx state together so that you can understand
    everything that’s going on in NgRx state management.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你已经更改了所有需要更改的内容，并且通过NgRx动作和状态来获取和检索`expenses`状态。在继续之前，让我们添加一个额外的NgRx状态，以便你可以理解NgRx状态管理中正在发生的一切。
- en: Adding additional actions, effects, reducers, and selectors
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加额外的动作、效果、还原器和选择器
- en: To get a better grasp of the NgRx state management we’ve built, let’s extend
    it a bit with additional actions, effects, reducers, and selectors.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地掌握我们构建的NgRx状态管理，让我们通过添加额外的动作、效果、还原器和选择器来扩展它。
- en: We will start by adding an action to adjust the `inclVat` state, just like we
    did before, by adding an action. Because the `inclVat` state only entails a state
    change and no HTTP request, you only need an action to adjust the `inclVat` state
    and no success and failed actions because you aren’t making an HTTP request that
    can succeed or fail. The action to adjust the `inclVat` state also doesn’t need
    a parameter because we will simply change the state to what it currently isn’t.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先添加一个动作来调整`inclVat`状态，就像我们之前做的那样，通过添加一个动作。因为`inclVat`状态只涉及状态变化而没有HTTP请求，所以你只需要一个动作来调整`inclVat`状态，不需要成功和失败的动作，因为你没有进行可能成功或失败的HTTP请求。调整`inclVat`状态的动作也不需要参数，因为我们只是将状态更改为它当前不是的状态。
- en: 'You can simply create an action and provide it with a description:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以简单地创建一个动作并为其提供一个描述：
- en: '[PRE68]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: No effect is needed for the `inclVat` state change because you don’t perform
    an HTTP request or need to dispatch additional actions. However, you do need a
    new reducer function inside the `expensesReducer` to adjust the state object.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`inclVat`状态更改不需要效果，因为你没有执行HTTP请求或需要分发额外的动作。然而，你确实需要在`expensesReducer`内部添加一个新的还原器函数来调整状态对象。
- en: 'Inside the `createReducer()` function of `expensesReducer`, add an additional
    `on()` function to change the `inclVat` state when the `adjustVat` action is dispatched:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在`expensesReducer`的`createReducer()`函数内部，添加一个额外的`on()`函数来改变`inclVat`状态，当`adjustVat`动作被分发时：
- en: '[PRE69]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'As you can see, upon dispatching the `adjustVat` action, we will change the
    `inclVat` state to what it currently isn’t. After adding the `reducer` function,
    you need to add a selector to retrieve the `inclVat` property from the state object:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在分发`adjustVat`动作后，我们将`inclVat`状态更改为它目前不是的状态。在添加`reducer`函数之后，你需要添加一个选择器来从状态对象中检索`inclVat`属性：
- en: '[PRE70]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now, the only thing that is left to do is adjust the facade service and use
    the `inclVat` property from the NgRx state instead of the Signal in `expenses.store.ts`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，唯一剩下要做的事情是调整外观服务，并使用NgRx状态中的`inclVat`属性而不是`expenses.store.ts`中的信号。
- en: 'To adjust the facade service, start by adding an `inclVat` property and use
    the `toSignal()` function to convert the `selectInclVat` selector into a Signal:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 要调整外观服务，首先添加一个`inclVat`属性，并使用`toSignal()`函数将`selectInclVat`选择器转换为信号：
- en: '[PRE71]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: After adding the `inclVat` property, all you have to do is change `this.expensesStore.inclVat()`
    to `this.inclVat()` inside the `expenses` computed Signal.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了`inclVat`属性之后，你只需在`expenses`计算信号内部将`this.expensesStore.inclVat()`更改为`this.inclVat()`即可。
- en: 'Lastly, you need to adjust the `adjustVat()` function inside the facade service.
    Remove what is currently in the function and replace it with a dispatch of the
    `adjustVat` action:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要调整外观服务中的`adjustVat()`函数。移除函数中的当前内容，并用分发`adjustVat`动作来替换它：
- en: '[PRE72]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: After adding the preceding code, you’ve made all necessary changes and you’re
    now using the `inclVat` property from the NgRx state instead of the Signal from
    `expenses.store.ts`. Now, all you need to do is add the rest of the actions, effects,
    reducers, and selectors so that you can remove the store from the facade service
    entirely and use the NgRx state for everything.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了前面的代码之后，你已经做出了所有必要的更改，现在你正在使用NgRx状态中的`inclVat`属性而不是`expenses.store.ts`中的信号。现在，你只需要添加剩余的动作、效果、还原器和选择器，这样你就可以完全从外观服务中移除存储，并使用NgRx状态来做所有事情。
- en: 'As an exercise, you can try to add the additional actions, effects, reducers,
    and selectors yourself based on what we did for the list of expenses. After adding
    the additional actions, effects, reducers, and selectors, you should be able to
    fully adjust the expenses facade and remove the store implementation completely.
    If you get stuck or simply want to copy the code, you can get it from this book’s
    GitHub repository: [https://github.com/PacktPublishing/Effective-Angular](https://github.com/PacktPublishing/Effective-Angular).'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，你可以尝试根据我们为费用列表所做的工作，自己添加额外的动作、效果、还原器和选择器。在添加了额外的动作、效果、还原器和选择器之后，你应该能够完全调整费用外观，并完全移除存储实现。如果你遇到了困难或者只是想复制代码，你可以从本书的GitHub仓库中获取：[https://github.com/PacktPublishing/Effective-Angular](https://github.com/PacktPublishing/Effective-Angular)。
- en: In this section, you explored NgRx and learned how to use it to manage the state
    of your application. We discussed the default NgRx implementation to manage the
    state. Note that the library has more solutions and packages to offer, but this
    is outside the scope of this book.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你探索了NgRx，并学习了如何使用它来管理你应用程序的状态。我们讨论了默认的NgRx实现来管理状态。请注意，该库还有更多解决方案和包可以提供，但这超出了本书的范围。
- en: Some of the other things NgRx has to offer are `signalStore` and `signalState`,
    two solutions that you can use to manage your state using NgRx and signals without
    having to convert Observables using `toSignal()`, which is what we did in this
    section. There are useful RxJS operators in the NgRx library. We only used the
    `ofType()` operators, but NgRx offers more utility operators, such as `concatLatestFrom()`
    and `tapResponse()`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: NgRx提供的一些其他功能包括`signalStore`和`signalState`，这两个解决方案你可以使用它们来管理你的状态，使用NgRx和信号而不必使用`toSignal()`转换Observables，这是我们在这个部分所做的工作。NgRx库中有有用的RxJS操作符。我们只使用了`ofType()`操作符，但NgRx还提供了更多实用操作符，例如`concatLatestFrom()`和`tapResponse()`。
- en: NgRx also offers solutions to manage component state and to dispatch actions
    of access state on route changes. I highly recommend exploring NgRx and other
    state management libraries on your own.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: NgRx 还提供了管理组件状态和在路由变更时分发访问状态动作的解决方案。我强烈建议你自己探索 NgRx 和其他状态管理库。
- en: Summary
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You’ve learned a lot in this chapter and brought everything we learned in [*Chapter
    7*](B21625_07.xhtml#_idTextAnchor129) together. You learned what state management
    is and why you need a good state management solution. You also learned about immutability,
    unidirectional data flow, and side effects. After some theory, you started building
    a state management solution using RxJS’s `BehaviorSubject` and `Subject` classes.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学到了很多，并将我们在 [*第7章*](B21625_07.xhtml#_idTextAnchor129) 中学到的所有内容结合起来。你学习了状态管理是什么以及为什么你需要一个好的状态管理解决方案。你还了解了不可变性、单向数据流和副作用。在理论学习之后，你开始使用
    RxJS 的 `BehaviorSubject` 和 `Subject` 类构建状态管理解决方案。
- en: When you finished building the state management solution using RxJS, you created
    a facade service that connects your component layer to the data-access and state
    management layers of your application. To end your custom state management solution,
    you converted the RxJS state implementation into a Signals implementation, further
    simplifying your component layer and facade service.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 RxJS 构建完状态管理解决方案后，你创建了一个门面服务，该服务将你的组件层连接到应用程序的数据访问和状态管理层。为了结束你的自定义状态管理解决方案，你将
    RxJS 的状态实现转换为 Signals 实现，进一步简化了你的组件层和门面服务。
- en: Finally, you learned about the shortcomings of using RxJS and Signals for your
    state management solution and replaced them with an NgRx implementation that uses
    actions, effects, reducers, and selectors.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你了解了使用 RxJS 和 Signals 作为你的状态管理解决方案的不足，并用 NgRx 实现替换了它们，该实现使用动作、效果、还原器和选择器。
- en: In the next chapter, you’ll learn how to improve the performance and security
    of your Angular applications.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何提高你的 Angular 应用程序的性能和安全性。
- en: Part 3:Getting Ready for Production with Automated Tests, Performance, Security,
    and Accessibility
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：使用自动化测试、性能、安全性和可访问性为生产做准备
- en: In the last part, you’ll learn how to improve the performance of your Angular
    applications and make them more secure and accessible for everyone. Starting with
    performance, you’ll do a deep dive into Angular’s change detection mechanism,
    learning how Angular detects changes and what actions you can take to reduce the
    number of change detection cycles. When you know how change detection works in
    detail, you’ll learn how to prevent other factors from impacting the performance
    of your Angular applications. Then, you will explore some common security risks
    when developing Angular applications and how to mitigate them. Furthermore, you’ll
    dive into accessibility, making your application content translatable using Transloco
    and learning how to develop applications accessible to users from different locations
    and abilities. Additionally, you’ll learn how to write and run unit tests using
    Jest, and end-to-end tests using Cypress, giving you the confidence to deploy
    your changes without breaking anything. Finally, you’ll make some final improvements,
    learn how to analyze and optimize your bundle sizes, and automate your deployment
    process.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一部分，你将学习如何提高你的 Angular 应用程序的性能，并使它们对每个人来说更加安全和易于访问。从性能开始，你将深入了解 Angular 的变更检测机制，学习
    Angular 如何检测变更以及你可以采取哪些行动来减少变更检测周期数。当你详细了解变更检测的工作原理后，你将学习如何防止其他因素影响你的 Angular
    应用程序的性能。然后，你将探讨在开发 Angular 应用程序时的一些常见安全风险以及如何减轻它们。此外，你将深入研究可访问性，使用 Transloco 使你的应用程序内容可翻译，并学习如何开发适用于来自不同地区和能力的用户的可访问应用程序。此外，你将学习如何使用
    Jest 编写和运行单元测试，以及使用 Cypress 进行端到端测试，这让你在部署更改时更有信心，而不会破坏任何东西。最后，你将进行一些最后的改进，学习如何分析和优化你的包大小，并自动化你的部署流程。
- en: 'This part includes the following chapters:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 9*](B21625_09.xhtml#_idTextAnchor170), *Enhancing the Performance
    and Security of Angular Applications*'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B21625_09.xhtml#_idTextAnchor170)，*增强 Angular 应用程序的性能和安全性*'
- en: '[*Chapter 10*](B21625_10.xhtml#_idTextAnchor185), *Internationalization, Localization,
    and Accessibility of Angular Applications*'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B21625_10.xhtml#_idTextAnchor185)，*Angular 应用程序的国际化和本地化以及可访问性*'
- en: '[*Chapter 11*](B21625_11.xhtml#_idTextAnchor200), *Testing Angular Applications*'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B21625_11.xhtml#_idTextAnchor200)，*测试 Angular 应用程序*'
- en: '[*Chapter 12*](B21625_12.xhtml#_idTextAnchor219), *Deploying Angular Applications*'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B21625_12.xhtml#_idTextAnchor219), *部署Angular应用程序*'
