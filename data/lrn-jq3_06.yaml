- en: Sending Data with Ajax
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ajax 发送数据
- en: 'The term **Asynchronous JavaScript and XML** (**Ajax**) was coined by *Jesse
    James Garrett* in 2005\. Since then, it has come to represent many different things,
    as the term encompasses a group of related capabilities and techniques. At its
    most basic level, an Ajax solution includes the following technologies:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 **Asynchronous JavaScript and XML**（**Ajax**）是由 *Jesse James Garrett* 在 2005
    年创造的。此后，它已经代表了许多不同的事物，因为该术语包含了一组相关的能力和技术。在其最基本的层次上，Ajax 解决方案包括以下技术：
- en: '**JavaScript**: This is used to capture interactions with the user or other
    browser-related events and to interpret the data from the server and present it
    on the page'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JavaScript**：用于捕获与用户或其他与浏览器相关的事件的交互，并解释来自服务器的数据并在页面上呈现它'
- en: '**XMLHttpRequest**: This allows requests to be made to the server without interrupting
    other browser tasks'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XMLHttpRequest**：这允许在不中断其他浏览器任务的情况下向服务器发出请求'
- en: '**Textual data:** The server provides data in a format such as XML, HTML, or
    JSON'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本数据：** 服务器提供的数据格式可以是 XML、HTML 或 JSON 等。'
- en: Ajax transforms static **web pages** into interactive **web applications**.
    Unsurprisingly, browsers are not entirely consistent with their implementations
    of the `XMLHttpRequest` object, but jQuery will assist us.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Ajax 将静态**网页**转变为交互式**网络应用程序**。毫不奇怪，浏览器在实现`XMLHttpRequest`对象时并不完全一致，但 jQuery
    会帮助我们。
- en: 'In this chapter, we will cover:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Loading data from the server without a page refresh
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不刷新页面的情况下从服务器加载数据
- en: Sending data from JavaScript in the browser back to the server
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从浏览器中的 JavaScript 发送数据回服务器
- en: Interpreting data in a variety of formats, including HTML, XML, and JSON
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释各种格式的数据，包括 HTML、XML 和 JSON
- en: Providing feedback to the user about the status of an Ajax request
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户提供有关 Ajax 请求状态的反馈
- en: Loading data on demand
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按需加载数据
- en: Ajax is just a means of loading data from the server into the web browser without
    a page refresh. This data can take many forms, and we have many options for what
    to do with it when it arrives. We'll see this by performing the same basic task,
    using different approaches.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Ajax 只是一种从服务器加载数据到网络浏览器中而无需刷新页面的方法。这些数据可以采用许多形式，而当数据到达时，我们有许多选项可以处理它。我们将通过使用不同的方法执行相同的基本任务来看到这一点。
- en: 'We are going to build a page that displays entries from a dictionary, grouped
    by the starting letter of the dictionary entry. The HTML defining the content
    area of the page will look like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个页面，显示按字典条目起始字母分组的条目。定义页面内容区域的 HTML 将如下所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Our page will have no content to begin with. We are going to use jQuery's various
    Ajax methods to populate this `<div>` tag with dictionary entries.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的页面一开始没有内容。我们将使用 jQuery 的各种 Ajax 方法来填充这个 `<div>` 标记，以显示字典条目。
- en: Getting the example code
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 获取示例代码
- en: You can access the example code from the following GitHub repository: [https://github.com/PacktPublishing/Learning-jQuery-3](https://github.com/PacktPublishing/Learning-jQuery-3).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下 GitHub 仓库访问示例代码：[https://github.com/PacktPublishing/Learning-jQuery-3](https://github.com/PacktPublishing/Learning-jQuery-3)。
- en: 'We''re going to need a way to trigger the loading process, so we''ll add some
    links for our event handlers to latch onto:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种触发加载过程的方法，所以我们将添加一些链接供我们的事件处理程序依附：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These simple links will lead us to pages that list the dictionary entries for
    that letter. We will use progressive enhancement to allow these links to manipulate
    the page without a full page load. With basic styling applied, this HTML will
    produce a page that looks like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的链接将带领我们到列出该字母字典条目的页面。我们将采用渐进式增强的方法，允许这些链接在不加载完整页面的情况下操作页面。应用基本样式后，这个 HTML
    将产生如下页面：
- en: '![](img/5297_06_01.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_06_01.png)'
- en: Now, we can focus on getting content onto the page.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以专注于将内容放到页面上。
- en: Appending HTML
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 追加 HTML
- en: 'Ajax applications are often no more than a request for a chunk of HTML. This
    technique, sometimes referred to as **Asynchronous HTTP and HTML** (**AHAH**),
    is almost simple to implement with jQuery. First, we need some HTML to insert,
    which we''ll place in a file called `a.html` alongside our main document. This
    secondary HTML file begins as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Ajax 应用程序通常不过是对一块 HTML 的请求。这种技术有时被称为 **Asynchronous HTTP and HTML**（**AHAH**），在
    jQuery 中几乎很容易实现。首先，我们需要一些要插入的 HTML，我们将其放置在一个名为 `a.html` 的文件中，与我们的主文档一起。这个辅助 HTML
    文件的开头如下：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The page continues with more entries in this HTML structure. Rendered on its
    own, `a.html` is quite plain:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 页面继续以这种 HTML 结构的更多条目。单独渲染的话，`a.html` 看起来相当简单：
- en: '![](img/5297_06_02.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_06_02.png)'
- en: 'Note that `a.html` is not a true HTML document; it contains no `<html>`, `<head>`,
    or `<body>`, all of which are normally required. We usually call such a file a
    *partial* or *fragment*; its only purpose is to be inserted into another HTML
    document, which we''ll do now:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`a.html` 不是一个真正的 HTML 文档；它不包含 `<html>`、`<head>` 或 `<body>`，这些通常是必需的。我们通常将这样的文件称为*部分*或*片段*；它的唯一目的是被插入到另一个
    HTML 文档中，我们现在将这样做：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Listing 6.1
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6.1 节
- en: 'The `.load()` method does all the heavy lifting for us. We specify the target
    location for the HTML snippet using a normal jQuery selector, and then pass the
    URL of the file to be loaded as a parameter. Now, when the first link is clicked
    on, the file is loaded and placed inside `<div id="dictionary">`. The browser
    will render the new HTML as soon as it is inserted:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`.load()` 方法为我们做了所有繁重的工作。我们使用普通的 jQuery 选择器指定 HTML 片段的目标位置，然后将要加载的文件的 URL 作为参数传递。现在，当单击第一个链接时，文件将被加载并放置在
    `<div id="dictionary">` 内。一旦插入新的 HTML，浏览器就会渲染它：'
- en: '![](img/5297_06_03.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_06_03.png)'
- en: Note that the HTML is now styled, whereas before it was plain. This is due to
    the CSS rules in the main document; as soon as the new HTML snippet is inserted,
    the rules apply to its elements as well.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 HTML 现在已经有样式了，而之前是原样呈现。这是由于主文档中的 CSS 规则；一旦插入新的 HTML 片段，规则也会应用于其元素。
- en: 'When testing this example, the dictionary definitions will probably appear
    instantaneously when the button is clicked on. This is a hazard of working on
    our applications locally; it is hard to account for delays or interruptions in
    transferring documents across the network. Suppose we added an alert box to display
    after the definitions are loaded:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试这个示例时，当单击按钮时，字典定义可能会立即出现。这是在本地工作应用程序时的一个危险；很难预测跨网络传输文档时的延迟或中断。假设我们添加一个警报框，在加载定义后显示：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Listing 6.2
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6.2 节
- en: We might assume from the structure of this code that the alert can only be displayed
    after the load has been performed. JavaScript execution is **synchronous**, working
    on one task after another in strict sequence.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会从这段代码的结构中假设警报只能在执行加载后显示。JavaScript 的执行是**同步**的，严格按顺序一个任务接一个任务执行。
- en: However, when this particular code is tested on a production web server, the
    alert will have come and gone before the load has completed, due to network lag.
    This happens because all Ajax calls are by default **asynchronous**. Asynchronous
    loading means that once the HTTP request to retrieve the HTML snippet is issued,
    script execution immediately resumes without waiting. Some time later, the browser
    receives the response from the server and handles it. This is the desired behavior;
    it is unfriendly to lock up the whole web browser while waiting for data to be
    retrieved.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当这段特定的代码在生产 Web 服务器上测试时，由于网络延迟，警报将在加载完成之前出现并消失。这是因为所有 Ajax 调用默认是**异步**的。异步加载意味着一旦发出检索
    HTML 片段的 HTTP 请求，脚本执行立即恢复而不等待。稍后，浏览器收到来自服务器的响应并处理它。这是期望的行为；锁定整个 Web 浏览器等待数据检索是不友好的。
- en: If actions must be delayed until the load has been completed, jQuery provides
    a callback for this. We've already seen callbacks in [Chapter 4](6544cf68-239c-4a0b-99f6-2d128dc5f7b1.xhtml),
    *Styling and Animating*, using them to execute actions after an effect has completed.
    Ajax callbacks perform a similar function, executing after data arrives from the
    server. We will use this capability in our next example, as you learn how to read
    JSON data from the server.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果必须延迟动作直到加载完成，jQuery 为此提供了一个回调函数。我们已经在[第 4 章](6544cf68-239c-4a0b-99f6-2d128dc5f7b1.xhtml)中看到了回调，在*样式和动画*中使用它们在效果完成后执行操作。Ajax
    回调执行类似的功能，在从服务器接收数据后执行。我们将在下一个示例中使用此功能，学习如何从服务器读取 JSON 数据。
- en: Working with JavaScript objects
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 JavaScript 对象
- en: Pulling in fully formed HTML on demand is very convenient, but it means having
    to transfer a lot of information about the HTML structure along with the actual
    content. There are times when we would rather transfer as little data as possible
    and process it after it arrives. In this case, we need to retrieve the data in
    a structure that we can traverse with JavaScript.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要按需获取完整形式的 HTML 非常方便，但这意味着必须传输有关 HTML 结构的大量信息以及实际内容。有时我们希望尽可能少地传输数据，并在数据到达后进行处理。在这种情况下，我们需要以
    JavaScript 可以遍历的结构检索数据。
- en: With jQuery's selectors, we could traverse the HTML we get back and manipulate
    it, but a native JavaScript data format involves less data to transfer and less
    code to process it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 借助 jQuery 的选择器，我们可以遍历获取的 HTML 并对其进行操作，但原生 JavaScript 数据格式涉及的数据量较少，处理起来的代码也较少。
- en: Retrieving JSON
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索 JSON
- en: As we have often seen, JavaScript objects are just sets of key-value pairs,
    and can be defined succinctly using curly braces (`{}`). JavaScript arrays, on
    the other hand, are defined on the fly with square brackets (`[]`) and have implicit
    keys, which are incrementing integers. Combining these two concepts, we can easily
    express some very complex and rich data structures.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们经常看到的那样，JavaScript 对象只是一组键值对，并且可以用花括号（`{}`）简洁地定义。另一方面，JavaScript 数组是用方括号（`[]`）即时定义的，并且具有隐式键，即递增整数。结合这两个概念，我们可以轻松表达一些非常复杂和丰富的数据结构。
- en: 'The term **JavaScript Object Notation** (**JSON**) was coined by *Douglas Crockford*
    to capitalize on this simple syntax. This notation can offer a concise alternative
    to the bulky XML format:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**JavaScript 对象表示法**（**JSON**）是由 *Douglas Crockford* 创造的，以利用这种简单的语法。这种表示法可以提供简洁的替代方法来替代臃肿的
    XML 格式：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: While based on JavaScript object literals and array literals, JSON is more prescriptive
    about its syntax requirements and more restrictive about the values it allows.
    For example, JSON specifies that all object keys, as well as all string values
    must be enclosed in double quotes. Also, functions are not valid JSON values.
    Because of its strictness, developers should avoid hand-editing JSON and instead
    rely on software such as a server-side script to format it properly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管基于 JavaScript 对象字面量和数组字面量，但 JSON 对其语法要求更具规范性，对其允许的值更具限制性。例如，JSON 指定所有对象键以及所有字符串值必须用双引号括起来。此外，函数不是有效的
    JSON 值。由于其严格性，开发人员应避免手动编辑 JSON，而应依赖于诸如服务器端脚本之类的软件来正确格式化它。
- en: For information on JSON's syntax requirements, some of its potential advantages
    and its implementations in many programming languages, visit [http://json.org/](http://json.org/).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 JSON 的语法要求、一些潜在优势以及它在许多编程语言中的实现的信息，请访问[http://json.org/](http://json.org/)。
- en: 'We can encode our data using this format in many ways. To illustrate one approach,
    we''ll place some dictionary entries in a JSON file that we''ll call `b.json`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以许多方式使用此格式对数据进行编码。为了说明一种方法，我们将一些字典条目放入一个名为 `b.json` 的 JSON 文件中：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To retrieve this data, we'll use the `$.getJSON()` method, which fetches the
    file and processes it. When the data arrives from the server, it is simply a text
    string in JSON format. The `$.getJSON()` method parses this string and provides
    the calling code with the resulting JavaScript object.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索此数据，我们将使用 `$.getJSON()` 方法，该方法获取文件并对其进行处理。当数据从服务器到达时，它只是一个 JSON 格式的文本字符串。`$.getJSON()`
    方法解析此字符串并向调用代码提供生成的 JavaScript 对象。
- en: Using global jQuery functions
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用全局 jQuery 函数
- en: Up until this point, all jQuery methods that we've used have been attached to
    a jQuery object that we've built with the `$()` function. The selectors have allowed
    us to specify a set of DOM nodes to work with, and the methods have operated on
    them in some way. This `$.getJSON()` function, however, is different. There is
    no logical DOM element to which it could apply; the resulting object has to be
    provided to the script, not injected into the page. For this reason, `getJSON()`
    is defined as a method of the global jQuery object (a single object called `jQuery`
    or `$` defined once by the `jQuery` library), rather than of an individual jQuery
    object instance (the object returned by the `$()` function).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的所有 jQuery 方法都附加在我们用 `$()` 函数构建的 jQuery 对象上。选择器允许我们指定一组要处理的 DOM 节点，并且这些方法以某种方式对其进行操作。然而，`$.getJSON()`
    函数是不同的。它没有逻辑 DOM 元素可以应用；结果对象必须提供给脚本，而不是注入到页面中。因此，`getJSON()` 被定义为全局 jQuery 对象的方法（由
    `jQuery` 库一次定义的单个对象，称为 `jQuery` 或 `$`），而不是单个 jQuery 对象实例的方法（由 `$()` 函数返回的对象）。
- en: If `$` were a class `$.getJSON()` would be a class method. For our purposes,
    we'll refer to this type of method as a **global function**; in effect, they are
    functions that use the `jQuery` namespace so as not to conflict with other function
    names.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `$` 是一个类 `$.getJSON()` 将是一个类方法。对于我们的目的，我们将把这种类型的方法称为**全局函数**；实际上，它们是使用 `jQuery`
    命名空间的函数，以避免与其他函数名称冲突。
- en: 'To use this function, we pass it the filename as before:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此函数，我们像以前一样将文件名传递给它：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Listing 6.3
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.3
- en: This code has no apparent effect when we click on the link. The function call
    loads the file, but we have not told JavaScript what to do with the resulting
    data. For this, we need to use a callback function.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们单击链接时，此代码似乎没有任何效果。函数调用加载文件，但我们还没有告诉 JavaScript 如何处理生成的数据。为此，我们需要使用回调函数。
- en: 'The `$.getJSON()` function takes a second argument, which is a function to
    be called when the load is complete. As mentioned earlier, Ajax calls are asynchronous,
    and the callback provides a way to wait for the data to be transmitted rather
    than executing code right away. The callback function also takes an argument,
    which is filled with the resulting data. So, we can write:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`$.getJSON()` 函数接受第二个参数，这是在加载完成时调用的函数。如前所述，Ajax 调用是异步的，回调提供了一种等待数据传输完成而不是立即执行代码的方法。回调函数还接受一个参数，其中填充了生成的数据。所以，我们可以写：'
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Listing 6.4
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.4
- en: 'Inside this function, we can use the `data` parameter to traverse the JSON
    structure as necessary. We''ll need to iterate over the top-level array, building
    the HTML for each item. We''ll use the `reduce()` method of the data array to
    turn it into an HTML string that we can then insert into the document. The `reduce()`
    method takes a function as an argument and returns a section of the result for
    each item of the array:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数内部，我们可以使用 `data` 参数根据需要遍历 JSON 结构。我们需要迭代顶级数组，为每个项目构建 HTML。我们将使用数据数组的 `reduce()`
    方法将其转换为 HTML 字符串，然后将其插入文档中。`reduce()` 方法接受一个函数作为参数，并为数组的每个项返回结果的一部分：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Listing 6.5
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.5
- en: We use a template string to build the HTML content for each array item. The
    `result` argument is the value from the previous array item. Using this approach,
    it's a lot easier to see the HTML structure than would otherwise be using string
    concatenation. Once all of the HTML has been built for each entry, we insert it
    into `<div id="dictionary">` with `.html()`, replacing anything that may have
    already been there.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用模板字符串来构建每个数组项的 HTML 内容。`result` 参数是上一个数组项的值。使用这种方法，通过字符串拼接，可以更容易地看到 HTML
    结构。一旦为每个条目构建了所有的 HTML，我们就用 `.html()` 将其插入到 `<div id="dictionary">` 中，替换可能已经存在的任何内容。
- en: Safe HTML
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 安全的 HTML
- en: This approach presumes that the data is safe for HTML consumption; it should
    not contain any stray `<` characters, for example.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法假定数据对 HTML 消费是安全的；例如，它不应该包含任何杂乱的 `<` 字符。
- en: 'All that''s left is to handle the entries with quotations, which we can accomplish
    by implementing a couple of helper functions that use the `reduce()` technique
    to build a string:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一剩下的就是处理带引号的条目，我们可以通过实现一对使用 `reduce()` 技术构建字符串的辅助函数来完成：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Listing 6.6
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.6
- en: 'With this code in place, we can click on the B link and confirm our results.
    The dictionary entries are displayed on the right-hand side of the page, as expected:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，我们可以单击 B 链接并确认我们的结果。词典条目如预期的那样显示在页面的右侧：
- en: '![](img/5297_06_04.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_06_04.png)'
- en: The JSON format is concise, but not forgiving. Every bracket, brace, quote,
    and comma must be present and accounted for, or the file will not load. In some
    cases, we won't even get an error message; the script will just silently fail.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 格式简洁，但并不宽容。每个括号、大括号、引号和逗号必须存在且被计算在内，否则文件将无法加载。在某些情况下，我们甚至不会收到错误消息；脚本会悄无声息地失败。
- en: Executing a script
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行脚本
- en: Occasionally, we don't want to retrieve all the JavaScript we will need when
    the page is first loaded. We might not know what scripts will be necessary until
    some user interaction occurs. We could introduce the `<script>` tags on the fly
    when they are needed, but a more elegant way to inject additional code is to have
    jQuery load the `.js` file directly.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们不希望在页面首次加载时检索到所有将需要的 JavaScript。在某些用户交互发生之前，我们可能不知道需要哪些脚本。我们可以在需要时动态引入
    `<script>` 标签，但更加优雅的注入附加代码的方法是让 jQuery 直接加载 `.js` 文件。
- en: 'Pulling in a script is about as simple as loading an HTML fragment. In this
    case, we use the `$.getScript()` function, which--like its siblings--accepts a
    URL locating the script file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取脚本与加载 HTML 片段一样简单。在这种情况下，我们使用 `$.getScript()` 函数，它——与其兄弟们一样——接受指向脚本文件的 URL：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Listing 6.7
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.7
- en: In our last example, we needed to process the result data so that we could do
    something useful with the loaded file. With a script file, though, the processing
    is automatic; the script is simply run.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最后一个示例中，我们需要处理结果数据，以便我们可以对加载的文件执行一些有用的操作。不过，对于脚本文件，处理是自动的；脚本只是简单地运行。
- en: 'Scripts that are fetched this way are run in the global context of the current
    page. This means they have access to all globally defined functions and variables,
    notably including jQuery itself. We can, therefore, mimic the JSON example to
    prepare and insert HTML on the page when the script is executed, and place this
    code in `c.js`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式获取的脚本在当前页面的全局上下文中运行。这意味着它们可以访问所有全局定义的函数和变量，特别是包括jQuery本身。因此，我们可以仿照JSON示例，在脚本执行时准备和插入HTML到页面上，并将此代码放在`c.js`中：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, clicking on the C link has the expected result, showing the appropriate
    dictionary entries.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击C链接会得到预期的结果，显示相应的字典条目。
- en: Loading an XML document
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载XML文档
- en: 'XML is part of the acronym Ajax, but we haven''t actually loaded any XML yet.
    Doing so is straightforward, and mirrors the JSON technique closely. First, we''ll
    need an XML file, `d.xml`, containing some data we wish to display:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: XML是Ajax首字母缩写的一部分，但我们实际上还没有加载任何XML。这样做很简单，而且与JSON技术非常相似。首先，我们需要一个XML文件，`d.xml`，其中包含我们希望显示的一些数据：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This data could be expressed in many ways, of course, and some would more closely
    mimic the structure we established for the HTML or JSON used earlier. Here, however,
    we're illustrating some of the features of XML designed to make it more readable
    to humans, such as the use of attributes for `term` and `part` rather than tags.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些数据可以用许多方式表达，有些方式更接近我们早期用于HTML或JSON的结构。然而，在这里，我们正在说明XML的一些特性，以使其对人类更加可读，例如使用`term`和`part`属性而不是标签。
- en: 'We''ll start off our function in a familiar manner:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以熟悉的方式开始我们的函数：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Listing 6.8
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.8
- en: This time, it's the `$.get()` function that does our work. In general, this
    function simply fetches the file at the supplied URL and provides the plain text
    to the callback. However, if the response is known to be XML because of its server-supplied
    MIME type, the callback will be handed to the XML DOM tree.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，是`$.get()`函数完成了我们的工作。通常，此函数只是获取所提供URL的文件，并将纯文本提供给回调函数。但是，如果由于其服务器提供的MIME类型而已知响应为XML，则回调函数将交给XML
    DOM树。
- en: 'Fortunately, as we have already seen, jQuery has substantial DOM-traversing
    capabilities. We can use the normal `.find()`, `.filter()`, and other traversal
    methods on the XML document just as we would on HTML:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，正如我们已经看到的，jQuery具有实质性的DOM遍历功能。我们可以像在HTML上一样在XML文档上使用正常的`.find()`、`.filter()`和其他遍历方法：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Listing 6.9
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.9
- en: 'This has the expected effect when the D link is clicked on:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击D链接时，这将产生预期的效果：
- en: '![](img/5297_06_05.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_06_05.png)'
- en: This is a new use for the DOM traversal methods we already know, shedding some
    light on the flexibility of jQuery's CSS selector support. CSS syntax is typically
    used to help beautify HTML pages, and thus selectors in standard `.css` files
    use HTML tag names such as `div` and `body` to locate content. However, jQuery
    can use arbitrary XML tag names, such as `entry` and `definition`, just as readily
    as the standard HTML ones.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们已经了解的DOM遍历方法的一种新用法，揭示了jQuery的CSS选择器支持的灵活性。CSS语法通常用于帮助美化HTML页面，因此标准`.css`文件中的选择器使用HTML标签名称（如`div`和`body`）来定位内容。然而，jQuery可以像标准HTML一样轻松地使用任意的XML标签名称，比如`entry`和`definition`。
- en: 'The advanced selector engine inside jQuery facilitates finding parts of the
    XML document in much more complicated situations as well. For example, suppose
    we wanted to limit the displayed entries to those that have quotes that, in turn,
    have attributed authors. To do this, we can limit the entries to those with the
    nested `<quote>` elements by changing `entry` to `entry:has(quote)`. Then, we
    can further restrict the entries to those with `author` attributes on the `<quote>`
    elements by writing `entry:has(quote[author])`. The line in *Listing 6.9* with
    the initial selector now reads:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery内部的高级选择器引擎使在更复杂的情况下找到XML文档的部分变得更加容易。例如，假设我们想将显示的条目限制为具有又带有作者的引用的条目。为此，我们可以通过将`entry`更改为`entry:has(quote)`来限制具有嵌套的`<quote>`元素的条目。然后，我们可以通过编写`entry:has(quote[author])`来进一步限制具有`<quote>`元素上的`author`属性的条目。现在，*列表
    6.9* 中的带有初始选择器的行如下所示：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This new selector expression restricts the returned entries correspondingly:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的选择器表达式相应地限制了返回的条目：
- en: '![](img/5297_06_06.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_06_06.png)'
- en: While we can use jQuery on XML data that's returned from the server, the downside
    is the size of our code has grown considerably.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在从服务器返回的XML数据上使用jQuery，但缺点是我们的代码量已经显著增长。
- en: Choosing a data format
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择数据格式
- en: We have looked at four formats for our external data, each of which is handled
    by jQuery's Ajax functions. We have also verified that all four can handle the
    task at hand, loading information onto an existing page when the user requests
    it and not before. How, then, do we decide which one to use in our applications?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经查看了四种用于外部数据的格式，每种格式都由 jQuery 的 Ajax 函数处理。我们还验证了所有四种格式都能够处理手头的任务，在用户请求时加载信息到现有页面上，并且在此之前不加载。那么，我们如何决定在我们的应用程序中使用哪种格式？
- en: '*HTML snippets* require very little work to implement. The external data can
    be loaded and inserted into the page with one simple method that doesn''t even
    require a callback function. No traversal of the data is necessary for the straightforward
    task of adding the new HTML into the existing page. On the other hand, the data
    is not necessarily structured in a way that makes it reusable for other applications.
    The external file is tightly coupled with its intended container.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*HTML 片段* 需要非常少的工作来实现。可以使用一个简单的方法将外部数据加载并插入到页面中，甚至不需要回调函数。对于简单的任务，添加新的 HTML
    到现有页面中不需要遍历数据。另一方面，数据的结构不一定适合其他应用程序重用。外部文件与其预期的容器紧密耦合。'
- en: '*JSON files* are structured for simple reuse. They are compact and easy to
    read. The data structure must be traversed to pull out the information and present
    it on the page, but this can be done with standard JavaScript techniques. Since
    modern browsers parse the files natively with a single call to `JSON.parse()`,
    reading in a JSON file is extremely fast. Errors in the JSON file can cause silent
    failure or even side effects on the page, so the data must be crafted carefully
    by a trusted party.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*JSON 文件* 结构化简单，易于重用。它们紧凑且易于阅读。必须遍历数据结构以提取信息并在页面上呈现，但这可以通过标准 JavaScript 技术完成。由于现代浏览器可以通过单个调用`JSON.parse()`原生解析文件，读取
    JSON 文件非常快速。JSON 文件中的错误可能导致静默失败，甚至在页面上产生副作用，因此数据必须由可信任的方进行精心制作。'
- en: '*JavaScript files* offer the ultimate in flexibility, but are not really a
    data storage mechanism. Since the files are language-specific, they cannot be
    used to provide the same information to disparate systems. Instead, the ability
    to load a JavaScript file means that behaviors that are rarely needed can be factored
    out into external files, reducing code size unless and until it is needed.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*JavaScript 文件* 提供了最大的灵活性，但实际上并不是一种数据存储机制。由于文件是特定于语言的，因此无法用于向不同的系统提供相同的信息。相反，加载
    JavaScript 文件的能力意味着很少需要的行为可以拆分到外部文件中，减少代码大小，直到需要为止。'
- en: While *XML* has fallen out of favor in the JavaScript community, with most developers
    preferring JSON, it is still so common that providing data in this format makes
    it very likely that the data can be reused elsewhere. The XML format is somewhat
    bulky, and can be a bit slower to parse and manipulate than other options.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 *XML* 在 JavaScript 社区中已经不再受欢迎，大多数开发人员更喜欢 JSON，但它仍然如此普遍，以至于以此格式提供数据很可能使数据在其他地方得到重用。XML
    格式有点臃肿，解析和操作速度可能比其他选项慢一些。
- en: With these characteristics in mind, it is typically easiest to provide external
    data as HTML snippets, as long as the data is not needed in other applications
    as well. In cases where the data will be reused but the other applications can
    also be influenced, JSON is often a good choice due to its performance and size.
    When the remote application is not known, XML may provide the greatest assurance
    that interoperability will be possible.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些特点，通常最容易将外部数据提供为 HTML 片段，只要数据不需要在其他应用程序中使用。在数据将被重用但其他应用程序也可能受到影响的情况下，由于其性能和大小，JSON
    通常是一个不错的选择。当远程应用程序未知时，XML 可能提供最大的保证，可以实现互操作性。
- en: More than any other consideration, we should determine if the data is already
    available. If it is, chances are that it's in one of these formats to begin with,
    so the decision may be made for us.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 比起其他任何考虑因素，我们应确定数据是否已经可用。如果是，那么很可能最初就是以其中一种这种格式呈现的，因此决策可能已经为我们做出。
- en: Passing data to the server
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向服务器传递数据
- en: Our examples to this point have focused on the task of retrieving static data
    files from the web server. However, the server can dynamically shape the data
    based on input from the browser. We're helped along by jQuery in this task as
    well; all of the methods we've covered so far can be modified so that data transfer
    becomes a two-way street.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的示例重点放在从 Web 服务器检索静态数据文件的任务上。但是，服务器可以根据来自浏览器的输入动态地塑造数据。在这项任务中，jQuery
    也为我们提供了帮助；我们迄今为止介绍的所有方法都可以修改，以便数据传输变成双向街道。
- en: Interacting with server-side code
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务器端代码交互
- en: Since demonstrating these techniques requires interaction with the web server,
    we'll need to use server-side code for the first time here. The examples given
    will use Node.js, which is very widely used as well as freely available. We will
    not cover any Node.js or Express specifics here, but there are plentiful resource
    on the web if you Google either of these technologies.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于演示这些技术需要与 Web 服务器进行交互，所以我们将在这里首次使用服务器端代码。给出的示例将使用 Node.js，它非常广泛使用并且免费提供。我们不会在这里涵盖任何
    Node.js 或 Express 的具体内容，但是如果你搜索这两项技术，网络上有丰富的资源可供参考。
- en: Performing a GET request
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行 GET 请求
- en: 'To illustrate the communication between client (using JavaScript) and server
    (also using JavaScript), we''ll write a script that only sends one dictionary
    entry to the browser on each request. The entry chosen will depend on a parameter
    sent from the browser. Our script will pull its data from an internal data structure
    like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明客户端（使用 JavaScript）与服务器（同样使用 JavaScript）之间的通信，我们将编写一个脚本，每次请求只向浏览器发送一个词典条目。所选择的条目将取决于从浏览器发送的参数。我们的脚本将从类似于这样的内部数据结构中获取数据：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In a production version of this example, the data would probably be stored
    in a database and loaded on demand. Since the data is a part of the script here,
    the code to retrieve it is quite straightforward. We examine the query string
    part of the URL, then pass the term and entry to a function that returns the HTML
    snippet to display:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例的生产版本中，数据可能会存储在数据库中，并根据需要加载。由于数据在这里是脚本的一部分，所以检索它的代码非常简单。我们检查 URL 的查询字符串部分，然后将术语和条目传递给一个返回
    HTML 片段以显示的函数：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, requests to this `/e` handler, will return the HTML snippet corresponding
    to the term that was sent in the GET parameters. For example, when accessing the
    handler with `/e?term=eavesdrop`, we get back:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对这个 `/e` 处理器的请求，将返回对应于在 GET 参数中发送的术语的 HTML 片段。例如，当使用 `/e?term=eavesdrop`
    访问处理器时，我们会得到：
- en: '![](img/5297_06_07.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_06_07.png)'
- en: Once again, we note the lack of formatting we saw with earlier HTML snippets,
    because CSS rules have not been applied.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意我们之前看到的 HTML 片段缺乏格式，因为尚未应用 CSS 规则。
- en: 'Since we''re showing how data is passed to the server, we will use a different
    method to request entries than the solitary buttons we''ve been relying on so
    far. Instead, we''ll present a list of links for each term, and cause a click
    on any of them to load the corresponding definition. The HTML we''ll add for this
    looks like the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在展示数据如何传递到服务器，所以我们将使用不同的方法来请求条目，而不是迄今为止所依赖的孤立按钮。相反，我们将为每个术语呈现一个链接列表，并且点击任何一个链接都将加载相应的定义。我们将添加以下
    HTML：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we need to get our frontend JavaScript code to call the backend JavaScript with
    the right parameters. We could do this with the normal `.load()` mechanism, appending
    the query string right to the URL and fetching data with addresses such as `e?term=eavesdrop`
    directly. Instead, though, we can have jQuery construct the query string based
    on an object we provide to the `$.get()` function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要让我们的前端 JavaScript 代码调用后端 JavaScript，并传递正确的参数。我们可以使用正常的 `.load()` 机制来做到这一点，直接将查询字符串附加到
    URL 并使用类似于 `e?term=eavesdrop` 的地址获取数据。但是，我们可以让 jQuery 根据我们提供给 `$.get()` 函数的对象构造查询字符串：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Listing 6.10
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.10
- en: 'Now that we have seen other Ajax interfaces that jQuery provides, the operation
    of this function seems familiar. The only difference is the second parameter,
    which allows us to supply an object containing keys and values that become part
    of the query string. In this case, the key is always `term`, but the value is
    taken from the text of each link. Now, clicking on the first link in the list
    causes its definition to appear:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到 jQuery 提供的其他 Ajax 接口，这个函数的操作看起来很熟悉。唯一的区别是第二个参数，它允许我们提供一个包含键和值的对象，这些键和值成为查询字符串的一部分。在这种情况下，键始终是
    `term`，但值是从每个链接的文本中获取的。现在，点击列表中的第一个链接会显示其定义：
- en: '![](img/5297_06_08.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_06_08.png)'
- en: All the links here have URLs, even though we are not using them in the code.
    To prevent the links from being followed normally when clicked on, we invoke the
    `.preventDefault()` method.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的所有链接都有 URL，即使我们在代码中没有使用它们。为了防止链接在点击时正常跟随，我们调用`.preventDefault()`方法。
- en: Return false or prevent default?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 false 还是阻止默认行为？
- en: When writing the `click` handlers in this chapter, we have chosen to use `e.preventDefault()`
    rather than ending the handler with `return false`. This practice is recommended
    when the default action would otherwise reload the page or load another page.
    If our `click` handler, for example, contains a JavaScript error, calling `.preventDefault()`
    on the handler's first line (before the error is encountered) ensures that the
    form will not be submitted, and our browser's error console will properly report
    the error. Remember from [Chapter 3](2036c6b0-e8c5-405a-b54b-b3f31eab404c.xhtml),
    *Handling Events*, that return `false` calls both `event.preventDefault()` and
    `event.stopPropagation()`. If we wanted to stop the event from bubbling, we would
    need to call the latter as well.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中编写 `click` 处理程序时，我们选择使用 `e.preventDefault()` 而不是以 `return false` 结束处理程序。当默认操作否则会重新加载页面或加载另一页时，建议采用这种做法。例如，如果我们的
    `click` 处理程序包含 JavaScript 错误，调用处理程序的第一行`.preventDefault()`（在遇到错误之前）确保表单不会被提交，并且我们浏览器的错误控制台将正确报告错误。请记住，从
    [第三章](2036c6b0-e8c5-405a-b54b-b3f31eab404c.xhtml) *处理事件*，`return false` 调用了 `event.preventDefault()`
    和 `event.stopPropagation()`。如果我们想要阻止事件冒泡，我们还需要调用后者。
- en: Serializing a form
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化表单
- en: Sending data to the server often involves the user filling out forms. Rather
    than relying on the normal form submission mechanism, which will load the response
    in the entire browser window, we can use jQuery's Ajax toolkit to submit the form
    asynchronously and place the response inside the current page.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据发送到服务器通常涉及用户填写表单。与其依赖于正常的表单提交机制，该机制将在整个浏览器窗口中加载响应，我们可以使用 jQuery 的 Ajax 工具包异步提交表单并将响应放置在当前页面中。
- en: 'To try this out, we''ll need to construct a simple form:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这个，我们需要构建一个简单的表单：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This time, we''ll return a set of entries from the server by having our `/f`
    handler search for the supplied search term as a substring of a dictionary term.
    We''ll use our `formatEntry()` function from the `/e` handler to return the data
    in the same format as before. Here''s the `/f` handler implementation:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们将通过使我们的 `/f` 处理程序搜索提供的搜索词作为字典词的子字符串来从服务器返回一组条目。我们将使用我们从 `/e` 处理程序 中的 `formatEntry()`
    函数以与之前相同的格式返回数据。以下是 `/f` 处理程序的实现：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we can react to a form submission and craft the proper query parameters
    by traversing the DOM tree:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以对表单提交做出反应，并通过遍历 DOM 树来制作正确的查询参数：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Listing 6.11
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6.11
- en: 'This code has the intended effect, but searching for input fields by name and
    appending them to a map one by one is cumbersome. In particular, this approach
    does not scale well as the form becomes more complex. Fortunately, jQuery offers
    a shortcut for this often-used idiom. The `.serialize()` method acts on a jQuery
    object and translates the matched DOM elements into a query string that can be
    passed along with an Ajax request. We can generalize our submission handler as
    follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码具有预期效果，但按名称搜索输入字段并逐个将其附加到地图中是繁琐的。特别是，随着表单变得更加复杂，这种方法的扩展性不佳。幸运的是，jQuery 提供了一个经常使用的惯用语的快捷方式。`.serialize()`
    方法作用于 jQuery 对象，并将匹配的 DOM 元素转换为可以与 Ajax 请求一起传递的查询字符串。我们可以将我们的提交处理程序概括如下：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Listing 6.12
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6.12
- en: 'The same script will work to submit the form, even as the number of fields
    increases. When we perform a search for `fid`, for example, the terms containing
    that substring are displayed as shown in the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的脚本将用于提交表单，即使字段数量增加。例如，当我们搜索 `fid` 时，包含该子字符串的术语会显示如下屏幕截图所示：
- en: '![](img/5297_06_10.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_06_10.png)'
- en: Keeping an eye on the request
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注意请求
- en: So far, it has been sufficient for us to make a call to an Ajax method and patiently
    await the response. At times, though, it is handy to know a bit more about the
    HTTP request as it progresses. If such a need arises, jQuery offers a suite of
    functions that can be used to register callbacks when various Ajax-related events
    occur.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只需调用一个 Ajax 方法并耐心等待响应就足够了。然而，有时候，了解 HTTP 请求在进行中的情况会很方便。如果出现这种需要，jQuery
    提供了一套函数，可以在发生各种与 Ajax 相关的事件时注册回调函数。
- en: The `.ajaxStart()` and `.ajaxStop()` methods are two examples of these observer
    functions. When an Ajax call begins with no other transfer in progress, the `.ajaxStart()`
    callback is fired. Conversely, when the last active request ends, the callback
    attached with `.ajaxStop()` will be executed. All of the observers are global,
    in that they are called when any Ajax communication occurs, regardless of what
    code initiates it. And all of them, can only be bound to `$(document)`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`.ajaxStart()` 和 `.ajaxStop()` 方法是这些观察者函数的两个示例。当没有其他传输正在进行时开始一个 Ajax 调用时，将触发
    `.ajaxStart()` 回调。相反，当最后一个活动请求结束时，将执行与 `.ajaxStop()` 绑定的回调。所有观察者都是全局的，它们在发生任何
    Ajax 通信时被调用，无论是什么代码启动的。而且所有这些观察者只能绑定到 `$(document)`。'
- en: 'We can use these methods to provide some feedback to the user in the case of
    a slow network connection. The HTML for the page can have a suitable loading message
    appended:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这些方法在网络连接缓慢的情况下向用户提供一些反馈。页面的 HTML 可以附加适当的加载消息：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This message is just a piece of arbitrary HTML; it could include an animated
    GIF image as a loading indicator, for instance. In this case, we''ll add a few
    simple styles to the CSS file so that when the message is displayed, the page
    will look like the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个消息只是一段任意的 HTML 代码；例如，它可以包含一个动画 GIF 图像作为加载指示器。在这种情况下，我们将在 CSS 文件中添加一些简单的样式，以便在显示消息时，页面看起来如下：
- en: '![](img/5297_06_11.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_06_11.png)'
- en: 'In keeping with the spirit of progressive enhancement, however, we won''t put
    this HTML markup directly on the page. Instead, we''ll insert it using jQuery:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了符合渐进增强的精神，我们不会直接将这个 HTML 标记放在页面上。相反，我们将使用 jQuery 插入它：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Our CSS file will give this `<div>` a `display: none;` style declaration so
    that the message is initially hidden. To display it at the right time, we just
    register it as an observer with `.ajaxStart()`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的 CSS 文件将给这个 `<div>` 添加一个 `display: none;` 的样式声明，以便最初隐藏消息。在适当的时候显示它，我们只需使用
    `.ajaxStart()` 将其注册为观察者：'
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can chain the hiding behavior right onto this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将隐藏行为链接在一起：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Listing 6.13
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.13
- en: We now have our loading feedback.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了加载反馈。
- en: Once again, note that these methods have no association with the particular
    ways in which the Ajax communications begin. The `.load()` method attached to
    the A link and the `.getJSON()` method attached to the B link both cause these
    actions to occur.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，这些方法与 Ajax 通信开始的具体方式无关。附加到 A 链接的 `.load()` 方法和附加到 B 链接的 `.getJSON()` 方法都会导致这些操作发生。
- en: In this case, this global behavior is desirable. If we need to get more specific,
    though, we have a few options at our disposal. Some of the observer methods, such
    as `.ajaxError()`, send their callback a reference to the `XMLHttpRequest` object.
    This can be used to differentiate one request from another and provide different
    behaviors. Other more specific handling can be achieved by using the low-level
    `$.ajax()` function, which we'll discuss a bit later.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这种全局行为是可取的。不过，如果我们需要更具体的行为，我们有几个选择。一些观察者方法，比如 `.ajaxError()`，会将它们的回调函数发送给
    `XMLHttpRequest` 对象的引用。这可以用于区分一个请求和另一个请求，并提供不同的行为。通过使用低级别的 `$.ajax()` 函数，我们可以实现其他更具体的处理，稍后我们会讨论这个函数。
- en: 'The most common way of interacting with the request is the `success` callback,
    which we have already covered. We have used this in several of our examples to
    interpret the data coming back from the server and to populate the page with the
    results. It can be used for other feedback too, of course. Consider once again
    our `.load()` example from *Listing 6.1*:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 与请求交互的最常见方式是 `success` 回调，我们已经介绍过了。我们在几个示例中使用它来解释从服务器返回的数据，并用结果填充页面。当然，它也可以用于其他反馈。再次考虑我们从
    *列表 6.1* 中的 `.load()` 示例：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can create a small enhancement here by making the loaded content fade into
    view rather than appear suddenly. The `.load()` method can take a callback to
    be fired on completion:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使加载的内容淡入而不是突然出现来进行一点小改进。`.load()` 方法可以接受一个回调函数在完成时被触发：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Listing 6.14
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.14
- en: First, we hide the target element and then initiate the load. When the load
    is complete, we use the callback to show the newly populated element by fading
    it in.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们隐藏目标元素，然后开始加载。加载完成后，我们使用回调函数将新填充的元素显示出来，以淡入的方式。
- en: Error handling
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: So far, we have only dealt with successful responses to Ajax requests, loading
    the page with new content when everything goes as planned. Responsible developers,
    however, should account for the possibility of network or data errors and report
    them appropriately. Developing Ajax applications in a local environment can lull
    developers into a sense of complacency since, aside from a possible mistyped URL,
    Ajax errors don't just happen locally. The Ajax convenience methods such as `$.get()`
    and `.load()` do not provide an error callback argument themselves, so we need
    to look elsewhere for a solution to this problem.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只处理了Ajax请求的成功响应，当一切顺利时加载页面以显示新内容。然而，负责任的开发人员应考虑网络或数据错误的可能性，并适当地报告它们。在本地环境中开发Ajax应用程序可能会使开发人员产生自满感，因为除了可能的URL输入错误外，Ajax错误不会在本地发生。Ajax方便的方法，如`$.get()`和`.load()`本身不提供错误回调参数，因此我们需要寻找其他地方解决此问题。
- en: 'Aside from using the `global .ajaxError()` method, we can react to errors by
    capitalizing on jQuery''s deferred object system. We will discuss deferred objects
    more fully in [Chapter 11](18ed1c5d-dfac-4361-b647-0cb63f5dd58b.xhtml), *Advanced
    Effects*, but, for now, we''ll simply note that we can chain `.done()`, `.always()`,
    and `.fail()` methods to any Ajax function except `.load()`, and use these methods
    to attach the relevant callbacks. For example, if we take the code from *Listing
    6.16* and change the URL to one that doesn''t exist, we can test the `.fail()`
    method:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`global .ajaxError()`方法外，我们还可以利用jQuery的延迟对象系统来对错误做出反应。我们将在[第11章](18ed1c5d-dfac-4361-b647-0cb63f5dd58b.xhtml)，*高级效果*中更详细地讨论延迟对象，但是，现在我们简单地指出，我们可以将`.done()`，`.always()`和`.fail()`方法链接到除`.load()`之外的任何Ajax函数，并使用这些方法来附加相关的回调。例如，如果我们取自*列表
    6.16*的代码，并将URL更改为不存在的URL，我们可以测试`.fail()`方法：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Listing 6.15
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.15
- en: 'Now, clicking on any of the links for terms beginning with E will produce an
    error message. The exact content of `jqXHR.responseText` will vary depending on
    the server configuration:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击以E开头的任何术语链接都会产生错误消息。`jqXHR.responseText`的确切内容将根据服务器配置的不同而变化：
- en: '![](img/5297_06_12.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_06_12.png)'
- en: 'The `.status` property contains a numeric code provided by the server. These
    codes are defined in the HTTP specification, and when a `.fail()` handler is triggered,
    they will represent an error condition such as:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`.status`属性包含服务器提供的数字代码。这些代码在HTTP规范中定义，当触发`.fail()`处理程序时，它们将代表错误条件，例如：'
- en: '| **Response code** | **Description** |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| **响应代码** | **描述** |'
- en: '| 400 | Bad request |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 400 | 错误请求 |'
- en: '| 401 | Unauthorized |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 401 | 未经授权 |'
- en: '| 403 | Forbidden |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 403 | 禁止访问 |'
- en: '| 404 | Not found |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 404 | 未找到 |'
- en: '| 500 | Internal server error |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 500 | 内部服务器错误 |'
- en: 'A complete list of response codes can be found on the W3C''s site: [http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在W3C的网站上找到完整的响应代码列表：[http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)。
- en: We will examine error handling more closely in [Chapter 13](6bf83967-6247-454a-b1d2-3f3f48937865.xhtml),
    *Advanced Ajax*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更仔细地检查错误处理在[第13章](6bf83967-6247-454a-b1d2-3f3f48937865.xhtml)，*高级Ajax*中。
- en: Ajax and events
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ajax和事件
- en: 'Suppose we wanted to allow each dictionary term name to control the display
    of the definition that follows; clicking on the term name would show or hide the
    associated definition. With the techniques we have seen so far, this should be
    pretty straightforward:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想允许每个词典术语名称控制其后跟的定义的显示；点击术语名称将显示或隐藏相关定义。根据我们目前所见的技术，这应该是相当简单的：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Listing 6.16
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.16
- en: When a term is clicked on, this code finds siblings of the element that have
    a class of `definition`, and slides them up or down as appropriate.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击术语时，此代码会查找具有`definition`类的元素的兄弟元素，并根据需要将它们上下滑动。
- en: All seems in order, but a click does nothing with this code. Unfortunately,
    the terms have not yet been added to the document when we attach the `click` handlers.
    Even if we managed to attach `click` handlers to these items, once we clicked
    on a different letter the handlers would no longer be attached.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来都井然有序，但此代码不起作用。不幸的是，当我们附加`click`处理程序时，术语尚未添加到文档中。即使我们设法将`click`处理程序附加到这些项上，一旦我们点击不同的字母，处理程序将不再附加。
- en: This is a common problem with areas of a page populated by Ajax. A popular solution
    is to rebind handlers each time the page area is refreshed. This can be cumbersome,
    however, as the event-binding code needs to be called each time anything causes
    the DOM structure of the page to change.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常见的问题，当页面的某些区域由Ajax填充时。一个流行的解决方案是每次页面区域被刷新时重新绑定处理程序。然而，这可能很麻烦，因为每次任何事情导致页面的DOM结构发生变化时，事件绑定代码都需要被调用。
- en: 'A superior alternative was introduced in [Chapter 3](2036c6b0-e8c5-405a-b54b-b3f31eab404c.xhtml),
    *Handling Events*. We can implement **event delegation**, actually binding the
    event to an ancestor element that never changes. In this case, we''ll attach the
    `click` handler to the `<body>` element, using `.on()` to catch our clicks that
    way:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 更优的选择在[第3章](2036c6b0-e8c5-405a-b54b-b3f31eab404c.xhtml)，*事件处理*中被介绍。我们可以实现**事件委托**，实际上将事件绑定到一个永远不会改变的祖先元素上。在这种情况下，我们将`click`处理程序附加到`<body>`元素上，使用`.on()`这样来捕获我们的点击：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Listing 6.17
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第6.17节
- en: When used this way, the `.on()` method tells the browser to observe all clicks
    anywhere in the document. If (and only if) the clicked element matches the `h3.term`
    selector, then the handler is executed. Now, the toggling behavior will take place
    on any term, even if it is added by a later Ajax transaction.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当以这种方式使用时，`.on()`方法告诉浏览器在整个文档中观察所有点击。如果（且仅当）点击的元素与`h3.term`选择器匹配，则执行处理程序。现在，切换行为将在任何术语上发生，即使它是由后来的Ajax事务添加的。
- en: Deferreds and promises
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟对象和承诺
- en: jQuery deferred objects were introduced at a time when there was no consistent
    way to handle asynchronous behavior in JavaScript code. Promises help us orchestrate
    asynchronous stuff, such as multiple HTTP requests, file reads, animations, and
    so on. Promises aren't exclusive to JavaScript, nor are they a new idea. The best
    way to think about a promise is as a contract that promises to resolve a value
    *eventually*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript代码中处理异步行为时，jQuery延迟对象是在没有一致的方式时引入的。承诺帮助我们编排异步事务，如多个HTTP请求、文件读取、动画等。承诺不是JavaScript专有的，也不是一个新的想法。将承诺视为一个承诺*最终*解析值的合同是最好的理解方式。
- en: Now that promises are officially part of JavaScript, jQuery now fully supports
    promises. That is, jQuery deferred objects behave just like any other promise.
    This is important, as we'll see in this section, because it means that we can
    use jQuery deferreds to compose complex asynchronous behavior with other code
    that return native promises.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在承诺已经正式成为JavaScript的一部分，jQuery现在完全支持承诺。也就是说，jQuery延迟对象的行为与任何其他承诺一样。这很重要，因为我们将在本节中看到，这意味着我们可以使用jQuery延迟对象来与返回原生承诺的其他代码组合复杂的异步行为。
- en: Performing Ajax calls on page load
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在页面加载时执行Ajax调用
- en: Right now, our dictionary doesn't show any definitions on the initial page load.
    Instead, it just shows some empty space. Let's change that by showing the "A"
    entries when the document is ready. How do we do this?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的字典在初始页面加载时不显示任何定义。相反，它只显示一些空白空间。让我们通过在文档准备好时显示"A"条目来改变这种情况。我们如何做到这一点？
- en: One approach is to simply add the `load('a.html')` call into our document ready
    handler (`$(() => {})`) along with everything else. The problem is that this is
    inefficient because we have to wait for the document to be ready before we can
    even make the Ajax request. Wouldn't it be better to make the Ajax request as
    soon as our JavaScript runs?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是简单地将`load('a.html')`调用添加到我们的文档准备处理程序（`$(() => {})`）中，以及其他所有内容。问题在于这样效率低下，因为我们必须等待文档准备好才能发出Ajax请求。如果我们的JavaScript一运行就发出Ajax请求会不会更好呢？
- en: 'The challenge is then synchronizing the document ready event with the Ajax
    response ready event. There is a race condition here because we don''t know which
    event will happen first. There''s a good chance that the document will be ready
    first, but we can''t make that assumption. This is where promises are super helpful:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战在于将文档准备事件与Ajax响应准备事件同步。这里存在竞争条件，因为我们不知道哪个事件会先发生。文档准备可能会首先完成，但我们不能做出这种假设。这就是承诺非常有用的地方：
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Listing 6.18
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第6.18节
- en: The `Promise.all()` method takes an array of other promises, and returns a new
    promise. This new promise is then resolved when everything in the array argument
    resolves. This is how promises handle asynchronous race conditions for us. It
    doesn't matter if the Ajax promise (`$.get('a.html')`) resolves first or the document
    ready promise (`$.ready`) resolves first.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.all()`方法接受其他promise的数组，并返回一个新的promise。当数组参数中的所有内容都解析了，这个新的promise就解析了。这就是promise为我们处理异步竞争条件的方式。无论Ajax
    promise (`$.get(''a.html'')`)先解析还是文档准备好promise (`$.ready`)先解析，都不重要。'
- en: The `then()` handler is where we want to execute any code that depends on asynchronous
    values. For example, the content value is the resolved Ajax call. The document
    being ready implicitly resolves the DOM. If the DOM isn't ready, we cannot run
    `$('#dictionary')...`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`then()`处理程序是我们想要执行依赖于异步值的任何代码的地方。例如，content值是解析后的Ajax调用。文档准备好隐式解析了DOM。如果DOM没有准备好，我们就不能运行`$(''#dictionary'')...`。'
- en: Using fetch()
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用fetch()
- en: 'Another recent addition to JavaScript is the `fetch()` function. This is a
    more flexible alternative to `XMLHttpRequest`. For example, it''s much easier
    to use `fetch()` when making cross-domain requests, or when you need to tweak
    specific HTTP header values. Let''s implement the *G* entries using `fetch()`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的另一个近期新增功能是`fetch()`函数。这是`XMLHttpRequest`的更灵活的替代品。例如，当进行跨域请求时或需要调整特定的HTTP头值时，使用`fetch()`更加容易。让我们使用`fetch()`来实现*G*条目：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Listing 6.19
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.19
- en: The `fetch()` function returns a promise, just like the various jQuery Ajax
    functions. This means that if the `/g` URL that we're calling in this example
    were actually located in another domain, we could use `fetch()` to access it.
    If we want JSON data, which we do, we need to call `.json()` in the `.then()`
    handler. Then, in a second handler, we can populate the DOM, using the same functions
    we created earlier in the chapter.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch()`函数返回一个promise，就像各种jQuery Ajax函数一样。这意味着如果我们在这个例子中调用的`/g`网址实际上位于另一个域中，我们可以使用`fetch()`来访问它。如果我们需要JSON数据，我们需要在`.then()`处理程序中调用`.json()`。然后，在第二个处理程序中，我们可以使用在本章前面创建的相同函数来填充DOM。'
- en: The whole idea behind promises is consistency. If we need to synchronize asynchronous
    behavior, promises are the way to do it. Anything that jQuery does asynchronously,
    can be used with other promises.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Promise背后的整个理念是一致性。如果我们需要同步异步行为，promise是解决的方法。任何jQuery异步执行的内容，都可以使用其他promise。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: You have learned that the Ajax methods provided by jQuery can help us to load
    data in several different formats from the server without a page refresh. We can
    execute scripts from the server on demand and send data back to the server.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了jQuery提供的Ajax方法可以帮助我们从服务器加载多种不同格式的数据，而无需页面刷新。我们可以根据需要从服务器执行脚本，并将数据发送回服务器。
- en: You've also learned how to deal with common challenges of asynchronous loading
    techniques, such as keeping handlers bound after a load has occurred and loading
    data from a third-party server.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学会了如何处理异步加载技术的常见挑战，比如在加载完成后保持处理程序的绑定以及从第三方服务器加载数据。
- en: This concludes our tour of the basic components of the `jQuery` library. Next,
    we'll look at how these features can be expanded upon easily using jQuery plugins.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对`jQuery`库基本组件的介绍。接下来，我们将看看这些功能如何通过jQuery插件轻松扩展。
- en: Further reading
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The topic of Ajax will be explored in more detail in [Chapter 13](6bf83967-6247-454a-b1d2-3f3f48937865.xhtml),
    *Advanced Ajax*. A complete list of Ajax methods is available in [Appendix B](d9485d2d-4300-48c1-825b-1c26c9b57a66.xhtml)*, Quick
    Reference*, of this book or in the official jQuery documentation at [http://api.jquery.com/](http://api.jquery.com/).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Ajax的主题将在[第13章](6bf83967-6247-454a-b1d2-3f3f48937865.xhtml) *高级Ajax*中更详细地探讨。完整的Ajax方法列表可以在本书的[附录B](d9485d2d-4300-48c1-825b-1c26c9b57a66.xhtml)
    *快速参考*或官方的jQuery文档中找到 [http://api.jquery.com/](http://api.jquery.com/)。
- en: Exercises
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: The challenge exercise may require the use of the official jQuery documentation
    at
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战性的练习可能需要使用官方的jQuery文档
- en: '[http://api.jquery.com/](http://api.jquery.com/):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://api.jquery.com/](http://api.jquery.com/):'
- en: When the page loads, pull the body content of `exercises-content.html` into
    the content area of the page.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当页面加载时，将`exercises-content.html`的内容填充到页面的内容区域。
- en: Rather than displaying the whole document at once, create tooltips for the letters
    in the left-hand column by loading just the appropriate letter's content from
    `exercises-content.html` when the user's mouse is over the letter.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 而不是一次性显示整个文档，当用户将鼠标悬停在左侧列中的字母上时，通过从`exercises-content.html`加载适当字母的内容，创建工具提示。
- en: Add error handling for this page load, displaying the error message in the content
    area. Test this error handling code by changing the script to request `does-not-exist.html`
    rather than `exercises-content.html`.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这个页面加载添加错误处理，将错误消息显示在内容区域。通过将脚本更改为请求`does-not-exist.html`而不是`exercises-content.html`来测试这个错误处理代码。
- en: Here's a challenge. When the page loads, send a JSONP request to GitHub and
    retrieve a list of repositories for a user. Insert the name and URL of each repository
    into the content area of the page. The URL to retrieve the jQuery project's repositories
    is [https://api.github.com/users/jquery/repos](https://api.github.com/users/jquery/repos).
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个挑战。页面加载时，向 GitHub 发送一个 JSONP 请求，并检索用户的存储库列表。将每个存储库的名称和网址插入页面的内容区域。检索 jQuery
    项目存储库的网址是[https://api.github.com/users/jquery/repos](https://api.github.com/users/jquery/repos)。
