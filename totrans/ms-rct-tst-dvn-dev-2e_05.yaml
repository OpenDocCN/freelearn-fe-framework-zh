- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Adding Complex Form Interactions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加复杂表单交互
- en: 'It’s time to apply what you’ve learned to a more complicated HTML setup. In
    this chapter, we’ll test-drive a new component: `AppointmentForm`. It contains
    a select box, for selecting the service required, and a grid of radio buttons
    that form a calendar view for selecting the appointment time.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将你所学应用到更复杂的HTML设置中了。在本章中，我们将测试一个新的组件：`AppointmentForm`。它包含一个下拉框，用于选择所需的服务，以及一组单选按钮，形成一个用于选择预约时间的日历视图。
- en: 'Combining both layout and form input, the code in this chapter shows how TDD
    gives you a structure for your work that makes even complicated scenarios straightforward:
    you will use your tests to grow the component into a component hierarchy, splitting
    out functionality from the main component as it begins to grow.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 结合布局和表单输入，本章中的代码展示了TDD如何为你提供一个工作结构，使复杂场景变得简单易懂：你将使用测试来扩展组件成为组件层次结构，随着组件开始增长，将功能从主组件中分离出来。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Choosing a value from a select box
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从下拉框中选择一个值
- en: Constructing a calendar view
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建日历视图
- en: Test-driving radio button groups
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试单选按钮组
- en: Reducing effort when constructing components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少构建组件时的努力
- en: By the end of the chapter, you’ll have learned how to apply test-driven development
    to complex user input scenarios. These techniques will be useful for all kinds
    of form components, not just select boxes and radio buttons.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何将测试驱动开发应用于复杂用户输入场景。这些技术对所有类型的表单组件都很有用，而不仅仅是下拉框和单选按钮。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter05).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter05)。
- en: Choosing a value from a select box
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从下拉框中选择一个值
- en: Let’s start by creating a component for booking new appointments, named `AppointmentForm`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为`AppointmentForm`的组件来预订新预约开始。
- en: 'The first field is a select box for choosing which service the customer requires:
    cut, color, blow-dry, and so on. Let’s create that now:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第一字段是一个下拉框，用于选择客户所需的服务：剪发、染色、吹干等。让我们现在创建它：
- en: 'Create a new file, `test/AppointmentForm.test.js`, with the following test
    and setup:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，`test/AppointmentForm.test.js`，包含以下测试和设置：
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Make this test pass by implementing and creating a new file, `src/AppointmentForm.js`,
    as shown here:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实现并创建一个新文件，`src/AppointmentForm.js`，如下所示，使这个测试通过：
- en: '[PRE1]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a nested `describe` block for the service field. We’ll jump to this
    right away because we know this form will have multiple fields:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为服务字段创建一个嵌套的`describe`块。我们将立即跳到这一点，因为我们知道这个表单将包含多个字段：
- en: '[PRE2]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the following test to the `describe` block:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试添加到`describe`块中：
- en: '[PRE3]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To make this test pass, modify the `AppointmentForm` component, as follows:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使这个测试通过，修改`AppointmentForm`组件，如下所示：
- en: '[PRE4]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Run the tests and ensure they are all passing.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试并确保它们全部通过。
- en: With that, we’ve done the basic scaffolding for the new select box field so
    that it’s ready to be populated with `option` elements.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经为新下拉框字段完成了基本的脚手架，使其准备好填充`option`元素。
- en: Providing select box options
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供下拉框选项
- en: 'Our salon provides a whole range of salon services. We should ensure that they
    are all listed in the app. We could start our test by defining our expectations,
    like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的沙龙提供一系列沙龙服务。我们应该确保它们都在应用程序中列出。我们可以从定义我们的期望开始测试，如下所示：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we do this, we’ll end up repeating the same array of services in our test
    code and our production code. We can avoid that repetition by focusing our unit
    tests on the *behavior* of the select box rather than the static data that populates
    it: what should the select box *do*?'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，我们最终会在测试代码和生产代码中重复相同的数组服务。我们可以通过将单元测试集中在下拉框的*行为*上而不是填充它的静态数据来避免这种重复：下拉框应该*做什么*？
- en: 'As it turns out, we can specify the functionality of our select box with just
    *two* items in our array. There’s another good reason for keeping it to just two,
    which is that keeping the array brief helps us focus the test on what’s important:
    the behavior, not the data.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，我们只需要在数组中指定两个项目就可以指定我们的选择框的功能。保持数组简短还有另一个很好的原因，那就是这有助于我们集中测试的重点：行为，而不是数据。
- en: That leaves the question, how do we use only two items in our test when we need
    six items for the production code?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这就留下了一个问题，当我们需要六个项目用于生产代码时，我们如何在测试中只使用两个项目？
- en: We’ll do this by introducing a new prop, `selectableServices`, to `AppointmentForm`.
    Our tests can choose to specify a value if they need to. In our production code,
    we can specify a value for the component’s `defaultProps`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过向`AppointmentForm`引入一个新的属性`selectableServices`来实现这一点。我们的测试可以选择指定一个值，如果需要的话。在我们的生产代码中，我们可以为组件的`defaultProps`指定一个值。
- en: '`defaultProps` is a nifty mechanism that React offers for setting default prop
    values that will be used when required props are not explicitly provided.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultProps`是React提供的一种巧妙机制，用于设置当所需的属性未明确提供时将使用的默认属性值。'
- en: For our tests that *don’t* care about the select box values, we can avoid passing
    the prop and ignore it entirely in the test. For the tests that *do* care, we
    can provide a short, two-item array for our tests.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不关心选择框值的测试，我们可以避免传递属性并在测试中完全忽略它。对于那些确实关心的测试，我们可以为测试提供一个简短的两个项目数组。
- en: How do we verify the real select box values?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何验证实际的选择框值？
- en: Testing static data does happen, just not within our unit tests. One place this
    can be tested is within acceptance tests, which we’ll look at in *Part 4, Behavior-Driven
    Development with Cucumber*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 测试静态数据确实会发生，但不是在我们的单元测试中。这种测试可以在验收测试中进行，我们将在第4部分*使用Cucumber的行为驱动开发*中探讨。
- en: 'We’ll start with a test to ensure the first value is a blank entry. This is
    the value that’s initially selected when the user creates a new appointment: no
    option is selected. Let’s write that test now:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从确保第一个值是一个空白条目开始测试。这是当用户创建新的预约时最初选择的值：没有选择任何选项。让我们现在编写这个测试：
- en: 'Add the following test at the end of the `AppointmentForm` test suite. It specifies
    that the very first item in the select box is blank, meaning the user is not automatically
    assigned a choice from our list of services:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppointmentForm`测试套件的末尾添加以下测试。它指定选择框中的第一个项目是空白，这意味着用户不会自动从我们的服务列表中分配一个选择：
- en: '[PRE6]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Make that pass by adding a blank `option` element to the existing `select`
    element:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过向现有的`select`元素添加一个空白的`option`元素来使这个测试通过：
- en: '[PRE7]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Back in your tests, add this new helper just after the `beforeEach` block.
    We’ll make use of it in our next test to build an array of all the labels of the
    select box options:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的测试中，在`beforeEach`块之后添加这个新的辅助函数。我们将在下一个测试中使用它来构建选择框选项的所有标签的数组：
- en: '[PRE8]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the following test. This makes use of a new prop, `selectableServices`,
    which is simply the array of available options:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下测试。这使用了新的属性`selectableServices`，它简单地是可用选项的数组：
- en: '[PRE9]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Choosing test data
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 选择测试数据
- en: 'I’ve used “real” data for my expected services: `Cut` and `Blow-dry`. It’s
    also fine to use non-real names such as `Service A` and `Service B`. Often, that
    can be more descriptive. Both are valid approaches.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经为预期的服务使用了“真实”数据：`Cut`和`Blow-dry`。使用非真实名称，如`Service A`和`Service B`也是可以的。通常，这可以提供更详细的描述。这两种方法都是有效的。
- en: 'Let’s make this pass. Change the component definition, as follows:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使这个测试通过。更改组件定义，如下所示：
- en: '[PRE10]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Check that the latest test now passes. However, you will see that our earlier
    tests break because of the introduction of the new prop.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查最新的测试现在是否通过。然而，你会看到我们之前的测试因为引入了新的属性而失败了。
- en: 'We can make these tests pass again using `defaultProps`. Just below the definition
    of the `AppointmentForm` function in `src/AppointmentForm.js`, add the following:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`defaultProps`使这些测试再次通过。在`src/AppointmentForm.js`中`AppointmentForm`函数定义下方，添加以下内容：
- en: '[PRE11]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run your tests and verify they are passing.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的测试并验证它们是否通过。
- en: That’s all there is to it. With that, we’ve learned how to define the behavior
    of our component using a short two-item array and saved the real data for `defaultProps`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部内容。通过这样，我们学习了如何使用简短的两个项目数组来定义我们组件的行为，并将真实数据保存为`defaultProps`。
- en: Preselecting a value
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预选一个值
- en: 'Let’s ensure that our component preselects the value that has already been
    saved if we’re editing an existing appointment:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保如果我们在编辑现有的预约，我们的组件会预选已经保存的值：
- en: 'Define a `findOption` arrow function at the top of the `describe` block. This
    function searches the DOM tree for a particular text node:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `describe` 块的顶部定义一个 `findOption` 箭头函数。这个函数在DOM树中搜索特定的文本节点：
- en: '[PRE12]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In our next test, we can find that node and then check that it is selected:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的下一个测试中，我们可以找到这个节点，然后检查它是否被选中：
- en: '[PRE13]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To make this pass, set the value property on the root `select` tag:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使这个通过，请设置根 `select` 标签的值属性：
- en: '[PRE14]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Accessible rich internet applications (ARIA) labels
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可访问的富互联网应用程序（ARIA）标签
- en: If you have experience with building React applications, you may be expecting
    to set the `aria-label` property on the `select` element. However, one of this
    chapter’s *Exercises* is to add a label element for this `select` box that will
    ensure an ARIA label is set implicitly by the browser.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有过构建React应用程序的经验，你可能期望在 `select` 元素上设置 `aria-label` 属性。然而，本章的*练习*之一是为这个 `select`
    框添加一个标签元素，这将确保浏览器隐式设置ARIA标签。
- en: 'You’ll need to change your component props so that it includes the new `service`
    prop:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要更改你的组件属性，使其包括新的 `service` 属性：
- en: '[PRE15]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run your tests. Although this test is now passing, you’ll find the previous
    tests are failing because the original prop has not been set. To fix them, first,
    define a new constant, `blankAppointment`, just above your `beforeEach` block.
    We’ll use this in each of the failing tests:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的测试。尽管这个测试现在通过了，但你将发现之前的测试失败了，因为原始属性尚未设置。要修复它们，首先，定义一个新的常量 `blankAppointment`，就在你的
    `beforeEach` 块之上。我们将在每个失败的测试中使用它：
- en: '[PRE16]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Update your previous tests so that they use this new constant as the value
    for the `original` prop. For example, the very first test for `AppointmentForm`
    will look as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新你的先前测试，以便它们使用这个新常量作为 `original` 属性的值。例如，`AppointmentForm` 的第一个测试将如下所示：
- en: '[PRE17]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Run the tests again with `npm test`; all your tests should be passing. (If they
    aren’t, go back and check that you’ve got an `original` prop value for each test.)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用 `npm test` 运行测试；所有测试应该都通过。（如果它们没有通过，请返回并检查每个测试是否都有一个 `original` 属性值。）
- en: 'Let’s finish with a small bit of refactoring. Your last two tests both have
    the same definition for services. Pull that out of each test, placing it above
    the definition of `blankAppointment`. Make sure that you delete that line from
    both tests:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们以一小部分重构来结束。你的最后两个测试都有相同的服务定义。将其从每个测试中提取出来，放在 `blankAppointment` 定义之上。确保你从两个测试中删除该行：
- en: '[PRE18]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That completes this test, but there is still more functionality to add if we
    want a fully functional select box. Completing those tests is left as one of the
    *Exercises* at the end of this chapter. They work the same as the tests for the
    text boxes in `CustomerForm`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了这个测试，但如果我们要有一个完全功能的下拉框，还需要添加更多功能。完成这些测试被留作本章末尾的*练习*之一。它们的工作方式与 `CustomerForm`
    中的文本框测试相同。
- en: 'If you compare our select box tests to those of the text box, you will see
    that it’s a similar pattern but with a couple of additional techniques: we used
    `defaultProps` to separate the definition of production data from test behavior,
    and we defined a couple of localized helper methods, `labelsOfAllOptions` and
    `findOption`, to help keep our tests short.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你比较我们的下拉框测试和文本框测试，你会看到它们是相似的，但有一些额外的技术：我们使用了 `defaultProps` 来分离生产数据定义和测试行为，并定义了几个本地化助手方法，`labelsOfAllOptions`
    和 `findOption`，以帮助缩短我们的测试。
- en: 'Let’s move on to the next item in our form: the time of the appointment.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到我们表单的下一个项目：预约的时间。
- en: Constructing a calendar view
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建日历视图
- en: In this section, we’ll learn how to use our existing helpers, such as `element`
    and `elements`, mixed with CSS selectors, to select specific elements we’re interested
    in within our HTML layout.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用我们现有的助手，例如 `element` 和 `elements`，结合CSS选择器，来选择我们HTML布局中感兴趣的具体元素。
- en: But first, let’s start with some planning.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们做一些规划。
- en: 'We’d like `AppointmentForm` to display available time slots over the next 7
    days as a grid, with columns representing days and rows representing 30-minute
    time slots, just like a standard calendar view. The user will be able to quickly
    find a time slot that works for them and then select the right radio button before
    submitting the form:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望 `AppointmentForm` 能够以网格的形式显示未来7天的可用时间段，列代表天数，行代表30分钟的时间段，就像标准的日历视图一样。用户将能够快速找到一个适合他们的时间段，然后在提交表单之前选择正确的单选按钮：
- en: '![Figure 5.1 – The visual design of our calendar view ](img/Figure_5.01_B18423.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 我们日历视图的视觉设计](img/Figure_5.01_B18423.jpg)'
- en: Figure 5.1 – The visual design of our calendar view
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 我们日历视图的视觉设计
- en: 'Here’s an example of the HTML structure that we’re aiming to build. We can
    use this as a guide as we write out our React component:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们试图构建的HTML结构示例。我们可以将其用作我们编写React组件时的指南：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the next few sections, we’ll test-drive the `table` element itself, then
    build a header column for times of the day, and then a header for days of the
    week.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将对`table`元素本身进行测试驱动，然后为一天中的时间添加一个标题列，然后为一周中的日子添加一个标题。
- en: Adding the table
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加表格
- en: 'Let’s begin by building `table` itself:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构建`table`本身开始：
- en: 'Create a nested `describe` block with a new test at the bottom of `test/AppointmentForm.test.js`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test/AppointmentForm.test.js`的底部创建一个嵌套的`describe`块，并添加一个新的测试：
- en: '[PRE20]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You’ll need to pull the `element` helper into your imports:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要将`element`辅助函数拉入你的导入中：
- en: '[PRE21]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To make that pass, move to `src/AppointmentForm.js` and define a new `TimeSlotTable`
    component, above the definition of `AppointmentForm`. We don’t need to mark this
    one as an export as it will only be referenced by `AppointmentForm`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个测试通过，转到`src/AppointmentForm.js`并定义一个新的`TimeSlotTable`组件，在`AppointmentForm`定义之上。我们不需要将其标记为导出，因为它只将被`AppointmentForm`引用：
- en: '[PRE22]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Why add an ID?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么添加一个ID？
- en: The ID is important because that’s what the application’s CSS uses to find the
    `table` element. Although it’s not covered in this book, if you’re using CSS and
    it defines selectors based on element IDs, then you should treat those IDs as
    a kind of technical specification that your code must satisfy. That’s why we write
    unit tests for them.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ID很重要，因为这是应用程序的CSS用来查找`table`元素的方式。尽管这在本章中没有涉及，如果你使用CSS并且它基于元素ID定义选择器，那么你应该将这些ID视为一种技术规范，你的代码必须满足。这就是为什么我们为它们编写单元测试的原因。
- en: 'Add this component to your `AppointmentForm` JSX, right at the bottom, just
    below the `select` tag:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此组件添加到你的`AppointmentForm` JSX中，正好在`select`标签下方：
- en: '[PRE23]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Run the tests and verify that they are all passing.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试并验证它们是否全部通过。
- en: That’s all there is to the `table` element. Now, let’s get some data into the
    first column.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`table`元素的全部内容。现在，让我们将一些数据放入第一列。
- en: Adding a header column
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加标题列
- en: 'For the next test, we’ll test the left-hand header column that displays a list
    of times. We’ll introduce two new props, `salonOpensAt` and `salonClosesAt`, which
    inform the component of which time to show each day. Follow these steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个测试，我们将测试显示时间列表的左侧标题列。我们将引入两个新的属性`salonOpensAt`和`salonClosesAt`，它们会通知组件每天显示哪个时间。按照以下步骤操作：
- en: 'Add the following test:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下测试：
- en: '[PRE24]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Asserting on array patterns
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 断言数组模式
- en: In this example, we are checking `textContent` on *three* array entries, even
    though there are four entries in the array.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在检查数组中的三个条目的`textContent`，尽管数组中有四个条目。
- en: Properties that are the same for all array entries only need to be tested on
    one entry. Properties that vary per entry, such as `textContent`, need to be tested
    on two or three entries, depending on how many you need to test a pattern.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有数组条目都相同的属性，只需要在其中一个条目上测试。对于每个条目都不同的属性，例如`textContent`，需要根据需要测试的模式数量在两个或三个条目上测试。
- en: For this test, I want to test that it starts and ends at the right time and
    that each time slot increases by 30 minutes. I can do that with assertions on
    array entries 0, 1, and 3.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个测试，我想测试它是否在正确的时间开始和结束，并且每个时间槽增加30分钟。我可以通过对数组条目0、1和3的断言来实现这一点。
- en: This test “breaks” our rule of one expectation per test. However, in this scenario,
    I think it’s okay. An alternative approach might be to use the `textOf` helper
    instead.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试“违反”了我们每个测试只有一个预期的规则。然而，在这种情况下，我认为这是可以接受的。另一种方法可能是使用`textOf`辅助函数。
- en: 'You’ll need to pull the `elements` helper into your imports:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要将`elements`辅助函数拉入你的导入中：
- en: '[PRE25]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To make this pass, add the following functions above the `TimeSlotTable` component.
    They calculate the list of daily time slots:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个测试通过，在`TimeSlotTable`组件之上添加以下函数。它们计算每日时间槽的列表：
- en: '[PRE26]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Define the `toTimeValue` function, as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`toTimeValue`函数，如下所示：
- en: '[PRE27]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, you can make use of those two functions. Update `TimeSlotTable` so that
    it reads as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以使用这两个函数。更新`TimeSlotTable`，使其如下所示：
- en: '[PRE28]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the JSX for `AppointmentForm`, pass the `salonOpensAt` and `salonClosesAt`
    props to `TimeSlotTable`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppointmentForm`的JSX中，将`salonOpensAt`和`salonClosesAt`属性传递给`TimeSlotTable`：
- en: '[PRE29]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Fill in `defaultProps` for both `salonOpensAt` and `salonsCloseAt`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`salonOpensAt`和`salonsCloseAt`填充`defaultProps`：
- en: '[PRE30]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Run the tests and make sure everything is passing.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试并确保一切通过。
- en: That’s all there is to adding the left-hand side column of headings.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是添加左侧标题列的全部内容。
- en: Adding a header row
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加标题行
- en: 'Now, what about the column headings? In this section, we’ll create a new top
    row that contains these cells, making sure to leave an empty cell in the top-left
    corner, since the left column contains the time headings and not data. Follow
    these steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，列标题怎么办？在本节中，我们将创建一个新的顶部行，包含这些单元格，并确保在左上角留出一个空单元格，因为左列包含时间标题而不是数据。按照以下步骤操作：
- en: 'Add the following test:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下测试：
- en: '[PRE31]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Modify the table JSX so that it includes a new table row:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改表格JSX，使其包含一个新的表格行：
- en: '[PRE32]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For the rest of the header row, we’ll show the 7 days starting from today.
    `AppointmentForm` will need to take a new prop, `today`, which is the first day
    to display within the table. The value that’s assigned to that prop is stored
    in a variable named `specificDate`. This name has been chosen to highlight the
    fact that this chosen date affects the rendered day output, for example, `"Sat
    01"`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于标题行的其余部分，我们将从今天开始显示7天。`AppointmentForm`需要接受一个新的属性`today`，这是表格中要显示的第一天。分配给该属性的值存储在一个名为`specificDate`的变量中。这个名字被选择用来强调这个选定的日期会影响渲染的日期输出，例如，`"Sat
    01"`：
- en: '[PRE33]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Why pass a date into the component?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要将日期传递给组件？
- en: When you’re testing a component that deals with dates and times, you almost
    always want a way to control the time values that the component will see, as we
    have in this test. You’ll rarely want to just use the real-world time because
    that can cause intermittent failures in the future. For example, your test may
    assume that a month has at least 30 days in the year, which is only true for 11
    out of 12 months. It’s better to fix the month to a specific month rather than
    have an unexpected failure when February comes around.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在测试处理日期和时间的组件时，你几乎总是想要一种方式来控制组件将看到的日期和时间值，就像我们在这次测试中所做的那样。你很少想只使用现实世界的时间，因为这可能会在未来导致间歇性故障。例如，你的测试可能假设一年中至少有30天，这只有在12个月中的11个月是正确的。将月份固定在特定月份比在二月到来时出现意外故障要好。
- en: For an in-depth discussion on this topic, take a look at [https://reacttdd.com/controlling-time](https://reacttdd.com/controlling-time-within-unit-tests/).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个话题的深入讨论，请查看[https://reacttdd.com/controlling-time](https://reacttdd.com/controlling-time-within-unit-tests/)。
- en: 'To make that pass, first, create a function that lists the 7 days we’re after,
    in the same way we did with time slots. You can place this just after the `toTimeValue`
    function:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现这个过渡，首先，创建一个函数来列出我们想要的7天，就像我们处理时间段时做的那样。你可以把这个函数放在`toTimeValue`函数之后：
- en: '[PRE34]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Define the `toShortDate` function, which formats our date as a short string:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`toShortDate`函数，将我们的日期格式化为短字符串：
- en: '[PRE35]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Modify `TimeSlotTable` so that it takes the new `today` prop and uses the two
    new functions:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`TimeSlotTable`，使其接受新的`today`属性并使用这两个新函数：
- en: '[PRE36]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Within `AppointmentForm`, pass the `today` prop from `AppointmentForm` into
    `TimeSlotTable`:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppointmentForm`内部，将`today`属性从`AppointmentForm`传递给`TimeSlotTable`：
- en: '[PRE37]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, add a `defaultProp` for `today`. Set it to the current date by calling
    the `Date` constructor:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为`today`添加一个`defaultProp`。通过调用`Date`构造函数将其设置为当前日期：
- en: '[PRE38]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Run the tests. They should be all green.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试。它们应该都是绿色的。
- en: With that, we’re done with our table layout. You’ve seen how to write tests
    that specify the table structure itself and fill in both a header column and a
    header row. In the next section, we’ll fill in the table cells with radio buttons.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了表格布局。你已经看到了如何编写指定表格结构本身的测试，并填写了标题列和标题行。在下一节中，我们将用单选按钮填充表格单元格。
- en: Test-driving radio button groups
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动单选按钮组
- en: Now that we have our table with headings in place, it’s time to add radio buttons
    to each of the table cells. Not all cells will have radio buttons – only those
    that represent an available time slot will have a radio button.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经放置了带有标题的表格，是时候给每个表格单元格添加单选按钮了。并不是所有单元格都会有单选按钮——只有代表可用时间段单元格才会有单选按钮。
- en: 'This means we’ll need to pass in another new prop to `AppointmentForm` that
    will help us determine which time slots to show. This prop is `availableTimeSlots`,
    which is an array of objects that list times that are still available. Follow
    these steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要向`AppointmentForm`传递另一个新的属性，这将帮助我们确定要显示哪些时间段。这个属性是`availableTimeSlots`，它是一个对象数组，列出了仍然可用的时段。按照以下步骤操作：
- en: 'Add the following test, which establishes a value for the `availableTimeSlots`
    prop and then checks that radio buttons have been rendered for each of those slots:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下测试，它为`availableTimeSlots`属性设置一个值，然后检查是否为每个时间段渲染了单选按钮：
- en: '[PRE39]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Notice that this test uses a `cellsWithRadioButtons` helper, which we need
    to define now. You can place this just above the test; there’s no need to move
    it to the extension’s module since it’s specific to this one component:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，此测试使用了一个`cellsWithRadioButtons`辅助函数，我们现在需要定义它。你可以将它放在测试上方；没有必要将其移动到扩展模块中，因为它只针对这个组件：
- en: '[PRE40]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This test checks that there are radio buttons in the first two time slots for
    today. These will be in cells 0 and 7 since `elements` returns matching elements
    in page order. We can make this test pass very simply by adding the following
    to our `AppointmentForm` render method, just below `th` within each `tr`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此测试检查今天前两个时间段内是否有单选按钮。这些按钮将位于单元格0和7，因为`elements`按页面顺序返回匹配的元素。我们可以通过在`AppointmentForm`的渲染方法中添加以下内容来非常简单地使此测试通过，就在每个`tr`中的`th`下面：
- en: '[PRE41]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: At this point, your test will be passing.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的测试将通过。
- en: We didn’t need to use `availableTimeSlots` in our production code, even though
    our tests require it! Instead, we just put a radio button in *every* cell! This
    is obviously “broken.” However, if you think back to our rule of only ever implementing
    the simplest thing that will make the test pass, then it makes sense. What we
    need now is another test to prove the opposite – that certain radio buttons do
    *not* exist, given `availableTimeSlots`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的测试需要它，但我们不需要在产品代码中使用`availableTimeSlots`！相反，我们只是在*每个*单元格中放了一个单选按钮！这显然是“错误的”。然而，如果你回想起我们只实现使测试通过的最简单规则，那么这就有意义了。我们现在需要另一个测试来证明相反的情况——在`availableTimeSlots`给定的情况下，某些单选按钮*不存在*。
- en: Hiding input controls
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏输入控件
- en: 'How can we get to the right implementation? We can do this by testing that
    having no available time slots renders no radio buttons at all:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何得到正确的实现？我们可以通过测试没有可用的时间段将不会渲染任何单选按钮来实现：
- en: 'Add the following test:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下测试：
- en: '[PRE42]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To make that pass, first, move to `src/AppointmentForm.js` and define the `mergeDateAndTime`
    function above the `TimeSlotTable` component. This takes the date from a column
    header, along with a time from a row header, and converts them into a timestamp
    that we can use to compare against the `startsAt` fields in `availableTimeSlots`:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使它通过，首先，转到`src/AppointmentForm.js`并在`TimeSlotTable`组件上方定义`mergeDateAndTime`函数。这个函数从列标题中获取日期，以及从行标题中获取时间，并将它们转换成我们可以用来与`availableTimeSlots`中的`startsAt`字段进行比较的时间戳：
- en: '[PRE43]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Update `TimeSlotTable` so that it takes the new `availableTimeSlots` prop:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`TimeSlotTable`使其接受新的`availableTimeSlots`属性：
- en: '[PRE44]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Replace the existing radio button element in `TimeSlotTable` with a JSX conditional:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用JSX条件替换`TimeSlotTable`中现有的单选按钮元素：
- en: '[PRE45]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Also, update `AppointmentForm` so that it takes the new prop, and then pass
    it through to `TimeSlotTable`:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，更新`AppointmentForm`使其接受新的属性，并将其传递给`TimeSlotTable`：
- en: '[PRE46]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Although your test will now be passing, the rest will be failing: they need
    a value for the `availableTimeSlots` prop. To do that, first, add the following
    definitions to the top of `AppointmentForm`:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然你的测试现在将通过，但其余的将失败：它们需要一个`availableTimeSlots`属性的值。为此，首先，在`AppointmentForm`的顶部添加以下定义：
- en: '[PRE47]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Go through each test and update each call to render to specify an `availableTimeSlots`
    prop with a value of `availableTimeSlots`. For example, the first test should
    have the following render call:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历每个测试并更新每个渲染调用，以指定一个值为`availableTimeSlots`的`availableTimeSlots`属性。例如，第一个测试应该有以下的渲染调用：
- en: '[PRE48]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Handling sensible defaults for props
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 处理属性的合理默认值
- en: Adding a default value for a new prop in every single test is no one’s idea
    of fun. Later in this chapter you'll learn how to avoid prop explosion in your
    tests by introducing a `testProps` object to group sensible default prop values.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个测试中为新的属性添加默认值并不是什么有趣的事情。在本章的后面，你将学习如何通过引入一个`testProps`对象来分组合理的默认属性值，以避免在测试中出现属性爆炸。
- en: 'Let’s continue with the next test. We must ensure each radio button has the
    correct value. We’ll use the `startsAt` value for each radio button’s value. Radio
    button values are strings, but the appointment object property, `startsAt`, is
    a number. We’ll use a standard library function, `parseInt`, to convert the button
    value back into a usable number:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续下一个测试。我们必须确保每个单选按钮都有正确的值。我们将使用每个单选按钮的`startsAt`值。单选按钮的值是字符串，但预约对象的属性`startsAt`是数字。我们将使用标准库函数`parseInt`将按钮值转换回可用的数字：
- en: '[PRE49]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Defining constants within tests
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中定义常量
- en: Sometimes, it’s preferable to keep constants within a test rather than pulling
    them out as helpers. In this case, these helpers are only used by this one test
    and are very specific in what they do. Keeping them inline helps you understand
    what the functions are doing without having to search through the file for the
    function definitions.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，在测试中保留常量而不是将它们作为辅助函数提取出来更可取。在这种情况下，这些辅助函数仅由这个测试使用，并且它们所做的事情非常具体。将它们保留在行内可以帮助你理解函数在做什么，而无需在文件中搜索函数定义。
- en: 'In your production code, pull out the ternary that contained the original call
    to `mergeDateAndTime` into a new component. Take care to add the new `name` and
    `value` attributes to the `input` element:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的生产代码中，将包含原始`mergeDateAndTime`调用的三元表达式提取到一个新的组件中。注意向`input`元素添加新的`name`和`value`属性：
- en: '[PRE50]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The name property
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 名称属性
- en: Radio buttons with the same `name` attribute are part of the same group. Clicking
    one radio button will check that button and uncheck all others in the group.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 具有相同`name`属性的无线电按钮属于同一组。点击一个单选按钮将选中该按钮并取消选中组中的所有其他按钮。
- en: 'You can now use this within `TimeSlotTable`, replacing the existing ternary
    with an instance of this functional component. After this, your tests should be
    passing:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以在`TimeSlotTable`中使用这个组件，用这个功能组件的实例替换现有的三元表达式。在此之后，你的测试应该通过：
- en: '[PRE51]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now that you’ve got the radio buttons displaying correctly, it’s time to give
    them some behavior.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经正确显示了单选按钮，是时候给它们添加一些行为。
- en: Selecting a radio button in a group
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在一组中选择单选按钮
- en: Let’s see how we can use the `checked` property on the input element to ensure
    we set the right initial value for our radio button.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用输入元素上的`checked`属性来确保为我们的单选按钮设置正确的初始值。
- en: 'For this, we’ll use a helper called `startsAtField` that takes an index and
    returns the radio button at that position. To do that, the radio buttons must
    all be given the same name. This joins the radio button into a group, which means
    only one can be selected at a time. Follow these steps:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将使用一个名为`startsAtField`的辅助函数，它接受一个索引并返回该位置的单选按钮。为了做到这一点，所有单选按钮都必须具有相同的名称。这意味着单选按钮被组合成一个组，这意味着一次只能选择一个。按照以下步骤操作：
- en: 'Start by adding the `startsAtField` helper at the top of the time slot table’s
    `describe` block:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在时间表表的`describe`块顶部添加`startsAtField`辅助函数：
- en: '[PRE52]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Add the following test. It passes in an existing appointment with a `startsAt`
    value set to the second item in the `availableTimeSlots` list. Choosing the second
    item rather than the first isn’t strictly necessary (since the default will be
    for *all* radio buttons to be unchecked), but it can help highlight to future
    maintainers that a specific value has been chosen and is being checked:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下测试。它传递了一个现有的预约，其`startsAt`值设置为`availableTimeSlots`列表中的第二个项目。选择第二个项目而不是第一个项目并不是严格必要的（因为默认情况下，所有单选按钮都将被取消选中），但它可以帮助未来的维护者突出显示已经选择并正在检查的特定值：
- en: '[PRE53]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To make that pass, first, add a new `checkedTimeSlot` prop to `TimeSlotTable`
    that has the value of the original `startsAt` value:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现这个传递，首先，向`TimeSlotTable`添加一个新的`checkedTimeSlot`属性，其值为原始的`startsAt`值：
- en: '[PRE54]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Update `TimeSlotTable` so that it makes use of this new prop, passing it through
    to `RadioButtonIfAvailable`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`TimeSlotTable`，使其利用这个新属性，将其传递给`RadioButtonIfAvailable`：
- en: '[PRE55]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, you can make use of that in `RadioButtonIfAvailable`, setting the `isChecked`
    prop on the input element, as shown here. After this change, your test should
    be passing:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以在`RadioButtonIfAvailable`中使用它，在输入元素上设置`isChecked`属性，如这里所示。在此更改之后，你的测试应该通过：
- en: '[PRE56]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: That’s it for setting the initial value. Next, we’ll hook up the component with
    the `onChange` behavior.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 设置初始值的操作就到这里。接下来，我们将组件与`onChange`行为连接起来。
- en: Handling field changes through a component hierarchy
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过组件层次结构处理字段更改
- en: 'Throughout this chapter, we have slowly built up a component hierarchy: `AppointmentForm`
    renders a `TimeSlotTable` component that renders a bunch of `RadioButtonIfAvailable`
    components that may (or may not) render the radio button input elements.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们逐渐构建了一个组件层次结构：`AppointmentForm`渲染一个`TimeSlotTable`组件，该组件渲染了一堆`RadioButtonIfAvailable`组件，这些组件可能会（也可能不会）渲染单选按钮输入元素。
- en: The final challenge involves how to take an `onChange` event from the input
    element and pass it back up to `AppointmentForm`, which will control the appointment
    object.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的挑战是如何从输入元素获取`onChange`事件并将其传递回`AppointmentForm`，这将控制预约对象。
- en: 'The code in this section will make use of the `useCallback` hook. This is a
    form of performance optimization: we can’t write a test to specify that this behavior
    exists. A good rule of thumb is that if you’re passing functions through as props,
    then you should consider using `useCallback`.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的代码将使用`useCallback`钩子。这是一种性能优化的形式：我们无法编写测试来指定这种行为。一个很好的经验法则是，如果你正在将函数作为属性传递，那么你应该考虑使用`useCallback`。
- en: The useCallback hook
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`useCallback`钩子'
- en: The `useCallback` hook returns a `TimeSlotTable`) would re-render each time
    the parent re-renders, because the different reference would cause it to believe
    that a re-render was required.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`useCallback`钩子返回的`TimeSlotTable`会在父组件每次重新渲染时重新渲染，因为不同的引用会导致它认为需要重新渲染。'
- en: Event handlers on `input` elements don’t need to use `useCallback` because event
    handler props are handled centrally; changes to those props do not require re-renders.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`input`元素上的事件处理器不需要使用`useCallback`，因为事件处理器属性是集中处理的；这些属性的更改不需要重新渲染。'
- en: The second parameter to `useCallback` is the set of dependencies that will cause
    `useCallback` to update. In this case, it’s `[]`, an empty array, because it isn’t
    dependent on any props or other functions that may change. Parameters to the function
    such as `target` don’t count, and `setAppointment` is a function that is guaranteed
    to remain constant across re-renders.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`useCallback`的第二个参数是`useCallback`更新的依赖项集合。在这种情况下，它是`[]`，一个空数组，因为它不依赖于任何可能会改变的属性或其他函数。函数的参数，如`target`不计，而`setAppointment`是一个保证在重新渲染中保持恒定的函数。'
- en: See the *Further reading* section at the end of this chapter for a link to more
    information on `useCallback`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾的*进一步阅读*部分查看有关`useCallback`的更多信息链接。
- en: 'Since we haven’t done any work on submitting `AppointmentForm` yet, we need
    to start there. Let’s add a test for the form’s submit button:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还没有对提交`AppointmentForm`进行任何工作，我们需要从这里开始。让我们为表单的提交按钮添加一个测试：
- en: 'Add the following test to your `AppointmentForm` test suite, which tests for
    the presence of a submit button. This can go at the top of the test suite, just
    underneath the `renders a form` test:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试添加到你的`AppointmentForm`测试套件中，该测试用于检查提交按钮的存在。这可以放在测试套件的顶部，就在`renders a form`测试下面：
- en: '[PRE57]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You’ll also need to import the `submitButton` helper into your tests:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要将`submitButton`辅助函数导入到你的测试中：
- en: '[PRE58]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To make that pass, add the button at the bottom of your `AppointmentForm`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这一步通过，请在你的`AppointmentForm`底部添加按钮：
- en: '[PRE59]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'For the next test, let’s submit the form and check that we get the original
    `startsAt` value submitted back. We’ll use the same `expect.hasAssertions` technique
    that we saw in the previous chapter. The test verifies that the `onSubmit` prop
    was called with the original, unchanged `startsAt` value:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于下一个测试，让我们提交表单并检查我们是否得到了提交的原始`startsAt`值。我们将使用我们在上一章中看到的相同`expect.hasAssertions`技术。测试验证`onSubmit`属性是否以原始的、未更改的`startsAt`值被调用：
- en: '[PRE60]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Since this test uses the `click` helper, you’ll need to import it:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这个测试使用了`click`辅助函数，你需要导入它：
- en: '[PRE61]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'For this test, all we need is to get the form’s `onSubmit` event handler in
    place. At this stage, it will simply submit the `original` object without any
    registered changes. Update the `AppointmentForm` component, as shown here:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个测试，我们只需要将表单的`onSubmit`事件处理器设置好。在这个阶段，它将简单地提交没有任何注册更改的`original`对象。更新`AppointmentForm`组件，如下所示：
- en: '[PRE62]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'With that test passing, let’s add the final test. This uses a `click` action
    rather than `change`, which we used for the text box and select box. We click
    on the desired radio button just as a user would:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那个测试通过后，让我们添加最后的测试。这个测试使用的是`click`动作而不是`change`，我们之前用于文本框和选择框。我们将点击所需的单选按钮，就像用户一样：
- en: '[PRE63]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, the fun begins. Let’s work from the top down: we’ll start by defining
    a new `appointment` state object, which we’ll then use in a new event handler
    that modifies the current appointment when a radio button is clicked. Move to
    `src/AppointmentForm.js` and update your React import so that it reads as follows:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，有趣的部分开始了。从上到下工作：我们首先定义一个新的`appointment`状态对象，然后使用一个新的事件处理器，当点击单选按钮时修改当前预约。移动到`src/AppointmentForm.js`并更新你的React导入，使其如下所示：
- en: '[PRE64]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Introduce a new `appointment` state object and update your `checkedTimeSlot`
    prop to use this object, rather than the `original` prop value:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引入一个新的`appointment`状态对象，并将你的`checkedTimeSlot`属性更新为使用此对象，而不是使用`original`属性值：
- en: '[PRE65]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Update the `handleSubmit` function so that it uses `appointment` rather than
    `original`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`handleSubmit`函数，使其使用`appointment`而不是`original`：
- en: '[PRE66]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The call to preventDefault
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 阻止默认行为的调用
- en: I’m avoiding writing the test for `preventDefault` since we’ve covered it previously.
    In a real application, I would almost certainly add that test again.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我避免编写 `preventDefault` 的测试，因为我们之前已经讨论过。在实际应用中，我几乎肯定会再次添加这个测试。
- en: 'Now, it’s time for the new event handler. This is the one that makes use of
    `useCallback` so that we can safely pass it through to `TimeSlotTable` and beyond.
    Add the following definition just below the `useState` call you added in the previous
    step. The handler uses `parseInt` to convert between our radio button’s string
    value and the numeric timestamp value we’ll be storing:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候为新的事件处理程序了。这是利用 `useCallback` 来安全地将其传递给 `TimeSlotTable` 及其超集的函数。在之前步骤中添加的
    `useState` 调用下方添加以下定义。处理程序使用 `parseInt` 在我们的单选按钮的字符串值和我们将存储的数字时间戳值之间进行转换：
- en: '[PRE67]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We’ve got to weave the event handler through to the `input` element, just like
    we did with `checkedTimeSlot`. Start by passing it into `TimeSlotTable`:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将事件处理程序编织到 `input` 元素中，就像我们处理 `checkedTimeSlot` 一样。首先，将它传递给 `TimeSlotTable`：
- en: '[PRE68]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, update `TimeSlotTable`, taking that prop and passing it through to `RadioButtonIfAvailable`:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，更新 `TimeSlotTable`，将那个属性传递给 `RadioButtonIfAvailable`：
- en: '[PRE69]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Finally, in `RadioButtonIfAvailable`, remove the `readOnly` property on the
    input field and set `onChange` in its place:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `RadioButtonIfAvailable` 中，从输入字段中移除 `readOnly` 属性，并设置 `onChange` 代替它：
- en: '[PRE70]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: At this point, your test should pass, and your time slot table should be fully
    functional.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的测试应该通过，你的时间段表应该完全可用。
- en: 'This section has covered a great deal of code: conditionally rendering `input`
    elements, as well as details of radio button elements, such as giving a group
    `name` and using the `onChecked` prop, and then passing its `onChange` event through
    a hierarchy of components.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了大量的代码：条件渲染 `input` 元素，以及单选按钮元素的细节，例如为组提供 `name` 并使用 `onChecked` 属性，然后通过组件层次结构传递其
    `onChange` 事件。
- en: 'This is a good moment to manually test what you’ve built. You’ll need to update
    `src/index.js` so that it loads `AppointmentForm`, together with sample data.
    These changes are included in the `Chapter05/Complete` directory:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个手动测试你构建内容的好时机。你需要更新 `src/index.js`，使其加载 `AppointmentForm` 以及示例数据。这些更改包含在
    `Chapter05/Complete` 目录中：
- en: '![Figure 5.2 – AppointmentForm on show ](img/Figure_5.02_B18423.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 显示的 AppointmentForm](img/Figure_5.02_B18423.jpg)'
- en: Figure 5.2 – AppointmentForm on show
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 显示的 AppointmentForm
- en: You’ve now completed the work required to build the radio button table. Now
    it’s time to refactor.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经完成了构建单选按钮表所需的工作。现在是时候进行重构了。
- en: Reducing effort when constructing components
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建组件时的效率提升
- en: 'Let’s look at a couple of simple ways to reduce the amount of time and code
    needed for test suites like the one we’ve just built: first, extracting builder
    functions, and second, extracting objects to store sensible defaults for our component
    props.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几种简单的方法来减少我们刚刚构建的测试套件所需的时间和代码量：首先，提取构建函数，其次，提取对象以存储我们组件属性的有意义默认值。
- en: Extracting test data builders for time and date functions
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取时间和日期函数的测试数据构建器
- en: You’ve already seen how we can extract reusable functions into namespaces of
    their own, such as the `render`, `click`, and `element` DOM functions. A special
    case of this is the **builder** function, which constructs objects that you’ll
    use in the **Arrange** and **Act** phases of your test.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到我们可以如何将可重用的函数提取到它们自己的命名空间中，例如 `render`、`click` 和 `element` DOM 函数。这是一个特殊情况，即
    **builder** 函数，它构建你在测试的 **安排** 和 **行动** 阶段将使用的对象。
- en: The purpose of these functions is not just to remove duplication but also for
    simplification and to aid with comprehension.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的目的不仅仅是去除重复，还包括简化并帮助理解。
- en: 'We already have one candidate in our test suite, which is the following code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在测试套件中有一个候选者，如下代码所示：
- en: '[PRE71]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We’ll update our test suite so that it uses a builder function called `todayAt`,
    which will save a bit of typing:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新我们的测试套件，使其使用一个名为 `todayAt` 的构建函数，这将节省一些输入：
- en: '[PRE72]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We’ll also extract the `today` value as a constant as we’ll also make use of
    that.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将提取 `today` 值作为常量，因为我们也会使用它。
- en: Builders for domain objects
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 领域对象的构建器
- en: Most often, you’ll create builder functions for the domain objects in your code
    base. In our case, that would be `customer` or `appointment` objects, or even
    the time slot objects with the single `startsAt` field. Our code base hasn’t progressed
    enough to warrant this, so we’ll start with builders for the `Date` objects that
    we’re using. We’ll write more builders later in this book.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会为代码库中的域对象创建构建函数。在我们的例子中，那将是`customer`或`appointment`对象，甚至是具有单个`startsAt`字段的时段对象。我们的代码库还没有发展到需要这一点，所以我们将从我们使用的`Date`对象的构建函数开始。我们将在本书的后面写更多的构建函数。
- en: 'Let’s get started:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: Create a new directory, `test/builders`. This is where all our `builder` functions
    will live.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新目录，`test/builders`。这是我们所有`builder`函数将存放的地方。
- en: Create a new file, `test/builders/time.js`. This is where we’ll throw everything
    related to time.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，`test/builders/time.js`。这是我们放置所有与时间相关内容的地方。
- en: 'Add the following constant to your new file:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的新文件中添加以下常量：
- en: '[PRE73]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Back in `test/AppointmentForm.test.js`, add the following import, just below
    your other imports:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test/AppointmentForm.test.js`中，在您的其他导入下面添加以下导入：
- en: '[PRE74]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Delete the definition of the `today` constant in the test suite.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从测试套件中删除`today`常量的定义。
- en: 'In `test/builders/time.js`, add the following definition of `todayAt`. Notice
    that this does allow us to specify hours, minutes, seconds, and milliseconds if
    we so choose, but it has a default value of `0` for each if we don’t specify them.
    We’ll make use of this full form in one of the tests. We must also make a copy
    of the `today` constant by calling the `date` constructor. This ensures that we
    don’t unexpectedly modify the `today` constant on any callers of this function:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test/builders/time.js`中，添加以下`todayAt`的定义。请注意，这确实允许我们指定小时、分钟、秒和毫秒，如果我们选择的话，但它为每个未指定的默认值为`0`。我们将在一个测试中使用这种完整形式。我们还必须通过调用`date`构造函数来复制`today`常量。这确保了我们不会意外地修改任何调用此函数的`today`常量：
- en: '[PRE75]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Immutability of builder functions
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 构建函数的不变性
- en: If your namespaces use shared constant values, like we’re doing with `today`
    here, make sure your functions don’t inadvertently mutate them.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的命名空间使用共享的常量值，就像我们在这里使用`today`一样，请确保您的函数不会意外地修改它们。
- en: 'Back in `test/AppointmentForm.test.js`, update your import so that it includes
    the new function:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test/AppointmentForm.test.js`中，更新您的导入，使其包括新函数：
- en: '[PRE76]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Time for a search and replace! Find all occurrences of the following:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候进行搜索和替换了！找到以下所有出现：
- en: '[PRE77]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Replace it with the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下内容替换它：
- en: '[PRE78]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Find all occurrences of the following:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到以下所有出现：
- en: '[PRE79]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Replace it with the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下内容替换它：
- en: '[PRE80]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Ensure your tests are still passing.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的测试仍然可以通过。
- en: 'Move these lines from the test suite into `test/builders/time.js`:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些行从测试套件移动到`test/builders/time.js`中：
- en: '[PRE81]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Rather than use the `tomorrow` constant directly, let’s write a `tomorrowAt`
    helper for that:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 而不是直接使用`tomorrow`常量，让我们为它编写一个`tomorrowAt`辅助函数：
- en: '[PRE82]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Update your import so that it includes the new function:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新您的导入，使其包括新函数：
- en: '[PRE83]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Delete the definitions of `oneDayInMs` and `tomorrow` from the test suite.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从测试套件中删除`oneDayInMs`和`tomorrow`的定义。
- en: 'Find the following expression:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到以下表达式：
- en: '[PRE84]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Replace it with the following code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换它：
- en: '[PRE85]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Run the tests again; they should be passing.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试；它们应该可以通过。
- en: We’ll make use of these helpers again in [*Chapter 7*](B18423_07.xhtml#_idTextAnchor125),
    *Testing useEffect and Mocking Components*. However, there’s one more extraction
    we can do before we finish with this chapter.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第7章*](B18423_07.xhtml#_idTextAnchor125)中再次使用这些辅助工具，*测试useEffect和模拟组件*。然而，在我们完成这一章之前，我们还可以进行一次提取。
- en: Extracting a test props object
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取测试属性对象
- en: 'A test props object is an object that sets sensible defaults for props that
    you can use to reduce the size of your `render` statements. For example, look
    at the following render call:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 测试属性对象是一个设置合理默认值的对象，您可以使用它来减少您的`render`语句的大小。例如，看看以下渲染调用：
- en: '[PRE86]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Depending on the test, some (or all) of these props may be irrelevant to the
    test. The `original` prop is necessary so that our render function doesn’t blow
    up when rendering existing field values. But if our test is checking that we show
    a label on the page, we don’t care about that – and that’s one reason we created
    the `blankAppointment` constant. Similarly, `availableTimeSlots` and the `today`
    prop may not be relevant to a test.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 根据测试的不同，这些属性中的一些（或全部）可能对测试不相关。`original`属性是必要的，这样我们的渲染函数在渲染现有字段值时不会崩溃。但如果我们测试的是显示页面上的标签，我们就不关心这一点——这也是我们创建`blankAppointment`常量的一个原因。同样，`availableTimeSlots`和`today`属性可能对测试不相关。
- en: Not only that, but often, our components can end up needing a whole lot of props
    that are necessary for a test to function. This can end up making your tests extremely
    verbose.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此，通常，我们的组件最终可能需要大量属性，这些属性对于测试功能是必要的。这可能导致你的测试非常冗长。
- en: Too many props?
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 属性太多？
- en: The technique you’re about to see is one way of dealing with many required props.
    But having a lot of props (say, more than four or five) might be a hint that the
    design of your components can be improved. Can the props be joined into a complex
    type? Or should the component be split into two or more components?
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你即将看到的技巧是处理许多必需属性的一种方法。但是，拥有很多属性（比如说，超过四五个）可能意味着你的组件设计可以改进。这些属性能否合并成一个复杂类型？或者应该将组件拆分成两个或更多组件？
- en: This is another example of listening to your tests. If the tests are difficult
    to write, take a step back and look at your component design.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个倾听你的测试的例子。如果测试难以编写，退一步看看你的组件设计。
- en: 'We can define an object named `testProps` that exists at the top of our `describe`
    block:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`describe`块顶部定义一个名为`testProps`的对象：
- en: '[PRE87]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'This can then be used in the `render` call, like this:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就可以在`render`调用中使用它，如下所示：
- en: '[PRE88]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'If the test does depend on a prop, such as if its expectation mentions part
    of the `props` value, then you shouldn’t rely on the hidden-away value in the
    `testProps` object. Those values are sensible defaults. The values in your test
    should be prominently displayed, as in this example:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试依赖于一个属性，比如如果其期望提到了`props`值的一部分，那么你不应该依赖于`testProps`对象中隐藏的值。这些值是合理的默认值。你的测试中的值应该突出显示，就像这个例子一样：
- en: '[PRE89]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Notice how the `original` prop is still included in the render call after `testProps`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`testProps`之后，`original`属性仍然包含在`render`调用中。
- en: Sometimes, you’ll want to explicitly include a prop, even if the value is the
    same as the `testProps` value. That’s to highlight its use within the test. We’ll
    see an example of that in this section.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能会明确地包含一个属性，即使其值与`testProps`值相同。这是为了在测试中突出其使用。我们将在本节中看到一个例子。
- en: When to use an explicit prop
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 何时使用显式属性
- en: As a rule of thumb, if the prop is used in your test assertions, or if the prop’s
    value is crucial for the scenario the test is testing, then the prop should be
    included explicitly in the `render` call, even if its value is the same as the
    value defined in `testProps`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，如果属性用于你的测试断言，或者如果属性值对于测试所测试的场景至关重要，那么即使其值与在`testProps`中定义的值相同，也应该在`render`调用中明确包含该属性。
- en: 'Let’s update the `AppointmentForm` test suite so that it uses a `testProps`
    object:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`AppointmentForm`测试套件，使其使用一个`testProps`对象：
- en: In your test suite, find the definitions for `services`, `availableTimeSlots`,
    and `blankAppointment`. These should be near the top.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的测试套件中找到`services`、`availableTimeSlots`和`blankAppointment`的定义。这些定义应该接近顶部。
- en: 'Add the following `testProps` definition just after the other definitions:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其他定义之后添加以下`testProps`定义：
- en: '[PRE90]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The first test in the suite looks like this:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 套件中的第一个测试看起来是这样的：
- en: '[PRE91]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'This can be updated to look as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以更新为如下所示：
- en: '[PRE92]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The next two tests, `renders a submit button` and `renders as a select box`,
    can use the same change. Go ahead and do that now.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的两个测试，`渲染提交按钮`和`渲染为选择框`，可以使用相同的更改。现在就去做吧。
- en: 'Next up, we have the following test:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有以下测试：
- en: '[PRE93]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Since this test depends on having a blank value passed in for the `service`
    field, let’s keep the original prop there:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个测试依赖于为`service`字段传递一个空白值，所以让我们保留原始属性：
- en: '[PRE94]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We’ve effectively hidden the `availableTimeSlots` property, which was noise
    before.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有效地隐藏了`availableTimeSlots`属性，这在之前是噪音。
- en: 'Next, we have a test that makes use of `selectableServices`:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有一个使用`selectableServices`的测试：
- en: '[PRE95]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'This test uses the `services` constant in its expectation, so this is a sign
    that we need to keep that as an explicit prop. Change it so that it matches the
    following:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试在其期望中使用`services`常量，因此这是一个迹象表明我们需要将其作为一个显式的prop。将其更改为以下内容：
- en: '[PRE96]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'In the next test, it’s just `availableTimeSlots` that we can get rid of since
    both `services` and `appointments` are defined in the test itself:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个测试中，我们只需要去掉`availableTimeSlots`，因为`services`和`appointments`都在测试本身中定义：
- en: '[PRE97]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The remaining tests in this test suite are in the nested `describe` block for
    the time slot table. Updating this is left as an exercise for you.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试套件中剩余的测试位于嵌套的`describe`块中的时间槽表中。更新这一点留作练习。
- en: 'You’ve now learned yet more ways to clean up your test suites: extracting test
    data builders and extracting a `testProps` object. Remember that using the `testProps`
    object isn’t always the right thing to do; it may be better to refactor your component
    so that it takes fewer props.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经学习了更多清理测试套件的方法：提取测试数据构建器和提取`testProps`对象。记住，使用`testProps`对象并不总是正确的事情；可能更好的做法是重构你的组件，使其接受更少的props。
- en: Summary
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned how to use two types of HTML form elements: select
    boxes and radio buttons.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用两种类型的HTML表单元素：选择框和单选按钮。
- en: The component we’ve built has a decent amount of complexity, mainly due to the
    component hierarchy that’s used to display a calendar view, but also because of
    the date and time functions we’ve needed to help display that view.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建的组件具有一定的复杂性，主要由于用于显示日历视图的组件层次结构，但也因为我们需要的一些日期和时间函数来帮助显示该视图。
- en: 'That is about as complex as it gets: writing React component tests shouldn’t
    feel any more difficult than it has in this chapter.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的复杂程度：编写React组件测试不应该比本章中更困难。
- en: Taking a moment to review our tests, the biggest issue we have is the use of
    `expect.hasAssertions` and the unusual **Arrange-Assert-Act** order. In [*Chapter
    6*](B18423_06.xhtml#_idTextAnchor099), *Exploring Test Doubles*, we’ll discover
    how we can simplify these tests and get them back into **Arrange-Act-Assert**
    order.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细审查我们的测试，最大的问题是使用`expect.hasAssertions`和异常的**安排-断言-行动**顺序。在[*第6章*](B18423_06.xhtml#_idTextAnchor099)
    *探索测试替身* 中，我们将发现如何简化这些测试并将它们恢复到**安排-行动-断言**顺序。
- en: Exercises
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'The following are some exercises for you to try out:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些供你尝试的练习：
- en: 'Add a `toBeElementWithTag` matcher that replaces the two expectations in the
    `renders as a select box` test. It should be used like so:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`renders as a select box`测试中替换两个期望，添加一个`toBeElementWithTag`匹配器。它应该像这样使用：
- en: '[PRE98]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Complete the remaining tests for the `AppointmentForm` select box:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成对`AppointmentForm`选择框剩余测试的补充：
- en: Renders a label
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染一个标签
- en: Assigns an ID that matches the label ID
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配一个与标签ID匹配的ID
- en: Saves an existing value when submitted
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交时保存现有值
- en: Saves a new value when submitted
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交时保存新值
- en: These tests are practically the same as they were for `CustomerForm`, including
    the use of the `change` helper. If you want a challenge, you can try extracting
    these form test helpers into a module of their own that is shared between `CustomerForm`
    and `AppointmentForm`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试实际上与`CustomerForm`的测试相同，包括使用`change`辅助函数。如果你想要挑战，你可以尝试将这些表单测试辅助函数提取到一个自己的模块中，该模块在`CustomerForm`和`AppointmentForm`之间共享。
- en: Update the time slot table tests so that they use the `testProps` object.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新时间槽表测试，使其使用`testProps`对象。
- en: Update the `AppointmentsDayView` component so that it uses the `todayAt` builder,
    where appropriate.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`AppointmentsDayView`组件，使其在适当的情况下使用`todayAt`构建器。
- en: Add the ability to choose a stylist before choosing a time slot. This should
    be a select box that filters based on the service required, as not all stylists
    will be qualified to provide all services. You’ll need to decide on a suitable
    data structure to hold this data. Modify `availableTimeSlots` so that it lists
    which stylists are available at each time, and update the table to reflect which
    stylist has been chosen and their availability during the week.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择时间槽之前添加选择风格的能力。这应该是一个基于所需服务进行筛选的选择框，因为并非所有造型师都具备提供所有服务的能力。你需要决定一个合适的数据结构来存储这些数据。修改`availableTimeSlots`，使其列出每个时间可用的造型师，并更新表格以反映所选造型师及其在一周内的可用性。
- en: Further reading
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The `useCallback` hook is useful when you’re passing event handlers through
    a hierarchy of components. Take a look at the React documentation for tips on
    how to ensure correct usage: https://reactjs.org/docs/hooks-reference.xhtml#usecallback.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`useCallback` 钩子在您通过组件层次结构传递事件处理程序时非常有用。请查看 React 文档以获取有关确保正确使用方法的提示：https://reactjs.org/docs/hooks-reference.xhtml#usecallback.'
