- en: Chapter 2. Customizing jQuery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。自定义jQuery
- en: Okay, so we've downloaded a version of jQuery…what do we do next, I wonder?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经下载了一个版本的jQuery……接下来该怎么做呢，我在想？
- en: This is a really good question—let me reveal all!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常好的问题——让我来揭开所有的秘密！
- en: jQuery has, over the years, become an accomplished library and is used in millions
    of websites around the world. While we can usually find a way to fulfill a need
    using the library, there may be instances where we have to provide our own patch
    or alteration, to satisfy our needs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，jQuery已经成为一个技艺精湛的库，在世界各地的数百万个网站中被使用。虽然我们通常可以找到一种方法来使用该库来满足需求，但可能会有一些情况需要我们提供自己的补丁或修改，以满足我们的需求。
- en: 'We can use a plugin, but that gets tedious after a while—it soon becomes a
    case of "plugin this, plugin that" syndrome, where we become too reliant on plugins.
    Instead, we can look to the override functionality within jQuery itself; yes,
    it has some risks, but as we''ll see, it is well worth the effort. Throughout
    this chapter, we''ll cover the basics of overriding jQuery, some of the benefits
    and pitfalls of doing so, and work our way through some examples of replacing
    the functionality. We will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用插件，但是这在一段时间后会变得很烦人——很快就会出现“这个插件，那个插件”综合症，我们变得过于依赖插件。相反，我们可以看一下jQuery本身的覆盖功能；是的，它有一些风险，但正如我们将看到的那样，它绝对值得。在本章中，我们将介绍覆盖jQuery的基础知识，一些这样做的利与弊，并通过一些替换功能的示例来逐步展示。我们将涵盖以下主题：
- en: Introducing duck punching
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍鸭子打孔
- en: Replacing or modifying existing behaviors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换或修改现有行为
- en: Creating a basic monkey patch
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个基本的猴子补丁
- en: Considering the benefits and pitfalls of monkey patching
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑猴子补丁的利与弊
- en: Distributing or applying patches
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发或应用补丁
- en: Ready to begin your adventure…? Let's get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 准备开始你的冒险了吗……？让我们开始吧！
- en: Getting prepared
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: At this point, I will recommend that you create a project folder somewhere on
    your PC—for the purposes of this demo, I will assume that it is called `project`
    and is at the root of your main hard disk or `C:` drive.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我建议你在你的电脑上的某个地方创建一个项目文件夹——为了演示的目的，我假设它被称为`project`并位于你的主硬盘或`C:`驱动器的根目录下。
- en: Within the folder, go ahead and create several subfolders; these need to be
    called `fonts`, `css`, `js`, and `img`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件夹中，继续创建几个子文件夹；这些文件夹需要被命名为`fonts`、`css`、`js`和`img`。
- en: Patching the library on the run
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时修补库
- en: Over the years, hundreds of developers have spent countless hours creating patches
    for jQuery, to either fix a bug of some description or provide new functionality
    within the library.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，数百名开发人员花费了无数个小时为jQuery创建补丁，以修复某种描述的错误或在库中提供新功能。
- en: The usual route is to submit a pull request against the Core jQuery library
    for peer consideration. As long as the patch works as expected and does not cause
    issues elsewhere in the library, then it will be submitted to core.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通常的做法是针对核心jQuery库提交一个拉取请求供同行考虑。只要补丁按预期工作且不会在库的其他地方引起问题，那么它就会被提交到核心。
- en: The downside of this approach means that we're constrained by the release schedule
    for jQuery; while the developers do an outstanding job, it nevertheless can take
    time before a patch is committed to core.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点意味着我们受到jQuery的发布时间表的约束；虽然开发人员做得很出色，但在提交到核心之前可能需要一些时间。
- en: Introducing monkey patching
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍猴子补丁
- en: What to do? Do we wait in the hope that our patch will be committed?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 该怎么办？我们是否等待，希望我们的补丁会被提交？
- en: For some, this won't be an issue—for others, patience may not be their strongest
    virtue and waiting is the last thing they will want to do! Fortunately, we can
    get around this by using a method called monkey patching.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些人来说，这可能不是问题——但对于其他人来说，耐心可能不是他们最强的美德，等待可能是他们最不想做的事情！幸运的是，我们可以通过使用一种称为猴子补丁的方法来解决这个问题。
- en: 'Now—before you ask—let me tell you that I''m not advocating any form of animal
    cruelty! **Monkey patching**, or **duck punching** as it is otherwise known, is
    a valid technique to create a patch that temporarily overrides the existing functionality
    within the jQuery Core library during runtime. Monkey patching comes with its
    risks: the primary one being that of clashing, should an update introduce a method
    or function of the same name within the library.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在——在你问之前——让我告诉你，我不主张任何形式的动物虐待！**猴子补丁**，或者另一种称为**鸭子打孔**的方式，是一种有效的技术，可以在运行时暂时覆盖jQuery核心库中现有的功能。猴子补丁也有其风险：主要的风险是冲突，如果更新在库中引入了同名的方法或函数。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Later in this chapter, we'll take a look at some of the risks that need to be
    considered.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章稍后，我们将研究一些需要考虑的风险。
- en: That said, if monkey patching is used with care and forethought, it can be used
    to update functionality until a more permanent fix can be applied. It's time,
    I think, for a demo—we'll be taking a look at how we can improve animation support
    in jQuery, but first let's take a look at the basics of replacing or modifying
    the jQuery core at runtime.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，如果小心和深思熟虑地使用猴子补丁，它可以被用来更新功能，直到一个更持久的修复方案被应用。我想，现在是时候进行演示了——我们将看看如何改进jQuery中的动画支持，但首先让我们看看如何在运行时替换或修改jQuery核心的基础知识。
- en: Replacing or modifying existing behaviors
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换或修改现有行为
- en: So, how can we effect a (temporary) change in the core functionality of jQuery?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何在jQuery的核心功能中进行（临时）更改？
- en: It all starts with the use of an **Immediately Invoked Function Expression**
    (**IIFE**); we then simply save a version of the original function before overriding
    it with our new function.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都始于使用**立即调用的函数表达式**（**IIFE**）；然后我们简单地保存原始函数的一个版本，然后用我们的新函数覆盖它。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may have heard the term *self-executing anonymous function* being used;
    it is a misleading phrase, although it means the same thing as an IIFE, which
    is a more accurate description.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听过使用*自执行匿名函数*这个术语；这是一个误导性的短语，尽管它的含义与IIFE相同，但后者是一个更准确的描述。
- en: 'Let''s see what the basic framework looks like in action:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看基本框架在实际中是什么样子的：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you were expecting something more complex, then I am sorry to disappoint
    you; there isn't a great deal of complexity required for a basic monkey patch!
    The extent of what goes into a patch will really come down to what it is that
    you are trying to fix or alter within the existing code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你期望有更复杂的东西，那么我很抱歉让你失望了；对于基本的猴子补丁，不需要太多的复杂性！补丁中需要加入的内容实际上取决于你试图修复或修改现有代码中的内容。
- en: To prove that this really is all that is required, let's take a look at an (albeit
    over-simplified) example. In the example, we'll use a standard click handler to
    show the response that a dog will give to its owner…except that our dog seems
    to have developed a personality problem.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这确实是所需的全部内容，让我们看一个（虽然过于简化的）例子。在这个例子中，我们将使用一个标准的点击处理程序来展示狗对主人的反应……只是我们的狗似乎出现了个性问题。
- en: Creating a basic monkey patch
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个基本的猴子补丁
- en: '"A personality change?" I hear you ask. Yes, that''s right; our dog seems to
    like miaowing…. (I can''t think of a reason why; I don''t know of any that would!)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: “个性变化？”我听到你问。是的，没错；我们的狗似乎喜欢喵喵叫……（我想不出任何原因；我不知道有哪些原因！）
- en: In our example, we're going to use a simple click handler to prove that (in
    some cases) our dog can meow; we will then work through what is required in order
    to persuade it to do what it should do.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将使用一个简单的点击处理程序来证明（在某些情况下）我们的狗可以喵喵叫；然后我们将逐步了解如何说服它做它应该做的事情。
- en: 'Let''s start by cracking open a text editor of our choice and then adding the
    following markup as a basis for our patch:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先打开我们选择的文本编辑器，然后添加以下标记作为我们补丁的基础：
- en: '[PRE1]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Save it as the `duck.html` file. In a separate file, we need to animate our
    button, so let''s first add in a simple event handler for this purpose:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其保存为`duck.html`文件。在另一个文件中，我们需要为我们的按钮添加动画效果，因此让我们首先添加一个简单的事件处理程序：
- en: '[PRE2]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'At this point, if we run the demo in a browser and then click on **Make it
    a dog!**, we can definitely see that our poor pet has some issues, as shown in
    the following screenshot:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此时，如果我们在浏览器中运行演示，然后点击**让它成为狗！**，我们确实可以看到我们可怜的宠物有些问题，如下截图所示：
- en: '![Creating a basic monkey patch](img/image00334.jpeg)'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![创建一个基本的猴子补丁](img/image00334.jpeg)'
- en: We clearly need to show it the error of its ways, so let's fix that now.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们明显需要让它看到自己行为的错误，所以现在让我们来修复它。
- en: 'To fix the problem, we need to override the original `toBark()` function. With
    our new fixed replacement; this will take the form of a monkey patch. Insert the
    following code immediately below the `.on()` click handler, leaving a line space
    for clarity:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要解决问题，我们需要覆盖原来的`toBark()`函数。使用我们新的修复替代品；这将采用猴子补丁的形式。将以下代码插入到`.on()`点击处理程序的下方，留出一行空白以提高清晰度：
- en: '[PRE3]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If all is well, we should now at least see that our dog has come to its senses,
    albeit gradually, as shown in the following screenshot:![Creating a basic monkey
    patch](img/image00335.jpeg)
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们现在至少应该看到我们的狗已经恢复了理智，虽然是逐渐地，如下截图所示：![创建一个基本的猴子补丁](img/image00335.jpeg)
- en: This little exercise, albeit heavily simplified, illustrates some key points—it's
    worth spending a little time going through this in more detail, so let's do that
    now.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个小练习虽然极为简化，但它阐明了一些关键点——花点时间更详细地研究一下这一点是值得的，所以现在让我们来做一下。
- en: Dissecting our monkey patch
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析我们的猴子补丁
- en: The patching of a core library should be done with care and consideration; the
    technical process may be straightforward, but it will raise some questions that
    need to be answered first. We will cover some of these questions later in the
    chapter, but for now, let's assume that we need to apply a patch.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对核心库进行补丁的过程应该谨慎和慎重；技术过程可能很简单，但首先需要回答一些问题。我们将在本章后面讨论其中的一些问题，但现在，让我们假设我们需要应用一个补丁。
- en: The basic patch takes the format of an IIFE—we include all the functionality
    within a single module; its scope is protected from the environment in which it
    is placed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 基本补丁采用了IIFE的格式——我们将所有功能都包含在一个单独的模块中；其范围受到其所放置环境的保护。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: For a more detailed explanation of IIFEs, please refer to [http://en.wikipedia.org/wiki/Immediately-invoked_
    function_expression](http://en.wikipedia.org/wiki/Immediately-invoked_%20function_expression).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解IIFE的更详细解释，请参考[http://en.wikipedia.org/wiki/Immediately-invoked_function_expression](http://en.wikipedia.org/wiki/Immediately-invoked_function_expression)。
- en: 'In our example, we started by storing a copy of the original function as an
    object, within `orig`. We then initiated our new replacement, the `.toBark()`
    function, within which we first call our `.toBark()` function, but follow it with
    the replacement:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们首先将原始函数存储为一个对象`orig`的副本。然后我们启动我们的新替换`.toBark()`函数，在其中我们首先调用`.toBark()`函数，但紧随其后进行替换：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A key part of our patch is the use of the `.apply()` function—this will call
    a function with the context being set to the object where the function is applied.
    In this instance, within the function, referencing the `this` keyword will refer
    to that object.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们补丁的一个关键部分是使用`.apply()`函数——这将调用一个函数，并将上下文设置为应用函数的对象。在这种情况下，在函数内部引用`this`关键字将指向该对象。
- en: 'Using an IIFE in the format used in our demo presents a number of advantages,
    as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的演示中使用的IIFE的格式有许多优点，如下：
- en: We can reduce the scope's lookup—IIFEs allow you to pass commonly used objects
    to the anonymous function, so they can be referenced within the IIFE at a local
    scope
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以减少作用域的查找——IIFE允许您将常用的对象传递给匿名函数，因此它们可以在IIFE中被引用为本地作用域的对象
- en: Note
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: As JavaScript first looks for properties within the local scope, this removes
    the need to look globally, providing faster lookup speeds and performance. Using
    an IIFE prevents the local variable from being overwritten by a global variable.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于JavaScript首先在本地范围内查找属性，这消除了全局查找的需要，提供更快的查找速度和性能。使用IIFE可以防止局部变量被全局变量覆盖。
- en: IIFEs help optimize the code through minification—we can pass objects to an
    IIFE as local values; a minifier can reduce the names of each global object to
    a single letter, provided there isn't a variable already present with the same
    name
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IIFE可通过压缩来优化代码——我们可以将对象作为本地值传递给IIFE；压缩器可以将每个全局对象的名称缩减为单个字母，前提是没有一个变量已经具有相同的名称
- en: 'The downside of using an IIFE is readability; if our IIFE contains a lot of
    code, then we have to scroll to the top in order to work out what objects are
    being passed. In more complex examples, we can consider using a pattern developed
    by Greg Franko in order to get around this issue:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用IIFE的缺点是可读性；如果我们的IIFE包含大量代码，那么必须滚动到顶部才能弄清楚正在传递哪些对象。在更复杂的示例中，我们可以考虑使用Greg Franko开发的模式以解决这个问题：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It's important to note that this pattern is about splitting the variables into
    two sections so that we can avoid the need to scroll up and down the page too
    often; it will still produce the same end result.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，这种模式是将变量分为两个部分，以便我们可以避免过度上下滚动页面的需要；它仍会产生相同的最终结果。
- en: We will delve more into using patterns within jQuery, in [Chapter 3](part0031.xhtml#aid-TI1E1
    "Chapter 3. Organizing Your Code"), *Organizing Your Code*. Now that we've seen
    a patch in action, let's move on and take some time to consider some of the benefits
    we may gain from using the monkey patching process.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更深入地讨论在jQuery中使用模式，[第3章](part0031.xhtml#aid-TI1E1 "第3章。整理你的代码")中的*整理你的代码*。现在我们已经看到了一个补丁的作用，让我们继续并花点时间考虑一下我们可以从使用猴子补丁过程中获得的一些好处。
- en: Considering the benefits of monkey patching
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑猴子补丁的好处
- en: Okay, so we've seen what a typical patch will look like; the question, though,
    is, why would we want to patch the core library functionality using this method?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，所以我们已经看到了一个典型的补丁是什么样子；然而，问题是，为什么我们要使用这种方法来打补丁核心库功能呢？
- en: 'This is a very good question—it''s a method that has its risks (as we will
    see later in this chapter, in the *Considering the pitfalls of monkey patching*
    section). The key to using this method is to take a considered approach; with
    this in mind, let''s take a moment to consider the benefits of duck punching jQuery:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常好的问题-这是一个有风险的方法（正如我们将在本章稍后在*考虑Monkey Patching的缺陷*部分看到的）。使用这种方法的关键是要有所考虑的方法；考虑到这一点，让我们花一点时间考虑一下插入jQuery的好处：
- en: We can replace methods, attributes, or functions at runtime, where they lack
    functionality or contain a bug that needs to be fixed and we can't wait for an
    official patch
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在运行时替换方法、属性或函数，其中它们缺乏功能或包含需要修复而不能等待官方补丁的bug。
- en: Duck punching jQuery allows you to modify or extend the existing behavior of
    jQuery without maintaining a private copy of the source code
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Duck punching jQuery允许你修改或扩展jQuery的现有行为，而无需维护源代码的私有副本。
- en: We have the safety net of being able to apply a patch to objects running in
    memory, instead of the source code; in other words, if it goes completely wrong,
    we can simply pull the patch from the site and leave the original source code
    untouched
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个安全网，可以将补丁应用于运行在内存中的对象，而不是源代码；换句话说，如果完全出错，我们可以简单地从站点中撤回补丁，并保持原始源代码不变。
- en: Monkey patching is a good way to distribute security or behavioral fixes that
    live alongside the original source code; if there is any doubt with the resiliency
    of a patch, we can stress test it before committing it to the source
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Monkey patching是一种很好的方法，用于分发与原始源代码并存的安全或行为修复；如果对补丁的弹性有任何疑问，我们可以在提交到源代码之前进行压力测试。
- en: Enough of the talking, let's get to coding some demos! We're going to work through
    some example patches that can be equally applied to jQuery, beginning with a look
    at animation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 言归正传，让我们开始编写一些演示代码！我们将逐步介绍一些示例补丁，这些补丁同样适用于jQuery，从动画开始。
- en: Updating animation support in jQuery
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新jQuery中的动画支持
- en: If you have spent any time developing with jQuery, you've most likely created
    some form of animation that included managing changes at a regular frequency—does
    this sound familiar?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你花了任何时间用jQuery开发，你很可能创建了一些形式的动画，其中包括以固定频率管理更改-这听起来熟悉吗？
- en: We can, of course, use the `setInterval()` function for this, but it—like the
    `setTimeOut()` function—is not ideal. Both these functions have a delay before
    being initiated, which varies from browser to browser; they are both equally resource
    intensive!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以使用`setInterval()`函数来实现这一点，但它-像`setTimeOut()`函数一样-并不理想。这两个函数在启动之前都有一个延迟，这个延迟因浏览器而异；它们都同样占用资源！
- en: 'Instead, we can use the **requestAnimationFrame** (**rAF**) API, which is now
    supported by most modern browsers, according to this chart from [caniuse.com](http://caniuse.com)
    where green labels show which browser versions support **requestAnimationFrame**:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以使用**requestAnimationFrame**（**rAF**）API，这个API现在由大多数现代浏览器支持，根据来自[caniuse.com](http://caniuse.com)的这个图表，绿色标签显示了哪些浏览器版本支持**requestAnimationFrame**：
- en: '![Updating animation support in jQuery](img/image00336.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![更新jQuery中的动画支持](img/image00336.jpeg)'
- en: The great thing about the requestAnimationFrame API is that it is less resource-intensive,
    doesn't impact other elements on the page, and is disabled when it loses focus
    (perfect for reducing power usage!). You may think, therefore, that it makes sense
    to implement it in jQuery by default, right?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[requestAnimationFrame（rAF）API](http://caniuse.com)的伟大之处在于它占用的资源较少，不会影响页面上的其他元素，并且在失去焦点时被禁用（非常适合减少功耗！）。因此，你可能会认为默认情况下在jQuery中实现它是有道理的，对吗？'
- en: Exploring the requestAnimationFrame API's past
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索requestAnimationFrame API的过去
- en: Ironically, jQuery used rAF back in version 1.6.2; it was pulled in 1.6.3, principally
    due to the animations piling up when windows regained focus. Part of this can
    be attributed to how rAF was (incorrectly) being used and that it would require
    major changes to its use, in order to correct the issues.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 具有讽刺意味的是，jQuery在1.6.2版本中使用了rAF；在1.6.3中被取消了，主要是因为当窗口重新获得焦点时，动画会堆积起来。部分原因可以归因于rAF的（错误）使用方式，以及为了纠正这些问题需要进行重大更改。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To see some of the issues with timing, browse to [http://xlo.co/requestanimationframe](http://xlo.co/requestanimationframe)—there
    are some demos on this site that illustrate perfectly why timing is so critical!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看一些与时序相关的问题，请访问[http://xlo.co/requestanimationframe](http://xlo.co/requestanimationframe)——该站点上有一些演示，完美地说明了为什么时序如此关键！
- en: Using the requestAnimationFrame method today
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 今天使用requestAnimationFrame方法
- en: Thankfully, we can still use requestAnimationFrame with jQuery today; Corey
    Frang, one of the developers of JQuery, wrote a plugin that can hook into and
    override the `setInterval()` method within the core library.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，今天我们仍然可以使用requestAnimationFrame与jQuery；jQuery的开发者之一Corey Frang编写了一个插件，可以钩入并重写核心库中的`setInterval()`方法。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The original version of the plugin is available from GitHub for download at
    [https://github.com/gnarf/jquery-requestAnimationFrame/blob/master/src/jquery.requestAnimationFrame.js](https://github.com/gnarf/jquery-requestAnimationFrame/blob/master/src/jquery.requestAnimationFrame.js).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件的原始版本可从GitHub下载，网址为[https://github.com/gnarf/jquery-requestAnimationFrame/blob/master/src/jquery.requestAnimationFrame.js](https://github.com/gnarf/jquery-requestAnimationFrame/blob/master/src/jquery.requestAnimationFrame.js)。
- en: This is probably one of the simplest changes we can make when using jQuery—we
    will explore this, and more, at the end of the exercise. For now, let's get on
    and create some code!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用jQuery时，这可能是我们可以做出的最简单的更改之一——在练习结束时，我们将探讨这个问题以及更多其他问题。现在，让我们继续编写一些代码吧！
- en: Creating our demo
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的演示
- en: For our next demo, we're going to use an updated version of a CodePen example,
    created by developer Matt West—the original demo is available from [http://codepen.io/matt-west/pen/bGdEC/](http://codepen.io/matt-west/pen/bGdEC/);
    I've refreshed the look and removed the vendor prefix elements of Corey's plugin,
    as they are no longer needed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的下一个演示，我们将使用开发者Matt West创建的CodePen示例的更新版本——原始演示可从[http://codepen.io/matt-west/pen/bGdEC/](http://codepen.io/matt-west/pen/bGdEC/)获取；我更新了外观并移除了Corey插件的供应商前缀元素，因为它们已不再需要。
- en: 'To give you some idea of what we''re going to achieve, we will override the
    main `setInterval` method; this method does not call a jQuery method although
    it may look like it is; `setInterval` is a plain JavaScript function, as shown
    here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你对我们即将实现的内容有所了解，我们将重写主`setInterval`方法；尽管它可能看起来像是调用了jQuery方法，但实际上`setInterval`是一个纯JavaScript函数，如下所示：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I've incorporated a change of font too—for this demo, I've used the Noto Sans
    typeface, which can be downloaded from [http://www.fontsquirrel.com/fonts/noto-sans](http://www.fontsquirrel.com/fonts/noto-sans);
    feel free to alter the code accordingly, if you want to use a different font.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我还更改了字体——为了这个演示，我使用了Noto Sans字体，可以从[http://www.fontsquirrel.com/fonts/noto-sans](http://www.fontsquirrel.com/fonts/noto-sans)下载；如果您想使用其他字体，请随意相应地更改代码。
- en: 'Ready? Let''s make a start by performing the following steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好了吗？让我们开始执行以下步骤：
- en: From a copy of the code download link that accompanies this book, go ahead and
    extract the `raf.css`, `raf.js` and `raf.html` files and save them to your project
    folder.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从随书附带的代码下载链接中提取`raf.css`、`raf.js`和`raf.html`文件，并将它们保存到项目文件夹中。
- en: 'In a new file, add the following code—this is our monkey patch or a modified
    version of Corey''s original plugin. We start by initiating a number of variables,
    as shown here:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新文件中，添加以下代码——这是我们的猴子补丁或Corey原始插件的修改版本。我们首先初始化了一些变量，如下所示：
- en: '[PRE7]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next up comes the animating function, which is called from the main `requestAnimationFrame`
    method:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是动画函数，它从主`requestAnimationFrame`方法中调用：
- en: '[PRE8]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We now need our main `requestAnimationFrame` method; go ahead and add the following
    lines of code directly below the `raf()` event handler:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要我们的主`requestAnimationFrame`方法；继续在`raf()`事件处理程序的下方直接添加以下代码行：
- en: '[PRE9]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Save the file as `jquery.requestAnimationFrame.js`, within a subfolder called
    `js` under the main project folder.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件保存为`jquery.requestAnimationFrame.js`，放在主项目文件夹下名为`js`的子文件夹中。
- en: If you run the demo in a browser, you can expect to see the bar move when you
    press **Start Animation**, as shown in the following screenshot:![Creating our
    demo](img/image00337.jpeg)
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在浏览器中运行演示，当你按下**开始动画**时，你会看到进度条移动，如下图所示：![创建我们的演示](img/image00337.jpeg)
- en: To prove that the plugin is being used, we can use Google Chrome's **Timeline**
    option (within **Developer Tools**)—clicking on the red **Record** icon, then
    running the demo, and then stopping it produces this extract:![Creating our demo](img/image00338.jpeg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了证明插件正在被使用，我们可以使用谷歌浏览器的**Developer Tools**中的**Timeline**选项——点击红色的**Record**图标，然后运行演示，然后停止它产生以下内容：![创建我们的演示](img/image00338.jpeg)
- en: Tip
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Make sure that you have the **JS Profiler** checkbox ticked under **Timeline**
    —the details will be shown; you may have to scroll down to view the **Event**
    entry.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保在**Timeline**下勾选了**JS Profiler**复选框——将会显示详细信息；可能需要向下滚动查看**Event**条目。
- en: This is probably one of the easiest changes we can make to override functionality
    in jQuery, yet potentially one of the most controversial—the latter being down
    to how we use it. The key point though is that we can override functionality using
    several formats.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是我们能在jQuery中最容易进行的覆盖功能的改变之一，但也可能是最具争议性的之一——后者是由我们如何使用它决定的。然而，关键点是，我们可以使用多种格式覆盖功能。
- en: The safest way is by the use of a plugin; in our example here, we used a modified
    one—the original was introduced from jQuery 1.8, so the changes made here just
    brought it up to the modern day. We could completely go in the opposite direction
    though and create a function that overrides an existing function—it carries a
    higher risk, but if done carefully, it is worth the effort! Let's take a look
    at a simple example, in the form of overriding `.hasClass()` to switch in the
    WebP format images when appropriate.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最安全的方法是使用插件；在我们的例子中，我们使用了一个修改过的插件——原始插件是从jQuery 1.8引入的，所以这里做的改动只是将它带入了现代化。我们当然也可以完全走向相反的方向，创建一个覆盖现有功能的函数——这更有风险，但如果小心操作，是值得的！让我们看一个简单的例子，通过覆盖`.hasClass()`来在适当时切换到WebP格式的图片。
- en: Adding WebP support to jQuery
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加WebP支持到jQuery
- en: 'At this point, I have a slight confession to make: adding full-blown WebP support
    to jQuery will probably be outside the scope of this book, let alone fill most
    of its pages!'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我有一个小小的坦白：为jQuery添加全面的WebP支持可能会超出本书的范围，更别提填满大部分页面了！
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: WebP is a relatively new image format created by Google, which offers better
    compression than standard PNG files—you can read more about it at [https://developers.google.com/speed/webp/](https://developers.google.com/speed/webp/).
    At present, both Chrome and Opera support this format natively; other browsers
    will display WebP images once support is added.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: WebP是谷歌创建的一种比标准PNG文件压缩更好的相对较新的图像格式，您可以在[https://developers.google.com/speed/webp/](https://developers.google.com/speed/webp/)上了解更多。目前，Chrome和Opera原生支持这种格式；其他浏览器在添加支持后也将显示WebP图像。
- en: The next demo is really about how we can make the switch between two different
    ways of presenting content on screen, depending on whether our browser supports
    the newer format. A good example of this is where we might use CSS3 animation
    wherever possible and fall back to using jQuery for those browsers that do not
    support CSS3 animation natively.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个演示实际上是关于我们如何根据浏览器是否支持新格式来在屏幕上显示内容的两种不同方式之间进行切换的。一个很好的例子是，我们可以尽可能使用CSS3动画，并在那些不原生支持CSS3动画的浏览器上回退到使用jQuery。
- en: In our next demo, we're going to use a similar principle to create a monkey
    patch that overrides the `.hasClass()` method in order to automatically switch
    to the WebP format images, where supported.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个演示中，我们将使用类似的原理创建一个monkey patch，以覆盖`.hasClass()`方法，以便在支持的情况下自动切换到WebP格式的图片。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to learn more, there is a useful discussion on how to get started
    with the format at [http://blog.teamtreehouse.com/getting-started-webp-image-format](http://blog.teamtreehouse.com/getting-started-webp-image-format).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多，可以在[http://blog.teamtreehouse.com/getting-started-webp-image-format](http://blog.teamtreehouse.com/getting-started-webp-image-format)上找到一个有用的讨论，介绍了如何开始使用这种格式。
- en: Getting started
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: For the purpose of this demo, we will need to avail ourselves of an image in
    two different formats; I will assume JPEG has been used as our base format. The
    other image, of course, needs to be in the WebP format!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这个演示，我们需要使用两种不同格式的图片；我先假设JPEG被用作我们的基本格式。另一张图片，当然，需要是WebP格式的！
- en: 'If you do not have the means already in place to convert your image to the
    WebP format, then you can do this using tools provided by Google, which are available
    for download at [https://developers.google.com/speed/webp/download](https://developers.google.com/speed/webp/download).
    Versions for Windows, Linux, and Mac OS are available for download here—for this
    exercise, I will assume that you are using Windows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有准备好将图像转换为WebP格式的方法，那么您可以使用谷歌提供的工具来进行转换，这些工具可在[https://developers.google.com/speed/webp/download](https://developers.google.com/speed/webp/download)下载。这里提供了Windows、Linux和Mac
    OS的下载版本——在本练习中，我将假设您正在使用Windows：
- en: On the download page, click on [http://downloads.webmproject.org/releases/webp/index.html](http://downloads.webmproject.org/releases/webp/index.html)
    and then look for `libwebp-0.4.2-windows-x64.zip` (if you are still using a 32-bit
    platform for Windows, then please select the `x86` version).
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下载页面上，单击[http://downloads.webmproject.org/releases/webp/index.html](http://downloads.webmproject.org/releases/webp/index.html)，然后查找`libwebp-0.4.2-windows-x64.zip`（如果您仍在使用32位Windows平台，请选择`x86`版本）。
- en: Once downloaded, extract the `libwebp-0.4.2-windows-x64` folder to a safe folder
    within your project folder and then navigate to the `bin` folder within it.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载后，将`libwebp-0.4.2-windows-x64`文件夹解压缩到项目文件夹中的一个安全文件夹中，然后导航到其中的`bin`文件夹。
- en: Open up a second Explorer view, then navigate to where your image is stored,
    and copy it into the `bin` folder.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开第二个资源管理器视图，然后导航到您存储图像的位置，并将其复制到`bin`文件夹中。
- en: Open up command prompt and then navigate to `C:\libwebp-0.4.2-windows-x64\bin`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符，然后导航到`C:\libwebp-0.4.2-windows-x64\bin`。
- en: 'At the prompt, enter this command, replacing both the names with the names
    of your JPEG and WebP images, respectively:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符下，输入此命令，将两个名称分别替换为您的JPEG和WebP图像的名称：
- en: '[PRE10]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If all is well, we will get a screen similar to the following screenshot, along
    with our WebP format image in the `bin` folder:![Getting started](img/image00339.jpeg)
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们将会得到一个类似于以下屏幕截图的屏幕，并且我们的WebP格式图像将会出现在`bin`文件夹中：![开始](img/image00339.jpeg)
- en: The last step is to copy the images into our project folder, so they are ready
    to be used for the next stage of our demo.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是将图像复制到我们的项目文件夹中，以便在我们的演示的下一阶段中使用。
- en: Creating our patch
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的补丁
- en: 'Now that we have our images prepared, we can go ahead and set up the markup
    for our demo:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好了图片，可以开始设置我们演示的标记了：
- en: 'Go ahead and copy the following code into a new file, saving it as `replacewebp.html`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下代码复制到一个新文件中，并将其保存为`replacewebp.html`：
- en: '[PRE11]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we need to add in our monkey patch—in a new file, add the following code
    and save it as `jquery.replacewebp.js`. This is a little more involved, so we''ll
    go through it in chunks, beginning with the standard declarations:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加我们的猴子补丁——在一个新文件中，添加以下代码并将其保存为`jquery.replacewebp.js`。这涉及到一些更复杂的内容，所以我们将分块介绍，从标准声明开始：
- en: '[PRE12]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next comes the function that performs the test to see whether our browser supports
    the use of the WebP image format; add the following code immediately below the
    variable assignments:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是执行测试以查看我们的浏览器是否支持使用WebP图像格式的函数；将以下代码立即添加到变量分配的下方：
- en: '[PRE13]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we make use of the `testWebP` function to determine whether our browser
    can support the WebP image format—if it can, we alter the file extension used
    to `.webp`, as follows:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`testWebP`函数来确定我们的浏览器是否支持WebP图像格式——如果支持，我们将更改所使用的文件扩展名为`.webp`，如下所示：
- en: '[PRE14]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We finish off our function by executing the original version of our function,
    before terminating it with the closing brackets normally associated with an IIFE:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过执行函数的原始版本来完成我们的函数，然后用与IIFE通常关联的关闭括号终止它：
- en: '[PRE15]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We then need to add one more function—this is used to initiate the call to
    `.hasClass()`; go ahead and add the following lines of code below the monkey patch
    function:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要再添加一个函数——这用于启动对`.hasClass()`的调用；继续添加以下代码行到猴子补丁函数的下方：
- en: '[PRE16]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If all went well, when we run our demo, we will see an image of an Phalaenopsis,
    or Moth Orchid, as shown in the following screenshot:![Creating our patch](img/image00340.jpeg)
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，当我们运行我们的演示时，我们将看到一幅蝴蝶兰或蛾蝶兰的图像，如下面的屏幕截图所示：![创建我们的补丁](img/image00340.jpeg)
- en: There is nothing out of the ordinary at this point; in fact, you're probably
    wondering what we've produced, right?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点并没有什么特别之处；实际上，你可能在想我们到底产生了什么，对吧？
- en: 'Aha! You''ll see the answer to this question if you inspect the source using
    a DOM inspector, such as Firebug, as shown here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哈！如果你使用DOM检查器（如Firebug）检查源代码，就会看到这个问题的答案，如下所示：
- en: '![Creating our patch](img/image00341.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们的补丁](img/image00341.jpeg)'
- en: 'Notice how it is showing a JPEG format image? That''s because Firefox doesn''t
    natively support this format out of the box; only Google Chrome does:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意它正在显示JPEG格式的图像？那是因为Firefox在出厂时不支持这种格式；只有Google Chrome支持：
- en: '![Creating our patch](img/image00342.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们的补丁](img/image00342.jpeg)'
- en: 'If you switch to using Google Chrome, then you can view the source by pressing
    *Ctrl* + *Shift* + *I*. You can clearly see the change in the format being used.
    If you are still in doubt, you can even take a look at the **Console** tab of
    Google Chrome. Here, it clearly shows that the patch has been referenced, as it
    displays the two messages that you expect to see:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您切换到使用Google Chrome，则可以通过按下*Ctrl* + *Shift* + *I*来查看源代码。您可以清楚地看到所使用格式的变化。如果您仍然怀疑，甚至可以查看Google
    Chrome的**控制台**选项卡。在这里，它清楚地显示了引用了补丁，因为它显示了您期望看到的两条消息：
- en: '![Creating our patch](img/image00343.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们的补丁](img/image00343.jpeg)'
- en: We've created our patch and it seems to work fine—that's all that we need to
    do, right? Wrong, there are more steps that we should consider, some of which
    may even prevent us from releasing the patch to a wider audience, at least for
    the time being.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了我们的补丁，它似乎运行正常——这就是我们需要做的全部了，对吗？错，还有更多步骤我们应该考虑，其中一些甚至可能会阻止我们将补丁发布给更广泛的受众，至少暂时是这样。
- en: There are some points that we need to consider and some actions that we may
    need to take as a result; let's pause for a moment and consider where we need
    to go from here, in terms of development.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些我们需要考虑的要点和可能需要采取的行动；让我们暂停一下，考虑一下我们需要从这里走向何方，就开发而言。
- en: Taking things further
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步的事情
- en: In this example, we've overwritten an existing method as a means to illustrate
    duck punching—in reality, we will need to spend a little more time finessing our
    patch before we can release it!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们重写了一个现有方法来说明“鸭子打”——实际上，在发布之前，我们需要再花一些时间来完善我们的补丁！
- en: 'The principle reason for this is the age-old issue of downloading more content
    than we really need; to prove this, take a look at the **Resources** tab of Google
    Chrome, when running the demo in that browser:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的主要原因是下载比我们实际需要的内容多；为了证明这一点，看一下在Google Chrome中运行演示时的**资源**选项卡：
- en: '![Taking things further](img/image00344.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![进一步的事情](img/image00344.jpeg)'
- en: 'As if we need further confirmation, this extract from the **Timeline** tab
    also confirms the presence of both the JPEG and WebP images being called and the
    resulting impact on download times:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们需要进一步确认一样，**时间轴**选项卡中的这段摘录也确认了JPEG和WebP图像的存在以及对下载时间的影响：
- en: '![Taking things further](img/image00345.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![进一步的事情](img/image00345.jpeg)'
- en: 'We created a patch here to illustrate what *can* be done; in reality, we will
    very likely include code to perform different actions on our content. As a start,
    we can do the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建了一个补丁，以说明*可以*做什么；实际上，我们很可能会包含代码来执行不同的操作在我们的内容上。首先，我们可以做以下操作：
- en: Include support for more image formats—this can include JPEG, GIF, or SVG.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括支持更多的图像格式——这可以包括JPEG，GIF或SVG。
- en: Hardcode the code to accept one image format; we can extend the usability of
    our patch by making it more generic.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码硬编码为接受一个图像格式；通过使其更通用，我们可以扩展我们补丁的可用性。
- en: jQuery is moving more toward a plugin-based architecture; should we really be
    considering patching the core code? There may be more mileage in creating a hook
    within the code, which then allows you to extend the existing functionality with
    a new plugin.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jQuery正朝着基于插件的架构发展；我们真的应该考虑修补核心代码吗？在代码中创建一个钩子可能会更有用，这样可以使用新插件扩展现有功能。
- en: We used `.hasClass()` as the basis for overriding an existing method; is this
    really the most appropriate thing to do? Although at face value it may appear
    to be useful, in reality, others may not agree with our choice of overriding `.hasClass`
    and consider other methods more useful.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了`.hasClass()`作为覆盖现有方法的基础；这真的是最合适的做法吗？虽然乍一看可能很有用，但实际上，其他人可能不同意我们覆盖`.hasClass`的选择，并认为其他方法更有用。
- en: There are plenty of questions that may be raised and need answering; it's only
    as a result of careful consideration that will we maximize any opportunity of
    our patch being successful and potentially consider it for submission to the core.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多问题可能会被提出并需要回答；只有经过仔细考虑，我们才能最大程度地使我们的补丁成功，并有可能考虑提交到核心中。
- en: Let's change tack and switch to examining a key part of monkey patching. The
    process has its risks, so let's take a moment to consider some of these risks
    and the impact these may have on our work.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改变方法，转而考虑猴子补丁的一个关键部分。这个过程有其风险，所以让我们花点时间考虑一下这些风险以及这些风险可能对我们的工作产生的影响。
- en: Considering the pitfalls of monkey patching
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑猴子补丁的缺陷
- en: 'Now that we''ve seen some examples in action, it''s worth taking a moment to
    consider some of the risks of monkey patching libraries, such as jQuery:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到一些示例在实际中的应用，值得花点时间考虑一下对库进行猴子补丁的一些风险，比如 jQuery：
- en: The principle risk and one that is likely to cause the most trouble is clashing.
    Imagine that you've created a patch that contains some functions—we'll call these
    functions `1`, `2`, and `3`. Add another patch, and it is essential that we do
    *not* use the same function names; otherwise, it's difficult to determine whether
    function `1`, or `2`, or even `3` comes first?
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要风险，也是最容易造成麻烦的风险是冲突。想象一下，您已经创建了一个包含一些函数的补丁——我们将这些函数称为 `1`、`2` 和 `3`。添加另一个补丁，重要的是我们不要使用相同的函数名称；否则，很难确定
    `1`、`2` 或甚至 `3` 哪一个先执行？
- en: Another risk is security. If a library such as jQuery can be monkey patched,
    what is to stop anyone from introducing malicious constructs that damage the existing
    code? One can argue that this risk is always present in client-side scripting;
    the risk is greater when you override core jQuery functionality, compared to a
    standard plugin.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个风险是安全性。如果 jQuery 等库可以进行猴子补丁，那么有什么能阻止任何人引入破坏现有代码的恶意构造？可以认为此风险在客户端脚本中始终存在；与标准插件相比，当您覆盖核心
    jQuery 功能时，风险更大。
- en: There is always a risk that an upgrade to the core library may introduce a change
    that not only breaks your patch but also removes or alters the functionality that
    would otherwise provide a basis for your patch to work. This will prevent a site
    that uses jQuery from being upgraded and ultimately leave it vulnerable to attack.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总会有一个风险，即对核心库的升级可能会引入更改，不仅会破坏您的补丁，而且会删除或修改否则可以为您的补丁提供基础的功能。这将阻止使用 jQuery 的网站升级，并最终使其容易受到攻击。
- en: Adding too many patches without due care and consideration will make your API
    bloated and slow; this will reduce responsiveness and make it harder to manage,
    as we have to spend more time dissecting the code before we can get to the crux
    of an issue.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加过多没有经过仔细考虑的补丁将使您的 API 庞大且缓慢；这将降低响应速度并使其更难管理，因为我们必须花更多时间剖析代码，然后才能找到问题的关键所在。
- en: Any monkey patches should really be kept within your site; they will be based
    on the code that directly alters jQuery, rather than use the predefined mechanism
    that a standard jQuery plugin provides. It is likely that authors may not have
    tested their monkey patches as extensively as they might have otherwise done for
    plugins; this presents a greater degree of risk if you are using someone else's
    patch.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何猴子补丁都应该真正保留在您的网站内部；它们将基于直接修改 jQuery 的代码，而不是使用标准 jQuery 插件提供的预定义机制。作者可能没有像他们为插件所做的那样广泛地测试他们的猴子补丁；如果您使用别人的补丁，这会带来更大的风险。
- en: If a patch contains a large number of functions, then the impact of changing
    the core functionality is higher and wider; making these changes may break someone
    else's patch or plugin.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个补丁包含大量函数，则更改核心功能的影响范围更广更大；进行这些更改可能会破坏其他人的补丁或插件。
- en: Ouch! There are serious concerns here! If we face these risks, then why use
    the process at all?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！这里有严重的问题！如果我们面临这些风险，那么为什么还要使用这个过程呢？
- en: 'This is a good question; when used judiciously, monkey patching is a useful
    technique to help provide that little extra functionality or correct an issue.
    It can even act as a means of stress testing the code before it is submitted for
    committal. There''s also an argument that says that the functionality should be
    included in a plugin, with good reason:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的问题；适当使用时，猴子补丁是一种有用的技术，可以提供额外的功能或纠正问题。它甚至可以作为提交之前对代码进行压力测试的手段。还有一个论点认为功能应该包含在插件中，有充分的理由：
- en: Plugins can be released for use by others; they can contribute fixes or updates
    via sites such as GitHub, if the plugin is available
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件可以发布供他人使用；如果插件可用，他们可以通过 GitHub 等网站贡献修复或更新。
- en: Plugins are likely to work with a wider range of versions of jQuery than a simple
    patch; the latter is likely to be tailored to fix a specific issue
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件可能与 jQuery 的更多版本兼容，而不仅仅是简单的补丁；后者可能专门用于修复特定问题。
- en: Producing a patch to cover multiple fixes may result in a large file size or
    a lot of changes to the core functionality; this is better managed within the
    framework of a plugin, which can include other functionality, such as internationalization
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作一个覆盖多个修复的补丁可能会导致文件大小较大或核心功能的许多更改；这在插件框架内更好地管理，可以包括其他功能，如国际化。
- en: The jQuery Core is moving toward a leaner, faster architecture; adding lots
    of patches will increase the level of redundant functionality and make it less
    appealing for use to other developers
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jQuery Core 正在朝着更精简、更快速的架构发展；添加大量补丁将增加冗余功能的水平，并使其对其他开发人员的使用不太吸引人。
- en: The key with monkey patching is not to abuse it; it is a valid tool but really
    only effective if you've exhausted all other possible solutions. If you have an
    urgent need for fixing an issue and cannot wait for an official update, then consider
    monkey patching jQuery—just be careful about how you do it!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 猴子补丁的关键不是滥用它；这是一个有效的工具，但只有在耗尽所有其他可能的解决方案后才真正有效。如果您急需修复问题并且不能等待官方更新，那么考虑猴子补丁
    jQuery—只是要小心如何操作！
- en: Distributing or applying patches
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发或应用补丁。
- en: 'Once our patch is completed, we need to distribute it; it is tempting to simply
    update a version of jQuery and release that with our plugin or use it within our
    site. There are some disadvantages of using this method though:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的补丁完成，我们需要分发它；诱人的是简单地更新 jQuery 版本并与我们的插件一起发布，或在我们的网站中使用它。然而，使用这种方法有一些缺点：
- en: We can't take advantage of our browser's caching capabilities; if we use a cached
    version of jQuery, then it will either not contain our patched code or pull a
    fresh copy from the server.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们无法利用浏览器的缓存功能；如果我们使用缓存版本的 jQuery，则要么不包含我们的修补代码，要么从服务器拉取一个新副本。
- en: Patching a copy of jQuery means that we're locked into that version of jQuery.
    This prevents the end user from being able to use their own version of jQuery,
    a CDN link, or even a newer version of jQuery (assuming that the patch still works!).
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 jQuery 的副本进行补丁意味着我们被锁定在那个版本的 jQuery 上。这会阻止最终用户能够使用他们自己的 jQuery 版本、CDN 链接，甚至是更新的
    jQuery 版本（假设补丁仍然有效！）。
- en: Allowing a patch to run separately at runtime means that it only patches the
    objects in the source code; if it goes horribly wrong, then we can drop the patch
    and still leave ourselves with a clean (unpatched) version of jQuery. Making changes
    to the source code does not afford us this luxury.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许补丁在运行时独立运行意味着它只会修补源代码中的对象；如果出现严重错误，那么我们可以放弃该补丁，仍然保留干净（未补丁）的 jQuery 版本。对源代码进行更改并不会给我们带来这种便利。
- en: 'Instead, there are some alternatives that we can use to apply patches:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以使用一些替代方法来应用补丁：
- en: We can simply include our patch in a separate file within our plugin or website—this
    keeps the Core jQuery library clean, although it means a slight overhead of requesting
    the patch file from the server. Users can then simply link to a copy of the file
    from runtime and discard if it circumstances change.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以简单地在插件或网站内的单独文件中包含我们的补丁—这样可以保持核心 jQuery 库的清洁，尽管这意味着从服务器请求补丁文件的轻微开销。用户然后可以简单地链接到运行时文件的副本，并在情况发生变化时丢弃。
- en: Patches can also be distributed as a Gist—this makes it independent of our site
    or plugin and allows others to comment or suggest tweaks that can be incorporated
    into our code.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 补丁也可以作为 Gist 分发—这使其独立于我们的网站或插件，并允许其他人评论或提出建议，这些建议可以纳入我们的代码中。
- en: Note
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'As an example, I''ve created the following Gist for the `replacewebp.js` patch—this
    is available at [https://gist.github.com/alibby251/89765d464e03ed6e0bc1](https://gist.github.com/alibby251/89765d464e03ed6e0bc1)
    and can be linked into projects as a means of distributing the code:'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，我为`replacewebp.js`补丁创建了以下 Gist—这可以在 [https://gist.github.com/alibby251/89765d464e03ed6e0bc1](https://gist.github.com/alibby251/89765d464e03ed6e0bc1)
    上找到，并且可以链接到项目中作为分发代码的手段：
- en: '[PRE17]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can take this a step further if the patch is available within a GitHub repository—either
    as part of an existing project or on its own. GitHub will allow users to submit
    pull requests in order to help improve an existing patch before it is considered
    for submission to core.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果补丁在 GitHub 存储库中可用—作为现有项目的一部分或独立存在。GitHub 将允许用户提交拉取请求以帮助改进现有补丁，然后再考虑提交到核心。
- en: 'There is an alternative route that we can take: the patch can be packaged and
    delivered via a frontend package manager, such as Bower ([http://www.bower.io](http://www.bower.io))
    or Jam ([http://www.jamjs.org](http://www.jamjs.org)).'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还有另一种选择：补丁可以通过前端包管理器（如 Bower ([http://www.bower.io](http://www.bower.io))
    或 Jam ([http://www.jamjs.org](http://www.jamjs.org))）进行打包和交付。
- en: Note
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on packaging content for download via Bower, please refer
    to [http://bower.io/docs/creating-packages/](http://bower.io/docs/creating-packages/).
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关通过 Bower 下载包装内容的更多信息，请参阅 [http://bower.io/docs/creating-packages/](http://bower.io/docs/creating-packages/)。
- en: These are some of the options we can use to distribute our patches; using a
    selection of these means that we can make our patch available to the widest possible
    audience and hopefully benefit from their testing and feedback!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们可以使用的分发补丁的一些选项；使用其中一些选项意味着我们可以让我们的补丁面向最广泛的受众，并希望从他们的测试和反馈中受益！
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: We've covered a lot of content in the last few pages, some of which may make
    your head spin, so let's take a breather and consider what we have learned.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几页中，我们涵盖了大量内容，其中一些可能会让你头晕，所以让我们喘口气，思考一下我们所学到的内容。
- en: We kicked off with an introduction to the patching of libraries, such as jQuery,
    and the term duck punching (or monkey patching). We looked at how we can replace
    or modify the existing behavior of jQuery by using this method, before moving
    on to create a basic monkey patch and working through its application to code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从介绍库的打补丁开始，比如 jQuery，并介绍了“鸭子补丁”（或者叫做猴子补丁）。我们看了如何使用这种方法替换或修改 jQuery 的现有行为，然后开始创建一个基本的猴子补丁，并详细解释了其在代码中的应用。
- en: Next up came a look at some of the benefits we can gain by using monkey patches;
    we spoke about the risk involved and some pitfalls that we need to consider when
    creating and applying patches.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下使用猴子补丁可以获得的一些好处；我们谈到了涉及的风险以及在创建和应用补丁时需要考虑的一些缺陷。
- en: We then switched to working through a number of demos that explored some of
    the ways in which we can alter code temporarily, before finishing with a look
    at how we can get our patches out into use for production.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们转而逐步完成了一些演示，探讨了一些我们可以暂时修改代码的方式，最后看了一下如何将我们的补丁用于生产环境。
- en: Developing any form of patch or plugin requires well-maintained code if were
    to be successful. In the next chapter, we'll see how we can improve our skills
    in this area, with a look at using design patterns to better organize our code.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 开发任何形式的补丁或插件都需要保持良好的代码才能成功。在下一章中，我们将看到如何通过学习设计模式来改善我们在这个领域的技能，以更好地组织我们的代码。
