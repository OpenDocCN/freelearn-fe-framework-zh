<html><head></head><body>
		<div>
			<div id="_idContainer323" class="Content">
			</div>
		</div>
		<div id="_idContainer324" class="Content">
			<h1 id="_idParaDest-232"><a id="_idTextAnchor312"/>11. Working with Vuex – Organizing Larger Stores</h1>
		</div>
		<div id="_idContainer328" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, you will learn how to better organize larger Vuex stores. As your applications grow in complexity and features, your store file may become harder to work with. Even simply finding things can become a difficult chore as the file grows larger and larger. This chapter will discuss two different approaches to making it easier to organize your stores for simpler updates. The first approach will have you splitting up your code across different files whereas the second will use a more advanced Vuex feature, modules.</p>
			<h1 id="_idParaDest-233"><a id="_idTextAnchor313"/>Introduction</h1>
			<p>So far, the stores we have worked on have been simple and short. But, as everyone knows, even the simplest of applications tend toward complexity over time. As you have learned in the previous chapters, your store can contain a <strong class="bold">state</strong>, a block of <strong class="bold">getters</strong>, a block of <strong class="bold">mutations</strong> and <strong class="bold">actions</strong>, and as you will learn later in this chapter, <strong class="bold">modules</strong>.</p>
			<p>As your application grows, having one file for your Vuex store could become hard to manage. Both bug fixing and updates for new functionality could become more difficult. This chapter will discuss two different ways to help manage this complexity and organize your Vuex stores. To be clear, these are <em class="italic">optional</em> things you can do to help manage your store. If your store is simple and you would like to keep it that way, that is fine. You can always use these approaches in the future, and the great thing is that no-one outside your store will need to be aware – they will continue to use Vuex data as they did before. You can keep these techniques in mind as a set of tools to help you when your application needs to level up. Let's start with the simplest of methods, file splitting.</p>
			<h1 id="_idParaDest-234"><a id="_idTextAnchor314"/>Approach One – Using File Splitting</h1>
			<p>The first approach, and certainly the simplest one, involves simply taking the code of your various Vuex parts (the <strong class="source-inline">state</strong>, the <strong class="source-inline">getters</strong>, and so forth) and moving them into their own files. These files can then be imported by the main Vuex Store and used as normal. Let's consider a simple example:</p>
			<p class="source-code">import Vue from 'vue'</p>
			<p class="source-code">import Vuex from 'vuex'</p>
			<p class="source-code">Vue.use(Vuex)</p>
			<p class="source-code">export default new Vuex.Store({</p>
			<p class="source-code">  state: {</p>
			<p class="source-code">    name:"Lindy", </p>
			<p class="source-code">    favoriteColor: "blue",</p>
			<p class="source-code">    profession: "librarian"</p>
			<p class="source-code">  },</p>
			<p class="source-code">  mutations: {</p>
			<p class="source-code">  },</p>
			<p class="source-code">  actions: {</p>
			<p class="source-code">  },</p>
			<p class="source-code">  modules: {</p>
			<p class="source-code">  }</p>
			<p class="source-code">})</p>
			<p>This is from the first exercise in <em class="italic">Chapter 9</em>, <em class="italic">Working with Vuex – State, Getters, Actions, and Mutations</em>, and is a store with only three state values. To migrate the state to a new file, you could create a new file in the <strong class="source-inline">store</strong> folder, called <strong class="source-inline">state.js</strong>, and set it up like so:</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  name: 'Lindy',</p>
			<p class="source-code">  favoriteColor: 'blue',</p>
			<p class="source-code">  profession: 'librarian'</p>
			<p class="source-code">}</p>
			<p>Then, back in your store, modify it to <strong class="source-inline">import</strong> and make use of the code:</p>
			<p class="source-code">import Vue from 'vue'</p>
			<p class="source-code">import Vuex from 'vuex'</p>
			<p class="source-code">Vue.use(Vuex)</p>
			<p class="source-code">import state from './state.js';</p>
			<p class="source-code">export default new Vuex.Store({</p>
			<p class="source-code">  state,</p>
			<p class="source-code">  mutations: {</p>
			<p class="source-code">  },</p>
			<p class="source-code">  actions: {</p>
			<p class="source-code">  },</p>
			<p class="source-code">  modules: {</p>
			<p class="source-code">  }</p>
			<p class="source-code">})</p>
			<p>While this example ends up being <em class="italic">more</em> lines of code, you can see how we are beginning to separate out different parts of the store into different files to make it easier to update. Let's consider a slightly larger example, again taking earlier work from the second exercise in <em class="italic">Chapter 9</em>, <em class="italic">Working with Vuex – State, Getters, Actions, and Mutations</em>. Here is the original store:</p>
			<p class="source-code">import Vue from 'vue'</p>
			<p class="source-code">import Vuex from 'vuex'</p>
			<p class="source-code">Vue.use(Vuex)</p>
			<p class="source-code">export default new Vuex.Store({</p>
			<p class="source-code">  state: {</p>
			<p class="source-code">    firstName: "Lindy",</p>
			<p class="source-code">    lastName: "Roberthon"</p>
			<p class="source-code">  },</p>
			<p class="source-code">  getters: {</p>
			<p class="source-code">    name(state) {</p>
			<p class="source-code">      return state.firstName + ' ' + state.lastName;</p>
			<p class="source-code">    }</p>
			<p class="source-code">  },</p>
			<p class="source-code">  mutations: {</p>
			<p class="source-code">  },</p>
			<p class="source-code">  actions: {</p>
			<p class="source-code">  },</p>
			<p class="source-code">  modules: {</p>
			<p class="source-code">  }</p>
			<p class="source-code">})</p>
			<p>This example only uses <strong class="source-inline">state</strong> values and a <strong class="source-inline">getter</strong>, but let's move both of them into new files. First, let's move the <strong class="source-inline">state</strong> into a file called <strong class="source-inline">state.js</strong>:</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  firstName: 'Lindy',</p>
			<p class="source-code">  lastName: 'Roberthon'</p>
			<p class="source-code">}</p>
			<p>And next, let's move the <strong class="source-inline">getters</strong> into a file called <strong class="source-inline">getters.js</strong>:</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  name(state) {</p>
			<p class="source-code">    return state.firstName + ' ' + state.lastName;</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Now we can update the store:</p>
			<p class="source-code">import Vue from 'vue'</p>
			<p class="source-code">import Vuex from 'vuex'</p>
			<p class="source-code">Vue.use(Vuex)</p>
			<p class="source-code">import state from './state.js';</p>
			<p class="source-code">import getters from './getters.js';</p>
			<p class="source-code">export default new Vuex.Store({</p>
			<p class="source-code">  state,</p>
			<p class="source-code">  getters,</p>
			<p class="source-code">  mutations: {</p>
			<p class="source-code">  },</p>
			<p class="source-code">  actions: {</p>
			<p class="source-code">  },</p>
			<p class="source-code">  modules: {</p>
			<p class="source-code">  }</p>
			<p class="source-code">})</p>
			<p>Applying the same type of update to <strong class="source-inline">mutations</strong> and <strong class="source-inline">actions</strong> would follow the exact same pattern, and obviously, you do not have to split everything. You could, for example, keep the state values in the main file but only split out your functions (<strong class="source-inline">getters</strong>, <strong class="source-inline">mutations</strong>, and <strong class="source-inline">actions</strong>).</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor315"/>Exercise 11.01: Using File Splitting</h2>
			<p>In this exercise, we are going to use file splitting across a slightly larger Vue store. Honestly, it is not very large at all, but we will use file splitting to handle <strong class="source-inline">state</strong>, <strong class="source-inline">getters</strong>, <strong class="source-inline">mutations</strong>, and <strong class="source-inline">actions</strong>.</p>
			<p>To access the code files for this exercise, visit <a href="https://packt.live/32uwiKB">https://packt.live/32uwiKB</a>:</p>
			<ol>
				<li>Generate a new Vue application and add Vuex support.</li>
				<li>Modify the default store's <strong class="source-inline">index.js</strong> file (located at <strong class="source-inline">src/store/index.js</strong>) to import the four files we will create to represent the store:<p class="source-code">import Vue from 'vue'</p><p class="source-code">import Vuex from 'vuex'</p><p class="source-code">Vue.use(Vuex)</p><p class="source-code">import state from './state.js';</p><p class="source-code">import getters from './getters.js';</p><p class="source-code">import mutations from './mutations.js';</p><p class="source-code">import actions from './actions.js';</p><p class="source-code">export default new Vuex.Store({</p><p class="source-code">  state,</p><p class="source-code">  getters,</p><p class="source-code">  mutations,</p><p class="source-code">  actions,</p><p class="source-code">  modules: {</p><p class="source-code">  }</p><p class="source-code">})</p></li>
				<li>Edit the new <strong class="source-inline">state.js</strong> file to add values for first and last names, numbers representing the amounts of cats and dogs possessed by the person in question, and a favorite film:<p class="source-code">export default {</p><p class="source-code">        firstName: 'Lindy',</p><p class="source-code">        lastName: 'Roberthon',</p><p class="source-code">        numCats: 5,</p><p class="source-code">        numDogs: 1,</p><p class="source-code">        favoriteFilm:''</p><p class="source-code">}</p></li>
				<li>Add a <strong class="source-inline">getter.js</strong> file that defines a <strong class="source-inline">getter</strong> for the full name and the total number of pets:<p class="source-code">export default {</p><p class="source-code">        name(state) {</p><p class="source-code">                return state.firstName + ' ' +state.lastName</p><p class="source-code">        },</p><p class="source-code">        totalPets(state) {</p><p class="source-code">                return state.numCats + state.numDogs</p><p class="source-code">        }</p><p class="source-code">}</p></li>
				<li>Next, add a <strong class="source-inline">mutations.js</strong> file for adding the number of cats and dogs, setting the first and last name, and adding the favorite film:<p class="source-code">export default {</p><p class="source-code">        addCat(state) {</p><p class="source-code">            state.numCats++;</p><p class="source-code">        },</p><p class="source-code">        addDog(state) {</p><p class="source-code">            state.numDogs++;</p><p class="source-code">        },</p><p class="source-code">        setFirstName(state, name) {</p><p class="source-code">            if(name !== '') state.firstName = name;</p><p class="source-code">        },</p><p class="source-code">        setLastName(state, name) {</p><p class="source-code">            if(name !== '') state.lastName = name;</p><p class="source-code">        },</p><p class="source-code">        setFavoriteFilm(state, film) {</p><p class="source-code">            if(film !== '') state.favoriteFilm = film;</p><p class="source-code">        }</p><p class="source-code">}</p></li>
				<li>Finally, add <strong class="source-inline">actions.js</strong> to define one action, <strong class="source-inline">updateFavoriteFilm</strong>. This will make a network request to the <strong class="source-inline">Star Wars</strong> API to ensure that the new favorite film is only allowed if it is a Star Wars film:<p class="source-code">export default {</p><p class="source-code">    async updateFavoriteFilm(context, film) {</p><p class="source-code">        try {</p><p class="source-code">            let response = await fetch('https://swapi.dev/api/films?search='+encodeURIComponent(film));</p><p class="source-code">            let data = await response.json();</p><p class="source-code">            if(data.count === 1) context.commit               ('setFavoriteFilm', film);</p><p class="source-code">            else console.log('Ignored setting non-Star Wars               film '+film+' as favorite.'); </p><p class="source-code">        } catch(e) {</p><p class="source-code">            console.error(e);</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>To see it in action, update <strong class="source-inline">src/App.vue</strong> to access various parts of the store. The only point of this step is to drive home the idea that how you use the store does not change:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app"&gt;</p><p class="source-code">    My first name is {{ $store.state.firstName }}.&lt;br/&gt;</p><p class="source-code">    My full name is {{ $store.getters.name }}.&lt;br/&gt;</p><p class="source-code">    I have this many pets - {{ $store.getters.totalPets }}.&lt;br/&gt;</p><p class="source-code">    My favorite film is {{ $store.state.favoriteFilm }}.</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  name: 'app',</p><p class="source-code">  created() {</p><p class="source-code">    this.$store.dispatch('updateFavoriteFilm', 'A New Hope');</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>The preceding code will generate an output as follows:</p><div id="_idContainer325" class="IMG---Figure"><img src="image/B15218_11_01.jpg" alt="Figure 11.1: Output from the newly organized store&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 11.1: Output from the newly organized store</p>
			<p>You have now seen a (somewhat simple) example of using file splitting to manage the size of your Vuex store. While the functionality is no different than what you have seen before, as your application grows, you will probably find it much easier to make additions and fixes.</p>
			<h1 id="_idParaDest-236"><a id="_idTextAnchor316"/>Approach Two – Using Modules</h1>
			<p>In the previous approach, we mainly just moved lines of code into other files. As we said, while this made it easier to work on the store itself, it changed nothing about how the store was used by Vue components. <strong class="bold">Modules</strong> help us deal with complexity at the level where components come in. </p>
			<p>Imagine a large <strong class="source-inline">state</strong> object containing values representing many different things, such as this one:</p>
			<p class="source-code">state: {</p>
			<p class="source-code">  name:"Lindy", </p>
			<p class="source-code">  favoriteColor: "blue", </p>
			<p class="source-code">  profession: "librarian", </p>
			<p class="source-code">  // lots more values about Lindy</p>
			<p class="source-code">  books: [</p>
			<p class="source-code">    { name: "An Umbrella on Fire", pages: 283 },</p>
			<p class="source-code">    { name: "Unicorn Whisperer", pages: 501 },</p>
			<p class="source-code">    // many, many more books</p>
			<p class="source-code">  ],</p>
			<p class="source-code">  robots: {</p>
			<p class="source-code">    skill:'advanced',</p>
			<p class="source-code">    totalAllowed: 10,</p>
			<p class="source-code">    robots: [</p>
			<p class="source-code">      { name: "Draconis" },</p>
			<p class="source-code">      // so much robots </p>
			<p class="source-code">    ]</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>This example contains information about a person, data related to books, and a set of values representing robots. That is a lot of data covering three uniquely different topics. Moving this into its own file does not necessarily make it easier to use or help keep things organized. This complexity would also spill over to <strong class="source-inline">getters</strong>, <strong class="source-inline">mutations</strong>, and <strong class="source-inline">actions</strong>. Given an action named <strong class="source-inline">setName</strong>, you could assume it applies to the state values representing the person, but if other state values had similar names, it could begin to get messy. </p>
			<p>This is where modules come in. A module allows us to define a separate <strong class="bold">bucket</strong> in our store for a portion of our data. Each module can have a unique <strong class="source-inline">state</strong>, <strong class="source-inline">getters</strong>, <strong class="source-inline">mutations</strong>, and <strong class="source-inline">actions</strong> completely separated from the <strong class="bold">root</strong> or core store. </p>
			<p>Here is an example store using a <strong class="source-inline">resume</strong> module:</p>
			<p class="source-code">import Vue from 'vue'</p>
			<p class="source-code">import Vuex from 'vuex'</p>
			<p class="source-code">Vue.use(Vuex)</p>
			<p class="source-code">export default new Vuex.Store({</p>
			<p class="source-code">  state: {</p>
			<p class="source-code">    firstName:'Raymond',</p>
			<p class="source-code">    lastName:'Camden'</p>
			<p class="source-code">  },</p>
			<p class="source-code">  getters: {</p>
			<p class="source-code">    name(state) {</p>
			<p class="source-code">      return state.firstName + ' ' + state.lastName;</p>
			<p class="source-code">    }</p>
			<p class="source-code">  },</p>
			<p class="source-code"> <a id="_idTextAnchor317"/> modules: {</p>
			<p class="source-code">    resume: {</p>
			<p class="source-code">      state: {</p>
			<p class="source-code">        forHire:true,</p>
			<p class="source-code">        jobs: [</p>
			<p class="source-code">          "Librarian", </p>
			<p class="source-code">          "Jedi",</p>
			<p class="source-code">          "Cat Herder"</p>
			<p class="source-code">        ]</p>
			<p class="source-code">      },</p>
			<p class="source-code">      getters: {</p>
			<p class="source-code">        totalJobs(state) {</p>
			<p class="source-code">          return state.jobs.length;</p>
			<p class="source-code">        }</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">})</p>
			<p>Both the <strong class="bold">root</strong> store and the <strong class="bold">module</strong> define <strong class="source-inline">state</strong> and <strong class="source-inline">getters</strong> but could also expose <strong class="source-inline">mutations</strong> and <strong class="source-inline">actions</strong>. Notice how in the <strong class="source-inline">resume</strong> module <strong class="source-inline">getters</strong>, <strong class="source-inline">totalJobs</strong>, the <strong class="source-inline">state</strong> variable refers to its own state, not that of the parent. This is great as it ensures you can work within the module and not worry about modifying, by accident, another value in the root or some other module. You can access the root state in <strong class="source-inline">getters</strong> by using a new third argument, <strong class="source-inline">rootState</strong>:</p>
			<p class="source-code">totalJobs(state, anyArgument, rootState)</p>
			<p>And actions can use <strong class="source-inline">rootState</strong> via the context object, <strong class="source-inline">context.rootState</strong>. In theory, though, your modules should concern themselves with their own data and only <strong class="bold">reach out</strong> to the root when necessary. </p>
			<p>When using module values, your code must know the name of the module. Consider the following example:</p>
			<p class="source-code">first name {{ $store.state.firstName }}&lt;br/&gt;</p>
			<p class="source-code">for hire? {{ $store.state.resume.forHire }}&lt;br/&gt;</p>
			<p><strong class="source-inline">getters</strong>, <strong class="source-inline">actions</strong>, and <strong class="source-inline">mutations</strong> are <em class="italic">not </em>differentiated, though. This is how you would access both <strong class="source-inline">getters</strong>:</p>
			<p class="source-code">full name {{ $store.getters.name }}&lt;br/&gt;</p>
			<p class="source-code">total jobs {{ $store.getters.totalJobs }}&lt;br/&gt;</p>
			<p>The idea behind this is to allow a module, or multiple modules, to potentially respond to the same calls. If this does not appeal to you, you can <strong class="bold">namespace</strong> your modules by passing in the <strong class="source-inline">namespaced</strong> option:</p>
			<p class="source-code">modules: {</p>
			<p class="source-code">  resume: {</p>
			<p class="source-code">    namespaced: true,</p>
			<p class="source-code">    state: {</p>
			<p class="source-code">      forHire:true,</p>
			<p class="source-code">      jobs: [</p>
			<p class="source-code">        "Librarian", </p>
			<p class="source-code">        "Jedi",</p>
			<p class="source-code">        "Cat Herder"</p>
			<p class="source-code">      ]</p>
			<p class="source-code">    },</p>
			<p class="source-code">    getters: {</p>
			<p class="source-code">      totalJobs(state) {</p>
			<p class="source-code">        return state.jobs.length;</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Then to refer to <strong class="source-inline">getters</strong>, <strong class="source-inline">mutations</strong>, and <strong class="source-inline">actions</strong> for this module, you must pass in the name of the module as part of the call. So, for example, the getter now becomes: <strong class="source-inline">$store.getters['resume/totalJobs']</strong>. </p>
			<p>For the most part, that is the core of module support, but note there are more options for how modules can expose themselves globally that are outside the scope of this book. See the latter parts of the module documentation (<a href="https://vuex.vuejs.org/guide/modules.html">https://vuex.vuejs.org/guide/modules.html</a>) for examples of that. Finally, note that you can build modules within modules as deep as you like. Obviously, you want to put some thought into building incredibly deeply nested modules, but if you want to do that, Vuex allows it!</p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor318"/>Exercise 11.02: Making Use of Modules</h2>
			<p>In this exercise, we'll work with a Vuex store that makes use of not one but two modules, and to make it more interesting, one of the modules will be stored in another file, showing that we can also use the first approach when using modules.</p>
			<p>To access the code files for this exercise, visit <a href="https://packt.live/35d1zDv">https://packt.live/35d1zDv</a>:</p>
			<ol>
				<li value="1">As usual, generate a new Vue application and ensure you add Vuex.</li>
				<li>In the store file (<strong class="source-inline">store/index.js</strong>), add two <strong class="source-inline">state</strong> values for the first and last names and a getter to return both:<p class="source-code">  state: {</p><p class="source-code">    firstName:'Raymond',</p><p class="source-code">    lastName:'Camden'</p><p class="source-code">  },</p><p class="source-code">  getters: {</p><p class="source-code">    name(state) {</p><p class="source-code">      return state.firstName + ' ' + state.lastName;</p><p class="source-code">    }</p><p class="source-code">  },</p></li>
				<li>Next, add a <strong class="source-inline">resume</strong> module to the <strong class="source-inline">store</strong> file. It will have two <strong class="source-inline">state</strong> values, one representing an open-for-hire value and the other, an array of past jobs. Lastly, add a getter to return the total number of jobs:<p class="source-code">  modules: {</p><p class="source-code">    resume: {</p><p class="source-code">      state: {</p><p class="source-code">        forHire:true,</p><p class="source-code">        jobs: [</p><p class="source-code">          "Librarian", </p><p class="source-code">          "Jedi",</p><p class="source-code">          "Cat Herder"</p><p class="source-code">        ]</p><p class="source-code">      },</p><p class="source-code">      getters: {</p><p class="source-code">        totalJobs(state) {</p><p class="source-code">          return state.jobs.length;</p><p class="source-code">        }</p><p class="source-code">      }</p><p class="source-code">    },</p></li>
				<li>Now create a new file for the next module, <strong class="source-inline">store/portfolio.js</strong>. This will contain a <strong class="source-inline">state</strong> value representing an array of websites worked on and a mutation to add a value:<p class="source-code">export default {</p><p class="source-code">        state: {</p><p class="source-code">            websites: [</p><p class="source-code">                "https://www.raymondcamden.com",</p><p class="source-code">                "https://codabreaker.rocks"</p><p class="source-code">            ]</p><p class="source-code">        },</p><p class="source-code">        mutations: {</p><p class="source-code">            addSite(state, url) {</p><p class="source-code">                state.websites.push(url);</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">}</p></li>
				<li>Back in the main store's <strong class="source-inline">index.js</strong> file, import <strong class="source-inline">portfolio</strong>:<p class="source-code">import portfolio from './portfolio.js';</p></li>
				<li>Then add <strong class="source-inline">portfolio</strong> to the list of modules, after <strong class="source-inline">resume</strong>:<p class="source-code">  modules: {</p><p class="source-code">    resume: {</p><p class="source-code">      state: {</p><p class="source-code">        forHire:true,</p><p class="source-code">        jobs: [</p><p class="source-code">          "Librarian", </p><p class="source-code">          "Jedi",</p><p class="source-code">          "Cat Herder"</p><p class="source-code">        ]</p><p class="source-code">      },</p><p class="source-code">      getters: {</p><p class="source-code">        totalJobs(state) {</p><p class="source-code">          return state.jobs.length;</p><p class="source-code">        }</p><p class="source-code">      }</p><p class="source-code">    },</p><p class="source-code">    portfolio</p><p class="source-code">  }</p></li>
				<li>Now, let's make use of the modules in our main <strong class="source-inline">src/App.vue</strong> file. Modify the template to add calls to various parts of the store:<p class="source-code">    &lt;p&gt;</p><p class="source-code">    My name is {{ $store.getters.name }} and I </p><p class="source-code">    &lt;span v-if="$store.state.resume.forHire"&gt;</p><p class="source-code">        am looking for work!</p><p class="source-code">    &lt;/span&gt;&lt;span v-else&gt;</p><p class="source-code">        am not looking for work.</p><p class="source-code">    &lt;/span&gt;</p><p class="source-code">    &lt;/p&gt;</p><p class="source-code">    &lt;p&gt;</p><p class="source-code">      I've had {{ $store.getters.totalJobs }} total jobs. </p><p class="source-code">    &lt;/p&gt;</p><p class="source-code">    &lt;h2&gt;Portfolio&lt;/h2&gt;</p><p class="source-code">    &lt;ul&gt;</p><p class="source-code">      &lt;li </p><p class="source-code">        v-for="(site,idx) in $store.state.portfolio.websites"</p><p class="source-code">        :key="idx"&gt;&lt;a :href="site" target="_new"&gt;{{ site }}&lt;/a&gt;&lt;/li&gt;</p><p class="source-code">    &lt;/ul&gt;</p></li>
				<li>Then add a <strong class="bold">form</strong> so that we can add a <strong class="bold">new website</strong>:<p class="source-code">    &lt;p&gt;</p><p class="source-code">      &lt;input type="url" placeholder="New site for portfolio"         v-model="site"&gt;</p><p class="source-code">      &lt;button @click="addSite"&gt;Add Site&lt;/button&gt;</p><p class="source-code">    &lt;/p&gt;</p></li>
				<li>Define the method for <strong class="source-inline">addSite</strong>. It will commit the <strong class="source-inline">mutation</strong> and clear the site value. Be sure to add a local data value for site as well. Here is the complete script block:<p class="source-code">export default {</p><p class="source-code">  name: 'app',</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      site:''</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  methods: {</p><p class="source-code">    addSite() {</p><p class="source-code">      this.$store.commit('addSite', this.site);</p><p class="source-code">      this.site = '';</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p>The result will look as follows:</p><div id="_idContainer326" class="IMG---Figure"><img src="image/B15218_11_02.jpg" alt="Figure 11.2: The application making use of Vuex data with modules&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 11.2: The application making use of Vuex data with modules</p>
			<p>Now you have seen yet another way to help manage your Vuex store. <strong class="bold">Modules</strong> provide a deeper, more complex way to organize your stores. As always, choose the method that best fits your application needs and the one you and your team are most comfortable with! </p>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor319"/>Other Approaches to Organizing Your Vuex Stores</h1>
			<p>While the previous two approaches should give you some good options for managing your Vuex store, there are a few other options you may wish to consider as well.</p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor320"/>Vuex Pathify</h2>
			<p>Vuex Pathify (<a href="https://davestewart.github.io/vuex-pathify/">https://davestewart.github.io/vuex-pathify/</a>) is a utility that makes it easier to access the Vuex store via a <strong class="bold">path</strong> API. So, for example, a store with a module called <strong class="source-inline">resume</strong> and a <strong class="source-inline">state</strong> value of <strong class="source-inline">jobs</strong> can be accessed like so: <strong class="source-inline">store.get('resume/jobs')</strong>. Basically, it creates a shortcut for reading and writing values to the store and simplifying synchronization. Fans of <strong class="bold">XPath</strong> will love this.</p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor321"/>Vuex Module Generator (VMG)</h2>
			<p><strong class="bold">VMG</strong> is a library that adds basic <strong class="bold">Create, Read, Update, Delete</strong> (<strong class="bold">CRUD</strong>) operations to your store to save you from rewriting common logic. You can import the library's features and then add them to your <strong class="source-inline">state</strong>, <strong class="source-inline">mutations</strong>, and <strong class="source-inline">actions</strong>. Anyone who has been in web development for any amount of time is familiar with the CRUD pattern and will absolutely jump for joy at not having to write those functions again.</p>
			<p>Check out the GitHub repository (<a href="https://github.com/abdullah/vuex-module-generator">https://github.com/abdullah/vuex-module-generator</a>) for more details and sample applications.</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor322"/>Vuex ORM</h2>
			<p><strong class="bold">Vuex ORM</strong> adds an <strong class="source-inline">ORM</strong> library to your Vuex store. <strong class="bold">ORM</strong> is short for <strong class="bold">object-relational mapping</strong> and is a pattern to help make object persistence simpler. Like VMG, Vuex ORM aims to simplify the rather common CRUD tasks web developers must write.</p>
			<p>Vuex ORM lets you define classes that represent the structure of your store data. Once you have defined the structure of the data, Vuex ORM then provides utility functions to make storing and retrieving that data in the store much simpler. It even handles relationships between data, such as a <strong class="bold">person</strong> who has an array of <strong class="source-inline">cat</strong> objects that belong to it.</p>
			<p>Here is an example of how you could define a type of data:</p>
			<p class="source-code">class Cat extends Model {</p>
			<p class="source-code">  static entity = 'cats'</p>
			<p class="source-code">  static fields () {</p>
			<p class="source-code">    return {</p>
			<p class="source-code">      id: this.attr(null),</p>
			<p class="source-code">      name: this.string(''),</p>
			<p class="source-code">      age: this.number(0),</p>
			<p class="source-code">      adoptable: this.boolean(true)</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>In the preceding class, four properties are defined for the <strong class="source-inline">Cat</strong> class: <strong class="source-inline">id</strong>, <strong class="source-inline">name</strong>, <strong class="source-inline">age</strong>, and <strong class="source-inline">adoptable</strong>. For each property, default values are specified. Once defined, asking for all the data is as simple as <strong class="source-inline">Cat.all()</strong>. There's a lot more to Vuex ORM, and you can check it out at <a href="https://vuex-orm.github.io/vuex-orm/">https://vuex-orm.github.io/vuex-orm/</a>.</p>
			<h2 id="_idParaDest-242">Ac<a id="_idTextAnchor323"/>tivity 11.01: Simplifying a Vuex Store</h2>
			<p>This activity will be a bit different than the ones you have done before. In this activity, you are going to take an <em class="italic">existing</em> application making use of Vuex and apply some of the techniques you have learned in this chapter in order to simplify the store and make it easier to use in future updates. This could be most useful when needing to tweak or fix existing functionality.</p>
			<p><strong class="bold">Steps:</strong></p>
			<ol>
				<li value="1">To begin this activity, you will use the completed example found at <strong class="source-inline">Chapter11/activity11.01/initial</strong> (<a href="https://packt.live/3kaqBHH">https://packt.live/3kaqBHH</a>).</li>
				<li>Modify the store file to place the <strong class="source-inline">state</strong>, <strong class="source-inline">getters</strong>, and <strong class="source-inline">mutations</strong> into their own file.</li>
				<li>Modify the <strong class="source-inline">state</strong> so that the <strong class="source-inline">cat</strong> values are in a <strong class="source-inline">module</strong>.</li>
				<li>Migrate the cat-related <strong class="source-inline">getter</strong> to the <strong class="source-inline">module</strong>.</li>
				<li>Update the <strong class="source-inline">App.vue</strong> file so that it still correctly displays the data it did initially.<p>This is how it looks when built:</p><div id="_idContainer327" class="IMG---Figure"><img src="image/B15218_11_03.jpg" alt="Figure 11.3: Final output of the activity&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 11.3: Final output of the activity</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found via <a href="B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor403">this link</a>.</p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor324"/>Summary</h1>
			<p>In this chapter, you learned multiple different techniques to prepare your Vuex stores for growing complexity. You first learned how to move logic into separate files and include them within your store. You then learned about modules and how they are exposed to components using the store. Finally, you learned about some optional libraries that may make your Vuex use even more powerful.</p>
			<p>In the next chapter, you are going to learn about an incredibly important aspect of development, unit testing.</p>
		</div>
		<div>
			<div id="_idContainer329" class="Content">
			</div>
		</div>
	</body></html>