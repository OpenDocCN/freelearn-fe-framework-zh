<html><head></head><body>
		<div id="_idContainer121">
			<h1 id="_idParaDest-145" class="chapter-number"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.1.1">11</span></h1>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.2.1">Managing Your Application’s State with Pinia</span></h1>
			<p><span class="koboSpan" id="kobo.3.1">Building web applications is no simple task, not only because of the amount of knowledge required to write them but also because of the architectural complexity that a mature application </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">can develop.</span></span></p>
			<p><span class="koboSpan" id="kobo.5.1">When we first started this book, we introduced simple topics such as the ability to replace text with string interpolation or hide an element with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.6.1">v-if</span></strong><span class="koboSpan" id="kobo.7.1"> directive. </span><span class="koboSpan" id="kobo.7.2">These features are at the core of the Vue.js framework and are needed to build an application with </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">this framework.</span></span></p>
			<p><span class="koboSpan" id="kobo.9.1">As we progressed in the book, we started to introduce topics that are not always required at the very start of your project development – and in some cases not needed at all. </span><span class="koboSpan" id="kobo.9.2">In the previous chapter, we covered Vue Router, which was the first additional package to join the Vue.js core framework. </span><span class="koboSpan" id="kobo.9.3">We are going to continue the trend by introducing another core maintained package that is part of the Vue </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">ecosystem: Pinia.</span></span></p>
			<p><span class="koboSpan" id="kobo.11.1">Pinia is the official state management package for Vue.js. </span><span class="koboSpan" id="kobo.11.2">It is the descendant of the previous state management package, which was </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">called Vuex.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.13.1">Why two different names?</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.14.1">If both packages have been created and maintained by the same open source maintainer, why do they have different names? </span><span class="koboSpan" id="kobo.14.2">Pinia was supposed to be called Vuex 5, but during its development, they decided to give it a different name due to the two versions being majorly different from </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">one another.</span></span></p>
			<p><span class="koboSpan" id="kobo.16.1">As I have already mentioned, some features are not always expected in every application, and state management is one of them. </span><span class="koboSpan" id="kobo.16.2">In fact, introducing state management on a very small site would probably be a sign </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">of over-architecture.</span></span></p>
			<p><span class="koboSpan" id="kobo.18.1">In this chapter, we are going to explain what state management is and introduce Pinia as the official package of the Vue.js ecosystem. </span><span class="koboSpan" id="kobo.18.2">We will then discuss when an application is expected to include a state management system and cover the pros and cons of using one. </span><span class="koboSpan" id="kobo.18.3">We will then do some practice by including two stores within our application: one to handle the sidebar and one to handle our posts. </span><span class="koboSpan" id="kobo.18.4">While doing so, we will also add a couple of features to our app, such as the ability to toggle the sidebar from the header and the option to add </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">new posts.</span></span></p>
			<p><span class="koboSpan" id="kobo.20.1">The chapter has the </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">following sections:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.22.1">When to use </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">state management</span></span></li>
				<li><span class="koboSpan" id="kobo.24.1">Learning about the structure of a </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">Pinia store</span></span></li>
				<li><span class="koboSpan" id="kobo.26.1">Centralized sidebar state management </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">with Pinia</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.28.1">By the end of the chapter, you should be familiar with the notion of state management and be able to define and use stores within your </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">future applications.</span></span></p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.30.1">Technical requirements</span></h1>
			<p><span class="koboSpan" id="kobo.31.1">In this chapter, the branch we will use is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.32.1">CH11</span></strong><span class="koboSpan" id="kobo.33.1">. </span><span class="koboSpan" id="kobo.33.2">To pull this branch, run the following command or use your GUI of choice to support you in </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">this operation:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.35.1">
git switch CH11</span></pre>
			<p><span class="koboSpan" id="kobo.36.1">The code files for the chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">at </span></span><a href="https://github.com/PacktPublishing/Vue.js-3-for-Beginners"><span class="No-Break"><span class="koboSpan" id="kobo.38.1">https://github.com/PacktPublishing/Vue.js-3-for-Beginners</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.39.1">.</span></span></p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.40.1">When to use state management</span></h1>
			<p><span class="koboSpan" id="kobo.41.1">The first and </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.42.1">most important part of this</span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.43.1"> chapter is learning when it is appropriate to use Pinia in your application and when it </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">is not.</span></span></p>
			<p><span class="koboSpan" id="kobo.45.1">All extra packages and features that are added to an application come with an extra cost. </span><span class="koboSpan" id="kobo.45.2">This cost is in the time that it takes to learn these new skills, the extra time that a new feature may take to build, the extra complexity that the overall architecture may add to the project, and finally the extra size that another package adds to your </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">JavaScript bundle.</span></span></p>
			<p><span class="koboSpan" id="kobo.47.1">Adding a state manager to your application falls into this category of possible features that may not always be needed. </span><span class="koboSpan" id="kobo.47.2">Luckily for us, adding and utilizing Pinia is simple and does not add as much overhead to the project as other counterparts such as </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">React Redux.</span></span></p>
			<p><span class="koboSpan" id="kobo.49.1">The rule of thumb is that state management should only be added to a project if the project is complex enough and includes many layers of components, and if passing values across the application </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">is complicated.</span></span></p>
			<p><span class="koboSpan" id="kobo.51.1">A good use case for Pinia is an application that is large, with properties being passed between many layers. </span><span class="koboSpan" id="kobo.51.2">Another use case would be a SPA that has very complex data that needs to be shared and manipulated by multiple parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">the application.</span></span></p>
			<p><span class="koboSpan" id="kobo.53.1">The main problem that state management</span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.54.1"> solves is </span><strong class="old"><span class="koboSpan" id="kobo.55.1"> prop drilling</span></strong><span class="koboSpan" id="kobo.56.1">. </span><span class="koboSpan" id="kobo.56.2">Therefore, the</span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.57.1"> more complex and deep the </span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.58.1">application structure is, the better suited Pinia is for </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">the project:</span></span></p>
			<div>
				<div id="_idContainer116" class="IMG---Figure">
					<span class="koboSpan" id="kobo.60.1"><img src="image/B21130_11_01_BW.jpg" alt="Figure 11.1: Properties are passed down to multiple layers of components"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.61.1">Figure 11.1: Properties are passed down to multiple layers of components</span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.62.1">What is prop drilling?</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.63.1">The process of passing </span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.64.1">data from parents to children, especially multiple layers deep, is also referred to as prop drilling. </span><span class="koboSpan" id="kobo.64.2">It is a commonly used term when talking about state management and will also be used in the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">this chapter.</span></span></p>
			<p><span class="koboSpan" id="kobo.66.1">Let’s analyze a few project examples and see whether we would need Pinia’s support to handle </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">state management:</span></span></p>
			<ul>
				<li><strong class="old"><span class="koboSpan" id="kobo.68.1">Brochure site</span></strong><span class="koboSpan" id="kobo.69.1">: A simple site with a couple of static pages, perfect for local businesses. </span><span class="koboSpan" id="kobo.69.2">The site may have a contact form. </span><span class="koboSpan" id="kobo.69.3">There is no real data that needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">be managed.</span></span><p class="list-inset"><em class="italic"><span class="koboSpan" id="kobo.71.1">Store </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.72.1">not needed</span></em></span></p></li>
				<li><strong class="old"><span class="koboSpan" id="kobo.73.1">A personal blog</span></strong><span class="koboSpan" id="kobo.74.1">: This site is a little more complex, with dynamic pages that render the blog pages as we learned about in the chapter on Vue Router. </span><span class="koboSpan" id="kobo.74.2">The data is passed to the pages, but it is not modified or needed in multiple parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">the application.</span></span><p class="list-inset"><em class="italic"><span class="koboSpan" id="kobo.76.1">Store </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.77.1">not needed</span></em></span></p></li>
				<li><strong class="old"><span class="koboSpan" id="kobo.78.1">An e-commerce site</span></strong><span class="koboSpan" id="kobo.79.1">: A commerce site used to sell products. </span><span class="koboSpan" id="kobo.79.2">This site will mostly be dynamic, with lots of interactivity offered throughout. </span><span class="koboSpan" id="kobo.79.3">Data needs to be passed and modified by many layers of the application, such as from the cart to </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">the checkout.</span></span><p class="list-inset"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.81.1">Store needed</span></em></span></p></li>
				<li><strong class="old"><span class="koboSpan" id="kobo.82.1">A social media site</span></strong><span class="koboSpan" id="kobo.83.1">: A site that is used to create and share posts. </span><span class="koboSpan" id="kobo.83.2">The site will also have pages filtered by user, tags, category, and so on. </span><span class="koboSpan" id="kobo.83.3">The same data can be reused in many parts of the application, and using a store can ensure the data is only fetched once and </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">then reused.</span></span><p class="list-inset"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.85.1">Store needed</span></em></span></p></li>
			</ul>
			<p><span class="koboSpan" id="kobo.86.1">Adding a state manager </span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.87.1">is</span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.88.1"> not a must for all sites, but a requirement that is driven by the specific use case and needs of your SPA. </span><span class="koboSpan" id="kobo.88.2">It is true that as you progress in your career and get familiar with the tools and technology that the framework has to offer, you will find yourself over-architecting your application more often than not. </span><span class="koboSpan" id="kobo.88.3">However, at the very start of your career, it is important to stay lean and only choose the tools that you really need for </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">your SPA.</span></span></p>
			<p><span class="koboSpan" id="kobo.90.1">Before moving on to the next section, we should say a few more words on the real benefits of using state management. </span><span class="koboSpan" id="kobo.90.2">We are going to do so by comparing two applications that have the same component structure but handle data differently. </span><span class="koboSpan" id="kobo.90.3">One uses prop drilling, while the other uses </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">state management.</span></span></p>
			<p><span class="koboSpan" id="kobo.92.1">We will start with the example shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.93.1">Figure 11</span></em></span><em class="italic"><span class="koboSpan" id="kobo.94.1">.1</span></em><span class="koboSpan" id="kobo.95.1">. </span><span class="koboSpan" id="kobo.95.2">That example is similar to our Companion App, and it shows the way the </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">post</span></strong><span class="koboSpan" id="kobo.97.1"> property flows from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">App.vue</span></strong><span class="koboSpan" id="kobo.99.1"> component all the way down to the last component to render the post on the screen. </span><span class="koboSpan" id="kobo.99.2">At this stage, the application is still quite simple. </span><span class="koboSpan" id="kobo.99.3">Even if there is some multi-layer prop drilling happening, the complexity is </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">still acceptable.</span></span></p>
			<p><span class="koboSpan" id="kobo.101.1">We are now going to add the possibility for a user to edit a post. </span><span class="koboSpan" id="kobo.101.2">Since properties can simply be modified in the component in which they are defined, we will have to emit an “edit” event all the way up the </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">component tree:</span></span></p>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<span class="koboSpan" id="kobo.103.1"><img src="image/B21130_11_02_BW.jpg" alt="Figure 11.2: Props are passed down and events are passed up the component tree"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.104.1">Figure 11.2: Props are passed down and events are passed up the component tree</span></p>
			<p><span class="koboSpan" id="kobo.105.1">The situation here</span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.106.1"> is </span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.107.1">starting to get more complicated. </span><span class="koboSpan" id="kobo.107.2">On top of prop drilling, we also</span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.108.1"> have </span><strong class="old"><span class="koboSpan" id="kobo.109.1">event </span></strong><strong class="old"><span class="koboSpan" id="kobo.110.1">bubbling</span></strong><span class="koboSpan" id="kobo.111.1">. </span><span class="koboSpan" id="kobo.111.2">The worst part of this scenario is the fact that when a single post changes, the whole component tree will have to be re-rendered because the components are all dependent on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">Post</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.113.1"> property.</span></span></p>
			<p><span class="koboSpan" id="kobo.114.1">We are going to include a Pinia store and see what changes it brings to the table. </span><span class="koboSpan" id="kobo.114.2">Pinia is going to take ownership of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">post</span></strong><span class="koboSpan" id="kobo.116.1"> property and provide it to the component that needs to read or </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">modify it:</span></span></p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<span class="koboSpan" id="kobo.118.1"><img src="image/B21130_11_03_BW.jpg" alt="Figure 11.3: A Pinia store managing the data"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.119.1">Figure 11.3: A Pinia store managing the data</span></p>
			<p><span class="koboSpan" id="kobo.120.1">Adding a store</span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.121.1"> has</span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.122.1"> removed a lot of complexity in our application. </span><span class="koboSpan" id="kobo.122.2">When we edit posts, the only component that we re-render now will be </span><strong class="old"><span class="koboSpan" id="kobo.123.1">Post Body</span></strong><span class="koboSpan" id="kobo.124.1">. </span><span class="koboSpan" id="kobo.124.2">Furthermore, the store easily allows us to pass specific data down, such as </span><strong class="old"><span class="koboSpan" id="kobo.125.1">Recent post</span></strong><span class="koboSpan" id="kobo.126.1"> in the sidebar. </span><span class="koboSpan" id="kobo.126.2">Doing so will also ensure that the sidebar will not be re-rendered unless the post that changed is included in it (this was also possible using props, but was not </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">usually practiced).</span></span></p>
			<p><span class="koboSpan" id="kobo.128.1">In this short section, we defined when state management is needed and when it should be omitted from your application. </span><span class="koboSpan" id="kobo.128.2">Then, we defined when a store is needed in your application by describing a few example applications. </span><span class="koboSpan" id="kobo.128.3">Finally, we introduced the notion of state management and covered the benefits that it brings to </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">your application.</span></span></p>
			<p><span class="koboSpan" id="kobo.130.1">In the next section, we </span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.131.1">are</span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.132.1"> going to learn about the structure of Pinia and how we can use it within </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">our application.</span></span></p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.134.1">Learning about the structure of a Pinia store</span></h1>
			<p><span class="koboSpan" id="kobo.135.1">In this chapter, we</span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.136.1"> are going to cover what makes up a Pinia store and how it can be used to support you in managing the data of your application. </span><span class="koboSpan" id="kobo.136.2">Pinia is built on the notion of multiple stores. </span><span class="koboSpan" id="kobo.136.3">Each individual store is going to manage a specific set of data or company logic that is not bound to a specific component. </span><span class="koboSpan" id="kobo.136.4">Your application could have a store for posts, a store for comments, and even a store to manage the state of </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">the sidebar.</span></span></p>
			<p><span class="koboSpan" id="kobo.138.1">Stores can talk with each other, but what matters the most is that you should be able to easily define what makes a single store. </span><span class="koboSpan" id="kobo.138.2">The stores’ data should be </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">split well.</span></span></p>
			<p><span class="koboSpan" id="kobo.140.1">Each store is divided into three different sections: </span><strong class="old"><span class="koboSpan" id="kobo.141.1">state</span></strong><span class="koboSpan" id="kobo.142.1">, </span><strong class="old"><span class="koboSpan" id="kobo.143.1">getters</span></strong><span class="koboSpan" id="kobo.144.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">and </span></span><span class="No-Break"><strong class="old"><span class="koboSpan" id="kobo.146.1">actions</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.148.1">These three sets of options that are available within a Pinia store can actually compare to existing features that we have learned about regarding Vue </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">Single-File Components.</span></span></p>
			<p><span class="koboSpan" id="kobo.150.1">The </span><strong class="old"><span class="koboSpan" id="kobo.151.1">state </span></strong><span class="koboSpan" id="kobo.152.1">object</span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.153.1"> defined in Pinia is comparable to Ref or Reactive used as private component data.  </span><span class="koboSpan" id="kobo.153.2">The </span><strong class="old"><span class="koboSpan" id="kobo.154.1">getters </span></strong><span class="koboSpan" id="kobo.155.1">are </span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.156.1">comparable to computed properties, as they are used to create a modified version of the existing </span><strong class="old"><span class="koboSpan" id="kobo.157.1">state</span></strong><span class="koboSpan" id="kobo.158.1">. </span><span class="koboSpan" id="kobo.158.2">Lastly, we have </span><a id="_idIndexMarker599"/><strong class="old"><span class="koboSpan" id="kobo.159.1">actions </span></strong><span class="koboSpan" id="kobo.160.1">that are like methods and are used to perform side effect on </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">the store.</span></span></p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<span class="koboSpan" id="kobo.162.1"><img src="image/B21130_11_04_BW.jpg" alt="Figure 11.4: Comparison between Pinia’s options and a Vue component"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.163.1">Figure 11.4: Comparison between Pinia’s options and a Vue component</span></p>
			<p><span class="koboSpan" id="kobo.164.1">When we first initialized the application, we opted for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">CLI</span></strong><span class="koboSpan" id="kobo.166.1"> command to create a store for us. </span><span class="koboSpan" id="kobo.166.2">For this reason, the Companion App includes a very simple store example here: </span><a href="https://src/stores/counter.js"><span class="koboSpan" id="kobo.167.1">src/stores/counter.js</span></a><span class="koboSpan" id="kobo.168.1">. </span><span class="koboSpan" id="kobo.168.2">Let’s </span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.169.1">see what it includes to learn more about the actual structure of a </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">Pinia store:</span></span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.171.1">src/stores/sidebar.js</span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.172.1">
import { defineStore } from 'pinia'
export const useCounterStore = defineStore('counter', {
  state: () =&gt; ({ count: 0, name: 'Eduardo' }),
  getters: {
    doubleCount: (state) =&gt; state.count * 2,
  },
  actions: {
    increment() {
      this.count++
    },
  },
})</span></pre>
			<p><span class="koboSpan" id="kobo.173.1">The first part of a store is its declaration. </span><span class="koboSpan" id="kobo.173.2">A store is declared using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">defineStore </span></strong><span class="koboSpan" id="kobo.175.1">method available within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">pinia</span></strong><span class="koboSpan" id="kobo.177.1"> package. </span><span class="koboSpan" id="kobo.177.2">When creating a store, it is common for the exported method to follow the format</span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.178.1"> of </span><strong class="old"><span class="koboSpan" id="kobo.179.1">use + store name + Store</span></strong><span class="koboSpan" id="kobo.180.1">. </span><span class="koboSpan" id="kobo.180.2">For example, for the store included in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">counter</span></strong><span class="koboSpan" id="kobo.182.1"> repository, we can expect the exported method to be </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">useCounterStore</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.186.1">Next, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">state</span></strong><span class="koboSpan" id="kobo.188.1"> object. </span><span class="koboSpan" id="kobo.188.2">This is declared as a function that returns an object. </span><span class="koboSpan" id="kobo.188.3">The syntax may look familiar because it is the same as the syntax that we introduced in </span><a href="B21130_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.189.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.190.1"> when we spoke about Vue components being declared using Options API. </span><span class="koboSpan" id="kobo.190.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">state</span></strong><span class="koboSpan" id="kobo.192.1"> object includes the values of the store at their </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">initial state.</span></span></p>
			<p><span class="koboSpan" id="kobo.194.1">Next, we have getters, which are the equivalent of the computed properties available within a Vue component. </span><span class="koboSpan" id="kobo.194.2">Getters are used to create a derivative value using </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">state</span></strong><span class="koboSpan" id="kobo.196.1"> or other getters. </span><span class="koboSpan" id="kobo.196.2">For example, in a post store, we may have getters for </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">visiblePost</span></strong><span class="koboSpan" id="kobo.198.1"> that just return the posts that have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">visible</span></strong><span class="koboSpan" id="kobo.200.1"> flag. </span><span class="koboSpan" id="kobo.200.2">Getters receive the state, as the first argument has shown in the previous code snippets within the </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">getters doubleCount</span></span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.203.1">Last, we have</span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.204.1"> actions. </span><span class="koboSpan" id="kobo.204.2">These are equivalent to methods and are used to trigger a side effect that can be used to modify one or more store entries. </span><span class="koboSpan" id="kobo.204.3">In our example, the action is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">increment</span></strong><span class="koboSpan" id="kobo.206.1">, and it is used to increase the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">count</span></strong><span class="koboSpan" id="kobo.208.1"> state. </span><span class="koboSpan" id="kobo.208.2">Actions are asynchronous and can include external side effects such as calling an API or calling other </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">store actions.</span></span></p>
			<p><span class="koboSpan" id="kobo.210.1">Now that we have learned how a store is structured, it is time to learn how to use a store within a component. </span><span class="koboSpan" id="kobo.210.2">To use a store within a component, we need to initialize it using the exported method generated using </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">definedStore</span></strong><span class="koboSpan" id="kobo.212.1">. </span><span class="koboSpan" id="kobo.212.2">In the instance of the counter store our initialization method would be </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">useCounterStore </span></strong><span class="koboSpan" id="kobo.214.1">that was defined in a previous </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">code block:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.216.1">
const counter = useCounterStore();</span></pre>
			<p><span class="koboSpan" id="kobo.217.1">Then use it to access the state </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">entries directly:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.219.1">
counter.count
counter.name</span></pre>
			<p><span class="koboSpan" id="kobo.220.1">The same is then applied for the getters </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">and actions:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.222.1">
counter.doubleCount
counter.increment()</span></pre>
			<p><span class="koboSpan" id="kobo.223.1">In this section, we introduced the basic structure of a Pinia store. </span><span class="koboSpan" id="kobo.223.2">We learned how to declare it using </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">defineStore</span></strong><span class="koboSpan" id="kobo.225.1">, then explained the three different parts of a store: state, getters, and actions. </span><span class="koboSpan" id="kobo.225.2">Finally, we learned how to access a store from the component by using </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.226.1">the counter store to learn the syntax required to access its state, getters, </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">and actions.</span></span></p>
			<p><span class="koboSpan" id="kobo.228.1">In the next section, we will apply what we have learned so far by creating a </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">few stores.</span></span></p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.230.1">Centralized sidebar state management with Pinia</span></h1>
			<p><span class="koboSpan" id="kobo.231.1">In the previous section, we </span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.232.1">introduced the basic structure and syntax of Pinia. </span><span class="koboSpan" id="kobo.232.2">To better learn and understand state management, we are going to modify our Companion App by refactoring some of the existing data into its own store. </span><span class="koboSpan" id="kobo.232.3">We are going to implement two different stores. </span><span class="koboSpan" id="kobo.232.4">The first is going to be a very simple store that will manage the state of the sidebar, while the second is going to </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">handle posts.</span></span></p>
			<p><span class="koboSpan" id="kobo.234.1">The store that handles the sidebar state is going to be quite small. </span><span class="koboSpan" id="kobo.234.2">It will be perfect for us to understand the basic syntax and usage of the store, while the one that handles posts is going to be a little </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">more complex.</span></span></p>
			<p><span class="koboSpan" id="kobo.236.1">State management should not be used for all data, and its addition should be accompanied by a good reason that supports its use. </span><span class="koboSpan" id="kobo.236.2">So, is it right to add it on </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">the sidebar?</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.238.1">Do your research</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.239.1">Go back to the code base and try to understand everything you can about the sidebar and how it functions. </span><span class="koboSpan" id="kobo.239.2">Exploratory knowledge is very useful in developing your </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">tech skills.</span></span></p>
			<p><span class="koboSpan" id="kobo.241.1">The sidebar currently offers </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">these features:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.243.1">It can either be opened </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">or closed</span></span></li>
				<li><span class="koboSpan" id="kobo.245.1">It can be toggled with the use of </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">a button</span></span></li>
				<li><span class="koboSpan" id="kobo.247.1">It remembers its state using </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">local storage</span></span></li>
				<li><span class="koboSpan" id="kobo.249.1">All the logic is included within the </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">same component</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.251.1">Our simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">Sidebar.vue</span></strong><span class="koboSpan" id="kobo.253.1"> component makes our sidebar nice and interactive. </span><span class="koboSpan" id="kobo.253.2">But from the preceding list, one line should catch our eye: “All the logic is included within the </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">same component.”</span></span></p>
			<p><span class="koboSpan" id="kobo.255.1">If you jump back to the previous section, you may notice that we mentioned that the use of a store is usually associated with complex scenarios whereby data is passed between multiple components. </span><span class="koboSpan" id="kobo.255.2">However, in our case, all the data is stored in just one file and there is not much logic or computation. </span><span class="koboSpan" id="kobo.255.3">So why would we need to include a store? </span><span class="koboSpan" id="kobo.255.4">And is it a good idea to </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">do so?</span></span></p>
			<p><span class="koboSpan" id="kobo.257.1">The short answer is no. </span><span class="koboSpan" id="kobo.257.2">In a scenario like this, a store is not actually needed. </span><span class="koboSpan" id="kobo.257.3">Even if I may handle sidebars with a store in my personal projects, I would not suggest that everyone should do so with all </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">Vue projects.</span></span></p>
			<p><span class="koboSpan" id="kobo.259.1">In its current state, the sidebar is too simple for it to be moved into a </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">Pinia store.</span></span></p>
			<p><span class="koboSpan" id="kobo.261.1">Luckily for us, we have full control of the application, so we can simply add a requirement that would make the use of a store appropriate. </span><span class="koboSpan" id="kobo.261.2">In this situation, the new requirement is going to be to </span><em class="italic"><span class="koboSpan" id="kobo.262.1">add the ability to toggle the sidebar from the </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.263.1">main header</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.265.1">Even if this requirement seems unreasonable, it is very common for the sidebar to be controlled by a</span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.266.1"> different element. </span><span class="koboSpan" id="kobo.266.2">This scenario could become reality for your </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">next project.</span></span></p>
			<p><span class="koboSpan" id="kobo.268.1">To accomplish this new requirement, we would need to perform some prop drilling and event bubbling for it to work without a store. </span><span class="koboSpan" id="kobo.268.2">However, with the use of a simple store, the logic is going to be abstracted from the component and easily accessible by the </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">whole application.</span></span></p>
			<p><span class="koboSpan" id="kobo.270.1">The creation of our first store is going to require two steps. </span><span class="koboSpan" id="kobo.270.2">First, we are going to refactor our application by moving the existing methods and data into the store. </span><span class="koboSpan" id="kobo.270.3">Second, we are going to update the components to use the newly </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">created store.</span></span></p>
			<p><span class="koboSpan" id="kobo.272.1">As we mentioned before, all of the logic that handles the sidebar switching is currently stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">Sidebar.vue</span></strong><span class="koboSpan" id="kobo.274.1"> component. </span><span class="koboSpan" id="kobo.274.2">Within this component, we can find the following code linked to the </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">sidebar toggling:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.276.1">Declaration of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">closed</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.278.1"> state:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.279.1">
const closed = ref(false);</span></pre></li>
				<li><span class="koboSpan" id="kobo.280.1">Method to toggle </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">the sidebar:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.282.1">
const toggleSidebar = () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.283.1">
  closed.value = !closed.value;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.284.1">
  window.localStorage.setItem("sidebar", closed.value);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.285.1">
}</span></pre></li>
				<li><span class="koboSpan" id="kobo.286.1">Life cycle to initialize the </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">sidebar state:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.288.1">
onBeforeMount( () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.289.1">
  const sidebarState = window.localStorage.getItem("sidebar");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.290.1">
  closed.value = sidebarState === "true";</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.291.1">
});</span></pre></li>
			</ul>
			<p><span class="koboSpan" id="kobo.292.1">Let’s go and </span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.293.1">create our </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">first store.</span></span></p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.295.1">Creating our first store</span></h2>
			<p><span class="koboSpan" id="kobo.296.1">We are now going to</span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.297.1"> take the preceding code and move it into a new store named </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">sidebar.js</span></strong><span class="koboSpan" id="kobo.299.1">. </span><span class="koboSpan" id="kobo.299.2">Just like we mentioned before, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">Ref</span></strong><span class="koboSpan" id="kobo.301.1"> variable is going to change into </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">State </span></strong><span class="koboSpan" id="kobo.303.1">and the methods are going to become </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">Pinia actions.</span></span></p>
			<p><span class="koboSpan" id="kobo.305.1">Let’s start by creating an empty structure for </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">our store:</span></span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.307.1">src/stores/sidebar.js</span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.308.1">
import { defineStore } from 'pinia'
export const useSidebarStore = defineStore('sidebar', {
  state: () =&gt; ({}),
  getters: {},
  actions: {},
})</span></pre>
			<p><span class="koboSpan" id="kobo.309.1">Our empty store includes the import of </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">defineStore</span></strong><span class="koboSpan" id="kobo.311.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">pinia</span></strong><span class="koboSpan" id="kobo.313.1"> package, the initialization of the store using the naming convention that we mentioned before (use + store name + Store) that creates </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">useSidebarStore</span></strong><span class="koboSpan" id="kobo.315.1">, and lastly three empty options for state, getters, </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">and actions.</span></span></p>
			<p><span class="koboSpan" id="kobo.317.1">At this stage, the store is ready to be filled with information. </span><span class="koboSpan" id="kobo.317.2">Let’s populate it with the </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">sidebar logic:</span></span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.319.1">src/stores/sidebar.js</span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.320.1">
import { defineStore } from 'pinia'
export const useSidebarStore = defineStore('sidebar', {
  state: () =&gt; ({ closed: true }),
  getters: {},
  actions: {
    toggleSidebar() {
      this.closed = !this.closed
      localStorage.setItem('sidebar', this.closed)
    },
    loadSidebarFromLocalStorage() {
      const closed = localStorage.getItem('sidebar')
      this.closed = closed === 'true'
    }
  },
})</span></pre>
			<p><span class="koboSpan" id="kobo.321.1">In the preceding</span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.322.1"> code, we declared a new value in the state object called </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">closed</span></strong><span class="koboSpan" id="kobo.324.1">. </span><span class="koboSpan" id="kobo.324.2">This has been set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">true</span></strong><span class="koboSpan" id="kobo.326.1"> initially. </span><span class="koboSpan" id="kobo.326.2">We have left the </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">getters</span></strong><span class="koboSpan" id="kobo.328.1"> untouched for now, as it is going to be used later in the section. </span><span class="koboSpan" id="kobo.328.2">Next, we declared two actions. </span><span class="koboSpan" id="kobo.328.3">One was to toggle the sidebar and the other was to load the sidebar from the local storage using existing code from our </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">previous methods.</span></span></p>
			<p><span class="koboSpan" id="kobo.330.1">If we compare the code within the actions with methods that existed in the component, you will notice that they are very similar. </span><span class="koboSpan" id="kobo.330.2">The main difference is in the way in which we can access the state. </span><span class="koboSpan" id="kobo.330.3">In fact, when these methods were in the component, we had to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">closed.value</span></strong><span class="koboSpan" id="kobo.332.1"> to access the value of the ref, while in Pinia, the value of individual state entities can be accessed using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">this.closed</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.334.1"> keyword.</span></span></p>
			<p><span class="koboSpan" id="kobo.335.1">Now that our store is complete, we just need to go back into the sidebar and replace the previous logic with the new store. </span><span class="koboSpan" id="kobo.335.2">Replacing the current logic with the store will require three steps. </span><span class="koboSpan" id="kobo.335.3">First, we need to load and initialize the store. </span><span class="koboSpan" id="kobo.335.4">Second, we need to replace the methods with Pinia actions, and finally, we need to modify the template to use the state from the store and not </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">the ref.</span></span></p>
			<p><span class="koboSpan" id="kobo.337.1">Let’s start by removing the previous ref and initialize </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">the store:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.339.1">
import IconRightArrow from '../icons/IconRightArrow.vue'
</span><strong class="old"><span class="koboSpan" id="kobo.340.1">import { useSidebarStore } from '../../stores/sidebar';</span></strong><span class="koboSpan" id="kobo.341.1">
const currentTime = ref(new Date().toLocaleTimeString());
const router = useRouter();
</span><strong class="old"><span class="koboSpan" id="kobo.342.1">const closed = ref(false);</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.343.1">const sidebarStore = useSidebarStore();</span></strong></pre>
			<p><span class="koboSpan" id="kobo.344.1">The store is</span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.345.1"> initialized by importing and calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">useSidebarStore</span></strong><span class="koboSpan" id="kobo.347.1">. </span><span class="koboSpan" id="kobo.347.2">This is the exported method that we declared in the store. </span><span class="koboSpan" id="kobo.347.3">It is common to declare a constant called either just </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">store</span></strong><span class="koboSpan" id="kobo.349.1"> or the name + </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">Store</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.352.1">Did you know?</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.353.1">Using specific names for the store such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">sidebarStore</span></strong><span class="koboSpan" id="kobo.355.1"> rather than just calling it </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">Store</span></strong><span class="koboSpan" id="kobo.357.1"> can be very beneficial when trying to search for all the usages of a specific store. </span><span class="koboSpan" id="kobo.357.2">Since using state management allows you to use this logic anywhere in the app, it is nice to be able to search for it quickly, so having a consistent naming convention </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">is helpful.</span></span></p>
			<p><span class="koboSpan" id="kobo.359.1">In the next step, we are going to work on the methods. </span><span class="koboSpan" id="kobo.359.2">We will remove existing methods and replace them with the </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">store actions:</span></span></p>
			<pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.361.1">const toggleSidebar = () =&gt; {</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.362.1">  closed.value = !closed.value;</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.363.1">  window.localStorage.setItem("sidebar", closed.value);</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.364.1">}</span></strong><span class="koboSpan" id="kobo.365.1">
const onUpdateTimeClick = () =&gt; {
  currentTime.value = new Date().toLocaleTimeString();
};
const navigateToPrivacy = (event) =&gt; {
  event.preventDefault();
  console.log("Run a side effect");
  router.push("privacy");
}
onBeforeMount ( () =&gt; {
</span><strong class="old"><span class="koboSpan" id="kobo.366.1">  const sidebarState = window.localStorage.getItem("sidebar");</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.367.1">    closed.value = sidebarState === "true";</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.368.1">  sidebarStore.loadSidebarFromLocalStorage();</span></strong><span class="koboSpan" id="kobo.369.1">
});</span></pre>
			<p><span class="koboSpan" id="kobo.370.1">Just like before, the</span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.371.1"> preceding code includes two steps. </span><span class="koboSpan" id="kobo.371.2">It first removes the previous logic and then replaces it with the store implementation. </span><span class="koboSpan" id="kobo.371.3">We updated the content of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">onBeforeMount</span></strong><span class="koboSpan" id="kobo.373.1"> life cycle by removing the logic that handles the retrieval of the sidebar from the state and replacing it with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">loadSidebarFromLocalStorage</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.375.1"> action.</span></span></p>
			<p><span class="koboSpan" id="kobo.376.1">You may have noticed that we have not replaced the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">toggleSidebar</span></strong><span class="koboSpan" id="kobo.378.1"> method yet. </span><span class="koboSpan" id="kobo.378.2">This was not a mistake; in fact, we are going to be able to call the Pinia action directly </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">&lt;template&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.382.1">Let’s see which changes are needed in the HTML of our component to complete our refactoring into a </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">Pinia store:</span></span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.384.1">src/components/organisms/sidebar.vue</span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.385.1">
&lt;template&gt;
  &lt;aside :class="{ 'sidebar__closed': sidebarStore.closed}"&gt;
    &lt;template v-if="</span><strong class="old"><span class="koboSpan" id="kobo.386.1">sidebarStore.</span></strong><span class="koboSpan" id="kobo.387.1">closed"&gt;
      &lt;IconRightArrow class="sidebar__icon" @click="</span><strong class="old"><span class="koboSpan" id="kobo.388.1">sidebarStore.</span></strong><span class="koboSpan" id="kobo.389.1">toggleSidebar" /&gt;
    &lt;/template&gt;
    &lt;template v-else&gt;
      &lt;h2&gt;Sidebar&lt;/h2&gt;
      &lt;IconLeftArrow class="sidebar__icon" @click="</span><strong class="old"><span class="koboSpan" id="kobo.390.1">sidebarStore.</span></strong><span class="koboSpan" id="kobo.391.1">toggleSidebar" /&gt;
      &lt;TheButton&gt;Create post&lt;/TheButton&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.392.1">Updating the HTML is the easiest change of all. </span><span class="koboSpan" id="kobo.392.2">In fact, the only requirement here is to prepend all states and actions with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">sidebarStore</span></strong><span class="koboSpan" id="kobo.394.1"> store constant. </span><span class="koboSpan" id="kobo.394.2">Just like actions, state values can also be accessed directly as shown by </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">sidebarStore.closed</span></strong><span class="koboSpan" id="kobo.396.1">. </span><span class="koboSpan" id="kobo.396.2">This was used to access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">closed</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.398.1">state value.</span></span></p>
			<p><span class="koboSpan" id="kobo.399.1">At this stage, our refactoring of the sidebar is complete. </span><span class="koboSpan" id="kobo.399.2">All the logic that used to live within the component has been moved into a new store. </span><span class="koboSpan" id="kobo.399.3">The sidebar should work as expected, with the only difference being that its value and logic are stored in a store and not in the </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">component itself.</span></span></p>
			<p><span class="koboSpan" id="kobo.401.1">To complete our</span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.402.1"> task, we need to allow another part of the application to toggle the sidebar. </span><span class="koboSpan" id="kobo.402.2">This was the requirement that we added to justify our store creation and to learn about the store in </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">more detail.</span></span></p>
			<h3><span class="koboSpan" id="kobo.404.1">Expanding the sidebar into the header</span></h3>
			<p><span class="koboSpan" id="kobo.405.1">In this section, we are</span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.406.1"> going to work in the header to complete our task by adding the ability to toggle the sidebar visibility from a different part of </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">the application.</span></span></p>
			<p><span class="koboSpan" id="kobo.408.1">We are going to do so by adding a simple button next to the settings icon in the header. </span><span class="koboSpan" id="kobo.408.2">Just like before, we are going to import and initialize the store and then use its actions directly. </span><span class="koboSpan" id="kobo.408.3">It is important to remember that this new button could have been placed anywhere within the application, since its action is owned and controlled by </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">the store.</span></span></p>
			<p><span class="koboSpan" id="kobo.410.1">Let’s go into </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">TheHeader.vue</span></strong><span class="koboSpan" id="kobo.412.1"> and add </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">the store:</span></span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.414.1">src/stores/TheHeader.vue</span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.415.1">
&lt;template&gt;
  &lt;header&gt;
    &lt;TheLogo /&gt;
    &lt;h1&gt;Companion app&lt;/h1&gt;
    &lt;span&gt;
      &lt;a href="#"&gt;Welcome {{ username }}&lt;/a&gt;
      &lt;IconSettings class="icon" /&gt;
      </span><strong class="old"><span class="koboSpan" id="kobo.416.1">&lt;IconFullScreen class="icon" @click="sidebarStore.toggleSidebar" /&gt;</span></strong><span class="koboSpan" id="kobo.417.1">
    &lt;/span&gt;
  &lt;/header&gt;
&lt;/template&gt;
&lt;script setup&gt;
import { ref } from 'vue';
import TheLogo from '../atoms/TheLogo.vue';
import IconSettings from '../icons/IconSettings.vue';
import IconFullScreen from '../icons/IconFullScreen.vue';
</span><strong class="old"><span class="koboSpan" id="kobo.418.1">import { useSidebarStore } from '../../stores/sidebar';</span></strong><span class="koboSpan" id="kobo.419.1">
const username = ref("Zelig880");
</span><strong class="old"><span class="koboSpan" id="kobo.420.1">const sidebarStore = useSidebarStore();</span></strong><span class="koboSpan" id="kobo.421.1">
&lt;/script&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.422.1">There is no difference </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.423.1">between the code we just wrote in the header and the one that we previously defined in the sidebar. </span><span class="koboSpan" id="kobo.423.2">In fact, when using a store, we are able to use it anywhere we want in the application without having to define anything else. </span><span class="koboSpan" id="kobo.423.3">All instances of the store will work as one, allowing us to use and modify states from different parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">the application.</span></span></p>
			<p><span class="koboSpan" id="kobo.425.1">At this stage, our </span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.426.1">Companion App will have an added feature that will allow us to toggle the sidebar either by using the sidebar itself or from </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">the header.</span></span></p>
			<h3><span class="koboSpan" id="kobo.428.1">Introducing the notion of getters</span></h3>
			<p><span class="koboSpan" id="kobo.429.1">Before we</span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.430.1"> move to the next section in this chapter, we should introduce another feature of the store that was mentioned but not yet used in our Companion </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">App: getters.</span></span></p>
			<p><span class="koboSpan" id="kobo.432.1">Getters are comparable to computed properties. </span><span class="koboSpan" id="kobo.432.2">They allow you to create variables with the use of the store state. </span><span class="koboSpan" id="kobo.432.3">In our case, we are going to introduce a simple getter that will create a friendly </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">open</span></strong><span class="koboSpan" id="kobo.434.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">closed</span></strong><span class="koboSpan" id="kobo.436.1"> label for our sidebar. </span><span class="koboSpan" id="kobo.436.2">Outside of this use case, getters can be used for translation purposes, to filter arrays, or to </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">normalize data.</span></span></p>
			<p><span class="koboSpan" id="kobo.438.1">Let’s go back to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">sidebar.js</span></strong><span class="koboSpan" id="kobo.440.1">  file and add our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">friendlyState</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.442.1"> getter:</span></span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.443.1">src/stores/sidebar.js</span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.444.1">
state: () =&gt; (
  { closed: true }
),
getters: {
</span><strong class="old"><span class="koboSpan" id="kobo.445.1">  friendlyState(state) {</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.446.1">    return state.closed ? </span><span class="koboSpan" id="kobo.446.2">"closed" : "open";</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.447.1">  }</span></strong><span class="koboSpan" id="kobo.448.1">
},
actions: {
...</span></pre>
			<p><span class="koboSpan" id="kobo.449.1">Creating a getter is very simple. </span><span class="koboSpan" id="kobo.449.2">You must declare a method within the getters object and then add the logic to create the value that is going to be returned by the getters. </span><span class="koboSpan" id="kobo.449.3">Just like computed properties, this is going to be cached. </span><span class="koboSpan" id="kobo.449.4">More importantly, it is not supposed to produce any side effects (e.g., calling an API or </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">logging data).</span></span></p>
			<p><span class="koboSpan" id="kobo.451.1">The main point to raise about getters is that they automatically receive the state object as the first argument. </span><span class="koboSpan" id="kobo.451.2">So, to access the closed state, we would write </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">state.closed</span></strong><span class="koboSpan" id="kobo.453.1">. </span><span class="koboSpan" id="kobo.453.2">Just like computed properties, thanks to the Vue reactivity system, if the state value changes, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">friendlyState</span></strong><span class="koboSpan" id="kobo.455.1"> value will also </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">update automatically.</span></span></p>
			<p><span class="koboSpan" id="kobo.457.1">Now that our getter is in place, it is time to use it. </span><span class="koboSpan" id="kobo.457.2">We are going back to the headers and adding this string to be visible right below the user settings. </span><span class="koboSpan" id="kobo.457.3">We can reuse the store we previously</span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.458.1"> imported to access the newly </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">defined getter:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.460.1">
&lt;template&gt;
&lt;header&gt;
  &lt;TheLogo /&gt;
  &lt;h1&gt;Companion app&lt;/h1&gt;
  &lt;span&gt;
    &lt;a href="#"&gt;Welcome {{ username }}&lt;/a&gt;
    &lt;IconSettings class="icon" /&gt;
    &lt;IconFullScreen class="icon" @click="sidebarStore.toggleSidebar" /&gt;
    </span><strong class="old"><span class="koboSpan" id="kobo.461.1">&lt;p&gt;Sidebar state: {{ sidebarStore.friendlyState }}&lt;/p&gt;</span></strong><span class="koboSpan" id="kobo.462.1">
  &lt;/span&gt;
&lt;/header&gt;
&lt;/template&gt;
&lt;script setup&gt;
import { ref } from 'vue';
import TheLogo from '../atoms/TheLogo.vue';
import IconSettings from '../icons/IconSettings.vue';
import IconFullScreen from '../icons/IconFullScreen.vue';
import { useSidebarStore } from '../../stores/sidebar';
const username = ref("Zelig880");
const sidebarStore = useSidebarStore();
&lt;/script&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.463.1">You may have noticed from the previous code snippets that we did not require any extra initialization or code and that we were able to use the existing store to print the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">friendlyState</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.465.1"> getters.</span></span></p>
			<p><span class="koboSpan" id="kobo.466.1">The header should now display </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">our string:</span></span></p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<span class="koboSpan" id="kobo.468.1"><img src="image/B21130_11_05.jpg" alt="Figure 11.5: Companion App header with the sidebar state"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.469.1">Figure 11.5: Companion App header with the sidebar state</span></p>
			<p><span class="koboSpan" id="kobo.470.1">This was a simple example that helped us learn how to refactor existing code, as well as how to define a store with states, getters, and actions. </span><span class="koboSpan" id="kobo.470.2">Lastly, it helped us learn how to use the store from one or more components within </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">the app.</span></span></p>
			<p><span class="koboSpan" id="kobo.472.1">We are going to continue our journey to learning about Pinia by introducing another store in our Companion App. </span><span class="koboSpan" id="kobo.472.2">In the next section, we are going to create a store that will handle our posts. </span><span class="koboSpan" id="kobo.472.3">This</span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.473.1"> is going to be a little bit more complex than the previous one and will allow us to introduce a few more features offered by the </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">state manager.</span></span></p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.475.1">Creating a post store with Pinia</span></h2>
			<p><span class="koboSpan" id="kobo.476.1">Adding state </span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.477.1">management in an application is a never-ending task, as it continues to evolve as the application grows. </span><span class="koboSpan" id="kobo.477.2">What we have done so far in our application – refactoring the application by moving logic out of the component and into the store – is a common practice. </span><span class="koboSpan" id="kobo.477.3">As we mentioned before, moving the sidebar logic into a store was a bit too much and not expected in a real app, because the logic was small enough to live within the component (even with the </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">prop drilling).</span></span></p>
			<p><span class="koboSpan" id="kobo.479.1">In this section, the situation is different. </span><span class="koboSpan" id="kobo.479.2">We are going to refactor a vital part of the application into the store: the posts. </span><span class="koboSpan" id="kobo.479.3">Handling the data fetching and management of the posts is a vital part of the application and will probably grow in complexity as your application grows. </span><span class="koboSpan" id="kobo.479.4">Because of these points, moving the posts into the store is going to improve the overall </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">application structure.</span></span></p>
			<p><span class="koboSpan" id="kobo.481.1">Just like before, we are going to refactor the current code by first analyzing the code base to find all the code related to the post. </span><span class="koboSpan" id="kobo.481.2">We are then going to create a new store and move the code there. </span><span class="koboSpan" id="kobo.481.3">Finally, we are going to update the component to use </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">the store.</span></span></p>
			<p><span class="koboSpan" id="kobo.483.1">Since this is the second time we are going through this exercise, I am going to jump past some steps and move directly into the creation of the store. </span><span class="koboSpan" id="kobo.483.2">Before you jump to the next section, I suggest you search for all the methods that are related to the post and compare them with the ones that we are going to write in our store. </span><span class="koboSpan" id="kobo.483.3">This exercise is going to be extremely valuable as it will provide you with insight into your current understanding of </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">the application.</span></span></p>
			<p><span class="koboSpan" id="kobo.485.1">Our new store is </span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.486.1">going to be called </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">posts.vue</span></strong><span class="koboSpan" id="kobo.488.1">. </span><span class="koboSpan" id="kobo.488.2">It will be saved in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">src/stores</span></strong><span class="koboSpan" id="kobo.490.1"> folder just like our </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">previous store.</span></span></p>
			<p><span class="koboSpan" id="kobo.492.1">This store is going to include a state with </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">posts</span></strong><span class="koboSpan" id="kobo.494.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">page</span></strong><span class="koboSpan" id="kobo.496.1"> properties, as well as two different actions: </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">fetchPosts</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.498.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">removePosts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.501.1">
import { defineStore } from 'pinia'
export const usePostsStore = defineStore('posts', {
  state: () =&gt; (
    { posts: [], page: 0 }
  ),
  actions: {
    fetchPosts(newPage = false) {
      if(newPage) {
        this.page++;
      }
      const baseUrl = "https://dummyapi.io/data/v1";
      fetch(`${baseUrl}/post?limit=5&amp;page=${this.page}`, {
        "headers": {
          "app-id": "1234567890"
        }
      })
        .then( response =&gt; response.json())
        .then( result =&gt; {
          this.posts.push(...result.data);
        })
    },
    removePost(postIndex) {
      this.posts.splice(postIndex, 1);
    }
  },
})</span></pre>
			<p><span class="koboSpan" id="kobo.502.1">We initialized the</span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.503.1"> store by utilizing the naming convention that we introduced before. </span><span class="koboSpan" id="kobo.503.2">This produced a named export called </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">usePostsStore</span></strong><span class="koboSpan" id="kobo.505.1">. </span><span class="koboSpan" id="kobo.505.2">Then we declared our state with an empty array for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">posts</span></strong><span class="koboSpan" id="kobo.507.1">  variable and a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">0</span></strong><span class="koboSpan" id="kobo.509.1"> for with </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">{ posts: [], page: 0 }</span></strong><span class="koboSpan" id="kobo.511.1">. </span><span class="koboSpan" id="kobo.511.2">Next, we copied our methods and turned them into Pinia’s action. </span><span class="koboSpan" id="kobo.511.3">The main difference between the previous methods that lived within the component and the copy that we have added to our store is the way in which we access variables such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">page</span></strong><span class="koboSpan" id="kobo.513.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">posts</span></strong><span class="koboSpan" id="kobo.515.1">. </span><span class="koboSpan" id="kobo.515.2">In a Pinia store, the state values can be accessed using the </span><strong class="old"><span class="koboSpan" id="kobo.516.1">this</span></strong><span class="koboSpan" id="kobo.517.1"> keyword. </span><span class="koboSpan" id="kobo.517.2">So, if a value was previously accessed using </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">page.value</span></strong><span class="koboSpan" id="kobo.519.1">, we would change this </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">this.page</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.523.1">This is the only change that we are going to make for the methods, as the rest of the logic stays the same and will not require </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">any modification.</span></span></p>
			<p><span class="koboSpan" id="kobo.525.1">Compared to the previous section, we have yet to introduce anything new, and the refactoring of the post store has followed a very similar flow as the sidebar store implementation. </span><span class="koboSpan" id="kobo.525.2">Refactoring logic into a store is usually going to be quite a simple exercise whereby we can lift and shift most of the logic like in our </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">two examples.</span></span></p>
			<p><span class="koboSpan" id="kobo.527.1">Now that the store is set, we will move our focus to the component to ensure it uses the store state and actions. </span><span class="koboSpan" id="kobo.527.2">While doing so, we are going to learn how to destructure a Pinia store to increase the readability of </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">our component.</span></span></p>
			<p><span class="koboSpan" id="kobo.529.1">Destructing a store directly using syntax such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">const { test, test2 } = useTestStore()</span></strong><span class="koboSpan" id="kobo.531.1"> is not possible, as it would break the reactivity of </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">this state.</span></span></p>
			<p><span class="koboSpan" id="kobo.533.1">Breaking the reactivity would mean that if the value changes within the store, the change will not propagate to the component anymore. </span><span class="koboSpan" id="kobo.533.2">To fix this limitation, Pinia exposes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">storeToRefs</span></strong><span class="koboSpan" id="kobo.535.1"> method that will allow us to safely destructure the </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">Pinia store.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.537.1">Store or ref is a personal preference</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.538.1">Using the store directly like we did in our previous example or destructuring values to turn them into Refs is a completely personal preference. </span><span class="koboSpan" id="kobo.538.2">There is no right or </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">wrong choice.</span></span></p>
			<p><span class="koboSpan" id="kobo.540.1">Using the store </span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.541.1">directly will clearly define what data is coming from the store, as it will prefix all data by the store name such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">myStore.firstName</span></strong><span class="koboSpan" id="kobo.543.1">. </span><span class="koboSpan" id="kobo.543.2">On the other hand, using Refs will generate a much cleaner component, as the state will not require the prefix, and accessing a state will just require the ref’s name such </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">firstName</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.547.1">Let’s complete our store migration by changing the component to use the store and doing so using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">storeToRefs</span></strong><span class="koboSpan" id="kobo.549.1"> method. </span><span class="koboSpan" id="kobo.549.2">Due to the file including many changes, we are going to break it down into </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">multiple stages:</span></span></p>
			<ol>
				<li><span class="koboSpan" id="kobo.551.1">Initialize </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">the store:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.553.1">
import { usePostsStore } from '../../stores/posts';</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.554.1">
import { storeToRefs } from 'pinia'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.555.1">
const postsStore = usePostsStore();</span></pre></li>
				<li><span class="koboSpan" id="kobo.556.1">Replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">private</span></strong><span class="koboSpan" id="kobo.558.1"> state with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">store</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.560.1"> state:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.561.1">
const { posts } = storeToRefs(postsStore);</span></pre></li>
				<li><span class="koboSpan" id="kobo.562.1">Replace methods with a </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">store action:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.564.1">
const { fetchPosts, removePost } = postsStore;</span></pre></li>
				<li><span class="koboSpan" id="kobo.565.1">Update </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">the HTML.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.567.1">Due to the fact that we have chosen to turn the store state into Refs, no changes are required within the HTML, as the names of the old Refs and the new Refs now match. </span><span class="koboSpan" id="kobo.567.2">The only change that we need to make is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">watch</span></strong><span class="koboSpan" id="kobo.569.1"> method. </span><span class="koboSpan" id="kobo.569.2">In fact, because we turned the posts array from a reactive to a ref, we now need to append the </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">.value</span></strong><span class="koboSpan" id="kobo.571.1"> for it to </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">function properly:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.573.1">
watch(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.574.1">
  </span><strong class="old"><span class="koboSpan" id="kobo.575.1">posts.value,</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.576.1">
  (newValue) =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.577.1">
    if( newValue.length &lt;= 3 ) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.578.1">
      fetchPosts(true);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.579.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.580.1">
  }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.581.1">
)</span></pre></li>
			</ol>
			<p><span class="koboSpan" id="kobo.582.1">Before we move on, I want</span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.583.1"> to bring your attention to step 3. </span><span class="koboSpan" id="kobo.583.2">In fact, if you were careful, you may have noticed that we extracted the actions of the store directly without using </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">storeToRefs</span></strong><span class="koboSpan" id="kobo.585.1">. </span><span class="koboSpan" id="kobo.585.2">This is possible because actions are stateless and do not have </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">any reactivity.</span></span></p>
			<p><span class="koboSpan" id="kobo.587.1">The complete file will look </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">like this:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.589.1">
&lt;template&gt;
  &lt;SocialPost
    v-for="(post, index) in posts"
    :username="post.owner.firstName"
    :id="post.id"
    :avatarSrc="post.image"
    :post="post.text"
    :likes="post.likes"
    :key="post.id"
    @delete="removePost(index)"
  &gt;&lt;/SocialPost&gt;
&lt;/template&gt;
&lt;script setup&gt;
import { watch } from 'vue';
import SocialPost from '../molecules/SocialPost.vue'
</span><strong class="old"><span class="koboSpan" id="kobo.590.1">import { usePostsStore } from '../../stores/posts';</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.591.1">import { storeToRefs } from 'pinia'</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.592.1">const postsStore = usePostsStore();</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.593.1">const { posts } = storeToRefs(postsStore);</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.594.1">const { fetchPosts, removePost } = postsStore;</span></strong><span class="koboSpan" id="kobo.595.1">
watch(
 </span><strong class="old"><span class="koboSpan" id="kobo.596.1"> posts.value,</span></strong><span class="koboSpan" id="kobo.597.1">
  (newValue) =&gt; {
    if( newValue.length &lt;= 3 ) {
      fetchPosts(true);
    }
  }
)
fetchPosts();
&lt;/script&gt;</span></pre>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.598.1">Implementing an Add Post action</span></h2>
			<p><span class="koboSpan" id="kobo.599.1">A few chapters ago, we</span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.600.1"> introduced a component aimed at adding new posts to our state. </span><span class="koboSpan" id="kobo.600.2">This component was never fully implemented, as it is missing the main logic required to create a post. </span><span class="koboSpan" id="kobo.600.3">The reason why the component was left in this state was that adding the functionality without a store in place would have required a lot of prop drilling and </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">event bubbling.</span></span></p>
			<p><span class="koboSpan" id="kobo.602.1">Thanks to the post store, this is not the case anymore. </span><span class="koboSpan" id="kobo.602.2">In fact, we are going to be able to generate the logic required to add a new post using </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">store actions.</span></span></p>
			<p><span class="koboSpan" id="kobo.604.1">The store is the sole owner of the posts, so we do not have to worry about where the posts are used. </span><span class="koboSpan" id="kobo.604.2">We can simply create an action that adds a post knowing that the store will handle the propagation and handling of the state within the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">the application.</span></span></p>
			<p><span class="koboSpan" id="kobo.606.1">First, we are going to add an action in our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">posts.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.608.1"> file:</span></span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.609.1">src/stores/post.js</span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.610.1">
addPost(postText) {
  const post = generatePostStructure(postText);
  this.posts.unshift(post);
}</span></pre>
			<p><span class="koboSpan" id="kobo.611.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">addPost  </span></strong><span class="koboSpan" id="kobo.613.1">action is going to add a post by adding it at the start of the posts list. </span><span class="koboSpan" id="kobo.613.2">For the scope of our Companion App, adding a new post will just set the main body of the post, because other information such as ID and user information are going to be hardcoded and provided by a function </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">generatePostStructure</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">..</span></span></p>
			<p><span class="koboSpan" id="kobo.617.1">Next, we are going to initialize the store and attach this action to </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">createPostHandler</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.621.1">
&lt;script setup&gt;
import TheButton from '../atoms/TheButton.vue';
</span><strong class="old"><span class="koboSpan" id="kobo.622.1">import { usePostsStore } from '../../stores/posts';</span></strong><span class="koboSpan" id="kobo.623.1">
import { onMounted, ref } from 'vue';
</span><strong class="old"><span class="koboSpan" id="kobo.624.1">const postsStore = usePostsStore();</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.625.1">const { addPost } = postsStore;</span></strong><span class="koboSpan" id="kobo.626.1">
const textareaRef = ref(null);
const createPostForm = ref(null);
const createPostHandler = (event) =&gt; {
  event.preventDefault();
  if(createPostForm.value.reportValidity()){
    </span><strong class="old"><span class="koboSpan" id="kobo.627.1">addPost(textareaRef.value.value);</span></strong><span class="koboSpan" id="kobo.628.1">
  };
}
...</span></pre>
			<p><span class="koboSpan" id="kobo.629.1">Using the new action follows the same syntax used before. </span><span class="koboSpan" id="kobo.629.2">First, we import the store. </span><span class="koboSpan" id="kobo.629.3">Second, we initialize it. </span><span class="koboSpan" id="kobo.629.4">Third, we destructure the actions that we want to use, and lastly, we use the action as if it were a </span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">simple method.</span></span></p>
			<p><span class="koboSpan" id="kobo.631.1">The preceding</span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.632.1"> example uses the text area ref to get the </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">textarea</span></strong><span class="koboSpan" id="kobo.634.1"> value. </span><span class="koboSpan" id="kobo.634.2">This is not the correct use of Vue.js and accessing values like this should be avoided. </span><span class="koboSpan" id="kobo.634.3">In fact, in the next chapter, we are going to refactor this file by introducing two-way binding </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">v-model</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.638.1">Create your own store</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.639.1">Before moving on to the next chapter, you should try and create your own store. </span><span class="koboSpan" id="kobo.639.2">You can create a very similar store to the sidebar by creating a store that can handle the visibility of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">create post</span></strong><span class="koboSpan" id="kobo.641.1"> component. </span><span class="koboSpan" id="kobo.641.2">You can use the button within the sidebar labeled </span><strong class="old"><span class="koboSpan" id="kobo.642.1">Create Post</span></strong><span class="koboSpan" id="kobo.643.1"> to toggle the </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">CreatePost.vue</span></strong><span class="koboSpan" id="kobo.645.1"> visibility. </span><span class="koboSpan" id="kobo.645.2">You can see the full implementation in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">CH11-END</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.647.1"> branch.</span></span></p>
			<p><span class="koboSpan" id="kobo.648.1">In this section, we continued learning about the Pinia store by refactoring the post data. </span><span class="koboSpan" id="kobo.648.2">We created a new store by defining its state and actions. </span><span class="koboSpan" id="kobo.648.3">We then converted the existing code to work within the Pinia store. </span><span class="koboSpan" id="kobo.648.4">Next, we introduced the </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">storeToRefs</span></strong><span class="koboSpan" id="kobo.650.1"> method and learned how to destructure state and actions from a store. </span><span class="koboSpan" id="kobo.650.2">Finally, we made use of the new store by adding the ability for users to add a new post by simply creating a new action. </span><span class="koboSpan" id="kobo.650.3">What you learned here is not a complete list of features offered by Pinia, but a quick </span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.651.1">introduction to a great state management package. </span><span class="koboSpan" id="kobo.651.2">As you practice more, you will then learn about other features such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">$patch</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.653.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">$reset</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">.</span></span></p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.656.1">Summary</span></h1>
			<p><span class="koboSpan" id="kobo.657.1">Introducing state management into your application can really help you handle your data with ease. </span><span class="koboSpan" id="kobo.657.2">In the two examples that we shared in this chapter, we saw the benefit that state management can add to your application by avoiding prop drilling and </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">event bubbling.</span></span></p>
			<p><span class="koboSpan" id="kobo.659.1">Before we conclude this chapter, I want to share one more benefit of using state management in your application. </span><span class="koboSpan" id="kobo.659.2">The refactor that we have accomplished in the previous two sections highlights the fact that using the Pinia store helped us remove lots of logic from the components to a single location within the </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">store file.</span></span></p>
			<p><span class="koboSpan" id="kobo.661.1">This abstraction is not only good for a development experience but can also be used to choose which parts of our application can be unit tested. </span><span class="koboSpan" id="kobo.661.2">You may remember from </span><a href="B21130_08.xhtml#_idTextAnchor103"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.662.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.663.1"> that choosing what to test is quite complicated, as there is a very fine line between testing too much and testing too little. </span><span class="koboSpan" id="kobo.663.2">I personally use state management to delineate which parts of the application I will unit test. </span><span class="koboSpan" id="kobo.663.3">I achieve this by always making sure all stores are </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">thoroughly tested.</span></span></p>
			<p><span class="koboSpan" id="kobo.665.1">In this chapter, we first introduced the notion of state management and talked through the syntax and features that Pinia has to offer. </span><span class="koboSpan" id="kobo.665.2">We then started to put what we learned into practice by refactoring the sidebar into its own store. </span><span class="koboSpan" id="kobo.665.3">By doing so, we learned how to declare state, getters, and actions and how to use them within our components. </span><span class="koboSpan" id="kobo.665.4">Next, we continued our learning by refactoring one more piece of our application: the posts. </span><span class="koboSpan" id="kobo.665.5">We created a store and converted the methods into Pinia actions. </span><span class="koboSpan" id="kobo.665.6">Finally, we learned how to destructure state and the importance that state management can have in our </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">application architecture.</span></span></p>
			<p><span class="koboSpan" id="kobo.667.1">In the next chapter, we are going to learn how to handle forms in our application by introducing two-way binding with </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">v-model</span></strong><span class="koboSpan" id="kobo.669.1"> and client-side validation </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">with </span></span><span class="No-Break"><strong class="old"><span class="koboSpan" id="kobo.671.1">VeeValidate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">.</span></span></p>
		</div>
	</body></html>