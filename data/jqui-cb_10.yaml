- en: Chapter 10. Using Tabs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。使用标签
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Working with remote tab content
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理远程标签内容
- en: Giving tabs an icon
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为标签添加图标
- en: Simplifying the tab theme
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化标签主题
- en: Using tabs as URL navigation links
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将标签用作 URL 导航链接
- en: Creating effects between tab transitions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在标签转换之间创建效果
- en: Sorting tabs using the sortable interaction
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可排序交互来排序标签
- en: Setting the active tab using href
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 href 设置活动标签
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The **tabs** widget is a container used to organize the content on your page.
    It is an excellent way to consolidate your page content so only the relevant items
    are displayed. The user has an easy navigation mechanism to activate content.
    The tabs widget can be applied in a larger navigational context, where the tabs
    widget is the main top-level container element for the page. It can also serve
    well as a smaller component for a specific page element, used to simply split
    two sections of content.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**标签** 小部件是用于组织页面内容的容器。它是整理页面内容的绝佳方式，因此只显示相关项目。用户具有简单的导航机制来激活内容。标签小部件可以应用于较大的导航上下文中，其中标签小部件是页面的主要顶级容器元素。它还可以作为特定页面元素的较小组件使用，用于简单地拆分两个内容部分。'
- en: The tabs widget in the latest jQuery UI version offers the developer a cohesive
    set of options to tweak the behavior of the widget. We'll look at how we can combine
    these options, as well as how to get the most out of the navigational pieces of
    the tabs widget. We'll also explore applying effects to tab transitions, and making
    tabs sortable for the user.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最新的 jQuery UI 版本中的标签小部件为开发人员提供了一套一致的选项，以调整小部件的行为。我们将看看如何组合这些选项，以及如何充分利用标签小部件的导航功能。我们还将探讨如何对标签转换应用效果，并使标签对用户可排序。
- en: Working with remote tab content
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理远程标签内容
- en: The tabs widget knows how to populate a given tab panel with remote content
    out of the box. It's all about how we specify the tab links. For example, an `href`
    attribute that points to `#tab-content-home` will load the content using the HTML
    found in that element. But, if instead of pointing to an already-existing element
    we point to another page, the tabs widget will load the content into the appropriate
    panel on demand.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 标签小部件知道如何将给定的标签面板填充为远程内容。关键在于我们如何指定标签链接。例如，指向 `#tab-content-home` 的 `href` 属性将使用该元素中找到的
    HTML 加载内容。但是，如果我们指向另一个页面而不是指向已存在的元素，则标签小部件将按需将内容加载到适当的面板中。
- en: This works as expected without passing options to the tabs, but there is the
    `beforeLoad` option should we want to tweak the behavior of the Ajax request in
    an any way. Let's take a look at some of the ways we can work with remote content
    using the tabs widget.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在不传递选项给标签的情况下，这样可以按预期运行，但是如果我们想要以任何方式调整 Ajax 请求的行为，可以使用 `beforeLoad` 选项。让我们来看看我们可以如何使用标签小部件处理远程内容的一些方法。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: First, we'll create the HTML for our tabs widget, which consists of four links.
    The first three point to existing resources while the fourth doesn't exist, and
    so the Ajax request will fail.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建标签小部件的 HTML，其中包括四个链接。前三个链接指向现有资源，而第四个链接不存在，因此 Ajax 请求将失败。
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, we have the JavaScript used to create the tabs widget instance as well
    as specify some custom behavior to alter the Ajax request.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有用于创建标签小部件实例的 JavaScript，以及指定一些自定义行为以修改 Ajax 请求。
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In order to view the Ajax behavior implemented in this demonstration, you''ll
    want to put a web server in front of it. The easiest way to do that is to install
    Python and run `python -m SimpleHTTPServer` from the directory with the main HTML
    file, as well as the Ajax content files, `tab1.html`, `tab2.html`, and `tab3.html`.
    Here is an example of what the tab1.html file looks like:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看此演示中实现的 Ajax 行为，您需要将 web 服务器放在前面。最简单的方法是安装 Python 并从包含主 HTML 文件的目录以及 Ajax
    内容文件 `tab1.html`、`tab2.html` 和 `tab3.html` 运行 `python -m SimpleHTTPServer`。以下是
    `tab1.html` 文件的示例：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When you load this tabs widget in your browser, the first tab is selected by
    default. So the widget will perform the Ajax request that loads the first tab''s
    content right away. You should see something like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在浏览器中加载此标签小部件时，默认情况下选择第一个标签。因此，小部件将立即执行加载第一个标签内容的 Ajax 请求。您应该看到类似于以下内容：
- en: '![How to do it...](img/2186_10_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/2186_10_01.jpg)'
- en: Switching to the second and third tabs will execute the Ajax request necessary
    to fetch the content. On the other hand, the fourth tab will result in an error
    as the linked resource doesn't exist. Instead of content being displayed in that
    panel, our custom behavior that we've added to the Ajax request displays an error
    message.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到第二个和第三个选项卡将执行必要的 Ajax 请求以获取内容。另一方面，第四个选项卡将导致错误，因为链接的资源不存在。在该面板中不会显示内容，而是显示了我们为
    Ajax 请求添加的自定义行为显示的错误消息。
- en: '![How to do it...](img/2186_10_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现...](img/2186_10_02.jpg)'
- en: The last thing to note about this example is our other modification to the Ajax
    request. If you were to revisit the first tab, we're not sending another Ajax
    request as we already have the panel content.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个示例的最后一点要注意的是我们对 Ajax 请求的另一个修改。如果你重新访问第一个选项卡，我们不会发送另一个 Ajax 请求，因为我们已经有了面板内容。
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We're creating a tabs widget from the `#tabs` div when the document has finished
    loading. We're passing `beforeLoad` a callback function, `tabLoad()`, defined
    earlier. The `tabLoad` function gets called just before the Ajax request to fetch
    the tab panel content that is dispatched. This gives us an opportunity to update
    the state of the `jqXHR` object.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当文档加载完成时，我们将从 `#tabs` div 创建一个选项卡部件。我们传递 `beforeLoad` 一个回调函数 `tabLoad()`，之前定义的。`tabLoad`
    函数在分派用于获取选项卡面板内容的 Ajax 请求之前被调用。这给了我们一个机会来更新 `jqXHR` 对象的状态。
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `jqXHR` object returned by `$.ajax()` is an extension of the native `XMLHTTPRequest`
    type found in JavaScript. Developers seldom interact with this object but occasionally,
    the need does arise as we've seen here.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`$.ajax()` 返回的 `jqXHR` 对象是 JavaScript 中原生 `XMLHTTPRequest` 类型的扩展。开发者很少与这个对象交互，但偶尔也会有需要，正如我们在这里看到的。'
- en: The first thing we're checking for in this example is whether or not the tab
    panel has any content in it. The `ui.panel` object represents the `div` element
    where the dynamic Ajax content will eventually land. If it is an empty string,
    we continue loading the content. If, on the other hand, there is content already,
    we abort the request. This is useful if the server isn't generating dynamic content
    and we're merely using this feature of the tabs widget as a means of structural
    composition. There is no point in requesting the same content over and over when
    we already have it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们首先检查选项卡面板是否有任何内容。`ui.panel` 对象代表最终将动态 Ajax 内容放置的 `div` 元素。如果是空字符串，我们继续加载内容。另一方面，如果已经有内容，我们会中止请求。如果服务器没有生成动态内容，而我们只是使用选项卡部件的此功能作为结构组合的手段，那么这是有用的。当我们已经拥有内容时，重复请求相同的内容是没有意义的。
- en: We're also attaching behavior to the `jqXHR` object that's executed if the Ajax
    request fails. We update the tab content with the status text returned by the
    server after formatting it using the `ui-state-error` and `ui-corner-all` classes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将行为附加到 `jqXHR` 对象上，以处理 Ajax 请求失败的情况。我们使用 `ui-state-error` 和 `ui-corner-all`
    类对服务器返回的状态文本进行格式化，然后更新选项卡内容。
- en: There's more...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The preceding example took the HTML retrieved from the remote resource and
    placed it into the tab panel. But now we''ve decided that the `h1` tags in the
    tab content are redundant, as the active tab serves the same purpose. We can take
    the tags directly out of the remote resource that we''re using to build the tab
    content, but that could pose a problem if we''re using that resource somewhere
    else in the application. Instead, we can just alter the tab content before the
    user actually sees it using the load event. Here is a modified version of our
    tabs widget instance:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子将从远程资源检索的 HTML 放置到选项卡面板中。但现在我们决定选项卡内容中的 `h1` 标签是多余的，因为活动选项卡具有相同的作用。我们可以直接从我们用于构建选项卡内容的远程资源中删除这些标签，但如果我们在应用程序的其他地方使用该资源，可能会出现问题。相反，我们可以在用户实际看到它之前，仅仅通过加载事件修改选项卡内容。这是我们选项卡部件实例的修改版本：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Looking at it now, you'll see that there is no longer a header inside the tab
    panel. Our `load` callback passed to the tabs in the constructor will find and
    remove any `h1` tags. The `load` event is triggered after the Ajax call has returned
    and the content inserted into the panel. We don't need to worry about the `h1`
    tags appearing after our code has run.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看，你会发现选项卡面板内不再有标题了。我们在构造函数中传递给选项卡的 `load` 回调将查找并删除任何 `h1` 标签。`load` 事件在 Ajax
    调用返回并将内容插入面板后触发。我们无需担心在我们的代码运行之后出现 `h1` 标签。
- en: '![There''s more...](img/2186_10_03.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/2186_10_03.jpg)'
- en: Giving tabs an icon
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给选项卡添加图标
- en: The tabs widget uses anchor elements, which when clicked, activate the various
    tab panels to reveal their content. This anchor element only displays text by
    default, which is good enough under the vast majority of circumstances. There
    are other times, however, where the tab link itself would benefit from an icon.
    For example, a house icon helps quickly cue what is in the panel content before
    actually activating it. Let's look at how we can extend the tab's capabilities
    to support using both an icon and text as the tab button.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 选项卡小部件使用锚元素，点击时激活各种选项卡面板以显示其内容。默认情况下，此锚元素仅显示文本，这在绝大多数情况下足够好。然而，在其他一些情况下，选项卡链接本身可能受益于图标。例如，一个房子图标有助于快速提示面板内容是什么，然后再激活它。让我们看看如何扩展选项卡的功能以支持将图标和文本作为选项卡按钮使用。
- en: How to do it...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll create a basic `tabs` div to support our widget that looks like the
    following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个支持我们小部件的基本`tabs` div，如下所示：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next, we have our JavaScript, including an extension to the tabs widget that
    understands how to utilize the `new data-icon` attributes we've included in the
    markup.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有我们的 JavaScript 代码，包括对了解如何利用我们在标记中包含的`new data-icon`属性的选项卡小部件的扩展。
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you were to look at this tabs widget in the browser, you'll notice that each
    tab button now has an icon to the left of the button text.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中查看此选项卡小部件，您会注意到每个选项卡按钮现在在按钮文本的左侧有一个图标。
- en: '![How to do it...](img/2186_10_04.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/2186_10_04.jpg)'
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运作原理...
- en: What's interesting about this customization to the tabs widget is that we're
    passing the data through the `li` elements that represent the tab buttons. As
    any given tabs widget instance could have any number of tabs, it'd be hard to
    specify which tab gets which icon through the `options` object. Instead, we're
    simply transferring these options through the use of a data attribute, `data-icon`.
    The value is the icon class we'd like to use from the theme framework.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项卡小部件的自定义之处在于，我们通过代表选项卡按钮的`li`元素传递数据。由于任何给定的选项卡小部件实例可能有任意数量的选项卡，通过`options`对象来指定哪个选项卡获取哪个图标是困难的。相反，我们简单地通过使用`data-icon`数据属性传递这些选项。该值是我们想要从主题框架中使用的图标类。
- en: The changes we've implemented could actually have been done manually in the
    markup itself, as we're just adding new elements and new classes to the widget.
    But, there are two problems with this way of thinking. First, there is a lot of
    manually injected markup that could be generated based on the value of one data
    attribute—it violates the DRY principle, especially if you're following this pattern
    for several tabs widgets. Second, we would be introducing new markup that the
    default widget implementation doesn't know about. It may work out fine, but when
    things stop working as expected, this can be very difficult to diagnose. And so,
    we're better off extending the tabs widget.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的更改实际上可以在标记本身手动完成，因为我们只是向小部件添加新元素和新类。但是，这种思维方式存在两个问题。首先，有大量手动注入的标记，可以根据一个数据属性的值生成，这违反了
    DRY 原则，特别是如果您为多个选项卡小部件遵循这种模式。其次，我们将引入默认小部件实现不了解的新标记。这可能效果很好，但当事情停止按预期工作时，这可能很难诊断。因此，我们最好扩展选项卡小部件。
- en: The `_processTabs()` method we're overriding will iterate over each `li` element
    that has the `data-icon` attribute, as these are the ones we need to manipulate.
    The `data-icon` attribute stores the class of icons to use from the theme framework.
    We construct a `span` element that uses the `ui-icon` class in conjunction with
    the specific icon class. It also gets our new `ui-tabs-icon` class that properly
    positions the element inside the link. We're then grabbing the original text of
    the tab button and wrapping it in a `div`. The reason being, it's easier to insert
    the icon `span`, followed by the text `span`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在重写的`_processTabs()`方法将迭代具有`data-icon`属性的每个`li`元素，因为这些是我们需要操作的元素。`data-icon`属性存储要从主题框架中使用的图标类。我们构造一个使用`ui-icon`类与特定图标类一起使用的`span`元素。它还得到我们新的`ui-tabs-icon`类，正确定位元素在链接内。然后，我们获取选项卡按钮的原始文本并将其包装在一个`div`中。原因是，插入图标`span`，然后是文本`span`更容易。
- en: Simplifying the tab theme
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化选项卡主题
- en: Sometimes, the context of our tabs widget has important theme implications.
    The default visual components of the tabs widget work best when the widget is
    near the top of the document, that is, the majority of the page content is nested
    within the tab panels. In contrast, there may be preexisting page elements that
    could benefit from being organized by a tabs widget. And therein lies the challenge—stuffing
    a top-level widget such as tabs into a smaller block can look awkward at best,
    unless we can figure out a way to strip down some unnecessary theme components
    from the tabs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们的选项卡小部件的上下文对主题有重要的影响。当小部件位于文档顶部附近时，选项卡小部件的默认视觉组件效果最佳，也就是说，大部分页面内容都嵌套在选项卡面板中。相反，可能存在着一些既有的页面元素，可以通过选项卡小部件进行组织。这就是挑战所在——将诸如选项卡这样的顶级小部件塞入较小的块中可能会显得尴尬，除非我们能够找到一种方法来从选项卡中剥离一些不必要的主题组件。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s first create ourselves some markup to base the tabs widget on. It should
    look something like the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一些标记以便基于选项卡小部件。它应该看起来像下面这样：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next, we'll define some CSS used by the tabs widget and the tabs widget container.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一些由选项卡小部件和选项卡小部件容器使用的 CSS。
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next comes our JavaScript code that creates the tabs widget once the document
    is ready.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们的 JavaScript 代码，它在文档准备就绪后创建选项卡小部件。
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `create` function we're passing to the tabs constructor gets triggered after
    the widget is created. This is where we're adding our custom class, `ui-tabs-basic`,
    which is used to override the `background` and `border` settings. These are the
    components we would like to be removed, and so we just set them to `none`. We're
    also removing the `ui-corner-all` class from the tabs navigation section because
    we're keeping the bottom border, and leaving this class doesn't look right.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在传递给选项卡构造函数的`create`函数在小部件创建后触发。这是我们添加自定义类`ui-tabs-basic`的地方，该类用于覆盖`background`和`border`设置。这些是我们希望被移除的组件，因此我们只需将它们设置为`none`。我们还从选项卡导航部分中移除了`ui-corner-all`类，因为我们保留了底部边框，保留此类看起来不合适。
- en: 'Creating this widget normally, that is, without passing our `create` function,
    the tabs widget would look something like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下创建此小部件，也就是不传递我们的`create`函数，则选项卡小部件将如下所示：
- en: '![How it works...](img/2186_10_05.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![它的工作原理...](img/2186_10_05.jpg)'
- en: As you can see, it looks like the tabs widget was stuffed into the `#tabs-container`
    element without much thought. After our simplifications were introduced, the tabs
    take on a more natural look inside their new context.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，选项卡小部件似乎是毫无考虑地塞入了`#tabs-container`元素中。在引入我们的简化之后，选项卡在其新上下文中呈现出更自然的外观。
- en: '![How it works...](img/2186_10_06.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![它的工作原理...](img/2186_10_06.jpg)'
- en: There's more...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you''re using this slimmed-down version of the tabs widget in several places
    throughout your UI, it can be cumbersome to define a function callback several
    times to pass to the tabs constructor. You could define the callback function
    once and pass a reference to it in the constructor, but then you still have the
    callback function out in the open. From a design perspective, we might want to
    encapsulate this behavior in the tabs widget and expose it to the outside world
    through a widget option. Here is a modification of the example that does just
    that:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在整个 UI 中的多个位置使用此精简版本的选项卡小部件，则多次定义要传递给选项卡构造函数的函数回调可能会很麻烦。您可以一次定义回调函数并在构造函数中传递其引用，但是然后您仍然需要将回调函数暴露在外。从设计的角度来看，我们可能希望将此行为封装在选项卡小部件中，并通过小部件选项将其暴露给外部世界。以下是对此示例进行的修改：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we've moved the functionality previously in our callback into the tabs
    constructor, but it's only ever executed if the `basic` option is set to `true`,
    and it defaults to `false`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将之前在回调中的功能移至选项卡构造函数中，但仅当`basic`选项设置为`true`时才执行，并且默认为`false`。
- en: Using tabs as URL navigation links
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将选项卡用作 URL 导航链接
- en: The tabs widget isn't limited to populating tab panels using preloaded div elements
    or by making Ajax calls. Some applications already have many components built,
    and lots of content to display. If you're updating a site, or application such
    as this, the tabs widget might be useful as the main form of navigation, especially
    if you're already using jQuery UI widgets. What we would need then is something
    generic that could be applied to every page, without much effort on the part of
    the developer using the widget. Although the tabs widget wasn't designed for such
    a purpose, we're not going to let that stop us because with a little tweaking,
    we can create a generic component that gives us exactly what we need.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 选项卡小部件不仅限于使用预加载的div元素或通过进行Ajax调用来填充选项卡面板。一些应用程序已经构建了许多组件，并且有大量内容要显示。如果您正在更新一个网站或应用程序，特别是如果您已经在使用jQuery
    UI小部件，则选项卡小部件可能作为主要的导航形式是有用的。那么我们需要的是一些通用的东西，可以应用于每个页面，而开发人员使用小部件的努力不多。尽管选项卡小部件并不是为这样的目的而设计的，但我们不会让这阻止我们，因为稍加调整，我们就可以创建一个能够给我们带来所需功能的通用组件。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The first thing we'll look at is the content on one of the pages in our application.
    The HTML defines both the tabs widget structure and the content displayed under
    the active tab.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看应用程序中一个页面上的内容。HTML定义了选项卡小部件结构以及活动选项卡下显示的内容。
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You'll notice that there are three pages in this application, and they each
    use the same widget HTML structure; the only difference is the tab content paragraph.
    Next, we'll define our new navigation widget and create it on the page. This same
    JavaScript code is included on each page of the application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到此应用程序中有三个页面，并且它们都使用相同的小部件HTML结构；唯一的区别是选项卡内容段落。接下来，我们将定义我们的新导航小部件并在页面上创建它。相同的JavaScript代码包含在应用程序的每个页面中。
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, when you interact with this navigation widget, you'll see that each time
    you activate a new tab, the browser will reload the page to point at the tab's
    `href`; for example, `tab3.html`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您与此导航小部件交互时，您会看到每次激活一个新的选项卡时，浏览器都会重新加载页面以指向选项卡的`href`；例如，`tab3.html`。
- en: '![How to do it...](img/2186_10_07.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/2186_10_07.jpg)'
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's first look at the HTML structure before we discuss the new `nav` widget
    we've created. The first thing to note is that the HTML structure we've provided
    here is different from what the tabs widget is expecting. We have a `div` element
    that holds the main content of the page and it has no ID, and thus no way for
    any tab link to reference it. Not to worry though, this is intentional. The `nav`
    widget is designed for sites or applications that have multiple pages—we're not
    embedding multiple tab pane content in this widget. With this structural change
    to the HTML the widget uses, it's best that we create an entirely new widget rather
    than just extend the tabs widget. This approach will avoid confusion as to what
    the HTML structure of a tabs widget should look like.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看我们创建的新`nav`小部件之前的HTML结构。首先要注意的是，我们在这里提供的HTML结构与选项卡小部件所期望的不同。我们有一个不带ID的`div`元素，用于保存页面的主要内容，因此没有任何选项卡链接可以引用它。但不用担心，这是有意为之的。`nav`小部件是为具有多个页面的站点或应用程序设计的——我们不会在此小部件中嵌入多个选项卡面板内容。由于我们对小部件使用的HTML进行了这种结构性变更，最好的做法是创建一个全新的小部件，而不仅仅是扩展选项卡小部件。这种方法将避免对选项卡小部件的HTML结构应该是什么样子产生混淆。
- en: The goal of our `nav` widget, based on the tabs widget, is to activate the appropriate
    tab and render the `div` element as the selected tab panel. When a tab link is
    clicked, we don't perform any of the usual tab activities, we simply follow `href`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`nav`小部件的目标，基于选项卡小部件，是激活适当的选项卡并将`div`元素呈现为所选的选项卡面板。当单击选项卡链接时，我们不执行任何常规的选项卡活动，只是跟随`href`。
- en: All the methods we're overriding in the definition of the `nav` widget come
    from the tabs widget, and for the most part, we're replacing the tabs functionality
    we don't need. The first method is `_initialActive()`, which determines the active
    tab when the widget is first created. Here, we're basing this decision on the
    path in the location object. We compare it to the tab's `href` attributes. Next
    is the `_eventHandler()` method. This method gets called when the user activates
    a tab. Here, we're just performing the same action as a default browser link and
    following the `href` attribute of the tab link. As we're doing this in the `_eventHandler()`
    method, the `keypress` events used to switch tabs will still work as expected.
    Next, the `_createPanel()` method is called when the tabs widget needs to create
    and insert a tab panel. The reason the tabs widget calls this method is that it
    needs a panel when making Ajax calls. As we're not making any Ajax calls in our
    `nav` widget, this method will now use the default `div` that has the content
    of the page. The only changes we're making to the content `div` is adding the
    appropriate tab panel CSS classes. Finally, we have the `_getPanelForTab()` method
    that returns our content `div`, the only one that matters for this widget, and
    the `load()` method is `$.noop`. This prevents the widget from trying to load
    Ajax content when the widget is first created.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `nav` 小部件的定义中覆盖的所有方法都来自标签小部件，而且在大多数情况下，我们都替换了不需要的标签功能。第一个方法是 `_initialActive()`，它确定小部件首次创建时的活动选项卡。在这里，我们将此决定基于位置对象中的路径。我们将其与选项卡的
    `href` 属性进行比较。接下来是 `_eventHandler()` 方法。当用户激活选项卡时，将调用此方法。在这里，我们只执行与默认浏览器链接相同的操作，并遵循选项卡链接的
    `href` 属性。由于我们在 `_eventHandler()` 方法中执行此操作，因此用于切换选项卡的 `keypress` 事件仍将按预期工作。接下来，当标签小部件需要创建和插入选项卡面板时，将调用
    `_createPanel()` 方法。标签小部件调用此方法的原因是在进行 Ajax 调用时需要面板。由于我们在 `nav` 小部件中不进行任何 Ajax
    调用，因此此方法现在将使用具有页面内容的默认 `div`。我们对内容 `div` 做的唯一更改是添加了适当的选项卡面板 CSS 类。最后，我们有 `_getPanelForTab()`
    方法，该方法返回我们的内容 `div`，对于此小部件，这是唯一重要的内容 `div`，并且 `load()` 方法是 `$.noop`。这样做可以防止小部件在首次创建时尝试加载
    Ajax 内容。
- en: Creating effects between tab transitions
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在选项卡之间创建效果
- en: The tabs widget lets the developer specify an effect to run when transitioning
    between tabs. Specifically, we're able to tell the tabs widget to run a specific
    effect when showing a tab, and another effect when hiding a tab. When the user
    clicks on a tab, both of these effects, if specified, are run. First the hide
    effect, followed by the show effect. Let's take a look at how we can combine these
    two tabs options to enhance the interactivity of the widget.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 标签小部件允许开发人员指定在选项卡之间进行转换时运行的效果。具体来说，我们能够告诉标签小部件在显示选项卡时运行特定效果，并在隐藏选项卡时运行另一个效果。当用户点击选项卡时，如果指定了这两个效果，则会运行它们。首先是隐藏效果，然后是显示效果。让我们看看如何结合这两个选项卡选项来增强小部件的互动性。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, we''ll create the necessary HTML structure we need to build our tabs
    widget. It should look something along the lines of what follows, producing three
    tabs:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建我们构建选项卡小部件所需的 HTML 结构。它应该看起来类似于以下内容，生成三个选项卡：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, the following JavaScript code instantiates the tabs widget, with the `show`
    and `hide` effect options passed to the widget constructor.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 JavaScript 代码实例化了标签小部件，其中 `show` 和 `hide` 效果选项传递给小部件构造函数。
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you view this tabs widget in your browser and click through the tabs, you'll
    notice how the content of the current tab slides to the right, while fading out
    at the same time. Once this effect has finished execution, the `show` effect of
    the now-active tab runs, and in this case, slides the content in from the left.
    The two effects complement each other—when combined, they create an illusion of
    the new content pushing the old out of the panel.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在浏览器中查看此选项卡小部件并点击选项卡时，您会注意到当前选项卡的内容向右滑动，同时淡出。一旦此效果执行完毕，当前活动选项卡的 `show` 效果就会运行，在这种情况下，内容从左侧滑入。这两种效果相辅相成——结合在一起，它们产生了新内容将旧内容推出面板的幻觉。
- en: The two effects we've chosen here are actually very similar. The `drop` effect
    is really just the `slide` effect with the addition of fading while sliding. The
    key to their collaboration is the `direction` property we've passed to each `effect`
    object. We've told the `hide` effect to move to the right when it runs. Likewise,
    we've told the `show` effect to enter from the left.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里选择的两种效果实际上非常相似。`drop`效果实际上只是`slide`效果，额外加上了在滑动时的淡入淡出。它们协作的关键是我们传递给每个`effect`对象的`direction`属性。我们告诉`hide`效果在运行时向右移动。同样，我们告诉`show`效果从左侧进入。
- en: Sorting tabs using the sortable interaction
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可排序交互进行标签排序
- en: When we implement tabs in a user interface, we might briefly consider the default
    ordering of the tabs. Obviously, we want the most relevant tabs accessible to
    the user in an order that makes most sense to them. But we seldom get this right
    in a way that makes everyone happy. So why not let the user arrange the tabs in
    a way that they see fit? Let's see if we can recruit the sortable interaction
    widget for some help by providing this capability in the tabs widget.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在用户界面中实现标签时，我们可能会简短地考虑标签的默认排序。显然，我们希望最相关的标签按照用户最能理解的顺序进行访问。但通常我们无法以让所有人满意的方式做到这一点。那么为什么不让用户自行安排标签的顺序呢？让我们看看能否通过在标签小部件中提供这种功能来利用可排序交互小部件来提供帮助。
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We''ll use the following as the sample HTML driving our tabs instance:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下HTML作为驱动我们标签实例的示例：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, we'll implement the new `sortable` option in the tabs widget. We'll also
    need to extend the widget's behavior to take advantage of this new option.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在标签小部件中实现新的`sortable`选项。我们还需要扩展小部件的行为以利用这个新选项。
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now when you drag the tab buttons along the x axis, dropping them will rearrange
    their order. For example, dragging the first tab would look something like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当您沿着x轴拖动标签按钮时，放下它们将重新排列它们的顺序。例如，拖动第一个标签会看起来像这样：
- en: '![How to do it...](img/2186_10_08.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现...](img/2186_10_08.jpg)'
- en: 'If we dropped the first tab at the end and activated **Tab 2**, now the first
    tab, you should see something like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将第一个标签放在末尾并激活 **Tab 2**，现在第一个标签，你应该看到类似这样的东西：
- en: '![How to do it...](img/2186_10_09.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现...](img/2186_10_09.jpg)'
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We've added a new option to the tabs widget, `sortable`, which when true will
    use the sortable interaction widget to enable the sortable behavior with the tab
    buttons. We've added this option by setting the default `sortable` value to `false`
    in the `options` object. This object will be merged with the default tabs options.
    In the `_create()` method, the tabs constructor, we call the original tabs widget
    constructor as nothing special needs to happen with the default widget construction.
    Next, still inside `_create()`, we check that the `sortable` option is `true`,
    and if so create the sortable widget. The `tablist` property we're using to create
    the sortable widget with is the `ul` element that holds our tabs buttons. This
    is why we're calling it here, we want its children to be sortable along the x
    axis.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经向标签小部件添加了一个新选项，`sortable`，当设置为true时，将使用可排序交互小部件来启用标签按钮的可排序行为。我们通过在`options`对象中将默认`sortable`值设置为`false`来添加了这个选项。该对象将与默认标签选项合并。在`_create()`方法中，标签构造函数中，我们调用原始的标签小部件构造函数，因为默认小部件构造不存在特殊情况。接下来，在`_create()`内部，我们检查`sortable`选项是否为`true`，如果是，就创建可排序小部件。我们使用`tablist`属性来创建可排序小部件，这是一个包含标签按钮的`ul`元素。这就是为什么我们在这里调用它，我们想让它的子元素在x轴上可以进行排序。
- en: We're also passing the `stop` option of the sortable widget a callback function,
    in this case, a proxy of the `_stopped()` method. This is using the `$.proxy()`
    utility so that we can implement `_stopped()` as though it is a regular method
    of tabs. Notice in the `_stopped()` implementation that this is the widget instance,
    whereas without a proxy, this would be the `ul` element.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将可排序小部件的`stop`选项传递给一个回调函数，这种情况下是`_stopped()`方法的代理。这里使用了`$.proxy()`实用程序，这样我们可以像实现标签的常规方法一样实现`_stopped()`。请注意在`_stopped()`的实现中，这是小部件实例，而没有代理，它会是`ul`元素。
- en: Finally, the `_destroy()` method is overridden here to ensure that the sortable
    widget is destroyed. Without doing so, we couldn't reliably destroy and recreate
    the tabs widget.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这里重写了`_destroy()`方法以确保可排序小部件被销毁。如果不这样做，我们就无法可靠地销毁并重新创建标签小部件。
- en: There's more...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多信息...
- en: 'We can further enhance the user interaction of the tabs widget when the `sortable`
    option is set to `true`. First, let''s modify `cursor` while the user is dragging
    the tab so that it uses a standard move icon. Next, we''ll activate the dropped
    tab. Here is the CSS we''ll need for the modified cursor; we''ll keep the previous
    HTML structure as is:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当将`sortable`选项设置为`true`时，我们可以进一步增强选项卡小部件的用户交互。首先，让我们在用户拖动选项卡时修改`cursor`，以便使用标准的移动图标。接下来，我们将激活放置的选项卡。这是我们为修改后的光标所需的CSS；我们将保持先前的HTML结构不变：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And here is the modified JavaScript:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是修改后的JavaScript代码：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now when you sort these tabs, you'll notice the new cursor is illustrated in
    the following screenshot. The `ui-tab-move` class defines the `cursor` CSS property,
    and this class is added to the `li` element in the `start` event handler of the
    sortable widget. It is subsequently removed in the `stop` handler. You'll also
    notice that the tab is activated when the tab is dropped. This is done by getting
    the index of the `li` element and passing that to the `activate()` method.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您对这些选项卡进行排序时，您会注意到新的光标如以下截图所示。`ui-tab-move`类定义了`cursor`的CSS属性，此类被添加到可排序小部件的`start`事件处理程序中的`li`元素中。在`stop`处理程序中随后删除。您还会注意到当放置选项卡时会激活选项卡。这是通过获取`li`元素的索引并将其传递给`activate()`方法来完成的。
- en: '![There''s more...](img/2186_10_10.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/2186_10_10.jpg)'
- en: Setting the active tab using href
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用href设置活动选项卡
- en: The tabs widget allows the developer to programmatically set the active tab.
    This can be done by passing a zero-based index value to the `active` option. This
    option can be set in the tabs constructor, which tells the widget which tab to
    activate by default, or it can be set afterwards, potentially changing the active
    tab. Changing the active tab using this option is essentially the same thing as
    a user clicking on a tab button to activate the panel. However, we can improve
    on this interface by allowing developers using the tabs widget to pass an `href`
    value instead of an index. This way, you don't have to remember the ordering of
    the tabs—which number represents which link, and so on.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 选项卡小部件允许开发人员通过将零基索引值传递给`active`选项来以编程方式设置活动选项卡。这可以通过在选项卡构造函数中设置此选项来完成，告诉小部件默认激活哪个选项卡，或者可以在之后设置，从而可能改变活动选项卡。使用此选项更改活动选项卡实质上与用户点击选项卡按钮激活面板是相同的。然而，我们可以改进此界面，让使用选项卡小部件的开发人员传递`href`值而不是索引值。这样，您就不必记住选项卡的顺序—哪个数字代表哪个链接，等等。
- en: How to do it...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Let's first set up the HTML used in this demonstration as the foundation of
    the tabs widget.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先设置此演示中使用的HTML作为选项卡小部件的基础。
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next is the modified implementation of the tabs widget that enables us to activate
    the second tab by passing the string `"#tab2"` to the `active` option.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是修改后的选项卡小部件实现，使我们可以通过将字符串`"#tab2"`传递给`active`选项来激活第二个选项卡。
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何运作的...
- en: You'll notice that when you look at this tabs widget in the browser, the second
    tab is activated by default as we're passing in the string `"#tab2"`. You'll also
    notice that the content of each tab panel has a link pointing to another tab.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在浏览器中查看此选项卡小部件时，您会注意到第二个选项卡默认处于激活状态，因为我们传递了字符串`"#tab2"`。还会注意到每个选项卡面板的内容都指向另一个选项卡的链接。
- en: '![How it works...](img/2186_10_11.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何运作的...](img/2186_10_11.jpg)'
- en: We're extending the tabs widget so that we can override a couple of tabs methods.
    The first method is `_findActive()`, which in the original implementation expects
    an integer. We've changed this to use the `_getIndex()` method that returns the
    index based on the `href` attribute of the tab button, that is, unless it gets
    an integer value passed to it, in which case, it just returns that number. In
    short, we've changed `_findActive()` to accept either a zero-based index number,
    or an `href` string.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在扩展选项卡小部件，以便我们可以重写一些选项卡方法。第一个方法是`_findActive()`，在原始实现中期望一个整数。我们已经改变了这一点，使用了根据选项卡按钮的`href`属性返回索引的`_getIndex()`方法，也就是说，除非它得到传递给它的整数值，否则它只返回那个数字。简而言之，我们已经改变了`_findActive()`，以接受零基索引号，或`href`字符串。
- en: The next method is `_initialActive()`, which is called when the tabs widget
    is first instantiated. What we're doing here is setting the active option to the
    appropriate index value before calling the original implementation of `_initialActive()`.
    This is necessary to support the `href` string in the constructor as the `active`
    option value.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法是 `_initialActive()`，当标签小部件首次实例化时调用。我们在这里要做的是在调用 `_initialActive()` 的原始实现之前，将活动选项设置为适当的索引值。这是为了支持构造函数中的
    `href` 字符串作为 `active` 选项值。
- en: Finally, we're creating our tabs widget using an `href` string, and we're binding
    an event handler to each of the tab-link anchors in the tab panels. Here, we're
    activating the tab based solely on the `href` attribute of the link, so you can
    see the value of this new `href` capability we've introduced.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `href` 字符串创建我们的标签小部件，并将事件处理程序绑定到标签面板中的每个标签链接上。在这里，我们仅基于链接的 `href` 属性激活标签，所以你可以看到我们引入的这种新
    `href` 功能的价值。
- en: There's more...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the preceding example, we're utilizing the `href` attribute of the tab button
    links. However, we're not utilizing the location hash of the browser. In other
    words, when a tab is activated, the location hash in the browser URL doesn't change.
    There are several advantages to supporting this approach. For one thing, we can
    use the Back button to navigate through our active tabs. Another benefit is that
    our links in the tab content panels no longer need an event handler; they can
    just point their `href` attributes to the tab `href`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们利用了标签按钮链接的 `href` 属性。但是，我们没有利用浏览器的位置哈希。换句话说，当激活标签时，浏览器 URL 中的位置哈希不会更改。支持这种方法有几个优点。首先，我们可以使用返回按钮浏览我们的活动标签。另一个好处是，标签内容面板中的链接不再需要事件处理程序；它们可以直接指向标签
    `href`。
- en: Here is the modified JavaScript that supports the same functionality as the
    previous example. The only difference is that the URL hash will change any time
    a tab is activated.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是修改后的 JavaScript，支持与上一个示例相同的功能。唯一的区别是，每次激活标签时，URL 哈希都会更改。
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now when you interact with this tabs widget in the browser, you'll notice that
    the hash changes in the URL as you navigate through the tabs. This is done by
    adding an event handler to the `_create()` method, after calling the original
    implementation of `_create()`. We're using the `_on()` utility method to subscribe
    to the window's `hashchange` event. Next, the `_hashChange()` method we've added
    is the handler for this event. First, we check if the URL hash, stored in the
    `location.hash` variable, is already pointing to the active tab. If not, we activate
    the tab based on the current URL hash value. This is all we need to support the
    links in the tab panel content that point directly to a URL hash. But, when the
    user clicks directly on the tab button, there is no change in the hash value.
    This doesn't help us much because we cannot track the tab navigation history.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你在浏览器中与此标签小部件交互时，你会注意到在导航标签时 URL 中的哈希会更改。这是通过在调用 `_create()` 的原始实现后向该方法添加事件处理程序来完成的。我们使用
    `_on()` 实用程序方法订阅窗口的 `hashchange` 事件。接下来，我们添加的 `_hashChange()` 方法是此事件的处理程序。首先，我们检查
    URL 哈希，存储在 `location.hash` 变量中，是否已经指向活动标签。如果没有，我们根据当前 URL 哈希值激活标签。这是我们支持指向 URL
    哈希的标签面板内容中的链接所需的全部内容。但是，当用户直接单击标签按钮时，哈希值不会更改。这对我们没有帮助，因为我们无法跟踪标签导航历史记录。
- en: This is why we've implemented a customization of the `_eventHandler()` method.
    We first call the original implementation of the method before we go about handling
    the URL hash specifics. If the URL hash is already pointing to the active tab,
    we have nothing to do here; otherwise, we update the URL hash.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们实现了 `_eventHandler()` 方法的自定义。我们首先调用方法的原始实现，然后再处理 URL 哈希的具体情况。如果 URL
    哈希已经指向活动标签，我们在这里没有任何操作；否则，我们更新 URL 哈希。
