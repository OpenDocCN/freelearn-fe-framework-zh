- en: Chapter 3. Composing with Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。使用组件进行组合
- en: In this chapter, we will go one step further in structuring our application
    and working on the layout and architecture that serves as the base for our task
    management system. Besides introducing new components and creating larger compositions
    with the existing components, we'll also look at the way that we deal with data.
    So far, we've obtained task data synchronously from the `TaskListService` that
    we created in the previous chapter. However, in real-world scenarios, this would
    rarely be the case. In a real application, data is mostly retrieved in an asynchronous
    form. Usually, we acquire data through a RESTful web service, and we use `XMLHttpRequest`
    or the recently standardized fetch API. However, as we're trying to build a cutting-edge
    application, we will go one step further. In this chapter, we'll look at how we
    can restructure our application to deal with observable data structures using
    RxJS—a functional and reactive programming library that is used in Angular.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进一步构建我们的应用程序结构，并处理作为我们任务管理系统基础的布局和架构。除了引入新组件和通过现有组件创建更大的组合外，我们还将探讨我们处理数据的方式。到目前为止，我们已经从上一章中创建的`TaskListService`同步获取了任务数据。然而，在现实世界的场景中，这种情况很少发生。在实际应用中，数据大多以异步形式检索。通常，我们通过RESTful
    Web服务获取数据，并使用`XMLHttpRequest`或最近标准化的fetch API。然而，由于我们试图构建一个前沿的应用程序，我们将更进一步。在本章中，我们将探讨如何使用RxJS重构我们的应用程序以处理可观察数据结构——RxJS是一个在Angular中使用的功能性和响应式编程库。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Restructuring our application to deal with observable data structures
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构我们的应用程序以处理可观察数据结构
- en: The basics of RxJS and its operators in order to build a reactive data model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJS及其操作符的基本知识，以便构建响应式数据模型
- en: Using pure components in Angular
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular中使用纯组件
- en: Using `ChangeDetectionStrategy.OnPush` for pure components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为纯组件使用`ChangeDetectionStrategy.OnPush`
- en: Using content projection points and `@ContentChildren` to create a `Tab` component
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内容投影点和`@ContentChildren`创建`Tab`组件
- en: Creating a simple navigation component
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的导航组件
- en: Injecting parent components and establishing direct component communication
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入父组件并建立直接组件通信
- en: Combining internal and external content to create a flexible component API
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合内部和外部内容以创建灵活的组件API
- en: Data – Fake to real
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据 – 从伪造到真实
- en: Starting with this chapter, we are switching to a document-based database to
    store our tasks and project data. As a data store, we use the PouchDB project,
    which is an in-browser database that is designed to run with IndexedDB and various
    fallback strategies. PouchDB is designed similarly to Apache CouchDB, and it can
    even be synchronized with it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我们将切换到基于文档的数据库来存储我们的任务和项目数据。作为一个数据存储，我们使用PouchDB项目，这是一个设计用于与IndexedDB一起运行并在各种回退策略中运行的浏览器数据库。PouchDB的设计类似于Apache
    CouchDB，并且甚至可以与之同步。
- en: In order to provide a quality experience for you while you build your application,
    it's important that we work in real-life conditions. This means that we should
    use asynchronous data in our components and not rely on a simple JavaScript array
    of data. In order to make this as smooth as possible, the whole data layer is
    already set up for you, and you don't need to worry about the internals too much.
    Of course if you're still interested, I'm not holding you back from exploring
    the source code that is in the `data-access` folder.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在你构建应用程序的过程中为你提供优质体验，我们工作在真实生活条件下是非常重要的。这意味着我们应该在我们的组件中使用异步数据，而不是依赖于简单的JavaScript数据数组。为了使这个过程尽可能顺畅，整个数据层已经为你设置好了，你不需要过多地担心内部细节。当然，如果你仍然感兴趣，我不会阻止你探索位于`data-access`文件夹中的源代码。
- en: Reactive programming with observable data structures
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可观察数据结构进行响应式编程
- en: So far, we used simple array data structures in the task list that we created.
    This is not really what we'll find in real-world scenarios. In real applications,
    we have to deal with asynchronous data and the changes of the data that needs
    to be synchronized between users. The requirements for modern applications sometimes
    even go further and also provide view updates on the changed data in real time.
    As we're building a modern task management system here, we should try to keep
    up with these requirements.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在创建的任务列表中使用了简单的数组数据结构。这并不是我们在现实世界场景中会遇到的。在实际应用中，我们必须处理异步数据和需要在用户之间同步的数据变化。现代应用程序的要求有时甚至更严格，还需要实时提供更改数据的视图更新。既然我们正在构建一个现代任务管理系统，我们应该努力跟上这些要求。
- en: Both of these, handling asynchronous data and handling real-time data updates,
    require a major redesign of the data flow in our application. Using observable
    data structures, we enable our application to master the challenges of asynchronous
    data where we need to react to change.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者，处理异步数据和处理实时数据更新，都需要对我们应用程序中的数据流进行重大重构。使用可观察数据结构，我们使我们的应用程序能够掌握异步数据的挑战，在这些数据中我们需要对变化做出反应。
- en: Handling data in applications behaves very similarly to streams. You take input,
    transform it, combine it, merge it, and finally, write it into output. In systems
    such as this, it's also very likely that input is in a continuous form and sometimes
    even of infinite duration. Just take a live feed as an example; this type of data
    flows continuously, and the data also flows infinitely. Functional and reactive
    programming are paradigms to help us deal with this kind of data in a cleaner
    way.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中处理数据的行为与流非常相似。你接收输入，转换它，组合它，合并它，最后将其写入输出。在类似这样的系统中，输入也很有可能是连续的，有时甚至是无限期的。以实时流为例；这类数据持续流动，数据也无限流动。函数式和响应式编程是帮助我们以更干净的方式处理这类数据的范式。
- en: '![Reactive programming with observable data structures](img/image00309.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![使用可观察数据结构的响应式编程](img/image00309.jpeg)'
- en: A simple observable subscription with value emission and a transformation
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的可观察订阅，带有值发射和转换
- en: Angular 2 is reactive at its very core and the whole of the change detection
    and bindings are built using a reactive architecture. The input and output of
    components, which we've learned about in the previous chapter, is nothing but
    a data flow that is established using a reactive event-driven approach. Angular
    uses RxJS, a functional and reactive programming library for JavaScript, to implement
    this data flow. In fact, the `EventEmitter`, which we've used to send custom events
    from within our components, is just a wrapper around an RxJS observable.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2 在其核心是响应式的，整个变化检测和绑定都是使用响应式架构构建的。我们在上一章中学到的组件的输入和输出，不过是一个使用响应式事件驱动方法建立的数据流。Angular
    使用 RxJS，一个用于 JavaScript 的函数式和响应式编程库，来实现这个数据流。实际上，我们用来从组件内部发送自定义事件的 `EventEmitter`，只是
    RxJS 可观察对象的一个包装。
- en: 'Reactive and functional programming is exactly what we are looking for to redesign
    our application in order to handle asynchronous data and data changes. As we already
    have RxJS at hand from the production dependency of Angular, let''s use it to
    establish a continuous data flow from our data source into our application. The
    `DataProvider` service that is present in the `data-access` folder of our project
    provides a nice wrapper around our data store using RxJS. As we will use this
    service in our whole application, we can directly provide it to the bootstrap
    in the `bootstrap.js` file, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式和函数式编程正是我们为了处理异步数据和数据变化而重新设计应用程序所寻找的。因为我们已经从 Angular 的生产依赖中获得了 RxJS，所以让我们使用它来从我们的数据源到我们的应用程序建立一个连续的数据流。我们项目
    `data-access` 文件夹中存在的 `DataProvider` 服务使用 RxJS 为我们的数据存储提供了一个很好的包装。由于我们将在整个应用程序中使用此服务，我们可以在
    `bootstrap.js` 文件中直接将其提供给 `bootstrap`，如下所示：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As a second argument to the `bootstrap` function of Angular, we can provide
    application-level dependencies, which will be available for injection in all components
    and directives.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Angular 的 `bootstrap` 函数的第二个参数，我们可以提供应用级别的依赖项，这些依赖项将在所有组件和指令中可用。
- en: Let's now use the `DataProvider` service as an abstraction to obtain data from
    the PouchDB data store and create a new service responsible to provide project
    data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用 `DataProvider` 服务作为抽象来从 PouchDB 数据存储中获取数据，并创建一个新的服务，负责提供项目数据。
- en: 'We will create a new `ProjectService` class on the `lib/project/project-service/project-service.js`
    path, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `lib/project/project-service/project-service.js` 路径上创建一个新的 `ProjectService`
    类，如下所示：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Looking at the import section of our new module, you can see that we import
    the necessary dependencies from the Angular core module for dependency injection.
    Our service class uses the `@Injectable` decorator so that we can provide this
    to the injectors of components. We also inject the `DataProvider` service into
    the constructor of our newly-created service.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们新模块的导入部分，你可以看到我们从 Angular 核心模块中导入了必要的依赖项以进行依赖注入。我们的服务类使用 `@Injectable` 装饰器，这样我们就可以将其提供给组件的注入器。我们还将在新创建的服务构造函数中注入
    `DataProvider` 服务。
- en: The `ReplaySubject` class, which we import from the RxJS library, is used to
    make our service reactive. A subject in the RxJS world is both an observer as
    well as an observable. It can observe something for changes and then emit further
    on to all its subscribers. You can think of a subject like a proxy, where it sits
    in the middle between a source for changes and a group of observers. Whenever
    the source emits changes, the subject will notify all subscribers about these
    changes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 RxJS 库中导入的 `ReplaySubject` 类用于使我们的服务变得响应式。在 RxJS 世界中，一个主题（subject）既是观察者（observer）也是可观察的（observable）。它可以观察某些变化，然后向所有订阅者发出进一步的通知。你可以将主题想象成一个代理，它位于变化源和一组观察者之间。每当源发出变化时，主题将通知所有订阅者这些变化。
- en: Now, the `ReplaySubject` class is a special kind of subject that allows you
    to replay a buffer of changes when new subscribers get added. This is especially
    useful if you always need to provide some initial data to subscribers. Imagine
    our data, which we'd like to get propagated into the UI. We want to immediately
    get the initial data when we subscribe to our service and then going forward,
    we also want to get notified about changes. Using a `ReplySubject` class, which
    is buffering just one change, suits this use-case perfectly.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`ReplaySubject` 类是一种特殊的主题，它允许你在添加新订阅者时回放一个变化缓冲区。这在始终需要向订阅者提供一些初始数据时特别有用。想象一下我们的数据，我们希望将其传播到
    UI 中。我们希望在订阅我们的服务时立即获取初始数据，然后继续，我们也希望得到关于变化的通知。使用仅缓冲一个变化的 `ReplaySubject` 类，可以完美地满足这种用例。
- en: 'Let''s look at the following figure, which illustrates the behavior of `ReplaySubject`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下图，它说明了 `ReplaySubject` 的行为：
- en: '![Reactive programming with observable data structures](img/image00310.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![使用可观察数据结构的响应式编程](img/image00310.jpeg)'
- en: A source connected to an observer using a ReplaySubject class, which buffers
    the most recent value and emits on subscription
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ReplaySubject` 类连接到观察者的源，该类缓冲最新值并在订阅时发出
- en: In the preceding figure, you can see that we're connecting a `ReplaySubject`
    class to a source that is emitting value changes over time. After two emissions,
    an observer subscribes to our `ReplaySubject` class. `ReplaySubject` will then
    replay all buffered changes to the new subscriber as if these events just occurred.
    In this example, we use a replay buffer length of one. On subsequent value emissions,
    these will be directly re-emitted to the subscribers of the `ReplaySubject` class.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，你可以看到我们正在将一个 `ReplaySubject` 类连接到一个随时间发出值变化的源。在两次发出后，一个观察者订阅了我们的 `ReplaySubject`
    类。然后 `ReplaySubject` 将所有缓冲的变化回放到新订阅者，就像这些事件刚刚发生一样。在这个例子中，我们使用了一个回放缓冲长度为 1。在随后的值发出时，这些值将直接重新发出到
    `ReplaySubject` 类的订阅者。
- en: Let's go back to our `ProjectService` class and add some logic to the `constructor`
    function in order to emit project data using a `ReplaySubject` class.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的 `ProjectService` 类，并在构造函数中添加一些逻辑，以便使用 `ReplaySubject` 类发出项目数据。
- en: 'We will start off with some member field initialization, for which we''re going
    to need to implement the logic:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始一些成员字段的初始化，我们需要实现以下逻辑：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that we created a new `ReplaySubject` class with a buffer length of one,
    and assign it to the member filed with the name `change`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们创建了一个具有一个缓冲长度的 `ReplaySubject` 类，并将其分配给名为 `change` 的成员字段。
- en: We also assign the `DataProvider` service, which was previously injected in
    the constructor parameters, to the `dataProvider` member field.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将之前在构造函数参数中注入的 `DataProvider` 服务分配给 `dataProvider` 成员字段。
- en: 'Now, it''s time to make use of the `DataProvider` service in order to subscribe
    for any changes within our data store. This establishes a reactive connection
    to our data that is stored in PouchDB:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候利用 `DataProvider` 服务来订阅数据存储中的任何变更了。这建立了一个对我们的 PouchDB 中存储的数据的响应式连接：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The observable that is returned by the `getLiveChanges()` function emits data
    in our data store as changes. In addition to this, this will also emit any future
    changes that are applied to our store after we've received the initial data. You
    can imagine a persistent connection to the database, and whenever a document is
    updated in the database, our observer will receive this change as a value.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `getLiveChanges()` 函数返回的可观测量会以变更的形式在我们的数据存储中发出数据。除此之外，这还会在我们在收到初始数据之后对存储应用任何后续变更时发出这些变更。你可以想象一个持续连接到数据库的连接，每当数据库中的文档被更新时，我们的观察者都会接收到这个变更值。
- en: Observables provide a large amount of so-called operators that allow you to
    transform the data stream that originated at the observable. You might already
    know about some of these functional operators from the ECMAScript 5 array extra
    functions, such as `map` and `filter`. Using operators, you can model a whole
    transformation flow until you finally subscribe to the data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 可观测量提供了一大堆所谓的算子，这些算子允许你转换来自可观测量的数据流。你可能已经从 ECMAScript 5 数组扩展函数中了解到一些这些函数算子，例如
    `map` 和 `filter`。使用算子，你可以模拟整个转换流程，直到你最终订阅数据。
- en: 'As we receive changed objects from the data store, we first need to transform
    them into document objects. This is fairly easy because each change object contains
    a `doc` property that actually holds the whole data of the changed document for
    which we have received an update. Using the `map` function, we can transform the
    changed objects into project objects before we return them back into the data
    flow:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从数据存储中接收到变更对象时，我们首先需要将它们转换成文档对象。这相当简单，因为每个变更对象都包含一个 `doc` 属性，实际上它持有我们已接收更新的变更文档的全部数据。使用
    `map` 函数，我们可以在将变更对象返回到数据流之前，将它们转换成项目对象：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`DataProvider` will provide us with data for all the documents in the store.
    As we are only interested in project data at the moment, we also apply a filter
    that filters out all the documents that are not of the `project` type:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataProvider` 将为我们提供存储中所有文档的数据。由于我们目前只对项目数据感兴趣，我们还应用了一个过滤器，过滤掉所有不是 `project`
    类型的文档：'
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we can subscribe to the transformed stream, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以订阅转换后的流，如下所示：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `subscribe` operator is where we terminate our observation path. This is
    like an endpoint at which we sit and observe. Inside our `subscribe` function,
    we listen for project document updates and incorporate them into the `projects`
    member property of our `App` component. This includes not only adding the new
    projects that were added to the document store, but it also includes updating
    existing projects. Each project contains a unique identifier that can be accessed
    by the `_id` property. This allows us to find the right action easily.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribe` 算子是我们观察路径的终止点。这就像是我们坐下来观察的终点。在我们的 `subscribe` 函数内部，我们监听项目文档的更新，并将它们纳入
    `App` 组件的 `projects` 成员属性中。这包括不仅添加到文档存储中的新项目，还包括更新现有项目。每个项目都包含一个可以通过 `_id` 属性访问的唯一标识符。这使我们能够轻松找到正确的操作。'
- en: 'After updating our actual view of the projects and storing the list of projects
    in the `projects` member field, we can emit the updated list using our `ReplaySubject`
    class:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新我们的项目实际视图并将项目列表存储在 `projects` 成员字段之后，我们可以使用我们的 `ReplaySubject` 类发出更新后的列表：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our `ProjectService` class is now ready to be used, and applications components
    that need to obtain project data can subscribe to the exposed `ReplaySubject`
    class in order to react on these data changes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `ProjectService` 类现在已准备好使用，需要获取项目数据的应用组件可以订阅暴露的 `ReplaySubject` 类，以便对这些数据变更做出反应。
- en: 'Let''s refactor our `App` component in `lib/app.js` and get rid of the fake
    `TaskListService` that we''ve used so far:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `lib/app.js` 中重构 `App` 组件，并移除我们迄今为止使用的假 `TaskListService`：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In our `App` component, we now obtain a list of projects using the changed observable
    on our `ProjectService` class. Using a reactive subscription to `ReplaySubject`
    on the service, we make sure that our projects list that is stored in the `App`
    component will always be updated after any changes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `App` 组件中，我们现在通过 `ProjectService` 类上的变化可观察对象来获取项目列表。通过在服务上使用对 `ReplaySubject`
    的响应式订阅，我们确保存储在 `App` 组件中的项目列表在发生任何更改后都会更新。
- en: We use the `OnDestroy` lifecycle hook to unsubscribe from the `ProjectService`
    change observable. This is a necessary manual step if you like to do proper housekeeping
    in your application. Depending on the source, forgetting to unsubscribe could
    lead to memory leaks.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `OnDestroy` 生命周期钩子来取消订阅 `ProjectService` 的变化可观察对象。如果你喜欢在应用程序中进行适当的清理，这是一个必要的手动步骤。根据来源，忘记取消订阅可能会导致内存泄漏。
- en: 'With the preceding code, we already established the base for a reactive data
    architecture. We observe our data store for changes and our user interface will
    react on them:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的代码，我们已经为响应式数据架构奠定了基础。我们观察数据存储的变化，并且我们的用户界面会对其做出反应：
- en: '![Reactive programming with observable data structures](img/image00311.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![使用可观察数据结构的响应式编程](img/image00311.jpeg)'
- en: This figure shows the reactive data flow end-to-end from our data-store into
    the view
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图展示了从我们的数据存储到视图的端到端响应式数据流。
- en: Immutability
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性
- en: Immutable data was originally a core concept of functional programming. This
    topic will not cover immutable data in much depth, but it will explain the core
    concept so that we can talk about how to apply this concept to Angular components.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性最初是函数式编程的核心概念。这个主题不会深入探讨不可变性，但它将解释核心概念，以便我们可以讨论如何将这个概念应用到 Angular 组件中。
- en: Immutable data structures force you to create a full copy of the data that you
    want to modify before you can do this. You'll never operate on the data directly
    but on a copy of this same data. This has many benefits over standard mutable
    data, the most obvious probably being the application state. When you always operate
    on new copies of data, there's no chance that you're messing up the data that
    you actually didn't want to modify.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变数据结构迫使你在修改数据之前必须创建数据的完整副本。你将永远不会直接操作数据，而是操作这个相同数据的副本。与标准可变数据相比，这有许多优点，最明显的大概是应用状态。当你总是操作数据的新副本时，你就不太可能破坏你实际上不想修改的数据。
- en: 'Let''s take this simple example, which illustrates the issues object references
    can cause:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的例子来说明对象引用可能引起的问题：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Although this seems odd at first, it actually makes sense that the output of
    this example is true. `Array.reverse()` is a mutable operation, and it will modify
    the innards of the array. The actual reference will stay the same because JavaScript
    will not create a copy of the array to reverse it. Although technically this makes
    a lot of sense, this is not what we expected in the first place when we look at
    this code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始看起来有些奇怪，但实际上这个示例的输出为真是有道理的。`Array.reverse()` 是一个可变操作，它会修改数组的内部结构。实际的引用将保持不变，因为
    JavaScript 不会创建数组的副本来反转它。虽然从技术上讲这很有道理，但当我们最初查看这段代码时，这并不是我们预期的。
- en: 'We can easily change this example to an immutable procedure by creating a copy
    of the array before we reverse it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地将这个例子改为不可变过程，通过在反转之前创建数组的副本：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The issue with references is that they can cause a lot of unexpected side-effects.
    Also, if we come back to our encapsulation topic from [Chapter 1](part0014.xhtml#aid-DB7S1
    "Chapter 1. Component-Based User Interfaces"), *Component-Based User Interfaces*,
    they are completely against the concept of encapsulation. Although we might think
    that it would be safe to pass complex data types into a capsule, it''s actually
    not. As we''re dealing with references here, the data can still be modified from
    the outside, and our capsule will not have the complete ownership. Consider the
    following example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 引用的问题在于它们可以引起许多意外的副作用。此外，如果我们回到第一章中关于封装的讨论，即[基于组件的用户界面](part0014.xhtml#aid-DB7S1
    "第一章。基于组件的用户界面")，它们与封装的概念完全相反。尽管我们可能认为将复杂的数据类型传递到胶囊中是安全的，但实际上并不是这样。因为我们在这里处理的是引用，数据仍然可以从外部被修改，并且我们的胶囊将不会拥有完整的所有权。考虑以下示例：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Even if we only wanted to store the data internally in our `Sum` class, we would
    have created an unwanted side-effect of referencing and modifying the data object
    that's outside the instance. Multiple `sum` instances would also share the same
    data from outside and cause more side-effects. As a developer, you've learned
    to treat object references right, but they still can cause a lot of problems.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们在我们的 `Sum` 类中只想内部存储数据，我们也会创建一个不希望出现的副作用，即引用和修改实例之外的数据对象。多个 `sum` 实例也会共享外部相同的数据并引起更多的副作用。作为一个开发者，你已经学会了正确地处理对象引用，但它们仍然可以引起很多问题。
- en: 'We don''t have these problems with immutable data, which can be illustrated
    easily with primitive data types in JavaScript. Primitive data types don''t use
    references, and they are immutable by design:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在不可变数据中没有这些问题，这可以通过 JavaScript 中的原始数据类型很容易地说明。原始数据类型不使用引用，并且它们的设计就是不可变的：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There's no way we can modify an instance of a string. Every modification that
    we perform on a string will generate a new string, and this prevents the unwanted
    side-effects.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法修改字符串的实例。我们对字符串进行的任何修改都会生成一个新的字符串，这防止了不希望出现的副作用。
- en: So, why do we still have object references within programming languages, even
    though they cause so many issues? Why aren't we performing all these operations
    on immutable data, and why are we only dealing with values rather than object
    references?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们仍然在编程语言中有对象引用，尽管它们会引起很多问题？为什么我们不执行所有这些操作在不可变数据上，而只是处理值而不是对象引用？
- en: Of course, imperative data structures also come with their benefits, and it
    always depends on the context if immutable data brings value.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，命令式数据结构也带来了它们的好处，并且是否不可变数据带来价值总是取决于上下文。
- en: One of the main reasons that is often used against immutable data is bad performance.
    Of course, it costs some performance if we need to create tons of copies of our
    data every time we want to modify it. However, there are great optimization techniques,
    which fully eliminate the performance issues that we would usually expect from
    immutable data structures. Using a tree data structure that allows internal structural
    sharing, copies of the data will be shared internally. This allows very efficient
    memory management, which in some situations, even outperforms mutable data structures.
    I can highly recommend the paper by Chris Okasaki about *Purely Functional Data
    Structures* if you would like to read more about performance in immutable data
    structures.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 人们经常用来反对不可变数据的主要原因是性能问题。当然，如果我们每次想要修改数据时都需要创建大量数据的副本，这会消耗一些性能。然而，有一些优秀的优化技术，可以完全消除我们通常从不可变数据结构中期望的性能问题。使用允许内部结构共享的树数据结构，数据副本将在内部共享。这允许非常高效的内存管理，在某些情况下，甚至可以超越可变数据结构。如果你想了解更多关于不可变数据结构中的性能信息，我强烈推荐阅读
    Chris Okasaki 关于 *纯函数数据结构* 的论文。
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: JavaScript does not support immutable data structures out of the box. However,
    you can use libraries, such as `Immutable.js` by Facebook, which provide you with
    an easy API to deal with immutable data. `Immutable.js` even implements structural
    sharing and makes it a perfect power tool if you decide to build on an immutable
    architecture in your application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 默认不支持不可变的数据结构。然而，你可以使用库，例如 Facebook 的 `Immutable.js`，它为你提供了一个简单的
    API 来处理不可变数据。`Immutable.js` 甚至实现了结构共享，如果你决定在你的应用程序中构建不可变架构，它将是一个完美的强大工具。
- en: 'As with every paradigm, there are pros and cons, and depending on the context,
    one concept may fit better than another one. In our application, we won''t use
    immutable data structures that are provided by third-party libraries, but we''ll
    borrow some of the benefits that you get from immutable data by the following
    immutable idioms:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个范式一样，都有优点和缺点，并且根据上下文，一个概念可能比另一个更适合。在我们的应用程序中，我们不会使用第三方库提供的不可变数据结构，但我们会通过以下不可变习惯用法借用一些从不可变数据中获得的好处：
- en: '**It''s much easier to reason about immutable data**: You can always tell why
    your data is in a given state because you know the exact transformation path.
    This may sound irrelevant, but in practice, this is a huge benefit not only for
    humans to write code, but also for compilers and interpreters to optimize it.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变数据更容易推理**：你总是可以知道你的数据为什么处于某种状态，因为你知道确切的转换路径。这可能听起来无关紧要，但在实践中，这对人类编写代码以及编译器和解释器优化代码都是一个巨大的好处。'
- en: '**Using immutable objects makes change detection much faster**: If we rely
    on immutable patterns to treat our data, we can rely on object reference checks
    to detect change. We no longer need to perform complex data analysis and comparison
    for dirty checking, and can fully rely on checking references. We have the guarantee
    that object properties don''t change without the object identity changing as well.
    This makes change detection as easy as `oldObject === newObject`.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用不可变对象使变化检测变得更快**：如果我们依赖于不可变模式来处理我们的数据，我们可以依赖于对象引用检查来检测变化。我们不再需要执行复杂的数据分析和比较来进行脏检查，而可以完全依赖于检查引用。我们有保证，对象属性不会在没有对象身份改变的情况下改变。这使得变化检测变得像
    `oldObject === newObject` 一样简单。'
- en: Pure components
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯组件
- en: The idea of a "pure" component is that its whole state is represented by its
    inputs, where all inputs are immutable. This is effectively a stateless component,
    but additionally, all the inputs are immutable.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: “纯”组件的想法是它的整个状态由其输入表示，其中所有输入都是不可变的。这实际上是一个无状态组件，但除此之外，所有输入都是不可变的。
- en: 'I like to call such components "pure" because their behavior can be compared
    to the concept of pure functions in functional programming. A pure function is
    a function which has the following properties:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢称这样的组件为“纯”，因为它们的行为可以与函数式编程中纯函数的概念相比较。纯函数是一个具有以下属性的函数：
- en: It does not rely on any state outside of the function scope
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不依赖于函数作用域之外的状态
- en: It always behave the same if input parameters don't change
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入参数没有改变，它总是表现相同
- en: It never changes any state outside the function scope (side-effect)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它永远不会在函数作用域之外改变任何状态（副作用）
- en: With pure components, we have a simple guarantee. A pure component will never
    change without its input parameters being changed. We can ignore a component and
    its subcomponents in change detection until one of the component inputs changes.
    Sticking to this idea about components gives us several advantages.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯组件，我们有一个简单的保证。纯组件在其输入参数未被更改的情况下永远不会改变。在检测变化时，我们可以忽略组件及其子组件，直到其中一个组件的输入发生变化。坚持这种关于组件的想法给我们带来几个优点。
- en: 'It''s very easy to reason about pure components and their behavior can be predicted
    very easily. Let''s look at a simple illustration of a component tree where we
    use pure components:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 纯组件的推理非常简单，它们的行为可以很容易地预测。让我们看看一个使用纯组件的组件树简单示例：
- en: '![Pure components](img/image00312.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![纯组件](img/image00312.jpeg)'
- en: A component tree with immutable components
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 具有不可变组件的组件树
- en: 'If we have the guarantee that each component in our tree has a stable state
    until an immutable input property changes, we can safely ignore change detection
    that would usually be triggered by Angular. The only way that such a component
    could change is if an input of the component changes. Let''s say that there''s
    an event that causes the **A** root component to change the input binding value
    of the **B** component, which will change the value of a binding on the **E**
    component. This event, and the resulting procedure, would mark a certain path
    in our component tree to be checked by change detection:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们保证我们的树中的每个组件在不可变输入属性改变之前都有一个稳定的状态，我们可以安全地忽略通常由 Angular 触发的变化检测。这种组件唯一可能改变的方式是如果组件的输入发生变化。比如说，有一个事件导致
    **A** 根组件更改 **B** 组件的输入绑定值，这将改变 **E** 组件上的绑定值。这个事件和由此产生的程序将标记我们的组件树中的某个路径以供变化检测检查：
- en: '![Pure components](img/image00313.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![纯组件](img/image00313.jpeg)'
- en: Figure that shows a marked path for change detection (in black) with "pure"
    components.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图中显示了带有“纯”组件的标记路径（黑色）用于变化检测。
- en: Although the state of the root component changed, which also changed input properties
    of the subcomponents on two levels, we only need to be concerned about a given
    path when thinking about possible changes in the system. Pure components give
    us the promise that they will not change if their inputs will not. Immutability
    plays a big role here. Imagine that you're binding a mutable object to the component,
    **B**, and the **A** component would change a property of this object. As we use
    object references and mutable objects, the property would also be changed for
    the **B** component. However, there's no way for the **B** component to notice
    this change, as we can't track who knows about our object within the component
    tree. Basically, we'd need to go back to regular dirty checking of the whole tree
    again.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管根组件的状态发生了变化，这也改变了两级子组件的输入属性，但我们只需要在考虑系统可能发生的变更时关注给定的路径。纯组件给我们一个承诺，即如果它们的输入不会改变，它们就不会改变。不可变性在这里起着重要作用。想象一下，你将一个可变对象绑定到组件
    **B** 上，**A** 组件会改变这个对象的属性。由于我们使用对象引用和可变对象，**B** 组件的属性也会改变。然而，**B** 组件无法注意到这个变化，因为我们无法在组件树中跟踪谁知道我们的对象。基本上，我们可能需要再次回到整个树的常规脏检查。
- en: By knowing that all our components are pure and that their inputs are immutable,
    we can tell Angular to disable change detection until an input property value
    changes. This makes our component tree very efficient, and Angular can optimize
    change detection effectively. When thinking about large component trees, this
    can make the difference between a stunningly-fast application and a slow one.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过知道所有我们的组件都是纯组件并且它们的输入是不可变的，我们可以告诉 Angular 在输入属性值改变之前禁用变更检测。这使得我们的组件树非常高效，Angular
    可以有效地优化变更检测。当考虑大型组件树时，这可能会在惊人的快速应用和慢速应用之间产生差异。|
- en: The change detection of Angular is very flexible, and each component gets its
    own change detector. We can configure the change detection of a component by specifying
    the `changeDetection` property of the component decorator.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 的变更检测非常灵活，每个组件都有自己的变更检测器。我们可以通过指定组件装饰器的 `changeDetection` 属性来配置组件的变更检测。
- en: Using `ChangeDetectionStrategy`, we can choose from a list of strategies that
    apply for the change detection of our component. In order to tell Angular that
    our component should only be checked if an immutable input was changed, we can
    use the `OnPush` strategy, which is designed exactly for this purpose.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ChangeDetectionStrategy`，我们可以从适用于我们组件变更检测的策略列表中进行选择。为了告诉 Angular 只有在不可变输入被更改时我们的组件才应该被检查，我们可以使用
    `OnPush` 策略，它正是为此目的而设计的。
- en: 'Let''s take a look at the different configuration possibilities of component
    change-detection strategies and some possible use cases:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看组件变更检测策略的不同配置可能性以及一些可能的用例：
- en: '| Change-detection strategy | Description |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 变更检测策略 | 描述 |'
- en: '| --- | --- |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CheckAlways` | This strategy tells Angular to check this component during
    every change-detection cycle, and this is obviously the most expensive strategy.
    This is the only strategy that guarantees that a component gets checked for changes
    on every possible application state change. If we''re not working with stateless
    or immutable components, or we are using an inconsistent data flow within our
    application, this is still the most reliable change-detection method. Change detection
    will be executed on every browser event that runs within the zone of this component.
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `CheckAlways` | 这个策略告诉 Angular 在每个变更检测周期中检查这个组件，这显然是最昂贵的策略。这是唯一保证在应用状态可能发生变化的每一个情况下都会检查组件变更的策略。如果我们不处理无状态或不可变组件，或者我们在应用中使用不一致的数据流，这仍然是最可靠的变更检测方法。变更检测将在运行在此组件作用域内的每个浏览器事件上执行。|'
- en: '| `Detached` | This strategy tells Angular to completely detach a component
    subtree from change detection. This strategy can be used to create a manual change-detection
    mechanism. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `Detached` | 这个策略告诉 Angular 完全从变更检测中分离一个组件子树。这个策略可以用来创建一个手动变更检测机制。|'
- en: '| `OnPush` | This strategy tells Angular that a given component subtree will
    only change under one of the following conditions:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '| `OnPush` | 这个策略告诉 Angular 给定的组件子树只有在以下条件之一成立时才会改变：'
- en: One of the input properties changes where changes need to be immutable
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中一个输入属性发生变化，需要不可变变更
- en: An event binding within the component subtree is receiving an event
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件子树内的一个事件绑定正在接收一个事件
- en: '|'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Default` | This strategy simply evaluates to `CheckAlways` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: Purifying our task list
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous topic, we changed our main application component to use RxJS
    Observables in order to get notified about the data changes in our data store.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: We also looked into the basics of using immutable data structures and that Angular
    can be configured to assume component changes only occur when component input
    changes ("pure" components). As we'd like to get the performance benefits that
    result from this optimization, let's refactor our task list component to make
    use of this.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we built our `TaskList` component and directly placed
    the task data in the component. We then refactored our code so that we could place
    the task data into a service and use injection to obtain data.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Now, we're rebuilding our `TaskList` component to make it "pure" and only dependent
    on its input properties. As we'll make sure that the data flowing into the component
    is always immutable, we can use the `OnPush` change-detection strategy on our
    refactored component. This will certainly give our task list a performance boost.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Equally important as performance, are the structural benefits that we get from
    using pure components. A "pure" component does not change any data directly because
    it's not allowed to modify application state. Instead, it uses output properties
    to emit events on changed data. This allows our parent component to react to these
    events and perform the necessary steps to handle the changes. As a result of this,
    the parent component will possibly change the input properties of the pure component.
    This will trigger change detection and effectively change the state of the pure
    component.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: What might sound a bit overcomplicated at first is actually an immense benefit
    to the structure of our application. This allows us to reason about our component
    with high confidence. The unidirectional data flow as well as stateless nature
    makes it easy to understand, examine, and test our components. Also, the loose
    nature of inputs and outputs makes our component extremely portable. We can decide
    on a parent component, what data we'd like to run into our component, and how
    we'd like to handle changes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at our `TaskList` component and how we change it to conform
    to our concept of "pure" components:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: All the operations in our task list component are now immutable. We never directly
    modify our task's data that was passed in as input, but rather we create new task
    data arrays to perform mutable operations.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: From what we've learned from the previous section, this effectively makes our
    component a "pure" component. This component itself is only relying on its input
    and makes our component very easy to reason about.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ve probably noticed that we''ve also configured the change-detection strategy
    of our component. As we have a "pure" component now, we can configure our change-detection
    strategy accordingly to save some performance:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As we're rendering a `Task` component for each data record in our task list,
    we should also check what we can change there in order to round this out.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the changes in our `Task` component:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We also use the `OnPush` strategy for our `Task` component, and we can do this
    because we also have a pure component here. This component only depends on its
    inputs. Both inputs expect native values (a `String` for title and a `Boolean`
    for done), which actually makes them immutable by nature. Changes on the task
    will be communicated using the `taskUpdated` output property.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this is a good time to think about where to place our task list in the
    application. As we''re writing a task management system that gives our users the
    ability to manage tasks within projects, we need to have a container that will
    encapsulate the concerns of projects. We create a new `Project` component, on
    the path `lib/project/project.js`, which will display project details and renders
    the `TaskList` component as a subcomponent:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Again, we make the state of this component dependent only on its immutable inputs,
    and we use the `OnPush` strategy in order to get the positive performance implications
    of using a pure component. It's also important to note that the `updateTasks`
    function acts as some sort of a delegate from our `TaskList` component. When we
    update a task inside the `TaskList` component, we catch the event in the project
    template and call the `updateTasks` function with the new updated task list. From
    here, we're just emitting the updated project data with the new task list further
    up in the component tree.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also take a look at the template of our `Project` component quickly
    to understand the wiring behind this component:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The binding logic in the template tells us how the whole data flow with our
    purified components work. While the `Project` component itself receives the list
    of tasks as input, it directly forwards this data to the `tasks` input of the
    `TaskList` component. If the `TaskList` component fires a `tasksUpdated` event,
    we're calling the `updateTasks` method on the `Project` component, which in fact
    just emits a `projectUpdated` event again.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Recap
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The refactoring of our task list is now completed, and we applied our knowledge
    about immutable components and observable data structures to gain some performance
    wins in this structure. There won't be unnecessary dirty checking on our `Task`
    component any more because we switched to the `OnPush` change-detection strategy.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: We have also reduced the complexity of the `TaskList` and `Task` components
    a lot, and it's now far easier to reason about these components and their state.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: A further benefit of this refactoring is the great encapsulation level that
    we achieved using immutable inputs. Our `TaskList` component is not relying on
    any task container as a project. We can also pass it a list of tasks across all
    the projects, and it can still work as expected.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Composition using content projection
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create a tabbed interface for our `Project` component
    that will help us further organize the structure of our application user interface.
    In order to create a `Tabs` component, we'll look at content projection and content
    child injection using observable query lists.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Input and output properties are great to establish encapsulation, and this is
    a main property of proper composition. However, sometimes the requirements are
    not to only pass data but to also pass content from the outside of a component
    into the component. In Shadow DOM, this is done using so-called slots. In Angular
    components, we can create content projection points using the `<ng-content>` element.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a simple content projection example that helps us understand
    what this is good for:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Looking at the `App` component in this example, we can see that we've put elements
    inside the actual `<child>` element. Usually, this content would be ignored and
    removed by Angular before it renders the `Child` component with its template.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: However, when using content projection, the elements that are placed inside
    our component HTML element can be sucked into the `Child` component. This is what
    content projection is all about. Content projection is actually very similar to
    the concept of transclusion from Angular 1.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: All that we need to do in order to enable content projection within a `Child`
    component is to place a `<ng-content>` element within its template. In this way,
    we specify at what locations in our component template we want to insert the content
    that is sucked in from the parent component.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we can use the select attribute on the `<ng-content>` element
    to set a CSS-like selector. This selector will be used to only suck in specific
    elements, which match this selector. In this way, you can have multiple insertion
    points that cover different content requirements.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Elements from the component element can only be inserted once, and the content
    projection works by going through all the `<ng-content>` elements in sequential
    order by project matching elements. If you have multiple competing content projection
    points in your template that are interested in the same elements, the first one
    will actually win.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Creating a tabbed interface component
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's introduce a new UI component in our `ui` folder in the project that will
    provide us with a tabbed interface that we can use for composition. We use what
    we learned about content projection in order to make this component reusable.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: We'll actually create two components, one for `Tabs`, which itself holds individual
    `Tab` components.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create the component class within a new `tabs/tab` folder in
    a file called `tab.js`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The only state that we store in our `Tab` component is whether the tab is active
    or not. The name that is displayed on the tab will be available through an input
    property.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: We use a class property binding to make a tab visible, based on the active flag
    we set a class; without this, our tabs are hidden.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `tab.html` template file of this component:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is it already? Actually, yes it is! The `Tab` component is only responsible
    for the storage of its name and active state, as well as the insertion of the
    host element content in the content projection point. There's no additional templating
    that is needed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll move one level up and create the `Tabs` component that will be responsible
    for grouping all the `Tab` components. As we won't include `Tab` components directly
    when we want to create a tabbed interface but use the `Tabs` component instead,
    this needs to forward content that we put into the `Tabs` host element. Let's
    look at how we can achieve this.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `tabs` folder, we will create a `tabs.js` file that contains our `Tabs`
    component code, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let's observe what's happening here. We used a new `@ContentChildren` annotation,
    in order to query our inserted content for directives that match the type that
    we pass to the decorator. The `tabs` property will contain an object of the `QueryList`
    type, which is an observable list type that will be updated if the content projection
    changes. You need to remember that content projection is a dynamic process, as
    the content in the host element can actually change, for example, using the `NgFor`
    or `NgIf` directives.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: We use the `AfterContentInit` lifecycle hook, which we've already briefly discussed
    in the *Custom UI elements* section of [Chapter 2](part0020.xhtml#aid-J2B81 "Chapter 2. Ready,
    Set, Go!"), *Ready, Set, Go!* This lifecycle hook is called after Angular has
    completed content projection on the component. Only then do we have the guarantee
    that our `QueryList` object will be initialized, and we can start working with
    child directives that were projected as content.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The `activateTab` function will set the `Tab` component's active flag, deactivating
    any previous active tab. As the observable `QueryList` object is not a native
    array, we first need to convert it using `toArray()` before we start working with
    it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now look at the template of the `Tabs` component that we created in
    a file called `tabs.html` in the `tabs` directory:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The structure of our `Tabs` component is as follows.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: First we render all the `tab` buttons in an unordered list.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the unordered list, we have a `tabs` container that will contain all our
    `Tab` components that are inserted using content projection and the `<ng-content>`
    element. Note that the selector that we use is actually the selector we use for
    our `Tab` component.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tabs that are not active will not be visible because we control this using CSS
    on our `Tab` component class attribute binding (refer to the `Tab` component code).
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is all that we need to create a flexible and well-encapsulated tabbed interface
    component. Now we can go ahead and use this component in our `Project` component
    to provide a segregation of our project detail information.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: We will create three tabs for now, where the first one will embed our task list.
    We will address the content of the other two tabs in a later chapter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Let's modify our `Project` component template in the `project.html` file as
    a first step.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of including our `TaskList` component directly, we now use the `Tabs`
    and `Tab` components to nest the task list into our tabbed interface:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should have noticed by now that we are actually nesting two components
    within this template code using content projection, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: First, the `Tabs` component uses content projection to select all the `<ngc-tab>`
    elements. As these elements happen to be components too (our `Tab` component will
    attach to elements with this name), they will be recognized as such within the
    `Tabs` component once they are inserted.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `<ngc-tab>` element, we then nest our `TaskList` component. If we go
    back to our `Task` component template, which will be attached to elements with
    the name `ngc-tab`, we will have a generic projection point that inserts any content
    that is present in the host element. Our task list will effectively be passed
    through the `Tabs` component into the `Tab` component.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recap
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this topic, we created a very handy tabbed interface component that we can
    use to segregate our user interface and provide a focused context for our users.
    We used content projection points using the `<ng-content>` elements. We also learned
    how to access inserted components using the `@ContentChildren` annotation and
    observable lists using the `QueryList` type.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Mixing projected with generated content
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our task management application supports the listing of multiple projects where
    a user can manage tasks. We need to provide a navigation that enables a user to
    browse through the existing projects. As projects come from our data store, the
    navigation will need to be generated dynamically. However, we also would like
    to have the possibility of specifying some navigation items within our navigation,
    as static content with pure templating.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will create a simple navigation component, which will use
    content projection, so that we can add static navigation items. At the same time,
    navigation items can be generated from data and mixed with the static content-based
    navigation items.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first take a look at an illustration of the architectural design and
    composition that we''re going to use to implement our navigation:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![Mixing projected with generated content](img/image00314.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: An illustration of the navigation component tree and interactions
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: We'll use an intermediate component between the `Navigation` and `NavigationItem`
    components. The `NavigationSection` component is responsible for the division
    of multiple items into a section. The navigation sections also have a title that
    will be displayed on top of the item list.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: The illustration shows two `NavigationSection` components, where the left one
    uses pure content projection to create items, as we have learned in the previous
    section. The right `NavigationSection` component generates items using an input
    data structure, which is a list of navigation item models.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: As we have intermediate components between the `Navigation` and `NavigationItems`
    components (we can only have one selected navigation), we also establish a direct
    communication path between them. We will achieve this using ancestor component
    injection.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The architectural approach for this navigation is just one of many possible
    approaches. We choose this approach in order to show you how we can easily mix
    content projection and generated content. In this example, we don't use the Angular
    router to provide navigation state and route mapping. This will be part of a later
    chapter.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start bottom up with the `NavigationItem` component and create a new
    `navigation-item.js` file in a newly-created `navigation/navigation-section/navigation-item`
    path:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: From the `NavigationItem` component code, we can see that we're directly communicating
    with the `Navigation` ancestor component. We can simply inject the `NavigationComponent`,
    as this is a child of the component. As the `Navigation` items will never exist
    without a `Navigation` component, we should be fine with this direct dependency.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the `NavigationSection` component that is the intermediate
    component between the `Navigation` component and the items and is responsible
    for the grouping of items together.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a file called `navigation-section.js` in the `navigation/navigation-section`
    path:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Hold on! That's all that this needs? Didn't we say that we want our `NavigationSection`
    component to also be responsible for not only providing a way to insert content,
    but also accepting data in order to generate items? Well, this is true. However,
    this is actually pure templating logic, and it can be done solely within the template
    file of the component. All that we need is an optional input with item data that
    we will use to generate the `NavigationItem` components.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the view template for this component in a file named `navigation-section.html`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Well, this wasn''t rocket science, was it? However, this shows the great flexibility
    that we have in Angular component templates:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we create a content projection point that selects all the elements
    from the host element that match the name `ngc-navigation-item`. This means that
    the `NavigationItem` components can be placed outside the component in a very
    static fashion to create, for example, static links. As the model properties of
    navigation items are directly exposed as bindable attributes on the `NavigationItem`
    element, we can also place them statically into a pure HTML template with regular
    DOM attributes.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, we can use the `NgFor` directive to generate the `NavigationItem`
    components inside the component. Here, we just iterate over the list of navigation
    item models that acts as an optional input to our component. We use bindings in
    the items model so that we can even propagate change into our navigation item
    components.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a final step, we create the `Navigation` component itself that uses content
    projection points so that we can manage the `NavigationSection` component from
    outside. We create a file called `navigation.js` to write the code of the `Navigation`
    component:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the `Navigation` component, we store the state of which navigation item is
    activated. This is also provided as input to the component so that we can set
    the activated link with an input binding from outside. The `isItemActive` and
    `activateLink` functions are there to monitor and change the state of the active
    item within the navigation. These functions are directly used within the `NavigationItem`
    components, which inject the navigation using ancestor component injection.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the only bit that is missing is to include our navigation in the main
    application. For this, we will edit the `app.html` template of the component:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, we only use the generative approach to write a `NavigationSection` component
    where we actually pass a list of navigation item models into the navigation component.
    This list is generated by the `getProjectNavigationItems` function on our main
    application component using the available projects from our observable data structure:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![Mixing projected with generated content](img/image00315.jpeg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: A screenshot of the newly-created project navigation
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about how we can profit from concepts, such as reactive
    programming, observable data structures, and immutable objects, in order to make
    our application perform better, and most importantly, simple and easy to reason
    about.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: We touched on the different change-detection strategies and learned how to use
    the `OnPush` strategy to gain better performance in combination with immutable
    data.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: We built a tabbed user interface component that we can reuse wherever we need
    it, and we learned about the concept of content projection. We also created a
    simple navigation component tree that uses a mix of content projection and generation.
    The navigation items also directly communicate with their ancestor `Navigation`
    component, in order to manage their state using ancestor component injection.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: As we switched to a reactive approach to manage data within our application,
    I want you to perform a little experiment. If you've downloaded the final chapter's
    code, go ahead and open two browser windows that point to the task management
    application. You will be amazed that we already have a working real-time synchronization
    in place that allows us to work in both browser windows and have both of them
    updated at the same time. This has all been made possible because of the reactive
    and functional way that we work with data in our components.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们转向在应用程序内以响应式方法管理数据，我想让你进行一个小实验。如果你已经下载了最后一章的代码，请打开两个指向任务管理应用的浏览器窗口。你会惊讶地发现，我们已经在实时同步方面实现了工作，这使得我们可以在两个浏览器窗口中工作，并且同时更新它们。这一切都得益于我们在组件中处理数据时所采用的响应式和函数式方式。
