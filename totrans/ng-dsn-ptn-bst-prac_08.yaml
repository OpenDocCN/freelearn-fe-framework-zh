- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Improving Backend Integrations: the Interceptor Pattern'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a `Service`. However, many side tasks are common to all communications with
    the backend, such as header processing, authentication, and loading.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: We could do this sides task on a service-by-service basis, but in addition to
    being an unproductive activity, the team might not be able to implement some control
    on the request due to the carelessness or ignorance of a new member of the team.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to simplify the development of side tasks for communicating with the
    backend, the Angular framework implements the interceptor design pattern, which
    we will explore in this chapter. Here, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Attaching the token to the request with an interceptor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the request route
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a loader
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notifying success
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring the performance of a request
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to create interceptors capable
    of implicitly performing tasks necessary for your backend communication.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the instructions in this chapter, you’ll need the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js 18 or higher ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for this chapter are available at [https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch8](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch8).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: While following this chapter, remember to run the backend of the application
    found in the `gym-diary-backend` folder with the `npm` `start` command.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Attaching the token to the request with an interceptor
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, our backend doesn’t have any kind of authentication control, which
    doesn’t happen (or at least it shouldn’t happen) in the real world. The backend
    was modified to perform authentication, but this was reflected in the frontend
    because, if we tried to log in, the following error would occur:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This error means that our request was rejected by the server because it was
    not authorized. That’s because our server implements a very common form of security
    that consists of asking for an authorization token in every request.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: This token is created when the user logs in to the application and it must be
    passed in the header of the HTTP request.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll fix this problem first by making a change to the `AuthService` service:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First, we change the access mode of the `token` attribute. We are using the
    `#` symbol, which is the way to declare a `private` attribute in standard JavaScript.
    We want the token to be read by the other `component` but never overwritten, and
    using the token ensures that this happens even if the consumer class forces manipulation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: We change the class to the new attribute name and, at the end, we create the
    `token()` accessor method to return the token stored by the service.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll refactor the `ExerciseSetsService` service to send the token in the request
    that returns the diary items:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we create a header using the accessory class of Angular, `HttpHeaders`,
    passing the token in the `Authorization` attribute. Then, we pass this header
    in the `get` method of Angular’s `HttpClient` service.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run our application again, it works again (`mario`, and `1234`):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Gym diary home page](img/B19562_08_1.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Gym diary home page
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: This approach has a problem, as we would need to replicate this operation for
    all of the service’s methods, and as our application grows, we would need to remember
    to do this token handling.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: A good software architecture should think about new team members with different
    backgrounds and even the creation of new teams as the project grows. Therefore,
    this type of transversal requirement of our system must be treated in a more intelligent
    way.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Enter **Angular Interceptor**, which is a service of a specific type to handle
    the HTTP request flow. This component is based on the design pattern of the same
    name, which aims to change a processing cycle.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s illustrate this pattern with the following diagram:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19562_08_2.jpg)![Figure 8.2 – Interceptor design pattern](img/B19562_08_3.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Interceptor design pattern
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: In this diagram, we have the Angular application that makes an HTTP request
    to the backend; in the interceptor pattern, we have an Angular service in the
    middle of the request that can change both the request and the return from the
    backend.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'We will refactor our previous solution to see this pattern in practice. We’ll
    clean up the `ExerciseSetsService` service by removing the handling from the `Authorization`
    header:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To create the interceptor, we are going to use the Angular CLI for Angular
    to create the entire boilerplate of the service:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With the `AuthInterceptor` service created, let’s create our logic to attach
    the `Authorization` header:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first thing we can notice is that the interceptor is a common Angular service,
    so it has the `@Injectable` notation; for more details about Angular services,
    see [*Chapter 5*](B19562_05.xhtml#_idTextAnchor163)*,* *Angular Services and the*
    *Singleton Pattern*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: This service implements the `HttpInterceptor` interface, which requires the
    class to have the `inject` method. This method receives the request we want to
    handle and expects an observable as a return. This signature indicates the characteristic
    of the interceptor because this class is always in the middle of a flow between
    the component making the request and the backend.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the service receives information from the flow and must return the
    flow represented by the observable. In our case, we use the `AuthService` service
    to get the token. The service cannot attach the token to the login endpoint because
    that is where we will get the token, so we make an `if` statement by analyzing
    which URL the request is using.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: If we have a token, we clone the request, but this time, we inform the header
    with the token. The reason we need to use the `clone` method to get a new object
    is that the request object is immutable – that is, it is not possible to change
    it; we need to create a new one, identical to the old one, but this time, we put
    the header.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有令牌，我们克隆请求，但这次，我们使用令牌来设置头信息。我们需要使用`clone`方法来获取新对象的原因是请求对象是不可变的——也就是说，它不能被更改；我们需要创建一个新的，与旧的完全相同，但这次，我们添加了头信息。
- en: 'Finally, the flow is returned but, this time, with the new request object.
    To configure the interceptor, we need to change the `AppModule` module:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，流程被返回，但这次，带有新的请求对象。为了配置拦截器，我们需要更改`AppModule`模块：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We’re including the `AuthInterceptor` service in the `HTTP_INTERCEPTORS` token.
    This tells the framework to call the service whenever a component uses Angular’s
    `HttpClient` service. The `multi` attribute informs the framework that we can
    have more than one interceptor because, by default, Angular adds only one.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`AuthInterceptor`服务包含在`HTTP_INTERCEPTORS`令牌中。这告诉框架每当组件使用Angular的`HttpClient`服务时调用该服务。`multi`属性通知框架我们可以有多个拦截器，因为默认情况下，Angular只添加一个。
- en: Running the application again, we can see that it is working now with the addition
    that all the resources are attaching the header, but implicitly, without the need
    to change each `HttpClient` call.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行应用程序，我们可以看到它现在正在工作，新增的是所有资源都在附加头信息，但隐式地，不需要更改每个`HttpClient`调用。
- en: Let’s explore this feature further with a very common task in our project, which
    is URL routing in the API call.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探讨这个功能，通过我们项目中的一个非常常见的任务，即在API调用中的URL路由。
- en: Changing the request route
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改请求路由
- en: In our project so far, we have two services that make requests to the backend.
    If we analyze them, we see that they both point directly to the backend URL. This
    is not a good practice since, as the project scales and grows in complexity, errors
    can occur by pointing to the wrong URL. In addition to the need to change the
    host, we will need to change numerous files.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们到目前为止的项目中，我们有两个服务会向后端发送请求。如果我们分析它们，我们会看到它们都直接指向后端URL。这不是一个好的做法，因为随着项目的规模和复杂性的增长，指向错误的URL可能会导致错误。除了需要更改主机之外，我们还需要更改许多文件。
- en: 'There are a few ways to handle this problem, but a very useful tool for this
    is the Angular interceptor. Let’s see it in practice starting with the Angular
    CLI, where we are going to create the new interceptor:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题的方法有很多，但在这个问题中一个非常有用的工具是Angular拦截器。让我们从Angular CLI开始，我们将创建新的拦截器：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With the generated file, let’s create the `intercept` function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生成的文件，让我们创建`intercept`函数：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this function, we have the URL of the backend and, in the `resource` variable,
    we receive the original URL of the request that we want to intercept and modify.
    We use an `if` statement next because we want to avoid errors in case some service
    needs to call another API directly.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们有后端的URL，在`resource`变量中，我们接收我们想要拦截和修改的原始请求URL。我们使用`if`语句是因为我们想要避免错误，以防某些服务需要直接调用另一个API。
- en: 'Finally, we create a new request object (this time, with the URL changed) and
    we pass this new object to the request flow. For this interceptor to be triggered
    by Angular, we need to add it to the `providers` array of the `AppModule` module:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个新的请求对象（这次，URL已更改）并将这个新对象传递给请求流程。为了让这个拦截器被Angular触发，我们需要将其添加到`AppModule`模块的`providers`数组中：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will refactor our service to only care about the features they need, starting
    with the `ExerciseSetsService` service:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重构我们的服务，使其只关注它们需要的特性，从`ExerciseSetsService`服务开始：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We follow this with the `Authentication` service:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`Authentication`服务：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can see that if we needed new services or changed the URL, the HTTP requests
    would not need to be refactored, as we created an interceptor to work on that.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，如果我们需要新的服务或更改URL，HTTP请求就不需要重构，因为我们创建了一个拦截器来处理这个问题。
- en: Next, we’ll learn how to give our users a better experience if a request takes
    too long.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何让用户在请求耗时过长时获得更好的体验。
- en: Creating a loader
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个加载器
- en: In a frontend project, performance is not only about having faster requests
    but also improving the user’s perception of the application. A blank screen without
    any feedback signals to the user that the page did not load, that their internet
    is having a problem, or any other type of negative perception.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s why we always need to signal that the action the user expects is being
    performed. One way to show this is a loading indicator, and that’s what we’re
    going to do in this session. In the command line of our operating system, we will
    use the Angular CLI:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With that, we created the `overlay` component, the service that will control
    the loading state, and the interceptor that will control the beginning and end
    of the loading based on HTTP requests.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the loading overlay screen in the HTML template of the `LoadingOverlayComponent`
    component:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will implement the `LoadService` service, which will maintain and control
    the loading state:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We create two methods to turn the loading state on and off and a property to
    expose this state.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'In the load interceptor, we will implement the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `intercept` method starts by turning on the loading state and returning
    requests without modifying anything in them.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: However, in the flow of the request, we placed the `finalize` operator from
    RxJs, which has the characteristic of executing a function when an observable
    arrives in the complete state – here, turning off the loading state. For more
    details about RxJS, read [*Chapter 9*](B19562_09.xhtml#_idTextAnchor242), *Exploring
    Reactivity* *with RxJS*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate the interceptor, we will add it to `AppModule`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We want the overlay to be executed in the application as a whole, so we will
    include the `overlay` component in the `AppComponent` component:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We just need to inject the `LoadService` service because that’s where we’ll
    have the loading state.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s place the `overlay` component in the HTML template:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Running our application, as we are running it with a backend on our machine,
    we may not notice the loading screen. However, for these cases, we can use a Chrome
    feature that simulates a slow 3G network.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Open **Chrome DevTools** and, in the **Network** tab, use the throttling option,
    as shown in the following figure:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Simulation of a slow 3G network to notice the loading screen](img/B19562_08_4.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Simulation of a slow 3G network to notice the loading screen
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to notify the success of a backend request
    to the user.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Notifying success
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the loading screen to inform the user that the system is looking
    for the information they want, it is important to notify the user after processing
    an item. We can handle this notification directly from the service or component,
    but we can also implement it generically and implicitly using interceptors.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'We will refactor our application to add this treatment. But first, let’s install
    a library to show the `toaster` component on the screen with an animation. In
    the command line of our operating system, we will use the following command in
    the `main` folder of our frontend project:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In order for the package to work, we need to add our CSS to our project by
    editing the `angular.json` file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For the toaster animations to work, we need to change the `AppModule` module:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the `main` module of our application, we are adding the `ToastrModule` module
    from the library and changing `BrowserModule` to `BrowserAnimationsModule`, which
    adds Angular animation services used by the library.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'With the new package configured, we can proceed with creating the new interceptor
    using the Angular CLI:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With the interceptor created, we will change the file with the treatment for
    the notification:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As in the *Creating a loader* section, we are using the fact that the request
    is treated as a flow to use RxJS and its observables to verify the request’s characteristics.
    We are using the `tap` operator, which aims to perform side effects on the request
    without changing it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: This operator will execute an anonymous function that will check the HTTP event,
    which brings us to an interesting point. As we are interested in the return of
    the request, we only select the event of type `HttpResponse` and the event code
    is `201-Created`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: When we develop an interceptor, we have to remember that it is called in the
    request and the response, so it is important to use conditionals to execute what
    we need when we need it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'The last point we need to configure is the main `AppModule` module:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Running our project and creating an entry, we notice that the toast appears
    on the screen with the configured message.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Success notification](img/B19562_08_5.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Success notification
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Another use for interceptors is to instrument our application to measure performance
    and stability, which we’ll learn about in the next section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Measuring the performance of a request
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a development team, we must always seek to offer the best experience for
    our users, and, in addition to developing quality products, we must allow the
    application to be monitored to maintain quality during production.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: There are several tools available on the market, and many of them need some
    level of instrumentation to accurately measure the user experience. We will develop
    a simpler telemetry example, but it can be applied to the monitoring tool your
    team uses.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the Angular CLI, we will create a new interceptor:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the file generated by the Angular CLI, we will develop our interceptor:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To illustrate the ability to customize an interceptor, we agree that telemetry
    will only be used if the request made has a custom header called `X-TELEMETRY`,
    and right at the beginning of the function, we do this verification.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: As we did in the loader example, we used the `finalize` operator to measure
    the performance of the request in a simplified way and presented it in `console.log`.
    You could put your telemetry provider call or even your custom backend here.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在加载器示例中做的那样，我们使用了`finalize`运算符以简化的方式测量请求的性能，并在`console.log`中展示。你可以在这里放置你的遥测提供者调用，甚至你的自定义后端。
- en: 'To exemplify, we use `console.log` to show the information. As in the other
    sections, we need to configure the interceptor in the main `AppModule` module:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，我们使用`console.log`来展示信息。就像在其他部分一样，我们需要在主`AppModule`模块中配置拦截器：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, in the `ExerciseSetsService` service, we will send the customized
    header to carry out the telemetry of this request only:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`ExerciseSetsService`服务中，我们将发送定制的头以执行此请求的遥测：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Header passing is a way to configure an interceptor to behave differently depending
    on the situation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 头部传递是配置拦截器以根据不同情况表现不同的方式。
- en: 'Running our project, we can see the messages in the browser log:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的项目，我们可以在浏览器日志中看到消息：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With this development, HTTP requests with the configured header will be logged
    in `console.log`. You can replace this interceptor with an integration to a telemetry
    service, improving the monitoring of your application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这次开发，配置了头的HTTP请求将在`console.log`中记录。你可以用集成到遥测服务的拦截器替换这个拦截器，从而提高你应用程序的监控能力。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the interceptor feature in Angular and the possibilities
    that this feature can give our team. We learned how to attach the authentication
    token to the requests without having to change all the services in our project.
    We also worked on changing the URL of the request, making our project more flexible
    to its execution environment.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Angular中的拦截器功能以及这个功能可以为我们的团队带来的可能性。我们学习了如何在不改变我们项目中所有服务的情况下将身份验证令牌附加到请求中。我们还致力于更改请求的URL，使我们的项目对执行环境更加灵活。
- en: We also improved our users’ experience by creating a loader in case their internet
    is slow and notifying them on the screen when a new entry is registered in their
    gym diary. Finally, we created a simple example of telemetry using a custom header
    to give the team the ability to select which requests are telemetry capable.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过创建一个加载器来改善用户的体验，以防他们的网络速度慢，并在他们的健身房日记中注册新条目时在屏幕上通知他们。最后，我们使用自定义头创建了一个简单的遥测示例，以便团队能够选择哪些请求具有遥测能力。
- en: In the next chapter, we’ll explore RxJS, the most powerful library in the Angular
    utility belt.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索RxJS，这是Angular工具包中最强大的库。
