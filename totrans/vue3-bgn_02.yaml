- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Foundation of Vue.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are reading this book, chances are that you have decided to use Vue.js
    as your framework of choice and there is very little reason to try to convince
    you not to use it. We are going to use this chapter to begin sharing details of
    what makes Vue.js unique and why it has become so successful.
  prefs: []
  type: TYPE_NORMAL
- en: We are first going to learn what makes Vue.js different from other frameworks;
    we will then move on to study Vue.js’ reactivity and its lifecycles. Finally,
    we will learn about the component structure of Vue.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Vue.js’ reactivity fundamentals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Vue.js lifecycle and hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vue.js’ component structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal of this chapter is to provide you with information regarding Vue.js
    that will become the foundation of your future learning. Understanding Vue.js’
    reactivity will help differentiate Vue.js from other frontend frameworks and libraries,
    and you will learn the complete lifecycle of a Vue.js component to help you make
    the correct technical decisions. Finally, understanding the different ways to
    define a Vue.js component will prepare you for the chapters to come.
  prefs: []
  type: TYPE_NORMAL
- en: Vue.js reactivity fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vue.js has been around for some time; the framework’s first release dates back
    to 2014, when its creator, Evan You, a former Google developer, informed the world
    of its creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Evan’s previous experience with Angular at Google gave him the knowledge necessary
    to build a great framework. In an interview for *Between the Wires* shortly after
    making the framework public, Evan said the following:'
  prefs: []
  type: TYPE_NORMAL
- en: I figured, what if I could just extract the part that I really liked about Angular
    and build something really lightweight.
  prefs: []
  type: TYPE_NORMAL
- en: Evan did not just create a lightweight framework, but he also managed to build
    an amazing community around it, making it one of the most loved frameworks by
    developers.
  prefs: []
  type: TYPE_NORMAL
- en: Vue.js has had just three major releases until now, with the latest one being
    a full rewrite that made Vue.js faster, smaller, and even easier to use.
  prefs: []
  type: TYPE_NORMAL
- en: Two main aspects made Vue.js so successful. The first is that its growth and
    adoption are driven by the community for the community. Vue.js is one of the few
    major frameworks not to be backed by a big company. It is fully funded by people’s
    donations to the core team and its development is mainly driven by the community.
    This is shown by the focus on the development experience that is always present
    within the Vue.js ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: The second aspect that makes it unique is its reactivity system. The Vue.js
    core engine has been built to be reactive behind the scenes, making handling states
    with Vue.js simple and intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we talk about reactivity in development, we refer to the ability of certain
    variables to automatically update when a change occurs. A simple example of reactivity
    outside of the developing world is offered by Excel and Google Sheets. Setting
    up a calculation, such as a sum of a column, will result in the total number being
    “reactive” to any chance that happens in the summed cells:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: Google Sheet example showing how the value of cells updates automatically](img/B21130_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Google Sheet example showing how the value of cells updates automatically'
  prefs: []
  type: TYPE_NORMAL
- en: Like Excel, reactivity in web development, particularly in Vue.js, allows your
    variables to be dynamic and automatically change when a value it depends on changes.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see a real example to understand how reactivity plays a big part in the
    UI framework. Let’s start by seeing the behavior of vanilla JS and then see how
    this translates into Vue.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we are going to create two variables, `firstName` and
    `lastName`, and then we will try to create a reactive variable called `fullName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippets, the full name that is printed in the console
    is equal to the `firstName` and `secondName` variables that we have created. What
    would happen if we now change the `firstName` variable to a different value? What
    would the value of `fullName` be?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code, the variable that is supposed to print
    the full name has output the incorrect value, as it has not “reacted” to the change
    in the `firstName` variable.
  prefs: []
  type: TYPE_NORMAL
- en: This is perfectly normal behavior; you do not want all variables to automatically
    react in JavaScript, as this will complicate its usage, but when it comes to the
    UI, having values that are updated is the expected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Say, for example, you are filling up a basket and you want the total number
    of items to change if you add one more item to your basket, or you would like
    the word count to update if you type in a limited textbox, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s replicate the preceding example using Vue.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: At this stage, your understanding of Vue.js is still limited to what experience
    you had before reading this book, so you are not expected to understand the preceding
    code yet. What we need to focus our attention on is the output that the code produces
    when compared to the one produced by plain JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: As the preceding code shows, the `fullName` variable changes automatically as
    soon as any of its dependent variables (`firstName` and `secondName`) change.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how the reactivity system works behind the scenes is out of the
    scope of this book, but this does not prevent us from understanding the technicalities
    that take place behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows what happens behind the scenes and how the reactivity
    actually takes place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2: Diagram explaining the Vue.js reactivity system](img/B21130_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Diagram explaining the Vue.js reactivity system'
  prefs: []
  type: TYPE_NORMAL
- en: 'This illustration is a simplified version of what happens within the Vue.js
    reactivity core system to make our variables dynamic. Let’s break down what is
    happening:'
  prefs: []
  type: TYPE_NORMAL
- en: We defined reactive variables, such as `FirstName`. Vue.js watches this variable
    for any change event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We declared a complex variable that is dependent on other reactive variables
    (e.g., `fullName`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Vue.js tracks a dependency tree. It creates a list of what depends on what.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a change takes place in a reactive variable, the reactivity engine will
    trigger `onDependenciesChange`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Vue.js evaluates which values depend on the value that was just changed and
    triggers an update *only* if the value is part of their dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While reading the preceding process, you probably thought that it sounded quite
    familiar, and you would be correct, as the reactivity system follows the same
    principles offered by HTML elements such as input fields. Elements such as `<input>`,
    `<select>`, and many more have the ability to hold values and react when they
    are changed by triggering an `onChange` or similar event.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding example, listening to a change event to handle data
    reactivity is not something unique. So, what makes the Vue.js reactivity system
    special? Vue.js reactivity stands out for the way it handles the dependencies
    tree and automatically updates variables behind the scenes. The reactivity system
    of Vue.js is non-obstructive and it is completely unseen by developers. Vue.js
    manages all the dependencies behind the scenes as part of its **lifecycles** and
    acts upon changes with speed and high performance.
  prefs: []
  type: TYPE_NORMAL
- en: This section introduced you to the Vue.js reactivity system, explaining how
    it plays a vital role in the success of the framework. We then explained, with
    the help of some examples, how the engine works behind the scenes. It is now time
    to understand how the Vue.js core engine works by taking a closer look at its
    lifecycles and understanding how they can be used within our application development.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Vue.js lifecycle and hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we progress into the book, our knowledge of Vue.js continues to expand. In
    this section, we are going to discuss the Vue.js lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: When we use Vue.js, the application goes through a defined list of steps, from
    creating the component HTML to gathering all the dynamic values, as well as displaying
    these values in the DOM. Each of these is part of what we call the **lifecycle**,
    and in this section, we are going to define them all and learn when and how to
    use them during the course of our development careers.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have ever tried to learn Vue.js in the past, you have probably already
    been exposed to the following diagram, which is available in the main Vue.js documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3: Vue.js lifecycle diagram (from www.vuejs.org)](img/B21130_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Vue.js lifecycle diagram (from www.vuejs.org)'
  prefs: []
  type: TYPE_NORMAL
- en: No matter how long you have been using Vue.js, the preceding diagram will repeatedly
    appear in your browser history, and it will slowly be imprinted in your memory,
    as it is the foundation of Vue.js and a must-know in order to write clean and
    performant code.
  prefs: []
  type: TYPE_NORMAL
- en: As you progress in the course of this book, you will be asked to revisit different
    parts of the lifecycle, and you will be asked to revisit the diagram.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to review the diagram step by step and understand
    what it means and how this knowledge can be applied during development.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to start explaining it from the top down, but we will be starting
    with **beforeCreate**. We are purposely leaving **setup** for later, as it is
    easier to understand after all the lifecycles have been introduced, even if it
    is the first part of the list.
  prefs: []
  type: TYPE_NORMAL
- en: The following lifecycles are progressive; this means that the end state of one
    of them is the beginning of the next.
  prefs: []
  type: TYPE_NORMAL
- en: beforeCreate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This lifecycle is created as soon as a component is initialized. At this stage,
    our component does not exist at all. The Vue.js framework has just been instructed
    to create it and it is triggering this hook to inform us that the component is
    on its way.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, nothing of the component is available, no HTML is being created,
    and no internal variables are set yet.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, this lifecycle is used to trigger analytics logs or long async tasks.
  prefs: []
  type: TYPE_NORMAL
- en: created
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this stage, Vue.js knows about your component, and it has loaded its JavaScript
    logic, but it has not yet rendered or mounted any HTML.
  prefs: []
  type: TYPE_NORMAL
- en: This is the perfect stage to trigger async calls to gather some data. Triggering
    a slow request now will help us save some time, as this request will continue
    behind the scenes while our component is being rendered.
  prefs: []
  type: TYPE_NORMAL
- en: beforeMount
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This lifecycle is triggered right before the HTML is appended to the DOM. There
    are very limited use cases for this lifecycle, as most of the pre-render actions
    are triggered within the **created** lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: mounted
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this stage, the component has been fully rendered, and its HTML has been
    attached to the DOM. If you need to complete any operation that requires you to
    access the DOM, this is the correct lifecycle, as the HTML is ready to be read
    and modified.
  prefs: []
  type: TYPE_NORMAL
- en: If you come from a non-framework background, you may think that most of the
    logic of your component will probably be included in this lifecycle, but you will
    quickly learn that due to the way Vue.js components are specified, you will rarely
    need access to the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: beforeUpdate and update
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**beforeUpdate** and **update** form a recursive circle that happens any time
    the component data or dependencies change. We already introduced this step in
    the previous section when we spoke about the reactivity system.'
  prefs: []
  type: TYPE_NORMAL
- en: '**beforeUpdate** is triggered as soon as Vue.js realizes that a reactive value
    on which the component depends has changed.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, **update** is triggered when the value has been fully changed,
    and its value has been assigned to the correct DOM node and is ready in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: You will very rarely have to use these two lifecycles directly, as Vue.js provides
    other features, such as computed properties and watchers, to be able to handle
    individual changes within the component data.
  prefs: []
  type: TYPE_NORMAL
- en: beforeUnmount and unmount
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this stage, our component is no longer needed, and Vue.js is ready to remove
    it from the DOM. This could be due to the user navigating to a different page
    or any other event that would require the component to be removed from the UI.
  prefs: []
  type: TYPE_NORMAL
- en: There is very little difference in usage between **beforeUnmount** and **unmount**.
    This lifecycle is very useful for unsubscribing to events, such as “click” and
    “observers,” that will result in a drop in performance if left active.
  prefs: []
  type: TYPE_NORMAL
- en: setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As promised at the start of this section, we left **setup** for last, as it
    is easier to explain it after all lifecycles were covered. **setup** is not a
    lifecycle in itself, but it is the entry point used by the CompositionAPI (something
    that you will learn about a bit later in this chapter). When using **setup**,
    you have the ability to call and access all the lifecycles (**mounted**, **updated**,
    **unmounted**, and so on). You can think of **setup** as a wrapper for the Vue.js
    lifecycle, a single method that includes all lifecycle hooks. Composition API
    is going to be what we use in this book, and we are going to explain the **setup**
    function in much more detail at a later stage.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned the basic flow of Vue.js, introducing all its
    lifecycles. At this stage, we should know when Vue.js component is rendered, updated,
    or destroyed. This knowledge will drive our development and allow us to make the
    correct choices to make our application performant. In the next section, we are
    going to see how to introduce Vue.js component syntax, and we will also learn
    how to make use of the preceding lifecycles.
  prefs: []
  type: TYPE_NORMAL
- en: Vue.js component structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components are the basis of the Vue.js framework. They are the building blocks
    required to create an application using this framework. As was previously explained,
    a component can be as small as a simple button or as large as a full page.
  prefs: []
  type: TYPE_NORMAL
- en: No matter their size, all components are built using the same syntax and structure.
    In this section, we are going to learn the different forms of syntax available
    to write components and learn about the different sections that make up a Vue.js
    **single-file** **component** (**SFC**).
  prefs: []
  type: TYPE_NORMAL
- en: Single-file components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SFCs are specific to Vue.js and can be found in Vue.js projects with the extension
    `.vue`. These files are composed of three main sections: **template**, **script**,
    and **style**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The Vue.js compiler takes the preceding three sections and splits them up into
    individual chunks during build time. We are now going to explain each of them
    in this section. We will cover the SFC section in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Template
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Style
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Script
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The <template> tag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first section is `<template>`. This section includes the HTML hosted by
    our component. So, if we take an example of an extremely simple button, the template
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In contrast to React, the HTML of a Vue.js component is plain **HTML** and not
    **JSX**. As we will learn in the course of the book, Vue.js provides some handy
    tools to simplify the content of our HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: As for template writing styles, it is possible to write your HTML with different
    methods, such as render functions, or by writing it in JSX (with the correct loader),
    but these two methods are for specific uses and are not expected within the Vue.js
    ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: The <style> tag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next section available is `<style>`. This section will include the styles
    associated with our component using plain `<style>` tag in a component does not
    *scope* the style to that specific component.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, let’s explain what it actually means for styles to be scoped
    and how to achieve this in our Vue.js application.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use a simple `<style>` tag, as shown in the preceding example, our
    style will leak to the rest of the application. Anything we declare in the tag
    will be global unless we scope it with CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Writing the preceding style in Vue.js is permitted and is even suggested for
    performance and maintainability reasons. The problem is that the preceding declaration
    will change the color of our paragraph to red in the whole application and not
    just in the component in which it has been written.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily for us, Vue.js has a handy tool to use in the case where we would like
    our component to be fully scoped, making sure that no style bleeds and breaks
    the rest of the app. To do so, we need to add an attribute called `scoped` to
    our `<``style>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With this new attribute, our styles will be locked to the component in which
    they are defined, and they will not affect the rest of the application. We are
    going to learn more about when it is best to use these two methods when building
    our Companion App.
  prefs: []
  type: TYPE_NORMAL
- en: The <script> tag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next section available within an SFC is the `<script>` tag. This tag will
    include the component JavaScript logic, from the properties that are accepted
    for the component to the private data used to define the component logic, all
    the way to the actual methods needed for the component to function properly.
  prefs: []
  type: TYPE_NORMAL
- en: Just a few years ago, when Vue.js’ major version was still 2, components were
    mostly defined using a syntax called **Options API**. Even though other methodologies
    were available, this was the main way to write a Vue.js component.
  prefs: []
  type: TYPE_NORMAL
- en: With the release of Vue.js 3, a new method of writing components was created.
    This is offered alongside the existing Options API, and it offers better TypeScript
    support, improved techniques to reuse logic, and flexible code organization. This
    method is called **Composition API**.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Composition API is also referred to as **Script Setup**.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this moment in time, neither of the two methods is officially preferred
    over the other; this is also emphasized by the Vue.js official documentation,
    which currently showcases all its tutorials and examples using both methodologies,
    offering the option to switch between the methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4: Vue.js official documentation for API preference switch](img/B21130_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Vue.js official documentation for API preference switch'
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of this book and its Companion App are going to be written using
    Composition API. This decision was made for two main reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Due to Vue.js 2’s history, the web is full of resources that focus on Options
    API but less so on the new Composition API syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evan You (the creator of Vue.js) has predicted (more than once) that, in the
    long run, Composition API will take over and become the standard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because I am a strong believer that extra knowledge does no harm, in this section,
    we are going to learn how to define the component in both syntaxes, including
    Options API. Knowing both methods can help you build a strong foundation to support
    your learning of the Vue.js framework.
  prefs: []
  type: TYPE_NORMAL
- en: Options API versus Composition API – Two sides of the same coin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Under the hood, both methods are actually going to produce a very similar output,
    with Composition API producing slightly more performant code. Nevertheless, the
    syntax differences and benefits that these methods bring are quite different and
    can make a big change depending on your habits.
  prefs: []
  type: TYPE_NORMAL
- en: The first and main difference between Composition API and Options API is in
    the way the `<script>` section of your code is broken down. As I mentioned before,
    both syntaxes will offer the same features, so this means that we can declare
    props data, compute, and methods, as well as access all the lifecycles in both
    methods, but the way we do so differs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The differences are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Composition API**: Code broken down by functionality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Options API**: Code broken down by Vue.js options'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at an example to clearly define the difference between both methods.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5: Comparison between Composition API and Options API for breaking
    down code](img/B21130_02_05_v2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: Comparison between Composition API and Options API for breaking
    down code'
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the preceding diagram, in Options API, the code does not take into
    consideration the actual component requirements and logic, but it is sliced vertically
    using Vue.js options: **Props**, **Data**, **Methods**, **Computed**, **mounted**,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, Composition API takes a different approach by breaking down
    the component by its technical output. This allows us to create a section for
    Feature 1, a section for Feature 2, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The second difference is associated with TypeScript support. This is the main
    reason that led the Vue.js core team to decide to create The Composition API during
    the Vue.js 3 rewrite. Options API offers very basic TypeScript support, and this
    has prevented many developers from joining the Vue.js ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: We have reached the end of this section, and it is time to clearly say which
    method is better, but, unfortunately, the answer is that it depends.
  prefs: []
  type: TYPE_NORMAL
- en: Because both syntactic sugars compile in the same code, the decision really
    goes back to coding preferences. Options API provides more structure, and it can,
    therefore, be more helpful at the start of your career when your experience in
    creating a component is still limited, while Composition API, with the added TypeScript
    support and greater flexibility in code partitioning, can be a very strong tool
    to improve code readability in big applications.
  prefs: []
  type: TYPE_NORMAL
- en: Sample components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this stage, we have learned enough about the foundations of Vue.js to be
    ready to introduce some sample components and see the framework in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to look at an example of an Atom. In our case, it is a simple
    icon component. This sample component is going to exhibit the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: It is going to accept a couple of properties (`size` and `name`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is going to include some style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is going to dynamically load the icon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The component will be called using the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As previously mentioned, in this section, I am going to show the components
    utilizing both writing methods; however, later in the book, we will just write
    components using Script Setup (Composition API).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Please note that we will cover all of this again in more detail later in the
    book. This is just a quick introduction to Vue.js components.
  prefs: []
  type: TYPE_NORMAL
- en: An Atom component using Options API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s first see how this component looks as a Vue.js component using Options
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s break down all the sections, starting with `<template>`, which hosts
    the HTML for our component; in this case, this is a native `<img>` element. This
    component has a few attributes being passed to it. The first two are native attributes:
    `src` and `class`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: These attributes are declared a little bit differently than you are used to
    in HTML, as they are preceded by `:`. When an attribute has this syntax, it means
    that its value is dynamic and that the values (in our case, `iconPath` and `sizeClass`)
    are going to be evaluated as a JavaScript variable and not actual strings.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Please note that you can write plain HTML in Vue.js, and using the dynamic variables
    is not a requirement for the framework but just a feature to make the attributes
    dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, let’s move to the logical part of the application, the `<script>`
    section. Here, we start by declaring the name of our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It is good practice for all Vue.js components to be formed of two words. This
    will ensure that the component does not clash with native HTML elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, it is time to declare the properties. Properties are values that are
    accepted by our component when it is initialized. This is an existing concept
    in development, as all HTML elements accept attributes such as `class`, `id`,
    and `value`. These properties make our components reusable and flexible. In our
    example, we declared two different properties: `name` and `size`. These will be
    passed down when the component is called, just as if they were native HTML attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This example shows a basic configuration for a property, in which we just define
    its type, but, as we will later see in the course of the book, `props` can have
    different configurations, such as validation, default values, and requirements
    rules, to state whether they are required or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next piece of code is where we declare our dynamic properties. For our
    component to function correctly, we need a path and a class defined as `iconPath`
    and `sizeClass`. These values are going to be dynamic due to the fact that they
    include the dynamic properties and will be declared using something called computed
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The computed properties allow us to declare values that are reactive (remember
    the reactivity chapter earlier on in the book) and can make use of our entire
    component logic; in this case, we just used the props, but we could have used
    a collection of values and external logic to create a new value.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Please note that when using Options API, you have to use the `this` keyword
    to be able to access variables within the component, such as `props` and `computed`.
    In our example, we used it to access properties by using `this.name` and `this.size`;.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our last section is `<style>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is quite simple because this example does not include anything different
    than you would normally see in plain CSS. As mentioned in a previous chapter,
    we can add the attribute scoped to our style to ensure that their style does not
    bleed from our component.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, you can see (in practice) how Options API divides
    our component into sections. In our case, we have `props`, `name`, `computed`,
    and `methods`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: An Atom component using Script Setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is now time to look at the same component but written using the `<script`
    `setup>` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can clearly see, the preceding example omits the `<template>` and `<style>`
    tags. These have been omitted because they are identical to the Options API counterpart.
    In fact, as we have already mentioned, the difference between these two methods
    only affects the logical part of the component, which is `<script>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line of our component is `import`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In contrast to Options API, where all the options were already available to
    us when using `<script setup>`, we have to import each individual Vue.js method
    from `'vue'`, just as we did in the previous code for `computed`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we are going to see how properties are defined in Composition API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Properties are one of the few options to have a verbose declaration while using
    `<script setup>`. In fact, to be able to declare them, we need to make use of
    a compiler macro called `defineProps`. Macros do not need to be imported, as they
    are just going to be used by the compiler and removed from the code. If you have
    ever used TypeScript, you will be familiar with this approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we have `computed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Declaring the properties of `computed` is very similar to Options API but with
    two small differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The logic of the properties of `computed` need to be passed as a callback to
    the computed method imported from `'vue'`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `this` keyword is not available anymore, and we can access variables directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is as far as we will go in terms of explaining the differences between
    Options API and Composition API for now. We will cover Script Setup (Composition
    API) in more detail later in the book. If you are extremely new to Vue.js, this
    section probably included lots of new syntax, and it was a little hard to grasp,
    but as soon as we start to build our Companion App, as you gain knowledge with
    Vue.js and its syntax, things will quickly make more sense to you.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have started to learn how Vue.js components are defined
    and the different sections that form an SFC. We then concluded the section by
    covering a sample component in both syntactic sugars in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now reached the end of this fairly theory-heavy chapter, and this was
    required for us to get started with our app-building process. In this chapter,
    we have learned what makes Vue.js different from the other frameworks by analyzing
    its reactivity system. We then broke down the composition of a Vue.js SFC, also
    known as a `.vue` file, and we walked through a Vue.js component’s lifecycle by
    analyzing all the different lifecycle hooks available within the framework.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the chapter, we learned the main differences between Composition
    API and Options API by exploring them using sample components.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start to learn Vue.js by starting to build our
    Companion App. This will be the beginning of your long journey from being a complete
    beginner to an experienced Vue.js developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Understanding the Core Features of Vue.js'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Part 2 of this book focuses on Vue.js and its core features. We will build the
    core of the Companion App one step at a time, while continuing to expand our knowledge
    of the Vue.js framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B21130_03.xhtml#_idTextAnchor039)*, Making Our HTML Dynamic*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B21130_04.xhtml#_idTextAnchor049)*, Utilizing Vue’s Built-in
    Directives for Effortless Development*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B21130_05.xhtml#_idTextAnchor060)*, Leveraging Computed Properties
    and Methods in Vue.js*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B21130_06.xhtml#_idTextAnchor074)*,* *Event and Data Handling
    in Vue.js*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B21130_07.xhtml#_idTextAnchor088)*,* *Handling API Data and Managing
    Async Components with Vue.js*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
