<html><head></head><body>
		<div id="_idContainer006">
			<h1 id="_idParaDest-15"><em class="italic"><a id="_idTextAnchor014"/>Chapter 1</em>: A Brief Introduction to Next.js</h1>
			<p>Next.js is an open source JavaScript web framework for React that ships with a rich set of features out of the box, such as server-side rendering, static site generation, and incremental static regeneration. These are just some of the many built-in components and plugins that make Next.js a framework ready for both enterprise-level applications and small websites.</p>
			<p>This book aims to show you the full potential of this framework while building real-world applications and use cases, such as e-commerce websites and blogging platforms. You will learn the basics of Next.js, how to choose between different rendering strategies and deployment methodologies, and different tips and approaches for making your web application both scalable and maintainable.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Introduction to the Next.js framework</li>
				<li>Comparing Next.js with other popular alternatives</li>
				<li>Differences between Next.js and client-side React</li>
				<li>Anatomy of a default Next.js project</li>
				<li>How to develop Next.js applications using TypeScript</li>
				<li>How to customize both Babel and webpack configurations</li>
			</ul>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Technical requirements</h1>
			<p>To get started with Next.js, you need to install a couple of dependencies on your machine.</p>
			<p>First of all, you need to install <strong class="bold">Node.js</strong> and <strong class="bold">npm</strong>. Please refer to this blog post if you need a detailed guide for installing them: <a href="https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js">https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js</a>.</p>
			<p>If you don't want to install Node.js on your local machine, some online platforms will let you follow the code examples in this book using an online IDE for free, such as <a href="https://codesandbox.io">https://codesandbox.io</a> and https://repl.it.</p>
			<p>Once you have both Node.js and npm installed (or you're using an online environment), you'll only need to follow the instructions displayed in each section of this book for installing the required project-specific dependencies using npm.</p>
			<p>You can find complete code examples on GitHub under the following repository:   <a href="https://github.com/PacktPublishing/Real-World-Next.js">https://github.com/PacktPublishing/Real-World-Next.js</a>. Feel free to fork, clone, and edit this repository for any experimentation with Next.js.</p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Introducing Next.js</h1>
			<p>Web development<a id="_idIndexMarker000"/> has changed a lot over the last few years. Before the advent of modern JavaScript frameworks, creating dynamic web applications was complex, and it required many different libraries and configurations to make them work as expected.</p>
			<p>Angular, React, Vue, and all the other frameworks have enabled the web to evolve very quickly, and brought with them some very innovative ideas to frontend web development.</p>
			<p>React, in particular, was created by <em class="italic">Jordan Walke</em> at Facebook and was heavily influenced by the <em class="italic">XHP Hack Library</em>. XHP allowed Facebook's PHP and Hack developers to create reusable components for the frontend of their applications. The JavaScript library became open source in 2013 and forever changed how we build websites, web apps, native <a id="_idIndexMarker001"/>apps (with <strong class="bold">React Native</strong> later on), and even VR <a id="_idIndexMarker002"/>experiences (with <strong class="bold">React VR</strong>). As a result, React has quickly become one of the most loved and popular JavaScript libraries, with millions of websites using it in production for many different purposes. </p>
			<p>There was just one problem: by default, React runs on the <strong class="bold">client side</strong> (meaning that it runs on the web browser), so a web application written entirely with that library could negatively<a id="_idIndexMarker003"/> affect <strong class="bold">Search Engine Optimization</strong> (<strong class="bold">SEO</strong>) and initial load performance, as it takes some time to be correctly rendered on screen. In fact, to display the complete web app, the browser had to download the entire application bundle, parse its content, then execute it and render the result in the browser, which could take up to a few seconds (with very large applications).</p>
			<p>Many companies and developers started investigating how to pre-render the application on the server, letting the browser display the rendered React app as plain HTML, making it interactive as soon as the JavaScript bundle has been transferred to the client.</p>
			<p>Then, <strong class="bold">Vercel</strong> came up with Next.js, which has turned out to be a game-changer.</p>
			<p>Since its first release, the framework has provided many innovative features out of the box, such as automatic code-splitting, server-side rendering, file-based routing systems, route pre-fetching, and so on. Next.js showed how easy it should be to write universal web applications by allowing developers to write reusable code for both client and server sides and making very complex tasks (such as code-splitting and server-side rendering) effortless to implement.</p>
			<p>Today, Next.js provides<a id="_idIndexMarker004"/> tons of new features out of the box, such as the<a id="_idIndexMarker005"/> following:</p>
			<ul>
				<li>Static site generation</li>
				<li>Incremental static generation</li>
				<li>Native TypeScript support</li>
				<li>Automatic polyfills</li>
				<li>Image optimization</li>
				<li>Support for internationalization</li>
				<li>Performance analytics</li>
			</ul>
			<p>All this, along with many other great features that we'll look at in depth later on in this book.</p>
			<p>Today, Next.js is used in production by top-level companies such as Netflix, Twitch, TikTok, Hulu, Nike, Uber, Elastic, and many others. If you're interested, you can read the complete list at https://nextjs.org/showcase.</p>
			<p>Next.js showed how versatile React could be for building many different applications at any scale, and it's not surprising to see it in use by both big companies and small start-ups. By the way, it is not the only framework that lets you render JavaScript on the server side, as we'll <a id="_idIndexMarker006"/>see in the next section.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Comparing Next.js to other alternatives</h1>
			<p>As you may be <a id="_idIndexMarker007"/>wondering, Next.js is not the only player in the server-side rendered JavaScript world. However, alternatives might be considered depending on the final purpose of a project.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Gatsby</h2>
			<p>One popular<a id="_idIndexMarker008"/> alternative is Gatsby. You may want to consider this framework <a id="_idIndexMarker009"/>if you seek to build static websites. Unlike Next.js, Gatsby only supports static site generation and  does it incredibly well. Every page is pre-rendered at build time and can be served on any <strong class="bold">Content Delivery Network</strong> (<strong class="bold">CDN</strong>) as a static asset, allowing the performance to be incredibly competitive <a id="_idIndexMarker010"/>compared to dynamically server-side rendered alternatives. The biggest downside of using Gatsby over Next.js is that you'll lose the ability of dynamic server-side rendering, which is an important feature for building more dynamically data-driven and complex websites.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Razzle</h2>
			<p>Less popular <a id="_idIndexMarker011"/>than Next.js, Razzle<a id="_idIndexMarker012"/> is a tool for creating server-side rendered JavaScript applications. It aims to maintain the ease of use of <strong class="source-inline">create-react-app</strong> while abstracting all the complex configurations needed for rendering the application both on the server and client sides. The most significant advantage of using Razzle instead of Next.js (or the following alternatives) is that it is framework agnostic. You can choose your favorite frontend framework (or language), such as React, Vue, Angular, Elm, or Reason-Reactâ€¦ it's your choice.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Nuxt.js</h2>
			<p>If you have <a id="_idIndexMarker013"/>experience with <a id="_idIndexMarker014"/>Vue, then Nuxt.js can be a valid Next.js competitor. They both offer support for server-side rendering, static site generation, progressive web app management, and so on, with no significant differences regarding performance, SEO, or development speed. While Nuxt.js and Next.js serve the same purpose, Nuxt.js needs more configuration, which is sometimes not a bad thing. In your Nuxt.js configuration file, you can define layouts, global plugins and components, routes, and so on, while with Next.js, you need to do it <em class="italic">the React way</em>. Apart from that, they share many functionalities, but the most significant difference is the library underneath. That said, if you already have a Vue component library, you <a id="_idIndexMarker015"/>could<a id="_idIndexMarker016"/> consider Nuxt.js for server-side rendering it.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Angular Universal</h2>
			<p>Of course, Angular <a id="_idIndexMarker017"/>has also made its move to the JavaScript <a id="_idIndexMarker018"/>server-side rendering scene, and it proposes Angular Universal as an official way for server-side rendering Angular applications. It supports both static site generation and server-side rendering and, unlike Nuxt.js and Next.js, it was developed by one of the biggest companies out there: Google. So if you are into Angular development and already have some components written with that library, Angular Universal can be a natural alternative to Nuxt.js, Next.js, and other similar frameworks.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>So, why Next.js?</h2>
			<p>We've now seen<a id="_idIndexMarker019"/> some popular alternatives to Next.js, and their strengths and weaknesses.</p>
			<p>The main reason why I'd suggest using Next.js instead of any other framework is because of its incredible feature set. With Next.js, you get everything you need right out of the box, and I'm not only referring to components, configurations, and deployment options, although they're probably the most complete I've ever seen.</p>
			<p>In addition, Next.js has an incredibly welcoming and active community ready to support you at every step you take in building your application. I would consider this as a huge bonus point, because as soon as you have a problem with your code base, you'll be able to get help from the massive community across many different platforms, including StackOverflow and GitHub, where the Vercel team is also often involved in discussions and support requests.</p>
			<p>Now that you know how Next.js competes with other similar frameworks, let's see the main differences between a default client-side React app and a fully-featured server-side environment for rendering your JavaScript code base dynamically for each request, and statically at<a id="_idIndexMarker020"/> build time.</p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>Moving from React to Next.js</h1>
			<p>If you already have <a id="_idIndexMarker021"/>some experience with React, you'll find it incredibly easy to build your first Next.js website. Its philosophy is very close to React and provides a <em class="italic">convention-over-configuration </em>approach for most of its settings, so if you want to take advantage of a specific Next.js feature, you'll easily find the official way for doing it without any need for complex configurations. An example? In a single Next.js app, you can specify which pages shall be server-side rendered and which shall be statically generated at build time without the need to write any configuration files or anything like that. You just have to export a specific function from your page and let Next.js do its magic (we'll see that in <a href="B16985_02_Final_SB_epub.xhtml#_idTextAnchor029"><em class="italic">Chapter 2</em></a><em class="italic">, Exploring Different Rendering Strategies</em>).</p>
			<p>The most significant difference between React and Next.js is that while React is just a JavaScript library, Next.js is a framework for building rich and complete user experiences both on the client and server sides, adding tons of incredibly useful features. Every server-side rendered or statically generated page will run on Node.js, so you'll lose access to some browser-specific global objects, such as <strong class="source-inline">fetch</strong>, <strong class="source-inline">window</strong>, and <strong class="source-inline">document</strong>, as well as some HTML elements such as <strong class="source-inline">canvas</strong>. You will always need to keep that in mind when you're writing your Next.js pages, even if the framework provides its own way for dealing with components that <em class="italic">must</em> use such global variables and HTML elements, as we'll see in<em class="italic"> </em><a href="B16985_02_Final_SB_epub.xhtml#_idTextAnchor029"><em class="italic">Chapter 2</em></a><em class="italic">, Exploring Different Rendering Strategies</em>.</p>
			<p>On the other hand, there might be times when you want to use Node.js specific libraries or APIs, such as <strong class="source-inline">fs</strong> or <strong class="source-inline">child_process</strong>, and Next.js allows you to use them by running your server-side code on each request or at build time (depending on how you choose to render your pages) before sending the data to the client.</p>
			<p>But even if you want to create a client-side rendered app, Next.js can be a great alternative to the well-known <strong class="source-inline">create-react-app</strong>. Next.js, in fact, can be used as a framework for writing progressive and offline-first web apps with ease, taking advantage of its incredible built-in components and optimizations. So let's get started with Next.js.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>Getting started with Next.js</h1>
			<p>Now that we have<a id="_idIndexMarker022"/> some basic knowledge about Next.js use cases and the differences between client-side React and other frameworks, it's time to look at the code. We'll start by creating a new Next.js app and customizing its default webpack and Babel configurations. We'll also see how to use TypeScript as the primary language for developing Next.js apps.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Default project structure</h2>
			<p>Getting started <a id="_idIndexMarker023"/>with Next.js is incredibly easy. The only system requirement is to have both Node.js and <strong class="source-inline">npm</strong> installed on your machine (or development environment). The Vercel team created and published a straightforward but powerful tool called <strong class="source-inline">create-next-app</strong> for generating the boilerplate code for a basic Next.js app. You can use it by typing the following command in the terminal:</p>
			<p class="source-code">npx create-next-app &lt;app-name&gt;</p>
			<p>It will install all the required dependencies and create a couple of default pages. At this point, you can just run <strong class="source-inline">npm run dev</strong>, and a development server will start on port <strong class="source-inline">3000</strong>, showing a landing page.</p>
			<p>Next.js will initialize your project using the Yarn package manager if installed on your machine. You can override this option by passing a flag to tell <strong class="source-inline">create-next-app</strong> to use <strong class="source-inline">npm</strong> instead:</p>
			<p class="source-code">npx create-next-app &lt;app-name&gt; --use-npm</p>
			<p>You can also ask <strong class="source-inline">create-next-app</strong> to initialize a new Next.js project by downloading the boilerplate code from the Next.js GitHub repository. In fact, inside the Next.js repository, there's an <strong class="source-inline">examples</strong> folder containing tons of great examples about how to use Next.js with different technologies.</p>
			<p>Let's say that you want to do some experiments with using Next.js on Docker â€“ you can just pass the <strong class="source-inline">--example</strong> flag to the boilerplate code generator:</p>
			<p class="source-code">npx create-next-app &lt;app-name&gt; --example with-docker</p>
			<p><strong class="source-inline">create-next-app</strong> will download the code from <a href="https://github.com/vercel/next.js/tree/canary/examples/with-docker">https://github.com/vercel/next.js/tree/canary/examples/with-docker</a> and will install the required dependencies for you. At this point, you only have to edit the downloaded files, customize them, and you're ready to go.</p>
			<p>You can find other great examples at https://github.com/vercel/next.js/tree/canary/examples. If you're already familiar with Next.js, feel free to explore how Next.js can integrate with different services and toolkits (we'll see some of them in more detail later on in this book).</p>
			<p>Now, let's go back to a default <strong class="source-inline">create-next-app</strong> installation for a moment. Let's open the terminal and generate a new Next.js app together:</p>
			<p class="source-code">npx create-next-app my-first-next-app --use-npm</p>
			<p>After a few<a id="_idIndexMarker024"/> seconds, the boilerplate generation will succeed, and you'll find a new folder called <strong class="source-inline">my-first-next-app</strong> with the following structure:</p>
			<p class="source-code">- README.md</p>
			<p class="source-code">- next.config.js</p>
			<p class="source-code">- node_modules/</p>
			<p class="source-code">- package-lock.json</p>
			<p class="source-code">- package.json</p>
			<p class="source-code">- pages/</p>
			<p class="source-code">Â Â - _app.js</p>
			<p class="source-code">Â Â - api/</p>
			<p class="source-code">Â Â Â Â - hello.js</p>
			<p class="source-code">Â Â - index.js</p>
			<p class="source-code">- public/</p>
			<p class="source-code">Â Â - favicon.ico</p>
			<p class="source-code">Â Â - vercel.svg</p>
			<p class="source-code">- styles/</p>
			<p class="source-code">Â Â - Home.module.css</p>
			<p class="source-code">Â Â - globals.css</p>
			<p>If you're coming from React, you may be used to <strong class="bold">react-router</strong> or similar libraries for managing client-side navigation. Next.js makes navigation even easier by using the <strong class="source-inline">pages/</strong> folder. In fact, every JavaScript file inside the <strong class="source-inline">pages/</strong> directory will be a public page, so if you try to duplicate the <strong class="source-inline">index.js</strong> page and rename it <strong class="source-inline">about.js</strong>, you'll be able to go to <strong class="source-inline">http://localhost:3000/about</strong> and see an exact copy of your home page. We'll look in detail how Next.js handles client-side and server-side routes in the next chapter; for now, let's just think of the <strong class="source-inline">pages/</strong> directory as a container for your public pages.</p>
			<p>The <strong class="source-inline">public/</strong> folder contains all the public and static assets used in your website. For example, you can put your images, compiled CSS stylesheets, compiled JavaScript files, fonts, and so on there.</p>
			<p>By default, you will also see a <strong class="source-inline">styles/</strong> directory; while this is very useful for organizing your application stylesheets, it is not strictly required for a Next.js project. The only mandatory and reserved directories are <strong class="source-inline">public/</strong> and <strong class="source-inline">pages/</strong>, so make sure not to delete or use them for different purposes.</p>
			<p>That said, you're free to add more directories and files to the project root, as it won't negatively interfere with the Next.js build or development process. If you want to organize your components under a <strong class="source-inline">components/</strong> directory and your utilities under a <strong class="source-inline">utilities/</strong> directory, feel free to add those folders inside your project.</p>
			<p>If you're not into <a id="_idIndexMarker025"/>boilerplate generators, you can bootstrap a new Next.js application by just adding all the required dependencies (as previously listed) and the basic folder structure that we just saw to your existing React application, and it'll just work with no other configuration required.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>TypeScript integration </h2>
			<p>The Next.js <a id="_idIndexMarker026"/>source <a id="_idIndexMarker027"/>code is written in TypeScript and natively provides high-quality <strong class="bold">type</strong> definitions to make your developer experience even better. Configuring TypeScript as the default language for your Next.js app is very easy; you just have to create a TypeScript configuration file (<strong class="source-inline">tsconfig.json</strong>) inside the root of your project. If you try to run <strong class="source-inline">npm run dev</strong>, you'll see the following output:</p>
			<p class="source-code">It looks like you're trying to use TypeScript but do not have the required package(s) installed.</p>
			<p class="source-code">Please install typescript and @types/react by running:</p>
			<p class="source-code">Â Â Â Â  npm install --save typescript @types/react</p>
			<p class="source-code">Â Â Â Â  If you are not trying to use TypeScript, please remove</p>
			<p class="source-code">Â Â Â Â  the tsconfig.json file from your package root (and any </p>
			<p class="source-code">Â Â Â Â  TypeScript files in your pages directory).</p>
			<p>As you can see, Next.js has correctly detected that you're trying to use TypeScript and asks you to install all the required dependencies for using it as the primary language for your project. So now you just have to convert your JavaScript files to TypeScript, and you're ready to go.</p>
			<p>You may notice that even if you created an empty <strong class="source-inline">tsconfig.json</strong> file, after installing the<a id="_idIndexMarker028"/> required dependencies and rerunning the project, Next.js fills<a id="_idIndexMarker029"/> it with its default configurations. Of course, you can always customize the TypeScript options inside that file, but keep in mind that Next.js uses Babel to handle TypeScript files (via the <strong class="source-inline">@babel/plugin-transform-typescript</strong>), and it has some caveats, including the following:</p>
			<ul>
				<li>The <strong class="source-inline">@babel/plugin-transform-typescript</strong> plugin does not support <strong class="source-inline">const enum</strong>, often used in TypeScript. To support it, make sure to add <strong class="source-inline">babel-plugin-const-enum</strong> to the Babel configuration (we'll see how in the <em class="italic">Custom Babel and webpack configuration</em> section).</li>
				<li>Neither <strong class="source-inline">export =</strong> nor <strong class="source-inline">import =</strong> are supported because they cannot be compiled to valid ECMAScript code. You should either install <strong class="source-inline">babel-plugin-replace-ts-export-assignment</strong>, or convert your imports and exports to valid ECMAScript directives, such as <strong class="source-inline">import x, {y} from 'some-package'</strong> and <strong class="source-inline">export default x</strong>.</li>
			</ul>
			<p>There are other caveats, too; I'd suggest you read them before going further with using TypeScript as the main language for developing your Next.js app: <a href="https://babeljs.io/docs/en/babel-plugin-transform-typescript#caveats">https://babeljs.io/docs/en/babel-plugin-transform-typescript#caveats</a>.</p>
			<p>Also, some compiler options might be a bit different from the default TypeScript ones; once again, I'd suggest you read the official Babel documentation, which will always be up to date: <a href="https://babeljs.io/docs/en/babel-plugin-transform-typescript#typescript-compiler-options">https://babeljs.io/docs/en/babel-plugin-transform-typescript#typescript-compiler-options</a>.</p>
			<p>Next.js also creates a <strong class="source-inline">next-env.d.ts</strong> file inside the root of your project; feel free to edit it if you<a id="_idIndexMarker030"/> need, but <a id="_idIndexMarker031"/>make sure not to delete it.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>Custom Babel and webpack configuration </h2>
			<p>As already<a id="_idIndexMarker032"/> mentioned in the <em class="italic">TypeScript Integration</em> section, we can <a id="_idIndexMarker033"/>customize <strong class="bold">Babel</strong> and <strong class="bold">webpack</strong> configurations.</p>
			<p>There might be many reasons we would like to customize our Babel configuration. If you're not very familiar with it, let me quickly explain what I'm talking about. Babel is a JavaScript transcompiler mainly used for transforming modern JavaScript code into a backward-compatible script, which will run without problem on any browser.</p>
			<p>If you're writing a web app that <em class="italic">must</em> support older browsers such as <strong class="bold">Internet Explorer </strong>(<strong class="bold">IE</strong>) 10 or Internet Explorer 11, Babel will help you a lot. It allows you to use modern ES6/ESNext features and will transform them into IE-compatible code at build time, letting you maintain a beautiful developer experience with very few compromises.</p>
			<p>Also, the JavaScript language (standardized under the ECMAScript specification) is quickly evolving. So while some fantastic features have already been announced, you'll have to wait for years before being able to use them in both browsers and Node.js environments. That's because after the ECMA committee has accepted these features, the companies developing web browsers and communities working on the Node.js project will have to plan a roadmap for adding support for these enhancements. Babel solves this problem by transpiling modern code into a compatible script for today's environments.</p>
			<p>For example, you may be familiar with this code:</p>
			<p class="source-code">export default function() {</p>
			<p class="source-code">Â Â console.log("Hello, World!");</p>
			<p class="source-code">};</p>
			<p>But if you try to run it in Node.js, it will throw a syntax error because the JavaScript engine won't recognize the <strong class="source-inline">export default</strong> keywords.</p>
			<p>Babel will transform the preceding code into this equivalent ECMAScript code, at least until Node.js gets support for the <strong class="source-inline">export default</strong> syntax:</p>
			<p class="source-code">"use strict";</p>
			<p class="source-code">Object.defineProperty(exports, "__esModule", {</p>
			<p class="source-code">Â Â value: true</p>
			<p class="source-code">});</p>
			<p class="source-code">exports.default = _default;</p>
			<p class="source-code">function _default() {</p>
			<p class="source-code">Â Â console.log("Hello, World!");</p>
			<p class="source-code">};</p>
			<p>This makes it<a id="_idIndexMarker034"/> possible to run this code on Node.js with no <a id="_idIndexMarker035"/>problems.</p>
			<p>You can customize your default Next.js Babel configuration by simply creating a new file called <strong class="source-inline">.babelrc</strong> inside the root of your project. You will notice that if you leave it empty, the Next.js build/development process will throw an error, so make sure to add at least the following code:</p>
			<p class="source-code">{</p>
			<p class="source-code">Â Â "presets": ["next/babel"]</p>
			<p class="source-code">}</p>
			<p>This is the Babel preset created by the Vercel team specifically for building and developing Next.js applications. Let's say that we're building an application, and we want to use an experimental ECMAScript feature such as the pipeline operator; if you're not familiar with it, it basically allows you to re-write this code as follows:</p>
			<p class="source-code">console.log(Math.random() * 10);</p>
			<p class="source-code">// written using the pipeline operator becomes:</p>
			<p class="source-code">Math.random()</p>
			<p class="source-code">Â Â |&gt; x =&gt; x * 10</p>
			<p class="source-code">Â Â |&gt; console.log</p>
			<p>This operator has not been officially accepted yet by <strong class="bold">TC39</strong> (the technical committee behind the ECMAScript specification), but you can start using it today, thanks to Babel.</p>
			<p>To provide support for <a id="_idIndexMarker036"/>this <a id="_idIndexMarker037"/>operator in your Next.js app, all you need to do is install the Babel plugin using <strong class="source-inline">npm</strong>:</p>
			<p class="source-code">npm install --save-dev @babel/plugin-proposal-pipeline-operator @babel/core</p>
			<p>Then update your custom <strong class="source-inline">.babelrc</strong> file as follows:</p>
			<p class="source-code">{</p>
			<p class="source-code">Â Â "presets": ["next/babel"],</p>
			<p class="source-code">Â Â "plugins": [</p>
			<p class="source-code">Â Â Â Â [</p>
			<p class="source-code">Â Â Â Â Â Â "@babel/plugin-proposal-pipeline-operator",</p>
			<p class="source-code">Â Â Â Â Â Â { "proposal": "fsharp" }</p>
			<p class="source-code">Â Â Â Â ]</p>
			<p class="source-code">Â Â ]</p>
			<p class="source-code">}</p>
			<p>You can now restart your development server and use this experimental feature.</p>
			<p>If you're interested in using TypeScript as the main development language for your Next.js app, you can just follow the same procedure for adding all the TypeScript-specific plugins to your Babel configuration. There are chances that during your Next.js development experience, you may also want to customize the default webpack configuration.</p>
			<p>While Babel only takes modern code as input and produces backward-compatible scripts as output, webpack creates the bundles containing all the compiled code for a specific library, page, or feature. For instance, if you create a page containing three components from three different libraries, webpack will merge everything into a single bundle to be shipped to the client. To put it simply, we can think of webpack as an infrastructure for orchestrating different compilation, bundle, and minification tasks for every web asset (JavaScript files, CSS, SVG, and so on).</p>
			<p>If you want to use CSS preprocessors such as <strong class="bold">SASS</strong> or <strong class="bold">LESS</strong> to create your app styles, you will need to customize the default webpack configuration to parse <strong class="bold">SASS</strong>/<strong class="bold">LESS</strong> files and produce plain CSS as output. The same, of course, occurs for JavaScript code using Babel as a transpiler.</p>
			<p>We talk more in detail about CSS preprocessors in the following chapters, but for now, we just need to keep in mind that Next.js provides an easy way for customizing the default webpack configuration.</p>
			<p>As we saw earlier, Next.js provides a <em class="italic">convention-over-configuration</em> approach, so you don't need to customize most of its settings for building a real-world application; you just have to<a id="_idIndexMarker038"/> follow<a id="_idIndexMarker039"/> some code conventions. </p>
			<p>But if you really need to build something custom, you'll be able to edit the default settings via the <strong class="source-inline">next.config.js</strong> file most of the time. You can create this file inside the root of your project. It should export an object by default, where its properties will override the default Next.js configurations:</p>
			<p class="source-code">module.exports = {</p>
			<p class="source-code">Â Â // custom settings here</p>
			<p class="source-code">};</p>
			<p>You can customize the default webpack configuration by creating a new property inside this object called <strong class="source-inline">webpack</strong>. Let's suppose that we want to add a new imaginary webpack loader called <strong class="source-inline">my-custom-loader</strong>; we can proceed as follows:</p>
			<p class="source-code">module.exports = {</p>
			<p class="source-code">Â Â webpack: (config, options) =&gt; {</p>
			<p class="source-code">Â Â Â Â config.module.rules.push({</p>
			<p class="source-code">Â Â Â Â Â Â test: /\.js/,</p>
			<p class="source-code">Â Â Â Â Â Â use: [</p>
			<p class="source-code">Â Â Â Â Â Â Â Â options.defaultLoaders.babel,</p>
			<p class="source-code">Â Â Â Â Â Â Â Â // This is just an example</p>
			<p class="source-code">Â Â Â Â Â Â Â Â //don't try to run this as it won't work</p>
			<p class="source-code">Â Â Â Â Â Â Â Â {</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â loader: "my-custom-loader", // Set your loader</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â options: loaderOptions, // Set your loader </p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â  options</p>
			<p class="source-code">Â Â Â Â Â Â Â Â },</p>
			<p class="source-code">Â Â Â Â Â Â ],</p>
			<p class="source-code">Â Â Â Â });</p>
			<p class="source-code">Â Â Â Â return config;</p>
			<p class="source-code">Â Â },</p>
			<p class="source-code">};</p>
			<p>So, as you can see, we're writing a proper webpack configuration that will later be merged with Next.js' default settings. This will allow us to extend, override, or even delete any setting from <a id="_idIndexMarker040"/>the <a id="_idIndexMarker041"/>default configuration, as although deleting default settings is generally never a good idea, there might be cases where you need it (if you're brave enough!).</p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor028"/>Summary</h1>
			<p>In this chapter, you have seen the main differences between default and client-side React apps and Next.js, and how Next.js compares with other well-known alternatives. You've also learned how to customize a default Next.js project by editing the Babel and webpack configurations, as well as adding TypeScript as an alternative to JavaScript for developing your applications.</p>
			<p>In the next chapter, we will take a closer look at three different rendering strategies: client-side rendering, server-side rendering, and static site generation.</p>
		</div>
	</body></html>