- en: Chapter 8. Time Will Tell
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 时间会证明
- en: Our task-management system is coming into shape. However, we were not concerned
    about one crucial aspect of managing our projects so far. Time plays a major role
    in all projects, and this is the thing that is often the most complicated to manage.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务管理系统正在成形。然而，到目前为止，我们并未关注到管理项目的一个关键方面。时间在所有项目中都扮演着重要角色，这也是最复杂的管理事项之一。
- en: In this chapter, we will add a few features to our task management system that
    will help our users to manage time more efficiently. Reusing some components that
    we created earlier, we will be able to provide a consistent user experience to
    manage time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向我们的任务管理系统添加一些功能，帮助用户更有效地管理时间。通过重用我们之前创建的一些组件，我们将能够提供一致的用户体验来管理时间。
- en: 'On a higher level, we will develop the following features to enable time management
    in our application:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在更高层次上，我们将开发以下功能以在我们的应用程序中实现时间管理：
- en: '**Task details**: So far, we did not include a details page of tasks because
    all the necessary information about tasks could be displayed on the task list
    of our project page. While our time management will increase the complexity of
    our tasks quite a bit, we will create a new detail view of project tasks that
    will also be accessible through routing.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务详情**：到目前为止，我们没有包括任务详情页面，因为所有关于任务的信息都可以在我们的项目页面上的任务列表中显示。虽然我们的时间管理将大大增加任务的复杂性，但我们将创建一个新的项目任务详情视图，它也将通过路由访问。'
- en: '**Efforts management**: We will include some new data on our tasks to manage
    efforts on tasks. Efforts are always represented by an estimated duration of time
    and an effective duration of spent time. We will make both properties of efforts
    optional so that they can exist independently. We will create new components to
    enable users to provide time duration input easily.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**努力管理**：我们将包括一些新的任务数据来管理任务上的努力。努力总是由估计的时间持续和实际花费的时间表示。我们将使努力的这两个属性都是可选的，以便它们可以独立存在。我们将创建新的组件，使用户能够轻松地提供时间持续时间输入。'
- en: '**Milestone management**: We will include a way to manage project milestones
    and then map them to project tasks. This will help us later gain an overview over
    the project status, and it enables the user to group tasks into smaller chunks
    of work.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**里程碑管理**：我们将包括一种管理项目里程碑的方法，并将它们映射到项目任务上。这将有助于我们后来对项目状态有一个全面的了解，并使用户能够将任务分组为更小的作业块。'
- en: 'The following topics will be covered in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Creating a project task detail component to edit task details and enable a new
    route
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个项目任务详情组件来编辑任务详情并启用新的路由
- en: Modifying our tag management system to include task tags
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改我们的标签管理系统以包含任务标签
- en: Creating new pipes to deal with formatting time durations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的管道来处理格式化时间持续时间
- en: Creating task information components to display task overview information on
    the existing task components
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建任务信息组件以在现有的任务组件上显示任务概述信息
- en: Creating a time duration use input component that enables users to easily input
    time durations
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个时间持续时间输入组件，使用户能够轻松输入时间持续时间
- en: Creating an SVG component to display progress on tasks
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个SVG组件来显示任务进度
- en: Creating an autocomplete component to manage milestones on tasks
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个自动完成组件来管理任务上的里程碑
- en: Task details
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务详情
- en: So far, our task list was sufficient enough to display all details of tasks
    directly in the listing. However, as we will add more details to tasks in this
    chapter, it's time to provide a detail view where users can edit the task.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的任务列表已经足够显示任务的所有详细信息。然而，随着我们在本章中为任务添加更多详细信息，是时候提供一个详情视图，让用户可以编辑任务了。
- en: We already laid the groundwork on project navigation using the router in [Chapter
    5](part0039.xhtml#aid-1565U1 "Chapter 5. Component-Based Routing"), *Component-Based
    Routing*, of this book. Adding a new routable component that we'll use in the
    context of our projects will be a breeze.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本书的[第5章](part0039.xhtml#aid-1565U1 "第5章. 组件化路由")，*组件化路由*中，使用路由器为项目导航奠定了基础。在项目中添加一个我们将使用的新可路由组件将变得轻而易举。
- en: 'Let''s create a new component class for our project task detail view in the
    `project/project-task-details/project-task-details.js` path:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`project/project-task-details/project-task-details.js`路径下为我们的项目任务详情视图创建一个新的组件类：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As this component will never exist without a parent `Project` component, we
    can safely rely on that to obtain the data we use. This component isn't used in
    pure UI composition cases, so it's not required to create a routable wrapper component
    like we did for other components in [Chapter 5](part0039.xhtml#aid-1565U1 "Chapter 5. Component-Based
    Routing"), *Component-Based Routing*. We can directly rely on route parameters
    and obtain the relevant data from the parent `Project` component.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此组件在没有父`Project`组件的情况下将不存在，我们可以安全地依赖它来获取我们使用的数据。此组件在纯UI组合情况下不使用，因此不需要创建像我们在第5章[“Component-Based
    Routing”](part0039.xhtml#aid-1565U1 "Chapter 5. Component-Based Routing")中为其他组件创建的可路由包装组件。我们可以直接依赖路由参数，并从父`Project`组件中获取相关数据。
- en: 'First, we use dependency injection in order to get a reference to the parent
    project component:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用依赖注入来获取父项目组件的引用：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Similarly to our routing wrapper components, we make use of parent component
    injection to obtain a reference to the parent `Project` component.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们的路由包装组件，我们利用父组件注入来获取父`Project`组件的引用。
- en: 'Now, we''ll use the `OnActivate` lifecycle hook of the router again to obtain
    the task number from the active route segment:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将再次使用路由器的`OnActivate`生命周期钩子来从活动路由段中获取任务编号：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Finally, we'll create a reactive subscription to the `LiveDocument` projects
    that will extract the task that we are concerned about and store it into the components
    `task` member. In this way, we ensure that our component will always receive the
    latest task data when the project is updated outside of the current task details
    view.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个对`LiveDocument`项目的响应式订阅，这将提取我们关心的任务并将其存储到组件的`task`成员中。这样，我们确保当项目在当前任务详情视图之外更新时，我们的组件将始终接收到最新的任务数据。
- en: 'If our component gets destroyed, we need to make sure that we unsubscribe from
    the RxJS `Observable` that is provided by the `LiveDocument` project. Let''s implement
    the `ngOnDestroy` lifecycle hook for this purpose:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的组件被销毁，我们需要确保我们取消订阅由`LiveDocument`项目提供的RxJS `Observable`。让我们为此实现`ngOnDestroy`生命周期钩子：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Alright, let''s now take a look at the template of our component, and see how
    we''ll deal with the task data to provide an interface to edit the details. We''ll
    create a `project-task-details.html` file in our new `component` folder:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在让我们看看我们组件的模板，看看我们将如何处理任务数据以提供一个编辑详情的接口。我们将在新的`component`文件夹中创建一个`project-task-details.html`文件：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Reusing the `Editor` component that we created in [Chapter 4](part0036.xhtml#aid-12AK82
    "Chapter 4. No Comments, Please!"), *No Comments, Please!*, of this book, we can
    rely on simple UI composition to make the title and description of our tasks editable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重新使用我们在本书第4章[“No Comments, Please!”](part0036.xhtml#aid-12AK82 "Chapter 4. No
    Comments, Please!")中创建的`Editor`组件，我们可以依靠简单的UI组合来使我们的任务标题和描述可编辑。
- en: As we stored the task data into the `task` member variable on our component,
    we can reference the `title` and `description` fields to create a binding to the
    `content` input property of our editor components.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将任务数据存储到我们的组件上的`task`成员变量中，我们可以引用`title`和`description`字段来创建一个绑定到我们的编辑组件的`content`输入属性。
- en: While the `title` should only consist of plaintext, we can support the tagging
    functionality that we created in [Chapter 7](part0049.xhtml#aid-1ENBI2 "Chapter 7. Components
    for User Experience"), *Components for User Experience*, on the `description`
    field of the task. For this, we simply set the `enableTags` input property of
    the description `Editor` component to `true`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`title`应仅包含纯文本，但我们可以支持我们在第7章[“Components for User Experience”](part0049.xhtml#aid-1ENBI2
    "Chapter 7. Components for User Experience")中创建的标签功能，在任务的`description`字段上。为此，我们只需将描述`Editor`组件的`enableTags`输入属性设置为`true`。
- en: 'The `Editor` component has an `editSaved` output property that will emit the
    updated content once a user saves his edits. Now, all we need to make sure of
    is that we create a binding to our component that will persist these changes.
    Let''s create the `onTitleSaved` and `onDescriptionSaved` methods on our `Component`
    class to handle these events:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Editor`组件有一个`editSaved`输出属性，当用户保存其编辑时将发出更新后的内容。现在，我们只需要确保我们创建一个绑定到我们的组件，以持久化这些更改。让我们在我们的`Component`类上创建`onTitleSaved`和`onDescriptionSaved`方法来处理这些事件：'
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The task member is just a reference to the given task in the `LiveDocument`
    project of the `Project` component. This simplifies the way we persist the data
    that was changed on the task. After updating the given property on the task, we
    simply call the `persist` method on the `LiveDocument` projects to store our changes
    in the data store.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 任务成员只是对`Project`组件中的`LiveDocument`项目所给任务的参考。这简化了我们持久化任务上更改的数据的方式。在更新任务上的给定属性后，我们只需在`LiveDocument`项目上调用`persist`方法来将我们的更改存储在数据存储中。
- en: 'So far, so good. We created a task details component that makes it easy to
    edit the title and description of tasks using our `Editor` UI component. The only
    thing left to enable our component is to create a child route on the `Project`
    component. Let''s open our `Project` component class in `lib/project/project.js`
    to make the necessary modifications:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。我们创建了一个任务详情组件，使用我们的`Editor` UI组件可以轻松编辑任务的标题和描述。我们唯一剩下要启用我们的组件的事情是在`Project`组件上创建一个子路由。让我们打开`lib/project/project.js`中的`Project`组件类，进行必要的修改：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We added a new child route on our `Project` component, which is responsible
    for the instantiation of our `ProjectTaskDetails` component. By including a `:nr`
    parameter in the route configuration, we can pass the concerned task number into
    the `ProjectTaskDetails` component.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Project`组件上添加了一个新的子路由，该路由负责实例化我们的`ProjectTaskDetails`组件。通过在路由配置中包含一个`:nr`参数，我们可以将相关的任务编号传递给`ProjectTaskDetails`组件。
- en: Our newly-created child route is now accessible in the router and we can access
    the task detail view using the `/projects/project-1/task/1` example URL.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新创建的子路由现在可以在路由器中访问，我们可以使用`/projects/project-1/task/1`示例URL访问任务详情视图。
- en: In order to make our `TaskDetails` route navigable, we need to add a navigation
    link to our `Task` component so that users can navigate to it in the projects
    task list.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的`TaskDetails`路由可导航，我们需要在我们的`Task`组件中添加一个导航链接，以便用户可以在项目任务列表中导航到它。
- en: 'For this rather simple task, the only thing that we need to do is use the `RouterLink`
    directive and create a new link in the `Task` template, `lib/task-list/task/task.html`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个相对简单的任务，我们唯一需要做的事情是使用`RouterLink`指令在`Task`模板`lib/task-list/task/task.html`中创建一个新的链接：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We use a relative router URL here because we''re already on the `/project/tasks`
    route. As our `task/:nr` route is part of the project router, we need to navigate
    one level back to access the `task` route:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用相对路由URL，因为我们已经在`/project/tasks`路由上。由于我们的`task/:nr`路由是项目路由的一部分，我们需要回退一级以访问`task`路由：
- en: '![Task details](img/image00333.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![任务详情](img/image00333.jpeg)'
- en: Newly created task detail view with editable title and description
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的任务详情视图，具有可编辑的标题和描述
- en: Enabling tags for tasks
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用任务标签
- en: 'So far, the tag-management system that we created in [Chapter 7](part0049.xhtml#aid-1ENBI2
    "Chapter 7. Components for User Experience"), *Components for User Experience*,
    only supports project tags. As we now created a detail view to tasks, it would
    be nice to also support task tags directly in our tagging system. Our tagging
    system is quite flexible, and we can implement new tags with very little effort.
    On a higher level, we need to make the following changes to enable task tags in
    our system:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在[第7章](part0049.xhtml#aid-1ENBI2 "第7章。用户体验组件")中创建的标签管理系统，*用户体验组件*，仅支持项目标签。由于我们现在创建了一个任务详情视图，因此也直接在我们的标签系统中支持任务标签会很好。我们的标签系统非常灵活，我们可以以非常少的努力实现新的标签。在更高层次上，我们需要进行以下更改以在我们的系统中启用任务标签：
- en: Edit the `generate-tag.js` module in order to support the generation of task
    tags from task and project data
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑`generate-tag.js`模块以支持从任务和项目数据生成任务标签
- en: Edit the `TagsService` in order to initialize task tags using the `generate-tag.js`
    module and cache
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑`TagsService`以使用`generate-tag.js`模块和缓存初始化任务标签
- en: 'Let''s first modify the `lib/tags/generate-tag.js` file to enable task tag
    generation:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先修改`lib/tags/generate-tag.js`文件以启用任务标签生成：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As we need to have a reference to project data as well as to the individual
    task of this project, we expect the `subject` parameter to look like the following
    object:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要同时引用项目数据和此项目的单个任务，我们期望`subject`参数看起来像以下对象：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: From this `subject` object, we can then create a new `Tag` object. For the `textTag`
    field, we use a construct that includes the project ID as well as the task number.
    Like this, we can uniquely identify the task using a simple text representation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个`subject`对象中，我们可以创建一个新的`Tag`对象。对于`textTag`字段，我们使用一个包含项目ID以及任务编号的结构。这样，我们可以使用简单的文本表示来唯一标识任务。
- en: For the `link` field, we construct a URL from the project as well as the task
    number. This string will resolve to a URL required to activate the `TaskDetails`
    route, which we configured in the previous section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`link`字段，我们从项目以及任务编号构建一个URL。这个字符串将解析为激活我们在上一节中配置的`TaskDetails`路由所需的URL。
- en: 'Our `generateTag` function is now ready to create task tags. Now, the only
    thing left to enable task tags in our system is the modification required in the
    `TagsService` class. Let''s open the `lib/tags/tags-service.js` file and apply
    our changes:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已准备好`generateTag`函数来创建任务标签。现在，我们系统中启用任务标签的唯一剩余操作是对`TagsService`类的修改。让我们打开`lib/tags/tags-service.js`文件并应用我们的更改：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the `initializeTags` method of our `TagsService` class, we now add task `Tag`
    objects for all available tasks in projects. First, we map each project task to
    the required `subject` object by the `generateTag` function. Then, we can simply
    map the resulting array using the `generateTag` function directly. The result
    is an array of generated task `Tag` objects that we then concatenate into the
    `tags` list of the `TagsService` class.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`TagsService`类的`initializeTags`方法中，我们现在为项目中所有可用的任务添加任务`Tag`对象。首先，我们通过`generateTag`函数将每个项目任务映射到所需的`subject`对象。然后，我们可以简单地使用`generateTag`函数直接映射结果数组。结果是生成任务`Tag`对象的数组，然后我们将它们连接到`TagsService`类的`tags`列表中。
- en: 'This wasn''t too complicated, right? This relatively simple change results
    in a huge improvement for our users. They can now reference individual tasks everywhere
    in our system where we enabled tags:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不太复杂，对吧？这个相对简单的更改为我们用户带来了巨大的改进。现在，他们可以在我们系统中任何我们启用了标签的地方引用单个任务：
- en: '![Enabling tags for tasks](img/image00334.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![为任务启用标签](img/image00334.jpeg)'
- en: The Editor component displaying newly-added task tags
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 显示新添加任务标签的编辑器组件
- en: Managing efforts
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理努力
- en: In this section, we will create some components that help us keep track of efforts.
    Primarily, we will use this to manage efforts on tasks, but this could be applied
    to any part of our application where we need to keep track of time.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一些组件，帮助我们跟踪努力。主要地，我们将使用这些组件来管理任务上的努力，但这可以应用于我们应用中的任何需要跟踪时间的部分。
- en: 'Efforts in our context always consist of two components:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的语境中，努力总是由两个组成部分组成：
- en: '**Estimated duration**: This is the duration that is initially estimated for
    the task'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预计持续时间**：这是对任务最初估计的持续时间'
- en: '**Effective duration**: This is the duration of time that is spent on a given
    task'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有效持续时间**：这是在特定任务上花费的时间长度'
- en: 'For time durations, we assume some time units and rules that will simplify
    the processing of time and align to some working standards. The goal here is not
    to provide a razor sharp time management but something that is accurate enough
    to bring value. For this purpose, we define the following working time units:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于时间长度，我们假设一些时间单位和规则，这将简化时间的处理并符合某些工作标准。这里的目的是不提供锐利的时管理，而是提供足够准确以带来价值的东西。为此，我们定义以下工作时间单位：
- en: '**Minute**: One minute is a regular 60 seconds'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分钟**：一分钟是标准的60秒'
- en: '**Hour**: One hour always represents 60 minutes'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小时**：一小时总是代表60分钟'
- en: '**Day**: One day represents a regular workday of eight hours'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**天**：一天代表一个标准的工作日，八小时'
- en: '**Week**: One week is equivalent to five working days (5 * 8 hours)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**周**：一周相当于五个工作日（5 * 8小时）'
- en: The time duration input
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间持续时间输入
- en: We can now start to write a complex user interface component, where users can
    enter individual time units in different input element. However, I believe it's
    much more convenient to treat time duration input with a no-UI approach. Therefore,
    instead of building a complex user interface, we can simply agree on a textual
    short form to write durations, and let the user write something, such as `1.5d`
    or `5h 30m`, in order to provide input. Sticking to the convention that we previously
    established, we can build a simple parser that can handle this sort of input.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始编写一个复杂的用户界面组件，用户可以在不同的输入元素中输入单独的时间单位。然而，我相信用无UI方法处理时间持续时间输入会更方便。因此，我们不必构建复杂的用户界面，而可以简单地约定一个文本简写形式来编写持续时间，并让用户输入一些内容，例如`1.5d`或`5h
    30m`，以提供输入。按照我们之前建立的约定，我们可以构建一个简单的解析器来处理这种输入。
- en: This approach has several advantages. Besides that, this is one of the most
    effective ways to enter time durations, and it's also easy for us to implement.
    We can simply reuse our `Editor` component to gather text input from the user.
    Then, we use a conversion process to parse the entered time duration.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有几个优点。除此之外，这也是输入时间持续的最有效方法之一，而且对我们来说也很容易实现。我们可以简单地重用我们的`Editor`组件来收集用户的文本输入。然后，我们使用一个转换过程来解析输入的时间持续时间。
- en: Let's spin up a new module that helps us deal with these conversions. We create
    a new module in the `lib/utilities/time-utilities.js` file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动一个新的模块，帮助我们处理这些转换。我们在`lib/utilities/time-utilities.js`文件中创建一个新的模块。
- en: 'First, we need to have a constant that defines all the units we need for the
    conversion process:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个常量来定义我们需要的所有转换单位：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is all the units that we need to deal with for now. You can see the milliseconds
    being calculated at interpretation time. We can also write the milliseconds as
    constants, but this provides us with some transparency on how we get to these
    values and we can spear on some comments.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们目前需要处理的全部单位。您可以看到在解释时计算的毫秒数。我们也可以将毫秒数写成常量，但这为我们提供了如何得到这些值的透明度，并且我们可以添加一些注释。
- en: 'Let''s look at our parsing function, which we can use to parse text input into
    time durations:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的解析函数，我们可以用它将文本输入解析为时间持续时间：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s analyze the preceding code briefly to explain what we do here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要分析一下前面的代码，以解释我们在这里做了什么：
- en: First, we define a regular expression that helps us dissect the text representation
    of a duration. This pattern will extract chunks from the text input that are important
    to calculate the duration behind the text representation. These chunks always
    consist of a number, followed by either `w`, `d`, `h`, or `m`. Therefore, the
    text `10w 3d 2h 30m` will be split into the chunks `10w`, `3d`, `2h`, and `30m`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个正则表达式，帮助我们分解持续时间文本表示。这个模式将提取文本输入中的重要部分，用于计算文本表示背后的持续时间。这些部分总是由一个数字后面跟着`w`、`d`、`h`或`m`组成。因此，文本`10w
    3d 2h 30m`将被分割成`10w`、`3d`、`2h`和`30m`这些部分。
- en: We initialize a `timeSpan` variable with `0`, so we can add all the milliseconds
    from discovered chunks together and later return this sum.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`timeSpan`变量初始化为`0`，这样我们就可以将发现的块中的所有毫秒数加在一起，然后返回这个总和。
- en: For each of the previously-extracted chunks, we now extract the number component
    into a variable called `amount`, and the unit (`w`, `d`, `h`, or `m`) into a variable
    called `unitShortName`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于之前提取的每个部分，我们现在将数字组件提取到一个名为`amount`的变量中，将单位（`w`、`d`、`h`或`m`）提取到一个名为`unitShortName`的变量中。
- en: Now, we can look up the data in the `UNITS` constant for the unit of the chunk
    that we will process, multiply the amount of milliseconds of the unit by the amount
    we extract from the chunk, and then add that result to our `timeSpan` variable.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以查找`UNITS`常量中的数据，为我们将要处理的块的单位，将单位的毫秒数乘以我们从块中提取的量，然后将这个结果加到我们的`timeSpan`变量中。
- en: 'Well this is quite a neat function we built here. It accepts a formatted time
    duration string and converts it into milliseconds. This is already half of what
    we need to deal with textual representation of time durations. The second piece
    is the opposite of what we have with the `parseDuration` function to convert a
    duration in milliseconds into a formatted duration string:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这是我们构建的一个相当整洁的函数。它接受一个格式化的时间持续时间字符串，并将其转换为毫秒。这已经是我们需要处理文本表示的时间持续期的半部分了。第二部分是`parseDuration`函数的相反，将毫秒持续时间转换为格式化的持续时间字符串：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s also explain briefly what the `formatDuration` function does:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也简要解释一下`formatDuration`函数的作用：
- en: We use the `Array.prototype.reduce` function to format a string that contains
    all time units and their amount. We iterate over all available time units in the
    `UNITS` constant starting with the largest unit for weeks.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`Array.prototype.reduce`函数来格式化包含所有时间单位和它们数量的字符串。我们从`UNITS`常量中的最大单位（周）开始，遍历所有可用的时间单位。
- en: We then divide the `timeSpan` variable, which is in milliseconds, by the milliseconds
    of the unit which gives us the amount of the given unit.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将以毫秒为单位的`timeSpan`变量除以单位的毫秒数，得到给定单位的数量。
- en: If the amount is greater than or equal to 1, we can add the unit with the given
    amount and unit short name to our formatted string.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数量大于或等于1，我们可以将给定的数量和单位简称添加到我们的格式化字符串中。
- en: As we could be left with some fractions after the comma in the amount, which
    we will need to encode in smaller units, we subtract the floored version of our
    amount from the `timeSpan` before we return to the `reduce` function again.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于在数量的小数点后可能留下一些分数，我们需要将这些分数编码到更小的单位中，所以我们从`timeSpan`中减去我们数量的向下取整版本，然后再返回到`reduce`函数。
- en: This process is repeated for every unit, where each unit will only provide formatted
    output if the amount is greater than or equal to 1.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个过程会为每个单位重复，其中每个单位只有在数量大于或等于1时才会提供格式化输出。
- en: This is all we need to convert back and forth between formatted time duration
    and time duration represented in milliseconds.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的所有内容，可以将格式化时间长度和以毫秒表示的时间长度相互转换。
- en: 'We''ll do one more thing before we create the actual component to enter time
    durations. We will create a simple pipe that basically just wraps our `formatTime`
    function. For this, we will create a new `lib/pipes/format-duration.js` file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建实际的时间长度输入组件之前，我们还将做一件事。我们将创建一个简单的管道，它基本上只是包装我们的`formatTime`函数。为此，我们将创建一个新的`lib/pipes/format-duration.js`文件：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using the `formatTime` function of our `time-utilities` module, we now have
    the ability to format durations in millisecond directly from in our templates.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的`time-utilities`模块中的`formatTime`函数，我们现在可以直接在我们的模板中以毫秒为单位格式化持续时间。
- en: Components to manage efforts
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理努力的组件
- en: Okay, this is enough time math for the moment. Let's now use the elements that
    we created to shape some components that will help us gather user input.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经有了足够的时间数学知识。现在让我们使用我们创建的元素来构建一些组件，这些组件将帮助我们收集用户输入。
- en: 'In this section, we will create two components to manage efforts:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建两个组件来管理努力：
- en: '`Duration`: The `Duration` component is a simple UI component, enabling user
    input of time durations using the formatted time strings we dealt with in the
    previous topics. It uses an `Editor` component to enable user input and makes
    use of the `FormatTimePipe` pipe as well as the `parseDuration` utility function.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`持续时间`: `持续时间`组件是一个简单的UI组件，它允许用户使用我们在前几节中处理过的格式化时间字符串输入时间长度。它使用`Editor`组件来启用用户输入，并使用`FormatTimePipe`管道以及`parseDuration`实用函数。'
- en: '`Efforts`: The `Efforts` component is just a composition of two `Duration`
    components that represent the estimated effort and the effective effort spent
    on a given task. Following a strict rule of composition, this component is important
    for us so that we don''t repeat ourselves and instead compose a larger component.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`努力`: `努力`组件只是两个`持续时间`组件的组合，这两个组件分别表示给定任务上的估计努力和实际花费的努力。遵循严格的组合规则，这个组件对我们来说很重要，这样我们就不需要重复自己，而是组合一个更大的组件。'
- en: 'Let''s start with the `Duration` component class, and create a new `lib/ui/duration/duration.js`
    file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`Duration`组件类开始，并创建一个新的`lib/ui/duration/duration.js`文件：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There's nothing fancy about this component really because we created the bulk
    of the logic already and we simply compose a higher component together.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件实际上并没有什么特别之处，因为我们已经创建了大部分逻辑，我们只是将一个高级组件组合在一起。
- en: As the `duration` input, we expect a time duration in milliseconds, while the
    `durationChange` output property will emit events when the user provides some
    input.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`duration`输入，我们期望一个以毫秒为单位的时间长度，而`durationChange`输出属性将在用户提供输入时发出事件。
- en: The `onEditSaved` method serves in the binding to the `Editor` component in
    our component. Whenever the user saves his edits on the `Editor` component, we'll
    take this input, convert the formatted time duration into milliseconds using the
    `parseDuration` function, and re-emit the converted value using the `durationChange`
    output property.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`onEditSaved`方法用于将我们的组件与`编辑器`组件绑定。每当用户在`编辑器`组件上保存其编辑时，我们将获取此输入，使用`parseDuration`函数将格式化的时长转换为毫秒，并使用`durationChange`输出属性重新发出转换后的值。'
- en: 'Let''s look at the template of our component in the `lib/ui/duration/duration.html`
    file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的组件模板，在`lib/ui/duration/duration.html`文件中：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Surprised with how simple our template is? Well, this is exactly what we should
    achieve with higher components once we establish a good foundation of base components.
    Well-organized composition radically simplifies our code. The only thing that
    we deal with here is our good old `Editor` component.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们的模板如此简单感到惊讶吗？好吧，这正是我们在建立了良好的基础组件之后，应该通过更高组件实现的目标。良好的组织结构极大地简化了我们的代码。我们在这里唯一处理的是我们那熟悉的`编辑器`组件。
- en: We bind the `duration` input property of our `Duration` component to the content
    input property of the `Editor` component. As we'd like to pass the formatted time
    duration and not the duration in milliseconds, we use the `FormatDurationPipe`
    pipe to convert in the binding expression.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的`时长`组件的`duration`输入属性绑定到`编辑器`组件的内容输入属性。由于我们希望传递格式化的时长而不是毫秒数，我们在绑定表达式中使用`FormatDurationPipe`管道进行转换。
- en: If the `Editor` component notifies us about a saved edit, we call the `onEditSaved`
    method on our `Duration` component, which will parse the entered duration and
    re-emit the resulting value.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`编辑器`组件通知我们已保存的编辑，我们将在我们的`时长`组件上调用`onEditSaved`方法，该方法将解析输入的时长并重新发出结果值。
- en: As we initially defined all efforts to consist of an estimated and an effective
    duration, we would now like to create another component that combines these two
    durations.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们最初定义所有努力都包括估计时长和有效时长，我们现在想创建另一个组件，该组件结合这两个时长。
- en: 'Let''s create a new `Efforts` component by starting with a new template on
    the `lib/efforts/efforts.html` path:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`lib/efforts/efforts.html`路径上创建一个新的`Efforts`组件，从一个新的模板开始：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First, we add two `Duration` components labelled, where the first one is used
    to gather input for the estimated time and the later one for effective time.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加两个标记为`Duration`的组件，其中第一个用于收集估计时间的输入，而后者用于有效时间。
- en: In addition to this, we provide three small buttons to increase the effective
    duration by a simple click. In this way, the user can quickly add one or four
    hours (half a working day) or a complete working day (which we defined as eight
    hours).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还提供了三个小按钮，通过简单的点击来增加有效时长。这样，用户可以快速增加一或四小时（半个工作日）或完整的工作日（我们定义为八小时）。
- en: 'Looking at the `Component` class, there should be no surprises. Let''s open
    the `lib/efforts/efforts.js` component class file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`Component`类，不应该有任何惊喜。让我们打开`lib/efforts/efforts.js`组件类文件：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The component provides two separate inputs for estimated and effective time
    duration in milliseconds. If you take a look at the component template again,
    these input properties are directly bound to the input properties of the `Duration`
    components.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件提供了两个单独的输入，用于估计和有效时间时长（以毫秒为单位）。如果您再次查看组件模板，这些输入属性直接绑定到`时长`组件的输入属性。
- en: The `onEstimatedChange` and `onEffectiveChange` methods are used to create bindings
    to the `durationChange` output properties of the `Duration` components. All we
    do here is emit an aggregated data object that contains the effective and estimated
    time in milliseconds using the `effortsChange` output property.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`onEstimatedChange`和`onEffectiveChange`方法用于创建到`时长`组件的`durationChange`输出属性的绑定。我们在这里所做的一切就是发出一个包含有效时间和估计时间（以毫秒为单位）的聚合数据对象，使用`effortsChange`输出属性。'
- en: In the `addEffectiveHours` method, we simply emit an `effortsChange` event and
    update the effective property by the calculated amount of milliseconds. We use
    our `UNITS` constant from the `time-utilities` module in order to get the amount
    of milliseconds for an hour.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`addEffectiveHours`方法中，我们简单地发出一个`effortsChange`事件，并通过计算出的毫秒数更新有效属性。我们使用来自`time-utilities`模块的`UNITS`常量来获取小时的毫秒数。
- en: This is all that we need in order to provide a user input to manage efforts
    on our tasks. To complete this topic, we will add our newly-created `Efforts`
    component to the `ProjectTaskDetail` component in order to manage efforts on tasks.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供用户输入来管理任务上的努力，我们需要这些所有信息。为了完成这个主题，我们将把新创建的`Efforts`组件添加到`ProjectTaskDetail`组件中，以便管理任务上的努力。
- en: 'Let''s first look at the code changes in the `Component` class located in `lib/project/project-task-detail/project-task-detail.js`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先查看位于`lib/project/project-task-detail/project-task-detail.js`的`Component`类中的代码更改：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Besides providing the `Efforts` component to the `directives` list of our `ProjectTaskDetail`
    component, we added a new `onEffortsChange` method that deals with the output
    provided by the `Efforts` component.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将`Efforts`组件添加到我们的`ProjectTaskDetail`组件的`directives`列表中，我们还添加了一个新的`onEffortsChange`方法来处理`Efforts`组件提供的输出。
- en: If both estimated and effective effort isn't set, or set to `0`, we'll set the
    task efforts to `null`. Otherwise, we use the output data of the `Efforts` component
    and assign it as our new task efforts.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果既未设置估计和实际努力，或设置为`0`，我们将任务努力设置为`null`。否则，我们使用`Efforts`组件的输出数据并将其分配为我们新的任务努力。
- en: After changing the task efforts, we persist the `LiveDocument` of the project
    in the same way that we do for the title and the description updates already.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改任务努力后，我们以与标题和描述更新相同的方式持久化项目的`LiveDocument`。
- en: 'Let''s check out the changes in the template of our component located in `lib/project/project-task-detail/project-task-detail.html`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查位于`lib/project/project-task-detail/project-task-detail.html`的组件模板中的更改：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We are binding the estimated and effective input properties of the `Efforts`
    component to the task data in the `ProjectTaskDetail` component. For the `effortsChange`
    output property we''re using an expression that is invoking our `onEffortsChange`
    method that we''ve just created:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Efforts`组件的估计和实际输入属性绑定到`ProjectTaskDetail`组件的任务数据中。对于`effortsChange`输出属性，我们使用一个表达式来调用我们刚刚创建的`onEffortsChange`方法：
- en: '![Components to manage efforts](img/image00335.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![用于管理努力的组件](img/image00335.jpeg)'
- en: Our new Efforts component that consists of two duration input components
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新`Efforts`组件由两个持续时间输入组件组成
- en: The visual efforts timeline
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视觉上的努力时间线
- en: Although the components that we created so far to manage efforts provide a good
    way to edit and display effort and time durations, we can still improve this with
    some visual indication.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们迄今为止创建的用于管理努力的组件提供了编辑和显示努力和时间持续的好方法，但我们仍然可以通过一些视觉指示来改进这一点。
- en: 'In this section, we will create a visual efforts timeline using SVG. This timeline
    should display the following information:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用SVG创建一个视觉上的努力时间线。此时间线应显示以下信息：
- en: The total estimated duration as a gray background bar
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总估计持续时间作为一个灰色背景条
- en: The total effective duration as a green bar that overlays on the total estimated
    duration bar
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总实际持续时间作为一个绿色条，它覆盖在总估计持续时间条上
- en: A yellow bar that shows any overtime (if the effective duration is greater than
    the estimated duration)
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个显示任何加班（如果实际持续时间大于估计持续时间）的黄色条
- en: 'The following two figures illustrate the different visual states of our efforts
    timeline component:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两个图示说明了我们的努力时间线组件的不同视觉状态：
- en: '![The visual efforts timeline](img/image00336.jpeg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![视觉上的努力时间线](img/image00336.jpeg)'
- en: The visual state if the estimated duration is greater than the effective duration
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当估计持续时间大于实际持续时间时的视觉状态
- en: '![The visual efforts timeline](img/image00337.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![视觉上的努力时间线](img/image00337.jpeg)'
- en: The visual state if the effective duration exceeds the estimated duration (the
    overtime is displayed as a black bar)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当实际持续时间超过估计持续时间时的视觉状态（加班显示为黑色条）
- en: 'Let''s start fleshing out our component by creating a new `EffortsTimeline`
    Component class on the `lib/efforts/efforts-timeline/efforts-timeline.js` path:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`lib/efforts/efforts-timeline/efforts-timeline.js`路径上创建一个新的`EffortsTimeline`组件类，以具体化我们的组件：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Our component has three input properties:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件有三个输入属性：
- en: '`estimated`: This is the estimated time duration in milliseconds'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`estimated`：这是估计时间持续时间的毫秒数'
- en: '`effective`: This is the effective time duration in milliseconds'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`effective`：这是实际时间持续时间的毫秒数'
- en: '`height`: This is the desired height of the efforts timeline in pixels'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`height`：这是努力时间线期望的高度，以像素为单位'
- en: 'In the `OnChanges` lifecycle hook, we set two component member fields, which
    are based on the estimated and effective time:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnChanges`生命周期钩子中，我们设置了两个基于估计和实际时间的组件成员字段：
- en: '`done`: This contains the width of the green bar in percentage that displays
    the effective duration without overtime that exceeds the estimated duration'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`done`：这包含显示没有超过估算持续时间的有效持续时间的绿色条宽度百分比'
- en: '`overtime`: This contains the width of the yellow bar in percentage that displays
    any overtime, which is any time duration that exceeds the estimated duration'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`overtime`：这包含显示任何加班的黄色条宽度百分比，任何超过估算持续时间的持续时间'
- en: Let's look at the template of the `EffortsTimeline` component and see how we
    can now use the `done` and `overtime` member fields to draw our timeline.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`EffortsTimeline`组件的模板，看看我们如何现在使用`done`和`overtime`成员字段来绘制我们的时间线。
- en: 'We will create a new `lib/efforts/efforts-timeline/efforts-timeline.html` file:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的`lib/efforts/efforts-timeline/efforts-timeline.html`文件：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our template is SVG-based, and it contains three rectangles for each of the
    bars that we want to display. The background bar that will be visible if there
    is remaining effort will always be displayed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模板是基于SVG的，它包含我们想要显示的每个条的三个矩形。如果有剩余的努力，将始终显示背景条形图。
- en: Above the remaining bar, we conditionally display the done and the overtime
    bar using the calculated widths from our component class.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在剩余的条形图上方，我们使用从我们的组件类计算出的宽度有条件地显示完成和加班条形图。
- en: Now, we can go ahead and include the `EffortsTimeline` class in our `Efforts`
    component. This way our users will have visual feedback when they edit the estimated
    or effective duration, and it provides them a sense of overview.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续在我们的`Efforts`组件中包含`EffortsTimeline`类。这样，当我们的用户编辑估算或实际持续时间时，他们将获得视觉反馈，这为他们提供了一个概览。
- en: 'Let''s look into the template of the `Efforts` component to see how we integrate
    the timeline:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Efforts`组件的模板，看看我们如何集成时间线：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As we have the estimated and effective duration times readily available in
    our `Efforts` component, we can simply create a binding to the `EffortsTimeline`
    component input properties:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在`Efforts`组件中已经有了估算和实际持续时间，我们可以简单地创建一个绑定到`EffortsTimeline`组件输入属性：
- en: '![The visual efforts timeline](img/image00338.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![可视的努力时间线](img/image00338.jpeg)'
- en: The Efforts component displaying our newly-created efforts timeline component
    (the overtime of six hours is visualized with the yellow bar)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 显示我们新创建的努力时间线组件的`Efforts`组件（六小时的加班用黄色条可视化）
- en: Recapitulating on efforts management
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 努力管理的总结
- en: 'In this section, we''ll create components that allow users to manage efforts
    easily and add a simple but powerful time tracking to our tasks. We''ve done the
    following to achieve this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建允许用户轻松管理努力并为我们任务添加简单但强大的时间跟踪的组件。我们已经做了以下事情来实现这一点：
- en: We implemented some utility functions to deal with the time math in order to
    convert time durations in milliseconds into formatted time durations and vice
    versa
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们实现了一些实用函数来处理时间数学，以便将毫秒时间段转换为格式化时间段，反之亦然
- en: We created a pipe to format time durations in milliseconds using our utility
    functions
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个管道，使用我们的实用函数格式化以毫秒为单位的时间段
- en: We created a `Duration` UI component, which wraps an `Editor` component and
    uses our time utilities to provide a no-UI kind of input element to enter durations
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个`Duration` UI组件，它包装了一个`Editor`组件，并使用我们的时间实用工具提供了一个无UI类型的输入元素来输入持续时间
- en: We created an `Efforts` component that acts as a composition of two `Duration`
    components for estimated and effective time and provides additional buttons to
    add effective spent time quickly
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个`Efforts`组件，它作为两个`Duration`组件的组合，用于估算和实际时间，并提供额外的按钮来快速添加实际花费的时间
- en: We integrated the `Efforts` component into the `ProjectTaskDetail` component
    in order to manage efforts on tasks
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`Efforts`组件集成到`ProjectTaskDetail`组件中，以便在任务上管理努力
- en: We created a visual `EffortsTimeline` component using SVG, which displays the
    overall progress on a task
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用SVG创建了一个可视的`EffortsTimeline`组件，它显示任务的总体进度
- en: Setting milestones
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置里程碑
- en: Tracking time is important. I don't know how you feel about time, but I really
    suck at organizing my time. Although a lot of people ask me how I manage to do
    so many things, I believe I'm actually very bad at managing how I get these things
    done. If I were a better organizer, I could get things done with much less energy
    involved.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪时间很重要。我不知道你对时间的看法如何，但我在组织时间方面真的很差。尽管很多人问我如何做到这么多事情，但我相信我实际上在管理如何完成这些事情方面真的很差。如果我能成为一个更好的组织者，我可以用更少的精力完成事情。
- en: One thing that always helps me organize myself is to break things down into
    smaller work packages. Users that organize themselves with our task management
    application can already do this by creating tasks in projects. While a project
    is the overall goal, we can create smaller tasks to achieve this goal. However,
    sometimes we tend to lose sight of the overall goal when we're only focused on
    tasks.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 总有一件事能帮助我组织自己，那就是将事情分解成更小的工作包。使用我们任务管理应用程序来组织自己的用户可以通过在项目中创建任务来实现这一点。虽然项目是整体目标，但我们可以创建更小的任务来实现这个目标。然而，有时我们只专注于任务时，往往会失去对整体目标的关注。
- en: Milestones are a perfect glue between projects and tasks. They make sure that
    we bundle tasks together into larger packages. This will help us a lot in organizing
    our tasks, and we can look at milestones of the project to see the overall project
    health. However, we can still focus on tasks when we work in the context of a
    milestone.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 里程碑是项目和任务之间完美的粘合剂。它们确保我们将任务捆绑成更大的包。这将极大地帮助我们组织任务，并且我们可以查看项目的里程碑来了解项目的整体健康状况。然而，当我们以里程碑的上下文工作时，我们仍然可以专注于任务。
- en: In this section, we will create the necessary components in order to add basic
    milestone functionality to our application.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建必要的组件，以便将基本里程碑功能添加到我们的应用程序中。
- en: 'To implement milestone functionality in our application, we will stick to the
    following design decisions:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的应用程序中实现里程碑功能，我们将坚持以下设计决策：
- en: Milestones should be stored on the project level, and tasks can contain an optional
    reference to a project milestone.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 里程碑应存储在项目级别，并且任务可以包含对项目里程碑的可选引用。
- en: To keep things simple, the only interaction point with milestones should be
    on task level. Therefore, creation of milestones will be done on task level, although
    the created milestones will be stored on project level.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了保持简单，与里程碑的唯一交互点应该在任务级别。因此，里程碑的创建将在任务级别完成，尽管创建的里程碑将存储在项目级别。
- en: Milestones currently only consist of a name. There are a lot more to milestones
    that we can potentially build into our system, such as deadlines, dependencies,
    and other nice things. However, we will stick to the bare minimum, which is a
    milestone name.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前里程碑仅包含一个名称。我们可以在系统中构建更多关于里程碑的内容，例如截止日期、依赖关系和其他美好的事物。然而，我们将坚持最基本的原则，即里程碑名称。
- en: Creating an autocomplete component
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自动完成组件
- en: In order to keep the management of milestones simple, we will create a new user
    interface component to deal with the design concerns that we listed. Our new autocomplete
    component will not only display possible values to select from, but it will also
    allow us to create new items. We can then simply use this component on our `ProjectTaskDetail`
    component in order to manage milestones.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持里程碑管理的简单性，我们将创建一个新的用户界面组件来处理我们列出的设计问题。我们的新自动完成组件不仅会显示可供选择的可能值，而且还会允许我们创建新项目。然后我们可以简单地使用这个组件在我们的`ProjectTaskDetail`组件上，以便管理里程碑。
- en: 'Let''s look at the `Component` class of our new autocomplete component that
    we will create in the `lib/ui/auto-complete/auto-complete.js` file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们将在`lib/ui/auto-complete/auto-complete.js`文件中创建的新自动完成组件的`Component`类：
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Once again, our `Editor` component can be reused to create this higher component.
    We're lucky that we created such a nice component, as this saved us a lot of time
    throughout this project.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们的`Editor`组件可以被重用来创建这个高级组件。我们很幸运地创建了一个如此好的组件，因为它在这个项目中节省了我们大量的时间。
- en: 'Let''s look at the input and output properties of the `AutoComplete` component
    in more detail:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看`AutoComplete`组件的输入和输出属性：
- en: '`items`: This is where we expect an array of strings. This will be the list
    of items a user can choose from when typing into the editor.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`items`：这是我们期望的字符串数组。这将是在编辑器中输入时用户可以选择的项目列表。'
- en: '`selectedItem`: This is when we make the selected item an input property to
    actually make this component pure, and we can rely on the parent component to
    set this property right.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selectedItem`：这是我们将选中的项目作为一个输入属性来使这个组件成为纯组件的时候，并且我们可以依赖父组件来设置这个属性。'
- en: '`selectedItemChange`: This output property will emit an event if the selected
    item was changed. As we create a pure component here, we somehow need to propagate
    the event of an item that was selected in the autocomplete list.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selectedItemChange`：这个输出属性会在选中的项目发生变化时触发事件。由于我们在这里创建了一个纯组件，我们需要以某种方式传播在自动完成列表中选中的项目的相关事件。'
- en: '`itemCreated`: This output property will emit an event if a new item was added
    to the autocomplete list. Updating the list of items and changing the component
    `items` input property will still be the responsibility of the parent component.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`itemCreated`：如果向自动完成列表添加了新项，此输出属性将发出事件。更新项目列表和更改组件`items`输入属性仍然是父组件的责任。'
- en: 'Let''s add more code to our component. We use an `Editor` component as main
    input source. While our users will type into the editor, we filter the available
    items using the text input of the editor. Let''s create a `filterItems` for this
    purpose:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在组件中添加更多代码。我们使用`Editor`组件作为主要输入源。当我们的用户在编辑器中键入时，我们使用编辑器的文本输入来过滤可用的项。让我们为此创建一个`filterItems`：
- en: '[PRE25]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `filterItems` method has a single parameter, which is the text that we want
    to use in order to search for relevant items in our list.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`filterItems`方法有一个单一参数，即我们想要用于在列表中搜索相关项的文本。'
- en: 'Let''s look at the content of the method in more detail:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看该方法的内容：
- en: For later use in our template, we will set aside the filter query that was used
    the last time this method was called
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了在模板中使用，我们将保存上一次调用此方法时使用的过滤查询。
- en: In the `filteredItems` member variable, we will store a filtered version of
    the item list by searching for text occurrences of the filter string
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`filteredItems`成员变量中，我们将通过搜索过滤字符串的文本出现来存储项目列表的过滤版本。
- en: As a last step, we also store the information if the search query resulted in
    an exact match of an item in our list
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为最后一步，我们还存储了搜索查询是否导致我们的列表中某个项的精确匹配的信息
- en: 'Now, we need to make sure that if the `items` or `selectedItem` input properties
    change, we also execute our filter method again. For this, we simply implement
    the `ngOnChanges` lifecycle hook:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要确保如果`items`或`selectedItem`输入属性发生变化，我们也再次执行我们的过滤方法。为此，我们简单地实现了`ngOnChanges`生命周期钩子：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s now see how we deal with the events provided by the `Editor` component:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们如何处理`Editor`组件提供的事件：
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If the editor changes to edit mode, we want to save the previously selected
    item. We'll need this if the user decides to cancel his edits and switch back
    to the previous item. Of course, this is also the point where we need to display
    the autocomplete list to the user.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编辑器切换到编辑模式，我们希望保存之前选中的项。如果用户决定取消他的编辑并切换回之前的项，我们将需要这样做。当然，这也是我们需要向用户显示自动完成列表的地方。
- en: 'On the other hand, if the edit mode is switched back to read mode, we want
    to hide the autocomplete list again:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果将编辑模式切换回阅读模式，我们希望再次隐藏自动完成列表：
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `editableInput` event is triggered by our editor on every editor input
    change. The event provides us with the text content that was entered by the user.
    If such an event occurs, we need to execute our filter function again with the
    updated filter query:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`editableInput`事件在每次编辑器输入更改时由我们的编辑器触发。该事件为我们提供了用户输入的文本内容。如果发生此类事件，我们需要再次使用更新的过滤查询执行我们的过滤函数：'
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When the `editSaved` event is triggered by our editor, we need to decide whether
    we should do either of the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的编辑器触发`editSaved`事件时，我们需要决定是否应该执行以下操作之一：
- en: Emit an event using the `selectedItemChange` output property if the saved content
    is an empty string to signal the removal of a selected item to the parent component
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果保存的内容是空字符串，则使用`selectedItemChange`输出属性发出事件，向父组件信号已删除选定的项。
- en: 'Emit an event using the `itemCreated` output property if valid content is given
    and our list does not include an item with that name to signal an item creation:'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果提供了有效内容并且我们的列表中不包含具有该名称的项，则使用`itemCreated`输出属性发出事件，以信号项的创建：
- en: '[PRE30]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: On the `editCanceled` event of the `Editor` component, we want to switch back
    to the previous selected item. For this, we can simply emit an event using the
    `selectedItemChange` output property and the `previousSelectedItem` member that
    we put aside after the editor was switched into edit mode.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Editor`组件的`editCanceled`事件上，我们希望切换回之前选中的项。为此，我们可以简单地使用`selectedItemChange`输出属性和我们在编辑器切换到编辑模式后留出的`previousSelectedItem`成员来发出一个事件。
- en: These are all the binding functions that we will use to wire up our editor and
    in order to attach the autocomplete functionality to it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将用于连接我们的编辑器并将自动完成功能附加到其上的所有绑定函数。
- en: 'There are two more rather simple methods that we will create before we take
    a look at the template of our autocomplete component:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看自动完成组件的模板之前，我们将创建两个更简单的其他方法：
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We will use these two for the click actions in the autocomplete callout from
    our template. Let''s take a look at the template so that you can see all the code
    that we just created in action:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这两个用于模板中自动完成提示的点击操作。让我们看一下模板，以便你可以看到我们刚刚创建的所有代码的实际效果：
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: First, the `Editor` component is placed and all necessary bindings to the handler
    methods that we created in our `Component` class are attached.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，放置`Editor`组件，并将我们创建的`Component`类中的处理方法所需的所有绑定附加到它上。
- en: 'Now, we will create the autocomplete list that will be displayed as a callout
    to the user right next to the editor input area:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个自动完成列表，它将作为用户在编辑器输入区域旁边的提示显示：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We rely on the `showCallout` member set by the `onEditModeChange` method of
    our `Component` class to signal if we should display the autocomplete list or
    not.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们依赖于`Component`类的`onEditModeChange`方法设置的`showCallout`成员变量，以表示是否应该显示自动完成列表。
- en: We then iterate over all filtered items using the `NgFor` directive and render
    the text content of each item. If one of the items gets clicked on, we will call
    our `selectItem` method with the concerned item as the parameter value.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`NgFor`指令遍历所有过滤后的项目，并渲染每个项目的文本内容。如果点击了某个项目，我们将调用我们的`selectItem`方法，并将相关项目作为参数值。
- en: 'As the last list element, after the repeated list items, we conditionally display
    an additional list element in order to create a nonexisting milestone. We only
    display this button if there''s a valid filter already and if there''s no exact
    match of the filter to an existing milestone:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一个列表元素，在重复的列表项之后，我们条件性地显示一个额外的列表元素，以创建一个不存在的里程碑。我们仅在存在有效的过滤器且过滤器与现有里程碑没有精确匹配时显示此按钮：
- en: '![Creating an autocomplete component](img/image00339.jpeg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![创建自动完成组件](img/image00339.jpeg)'
- en: Our milestone component plays nicely together with the editor component using
    a clean composition
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的里程碑组件与编辑器组件配合得很好，使用干净的组合方式。
- en: Now that we are all done with our autocomplete component, the only thing left
    to do in order to manage project milestones is to make use of it in the `ProjectTaskDetails`
    component.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了自动完成组件，为了管理项目里程碑，我们唯一需要做的就是将其用于`ProjectTaskDetails`组件中。
- en: 'Let''s open the `Component` class located in `lib/project/project-task-details/project-task-details.js`
    and apply the necessary modifications:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开位于`lib/project/project-task-details/project-task-details.js`中的`Component`类，并应用必要的修改：
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the subscription to project changes, we now also extract any preexisting
    project milestones and store them in a `projectMilestones` member variable. This
    makes it easier to reference in the template.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目更改的订阅中，我们现在还提取任何现有的项目里程碑，并将它们存储在`projectMilestones`成员变量中。这使得在模板中引用它们更容易。
- en: The `onMilestoneSelected` method will be bound to the `selectItemChange` output
    property of the `AutoComplete` component. We use the emitted value of the `AutoComplete`
    component to set our tasks milestone and persist the `LiveDocument` project using
    its `persist` method.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`onMilestoneSelected`方法将被绑定到`AutoComplete`组件的`selectItemChange`输出属性上。我们使用`AutoComplete`组件发出的值来设置我们的任务里程碑，并使用其`persist`方法持久化`LiveDocument`项目。'
- en: The `onMilestoneCreated` method will be bound to the `itemCreated` output property
    of the `AutoComplete` component. On such an event, we add the created milestone
    to the projects milestone list as well as assign the current task to the created
    milestone. After updating the `LiveDocument` data, we use the `persist` method
    to save all changes.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`onMilestoneCreated`方法将被绑定到`AutoComplete`组件的`itemCreated`输出属性上。在这种情况下，我们将创建的里程碑添加到项目的里程碑列表中，并将当前任务分配给创建的里程碑。更新`LiveDocument`数据后，我们使用`persist`方法保存所有更改。'
- en: 'Let''s look into `lib/project/project-task-details/project-task-details.html`
    to see the necessary changes in our template:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看`lib/project/project-task-details/project-task-details.html`，以查看模板中必要的更改：
- en: '[PRE35]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Besides the output property bindings that you're already aware of, we also create
    two input bindings for the `items` and `selectedItem` input properties of the
    `AutoComplete` component.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 除了你已经知道的输出属性绑定之外，我们还为`AutoComplete`组件的`items`和`selectedItem`输入属性创建了两个输入绑定。
- en: This is already it. We created a new UI component that provides autocompletion
    and used that component to implement milestone management on our tasks.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部了。我们创建了一个新的UI组件，提供了自动完成功能，并使用该组件在我们的任务中实现了里程碑管理。
- en: Isn't it nice how easy it suddenly seems to implement new functionality when
    using components with proper encapsulation? The great thing about component-oriented
    development is that your development time for new functionality decreased with
    the amount of reusable components that you already created.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用具有适当封装的组件实现新功能突然变得如此简单，这不是很好吗？面向组件的开发的好处在于，你为新的功能开发时间随着你已创建的可重用组件的数量而减少。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we implemented some components that help our users keep track
    of time. They can now log efforts on tasks and manage milestones on projects.
    We created a new task detail view that can be accessed using a navigation link
    on our task list.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们实现了一些帮助用户跟踪时间的组件。现在，他们可以在任务上记录努力，并在项目上管理里程碑。我们创建了一个新的任务详情视图，可以通过任务列表上的导航链接访问。
- en: Once more, we experienced the power of composition using components, and reusing
    existing components, we were able to easily implement higher components that provide
    more complex functionality.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们体验到了使用组件进行组合的力量，通过重用现有组件，我们能够轻松实现提供更复杂功能的高级组件。
- en: In the next chapter, we will look at how to use the charting library Chartist
    and create some wrapper components that allow us to build reusable charts. We
    will build a dashboard for our task management system, where we will see our chart
    components in action.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用图表库 Chartist 并创建一些包装组件，使我们能够构建可重用的图表。我们将为我们的任务管理系统构建一个仪表板，在那里我们将看到我们的图表组件的实际应用。
