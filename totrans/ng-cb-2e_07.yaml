- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Understanding Angular Navigation and Routing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Angular 导航和路由
- en: One of the most amazing things about Angular is that it is an entire ecosystem
    (a framework) rather than a library. In this ecosystem, the Angular router is
    one of the most critical blocks to learn about and understand. In this chapter,
    you’ll learn some really cool techniques for routing and navigation in Angular.
    You’ll learn about how to guard your routes, listen to route changes, and configure
    global actions on route changes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 最令人惊奇的事情之一是它是一个完整的生态系统（一个框架），而不仅仅是一个库。在这个生态系统中，Angular 路由是学习和理解的最关键的模块之一。在本章中，你将学习一些关于
    Angular 路由和导航的非常酷的技术。你将了解如何保护你的路由，监听路由变化，并在路由变化时配置全局操作。
- en: 'The following are the recipes we’re going to cover in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将在本章中涵盖的食谱：
- en: Creating routes in an Angular (standalone) app
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Angular (独立) 应用中创建路由
- en: Lazily loaded routes in Angular
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 中的懒加载路由
- en: Preloading route strategies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预加载路由策略
- en: Authorized access to routes using route guards
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用路由守卫授权访问路由
- en: Working with route parameters
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用路由参数进行操作
- en: Showing a global loader between route changes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在路由变化之间显示全局加载器
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For the recipes in this chapter, ensure your setup is complete as per the ''Technical
    Requirements'' in the ''Angular-Cookbook-2E'' GitHub repository. For setup details,
    visit: [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md).
    The starter code for this chapter is located at [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter07](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter07).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的食谱，请确保你的设置已按照 'Angular-Cookbook-2E' GitHub 仓库中的 '技术要求' 完成。有关设置详情，请访问：[https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md)。本章的起始代码位于
    [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter07](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter07)。
- en: Creating routes in an Angular (standalone) app
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Angular (独立) 应用中创建路由
- en: If you ask me about how we used to create projects for web applications 7–8
    years ago, you’ll be astonished to learn how difficult it was. Luckily, the tools
    and standards have evolved in the software development industry and, when it comes
    to Angular, starting a project is super easy. With the Angular standalone apps,
    the configuration is much smaller for the application’s bootstrap process and
    for routing. In this recipe, you’re going to implement some routes in a fresh
    Angular application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你问我我们过去 7-8 年是如何创建 Web 应用项目的话，你会惊讶地了解到那是多么困难。幸运的是，软件开发行业中的工具和标准已经发展，对于 Angular
    来说，开始一个项目变得超级简单。使用 Angular 独立应用，应用的引导过程和路由配置都要小得多。在本食谱中，你将要在一个新的 Angular 应用程序中实现一些路由。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter07/ng-basic-routing`
    inside the cloned repository:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆的仓库中的 `start/apps/chapter07/ng-basic-routing` 目录下：
- en: Open the code repository in your code editor.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This should open the app in a new browser tab. You should see the following:'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用。你应该看到以下内容：
- en: '![](img/B18469_07_01.png)'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_07_01.png)'
- en: 'Figure 7.1: ng-basic-routes app running on http://localhost:4200'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.1：ng-basic-routes 应用在 http://localhost:4200 上运行
- en: How to do it…
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We’ll configure routing in the app, add some routes, and add the links to those
    routes in the headers. Let’s get started:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在应用中配置路由，添加一些路由，并在页眉中添加这些路由的链接。让我们开始吧：
- en: 'First, create a file named `app.routes.ts` inside the `app` folder and add
    the following code to it:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `app` 文件夹内创建一个名为 `app.routes.ts` 的文件，并将以下代码添加到其中：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now update the file `app.config.ts` in the `src` folder with the following
    changes:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在更新 `src` 文件夹中的 `app.config.ts` 文件，并按照以下更改进行：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now let’s create some components (as pages). We’re going to create a home page
    and an `about` page. Running the following `npx` command in the terminal from
    the `start` folder in the workspace. If asked, you can use the `@nx/angular:component`
    schematics and choose the “As provided” action:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一些组件（作为页面）。我们将创建一个主页和一个`about`页。在工作区的`start`文件夹中，从终端运行以下`npx`命令。如果需要，你可以使用`@nx/angular:component`脚本来选择“按提供”操作：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You should see two new folders created in the `app` folder of the project now.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你现在应该在项目的`app`文件夹中看到创建了两个新文件夹。
- en: 'We will configure the routes now. Update the `app.routes.ts` file that we created
    in *step 1* as follows:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将配置路由。更新我们在*步骤1*中创建的`app.routes.ts`文件，如下所示：
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'All that remains is to hook the routes in the view using `<router-outlet>`
    in the template. Update the `app.component.html` file as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩下的就是在视图中使用模板中的`<router-outlet>`来连接路由。更新`app.component.html`文件如下：
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: But wait! That crashes the app. That’s because the `AppComponent` doesn’t understand
    routing yet.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是等等！这会导致应用崩溃。这是因为`AppComponent`还没有理解路由。
- en: 'Update the `app.component.ts` file to add the `RouterModule` in it as follows:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`app.component.ts`文件，在其中添加`RouterModule`，如下所示：
- en: '[PRE6]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And voilà ! You should be able to see the `home` component now, as follows:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 哇！现在你应该能够看到`home`组件了，如下所示：
- en: '![](img/B18469_07_02.png)'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_07_02.png)'
- en: 'Figure 7.2: The home component in the ng-basic-routes app'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.2：ng-basic-routes应用中的home组件
- en: If you look at the URL, it defaults to `http://localhost:4200/home` even if
    you try to go to `https://localhost:4200`.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你查看URL，它默认为`http://localhost:4200/home`，即使你尝试访问`https://localhost:4200`。
- en: 'Finally, we’ll add the links for the routes in the header. Update `app.component.html`
    as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将在页眉中添加路由的链接。更新`app.component.html`文件如下：
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, if you click the **About** link at the top, you should be able to see
    the `about` route, as follows:'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，如果你点击顶部的**关于**链接，你应该能够看到`about`路由，如下所示：
- en: '![](img/B18469_07_03.png)'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_07_03.png)'
- en: 'Figure 7.3: The about component in the ng-basic-routes app'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.3：ng-basic-routes应用中的about组件
- en: Awesome! Within a few minutes, and with the help of Angular router and NX CLI,
    we were able to create a home page and an `about` page, and we configured routing
    as well. The wonders of the modern web!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！在几分钟内，借助Angular路由和NX CLI，我们能够创建一个主页和一个`about`页，并且还配置了路由。现代网络的奇迹！
- en: Now that you know how basic routing is implemented, the next section will help
    you to understand how it works.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了基本路由是如何实现的，下一节将帮助你理解它是如何工作的。
- en: How it works…
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'When we create an Angular app without the `--routing` flag, we don’t get the
    `app.routes.ts` file or have the configuration added in the `main.ts` file. For
    this example, we worked with an app that already had this flag set. If you were
    to start a new project, you might as well just use the `--routing` flag while
    creating the app to have routing set up in the app from the start. Then we created
    some standalone components using the `nx g c <component name> –standalone` command.
    If you were using the Angular CLI instead of an NX monorepo, you would just replace
    `nx` with `ng` in the preceding command, and the rest would be the same. Using
    `npx` allows us to use the `nx` package without globally installing it in our
    system. Since we have a standalone app, i.e., the `AppComponent` is a standalone
    component (notice the `standalone: true` in the `app.component.ts` file), we had
    to import the `RouterModule` to it to be able to use the `<router-outlet>` and
    the `routeLink` attribute on the links. We configured the routes by using the
    `provideRouter` function in the `main.ts` file with the routes since we don’t
    have an `AppModule` (because the app is a standalone app).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们创建一个不带`--routing`标志的Angular应用时，我们不会得到`app.routes.ts`文件，也不会在`main.ts`文件中添加配置。在这个例子中，我们使用了一个已经设置了此标志的应用。如果你要开始一个新的项目，你可以在创建应用时直接使用`--routing`标志，以便从应用一开始就设置好路由。然后我们使用`nx
    g c <component name> –standalone`命令创建了一些独立组件。如果你使用Angular CLI而不是NX单仓库，你只需在上一个命令中将`nx`替换为`ng`，其余的都相同。使用`npx`允许我们使用`nx`包，而无需在我们的系统中全局安装它。由于我们有一个独立的应用，即`AppComponent`是一个独立组件（注意`app.component.ts`文件中的`standalone:
    true`），我们必须将其导入到`RouterModule`中，以便能够使用`<router-outlet>`和链接上的`routeLink`属性。由于我们没有`AppModule`（因为应用是一个独立应用），我们通过在`main.ts`文件中使用`provideRouter`函数并添加路由来配置路由。'
- en: See also
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Angular router docs: [https://angular.io/guide/router](https://angular.io/guide/router)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular路由文档：[https://angular.io/guide/router](https://angular.io/guide/router)
- en: 'Angular standalone components: [https://angular.io/guide/standalone-components](https://angular.io/guide/standalone-components)'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular独立组件：[https://angular.io/guide/standalone-components](https://angular.io/guide/standalone-components)
- en: Lazily loaded routes in Angular
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular中的懒加载路由
- en: In the previous recipe, we learned how to create a basic routing app with eagerly
    loaded routes. In this recipe, you’ll learn how to work with feature modules to
    lazily load them instead of loading them when the app loads. For this recipe,
    we’ll assume that we already have the routes in place, and we just need to load
    them lazily.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的食谱中，我们学习了如何创建一个带有急速加载路由的基本路由应用。在这个食谱中，你将学习如何使用功能模块来懒加载它们，而不是在应用加载时加载它们。对于这个食谱，我们假设我们已经有路由在位，我们只需要懒加载它们。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter07/ng-lazy-routing`
    inside the cloned repository:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆的仓库中的`start/apps/chapter07/ng-lazy-routing`：
- en: Open the code repository in your code editor.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE8]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This should open the app in a new browser tab. If you open the **Network**
    tab, you should see the following:'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签中打开应用。如果你打开**网络**标签，你应该会看到以下内容：
- en: '![](img/B18469_07_04.png)'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_07_04.png)'
- en: 'Figure 7.4: ng-lazy-routing app running on http://localhost:4200'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.4：ng-lazy-routing应用在http://localhost:4200上运行
- en: Now that we have the app running locally, let’s see the steps of the recipe
    in the next section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用，让我们看看下一节中食谱的步骤。
- en: How to do it…
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'As shown in *Figure 7.4*, we have all the components and modules inside the
    `main.js` file. Therefore, the `main.js` file is about 11.9 KB in size (this could
    change depending on how Angular further optimizes the framework). We’ll modify
    the code and the routing structure to achieve lazy loading. As a result, the files
    of the routes will load when we navigate to them. Before the *standalone components*
    era, this step was difficult. And even today, if you work with Angular applications
    using `NgModules`, you will find that it takes a lot more code to set up your
    routing. But since our application has only standalone components, see how easy
    it becomes to change it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图7.4*所示，我们所有的组件和模块都在`main.js`文件中。因此，`main.js`文件的大小约为11.9 KB（这可能会根据Angular如何进一步优化框架而改变）。我们将修改代码和路由结构以实现懒加载。因此，当我们导航到这些路由时，路由的文件将会被加载。在*独立组件*时代之前，这一步是困难的。即使今天，如果你使用`NgModules`与Angular应用一起工作，你也会发现设置路由需要更多的代码。但既然我们的应用只有独立组件，看看这变得有多简单：
- en: 'Update the `app.routes.ts` to use the `loadComponent` method instead of the
    `component` property in the routes, as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`app.routes.ts`更新为使用`loadComponent`方法代替路由中的`component`属性，如下所示：
- en: '[PRE9]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Refresh the app and you’ll see that the bundle size for the `main.js` file
    is down to 8.3 KB, which was about 11.9 KB before. See the following screenshot:'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 刷新应用后，你会看到`main.js`文件的包大小降至8.3 KB，之前大约是11.9 KB。请看以下截图：
- en: '![](img/B18469_07_05.png)'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_07_05.png)'
- en: 'Figure 7.5: Reduced size of main.js on app load'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.5：应用加载时main.js文件大小的减少
- en: 'But what about the `Home` and `About` routes? And what about lazy loading?
    Well, tap the **About** route from the header and you’ll see a new JavaScript
    file being downloaded in the **Network** tab specifically for the route. That’s
    lazy loading in action! See the following screenshot:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但关于`Home`和`About`路由呢？还有懒加载呢？好吧，点击页眉中的**About**路由，你会在**网络**标签中看到一个针对该路由的新JavaScript文件正在下载。这就是懒加载的作用！请看以下截图：
- en: '![](img/B18469_07_06.png)'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_07_06.png)'
- en: 'Figure 7.6: about route being lazily loaded'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.6：关于路由的懒加载
- en: Awesomesauce! You just became lazy! Just kidding. You just learned the art of
    lazily loading routes and feature components in your Angular app. You can now
    show this off to your friends as well.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你刚刚学会了如何在Angular应用中懒加载路由和功能组件的艺术。你现在可以向你的朋友炫耀这项技能了。
- en: How it works…
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Angular works with modules and components and, usually, the features are broken
    down into either `NgModules`, or with standalone components, the components themselves
    are lazily loaded. We’re going to look into the standalone components perspective.
    As we know, `AppComponent` serves as the entry point for the standalone Angular
    app and Angular will import and bundle anything that is imported in `AppComponent`
    during the build process, resulting in the `main.js` file. However, if we want
    to lazily load our routes/feature components, we need to avoid importing feature
    components in `AppComponent` directly or even importing them in the routes. Instead,
    we can use the `loadChildren` method for lazily loading other modules, or the
    `loadComponent` method to lazily load other standalone components. That’s what
    we did in this recipe. It is important to note that the routes stayed the same
    in the `app.routes.ts` file.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 使用模块和组件，通常，功能被拆分为 `NgModules`，或者使用独立组件，组件本身是懒加载的。我们将从独立组件的角度来探讨。正如我们所知，`AppComponent`
    作为独立 Angular 应用的入口点，Angular 将在构建过程中导入并捆绑在 `AppComponent` 中导入的任何内容，从而生成 `main.js`
    文件。然而，如果我们想懒加载我们的路由/功能组件，我们需要避免在 `AppComponent` 中直接导入功能组件，甚至不在路由中导入它们。相反，我们可以使用
    `loadChildren` 方法来懒加载其他模块，或者使用 `loadComponent` 方法来懒加载其他独立组件。这正是我们在本食谱中做的事情。需要注意的是，在
    `app.routes.ts` 文件中，路由保持不变。
- en: See also
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考也
- en: 'Lazily loading modules in Angular: [https://angular.io/guide/lazy-loading-ngmodules](https://angular.io/guide/lazy-loading-ngmodules)'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Angular 中懒加载模块：[https://angular.io/guide/lazy-loading-ngmodules](https://angular.io/guide/lazy-loading-ngmodules)
- en: 'Lazily loading standalone components: [https://angular.io/guide/standalone-components#routing-and-lazy-loading](https://angular.io/guide/standalone-components#routing-and-lazy-loading)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒加载独立组件：[https://angular.io/guide/standalone-components#routing-and-lazy-loading](https://angular.io/guide/standalone-components#routing-and-lazy-loading)
- en: Preloading route strategies
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预加载路由策略
- en: We’re already familiar with how to lazily load different feature modules during
    navigation. Sometimes, though, you might want to preload subsequent routes to
    make the next route navigation instantaneous or might even want to use a custom
    preloading strategy based on your application’s business logic. In this recipe,
    you’ll learn about the `PreloadAllModules` strategy and also implement a custom
    strategy to cherry-pick which modules should be preloaded.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了如何在导航期间懒加载不同的功能模块。不过，有时你可能希望预加载后续路由以使下一个路由导航瞬间完成，或者甚至可能希望根据应用程序的业务逻辑使用自定义预加载策略。在本食谱中，你将了解
    `PreloadAllModules` 策略，并实现一个自定义策略来选择哪些模块应该被预加载。
- en: Getting ready
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter07/ng-route-preload-strat`
    inside the cloned repository:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆的仓库中的 `start/apps/chapter07/ng-route-preload-strat`：
- en: Open the code repository in your code editor.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以运行项目：
- en: '[PRE10]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This should open the app in a new browser tab. If you log in as an admin, you
    should see the following:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用。如果你以管理员身份登录，你应该看到以下内容：
- en: '![](img/B18469_07_07.png)'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片 B18469_07_07.png](img/B18469_07_07.png)'
- en: 'Figure 7.7: The ng-route-preload-strat app running on http://localhost:4200'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.7：在 http://localhost:4200 上运行的 ng-route-preload-strat 应用
- en: Open Chrome DevTools by pressing *Ctrl* + *Shift* + *C* on Windows or *Cmd*
    + *Shift* + *C* on Mac.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按 Windows 上的 *Ctrl* + *Shift* + *C* 或 Mac 上的 *Cmd* + *Shift* + *C* 来打开 Chrome
    开发者工具。
- en: Navigate to the **Network** tab and filter on JavaScript files only. You should
    see something like this:![](img/B18469_07_08.png)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **网络** 选项卡，并仅过滤 JavaScript 文件。你应该看到如下内容！![图片 B18469_07_08.png](img/B18469_07_08.png)
- en: 'Figure 7.8: JavaScript files loaded on app load'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.8：应用加载时加载的 JavaScript 文件
- en: Now that we have the app running locally, let’s see the next section for this
    recipe.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用，让我们看看本食谱的下一节。
- en: How to do it…
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Notice in *Figure 7.8* the first network call. It is the JavaScript bundle
    that contains the `admin` component and the `bucket` component. Although the routes
    in `app-routes.t`s are all configured to be lazily loaded, we can still look into
    what happens if we use the `PreloadAllModules` strategy and then a custom preload
    strategy:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 *图 7.8* 中的第一个网络调用。这是包含 `admin` 组件和 `bucket` 组件的 JavaScript 包。尽管 `app-routes.ts`
    中的所有路由都配置为懒加载，但我们仍然可以查看如果我们使用 `PreloadAllModules` 策略然后自定义预加载策略会发生什么：
- en: 'We’re going to try out the `PreloadAllModules` strategy first. To use it, let’s
    modify the `app/app.config.ts` file as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先尝试使用`PreloadAllModules`策略。为了使用它，让我们按照以下方式修改`app/app.config.ts`文件：
- en: '[PRE11]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you refresh the app, you should see all the JavaScript bundles being downloaded
    for all components, as follows:'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你刷新应用，你应该看到所有组件的JavaScript包正在下载，如下所示：
- en: '![](img/B18469_07_09.png)'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_07_09.png)'
- en: 'Figure 7.9: All components being loaded eagerly using PreloadAllModules strategy'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.9：使用PreloadAllModules策略预先加载所有组件
- en: This already provides huge performance benefits because the minimal `app` `shell`
    is loaded first, and then all the other bundles are preloaded in parallel. This
    means that whenever the user navigates to a page now, they will not have to download
    the route’s bundle and navigate right away (i.e., navigation will be faster).
    But what if we wanted to preload only the `admin` module, supposing our app is
    intended for admins mostly? We’ll create a custom preload strategy for that.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这已经提供了巨大的性能优势，因为最小的`app` `shell`首先被加载，然后所有其他包并行预加载。这意味着当用户现在导航到页面时，他们不需要下载路由的包并立即导航（即，导航将更快）。但如果我们只想预加载`admin`模块，假设我们的应用主要是为管理员设计的呢？我们将为那个创建一个自定义预加载策略。
- en: 'Let’s create a service named `CustomPreloadStrategy` by running the following
    command from within the `start` folder:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从`start`文件夹中运行以下命令来创建一个名为`CustomPreloadStrategy`的服务：
- en: '[PRE12]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In order to use our preload strategy service with Angular, our service needs
    to implement the `PreloadingStrategy` interface from the `@angular/router` package.
    Modify the newly created service as follows:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用我们的预加载策略服务与Angular一起工作，我们的服务需要实现`@angular/router`包中的`PreloadingStrategy`接口。按照以下方式修改新创建的服务：
- en: '[PRE13]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we need to implement the `preload` method from the `PreloadingStrategy`
    interface for our service to work properly. Let’s modify `CustomPreloadStrategyService`
    to implement the `preload` method, as follows:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现`PreloadingStrategy`接口中的`preload`方法，以便我们的服务能够正常工作。让我们修改`CustomPreloadStrategyService`以实现`preload`方法，如下所示：
- en: '[PRE14]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Right now, our `preload` method returns `of(null)`. Instead, in order to decide
    which routes to preload, we’re going to add an object to our route definitions
    as the `data` object that has a Boolean value for `admin` routes and `employee`
    routes to preload. Let’s modify the `app-routes.ts` as follows:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，我们的`preload`方法返回`of(null)`。相反，为了决定要预加载哪些路由，我们将在我们的路由定义中添加一个对象作为`data`对象，该对象具有布尔值，用于预加载`admin`路由和`employee`路由。让我们按照以下方式修改`app-routes.ts`：
- en: '[PRE15]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now let’s add the logic to our `preload` method in the `AppPreloadStrategyService`
    class to work with the properties added in *step 5*. We’re going to first inject
    the `AuthService` and will create some variables inside the `preload` method.
    Update the `app-preload-strategy.service.ts` file as follows:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在`AppPreloadStrategyService`类的`preload`方法中添加逻辑，以处理在*步骤5*中添加的属性。我们将首先注入`AuthService`，并在`preload`方法内部创建一些变量。更新`app-preload-strategy.service.ts`文件如下：
- en: '[PRE16]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s modify the `preload` method further to work with the `loadForAdmin` and
    `loadForEmployee` route data properties as follows:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进一步修改`preload`方法，以便与`loadForAdmin`和`loadForEmployee`路由数据属性一起使用如下：
- en: '[PRE17]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The final step is to use our custom preloading strategy. In order to do so,
    modify the `app/app.config.ts` file as follows:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是使用我们的自定义预加载策略。为了做到这一点，我们需要按照以下方式修改`app/app.config.ts`文件：
- en: '[PRE18]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Voilà! If you refresh the app now and monitor the **Network** tab, you’ll notice
    when you’re logged in as `admin`, you can see in the console log that the `admin-campaign`
    route is preloaded, as shown in *Figure 7.10*:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 哇！如果你现在刷新应用并监控**网络**选项卡，你会注意到当你以`admin`身份登录时，你可以在控制台日志中看到`admin-campaign`路由已被预加载，如图*图7.10*所示：
- en: '![](img/B18469_07_10.png)'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_07_10.png)'
- en: 'Figure 7.10: Preloading the admin-campaign route when landing on the admin
    route using the custom preload strategy'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.10：使用自定义预加载策略在到达admin路由时预加载admin-campaign路由
- en: 'You can also have a look at the **Network** tab to see the bundles being downloaded:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以查看**网络**选项卡来查看正在下载的包：
- en: '![](img/B18469_07_11.png)'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_07_11.png)'
- en: 'Figure 7.11: JavaScript bundle for admin-campaign route preloaded'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.11：为admin-campaign路由预先加载JavaScript包
- en: Try logging out and logging in as an employee. You’ll see the `employee-campaign`
    route being preloaded. Not only that, if you refresh the employee-campaign route,
    you’ll see the `employee` route being preloaded as well. The same goes for the
    admin-campaign and `admin` routes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试注销并作为员工登录。你会看到`employee-campaign`路由正在预加载。不仅如此，如果你刷新`employee-campaign`路由，你还会看到`employee`路由也在预加载。对于`admin-campaign`和`admin`路由也是如此。
- en: Now that you’ve finished the recipe, see the next section on how this works.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了配方，请查看下一节了解它是如何工作的。
- en: How it works…
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Angular provides a great way to implement our own custom preloading strategy
    for our feature modules. We can decide easily which modules should be preloaded
    and which should not. In the recipe, we learned a very simple way to configure
    the preloading using the `data` object of the routes configuration by adding properties
    named `loadForAdmin` and `loadForEmployee`. We created our own custom preloading
    strategy service named `AppPreloadStrategyService`, which implements the `PreloadingStrategy`
    interface from the `@angular/router` package. The `PreloadingStrategy` class provides
    a method named `preload`, which has the following signature:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了一种很好的方式来实现我们自己的自定义预加载策略，用于我们的功能模块。我们可以轻松地决定哪些模块应该预加载，哪些不应该。在配方中，我们学习了一种非常简单的方法来配置预加载，即通过在路由配置的`data`对象中添加名为`loadForAdmin`和`loadForEmployee`的属性。我们创建了自己的自定义预加载策略服务，名为`AppPreloadStrategyService`，该服务实现了来自`@angular/router`包的`PreloadingStrategy`接口。`PreloadingStrategy`类提供了一个名为`preload`的方法，该方法具有以下签名：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The argument named `load` is a method from the Angular router that allows us
    to load the component/module by calling it. As a result, it provides an observable.
    Since the `preload` method must return an observable, we return `of(null)` when
    we do not want to preload a route, or we return `load` (which returns an observable)
    when we want to load the component associated with the route. The target in general
    is to have a custom preloading strategy that uses the `preload` method to decide
    whether a route should be preloaded. That is because Angular goes through each
    route using our custom preloading strategy and lets us decide which routes to
    preload. And that is it. We can see if the logged-in user is `admin` and has the
    `loadForAdmin` property in the route’s data, or if the logged-in user is an employee
    and has the `loadForEmployee` property in the route’s data. We then preload the
    route. Otherwise, we don’t. And there’s no preloading when the user is not logged
    in.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为`load`的参数是Angular路由中的一个方法，它允许我们通过调用它来加载组件/模块。因此，它提供了一个可观察对象。由于`preload`方法必须返回一个可观察对象，所以当我们不想预加载一个路由时，我们返回`of(null)`；当我们想加载与路由关联的组件时，我们返回`load`（它返回一个可观察对象）。一般来说，目标是拥有一个自定义预加载策略，该策略使用`preload`方法来决定是否应该预加载路由。这是因为Angular会遍历每个路由，使用我们的自定义预加载策略，并让我们决定哪些路由应该预加载。就是这样。我们可以看到登录用户是否是`admin`并且路由的数据中是否有`loadForAdmin`属性，或者登录用户是否是员工并且路由的数据中是否有`loadForEmployee`属性。然后我们预加载该路由。否则，我们不预加载。当用户未登录时，没有预加载。
- en: See also
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'Route preloading strategies article on `web.dev`: [https://web.dev/route-preloading-in-angular/](https://web.dev/route-preloading-in-angular/)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`web.dev`上的路由预加载策略文章：[https://web.dev/route-preloading-in-angular/](https://web.dev/route-preloading-in-angular/)
- en: 'Route preloading strategies in Angular: [https://www.youtube.com/watch?v=RQGLcMnh9k8](https://www.youtube.com/watch?v=RQGLcMnh9k8)'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular中的路由预加载策略：[https://www.youtube.com/watch?v=RQGLcMnh9k8](https://www.youtube.com/watch?v=RQGLcMnh9k8)
- en: Authorized access to routes using route guards
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路由守卫授权访问路由
- en: Not all routes in your Angular app should be accessible to everyone in the world.
    In this recipe, we’ll learn how to create route guards in Angular to prevent unauthorized
    access to routes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 并非你的Angular应用中的所有路由都应该对世界上所有人可访问。在本配方中，我们将学习如何在Angular中创建路由守卫以防止未经授权访问路由。
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter07/ng-route-guards`
    inside the cloned repository:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆的仓库中的`start/apps/chapter07/ng-route-guards`目录内：
- en: Open the code repository in your code editor.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以运行项目：
- en: '[PRE20]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This should open the app in a new browser tab. You should see the following:'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用。你应该看到以下内容：
- en: '![](img/B18469_07_12.png)'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_07_12.png)'
- en: 'Figure 7.12: ng-route-guards app running on http://localhost:4200'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.12：ng-route-guards应用在http://localhost:4200上运行
- en: Now that we have the app running locally, let’s see the steps of the recipe
    in the next section.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用程序，让我们看看下一节中食谱的步骤。
- en: How to do it…
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We have an app with a couple of routes already set up. You can log in as either
    an employee or an admin to get to the bucket list of the app. However, if you
    tap any of the two buttons in the header, you’ll see that you can navigate to
    the **Admin** and **Employee** sections even without being logged in. This is
    what we want to prevent from happening. Notice in the `auth.service.ts` file that
    we already have a way for the user to log in, and we can check whether the user
    is logged in or not using the `isLoggedIn` method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个应用程序，其中已经设置了一些路由。你可以以员工或管理员的身份登录，以访问应用程序的待办事项列表。然而，如果你点击页眉中的任意一个按钮，你会看到即使没有登录，你也可以导航到**管理员**和**员工**部分。这正是我们想要防止发生的事情。注意在`auth.service.ts`文件中，我们已经有了一种让用户登录的方法，我们可以使用`isLoggedIn`方法来检查用户是否已登录：
- en: 'First, let’s create a route guard that will only allow the user to go to the
    particular routes if the user is logged in. We’ll name it `AuthGuard`. Let’s create
    a new file inside the `auth` folder and name it `auth.guards.ts`. Then add the
    following code:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个路由守卫，它将只允许用户在登录的情况下访问特定的路由。我们将它命名为`AuthGuard`。让我们在`auth`文件夹内创建一个新文件，并将其命名为`auth.guards.ts`。然后添加以下代码：
- en: '[PRE21]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we can add this guard to the routes. Update `app.routes.ts` as follows:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以将这个守卫添加到路由中。按照以下方式更新`app.routes.ts`：
- en: '[PRE22]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you try to go to the Admin or Employee pages without being logged in now,
    you’ll see you are not able to do that anymore thanks to the route guard.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在尝试在不登录的情况下访问管理员或员工页面，你会看到由于路由守卫的存在，你将无法再这样做。
- en: 'Let’s make sure we can’t go to the `auth` page if we’re already logged in.
    Add a function guard in the `auth.guards.ts` file as follows:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们确保如果我们已经登录，我们无法访问`auth`页面。在`auth.guards.ts`文件中添加一个函数守卫，如下所示：
- en: '[PRE23]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you log in, and then click the browser’s **Back** button, you’ll see you
    can’t go back to the `/auth` page either. Even if you open a new tab and go to
    `http://localhost:4200`, you’ll see that it takes you to the correct page based
    on the logged-in user’s type.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你登录，然后点击浏览器的**后退**按钮，你会看到你也不能回到`/auth`页面。即使你打开一个新标签页并访问`http://localhost:4200`，你也会看到它根据登录用户的类型带你到正确的页面。
- en: Great! You now are an authorization expert when it comes to guarding routes.
    With great power comes great responsibility. Use it wisely.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，在路由守卫方面，你已经成为了一名授权专家。权力越大，责任越大。明智地使用它。
- en: How it works…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Angular has switched to functional route guards since Angular v14.2\. This makes
    it much easier to configure the routes compared to the previous version. There
    are many route guards, such as `CanActivate`, `CanDeactivate`, and `CanActivateChildren`.
    The `provideRouter` function used in `main.ts` makes it possible for us to provide
    the routes with functional route guards. A route can take the guards as an array
    against the guard property name. You can see how we provided our `canActivateAdminOrEmployee`
    guard against both the `/employee` and `/admin` routes in *step 2*. A functional
    guard is supposed to return a Boolean value or a `UrlTree`, a **promise** of Boolean
    or `UrlTree`, or an observable of Boolean or `UrlTree`. We’ve focused on the Boolean
    value’s usage in our recipe. In the `canActivateAdminOrEmployee` guard, we check
    if the user is logged in. If that’s true, we allow the route to be activated (i.e.,
    we allow the routing to happen), or we navigate to the `/auth` route. In the `canActivateLogin`
    guard, we do something a bit more complex. Since someone could land on the home
    page (the route is `/`, which redirects to `/auth`), we have to first check if
    the user is logged in, and if that’s the case, then which type of user this is.
    Based on evaluation, we route the user to either the `/employee` or `/admin` route.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从Angular v14.2开始，Angular切换到了功能路由守卫。这使得与之前的版本相比，配置路由变得更加容易。有许多路由守卫，例如`CanActivate`、`CanDeactivate`和`CanActivateChildren`。在`main.ts`中使用的`provideRouter`函数使我们能够提供带有功能路由守卫的路由。一个路由可以将守卫作为数组与守卫属性名称相对。你可以在*步骤2*中看到我们如何为`/employee`和`/admin`路由提供了我们的`canActivateAdminOrEmployee`守卫。功能守卫应该返回一个布尔值或一个`UrlTree`，一个布尔值或`UrlTree`的**promise**，或者一个布尔值或`UrlTree`的可观察对象。在我们的菜谱中，我们专注于布尔值的用法。在`canActivateAdminOrEmployee`守卫中，我们检查用户是否已登录。如果是这样，我们允许路由被激活（即，我们允许路由发生），或者我们导航到`/auth`路由。在`canActivateLogin`守卫中，我们做了一些更复杂的事情。由于有人可能会到达主页（路由是`/`，它重定向到`/auth`），我们必须首先检查用户是否已登录，如果是这样，那么这是哪种类型的用户。基于评估，我们将用户路由到`/employee`或`/admin`路由。
- en: See also
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Preventing unauthorized access in Angular routes: [https://angular.io/guide/router#preventing-unauthorized-access](https://angular.io/guide/router#preventing-unauthorized-access)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular路由中防止未授权访问：[https://angular.io/guide/router#preventing-unauthorized-access](https://angular.io/guide/router#preventing-unauthorized-access)
- en: 'Angular `CanActivateFn` docs: [https://angular.io/api/router/CanActivateFn](https://angular.io/api/router/CanActivateFn
    )'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular `CanActivateFn` 文档：[https://angular.io/api/router/CanActivateFn](https://angular.io/api/router/CanActivateFn)
- en: Working with route parameters
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路由参数进行工作
- en: Whether it is about building a REST API using Node.js or configuring routes
    in Angular, setting up routes is an absolute art, especially when it comes to
    working with parameters. In this recipe, you’ll create some routes with parameters
    and will learn how to get those parameters in your components once the route is
    active.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是使用Node.js构建REST API还是配置Angular的路由，设置路由是一项绝对的艺术，尤其是在处理参数时。在这个菜谱中，你将创建一些带有参数的路由，并学习如何在路由激活后如何在组件中获取这些参数。
- en: Getting ready
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter07/ng-route-params`
    inside the cloned repository:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆的仓库中的`start/apps/chapter07/ng-route-params`目录下：
- en: Open the code repository in your code editor.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以运行项目：
- en: '[PRE24]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This should open the app in a new browser tab. You should see the following:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用。你应该看到以下内容：
- en: '![](img/B18469_07_13.png)'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_07_13.png)'
- en: 'Figure 7.13: The ng-route-params app running on localhost:4200'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.13：在localhost:4200上运行的ng-route-params应用
- en: Now that we have the app running locally, let’s see the steps of the recipe
    in the next section.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用，让我们在下一节中查看菜谱的步骤。
- en: How to do it…
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The problem right now is that we have a route for opening the user details,
    but we don’t see anything, i.e., we have a blank page. That’s because this route
    doesn’t have any idea about which user to show. Wouldn’t it be nice to have a
    way to pass the clicked user’s information from the users list page to the user
    detail page? That’s exactly what we’re going to do in this recipe:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 目前的问题是，我们有一个用于打开用户详情的路由，但我们看不到任何内容，即我们有一个空白页面。这是因为这个路由没有任何关于要显示哪个用户的想法。如果有一种方法可以从用户列表页面传递点击的用户信息到用户详情页面不是很好吗？这正是我们将在本菜谱中要做的：
- en: 'First, we have to make our user route capable of accepting the `route` parameter.
    This is going to be a `required` parameter, which means the route will not work
    without passing this. Let’s modify `app.routes.ts` to add this required parameter
    to the route definition, as follows:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We’ll now update the `src/app/components/users-list/users-list.component.html`
    file to change the links to use the `uuid` as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We’re now able to navigate to a particular user’s route using the `uuid`, and
    you should also be able to see it in the address bar as follows:'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_07_14.png)'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 7.14: The UUID being shown in the address bar'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To get the user from `UserService` based on the `uuid`, we need to get the
    `uuid` value in `UserDetailsComponent` from the route parameters. Let’s update
    the `user-details.component.ts` as follows:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You should be able to see the user we clicked from the `/users` page now. The
    only thing remaining is showing similar users.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Instead of creating another subscription, we can tap into the one we created
    in the previous step using the `tap` operator from RxJS. Update the `user-details.component.ts`
    file further, as follows:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And boom, you should be able to see both the clicked user and similar users,
    as follows:'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_07_15.png)'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 7.15: The UUID being shown in the address bar'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Great! With this change, you can try refreshing the app on the home page and
    then click any user. You should see the current user as well as similar users
    being loaded. To understand all the magic behind the recipe, see the next section.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It all begins when we change our route’s path to `user/:userId`. This makes
    `userId` a parameter for our route. The other piece of the puzzle is to retrieve
    this parameter in `UserDetailsComponent` and then use it to get the target user,
    as well as similar users. For that, we use the `ActivatedRoute` service. The `ActivatedRoute`
    service holds a lot of necessary information about the current route and, therefore,
    we were able to fetch the current route’s `uuid` parameter by subscribing to the
    `paramMap` observable, so even if the parameter changes while staying on a user’s
    page, we still execute the necessary operations. The `ActivatedRoute` also has
    a `queryParamMap` observable, but it works for query parameters instead of route
    parameters. And if you don’t want to subscribe to the `paramMap` observable and
    just want the value to appear once inside `ngOnInit` or in the constructor, you
    can also use the `snapshot` property on the `ActivatedRoute` object as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that with the `paramMap` observable, we also use the `tap` operator to
    do something extra. That is assigning the value of similar users to the desired
    observable. Since both of the observables are only used in the template with the
    `async` pipe, there is no need to unsubscribe them ourselves as Angular takes
    care of it. Also, if you re-assign a new observable to a property being used by
    the `async` pipe, it automatically subscribes to the new one and cancels the previous
    subscription.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can also provide resolved values from the route definition directly
    to the component as `@Input()` properties using the `bindToComponentInputs` or
    `withComponentInputBinding` properties introduced in v16 for the Angular Router
    for Angular modules and standalone components, respectively. See the next section
    for relevant links including an article explaining the use of `withComponentInputBinding`
    as well.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Accessing* *query parameters and fragments*: [https://angular.io/guide/router#accessing-query-parameters-and-fragments](https://angular.io/guide/router#accessing-query-parameters-and-fragments)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Getting route* *information* – Angular docs: [https://angular.io/guide/router#getting-route-information](https://angular.io/guide/router#getting-route-information)'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Bind Route Info* *to Component Inputs (New Router feature)*: [https://itnext.io/bind-route-info-to-component-inputs-new-router-feature-1d747e559dc4](https://itnext.io/bind-route-info-to-component-inputs-new-router-feature-1d747e559dc4)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing a global loader between route changes
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building user interfaces that are snappy and fast is key to winning users. The
    apps become much more enjoyable for the end users, and it could bring a lot of
    value to the owners/creators of the apps. One of the core experiences on the modern
    web is to show a loader when something is happening in the background. In this
    recipe, you’ll learn how to create a global user interface loader in your Angular
    app that shows whenever there is a route transition in the app.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter07/ng-global-loader`
    inside the cloned repository:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This should open the app in a new browser tab and you should see the following:'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_07_16.png)'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 7.16: ng-global-loader app running on http://localhost:4200'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let’s see the steps of the recipe
    in the next section.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you try logging in or logging out, you’ll see that it takes a while before
    the route changes. We’re simulating a delay in route change manually in the `canActivateLogin`
    route guard in the `start/apps/chapter07/ng-global-loader/src/app/auth/auth.guard.ts`
    file, which uses the `delay` operator from RxJS in an observable chain before
    checking if the user is logged in, and the type of user. The intention is to simulate
    the use cases where you need to route based on an HTTP call. In this recipe, we
    have the `LoaderComponent` already created, which we must use during the route
    changes:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试登录或登出，你会注意到路由变化需要一段时间。我们在 `start/apps/chapter07/ng-global-loader/src/app/auth/auth.guard.ts`
    文件中的 `canActivateLogin` 路由守卫中手动模拟了路由变化的延迟，该文件使用 RxJS 的 `delay` 操作符在一个可观察链中，在检查用户是否登录以及用户的类型之前。目的是模拟需要基于
    HTTP 调用来路由的使用场景。在这个食谱中，我们已经创建了 `LoaderComponent`，我们必须在路由变化期间使用它：
- en: 'We’ll begin by adding a new property in the `app.component.ts` that says `isRouting`.
    We’ll initialize it as `true` for now. We’ll also import the `LoaderComponent`
    class in the `AppComponent` class’s `imports` so we can use it in the template.
    Update the file as follows:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先在 `app.component.ts` 中添加一个新的属性 `isRouting`。我们将其初始化为 `true`。我们还在 `AppComponent`
    类的 `imports` 中导入 `LoaderComponent` 类，这样我们就可以在模板中使用它。按照以下方式更新文件：
- en: '[PRE31]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we’ll add the loader in the `app.component.html` to show it conditionally,
    and we’ll wrap the entire app content in another variable. Update the file as
    follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在 `app.component.html` 中添加加载器以有条件地显示它，并将整个应用内容包裹在另一个变量中。按照以下方式更新文件：
- en: '[PRE32]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You should be able to see the loader consistently on the screen now, on every
    route. However, we want to make it work with the Angular Router.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你现在应该能够在每个路由上，在屏幕上持续看到加载器。然而，我们希望它与 Angular 路由一起工作。
- en: 'We’ll now update the `app.component.ts` file to listen to the router service’s
    `events` property, and take an action upon the `NavigationStart` event. Modify
    the code in the `app.component.ts` file as follows:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将更新 `app.component.ts` 文件以监听路由服务的 `events` 属性，并在 `NavigationStart` 事件上采取行动。按照以下方式修改
    `app.component.ts` 文件中的代码：
- en: '[PRE33]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you refresh the app, you’ll notice that `<app-loader>` still never goes away.
    That’s because we’re not marking the `isRouting` property as `false` anywhere.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你刷新应用，你会注意到 `<app-loader>` 从未消失。这是因为我们没有在任何地方将 `isRouting` 属性标记为 `false`。
- en: 'To mark `isRouting` as `false`, we need to check for three different events:
    `NavigationEnd`, `NavigationError`, and `NavigationCancel`. Let’s add some more
    logic to handle these three events and mark the property as `false`:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将 `isRouting` 标记为 `false`，我们需要检查三个不同的事件：`NavigationEnd`、`NavigationError` 和
    `NavigationCancel`。让我们添加一些额外的逻辑来处理这三个事件并将属性标记为 `false`：
- en: '[PRE34]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We now have a global loader that shows during the route navigation among different
    pages.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们有一个在页面间导航时显示的全局加载器。
- en: Congrats on finishing the recipe. You now can implement a global loader in Angular
    apps, which will show from the navigation start to the navigation end.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你完成了食谱。现在你可以在 Angular 应用中实现一个全局加载器，它将从导航开始显示到导航结束。
- en: How it works…
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The router service is a very powerful service in Angular. It has a lot of methods
    as well as observables that we can use for different tasks in our apps. For this
    recipe, we used the `events` observable. By subscribing to the `events` observable,
    we can listen to all the events that the `Router` service emits through the observable.
    One of the most common use cases for this (especially being a **Single-Page Application**
    (**SPA**)) is tracking page visits with Google Analytics or Mixpanel. For this
    recipe, we were only interested in the `NavigationStart`, `NavigationEnd`, `NavigationError`,
    and `NavigationCancel` events. The `NavigationStart` event is emitted when the
    router starts navigation. The `NavigationEnd` event is emitted when the navigation
    ends successfully. The `NavigationCancel` event is emitted when the navigation
    is canceled due to a route guard returning `false`, or redirects by using `UrlTree`
    due to some reason. The `NavigationError` event is emitted when there’s an error
    due to any reason during the navigation. All of these events are of the `Event`
    type and we can identify the type of the event by checking whether it is an instance
    of the target event, using the `instanceof` keyword. Notice that since we had
    the subscription to the `Router.events` property in `AppComponent`, we didn’t
    have to worry about unsubscribing the subscription because there’s only one subscription
    in the app, and `AppComponent` will not be destroyed throughout the life cycle
    of the app.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Router events docs: [https://angular.io/guide/router#router-events](https://angular.io/guide/router#router-events)'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Router service docs: [https://angular.io/api/router/Router](https://angular.io/api/router/Router)'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/AngularCookbook2e](Chapter_7.xhtml)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1388317275422265.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
