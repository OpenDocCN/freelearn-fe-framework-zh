<html><head></head><body>
  <div id="_idContainer122" class="Basic-Text-Frame">
    <h1 class="chapterNumber">14</h1>
    <h1 id="_idParaDest-186" class="chapterTitle">Unit Testing in React</h1>
    <p class="normal">Although testing is an integral part of the software development process, developers and companies often pay surprisingly little attention to it in reality, especially to automated testing. In this chapter, we will try to understand why it is important to pay attention to testing and what advantages it gives. We will also explore the basics of unit testing in ReactJS, including general testing theory, tools, and methods, as well as specific aspects of testing ReactJS components.</p>
    <p class="normal">In this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bulletList">Testing in general</li>
      <li class="bulletList">Unit testing</li>
      <li class="bulletList">Testing ReactJS</li>
    </ul>
    <h1 id="_idParaDest-187" class="heading-1">Technical requirements </h1>
    <p class="normal">You can find the code files of this chapter on GitHub at <a href="https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter14"><span class="url">https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter14</span></a>.</p>
    <h1 id="_idParaDest-188" class="heading-1">Testing in general</h1>
    <p class="normal"><strong class="keyWord">Software testing</strong> is a process <a id="_idIndexMarker495"/>aimed at identifying errors and verifying the functionality of a product to ensure its quality. Testing also allows developers and testers to assess the system’s behavior under various conditions and to ensure that new changes have not led to regression, meaning they have not disrupted existing functionality.</p>
    <p class="normal">The testing process includes a series of actions conducted to detect and identify any aspects that do not meet requirements or expectations. One example of such an action could be <strong class="keyWord">manual testing</strong>, where a <a id="_idIndexMarker496"/>developer or tester manually checks the application. However, this approach is time-consuming and provides little guarantee that the application is secure and free of critical errors in operation.</p>
    <p class="normal">To ensure a higher <a id="_idIndexMarker497"/>level of application reliability while saving time on testing, there are <strong class="keyWord">automated tests</strong>. They allow the functionality of the application to be verified without human intervention.</p>
    <p class="normal">An automated test typically consists of a set of predefined tests and a software product, often referred <a id="_idIndexMarker498"/>to as a <strong class="keyWord">runner</strong>, which launches these tests and analyzes the results to determine the success or failure of each test. In addition to this, automated tests can be used to check performance, stability, security, availability, and compatibility, allowing you to write truly stable, large, and successful projects. That’s why it’s never a good idea to avoid tests; on the contrary, it’s worth getting to know them better and trying to use them in all possible projects.</p>
    <p class="normal">As developers, we are obviously more interested in automated testing than manual testing, so this chapter will focus on that. But before that, let’s briefly look at the approaches to testing and the types of tests that exist.</p>
    <h2 id="_idParaDest-189" class="heading-2">Test types and approaches</h2>
    <p class="normal">Software testing <a id="_idIndexMarker499"/>can be classified by various criteria, including the level of <a id="_idIndexMarker500"/>testing and the objectives it pursues.</p>
    <p class="normal">Typically, the following types of tests are distinguished:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Unit testing</strong>: Testing <a id="_idIndexMarker501"/>individual modules or components <a id="_idIndexMarker502"/>of the program for correct operation. Unit tests are usually written and executed by developers to check specific functions or methods. Such tests are generally quick to write and can be executed quickly, but they do not test the final application for critical bugs, as the tested and stable components themselves may have problems when interacting with each other. An example of a unit test would be checking the functionality of a single function, React component, or Hook.</li>
      <li class="bulletList"><strong class="keyWord">Integration testing</strong>: Testing <a id="_idIndexMarker503"/>in which we check <a id="_idIndexMarker504"/>the interaction between various modules or system components. The goal is to detect defects in the interfaces and interactions between integrated components. This type of testing is usually conducted on the server side to ensure that all systems work smoothly together and that the business logic meets the specified requirements. 
    <p class="bulletList">For example, an integration test would be one that checks that user <a id="_idIndexMarker505"/>registration works by making real calls to REST API <a id="_idIndexMarker506"/>endpoints and checking the returned data. Such a test depends less on the application’s implementation and code and more on checking behavior and business logic.</p> </li>
    </ul>
    <ul>
      <li class="bulletList"><strong class="keyWord">End-to-end (E2E) testing</strong>: Testing a complete and integrated software system <a id="_idIndexMarker507"/>to ensure that it meets specified requirements. E2E testing evaluates the program as a whole. This type of <a id="_idIndexMarker508"/>testing is the most reliable, as it completely abstracts from the application’s implementation and checks the final behavior by interacting directly with the application itself. In the process of such testing, for example, in a web application, a real browser is launched in a special environment, in which a script performs real actions with the application like clicking buttons, filling out forms, and navigating through pages. </li>
    </ul>
    <p class="normal">Although test types such as integration and E2E testing provide greater confidence in verifying the <a id="_idIndexMarker509"/>quality of an application, they come with drawbacks such as complexity and speed of test development, execution speed, and consequently, their costliness. Therefore, it is <a id="_idIndexMarker510"/>considered good practice to maintain a balance where preference is given to unit tests, as they are easier to maintain and faster to run. Then, all main business processes and logic are verified using integration tests, and E2E tests cover only the most critical business cases. This approach can be depicted in the form of a pyramid:</p>
    <figure class="mediaobject"><img src="../Images/B19636_14_01.png" alt="Picture 1"/></figure>
    <p class="packt_figref">Figure 14.1: Test pyramid</p>
    <p class="normal">The pyramid perfectly describes the approach we have discussed above. At its base lies <strong class="keyWord">unit</strong> testing, which should <a id="_idIndexMarker511"/>cover the application’s source code as extensively <a id="_idIndexMarker512"/>as possible. It has the lowest cost of development and maintenance, as well as the highest test execution performance. In the middle are the <strong class="keyWord">integration</strong> tests, which are quite fast but more expensive to develop. At the very top, we have the <strong class="keyWord">E2E</strong> tests, which take the longest to execute and are the most expensive to develop, but they provide the maximum confidence in the quality of the product being tested.</p>
    <p class="normal">Since integration and E2E tests abstract away from the implementation, and thus from the programming language or libraries used in the application, we are not going to cover those types of testing. Therefore, let’s focus in more detail on unit testing. </p>
    <h1 id="_idParaDest-190" class="heading-1">Unit testing</h1>
    <p class="normal">We already know <a id="_idIndexMarker513"/>that unit testing is the process of verifying the correctness of individual “<strong class="keyWord">units</strong>” of code: namely, <strong class="keyWord">functions</strong> and <strong class="keyWord">methods</strong>. The goal of unit testing is to ensure that each separate unit performs its task correctly, which, in turn, increases confidence in the reliability of the entire application.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a: number, b: number</span>): number {
  <span class="hljs-keyword">return</span> a + b;
}
<span class="hljs-title">test</span>('adds <span class="hljs-number">1</span> + <span class="hljs-number">2</span> to equal <span class="hljs-number">3</span>', <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title">expect</span>(<span class="hljs-title">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)).<span class="hljs-title">toBe</span>(<span class="hljs-number">3</span>);
});
</code></pre>
    <p class="normal">The above represents the most basic and simplest test of a function that adds two values. The test code itself is a function that calls a special method, <code class="inlineCode">expect</code>, which takes a value and then has a series of methods allowing for the checking and comparing of results.</p>
    <p class="normal">Looking at this code, the first question that might come to mind is, is it really necessary to write another three lines of tests for such a simple three-line function? And why test such a function at all? I would answer with a definitive <em class="italic">yes</em>. It often happens that a function can be <a id="_idIndexMarker514"/>covered by a test that is larger in volume than the function itself, and there is nothing wrong with that. Let’s understand why.</p>
    <p class="normal">Unit testing is most useful and effective when you are testing <strong class="keyWord">pure functions</strong>, which have no side effects and do not depend on external state. Conversely, unit testing is useless when the function being tested can change its behavior due to external factors or simply because that’s how the function was designed. For example, functions for requesting data from the server, getting data from <code class="inlineCode">localStorage</code>, or relying on global variables might return different results for the same input. From this, we can conclude that in an application development approach that requires code coverage with tests, you will automatically strive <a id="_idIndexMarker515"/>to write <strong class="keyWord">testable code</strong>, meaning more modular, independent, clean, and scalable code. This becomes especially noticeable on large projects. If tests were written from the start, such projects could continue to grow without the need for major refactoring or rewriting functionality from scratch. Also, in projects with tests, it is easier for newcomers to understand, as tests can serve as additional documentation for modules, reading which one can understand what the module is responsible for and what behavior it possesses.</p>
    <p class="normal">For writing unit tests, there are entire concepts and methodologies. The main and most popular one is the traditional coverage of tests after code development. The advantage of this approach is the speed of development of the main functionality, as tests are usually dealt with later. Hence, the problem with this approach lies in delaying testing, which poses a risk of accumulating code that is not covered by tests. Later, when writing tests, it often becomes necessary to correct the main code, making it more modular and cleaner, which takes additional time.</p>
    <p class="normal">There is also a methodology directly aimed at writing tests, called <strong class="keyWord">test-driven development</strong> (<strong class="keyWord">TDD</strong>). This is <a id="_idIndexMarker516"/>a software development methodology in which tests are written before the code itself. The benefit of this approach is that your code will be immediately covered by tests, meaning it will be cleaner and more reliable. However, this approach may not be suitable for prototyping or for projects where requirements often change.</p>
    <p class="normal">The choice between TDD and testing after development depends on many factors, including the team’s culture, project requirements, and developers’ preferences. It is important to understand that neither approach is a universal solution, and different choices may be <a id="_idIndexMarker517"/>justified in different situations. Most importantly, understand the importance of testing and that one should avoid an approach in work where tests are not written at all as, in most cases, such code is doomed to be rewritten from scratch.</p>
    <p class="normal">Now that we understand what unit tests are and their importance, let’s take a closer look at them. Before writing tests, we should set up the environment in which we will run our tests. </p>
    <h2 id="_idParaDest-191" class="heading-2">Setting up the test environment</h2>
    <p class="normal">The most popular framework for writing <a id="_idIndexMarker518"/>and running unit tests is <strong class="keyWord">Jest</strong>. However, we will look at its <a id="_idIndexMarker519"/>more performant <a id="_idIndexMarker520"/>alternative, which is fully compatible with <strong class="keyWord">Vite</strong>, called <strong class="keyWord">Vitest</strong>. To install Vitest in your project, you need to execute this command:</p>
    <pre class="programlisting con"><code class="hljs-con">npm install -D vitest
</code></pre>
    <p class="normal">For basic <a id="_idIndexMarker521"/>operation, Vitest does not require any configuration, as it is fully compatible with the Vite configuration file.</p>
    <p class="normal">Next, to get started, we need to create a file with the extension <code class="inlineCode">*.test.ts</code>. The location of the file is not critical; the main thing is that the file is inside your project. Usually, test files are associated with the files of the functions being tested and are placed in the same directory; for example, for the <code class="inlineCode">sum</code> function located in the <code class="inlineCode">sum.ts</code> file, a file with a test named <code class="inlineCode">sum.test.ts</code> is created and located in the same folder.</p>
    <p class="normal">To run the tests, we need to add a launch script to the <code class="inlineCode">package.json</code> file:</p>
    <pre class="programlisting code"><code class="hljs-code">{
  "scripts": {
    "test": "vitest"
  }
}
</code></pre>
    <p class="normal">Then, to call it, just execute the command in the terminal:</p>
    <pre class="programlisting con"><code class="hljs-con">npm run test
</code></pre>
    <p class="normal">This command will start the Vitest process, which will scan the project for files with the <code class="inlineCode">.test</code>. extension and then execute all the tests in each such file. Once all tests are completed, you will see the result in the terminal window, and then the process will wait for <a id="_idIndexMarker522"/>changes in the test files to rerun them. This is specifically designed as a mode for developing tests, where you do not need to constantly run the test command. For a one-time test run, you can add another command that will close the process upon completion of testing:</p>
    <pre class="programlisting con"><code class="hljs-con">"test:run": "vitest run"
</code></pre>
    <p class="normal">The <code class="inlineCode">run</code> parameter is precisely for telling Vitest that you want to run the tests only once.</p>
    <h2 id="_idParaDest-192" class="heading-2">Vitest features</h2>
    <p class="normal">Let’s now look at the main features of Vitest and the types of tests we can write. Let’s start <a id="_idIndexMarker523"/>with a simple function, <code class="inlineCode">squared</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title">squared</span> = (<span class="hljs-params">n: number</span>) =&gt; n * n
</code></pre>
    <p class="normal">This function <a id="_idIndexMarker524"/>returns the square of a number. Here is what the test for this function would look like:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { expect, test } <span class="hljs-keyword">from</span> 'vitest'
<span class="hljs-title">test</span>('<span class="hljs-title">Squared</span>', <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title">expect</span>(<span class="hljs-title">squared</span>(<span class="hljs-number">2</span>)).<span class="hljs-title">toBe</span>(<span class="hljs-number">4</span>)
  <span class="hljs-title">expect</span>(<span class="hljs-title">squared</span>(<span class="hljs-number">4</span>)).<span class="hljs-title">toBe</span>(<span class="hljs-number">16</span>)
  <span class="hljs-title">expect</span>(<span class="hljs-title">squared</span>(<span class="hljs-number">25</span>)).<span class="hljs-title">toBe</span>(<span class="hljs-number">625</span>)
})
</code></pre>
    <p class="normal">The <code class="inlineCode">test</code> and <code class="inlineCode">expect</code> functions are part of the Vitest package. The test function takes the name of the test as its first argument and the test function itself as its second argument. The <code class="inlineCode">expect</code> method serves as the basis for checking the expected result from the function being tested. Calling the <code class="inlineCode">expect</code> method creates an object that contains a large number of methods, allowing for different ways to check the execution result. In our example, we explicitly compare the result of executing the <code class="inlineCode">squared</code> function with the expected value.</p>
    <p class="normal">By running this test, in the terminal window, we will see the following message:</p>
    <pre class="programlisting con"><code class="hljs-con">✓ test/basic.test.ts (1)
   ✓ Squared
 Test Files  1 passed (1)
      Tests  1 passed (1)
   Start at  17:39:33
   Duration  1.14s
</code></pre>
    <p class="normal">To check that <a id="_idIndexMarker525"/>the tests are working correctly, let’s change the expected <a id="_idIndexMarker526"/>value from <code class="inlineCode">4</code> and see what result we get:</p>
    <pre class="programlisting con"><code class="hljs-con">FAIL  test/basic.test.ts &gt; Squared
AssertionError: expected 4 to be 5 // Object.is equality
- Expected
+ Received
 ❯ eval test/basic.test.ts:13:22
     11| 
     12| test('Squared', () =&gt; {
     13|   expect(squared(2)).toBe(5);
       |                      ^
     14|   expect(squared(4)).toBe(16);
     15|   expect(squared(25)).toBe(625);
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[1/1]⎯
 Test Files  1 failed (1)
      Tests  1 failed (1)
   Start at  17:41:45
   Duration  1.15s
</code></pre>
    <p class="normal">When a test fails, we can see directly in the results where the error occurred, what result we received, and what we expected. </p>
    <p class="normal">The <code class="inlineCode">toBe</code> method is very useful for direct comparison of results, but what about objects and arrays? Let’s consider this test example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">test</span>('objects', <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> obj1 = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> };
  <span class="hljs-keyword">const</span> obj2 = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> };
  <span class="hljs-title">expect</span>(obj1).<span class="hljs-property">not</span>.<span class="hljs-title">toBe</span>(obj2);
  <span class="hljs-title">expect</span>(obj1).<span class="hljs-title">toEqual</span>(obj2);
});
</code></pre>
    <p class="normal">In this test, we created two identical objects, which will not be equal as variables. To expect the opposite assertion, we use the additional <code class="inlineCode">.not.</code> key, which ultimately gives us the statement that the two variables are not equal to each other. If we still want to check that <a id="_idIndexMarker527"/>the objects have the same structure, there is a method called <code class="inlineCode">toEqual</code>, which recursively compares objects. This method also works similarly with arrays.</p>
    <p class="normal">For arrays, there are <a id="_idIndexMarker528"/>also additional methods that allow checking for the presence of an element, which is often very useful:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">test</span>('<span class="hljs-title">Array</span>', <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title">expect</span>(['<span class="hljs-number">1</span>', '<span class="hljs-number">2</span>', '<span class="hljs-number">3</span>']).<span class="hljs-title">toContain</span>('<span class="hljs-number">3</span>');
});
</code></pre>
    <p class="normal">The <code class="inlineCode">toContain</code> method can also work with strings and even DOM elements, checking for the presence of a class in <code class="inlineCode">classList</code>.</p>
    <p class="normal">The next big <a id="_idIndexMarker529"/>part of unit testing is working with functions. Vitest allows you to create <strong class="keyWord">spyable fake functions</strong>, which lets you check how and with what parameters this function was called. Let’s look at an example function:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">selector</span> = (<span class="hljs-params">onSelect: (value: string) =&gt; </span><span class="hljs-keyword">void</span>) =&gt; {
  <span class="hljs-title">onSelect</span>('<span class="hljs-number">1</span>');
  <span class="hljs-title">onSelect</span>('<span class="hljs-number">2</span>');
  <span class="hljs-title">onSelect</span>('<span class="hljs-number">3</span>');
};
</code></pre>
    <p class="normal">This function is created just for demonstration, but we can easily imagine some module or selector component that takes the <code class="inlineCode">onSelect</code> callback, which will be called under some condition: in our case, three times in a row. Now let’s see how we can test using observable functions:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">test</span>('selector', <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> onSelect = vi.<span class="hljs-title">fn</span>();
  <span class="hljs-title">selector</span>(onSelect);
  <span class="hljs-title">expect</span>(onSelect).<span class="hljs-title">toBeCalledTimes</span>(<span class="hljs-number">3</span>);
  <span class="hljs-title">expect</span>(onSelect).<span class="hljs-title">toHaveBeenLastCalledWith</span>('<span class="hljs-number">3</span>');
});
</code></pre>
    <p class="normal">In the test, we created the <code class="inlineCode">onSelect</code> function using the <code class="inlineCode">vi</code> module from the <code class="inlineCode">Vitest</code> package. This function now allows us to check how many times it was called and with what arguments. For this, we used the methods <code class="inlineCode">toBeCalledTimes</code> and <code class="inlineCode">toHaveBeenLastCalledWith</code>. There is also a method called <code class="inlineCode">toHaveBeenCalledWith</code>, which can <a id="_idIndexMarker530"/>step-by-step check which arguments were used on <a id="_idIndexMarker531"/>each call of the observed function. In our case, the valid checks would be these three lines:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-title">expect</span>(onSelect).<span class="hljs-title">toHaveBeenCalledWith</span>('<span class="hljs-number">1</span>');
  <span class="hljs-title">expect</span>(onSelect).<span class="hljs-title">toHaveBeenCalledWith</span>('<span class="hljs-number">2</span>');
  <span class="hljs-title">expect</span>(onSelect).<span class="hljs-title">toHaveBeenCalledWith</span>('<span class="hljs-number">3</span>');
</code></pre>
    <p class="normal">Vitest also allows you to spy a real function, for which you need to use the <code class="inlineCode">vi.spyOn</code> method. However, for this, the function must be accessible from an object. Let’s look at an example of spying on a real function:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">test</span>('spyOn', <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> cart = {
    <span class="hljs-attr">getProducts</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-number">10</span>,
  };
  <span class="hljs-keyword">const</span> spy = vi.<span class="hljs-title">spyOn</span>(cart, 'getProducts');
  <span class="hljs-title">expect</span>(cart.<span class="hljs-title">getProducts</span>()).<span class="hljs-title">toBe</span>(<span class="hljs-number">10</span>);
  <span class="hljs-title">expect</span>(spy).<span class="hljs-title">toHaveBeenCalled</span>();
  <span class="hljs-title">expect</span>(spy).<span class="hljs-title">toHaveReturnedWith</span>(<span class="hljs-number">10</span>);
});
</code></pre>
    <p class="normal">To create an observation for a function, we call <code class="inlineCode">vi.spyOn</code> and pass it the object as the first argument and the name of the method as the second. Then, we can work with the original function and, later, make the necessary checks working with the <code class="inlineCode">spy</code> variable. In the example above, you can also notice the new method <code class="inlineCode">toHaveReturnedWith</code>, which allows you to check what the observed function returned.</p>
    <h2 id="_idParaDest-193" class="heading-2">Mocking</h2>
    <p class="normal">Moving on, I’d like to mention one of the most challenging parts of unit testing: namely, working with functions that have side effects or depend on external data or libraries. Earlier, I mentioned <a id="_idIndexMarker532"/>that testing is useless in functions with side effects, like calling something under the hood. Actually, that’s not entirely true. In some cases, it’s simply <a id="_idIndexMarker533"/>impossible to write a pure function, but that doesn’t mean it can’t be tested. To write tests for such functions, we can use <strong class="keyWord">mocking</strong>: namely, emulating external behavior or simply replacing the implementation of some modules or libraries. </p>
    <p class="normal">An example could be a function that depends on the system time of the computer, or a function that returns data from a server. In such cases, we can apply a fake instruction that can change the current date of the computer specifically for this test, to have a clean result that is easier to test. Similarly, it is possible to create a fake implementation of a network request, which will ultimately be executed locally with the return of predetermined values. Let’s discuss some of these scenarios in this section.</p>
    <p class="normal">Consider the example of testing and using <strong class="keyWord">timers</strong>. In the testing environment, we can avoid waiting for timers and manually control them to more thoroughly test the behavior of the function. Let’s look at an example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span> <span class="hljs-title">executeInMinute</span>(<span class="hljs-params">func: () =&gt; </span><span class="hljs-keyword">void</span>) {
  <span class="hljs-built_in">setTimeout</span>(func, <span class="hljs-number">1000</span> * <span class="hljs-number">60</span>)
}
<span class="hljs-keyword">function</span> <span class="hljs-title">executeEveryMinute</span>(<span class="hljs-params">func: () =&gt; </span><span class="hljs-keyword">void</span>) {
  <span class="hljs-built_in">setInterval</span>(func, <span class="hljs-number">1000</span> * <span class="hljs-number">60</span>)
}
<span class="hljs-keyword">const</span> mock = vi.<span class="hljs-title">fn</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>('done'))
</code></pre>
    <p class="normal">We created the <code class="inlineCode">executeInMinute</code> and <code class="inlineCode">executeEveryMinute</code> functions for delaying the call of a function by one minute and for cyclic execution every minute, respectively. We also created a mock function that we will subsequently spy on. Here’s what the test will look like:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">describe</span>('delayed execution', <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title">beforeEach</span>(<span class="hljs-function">() =&gt;</span> {
    vi.<span class="hljs-title">useFakeTimers</span>()
  })
  <span class="hljs-title">afterEach</span>(<span class="hljs-function">() =&gt;</span> {
    vi.<span class="hljs-title">restoreAllMocks</span>()
  })
  <span class="hljs-title">it</span>('should execute the <span class="hljs-keyword">function</span>', <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title">executeInMinute</span>(mock)
    vi.<span class="hljs-title">runAllTimers</span>()
    <span class="hljs-title">expect</span>(mock).<span class="hljs-title">toHaveBeenCalledTimes</span>(<span class="hljs-number">1</span>)
  })
  <span class="hljs-title">it</span>('should not execute the <span class="hljs-keyword">function</span>', <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title">executeInMinute</span>(mock)
    vi.<span class="hljs-title">advanceTimersByTime</span>(<span class="hljs-number">2</span>)
    <span class="hljs-title">expect</span>(mock).<span class="hljs-property">not</span>.<span class="hljs-title">toHaveBeenCalled</span>()
  })
  
  <span class="hljs-title">it</span>('should execute every minute', <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title">executeEveryMinute</span>(mock)
    vi.<span class="hljs-title">advanceTimersToNextTimer</span>()
    <span class="hljs-title">expect</span>(mock).<span class="hljs-title">toHaveBeenCalledTimes</span>(<span class="hljs-number">1</span>)
    vi.<span class="hljs-title">advanceTimersToNextTimer</span>()
    <span class="hljs-title">expect</span>(mock).<span class="hljs-title">toHaveBeenCalledTimes</span>(<span class="hljs-number">2</span>)
  })
})
</code></pre>
    <p class="normal">In this example, there’s a lot to discuss but let’s start with the fact that we didn’t use the <code class="inlineCode">test</code> function; instead, we used <code class="inlineCode">describe</code> and <code class="inlineCode">it</code>. The <code class="inlineCode">describe</code> function allows us to create a test <a id="_idIndexMarker534"/>suite that can have its own context and lifecycle. In the test suite, we can set initial parameters or mock some behavior so that our test cases can reuse this <a id="_idIndexMarker535"/>context and these parameters later on. In our example, we use the <code class="inlineCode">beforeEach</code> and <code class="inlineCode">afterEach</code> methods, which set up fake timers before each test and then restore everything back to its original state after each test.</p>
    <p class="normal">The <code class="inlineCode">it</code> method is an alias for the <code class="inlineCode">test</code> method and does not differ functionally from it. It’s only there to make the test case more readable in the results. For example, <code class="inlineCode">describe</code> with ‘<code class="inlineCode">delayed execution</code>' and <code class="inlineCode">it</code> with ‘<code class="inlineCode">should execute the function</code>' in the results would look like this: </p>
    <pre class="programlisting con"><code class="hljs-con">delayed execution &gt; should execute the function
</code></pre>
    <p class="normal">However, using <code class="inlineCode">test</code>, we would see the result as:</p>
    <pre class="programlisting con"><code class="hljs-con">delayed execution &gt; if should execute the function
</code></pre>
    <p class="normal">Now, let’s look at the tests themselves. The first test uses the <code class="inlineCode">executeInMinute</code> function, which, in reality, would call our observed method only after a minute, but in the test, we can control time. By using <code class="inlineCode">vi.runAllTimers()</code>, we force the environment to start and skip all timers and immediately check the result. In the next test, we move time forward by 2 milliseconds using <code class="inlineCode">vi.advanceTimersByTime(2)</code>, which already allows us to ensure that the original function will not be called.</p>
    <p class="normal">Next, let’s discuss the <code class="inlineCode">executeEveryMinute</code> method, which should start a timer with a call to an argument every minute. In this case, we can step through each iteration of this timer using <code class="inlineCode">advanceTimersToNextTimer</code>, giving us precise control over time without having to wait in real time.</p>
    <p class="normal">When writing unit tests, we will often encounter that the function being tested will depend on <a id="_idIndexMarker536"/>some library or even a package. </p>
    <p class="normal">Most often, you will encounter this in React Native, if a library or some method uses the device’s native functions. In such <a id="_idIndexMarker537"/>a case, to write a test, we need to create a mock version of this logic that will be called during the test.</p>
    <p class="normal">Let’s consider a simple example where we imagine that we have a package that can interact with the device and get the current number of steps. To obtain the steps, we’ll use the <code class="inlineCode">getSteps</code> function:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title">getSteps</span>() {
  <span class="hljs-comment">// SOME NATIVE LOGIC</span>
  <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;
}
</code></pre>
    <p class="normal">As an example, the function itself will be very simple and will just return the value of <code class="inlineCode">100</code>. However, in reality, such a function would interact with a smartphone API, which would be impossible to invoke within the scope of testing. Next, let’s look at what we can do when writing a test:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { beforeAll, describe, expect, it, vi } <span class="hljs-keyword">from</span> 'vitest';
<span class="hljs-keyword">import</span> { getSteps } <span class="hljs-keyword">from</span> './ios-health-kit';
<span class="hljs-title">describe</span>('<span class="hljs-variable">IOS</span> <span class="hljs-title">Health</span> <span class="hljs-title">Kit</span>', <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title">beforeAll</span>(<span class="hljs-function">() =&gt;</span> {
    vi.<span class="hljs-title">mock</span>('./ios-health-kit', <span class="hljs-function">() =&gt;</span> ({
      <span class="hljs-attr">getSteps</span>: vi.<span class="hljs-title">fn</span>().<span class="hljs-title">mockImplementation</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-number">2000</span>),
    }));
  });
  <span class="hljs-title">it</span>('should <span class="hljs-keyword">return</span> steps', <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title">expect</span>(<span class="hljs-title">getSteps</span>()).<span class="hljs-title">toBe</span>(<span class="hljs-number">2000</span>);
    <span class="hljs-title">expect</span>(getSteps).<span class="hljs-title">toHaveBeenCalled</span>();
  });
});
</code></pre>
    <p class="normal">The test and the entire example are quite primitive but they will give you an understanding of how mocking works. At the beginning of the file, we import our original package, <code class="inlineCode">ios-health-kit</code>, then using the <code class="inlineCode">beforeAll</code> method, we call <code class="inlineCode">vi.mock</code>, passing it the path to the package as the first argument and a function that will return the implementation <a id="_idIndexMarker538"/>of the original file: namely, creating an object with the <code class="inlineCode">getSteps</code> method as a fake function with an implementation that will return the value of <code class="inlineCode">2000</code>. Then, in the test, we check that it indeed returns this value.</p>
    <p class="normal">In this test, the <code class="inlineCode">vi.mock</code> function creates a mock of the imported package and replaces the original <a id="_idIndexMarker539"/>import with it, which allows us to successfully test this functionality.</p>
    <p class="normal">In fact, this example, in essence, does not test anything but merely demonstrates the possibility of mocking. In a real project, you will likely need to test functions that somewhere inside may use libraries that are important to mock. For this, it may be inconvenient to constantly manually write mocks before the actual test; to solve this, you can mock libraries and APIs at a global level. For this, you will need to create a configuration file or use <code class="inlineCode">vi.stubGlobal</code>. I do not recommend diving so deeply right away without understanding and learning the basics, so let’s move on.</p>
    <div class="note">
      <p class="normal">More information <a id="_idIndexMarker540"/>about dependency mocking via configuration can be found at <a href="https://vitest.dev/guide/mocking"><span class="url">https://vitest.dev/guide/mocking</span></a>.</p>
    </div>
    <p class="normal"> </p>
    <p class="normal">The last but not least important example I’d like to discuss is mocking <strong class="keyWord">network requests</strong>. Almost any application you’ll be developing will work with data that needs to be fetched from a server. For a unit test, this can be a problem, as it’s important to test the unit abstracted from the external environment. Therefore, in unit tests, you should always mock server requests and provide the data necessary for the current test case. There’s a library called <code class="inlineCode">Mock Service Worker</code> for mocking server requests. It allows you to mock REST and GraphQL requests very flexibly. Let’s look at an example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { http, <span class="hljs-title">HttpResponse</span> } <span class="hljs-keyword">from</span> 'msw';
<span class="hljs-keyword">import</span> { setupServer } <span class="hljs-keyword">from</span> 'msw/node';
<span class="hljs-keyword">import</span> { describe, it, expect, beforeAll, afterEach, afterAll } <span class="hljs-keyword">from</span> 'vitest';
<span class="hljs-keyword">const</span> server = <span class="hljs-title">setupServer</span>(
  http.<span class="hljs-title">get</span>('<span class="hljs-attr">https</span>:<span class="hljs-comment">//api.github.com/users', () =&gt; {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title">HttpResponse</span>.<span class="hljs-title">json</span>({
      <span class="hljs-attr">firstName</span>: '<span class="hljs-title">Mikhail</span>',
      <span class="hljs-attr">lastName</span>: '<span class="hljs-title">Sakhniuk</span>',
    });
  })
);
<span class="hljs-title">describe</span>('<span class="hljs-title">Mocked</span> fetch', <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title">beforeAll</span>(<span class="hljs-function">() =&gt;</span> server.<span class="hljs-title">listen</span>());
  <span class="hljs-title">afterEach</span>(<span class="hljs-function">() =&gt;</span> server.<span class="hljs-title">resetHandlers</span>());
  <span class="hljs-title">afterAll</span>(<span class="hljs-function">() =&gt;</span> server.<span class="hljs-title">close</span>());
  <span class="hljs-title">it</span>('should returns test data', <span class="hljs-title">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title">fetch</span>('<span class="hljs-attr">https</span>:<span class="hljs-comment">//api.github.com/users');</span>
    <span class="hljs-title">expect</span>(response.<span class="hljs-property">status</span>).<span class="hljs-title">toBe</span>(<span class="hljs-number">200</span>);
    <span class="hljs-title">expect</span>(response.<span class="hljs-property">statusText</span>).<span class="hljs-title">toBe</span>('<span class="hljs-variable">OK</span>');
    <span class="hljs-title">expect</span>(<span class="hljs-keyword">await</span> response.<span class="hljs-title">json</span>()).<span class="hljs-title">toEqual</span>({
      <span class="hljs-attr">firstName</span>: '<span class="hljs-title">Mikhail</span>',
      <span class="hljs-attr">lastName</span>: '<span class="hljs-title">Sakhniuk</span>',
    });
  });
});
</code></pre>
    <p class="normal">In this test, we created a mock network request for the path <code class="inlineCode">https://api.github.com/users</code>, which returns the data we need. For this, we used the <code class="inlineCode">setupServer</code> function from the <code class="inlineCode">Mock Service Worker</code> package. Next, in the lifecycle methods, we set up <a id="_idIndexMarker541"/>the mock server to listen to server requests and then implemented a standard test where data is requested using the regular Fetch API. As you can see <a id="_idIndexMarker542"/>in the results, we can check the status code and the returned data.</p>
    <p class="normal">With such a mocking approach, we truly have vast possibilities for testing different logic depending on the data returned from the server, status codes, errors, and so on.</p>
    <p class="normal">In this section, we’ve introduced the basics of unit tests: namely, what they are and why we need to write them. We’ve learned how to set up the testing environment and write basic tests for our future projects. Next, let’s move on to the main topic of our chapter, testing ReactJS compaonents.</p>
    <h1 id="_idParaDest-194" class="heading-1">Testing ReactJS</h1>
    <p class="normal">We already know that unit testing involves checking small units, and most often, just functions, which perform some logic and return a result. To understand how testing in ReactJS works, the concept and idea remain the same. We know that at their core, React components <a id="_idIndexMarker543"/>are actually <code class="inlineCode">createElement</code> functions that return a node, which, as a result of the <code class="inlineCode">render</code> function, is displayed on the browser screen as HTML elements. In unit testing, we don’t have a browser, but this is not a problem for us since we know that the render target in React can be almost anything. As you may have already guessed, in the unit tests of ReactJS components, we will be rendering <a id="_idIndexMarker544"/>components into a specially created <strong class="keyWord">JSDOM</strong> format, which is fully identical to the DOM, and the <strong class="keyWord">React Testing Library</strong> will help us with this. </p>
    <p class="normal">This library contains a set of tools that allow rendering components, simulating events, and then checking the results in various ways.</p>
    <p class="normal">Before we start, let’s set up the environment for testing React components. To do this, in a fresh Vite project, execute this command:</p>
    <pre class="programlisting con"><code class="hljs-con">npm install --save-dev \
  @testing-library/react \
  @testing-library/jest-dom \
  vitest \
  jsdom
</code></pre>
    <p class="normal">This command will install all the dependencies we need. Next, we need to create a <code class="inlineCode">tests/setup.ts</code> file to integrate Vitest and the React Testing Library:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { expect, afterEach } <span class="hljs-keyword">from</span> 'vitest';
<span class="hljs-keyword">import</span> { cleanup } <span class="hljs-keyword">from</span> '@testing-library/react';
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> matchers <span class="hljs-keyword">from</span> "@testing-library/jest-dom/matchers";
expect.<span class="hljs-title">extend</span>(matchers);
<span class="hljs-title">afterEach</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title">cleanup</span>();
});
</code></pre>
    <p class="normal">Next, we need to update the <code class="inlineCode">vite.config.ts</code> configuration file and add the following code there:</p>
    <pre class="programlisting code"><code class="hljs-code">  test: {
    globals: true,
    environment: "jsdom",
    setupFiles: "./tests/setup.ts",
  },
</code></pre>
    <p class="normal">These parameters tell Vitest to use an additional environment and execute our setup script before starting the tests. </p>
    <p class="normal">The last step is to configure TypeScript typing, where we will specify that the <code class="inlineCode">expect</code> function will <a id="_idIndexMarker545"/>now have additional methods to work with React components. To do this, we need to add the following code to the <code class="inlineCode">src/vite-env.d.ts</code> file:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> type { <span class="hljs-title">TestingLibraryMatchers</span> } <span class="hljs-keyword">from</span> "@testing-library/jest-dom/matchers";
declare <span class="hljs-variable">global</span> {
  namespace jest {
    interface <span class="hljs-title">Matchers</span>&lt;R = <span class="hljs-keyword">void</span>&gt;
      <span class="hljs-keyword">extends</span> <span class="hljs-title">TestingLibraryMatchers</span>&lt;<span class="hljs-keyword">typeof</span> expect.<span class="hljs-property">stringContaining</span>, R&gt; {}
  }
}
</code></pre>
    <p class="normal">This construction adds types for all the new methods provided by the React Testing Library. With this, the environment setup is complete, and we can proceed to writing tests.</p>
    <p class="normal">First, let’s consider the most basic check that a component has successfully rendered and is present in the document. For this, we’ll create an <code class="inlineCode">App</code> component that returns a title with the <code class="inlineCode">Hello world</code> text:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title">App</span>() {
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>Hello world<span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>;
}
</code></pre>
    <p class="normal">The test for such a component would look like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { render, screen } <span class="hljs-keyword">from</span> "@testing-library/react";
<span class="hljs-keyword">import</span> { describe, it, expect } <span class="hljs-keyword">from</span> "vitest";
<span class="hljs-keyword">import</span> { <span class="hljs-title">App</span> } <span class="hljs-keyword">from</span> "./<span class="hljs-title">App</span>";
<span class="hljs-title">describe</span>("<span class="hljs-title">App</span>", <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title">it</span>("should be <span class="hljs-keyword">in</span> <span class="hljs-variable">document</span> ", <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title">render</span>(<span class="hljs-tag">&lt;</span><span class="hljs-name">App</span><span class="hljs-tag"> /&gt;</span>);
    <span class="hljs-title">expect</span>(screen.<span class="hljs-title">getByText</span>("<span class="hljs-title">Hello</span> world")).<span class="hljs-title">toBeInTheDocument</span>();
  });
});
</code></pre>
    <p class="normal">The structure of the test itself is the same as before and is already familiar to us. The main thing to note is that at the beginning of the test, we render the component using the <code class="inlineCode">render</code> function from <code class="inlineCode">testing-library</code>, and after that, we can perform checks. To work with the rendering result, we use the <code class="inlineCode">screen</code> module. It allows us to interact with our virtual DOM tree, and search for necessary elements in various ways. </p>
    <p class="normal">We will cover the main <a id="_idIndexMarker546"/>ones later, but in this example, we used the <code class="inlineCode">getByText</code> method, which queries for an element containing the text “<code class="inlineCode">Hello World</code>". To check whether this element is present in the document, we use the <code class="inlineCode">toBeInTheDocument</code> method. This is how the output looks when you run the test:</p>
    <pre class="programlisting con"><code class="hljs-con">✓ src/App.test.tsx (1)
   ✓ App (1)
     ✓ should be in document
 Test Files  1 passed (1)
      Tests  1 passed (1)
   Start at  14:19:01
   Duration  198ms
</code></pre>
    <p class="normal">Now let’s consider a more complex example, where we need to check that clicking a button adds a new <code class="inlineCode">className</code> property to the component:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title">ClassCheck</span>() {
  <span class="hljs-keyword">const</span> [clicked, setClicked] = <span class="hljs-title">useState</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span>
<span class="hljs-tag">      </span><span class="hljs-attr">className</span><span class="hljs-tag">=</span><span class="hljs-string">{clicked</span><span class="hljs-tag"> ? "</span><span class="hljs-attr">active</span><span class="hljs-tag">" </span><span class="hljs-attr">:</span><span class="hljs-tag"> ""}</span>
<span class="hljs-tag">      </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{()</span><span class="hljs-tag"> =&gt;</span> setClicked(true)}
    &gt;
      Click me
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
  );
}
</code></pre>
    <p class="normal">By clicking the button, we update the state, which updates the component and adds an <code class="inlineCode">active</code> class to it. Now, let’s write a test for this component:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">describe</span>("<span class="hljs-title">ClassCheck</span>", <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title">it</span>("should have <span class="hljs-keyword">class</span> <span class="hljs-title">active</span> when button was clicked", <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title">render</span>(<span class="hljs-tag">&lt;</span><span class="hljs-name">ClassCheck</span><span class="hljs-tag"> /&gt;</span>);
    <span class="hljs-keyword">const</span> button = screen.<span class="hljs-title">getByRole</span>("button");
    <span class="hljs-title">expect</span>(button).<span class="hljs-property">not</span>.<span class="hljs-title">toHaveClass</span>("active");
    fireEvent.<span class="hljs-title">click</span>(button);
    <span class="hljs-title">expect</span>(button).<span class="hljs-title">toHaveClass</span>("active");
  });
});
</code></pre>
    <p class="normal">In this test, you first render the <code class="inlineCode">ClassCheck</code> component, then we need to find the button element, and for this, we use the <code class="inlineCode">screen</code> module with the <code class="inlineCode">getByRole</code> method. This is the next <a id="_idIndexMarker547"/>method that allows query elements in the document, but it’s important to understand that if there is more than one <code class="inlineCode">button</code> in the document, this test will produce an error. Therefore, it’s necessary to apply suitable query methods in different situations. Now that the button is accessible, we first ensure that the component does not contain the <code class="inlineCode">active</code> class using the <code class="inlineCode">toHaveClass</code> method with the <code class="inlineCode">not</code> prefix. </p>
    <p class="normal">To click on this button, the React Testing Library provides the <code class="inlineCode">fireEvent</code> module, which allows generating click events. After clicking the button, we check that the required class is present in the element.</p>
    <p class="normal">With <code class="inlineCode">fireEvent</code>, it’s possible to generate all possible events such as click, drag, play, focus, blur, and many others. A very common event that is also important to test is the <code class="inlineCode">change</code> event in an input element. Let’s discuss this using the <code class="inlineCode">Input</code> component as an example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title">Input</span>() {
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span><span class="hljs-tag"> </span><span class="hljs-attr">type</span><span class="hljs-tag">=</span><span class="hljs-string">"text"</span><span class="hljs-tag"> </span><span class="hljs-attr">data-testid</span><span class="hljs-tag">=</span><span class="hljs-string">"userName"</span><span class="hljs-tag"> /&gt;</span>;
}
</code></pre>
    <p class="normal">This component simply returns an <code class="inlineCode">input</code> element, but in this example, I’ve also added a special attribute, <code class="inlineCode">data-testid</code>. This is used for more convenient searching of elements in the document, as this attribute abstracts you from working with the content of the component or the role of the element. During the development of the project, you will often update your components, and the <code class="inlineCode">data-testid</code> attribute will help you less frequently fix broken tests due to content updates or changes, say from <code class="inlineCode">h1</code> to <code class="inlineCode">h2</code> or <code class="inlineCode">div</code> to a more semantic element.</p>
    <p class="normal">Now let’s write a test for this component:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">describe</span>("<span class="hljs-title">Input</span>", <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title">it</span>("should handle change event", <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title">render</span>(<span class="hljs-tag">&lt;</span><span class="hljs-name">Input</span><span class="hljs-tag"> /&gt;</span>);
    <span class="hljs-keyword">const</span> input = screen.<span class="hljs-property">getByTestId</span>&lt;<span class="hljs-title">HTMLInputElement</span>&gt;("userName");
    fireEvent.<span class="hljs-title">change</span>(input, { <span class="hljs-attr">target</span>: { <span class="hljs-attr">value</span>: "<span class="hljs-title">Mikhail</span>" } });
    <span class="hljs-title">expect</span>(input.<span class="hljs-property">value</span>).<span class="hljs-title">toBe</span>("<span class="hljs-title">Mikhail</span>");
  });
});
</code></pre>
    <p class="normal">In this test, as usual, we render the component, and then we find our element using the more convenient method, <code class="inlineCode">getByTestId</code>. Next, we simulate the <code class="inlineCode">change</code> event on <code class="inlineCode">input</code> using the <code class="inlineCode">fireEvent.change</code> method, which takes the event object, and at the end of the test, we assert the entered value in the expected one. In this way, we can now test large forms with <a id="_idIndexMarker548"/>various logic for formatting, validation, and so on.</p>
    <p class="normal">Just like testing components, the React Testing Library can also test Hooks. This allows testing only the custom logic and abstracting away from the components. Let’s write a small <code class="inlineCode">useCounter</code> Hook, which will return the current <code class="inlineCode">counter</code> value and the <code class="inlineCode">increment</code> and <code class="inlineCode">decrement</code> functions:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title">useCounter</span>(<span class="hljs-params">initialValue: number = </span><span class="hljs-number">0</span>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title">useState</span>(initialValue);
  <span class="hljs-keyword">const</span> <span class="hljs-title">increment</span> = () =&gt; <span class="hljs-title">setCount</span>(<span class="hljs-function">(</span><span class="hljs-params">c</span><span class="hljs-function">) =&gt;</span> c + <span class="hljs-number">1</span>);
  <span class="hljs-keyword">const</span> <span class="hljs-title">decrement</span> = () =&gt; <span class="hljs-title">setCount</span>(<span class="hljs-function">(</span><span class="hljs-params">c</span><span class="hljs-function">) =&gt;</span> c - <span class="hljs-number">1</span>);
  <span class="hljs-keyword">return</span> { count, increment, decrement };
}
</code></pre>
    <p class="normal">In order to test this Hook, instead of using the <code class="inlineCode">render</code> function, the React Testing Library has a <code class="inlineCode">renderHook</code> method. This is what a test of this Hook would look like:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">test</span>("useCounter", <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> { result } = <span class="hljs-title">renderHook</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title">useCounter</span>());
  <span class="hljs-title">expect</span>(result.<span class="hljs-property">current</span>.<span class="hljs-property">count</span>).<span class="hljs-title">toBe</span>(<span class="hljs-number">0</span>);
  <span class="hljs-title">act</span>(<span class="hljs-function">() =&gt;</span> {
    result.<span class="hljs-property">current</span>.<span class="hljs-title">increment</span>();
  });
  <span class="hljs-title">expect</span>(result.<span class="hljs-property">current</span>.<span class="hljs-property">count</span>).<span class="hljs-title">toBe</span>(<span class="hljs-number">1</span>);
  <span class="hljs-title">act</span>(<span class="hljs-function">() =&gt;</span> {
    result.<span class="hljs-property">current</span>.<span class="hljs-title">decrement</span>();
  });
  <span class="hljs-title">expect</span>(result.<span class="hljs-property">current</span>.<span class="hljs-property">count</span>).<span class="hljs-title">toBe</span>(<span class="hljs-number">0</span>);
});
</code></pre>
    <p class="normal">Initially, we render the Hook itself and check that the initial value is zero. The <code class="inlineCode">renderHook</code> method returns the <code class="inlineCode">result</code> object, through which we can read the data returned from the Hook. Next, we need to test the <code class="inlineCode">increment</code> and <code class="inlineCode">decrement</code> methods. To do this, it is not enough to simply call them, as Hooks are not pure functions by nature and contain <a id="_idIndexMarker549"/>a lot of logic under the hood. Therefore, we need to call those methods wrapped in the <code class="inlineCode">act</code> method, which will synchronously wait for the method to execute and the Hook to re-render. After that, we can assert the expectations in the usual way. The output will look the same as we saw in the previous example, but let’s now try to update the test to make failed results. Updating the first assertion from <code class="inlineCode">.toBe(0)</code> to <code class="inlineCode">.toBe(10)</code> will look like:</p>
    <pre class="programlisting con"><code class="hljs-con">AssertionError: expected +0 to be 10 // Object.is equality
- Expected
+ Received
- 10
+ 0
 ❯ src/useCounter.test.ts:8:32
      6|   const { result } = renderHook(() =&gt; useCounter());
      7| 
      8|   expect(result.current.count).toBe(10);
       |                                ^
      9| 
     10|   act(() =&gt; {
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[1/1]⎯
 Test Files  1 failed (1)
      Tests  1 failed (1)
   Start at  14:24:06
   Duration  200ms
</code></pre>
    <p class="normal">You will notice <a id="_idIndexMarker550"/>how Vitest highlights the part of the code where we got a failed assertion.</p>
    <p class="normal">In this section, we have learned how we can test components and Hooks using the React Testing Library.</p>
    <h1 id="_idParaDest-195" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we explored the broad and extensive topic of testing. We became acquainted with the concept itself, testing types, and various approaches. Then, we delved into unit testing and learned what it is, and what possibilities this type of testing offers. After that, we learned how to set up the environment and write tests for regular functions and logic. At the end of the chapter, we examined the basic capabilities of testing React components and Hooks.</p>
    <p class="normal">With this chapter, we conclude our acquaintance with the amazing ReactJS library and will next dive deeper into the React ecosystem with the incredible opportunity to create mobile applications based on React Native.</p>
    <h1 id="_idParaDest-196" class="heading-1">Join us on Discord!</h1>
    <p class="normal">Read this book alongside other users and the authors themselves. Ask questions, provide solutions to other readers, chat with the authors, and more. Scan the QR code or visit the link to join the community.</p>
    <p class="normal"><a href="Chapter_14.xhtml"><span class="url">https://packt.link/ReactAndReactNative5e</span></a></p>
    <p class="normal"><img src="../Images/QR_Code196803360665486921.png" alt="" role="presentation"/></p>
  </div>
</body></html>