- en: 11\. Working with Vuex – Organizing Larger Stores
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11. 使用 Vuex – 组织更大的存储
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn how to better organize larger Vuex stores. As
    your applications grow in complexity and features, your store file may become
    harder to work with. Even simply finding things can become a difficult chore as
    the file grows larger and larger. This chapter will discuss two different approaches
    to making it easier to organize your stores for simpler updates. The first approach
    will have you splitting up your code across different files whereas the second
    will use a more advanced Vuex feature, modules.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何更好地组织更大的 Vuex 存储。随着你的应用程序在复杂性和功能上的增长，你的存储文件可能变得难以操作。随着文件越来越大，甚至简单地找到东西也可能变成一项困难的任务。本章将讨论两种不同的方法来简化存储的组织，以便进行更简单的更新。第一种方法将要求你将代码拆分到不同的文件中，而第二种方法将使用更高级的
    Vuex 功能，即模块。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: So far, the stores we have worked on have been simple and short. But, as everyone
    knows, even the simplest of applications tend toward complexity over time. As
    you have learned in the previous chapters, your store can contain a **state**,
    a block of **getters**, a block of **mutations** and **actions**, and as you will
    learn later in this chapter, **modules**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们处理过的存储都很简单且简短。但是，正如众所周知的那样，即使是简单的应用程序随着时间的推移也会趋向于复杂化。正如你在前面的章节中学到的，你的存储可以包含一个`state`、一个`getters`的块、一个`mutations`和`actions`的块，以及你将在本章后面学到的内容，即`modules`。
- en: As your application grows, having one file for your Vuex store could become
    hard to manage. Both bug fixing and updates for new functionality could become
    more difficult. This chapter will discuss two different ways to help manage this
    complexity and organize your Vuex stores. To be clear, these are *optional* things
    you can do to help manage your store. If your store is simple and you would like
    to keep it that way, that is fine. You can always use these approaches in the
    future, and the great thing is that no-one outside your store will need to be
    aware – they will continue to use Vuex data as they did before. You can keep these
    techniques in mind as a set of tools to help you when your application needs to
    level up. Let's start with the simplest of methods, file splitting.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的应用程序增长，拥有一个文件来管理你的 Vuex 存储（store）可能会变得难以管理。修复错误和更新新功能可能会变得更加困难。本章将讨论两种不同的方法来帮助管理这种复杂性并组织你的
    Vuex 存储。为了明确，这些都是你可以做的*可选*事情来帮助管理你的存储。如果你的存储很简单，并且你希望保持这种状态，那也是可以的。你总是可以在将来使用这些方法，而且好处是，没有人需要知道你的存储之外的事情——他们将继续像以前一样使用
    Vuex 数据。你可以将这些技巧作为一组工具保留在心中，以帮助你在应用程序需要升级时使用。让我们从最简单的方法，文件拆分，开始。
- en: Approach One – Using File Splitting
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法一 – 使用文件拆分
- en: 'The first approach, and certainly the simplest one, involves simply taking
    the code of your various Vuex parts (the `state`, the `getters`, and so forth)
    and moving them into their own files. These files can then be imported by the
    main Vuex Store and used as normal. Let''s consider a simple example:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法，当然也是最简单的一种方法，就是简单地将你的各种 Vuex 部分的代码（如`state`、`getters`等）移动到它们自己的文件中。然后，这些文件可以被主
    Vuex 存储`import`并正常使用。让我们考虑一个简单的例子：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is from the first exercise in *Chapter 9*, *Working with Vuex – State,
    Getters, Actions, and Mutations*, and is a store with only three state values.
    To migrate the state to a new file, you could create a new file in the `store`
    folder, called `state.js`, and set it up like so:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从*第9章*中的第一个练习*使用 Vuex – 状态、获取器、动作和突变*中来的，并且是一个只有三个状态值的存储。要将状态迁移到新文件，你可以在`store`文件夹中创建一个名为`state.js`的新文件，并按照如下设置：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, back in your store, modify it to `import` and make use of the code:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，回到你的存储中，将其修改为`import`并使用代码：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'While this example ends up being *more* lines of code, you can see how we are
    beginning to separate out different parts of the store into different files to
    make it easier to update. Let''s consider a slightly larger example, again taking
    earlier work from the second exercise in *Chapter 9*, *Working with Vuex – State,
    Getters, Actions, and Mutations*. Here is the original store:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子最终变成了更多的代码行，但你可以看到我们是如何开始将存储的不同部分分离到不同的文件中，以便更容易更新的。让我们考虑一个稍微大一点的例子，再次参考*第9章*中的第二个练习，*使用
    Vuex – 状态、获取器、动作和突变*。以下是原始存储：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This example only uses `state` values and a `getter`, but let''s move both
    of them into new files. First, let''s move the `state` into a file called `state.js`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子只使用了`state`值和一个`getter`，但让我们将它们都移动到新文件中。首先，让我们将`state`移动到名为`state.js`的文件中：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And next, let''s move the `getters` into a file called `getters.js`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将 `getters` 移入一个名为 `getters.js` 的文件中：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we can update the store:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以更新存储：
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Applying the same type of update to `mutations` and `actions` would follow the
    exact same pattern, and obviously, you do not have to split everything. You could,
    for example, keep the state values in the main file but only split out your functions
    (`getters`, `mutations`, and `actions`).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将相同类型的更新应用于 `mutations` 和 `actions` 将遵循完全相同的模式，并且显然，你不必拆分一切。例如，你可以将状态值保留在主文件中，但只拆分你的函数（`getters`、`mutations`
    和 `actions`）。
- en: 'Exercise 11.01: Using File Splitting'
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.01：使用文件拆分
- en: In this exercise, we are going to use file splitting across a slightly larger
    Vue store. Honestly, it is not very large at all, but we will use file splitting
    to handle `state`, `getters`, `mutations`, and `actions`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将在一个稍微大一点的 Vue store 中使用文件拆分。说实话，它并不大，但我们将会使用文件拆分来处理 `state`、`getters`、`mutations`
    和 `actions`。
- en: 'To access the code files for this exercise, visit [https://packt.live/32uwiKB](https://packt.live/32uwiKB):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请访问 [https://packt.live/32uwiKB](https://packt.live/32uwiKB)：
- en: Generate a new Vue application and add Vuex support.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个新的 Vue 应用程序并添加 Vuex 支持。
- en: 'Modify the default store''s `index.js` file (located at `src/store/index.js`)
    to import the four files we will create to represent the store:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改默认存储的 `index.js` 文件（位于 `src/store/index.js`），导入我们将创建的四个文件来表示存储：
- en: '[PRE7]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Edit the new `state.js` file to add values for first and last names, numbers
    representing the amounts of cats and dogs possessed by the person in question,
    and a favorite film:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑新的 `state.js` 文件，添加姓名和姓氏的值，代表该人拥有的猫和狗数量的数字，以及一个最爱电影：
- en: '[PRE8]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add a `getter.js` file that defines a `getter` for the full name and the total
    number of pets:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `getter.js` 文件来定义全名和宠物总数的 `getter`：
- en: '[PRE9]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, add a `mutations.js` file for adding the number of cats and dogs, setting
    the first and last name, and adding the favorite film:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个 `mutations.js` 文件来添加猫和狗的数量，设置姓名和姓氏，以及添加最爱电影：
- en: '[PRE10]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, add `actions.js` to define one action, `updateFavoriteFilm`. This
    will make a network request to the `Star Wars` API to ensure that the new favorite
    film is only allowed if it is a Star Wars film:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加 `actions.js` 文件来定义一个动作，`updateFavoriteFilm`。这将向 `Star Wars` API 发起网络请求，以确保只有当新的最爱电影是《星球大战》电影时才允许：
- en: '[PRE11]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To see it in action, update `src/App.vue` to access various parts of the store.
    The only point of this step is to drive home the idea that how you use the store
    does not change:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要看到它的实际效果，更新 `src/App.vue` 以访问存储的各个部分。这一步的唯一目的是强调你使用存储的方式并没有改变：
- en: '[PRE12]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code will generate an output as follows:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码将生成如下输出：
- en: '![Figure 11.1: Output from the newly organized store'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 11.1：新组织存储的输出'
- en: '](img/B15218_11_01.jpg)'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15218_11_01.jpg]'
- en: 'Figure 11.1: Output from the newly organized store'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：新组织存储的输出
- en: You have now seen a (somewhat simple) example of using file splitting to manage
    the size of your Vuex store. While the functionality is no different than what
    you have seen before, as your application grows, you will probably find it much
    easier to make additions and fixes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了一个（相对简单）的例子，使用文件拆分来管理 Vuex 存储的大小。虽然功能与之前看到的不同，但随着你的应用程序的增长，你可能会发现添加和修复要容易得多。
- en: Approach Two – Using Modules
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二种方法 – 使用模块
- en: In the previous approach, we mainly just moved lines of code into other files.
    As we said, while this made it easier to work on the store itself, it changed
    nothing about how the store was used by Vue components. **Modules** help us deal
    with complexity at the level where components come in.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的方法中，我们主要只是将代码行移动到其他文件中。正如我们所说的，虽然这使处理存储本身变得更容易，但它并没有改变 Vue 组件使用存储的方式。**模块**帮助我们处理组件级别的复杂性。
- en: 'Imagine a large `state` object containing values representing many different
    things, such as this one:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个包含许多不同值的 `state` 对象，例如这个：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This example contains information about a person, data related to books, and
    a set of values representing robots. That is a lot of data covering three uniquely
    different topics. Moving this into its own file does not necessarily make it easier
    to use or help keep things organized. This complexity would also spill over to
    `getters`, `mutations`, and `actions`. Given an action named `setName`, you could
    assume it applies to the state values representing the person, but if other state
    values had similar names, it could begin to get messy.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子包含了关于一个人的信息，与书籍相关的数据，以及代表机器人的值集。这是一大批数据，涵盖了三个独特不同的主题。将这些内容移入单独的文件并不一定能使使用变得更简单或有助于保持组织有序。这种复杂性也会影响到`getters`、`mutations`和`actions`。给定一个名为`setName`的操作，你可以假设它适用于代表个人的状态值，但如果其他状态值有类似的名字，可能会开始变得混乱。
- en: This is where modules come in. A module allows us to define a separate `state`,
    `getters`, `mutations`, and `actions` completely separated from the **root** or
    core store.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是模块的作用。一个模块允许我们定义一个完全独立的`state`、`getters`、`mutations`和`actions`，与**根**或核心存储完全分离。
- en: 'Here is an example store using a `resume` module:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用`resume`模块的示例存储：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Both the `state` and `getters` but could also expose `mutations` and `actions`.
    Notice how in the `resume` module `getters`, `totalJobs`, the `state` variable
    refers to its own state, not that of the parent. This is great as it ensures you
    can work within the module and not worry about modifying, by accident, another
    value in the root or some other module. You can access the root state in `getters`
    by using a new third argument, `rootState`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`state`和`getters`也可以公开`mutations`和`actions`。注意在`resume`模块的`getters`中，`totalJobs`的`state`变量引用的是它自己的状态，而不是父状态。这是非常好的，因为它确保你可以在模块内部工作，而不用担心意外修改根或其他模块中的某个值。你可以在`getters`中使用一个新的第三个参数`rootState`来访问根状态：'
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And actions can use `rootState` via the context object, `context.rootState`.
    In theory, though, your modules should concern themselves with their own data
    and only **reach out** to the root when necessary.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 动作可以通过上下文对象`context.rootState`使用`rootState`。然而，从理论上讲，你的模块应该关注它们自己的数据，并且只有在必要时才**向外**扩展到根状态。
- en: 'When using module values, your code must know the name of the module. Consider
    the following example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用模块值时，你的代码必须知道模块的名称。考虑以下示例：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`getters`, `actions`, and `mutations` are *not* differentiated, though. This
    is how you would access both `getters`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`getters`、`actions`和`mutations`并没有被区分。这就是你访问`getters`的方式：'
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The idea behind this is to allow a module, or multiple modules, to potentially
    respond to the same calls. If this does not appeal to you, you can `namespaced`
    option:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法背后的目的是允许一个模块或多个模块可能对相同的调用做出响应。如果你不喜欢这个，你可以使用`namespaced`选项：
- en: '[PRE18]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then to refer to `getters`, `mutations`, and `actions` for this module, you
    must pass in the name of the module as part of the call. So, for example, the
    getter now becomes: `$store.getters[''resume/totalJobs'']`.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后要引用此模块的`getters`、`mutations`和`actions`，你必须将模块的名称作为调用的一部分传递。例如，现在的getter变成了：`$store.getters['resume/totalJobs']`。
- en: For the most part, that is the core of module support, but note there are more
    options for how modules can expose themselves globally that are outside the scope
    of this book. See the latter parts of the module documentation ([https://vuex.vuejs.org/guide/modules.html](https://vuex.vuejs.org/guide/modules.html))
    for examples of that. Finally, note that you can build modules within modules
    as deep as you like. Obviously, you want to put some thought into building incredibly
    deeply nested modules, but if you want to do that, Vuex allows it!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分来说，这是模块支持的核心，但请注意，还有更多关于模块如何全局暴露自己的选项，这些选项超出了本书的范围。请参阅模块文档的后半部分（[https://vuex.vuejs.org/guide/modules.html](https://vuex.vuejs.org/guide/modules.html)）以获取相关示例。最后，请注意，你可以根据需要将模块嵌套在模块中，Vuex
    允许这样做！
- en: 'Exercise 11.02: Making Use of Modules'
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.02：利用模块
- en: In this exercise, we'll work with a Vuex store that makes use of not one but
    two modules, and to make it more interesting, one of the modules will be stored
    in another file, showing that we can also use the first approach when using modules.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将与一个Vuex存储库一起工作，它使用不止一个模块，为了使它更有趣，其中一个模块将存储在另一个文件中，这表明我们在使用模块时也可以使用第一种方法。
- en: 'To access the code files for this exercise, visit [https://packt.live/35d1zDv](https://packt.live/35d1zDv):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请访问[https://packt.live/35d1zDv](https://packt.live/35d1zDv)：
- en: As usual, generate a new Vue application and ensure you add Vuex.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同往常，生成一个新的Vue应用程序，并确保你添加了Vuex。
- en: 'In the store file (`store/index.js`), add two `state` values for the first
    and last names and a getter to return both:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`store/index.js`存储文件中，为姓氏和名字添加两个`state`值，并添加一个getter来返回两者：
- en: '[PRE19]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, add a `resume` module to the `store` file. It will have two `state` values,
    one representing an open-for-hire value and the other, an array of past jobs.
    Lastly, add a getter to return the total number of jobs:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向`store`文件添加一个`resume`模块。它将有两个`state`值，一个表示可雇佣值，另一个是一个表示过去工作的数组。最后，添加一个getter来返回工作的总数：
- en: '[PRE20]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now create a new file for the next module, `store/portfolio.js`. This will
    contain a `state` value representing an array of websites worked on and a mutation
    to add a value:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在为下一个模块创建一个新的文件，`store/portfolio.js`。这将包含一个表示已工作的网站数组的`state`值和一个添加值的`mutation`：
- en: '[PRE21]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Back in the main store''s `index.js` file, import `portfolio`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主存储的`index.js`文件中，导入`portfolio`：
- en: '[PRE22]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then add `portfolio` to the list of modules, after `resume`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将`portfolio`添加到模块列表中，在`resume`之后：
- en: '[PRE23]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, let''s make use of the modules in our main `src/App.vue` file. Modify
    the template to add calls to various parts of the store:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的主`src/App.vue`文件中使用这些模块。修改模板以添加对存储中各个部分的调用：
- en: '[PRE24]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then add a **form** so that we can add a **new website**:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加一个**表单**，以便我们可以添加一个**新网站**：
- en: '[PRE25]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Define the method for `addSite`. It will commit the `mutation` and clear the
    site value. Be sure to add a local data value for site as well. Here is the complete
    script block:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`addSite`方法的函数。它将提交`mutation`并清除站点值。务必为站点添加一个本地数据值。以下是完整的脚本块：
- en: '[PRE26]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The result will look as follows:'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![Figure 11.2: The application making use of Vuex data with modules'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图11.2：使用模块利用Vuex数据的应用程序](img/B15218_11_02.jpg)'
- en: '](img/B15218_11_02.jpg)'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](https://davestewart.github.io/vuex-pathify/)'
- en: 'Figure 11.2: The application making use of Vuex data with modules'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：使用模块利用Vuex数据的应用程序
- en: Now you have seen yet another way to help manage your Vuex store. **Modules**
    provide a deeper, more complex way to organize your stores. As always, choose
    the method that best fits your application needs and the one you and your team
    are most comfortable with!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了另一种帮助管理你的Vuex存储的方法。**模块**提供了一种更深入、更复杂的组织存储的方式。一如既往，选择最适合你的应用程序需求以及你和你的团队最舒适的方法！
- en: Other Approaches to Organizing Your Vuex Stores
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织Vuex存储的其他方法
- en: While the previous two approaches should give you some good options for managing
    your Vuex store, there are a few other options you may wish to consider as well.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前两种方法应该为你提供一些管理Vuex存储的好选项，但你可能还想考虑其他一些选项。
- en: Vuex Pathify
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vuex Pathify
- en: 'Vuex Pathify ([https://davestewart.github.io/vuex-pathify/](https://davestewart.github.io/vuex-pathify/))
    is a utility that makes it easier to access the Vuex store via a `resume` and
    a `state` value of `jobs` can be accessed like so: `store.get(''resume/jobs'')`.
    Basically, it creates a shortcut for reading and writing values to the store and
    simplifying synchronization. Fans of **XPath** will love this.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex Pathify（[https://davestewart.github.io/vuex-pathify/](https://davestewart.github.io/vuex-pathify/））是一个实用工具，它使得通过`resume`和`state`值`jobs`访问Vuex存储变得更加容易：`store.get('resume/jobs')`。基本上，它为读取和写入存储中的值以及简化同步创建了一个快捷方式。XPath的爱好者会喜欢这个。
- en: Vuex Module Generator (VMG)
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vuex模块生成器（VMG）
- en: '`state`, `mutations`, and `actions`. Anyone who has been in web development
    for any amount of time is familiar with the CRUD pattern and will absolutely jump
    for joy at not having to write those functions again.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`state`、`mutations`和`actions`。任何在Web开发领域工作过一段时间的人都会熟悉CRUD模式，并且绝对会为不必再次编写这些函数而感到高兴。'
- en: Check out the GitHub repository ([https://github.com/abdullah/vuex-module-generator](https://github.com/abdullah/vuex-module-generator))
    for more details and sample applications.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 查看GitHub仓库（[https://github.com/abdullah/vuex-module-generator](https://github.com/abdullah/vuex-module-generator)）以获取更多详细信息及示例应用程序。
- en: Vuex ORM
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vuex ORM
- en: '`ORM` library to your Vuex store. **ORM** is short for **object-relational
    mapping** and is a pattern to help make object persistence simpler. Like VMG,
    Vuex ORM aims to simplify the rather common CRUD tasks web developers must write.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将`ORM`库添加到Vuex存储中。**ORM**代表**对象关系映射**，是一种帮助简化对象持久化的模式。像VMG一样，Vuex ORM旨在简化Web开发者必须编写的相对常见的CRUD任务。
- en: Vuex ORM lets you define classes that represent the structure of your store
    data. Once you have defined the structure of the data, Vuex ORM then provides
    utility functions to make storing and retrieving that data in the store much simpler.
    It even handles relationships between data, such as a `cat` objects that belong
    to it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex ORM 允许你定义代表你的存储数据结构的类。一旦你定义了数据结构，Vuex ORM 就提供了实用函数，使得在存储中存储和检索数据变得更加简单。它甚至处理数据之间的关系，例如属于它的
    `cat` 对象。
- en: 'Here is an example of how you could define a type of data:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何定义一种数据类型的示例：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding class, four properties are defined for the `Cat` class: `id`,
    `name`, `age`, and `adoptable`. For each property, default values are specified.
    Once defined, asking for all the data is as simple as `Cat.all()`. There''s a
    lot more to Vuex ORM, and you can check it out at [https://vuex-orm.github.io/vuex-orm/](https://vuex-orm.github.io/vuex-orm/).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的课程中，为 `Cat` 类定义了四个属性：`id`、`name`、`age` 和 `adoptable`。对于每个属性，都指定了默认值。一旦定义，请求所有数据就像
    `Cat.all()` 一样简单。Vuex ORM 还有更多内容，你可以在 [https://vuex-orm.github.io/vuex-orm/](https://vuex-orm.github.io/vuex-orm/)
    上查看。
- en: 'Activity 11.01: Simplifying a Vuex Store'
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 11.01：简化 Vuex 存储
- en: This activity will be a bit different than the ones you have done before. In
    this activity, you are going to take an *existing* application making use of Vuex
    and apply some of the techniques you have learned in this chapter in order to
    simplify the store and make it easier to use in future updates. This could be
    most useful when needing to tweak or fix existing functionality.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动将与你之前做过的活动略有不同。在这个活动中，你将使用一个 *现有* 的应用，该应用使用 Vuex，并应用本章中学到的某些技术来简化存储，使其在未来更新中更容易使用。这在进行功能调整或修复时可能非常有用。
- en: '**Steps:**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤：**'
- en: To begin this activity, you will use the completed example found at `Chapter11/activity11.01/initial`
    ([https://packt.live/3kaqBHH](https://packt.live/3kaqBHH)).
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始这个活动，你将使用位于 `Chapter11/activity11.01/initial` 的完成示例（[https://packt.live/3kaqBHH](https://packt.live/3kaqBHH)）。
- en: Modify the store file to place the `state`, `getters`, and `mutations` into
    their own file.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改存储文件，将 `state`、`getters` 和 `mutations` 放入它们自己的文件。
- en: Modify the `state` so that the `cat` values are in a `module`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `state`，使 `cat` 值位于 `module` 中。
- en: Migrate the cat-related `getter` to the `module`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将与猫相关的 `getter` 迁移到 `module`。
- en: Update the `App.vue` file so that it still correctly displays the data it did
    initially.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `App.vue` 文件，使其仍然正确显示最初的数据。
- en: 'This is how it looks when built:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是构建后的样子：
- en: '![Figure 11.3: Final output of the activity'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 11.3：活动的最终输出'
- en: '](img/B15218_11_03.jpg)'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_11_03.jpg)'
- en: 'Figure 11.3: Final output of the activity'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3：活动的最终输出
- en: Note
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor403).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以通过[这个链接](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor403)找到。
- en: Summary
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned multiple different techniques to prepare your Vuex
    stores for growing complexity. You first learned how to move logic into separate
    files and include them within your store. You then learned about modules and how
    they are exposed to components using the store. Finally, you learned about some
    optional libraries that may make your Vuex use even more powerful.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了多种不同的技术来为你的 Vuex 存储准备增长复杂性。你首先学习了如何将逻辑移动到单独的文件并在你的存储中包含它们。然后你学习了模块以及它们是如何通过存储暴露给组件的。最后，你学习了可能使
    Vuex 使用更加强大的某些可选库。
- en: In the next chapter, you are going to learn about an incredibly important aspect
    of development, unit testing.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将学习关于开发一个极其重要的方面，单元测试。
