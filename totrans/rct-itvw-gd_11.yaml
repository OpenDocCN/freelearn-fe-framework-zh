- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building an App Based on React, Redux, Styled Components, and the Firebase Backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we progress through this book, we will cover many concepts and skills related
    to the React ecosystem, popular libraries, and the best practices to build robust
    React applications in the modern era of web apps. This chapter is dedicated to
    creating a full stack React application with the help of knowledge gained in the
    previous chapters. As part of the interview process, the interviewer might ask
    you to build a full-fledged React project based on certain functional and technical
    requirements, or assign a quick coding challenge to assess your abilities in a
    particular domain. This chapter will guide you on how to tackle the coding rounds,
    by creating a React project from scratch following standard guidelines and asking
    interview questions on the implemented project. In this chapter, we will build
    an e-commerce application by implementing various UI components, applying styles,
    verifying the identity of the registered users through an authentication mechanism,
    integrating with the Firebase backend, and deploying the application to make it
    available for public usage.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will start with the process of scaffolding the project using an official
    `react-intl` library to support internationalization, and the Firebase package
    to implement the backend. Then, we will quickly introduce the Firebase backend
    and its services, integrating Firebase inside our React project and authentication
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Thereafter, we will build business logic following Redux standards to work with
    various actions triggered from a UI. To increase the user base from various regions,
    we will enhance the application with the support of an internationalization process.
    Then, we will write a couple of unit tests to make our code flawless and work
    as per business requirements. At the end of the chapter, we will host our Git
    repository on GitHub and make it available online to showcase our skills.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Scaffolding and configuring a project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Firebase services and configuring an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing Firebase Authentication and its backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the Redux components for state management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the presentation layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting internationalization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing testing using the Vitest framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Git repository with README documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the application for public access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before starting our project’s journey, your workstation should have the latest
    Node.js and npm ([https://nodejs.org/en](https://nodejs.org/en)) packages installed
    on it. You will also need to have a Netlify account ([https://www.netlify.com/](https://www.netlify.com/))
    for the deployment section while building this project and a GitHub ([https://github.com/](https://github.com/))
    account to host the Git repository. The code base of this project can be found
    online in the git Repository: [https://github.com/PacktPublishing/React-Interview-Guide/tree/main/Chapter11/one-stop-electronics](https://github.com/PacktPublishing/React-Interview-Guide/tree/main/Chapter11/one-stop-electronics).'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first talk about the scaffolding and project configuration to build a
    React application.
  prefs: []
  type: TYPE_NORMAL
- en: Scaffolding and configuring the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B18603_06.xhtml#_idTextAnchor209), we covered various topics
    about Redux and its workflow to build React web applications, based on a Redux
    state management solution. To reduce the boilerplate code involved with Redux
    logic, the Redux team recommends using **RTK** to simplify many common use cases,
    apply best practices, and prevent common mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: If you create a project from scratch, doing so using the **Redux and TypeScript
    template for Vite** is one of the suggested approaches from the Redux team. So,
    we will use the same approach to build the project in this section. In this project,
    we will build an e-commerce application, named *One Stop Electronics*, where one
    can buy electronic devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `degit` project scaffolding command is helpful for creating a
    project structure based on RTK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This template creates a project based on TypeScript (`.tsx` or `.ts` files),
    with the required type definition dependencies for the `react`, `react-dom`, `and`
    `jest` packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The project will use React Router to navigate the pages in the application
    and `FormatJS`, which is a modular collection of JavaScript libraries to support
    internationalization, using the `React Intl` library. The commands to install
    these packages are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There are various approaches to styling React components. We will use styled-components
    for this project to write component-based styling. This package will be installed
    along with its type definition dependency, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'styled-components was discussed in [*Chapter 7*](B18603_07.xhtml#_idTextAnchor239).
    You can also find more details and features on the official website: [https://styled-components.com](https://styled-components.com).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Firebase cloud-based development platform will be used for this application
    to implement an authentication mechanism and backend data storage. So, let’s install
    the latest Firebase version with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the application folder structure is created and the aforementioned dependencies
    are installed, let’s create a few more folders to customize the project as per
    the tech stack. The important folders are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app/store`: The `store` folder is used to create various components of RTK,
    such as actions or action creators, reducers, and selectors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assets`: This folder holds all the image and icon files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backend`: This contains the Firebase-related API and e-commerce application
    data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`features`: The folder is dedicated to the main pages for the web application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i18n`: This contains all the internationalization-specific files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio** (**VS**) Code is widely used and quite popular for React
    development. So, we will use it for this project and the folder structure, after
    adding all the aforementioned folders, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1: The application folder structure](img/Figure_11.01_B18603.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: The application folder structure'
  prefs: []
  type: TYPE_NORMAL
- en: VS Code provides a big list of extensions in its marketplace. In this project,
    the `vscode-styled-components` extension will be used to highlight the syntax
    of styled-components, and the `Prettier` code formatter extension will be used
    to format code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There is no restriction to use a specific IDE. You can use any popular IDE based
    on your preference and required features.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will be introduced to Firebase’s services and required
    configuration and learn about Firebase Authentication and the backend, before
    proceeding with its implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Firebase services and configuring the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firebase is a comprehensive **backend as a service** (**BaaS**) provider offered
    by Google that provides database, authentication, cloud storage, analytics, and
    many other services on the fly. These backend services help developers to build
    apps faster and more securely without requiring much programming code.
  prefs: []
  type: TYPE_NORMAL
- en: What are the main features of Firebase?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get a clearer idea of Firebase, we will look at some of its main features.
    They are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Realtime Database**: The Firebase Realtime Database is a cloud-hosted NoSQL
    database. The data is stored in the JSON format and synchronized in real time
    for every connected client. The database supports all types of platforms such
    as Android, iOS, and web platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, *Realtime* means that any changes to data are reflected immediately across
    the platforms and devices within a few milliseconds. Moreover, the Realtime Database
    provides great offline support by caching all the data you have queried and retrieving
    it from the cache whenever there’s no internet connection. Once a device is connected
    back to the internet, the database synchronizes the local data changes to the
    original remote data to avoid any conflicts occurring with the internet outage.
    As a result, the apps remain responsive.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`FirebaseUI` library as a complete ready-made UI authentication solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud Storage**: Cloud Storage is a simple cost-effective storage service
    for application developers who need to store and process user-generated large-content
    files, such as images, audio, videos, and any other object type. You can use either
    the Firebase SDKs or Google Cloud Storage APIs to access those content files.
    The Firebase SDKs enable secure uploads and downloads from clients directly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Analytics and Crashlytics**: Google Analytics for Firebase is a free
    app measurement solution that helps you get insights into app usage and user engagement.
    This service provides unlimited reporting of up to 500 distinct events, defined
    using the Firebase SDK. This analytics information can be used for business growth
    by retaining more users and making wise decisions for marketing and performance
    optimizations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crashlytics is a real-time crash reporting tool that collects details about
    errors and crashes that occurred in your application. This is helpful to troubleshoot
    an issue by logging the error details, such as the line number where the error
    happened, the device name, the OS version, and when the issue happened.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How do you set up and configure Firebase for authentication and data storage?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the project that you build is based on the Firebase backend, you need to
    take the following steps to create a Firebase app:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the official Firebase console at [https://console.firebase.google.com/](https://console.firebase.google.com/)
    and log in with your Google account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `onestop-electronics`. After that, click on the **Continue** button
    to proceed with the configuration wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will get the option to enable Google Analytics for your project. This is
    optional and not required for this project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click on **Create project**. You need to wait for a while to provision
    the resources and finish the setup of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the web icon on the home page of your project to create your web app.
    This opens a form to enter the web app name. Then click on the **Register App**
    button to integrate the web app with Firebase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, copy the web app’s Firebase-generated configuration, and save it for later
    usage in the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, add Firebase products named `Authentication` to build a secure authentication
    system and `Cloud Firestore` for the cloud-hosted NoSQL database used in the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `Authentication` product is used to store the authenticated user on sign-up,
    and update the user on every sign-in operation, whereas the Firestore database
    will store the application data.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Firestore doesn’t provide read or write permissions. This permission
    flag can be enabled inside the **Rules** tab. The updated security rule looks
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Authentication` product, you can choose sign-in methods such as *email/password*
    and *Google* providers. You can also find several other third-party providers
    under the sign-in provider section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can create multiple projects under a single account, but there is a limit
    for the free plan.
  prefs: []
  type: TYPE_NORMAL
- en: Where do you put Firebase configuration securely in the project?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is not recommended to store the Firebase configuration in a repository that
    will be available on a public development platform, such as GitHub. You can keep
    the configuration in the following `.env.local` file in the key-value format,
    and add it to the `.gitignore` file of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The keys should start with the `VITE` keyword in a Vite-based project, as shown
    in the preceding code. The same keys are accessible in the project through `import.meta.env.VITE`.
    For instance, this configuration is useful to instantiate the Firebase app in
    the `config.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The exported `firebaseApp` from the preceding code can be used anywhere in the
    project when it is required.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you create a React project based on the `REACT_APP` and be accessible through
    the `process.env` variables.
  prefs: []
  type: TYPE_NORMAL
- en: Once the Firebase project is configured, we need to implement the Firebase authentication
    methods that will be invoked upon sign-up and sign-in form submission. Simultaneously,
    Cloud Firestore data operations should be implemented in the form of methods to
    store and retrieve product information. The following section will focus on this
    Firebase API implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Firebase Authentication and its backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the Firebase app is configured in the Firebase console, you can implement
    authentication for the One Stop Electronics application using the Firebase Authentication
    API. These API methods are helpful to authenticate legitimate users when they
    sign up and sign in to purchase products in this e-commerce application. Usually,
    we create all the API handlers inside a separate folder (in our case, `backend->firebase->api`)
    to keep it separate from the frontend code.
  prefs: []
  type: TYPE_NORMAL
- en: How do you implement Firebase authentication for sign-in, sign-up, and sign-out
    scenarios?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to import several Firebase functions and utilities from the `Firebase/auth`
    package to work with the authentication mechanism. The Firebase package provides
    separate methods for sign-in, sign-up, and sign-out scenarios. Let’s start by
    importing all these API methods along with a Firebase instance inside the following
    `api/auth.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `auth` instance has been created based on the Firebase
    app instance. Also, the Google provider has been configured to prompt for Google
    account details to perform Google sign-in authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the preceding API utilities, write down the two sign-in methods in the
    same file mentioned above – one with an email address and a password, and another
    one using Google sign-in authentication. Similarly, the sign-up method can be
    created based on an email address and a password, along with a username. The sign-out
    method will be used to end the current user session. The following `auth.ts` file
    is updated with these authentication methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding exported methods will be integrated with UI screens, especially
    for sign-in or sign-up forms, in the upcoming section where we will build the
    presentation layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, it is also possible to listen to the authenticate state changes using
    the following method. This method is helpful to update the current user details
    in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are ready with all the backend authentication methods, which are helpful
    to create an active user session in the e-commerce application. Once the user
    is authenticated, they can usually perform **create, read, update, and delete**
    (**CRUD**) operations on the application data, based on business needs.
  prefs: []
  type: TYPE_NORMAL
- en: How do you implement cloud store data operations? Can you explain data operations
    with any collection?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike a SQL database, there are no tables and rows within a cloud store database.
    Here, you store data as key-value pairs in the form of documents, which are organized
    into collections. The stored product information is displayed as a part of a landing
    page, which is crucial in this e-commerce application. So, let’s explain data
    operations with a product collection.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to create a product collection to store the electronic device
    data in Firebase’s *Cloud Firestore* database. If the collection does not exist
    in the database, it will be created automatically and insert the product data.
    In this application, the product records (or documents, using Firebase’s terminology)
    are uploaded to the database through a JSON file, available at `firebase/data/products-data.json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by importing all the required functions from the `firebase/firestore`
    package, along with the product type, inside the following `firebase/data/db-utils.ts`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the database instance is created through the
    `getFirestore()` function to perform database operations on the application collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the previously imported functions, you can create read and write operations
    for the product collection in the same file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the product data is inserted with the help of the following
    four steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a collection reference, which is based on the database instance
    and unique key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, create a batch reference based on the database instance to insert multiple
    products at a time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterate each product, and create a document reference to update the batch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, commit the batch to insert multiple records simultaneously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Similarly, the product data is retrieved in four steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a collection reference for products.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, create a query reference based on the collection reference created in
    the previous step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fetch all the documents of the product collection using the `getDocs` method,
    and store them as a snapshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, iterate through the query snapshot and return the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All the preceding cloud store data functions are imported from the `firebase/firestore`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to create a user collection based on each sign-up action,
    triggered through the new user. You can find this specific API handler within
    the code and extend the functionality of this project as per the requirements.
    However, this is out of the scope of this specific section and is the code snippet
    is only commented on for reference.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have completed the backend code. In the following section, let’s create
    all the Redux components to implement a state management solution for this application.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Redux components for state management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Redux store-related components cover most of the application actions, such
    as calculating the business logic, creating or updating the data inside the store,
    and fetching the latest data to display on the UI. In this project, the store
    components are categorized into product, cart, and user folders. Each folder contains
    files such as the entity type (`*.type.ts`), a slice that contains actions or
    a reducer (`*.slice.ts`), and a selector to retrieve the data (`*.selector.ts`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In our e-commerce application, the `Product` entity is required to display
    details such as product name, brand, price, and quantity to showcase all the available
    products. So, let’s create the store components for the product entity first.
    The following `product.type.ts` file creates the product and its relevant types,
    with all possible properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the product types are created, the product slice should be created to
    update the product list and product category in the store. RTK simplifies things
    by keeping these actions inside a reducer as a product slice. The following is
    a product slice with the name `product.slice.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding actions are exported in order to use them on the respective product
    UI page, in response to user actions, whereas the exported reducer is used to
    fetch the store state, such as the products, the category, and the product map,
    based on a category name using the `reselect` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is for the `product.selector.tsx` file. The code for this
    file is quite long, so let’s break it down into smaller code blocks. The first
    code block contains selectors to fetch products, the loading state of the products,
    and the product category:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code block contains a product map with respect to each category:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The One Stop Electronics application uses the preceding `selectProductsMap`
    to filter the products based on a category. Our application has various categories
    such as all types of laptops, tabs, and mobiles.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can create store components for the `User` and `Cart` entities.
  prefs: []
  type: TYPE_NORMAL
- en: How do you work with multiple reducers in a Redux application?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you complete all the Redux entities for the project, all the reducers
    need to be combined in a single root reducer named the `root-reducer.ts` file.
    Here, we will use the `combineReducers` method from Redux, which accepts all the
    reducers as an object in a single argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Thereafter, the store can be configured using the aforementioned root reducer
    inside the `store.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: RTK automatically calls the `combineReducers` method, so you don’t need to invoke
    it directly.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the store is ready to be used for any `read` or `update` operations on
    the application data.
  prefs: []
  type: TYPE_NORMAL
- en: The Redux development is now completed for the entire application using RTK.
    The next section is dedicated to building the presentation layer using UI components
    and web pages based on these reusable components.
  prefs: []
  type: TYPE_NORMAL
- en: Building the presentation layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is a common practice to keep reusable components under the `components` folder.
    In this project, we will create customized form components such as button, input,
    select, and spinner, layout components such as header and footer, and reusable
    functional components such as products and categories inside the `components`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: How do you implement a custom button using styled-components?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The HTML button element doesn’t come with different variations in terms of styling,
    but it is possible to create multiple button variations using React and styled-components.
    Let’s look at a button component and how it can be customized for the purposes
    of this project.
  prefs: []
  type: TYPE_NORMAL
- en: The project requires basic buttons that are bigger in size (mainly used for
    sign-up and sign-in pages), inverted buttons with constrasting colors for Google
    sign-in, and small buttons in scenarios where there is not a lot of space on screen
    (which are often used to add products to a cart). As a first step, the styled-component
    should be created with these different styles inside the `button.styles.tsx` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down the code into small code blocks because of the large content
    in the file. The first code block contains the `BasicButton` styled-component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code block contains two more styled button components that extend
    the basic button. The inverted button inverts the background and text colors of
    the basic button, and while the small button appears to be similar to the basic
    button, it will actually be smaller in size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding styled-components, we have used the `rem` relative unit instead
    of an absolute unit such as `px` to have dynamic sizing or spacing, depending
    on screen size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we import these button styles into the following `button.tsx` file and
    dynamically render the respective button component, based on the button’s type
    prop value. The component also accepts children and other button props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `MyButton` component is typed in such a way that it accepts only
    the `button` type and other built-in HTML button attributes as props. If you pass
    any other button prop that doesn’t belong to the button element, there will be
    a compile-time error due to `TypeScript` usage. The usage of the previously customized
    button appears on several pages of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing business-specific UI components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to a button component, you can create a product box component. The product
    component should display the product image, name, brand, and price details in
    a particular style layout. Let’s apply all the required styles for each field
    inside the `product.styles.tsx` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first code block contains the styled-components import and the type declaration
    for the image background prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code block has a `ProductContainer` styled component, which is
    used to wrap the product image and other product details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code block contains a `Footer` styled-component, which is used
    to style and wrap around the product fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have the styled-component for each product field declared in order
    to give them a unique look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding styled-component, each product field has its own style. For
    example, the name of the product should be in a bigger font size, and the price
    should be in a different font color to highlight the important data while showcasing
    the products.
  prefs: []
  type: TYPE_NORMAL
- en: The styled-components of the previously completed `product.styles.tsx` file
    will be used in the markup, as shown in the following `product.tsx` file. The
    component code is quite long, so let’s break it down into smaller code chunks.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, define the imports of our page, the product’s prop type, and the utility
    function to verify the non-white background images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s add the `ProductItem` component, which accepts `product` as a prop
    without having any markup code. The component declares `currentUser` and `addCartProduct`
    to dispatch the product to the cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the rendered product markup is added, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `ProductItem` component hides the button to add a product to the
    cart if the application is not authenticated by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can create other UI components to reuse them in the required
    pages. Now, let’s build the application pages based on all these reusable UI components.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing application pages using UI components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each web page in a React application is composed of UI components. Our application
    requires product landing, add product to cart, sign-up, and sign-in pages. These
    pages should be created under the `features` folder as per the scaffolding structure.
    The product’s landing page is created by iterating the `Product` component with
    a list of products. The following code is for the `products.tsx` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This file code is quite long, so let’s break it down into smaller code blocks.
    This first code block has imports related to React Hooks, components, selectors,
    and styled-components, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code block is updated with the components code, which has product
    information (i.e., `productsMap` and `category`) retrieved from the store using
    selectors. It also includes the `useEffect` Hook to set the latest products when
    there is a change in the category and product data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the rendered markup for our products page looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `Products` screen displays a page loader until the
    data is retrieved. Once the data is ready, a list of products appears in the grid
    format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversely, the sign-in page can be created using input and button UI components
    to authenticate the Firebase backend. It follows the sign-in process through either
    regular email or the Google sign-in mechanism. The sign-in page to authenticate
    the user appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2: The sign-in page](img/Figure_11.02_B18603.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: The sign-in page'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication through the sign-in page is helpful for adding products to the
    cart. It also provides a link at the bottom for sign-up if there are new users.
    In a similar fashion, you can implement sign-up and cart pages.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is still possible to see the available products irrespective of whether a
    user signs in to the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have reached a position with all the required UI components and pages
    ready to use. As a last step, the application layout can be designed with the
    `Header` and `Footer` UI components, along with the previously implemented pages
    mapped for each route, inside the following `App.tsx` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the routes are configured for each page. The products
    page is configured as a default route. That means that this page will be displayed
    immediately after running the `npm run dev` command in the project root folder.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3: The product showcase](img/Figure_11.03_B18603.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: The product showcase'
  prefs: []
  type: TYPE_NORMAL
- en: Upon adding each product to the cart, the count of cart products will appear
    on the cart icon. If a user doesn’t log in to the application, the add to cart
    button will be hidden. Moreover, you can filter the product list based on the
    selected category, as an additional feature.
  prefs: []
  type: TYPE_NORMAL
- en: Even though we have completed all the pages, the text messages are hardcoded
    in the English language. This means that it will be difficult for non-English
    readers to read the messages. In the following section, the application will be
    enhanced with internationalization support to increase our user base across the
    globe.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting internationalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to launch your current services in the international market, your
    web application should support internationalization to meet the needs of global
    users. In [*Chapter 4*](B18603_04.xhtml#_idTextAnchor150), we covered internationalization
    through the `FormatJS` library.
  prefs: []
  type: TYPE_NORMAL
- en: This project mainly uses the same `FormatJS` library to translate the text messages
    and support the formatted currency amounts. The entire process of extending the
    application with internationalization involves just a few instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create all the translations inside the `i18n->translations` folder in
    the form of JSON files. These translations will be loaded based on the respective
    locales defined inside the `i18n->locale.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you need to configure `IntlProvider` at the root of the application.
    This provider loads specific locale messages, as mapped in the previous step,
    using the `locale` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the current `locale` value is dynamic, and its value
    gets updated based on the locale dropdown that appears in the header section of
    the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can start localizing the text messages and formatting the currency
    number using the `FormattedMessage` and `FormattedNumber` components, respectively,
    from `react-intl`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The preceding translation related to currency amounts not only includes the
    currency symbols but also adds comma separators. For instance, the following add
    to cart screen displays a list of added products with the page text in the German
    language and formatted currency amounts.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4: Products added to the cart](img/Figure_11.04_B18603.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: Products added to the cart'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the comma and decimal separators and the currency symbol position
    are modified based on the selected language. The product quantity and the amount
    values and their formats will be updated upon clicking the increment, decrement,
    and clear buttons on the page.
  prefs: []
  type: TYPE_NORMAL
- en: How do you achieve internationalization through an imperative API?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is not always possible to use `react-intl` components such as `FormattedMessage`,
    `FormattedNumber`, or `FormattedDate` to format text messages, numbers, or dates
    – that is, you cannot use built-in components to format text messages inside text
    attributes such as `title` and `aria-label`, outside the markup area of React
    components and non-React ecosystems such as Node.js, a Redux store, and the testing
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you declare `IntlProvider`, you can get access to the `intl` object (with
    a type of `IntlShape`) by calling the `useIntl()` hook inside the React function
    component. For example, this Hook is used to support internationalization to prepare
    a category list outside the markup section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If you want to support internationalization outside a React component, you need
    to use the `createIntl` API method by passing `locale` and `messages` properties
    in the form of an object.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, we have reached a stage with the completion of a full-fledged backend
    and frontend implementation. In the following section, we will see how to write
    unit tests to ensure that functionality works as per the business requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing testing using the Vitest framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jest is quite a popular testing framework, with a full pack of testing features
    and an easy-to-use API, which makes it a standard testing framework in the web
    ecosystem. This project is based on Vite frontend tooling, and it is also possible
    to integrate Jest in Vite setups. However, this leads to a workspace where you
    have to configure and maintain two different pipelines, which is hard for developers.
    So, we will use **Vitest** for this project, which is a blazing-fast unit testing
    framework based on Jest and Vite tooling. This framework provides similar functionality
    and syntax to the Jest framework, using the existing configuration or plugins
    of Vite tooling.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project, we will write unit tests for all the actions that exist under
    `cart.slice.ts`. First, let’s create the test suite with an initial cart state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the initial state is available, with one cart product
    having a quantity of `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we will write a test case to verify the functionality of increasing quantity
    within the cart, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The preceding test case verifies that the quantity of products increased to
    `3` and the number of distinct products in the cart remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the test case to decrease the product quantity in the cart is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The preceding test case checks the quantity of products after decreasing the
    quantity in the cart. The quantity of products becomes `1` after decreasing or
    removing one item from the cart, which has an initial state quantity value of
    `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we have test cases to clear and reset the cart actions. Once you
    run the `npm run test` command, you can see a summary of all the passed tests
    and failed tests for any incorrect code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, our application is ready with full-fledged development code and covered
    with unit test cases to detect early flaws in the code. Let’s publish this code
    on GitHub as a Git repository to support version control and to make our app work
    smoothly online.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Git repository with README documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currently, the project is ready and able to run the application in a local
    system successfully. To enhance the project further, a hosting platform such as
    GitHub is required, as it provides storage and version control, deploys the project,
    and offers collaboration between various team members seamlessly. Let’s apply
    the following Git commands to push our local code to the GitHub platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, our project is on GitHub, which enables us to easily deploy the application
    on Netlify.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final version of the One Stop Electronics GitHub project with `README.md`
    instructions is available in the Git repository for quick reference: [https://github.com/PacktPublishing/React-Interview-Guide/tree/main/Chapter11/one-stop-electronics](https://github.com/PacktPublishing/React-Interview-Guide/tree/main/Chapter11/one-stop-electronics).'
  prefs: []
  type: TYPE_NORMAL
- en: The following section will discuss the deployment process to make the project
    accessible for the public.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the application for public access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several options to deploy an app, such as Netlify, Vercel, GitHub
    Pages, and Firebase Hosting. We will use Netlify for the deployment by signing
    in through a GitHub account on the Netlify website. On the dashboard, you will
    have the option to select the repository and configure the site through settings.
    It is also possible to change a random site name to a new name. Since an environment
    variable file (e.g., `.env.local`) is not available in the root of the GitHub
    repository, you need to import the environment variable file into the dashboard
    before clicking the **Deploy** **site** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'By following all these steps, the application is now available online for everyone
    to access around the world. You can quickly go through all the screens, which
    are available at the Netlify domain for your reference: [https://onestop-electronics.netlify.app/](https://onestop-electronics.netlify.app/).'
  prefs: []
  type: TYPE_NORMAL
- en: Through continuous deployment, Netlify automatically updates your site when
    the code is updated on the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have reached the end of the chapter and applied all the programming concepts
    learned in the previous chapters to build a robust full stack React application.
    At the beginning of the chapter, we had a quick introduction to scaffolding a
    React project using the standard templates of the Redux library. Later, we briefly
    covered Firebase services and provided step-by-step instructions to set up and
    configure authentication mechanisms, using the Firebase console. Then, we provided
    a detailed implementation of Firebase authentication and Cloud Firestore database
    operations for our One Stop Electronics application.
  prefs: []
  type: TYPE_NORMAL
- en: After the backend was ready to use, we moved on to building the UI layer by
    writing a few React UI components, building the application layout and pages for
    sign-in, sign-up, the product showcase, and cart items. This section was followed
    by implementing a business layer as per the RTK guidelines. Then, the project
    was further enhanced through internationalization support and writing unit tests.
    As the application reached the completion stage, the final step was creating a
    Git repository and making the application accessible online, with a deployment
    process.
  prefs: []
  type: TYPE_NORMAL
- en: After learning all these major milestones of application development, you should
    now be confident enough to showcase your skills in coding challenges and answer
    interview questions, especially armed with your practical working experience.
    In the following chapter, we will build another React app based on different skill
    sets, such as Next.js, GraphQL, SWR, and Vercel, for deployment. This will help
    you to enhance your knowledge of building various types of projects, with a different
    set of techniques and concepts that were not covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
