- en: Angular App Design and Recipes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular应用程序设计和示例
- en: In this chapter, we will complete the implementation of LemonMart. As part of
    the router-first approach, I will demonstrate the creation of reusable routable components
    that also support data binding - the ability to lay out components using auxiliary
    routes of the router, using resolve guards to reduce boilerplate code and leveraging
    class, interfaces, enums, validators, and pipes to maximize code reuse. In addition,
    we will create multi-step forms and implement data tables with pagination, and
    explore responsive design. Along the way, in this book, we will have touched upon
    most of the major functionality that Angular and Angular Material has to offer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将完成LemonMart的实现。作为路由器优先方法的一部分，我将演示创建可重用的可路由组件，这些组件还支持数据绑定 - 使用解析守卫来减少样板代码，并利用类、接口、枚举、验证器和管道来最大程度地重用代码。此外，我们将创建多步骤表单，实现带分页的数据表，并探索响应式设计。在本书中，我们将涉及Angular和Angular
    Material提供的大部分主要功能。
- en: In this chapter, the training wheels are off. I will provide general guidance
    to get you started on an implementation; however, it will be up to you to try
    and complete the implementation on your own. If you need assistance, you may refer
    to the complete source code that is provided with the book or refer to up-to-date
    sample on GitHub at [Github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将放开训练轮。我会提供一般指导来帮助你开始实现；然而，完成实现将取决于你自己的努力。如果你需要帮助，你可以参考本书提供的完整源代码，或者参考GitHub上最新的示例：[Github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将学习以下主题：
- en: Object-oriented class design
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象类设计
- en: Routable reusable components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可路由复用组件
- en: Caching service responses
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存服务响应
- en: HTTP POST requests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP POST请求
- en: Multi-step responsive forms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多步骤响应式表单
- en: Resolve guards
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析守卫
- en: Master/detail views using auxiliary routes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用辅助路由的主/细节视图
- en: Data tables with pagination
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带分页的数据表
- en: User class and object-oriented programming
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户类和面向对象编程
- en: So far, we have only worked with interfaces to represent data, and we still
    want to continue using interfaces when passing data around various components
    and services. However, there's a need to create a default object to initialize
    a `BehaviorSubject`. In **Object-oriented Programming** (**OOP**), it makes a
    lot of sense for the `User` object to own this functionality instead of a service.
    So, let's implement a `User` class to achieve this goal.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用接口来表示数据，并且我们仍然希望在各种组件和服务之间传递数据时继续使用接口。然而，需要创建一个默认对象来初始化`BehaviorSubject`。在**面向对象编程**（**OOP**）中，让`User`对象拥有这个功能比让一个服务拥有更有意义。因此，让我们实现一个`User`类来实现这个目标。
- en: 'Inside the `user/user` folder, define an `IUser` interface and a `User` class
    provided in `UserModule`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在`user/user`文件夹中，定义一个`IUser`接口和一个在`UserModule`中提供的`User`类：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that by defining all properties with default values in the constructors
    as `public` properties, we hit two birds with one stone; otherwise, we will need
    to define properties and initialize them separately. This way, we achieve a concise
    implementation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过在构造函数中将所有属性定义为`public`属性并赋予默认值，我们一举两得；否则，我们将需要分别定义属性并初始化它们。这样，我们实现了简洁的实现。
- en: 'You can also implement calculated properties for use in templates, such as
    being able to conveniently display the `fullName` of a user:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为模板实现计算属性，比如方便地显示用户的`fullName`：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using a `static BuildUser` function, you can quickly hydrate the object with
    data received from the server. You can also implement the `toJSON()` function
    to customize the serialization behavior of your object before sending the data
    up to the server.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`static BuildUser`函数，您可以快速为对象填充从服务器接收到的数据。您还可以实现`toJSON()`函数，以在将数据发送到服务器之前自定义对象的序列化行为。
- en: Reusing components
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重用组件
- en: 'We need a component that can display a given user''s information. A natural
    place for this information to be presented is when the user navigates to `/user/profile`.
    You can see the mock-up `User` profile file:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个能够显示特定用户信息的组件。这些信息被呈现的自然位置是当用户导航到`/user/profile`时。您可以看到`User`配置文件的模拟。
- en: '![](Images/ef9ce93e-84a3-4d59-a6f4-66d2d327507e.png)User profile mock-up'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/ef9ce93e-84a3-4d59-a6f4-66d2d327507e.png)用户配置文件模拟'
- en: 'User information is also displayed mocked up elsewhere in the app, at `/manager/users`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 用户信息还在应用程序的其他位置模拟显示，位于`/manager/users`：
- en: '![](Images/8de496e4-644b-4d38-bac6-7d4507a186ed.png)Manager user management
    mock-up'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/8de496e4-644b-4d38-bac6-7d4507a186ed.png)管理用户管理模拟'
- en: To maximize code reuse, we need to ensure that you design a `User` component
    that can be used in both contexts.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大程度地重用代码，我们需要确保设计一个`User`组件，可以在两个上下文中使用。
- en: As an example, let's complete the implementation of two user profile-related
    screens.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们完成两个与用户配置文件相关的屏幕的实现。
- en: User service with caching, GET and POST
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带缓存、GET和POST的用户服务
- en: 'In order to implement a user profile, we must first implement a `UserService`
    that can perform CRUD operations on `IUser`. Before creating the service, you
    need to be running the `lemon-mart-swagger-server`, so you can pull fake data
    with it while developing:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现用户配置文件，我们必须首先实现一个可以对`IUser`执行CRUD操作的`UserService`。在创建服务之前，您需要运行`lemon-mart-swagger-server`，这样您就可以在开发过程中使用它来拉取虚假数据：
- en: Add a new script called `mock:standalone` to `package.json`
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`package.json`中添加一个名为`mock:standalone`的新脚本
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that this script presumes that you have independently built your swagger
    server on your local machine and/or published from a repository you can pull from.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此脚本假定您已经在本地计算机上独立构建了您的swagger服务器和/或从您可以拉取的存储库中发布了它。
- en: Execute the script
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行脚本
- en: Create a `baseUrl` property in `environment.ts` and `environment.prod.ts` with
    the url to your mock server
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`environment.ts`和`environment.prod.ts`中创建一个`baseUrl`属性，其中包含到您的模拟服务器的url
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a `UserService` under `user/user`, as shown:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`user/user`下创建一个`UserService`，如下所示：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In `UserService`, `currentUser` will serve as the anchor `BehaviorSubject`.
    For the sake of keeping our cache up to date, we subscribe to `currentUser` changes in
    the `constructor`. Additionally, we subscribe to `authStatus`, so when the user
    loads their own profile, `getProfile` can perform a `GET` call using the authenticated
    user's `userId`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UserService`中，`currentUser`将作为锚定`BehaviorSubject`。为了保持我们的缓存最新，我们在`constructor`中订阅`currentUser`的变化。此外，我们订阅`authStatus`，因此当用户加载其自己的配置文件时，`getProfile`可以使用经过身份验证的用户的`userId`执行`GET`调用。
- en: Additionally, we provide a `getUser` function separately and publicly so that
    the manager can load details of other user profiles, which will be needed when
    we implement a master/detail view later in the chapter. Finally, `updateUser`
    accepts an object that implements the `IUser` interface, so the data can be sent
    to a `PUT` endpoint. It is important to highlight that you should always stick
    to interface and not concrete implementations like `User`, when passing data around.
    This is the D in SOLID – the Dependency Inversion Principle. Depending on concrete
    implementations creates a lot of risk, because they change a lot, whereas an abstraction
    such as `IUser` will seldom change. After all, would you solder a lamp directly
    to the electrical wiring in the wall? No, you would first solder the lamp to a
    plug and then use the plug to get the electricity you need.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们单独提供了一个`getUser`函数，以便管理员可以加载其他用户配置文件的详细信息，这在我们稍后在本章实现主/细节视图时将会需要。最后，`updateUser`接受一个实现`IUser`接口的对象，因此数据可以发送到`PUT`端点。重要的是要强调，当传递数据时，您应始终坚持接口而不是像`User`这样的具体实现。这是SOLID原则中的D-依赖反转原则。依赖具体实现会带来很多风险，因为它们经常变化，而像`IUser`这样的抽象很少会改变。毕竟，你会直接把灯焊接到墙上的电线吗？不，你会先把灯焊接到插头上，然后使用插头来获取你需要的电力。
- en: '`UserService` can now be used for basic CRUD operations.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserService`现在可以用于基本的CRUD操作。'
- en: User profile with multi-step auth-enabled responsive forms
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户配置文件与多步鉴权启用的响应式表单
- en: Now, let's implement a multi-step input form to capture user profile information.
    We will also make this multi-step form responsive for mobile devices using media
    queries.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现一个多步输入表单，以捕获用户配置文件信息。我们还将使用媒体查询使这个多步表单对移动设备具有响应性。
- en: 'Let''s start with adding some helper data that will help us display an input
    form with options:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从添加一些辅助数据开始，这些数据将帮助我们显示一个带有选项的输入表单：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Install a helper library to programmatically access TypeScript enum values
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装一个辅助库以以编程方式访问TypeScript枚举值
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Add new validation rules to `common/validations.ts`
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`common/validations.ts`中添加新的验证规则
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now implement `profile.component.ts` as follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在按照以下方式实现`profile.component.ts`：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Upon load, we request the current user from `userService`, but this will take
    a while, so we must first build an empty form with `this.buildUserForm()`. On
    this function, you can also implement a resolve guard, as discussed in a later
    section, to load a user based on their `userId` provided on a route, and pass
    that data into `buildUserForm(routeUser)` and skip loading `currentUser` to increase
    reusability of this component.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载时，我们从`userService`请求当前用户，但这将需要一些时间，因此我们必须首先用`this.buildUserForm()`构建一个空表单。在这个函数中，您还可以实现一个解析守卫，如后面的部分所讨论的那样，根据路由提供的`userId`加载用户，并将该数据传递到`buildUserForm(routeUser)`中，跳过加载`currentUser`以增加此组件的可重用性。
- en: Form groups
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单组
- en: Our form has many input fields, so we will use a `FormGroup`, created by `this.formBuilder.group`
    to house our various `FormControl` objects. Additionally, children `FormGroup`
    objects will allow us to maintain the correct shape of the data structure.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表单有许多输入字段，因此我们将使用`FormGroup`，由`this.formBuilder.group`创建，来容纳我们的各种`FormControl`对象。此外，子`FormGroup`对象将允许我们维护正确的数据结构形状。
- en: 'Start building the `buildUserForm` function, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式开始构建`buildUserForm`函数：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`buildUserForm` optionally accepts an `IUser` to prefill the form, otherwise
    all fields are set to their default values. The `userForm` itself is the top-level
    `FormGroup`. Various `FormControls` are added to it, such as `email`, with validators
    attached to them as needed. Note how `name` and `address` are their own `FormGroup`
    objects. This parent-child relationship ensures proper structure of the form data,
    when serialized to JSON, which fits the structure of `IUser`, in a manner that
    the rest of our application and server-side code can utilize.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildUserForm` 可选地接受一个 `IUser` 来预填表单，否则所有字段都设置为它们的默认值。`userForm` 本身是顶级 `FormGroup`。各种
    `FormControls` 被添加到其中，例如 `email`，并根据需要附加验证器。请注意 `name` 和 `address` 是它们自己的 `FormGroup`
    对象。这种父子关系确保了表单数据的正确结构，当序列化为 JSON 时，它符合 `IUser` 的结构，以便我们的应用程序和服务器端代码可以利用。'
- en: You will completing the implementation of the `userForm` independently following
    the sample code provided for the chapter and I will be going over sections of
    the code piece by piece over the next few sections to explain certain key capabilities.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您将独立完成 `userForm` 的实现，按照本章提供的示例代码，并且我将在接下来的几节中逐步解释代码的某些关键功能。
- en: Stepper and responsive layout
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步进器和响应式布局
- en: 'Angular Material Stepper ships with the MatStepperModule. The stepper allows
    for form inputs to be broken up into multiple steps so that the user is not overwhelmed
    with processing dozens of input fields all at once. The user can still track their
    place in the process and as a side effect, as the developer we breakup our `<form>`
    implementation and enforce validation rules on a step-by-step basis or create
    optional workflows where certain steps can be skipped or required. As with all
    Material user controls, the stepper has been designed with a responsive UX in
    mind. In the next few sections, we will implement three steps covering different
    form-input techniques in the process:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Material Stepper 需要使用 `MatStepperModule`。该步进器允许将表单输入分解为多个步骤，以便用户不会一次处理大量的输入字段。用户仍然可以跟踪他们在流程中的位置，并且作为开发人员，我们可以分解
    `<form>` 实现并逐步强制执行验证规则，或者创建可选的工作流，其中某些步骤可以被跳过或必需的。与所有 Material 用户控件一样，步进器是根据响应式
    UX 设计的。在接下来的几节中，我们将实现三个步骤，涵盖流程中的不同表单输入技术：
- en: Account Information
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 账户信息
- en: Input validation
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入验证
- en: Responsive layout with media queries
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用媒体查询的响应式布局
- en: Calculated properties
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算属性
- en: DatePicker
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期选择器
- en: Contact Information
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 联系信息
- en: Type ahead support
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型提前支持
- en: Dynamic form arrays
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态表单数组
- en: Review
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回顾
- en: Read-only views
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只读视图
- en: Saving and clearing data
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存和清除数据
- en: 'Let''s prep the User module for some new Material modules:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为用户模块准备一些新的 Material 模块：
- en: 'Create a `user-material.module` containing the following Material modules:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `user-material.module`，其中包含以下 Material 模块：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Ensure `user.module` correctly imports:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保 `user.module` 正确导入：
- en: The new `user-material.module`
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的 `user-material.module`
- en: The baseline  `app-material.module`
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基线 `app-material.module`
- en: Required  `FormsModule`, `ReactiveFormsModule` and `FlexLayoutModule`
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要 `FormsModule`、`ReactiveFormsModule` 和 `FlexLayoutModule`
- en: As we start adding sub material modules, it makes sense to rename our root `material.module.ts`
    file to `app-material.modules.ts` inline with how `app-routing.module.ts` is named.
    Going forward, I will be using the latter convention.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始添加子 Material 模块时，将根 `material.module.ts` 文件重命名为 `app-material.modules.ts`
    是有意义的，与 `app-routing.module.ts` 的命名方式一致。今后，我将使用后一种约定。
- en: 'Now, start implementing the first row of the Account Information step:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，开始实现账户信息步骤的第一行：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Take care to understand how the stepper and the form configuration works so
    far, you should be seeing the first row render, pulling mock data:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意了解步进器和表单配置的工作方式，到目前为止，您应该看到第一行呈现，提取模拟数据：
- en: '![](Images/c97a1ab4-0f09-4ffa-988c-7653e3d2fac7.png)Multi-step form - Step
    1'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](Images/c97a1ab4-0f09-4ffa-988c-7653e3d2fac7.png)多步骤表单 - 步骤1
- en: In order to complete the implementation of the form please refer to the sample
    code provided for this chapter or the reference implementation on [GitHub.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成表单的实现，请参考本章提供的示例代码或[GitHub.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)上的参考实现
- en: During your implementation, you will notice that the Review step uses a directive
    named `<app-view-user>`. A minimal version of this component is implemented in
    the ViewUser component section below. However, feel free to implement the capability
    inline for now and refactor your code during the Reusable component with binding
    and route data section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的实现过程中，您会注意到Review步骤使用了一个名为`<app-view-user>`的指令。这个组件的最小版本在下面的ViewUser组件部分中实现了。但是，现在可以随意实现内联功能，并在可重用组件与绑定和路由数据部分重构代码。
- en: 'In the following screenshot, you can see what a completed implementation of
    the multi-step form looks like on a desktop:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，您可以看到桌面上多步骤表单的完成实现是什么样子的：
- en: '![](Images/57c7a762-3c76-479f-8631-9aea9fe153f0.png)Multi-step form on desktop'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](Images/57c7a762-3c76-479f-8631-9aea9fe153f0.png)桌面上的多步骤表单
- en: 'Note that adding `fxLayout.lt-sm="column"` on a row with `fxLayout="row"` enables
    a responsive layout of the form, as shown:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在带有`fxLayout="row"`的行上添加`fxLayout.lt-sm="column"`可以启用表单的响应式布局，如下所示：
- en: '![](Images/b81c87cc-c4d2-47b6-b535-0d4ee3487d63.png)Multi-step form on mobileLet''s
    see how the Date of Birth field works in the next section.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](Images/b81c87cc-c4d2-47b6-b535-0d4ee3487d63.png)移动设备上的多步骤表单让我们看看出生日期字段在下一节中是如何工作的。
- en: Calculated properties and DatePicker
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算属性和日期选择器
- en: 'If you like to display calculated properties based on user input, you can follow
    the pattern shown here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想根据用户输入显示计算属性，可以按照这里显示的模式进行操作：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The usage of calculated properties in the template looks like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 模板中计算属性的使用如下所示：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here it is in action:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的作用：
- en: '![](Images/32973f3a-9310-4b3f-a27a-576e3ae49b15.png)Selecting date with DatePicker'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](Images/32973f3a-9310-4b3f-a27a-576e3ae49b15.png)使用日期选择器选择日期
- en: 'After the date is selected, the calculated age is displayed, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 选择日期后，将显示计算出的年龄，如下所示：
- en: '![](Images/4af6873a-d130-449b-a01d-96b82b2c4fb2.png)Calculated age property'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](Images/4af6873a-d130-449b-a01d-96b82b2c4fb2.png)计算年龄属性
- en: Now, let's move on to the next step, Contact Information and see how we can
    enable a convenient way to display and input the state portion of the address
    field.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一步，联系信息，并看看我们如何能够方便地显示和输入地址字段的州部分。
- en: Type ahead support
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入提示支持
- en: 'In `buildUserForm`, we set a listener on `address.state` to support a type
    ahead filtering drop-down experience:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在`buildUserForm`中，我们设置了一个监听器`address.state`来支持类型向前筛选下拉体验：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'On the template, implement `mat-autocomplete` bound to the filtered states
    array with an `async` pipe:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板上，使用`mat-autocomplete`实现绑定到过滤后的州数组的`async`管道：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here''s how it looks when a user enters the `V` character:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入`V`字符时，它是什么样子：
- en: '![](Images/3ffccda5-771e-4671-afee-6fe029507a19.png)Dropdown with Typeahead
    SupportIn the next section, let''s enable the input of multiple phone numbers.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](Images/3ffccda5-771e-4671-afee-6fe029507a19.png)带有输入提示支持的下拉菜单在下一节中，让我们启用多个电话号码的输入。
- en: Dynamic form arrays
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态表单数组
- en: 'Note that `phones` is an array, potentially allowing for many inputs. We can
    implement this by building a `FormArray` with `this.formBuilder.array` and with
    several helper functions:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`phones`是一个数组，可能允许多个输入。我们可以通过使用`this.formBuilder.array`构建一个`FormArray`和几个辅助函数来实现这一点：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`BuildPhoneArray` supports initializing a form with a single phone input or
    filling it with the existing data, working in tandem with `BuildPhoneFormControl`.
    The latter function comes in handy when a user clicks on an Add button to create
    a new row for entry:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`BuildPhoneArray`支持使用单个电话输入初始化表单，或者使用现有数据填充它，与`BuildPhoneFormControl`协同工作。当用户点击添加按钮创建新的输入行时，后者函数非常有用：'
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `phonesArray` property getter is a common pattern to make it easier to
    access certain form properties. However, in this case, it is also necessary, because
    `get(''phones'')` must be typecast to `FormArray` so that we can access the `length`
    property on it on the template:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`phonesArray`属性的getter是一种常见的模式，可以更容易地访问某些表单属性。然而，在这种情况下，它也是必要的，因为必须将`get(''phones'')`强制转换为`FormArray`，这样我们才能在模板上访问它的`length`属性：'
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `remove` function is implemented inline.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove`函数是内联实现的。'
- en: 'Let''s see how it should be working:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它应该如何工作：
- en: '![](Images/e6301bb9-df06-4398-92f8-e04509c99dd3.png)Multiple inputs using FormArray'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/e6301bb9-df06-4398-92f8-e04509c99dd3.png)使用FormArray的多个输入'
- en: Now that we're done with inputing data, we can move on to the last step of the
    stepper, Review. However, as it was mentioned earlier, the Review step uses the `app-view-user`
    directive to display its data. Let's build that view first.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了输入数据，可以继续进行步进器的最后一步，审查。然而，正如之前提到的，审查步骤使用`app-view-user`指令来显示其数据。让我们先构建那个视图。
- en: ViewUser component
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ViewUser组件
- en: Here's a minimal implementation of the `<app-view-user>` directive that is a
    prerequisite for the Review step.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`<app-view-user>`指令的最小实现，这是审查步骤的先决条件。
- en: 'Create a new `viewUser` component under `user` as shown below:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 按照下面的示例在`user`下创建一个新的`viewUser`组件：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The component above uses input binding with `@Input` to get user data, compliant
    with the `IUser` interface, from an outside component. We implement the `ngOnChanges`
    event, which fires whenever the bound data changes. In this event, we hydrate
    the simple JSON object stored in `this.user` as an instance of the class `User`
    with  `User.BuildUser` and assign it to `this.currentUser`. The template uses
    this variable, because calculated properties like `currentUser.fullName` will
    only work if the data resides in an instance of the class `User`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的组件使用输入绑定与`@Input`来获取用户数据，符合`IUser`接口，来自外部组件。我们实现了`ngOnChanges`事件，每当绑定的数据发生变化时就会触发。在这个事件中，我们使用`User.BuildUser`将存储在`this.user`中的简单JSON对象实例化为`User`类的实例，并将其赋值给`this.currentUser`。模板使用这个变量，因为像`currentUser.fullName`这样的计算属性只有在数据驻留在`User`类的实例中时才能工作。
- en: Now, we are ready to complete the multi-step form.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备完成多步表单。
- en: Review component and Save form
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件审查和保存表单
- en: 'On the last step of the multistep form, users should be able to review and
    then save the form data. As a good practice, a successful `POST` request will
    return the data that was saved back to the browser. We can then reload the form
    with the information received back from the server:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在多步表单的最后一步，用户应该能够审查然后保存表单数据。作为一个良好的实践，成功的`POST`请求将返回保存的数据到浏览器。然后我们可以使用从服务器接收到的信息重新加载表单：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If there are errors, they''ll be set to `userError` to be displayed. Before
    saving, we will present the data in a compact form in a reusable component that
    we can bind the form data to:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有错误，它们将被设置为`userError`以供显示。在保存之前，我们将以紧凑的形式呈现数据，使用一个可重用的组件将表单数据绑定到其中：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is how the final product should look:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最终产品应该是什么样子的：
- en: '![](Images/f3c684b9-b4c6-47c2-9900-482c14ad0fc7.png)Review stepNote the option
    to reset the form. Adding an alert dialog to confirm resetting of user input data
    would be good UX.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/f3c684b9-b4c6-47c2-9900-482c14ad0fc7.png)审查步骤请注意重置表单的选项。添加一个警报对话框来确认重置用户输入数据将是良好的用户体验。'
- en: Now that the user profile input is done, we are about midway into our eventual
    goal of creating a master/detail view where a Manager can click on a user and
    view their profile details. We still have a lot more code to add, and along the
    way, we have fallen into a pattern of adding lots of boilerplate code to load
    the requisite data for a component. In the next section, we will learn about resolve
    guards so that we can simplify our code and reduce boilerplate.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户配置文件输入已完成，我们已经完成了创建主/细节视图的最终目标的一半，其中经理可以点击用户并查看其配置文件详细信息。我们仍然有很多代码要添加，在这个过程中，我们已经陷入了添加大量样板代码来加载组件所需数据的模式。在下一节中，我们将学习解析守卫，以便简化我们的代码并减少样板代码。
- en: Resolve guard
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析守卫
- en: A resolve guard is a type of a router guard, as mentioned in [Chapter 9](55413e2b-68e2-4dd0-9018-133008fc3321.xhtml),* Design
    Authentication and Authorization.* A resolve guard can load necessary data for
    a component by reading record IDs from route parameters, asynchronously load the
    data and have it ready by the time the component activates and initializes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 解析守卫是一种路由守卫，如[第9章](55413e2b-68e2-4dd0-9018-133008fc3321.xhtml)中所述，*设计身份验证和授权*。解析守卫可以通过从路由参数中读取记录ID来加载组件所需的数据，异步加载数据，并在组件激活和初始化时准备好。
- en: 'The major advantages for a resolve guard includes reusability of loading logic,
    reduction of boilerplate code, and also shedding dependencies, because the component
    can receive the data it needs without having to import any service:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 解析守卫的主要优势包括加载逻辑的可重用性、减少样板代码以及减少依赖性，因为组件可以接收到所需的数据而无需导入任何服务：
- en: 'Create a new `user.resolve.ts` class under `user/user`:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`user/user`下创建一个新的`user.resolve.ts`类：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can use a resolve guard as shown:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用解析守卫，如下所示：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `routerLink` will look like this:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`routerLink`将如下所示：'
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'On the ` ngOnInit` hook of the target component, you can read the resolved
    user like this:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标组件的`ngOnInit`钩子中，您可以这样读取已解析的用户：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can observe this behavior in action in the next two sections, after we update `ViewUserComponent` and
    the router to leverage the resolve guard.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在接下来的两个部分中观察到这种行为，之后我们将更新`ViewUserComponent`和路由以利用解析守卫。
- en: Reusable component with binding and route data
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可重用的组件与绑定和路由数据
- en: 'Now, let''s refactor the `viewUser` component, so that we can reuse it in multiple
    contexts. One where it can load its own data using a resolve guard, suitable for
    a master/detail view and another, where we can bind the current user to it, as
    we have done in the Review step of the multi-step input form we built in the prior
    section:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重构`viewUser`组件，以便我们可以在多个上下文中重用它。一个是可以使用解析守卫加载自己的数据，适用于主/细节视图，另一个是可以将当前用户绑定到它，就像我们在之前部分构建的多步输入表单的审阅步骤中所做的那样：
- en: 'Update `viewUser` component with the following changes:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下更改更新`viewUser`组件：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We now have two independent events. One for `ngOnChanges`, which handles what
    value gets assigned to `this.currentUser`, if `this.user` has been bound to. `ngOnInit`
    will only fire once, when the component is first initialized or has been routed
    to. In this case, if any data for the route has been resolved then it'll be assigned
    to `this.currentUser`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个独立的事件。一个是`ngOnChanges`，它处理了如果`this.user`已经绑定，则将值分配给`this.currentUser`。`ngOnInit`只会在组件首次初始化或路由到达时触发。在这种情况下，如果路由的任何数据已经解析，它将被分配给`this.currentUser`。
- en: To be able to use this component across multiple lazy loaded modules, we must
    wrap it in its own module.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在多个惰性加载模块中使用该组件，我们必须将其包装在自己的模块中。
- en: 'Create a new `shared-components.module.ts` under `app`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app`下创建一个新的`shared-components.module.ts`：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Ensure that you import `SharedComponentsModule` module into each feature module
    you intended to use `ViewUserComponent` in. In our case, these will be `User`
    and `Manager` modules.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将`SharedComponentsModule`模块导入到您打算在其中使用`ViewUserComponent`的每个功能模块中。在我们的情况下，这将是`User`和`Manager`模块。
- en: Remove `ViewUserComponent` from the `User` module declarations
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`User`模块声明中删除`ViewUserComponent`
- en: We now have the key pieces in place to begin the implementation of master/detail
    view.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好开始实现主/细节视图了。
- en: Master/detail view auxiliary routes
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主/细节视图辅助路由
- en: The true power of router-first architecture comes to fruition with the use of
    auxiliary routes, where we can influence the layout of components solely through
    router configuration, allowing for rich scenarios where we can remix the existing
    components into different layouts. Auxiliary routes are routes that are independent
    of each other where they can render content in named outlets that have been defined
    in the markup, such as `<router-outlet name="master">` or `<router-outlet name="detail">`.
    Furthermore, auxiliary routes can have their own parameters, browser history,
    children, and nested auxiliaries.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器优先架构的真正力量在于使用辅助路由，我们可以仅通过路由器配置影响组件的布局，从而实现丰富的场景，我们可以将现有组件重新组合成不同的布局。辅助路由是彼此独立的路由，它们可以在已在标记中定义的命名出口中呈现内容，例如`<router-outlet
    name="master">`或`<router-outlet name="detail">`。此外，辅助路由可以有自己的参数、浏览器历史、子级和嵌套辅助。
- en: 'In the following example, we will implement a basic master/detail view using
    auxiliary routes:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用辅助路由实现基本的主/细节视图：
- en: 'Implement a simple component with two named outlets defined:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个具有两个命名出口的简单组件：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Create a `userTable` component under `manager`
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`manager`下创建一个`userTable`组件
- en: 'Update `manager-routing.module` to define the auxiliary routes:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`manager-routing.module`以定义辅助路由：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This means that when a user navigates to `/manager/users`, they'll see the `UserTableComponent`,
    because it is implemented with the `default` path.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当用户导航到`/manager/users`时，他们将看到`UserTableComponent`，因为它是用`default`路径实现的。
- en: Provide `UserResolve` in `manager.module` since `viewUser` depends on it
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`manager.module`中提供`UserResolve`，因为`viewUser`依赖于它
- en: Implement a temporary button in `userTable`
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`userTable`中实现一个临时按钮
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Consider that a user clicks on a View detail button like the one defined above,
    then `ViewUserComponent` will be rendered for the user with the given `userId`.
    In the next screenshot, you can see what the View Details button will look like
    after we implement the data table in the next section:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑用户点击上面定义的查看详情按钮，然后`ViewUserComponent`将为具有给定`userId`的用户呈现。在下一个截图中，您可以看到在我们在下一节中实现数据表后，查看详情按钮将是什么样子：
- en: '![](Images/42796437-7b97-4925-a3b6-4c5ba91b85e5.png)View Details buttonYou
    can have as many combinations and alternative components defined for master and
    detail, allowing for an infinite possibilities of dynamic layouts. However, setting
    up the `routerLink` can be a frustrating experience. Depending on the exact condition,
    you have to either supply or not supply all or some outlets in the link. For example,
    for the preceding scenario, if the link was `[''/manager/users'', { outlets: {
    master: [''''], detail: [''user'', {userId: row.id}] } }]`, the route will silently
    fail to load. Expect these quirks to be ironed out in future Angular releases.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/42796437-7b97-4925-a3b6-4c5ba91b85e5.png)查看详情按钮您可以为主和细节定义许多组合和替代组件，从而允许无限可能的动态布局。然而，设置`routerLink`可能是一种令人沮丧的体验。根据确切的条件，您必须在链接中提供或不提供所有或一些出口。例如，对于前面的情况，如果链接是`[''/manager/users'',
    { outlets: { master: [''''], detail: [''user'', {userId: row.id}] } }]`，路由将悄悄地无法加载。预计这些怪癖将在未来的Angular版本中得到解决。'
- en: Now that, we've completed the implementation of the resolve guard for `ViewUserComponent`,
    you can use Chrome Dev Tools to see the data being loaded correctly. Before debugging,
    ensure that the mock server we created in [Chapter 8,](efa828d3-c66a-4fa9-9b31-11a42937253a.xhtml)
    *Continuous Integration and API Design*, is running.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了对`ViewUserComponent`的解析守卫的实现，您可以使用Chrome Dev Tools来查看数据是否被正确加载。在调试之前，请确保我们在[第8章](efa828d3-c66a-4fa9-9b31-11a42937253a.xhtml)中创建的模拟服务器正在运行。
- en: Ensure that mock server is running by executing either `docker run -p 3000:3000
    -t duluca/lemon-mart-swagger-server` or `npm run mock:standalone`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保模拟服务器正在运行，通过执行`docker run -p 3000:3000 -t duluca/lemon-mart-swagger-server`或`npm
    run mock:standalone`。
- en: 'In Chrome Dev Tools, set a break point right after `this.currentUser` is assigned
    to, as shown:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Chrome Dev Tools中，设置一个断点，就在`this.currentUser`被分配后，如下所示：
- en: '![](Images/051a23aa-c6f1-46a2-bac7-34bd7583f08e.png)Dev Tools Debugging ViewUserComponent'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Dev Tools调试ViewUserComponent
- en: You will observe that `this.currentUser` is correctly set without any boilerplate
    code for loading data inside the `ngOnInit` function, showing the true benefit
    of a resolve guard. `ViewUserComponent` is the detail view; now let's implement
    the master view as a data table with pagination.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您将观察到`this.currentUser`在`ngOnInit`函数内部正确设置，而无需加载数据的样板代码，显示了解析守卫的真正好处。`ViewUserComponent`是细节视图；现在让我们将主视图实现为带分页的数据表。
- en: Data table with pagination
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带分页的数据表
- en: We have created the scaffolding to lay out our master/detail view. In the master
    outlet, we will have a paginated data table of users, so let's implement `UserTableComponent`,
    which will contain a `MatTableDataSource` property named `dataSource`. We will
    need to be able to fetch user data in bulk using standard pagination controls
    like `pageSize` and `pagesToSkip` and be able to further narrow down the selection
    with user provided `searchText`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了用于布置主/细节视图的脚手架。在主输出中，我们将拥有一个用户的分页数据表，因此让我们实现`UserTableComponent`，其中将包含一个名为`dataSource`的`MatTableDataSource`属性。我们需要能够使用标准分页控件（如`pageSize`和`pagesToSkip`）批量获取用户数据，并能够通过用户提供的`searchText`进一步缩小选择范围。
- en: Let's start by adding the necessary functionality to the `UserService`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向`UserService`添加必要的功能开始。
- en: Implement a new interface `IUsers` to describe the data structure of paginated
    data
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个新的接口`IUsers`来描述分页数据的数据结构
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Add `getUsers` to `UserService`
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UserService`中添加`getUsers`
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Set up `UserTable` with pagination, sorting, and filtering:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`UserTable`的分页、排序和过滤：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After initializing the pagination, sorting, and the filter properties, we use
    the `merge` method to listen for changes in all three data streams. If one changes,
    the whole `pipe` is triggered, which contains a call to `this.userService.getUsers`.
    Results are then mapped to the table's `datasource` property, otherwise errors
    are caught and handled.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化分页、排序和过滤属性后，我们使用`merge`方法来监听所有三个数据流的变化。如果有一个变化，整个`pipe`就会被触发，其中包含对`this.userService.getUsers`的调用。然后将结果映射到表格的`datasource`属性，否则会捕获和处理错误。
- en: 'Create a `manager-material.module` containing the following Material modules:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含以下Material模块的`manager-material.module`：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Ensure `manager.module` correctly imports:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保`manager.module`正确导入：
- en: The new `manager-material.module`
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的`manager-material.module`
- en: The baseline  `app-material.module`
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基线`app-material.module`
- en: Required  `FormsModule`, `ReactiveFormsModule` and `FlexLayoutModule`
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必需的`FormsModule`、`ReactiveFormsModule`和`FlexLayoutModule`
- en: 'Finally, implement the `userTable` template:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现`userTable`模板：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'With just the master view, the table looks like this screenshot:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 只有主视图时，表格看起来像这个截图：
- en: '![](Images/05ac9d60-43bf-4e61-a904-af8f94b16208.png)UserTable'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 用户表
- en: 'If you click on the View icon, `ViewUserComponent` will get rendered in the
    detail outlet, as shown:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击查看图标，`ViewUserComponent`将在详细信息输出中呈现，如下所示：
- en: '![](Images/75a8fe77-4da9-4413-b850-b147affe3c90.png)Master/Detail view'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/75a8fe77-4da9-4413-b850-b147affe3c90.png)主/细节视图'
- en: You can then wire up the Edit button and pass the `userId` to the `UserProfile` so
    that the data can be edited and updated. Alternatively, you can render the `UserProfile`
    in place in the detail outlet.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以连接编辑按钮并将`userId`传递给`UserProfile`，以便可以编辑和更新数据。或者，您可以在详细信息输出中直接呈现`UserProfile`。
- en: Data table with pagination completes the implementation of LemonMart for the
    purpose of this book. Now let's make sure all our tests our passing, before we
    move on.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 带分页的数据表完成了LemonMart的实现，以便在本书中使用。现在让我们确保所有的测试都通过，然后再继续。
- en: Updating Unit Tests
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新单元测试
- en: Since we introduced a new `userService`, create a fake implementation for it,
    using the same pattern from `authService` and `commonTestingProviders` with it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我们引入了新的`userService`，为它创建一个伪装实现，使用与`authService`和`commonTestingProviders`相同的模式。
- en: Implement `IUserService` interface for `UserService`
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`UserService`实现`IUserService`接口
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Implement the fake user service
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现伪装用户服务
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Add the user service fake to `commonTestingProviders`
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户服务的伪装添加到`commonTestingProviders`
- en: '[PRE41]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Add `SharedComponentsModule` to `commonTestingModules`
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SharedComponentsModule`添加到`commonTestingModules`
- en: '[PRE42]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Instantiate default data for `UserTableComponent`
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`UserTableComponent`实例化默认数据
- en: 'After fixing up its providers and imports, you will notice `UserTableComponent`
    is still failing to create. This is because, the component initialization logic
    requires `dataSource` to be defined. If undefined, the component can''t be created.
    However, we can easily modify component properties in the second `beforeEach`
    method, which executes after the `TestBed` has injected real, mocked or fake dependencies
    to the component class. See the changes bolded below for test data setup:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 修复提供者和导入后，您会注意到`UserTableComponent`仍然无法创建。这是因为组件初始化逻辑需要定义`dataSource`。如果未定义，组件将无法创建。但是，我们可以在第二个`beforeEach`方法中轻松修改组件属性，该方法在`TestBed`将真实的、模拟的或伪装的依赖项注入到组件类之后执行。查看下面加粗的更改以进行测试数据设置：
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'By now, you may have noticed that just by updating some of our central configuration
    some tests are passing and the rest of tests can be resolved by applying the various
    patterns we have been using throughout the book. For example `user-management.component.spec.ts`
    uses the common testing modules and providers we have created:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能已经注意到，只需更新一些我们中央配置，一些测试就通过了，其余的测试可以通过应用我们在整本书中一直在使用的各种模式来解决。例如`user-management.component.spec.ts`使用了我们创建的常用测试模块和提供者：
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When you are working with providers and fakes, keep in mind what module, component,
    service or class is under test and take care to only provide fakes of dependencies.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用提供者和伪装时，请记住正在测试的模块、组件、服务或类，并小心只提供依赖项的伪装。
- en: '`ViewUserComponent` is a special case, where we can''t use our common testing
    modules and providers, otherwise we would end up creating a circular dependency.
    In this case, manually specify the modules that need to be imported.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewUserComponent`是一个特殊情况，我们不能使用我们的常用测试模块和提供者，否则我们将最终创建循环依赖。在这种情况下，手动指定需要导入的模块。'
- en: Continue fixing unit test configurations until all of them are passing!
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续修复单元测试配置，直到所有测试都通过！
- en: In this book, we didn't cover any functional unit testing, where we would test
    some business logic to test its correctness. Instead, we focused on keeping the
    auto-generated tests in working order. I highly recommend implementing unit tests
    to cover key business logic using the excellent framework provided by Angular
    out-of-the-box.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们没有涉及任何功能单元测试，其中我们会测试一些业务逻辑以测试其正确性。相反，我们专注于保持自动生成的测试处于工作状态。我强烈建议使用Angular开箱即用提供的优秀框架来实现单元测试，以覆盖关键业务逻辑。
- en: You always have the option to write even further elemental unit tests, testing
    classes and functions in isolation using Jasmine. Jasmine has rich test double
    functionality, able to mock and spy on dependencies. It is easier and cheaper
    to write and maintain these kinds of elemental unit tests. However, this topic
    is a deep one in its own right and is beyond the scope of this book.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您始终可以选择进一步编写基本单元测试，使用Jasmine来隔离测试类和函数。Jasmine具有丰富的测试双功能，能够模拟和监视依赖关系。编写和维护这种基本单元测试更容易、更便宜。然而，这个话题本身非常深入，超出了本书的范围。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we completed going over all major Angular app design considerations,
    along with recipes, to be able to implement a line-of-business app with ease.
    We talked about applying object-oriented class design to make hydrating or serializing
    data easier. We created reusable components that can be activated by the router
    or embedded within another component with data binding. We showed that you can
    `POST` data to the server and cache responses. We also created a rich multistep
    input forms that is responsive to changing screen sizes. We removed boilerplate
    code from components by leveraging a resolve guard to load user data. We then
    implemented a master/detail view using auxiliary routes and demonstrated how to
    build data tables with pagination.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们完成了所有主要的Angular应用程序设计考虑，以及配方，以便能够轻松实现一款业务应用程序。我们讨论了应用面向对象的类设计，以使数据的填充或序列化更容易。我们创建了可由路由器激活或嵌入到另一个具有数据绑定的组件中的可重用组件。我们展示了您可以将数据“POST”到服务器并缓存响应。我们还创建了一个响应屏幕尺寸变化的丰富多步输入表单。我们通过利用解析守卫从组件中删除样板代码来加载用户数据。然后，我们使用辅助路由实现了主/详细视图，并演示了如何构建带有分页的数据表。
- en: Overall, by using the router-first design, architecture, and implementation
    approach, we approached our application's design with a good high-level understanding
    of what we wanted to achieve. Also, by identifying reuse opportunities early on,
    we were able to optimize our implementation strategy to implement reusable components
    ahead of time without running the risk of grossly over-engineering our solution.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，通过使用路由器优先设计、架构和实现方法，我们以对我们想要实现的内容有很好的高层次理解来处理我们应用程序的设计。此外，通过及早识别重用机会，我们能够优化我们的实现策略，提前实现可重用组件，而不会冒过度设计解决方案的风险。
- en: In the next chapter, we will set up a highly-available infrastructure on AWS
    to host LemonMart. We will update the project with new scripts to enable no-downtime
    Blue-Green deployments.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将在AWS上设置一个高可用的基础架构来托管LemonMart。我们将使用新的脚本更新项目，以实现无停机的蓝绿部署。
