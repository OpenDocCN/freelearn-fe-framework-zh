- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Handling Navigation with Routes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路由处理导航
- en: Almost every web application requires routing, which is the process of responding
    to a URL based on a set of route handler declarations. In other words, this is
    a mapping from the URL to rendered content. However, this task is more involved
    than it seems at first, due to the complexities of managing different URL patterns
    and mapping them to appropriate content rendering. This includes handling nested
    routes and dynamic parameters and ensuring proper navigation flow. The complexities
    of these tasks are why you’re going to leverage the `react-router` package in
    this chapter, the de facto routing tool for React.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个 Web 应用程序都需要路由，这是根据一组路由处理声明对 URL 进行响应的过程。换句话说，这是 URL 到渲染内容的映射。然而，这项任务比最初看起来要复杂得多，因为管理不同的
    URL 模式并将它们映射到适当的内容渲染涉及到许多复杂性。这包括处理嵌套路由、动态参数以及确保正确的导航流程。这些任务的复杂性是为什么在本章中，你将利用 `react-router`
    包，这是 React 的既定路由工具。
- en: First, you’ll learn the basics of declaring routes using JSX syntax. Then, you’ll
    learn about the dynamic aspects of routing, such as dynamic path segments and
    query parameters. Next, you’ll implement links using components from `react-router`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将学习使用 JSX 语法声明路由的基础知识。然后，你将了解路由的动态方面，例如动态路径段和查询参数。接下来，你将使用 `react-router`
    的组件实现链接。
- en: 'Here are the high-level topics that we’ll cover in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下高级主题：
- en: Declaring routes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明路由
- en: Handling route parameters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理路由参数
- en: Using link components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用链接组件
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter07](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter07).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章的代码文件，地址为 [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter07](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter07)。
- en: Declaring routes
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明路由
- en: With `react-router`, you can collocate routes with the content that they render.
    By defining routes using JSX syntax alongside the components they are associated
    with, `react-router` empowers developers to create a clear and logical structure
    for their React applications. This collocation makes it easier to understand how
    different parts of the application are connected and navigated, leading to improved
    readability and maintainability of the code base.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `react-router`，你可以将路由与它们渲染的内容进行组合。通过使用 JSX 语法定义与组件关联的路由，`react-router` 使开发者能够为他们的
    React 应用程序创建一个清晰且逻辑的结构。这种组合使得理解应用程序的不同部分是如何连接和导航的变得更加容易，从而提高了代码库的可读性和可维护性。
- en: Throughout this chapter, we’ll explore the fundamentals of routing in React
    applications using `react-router`. We’ll start by creating a basic example route
    to familiarize ourselves with the syntax and structure of route declarations.
    Then, we’ll dive deeper into organizing routes by feature, rather than relying
    on a monolithic routing module. Finally, we’ll implement a common parent-child
    routing pattern to demonstrate how to handle more complex routing scenarios.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 `react-router` 探索 React 应用程序中路由的基础知识。我们将从创建一个基本的示例路由开始，以便熟悉路由声明的语法和结构。然后，我们将更深入地研究按功能组织路由，而不是依赖于一个单一的路由模块。最后，我们将实现一个常见的父子路由模式，以展示如何处理更复杂的路由场景。
- en: Hello route
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嗨，路由
- en: 'Before we start writing code, let’s set up the `react-router` project. Run
    the following command to add `react-router-dom` to the dependencies:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，让我们设置 `react-router` 项目。运行以下命令以将 `react-router-dom` 添加到依赖项中：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s create a simple route that renders a simple component:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的路由，它渲染一个简单的组件：
- en: 'First, we have a small React component that we want to render when the route
    is activated:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们有一个小的 React 组件，当路由被激活时我们想要渲染它：
- en: '[PRE1]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, let’s look at the route definition:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们看看路由定义：
- en: '[PRE2]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `RouterProvider` component is the top-level component of the application.
    Let’s break it down to find out what’s happening within the router.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouterProvider` 组件是应用程序的最高级组件。让我们分解它，以了解路由器内部发生了什么。'
- en: 'You have the actual routes declared in the `createBrowserRouter` function.
    There are two key properties of any route: `path` and `element`. When the `path`
    property is matched against the active URL, the component is rendered. But where
    is it rendered, exactly? The router doesn’t actually render anything itself; it’s
    responsible for managing how other components are connected based on the current
    URL. In other words, the router checks the current URL and returns the corresponding
    component from the `createBrowserRouter` declaration. Sure enough, when you look
    at this example in a browser, `<MyComponent>` is rendered as expected:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你在`createBrowserRouter`函数中声明了实际的路线。任何路由都有两个关键属性：`path`和`element`。当`path`属性与活动URL匹配时，组件将被渲染。但它在哪里渲染呢？实际上，路由器并不渲染任何内容；它负责根据当前URL管理其他组件的连接。换句话说，路由器检查当前URL，并从`createBrowserRouter`声明中返回相应的组件。确实，当你在一个浏览器中查看这个例子时，`<MyComponent>`如预期那样被渲染：
- en: '![](img/B19636_07_01.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_07_01.png)'
- en: 'Figure 7.1: The rendered output of our component'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：我们组件的渲染输出
- en: When the `path` property matches the current URL, the route component is replaced
    by the `element` property value. In this example, the route returns `<MyComponent>`.
    If a given route doesn’t match, nothing is rendered.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当`path`属性与当前URL匹配时，路由组件会被`element`属性值替换。在这个例子中，路由返回`<MyComponent>`。如果给定的路由不匹配，则不会渲染任何内容。
- en: This example shows the fundamentals of routing in React. It’s really simple
    and intuitive to declare routes. To further solidify your understanding of `react-router`,
    I encourage you to experiment with the concepts we’ve covered. Try creating more
    routes on your own, and observe how they impact the behavior of your application.
    After that, you can try more advanced techniques like lazy loading components
    using React.lazy and Suspense (you’ll learn more about these in the next chapter),
    and implement route-based code splitting to optimize your application’s performance.
    By diving deeper into these topics and applying them to your own projects, you’ll
    gain a greater appreciation for the capabilities of `react-router` and its role
    in building modern, efficient, and user-friendly React applications.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了React中路由的基础。声明路由非常简单直观。为了进一步巩固你对`react-router`的理解，我鼓励你尝试实验我们覆盖的概念。尝试自己创建更多路由，并观察它们如何影响你应用程序的行为。之后，你可以尝试更高级的技术，比如使用React.lazy和Suspense来懒加载组件（你将在下一章中了解更多关于这些的内容），并实现基于路由的代码拆分以优化你应用程序的性能。通过深入研究这些主题并将它们应用到自己的项目中，你将更加欣赏`react-router`的能力及其在现代、高效和用户友好的React应用程序构建中的作用。
- en: Decoupling route declarations
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解耦路由声明
- en: The difficulty with routing happens when your application has dozens of routes
    declared within a single module since it’s more difficult to mentally map routes
    to features.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 路由的困难在于当你的应用程序在单个模块中声明了数十个路由时，因为将路由映射到功能上在心理上更困难。
- en: 'To help with this, each top-level feature of the application can define its
    own routes. This way, it’s clear which routes belong to which feature. So, let’s
    start with the `App` component:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助解决这个问题，应用程序的每个顶级功能都可以定义自己的路由。这样，就可以清楚地知道哪些路由属于哪个功能。所以，让我们从`App`组件开始：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this example, the application has two routes: `one` and `two`. These are
    imported as route objects and placed inside `createBrowserRouter`. The first `element`
    in this router is the `<Layout />` component, which renders a page template with
    data that never changes and serves as a place for our route data. Let’s take a
    look at the `<Layout />` component:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，应用程序有两个路由：`one`和`two`。这些作为路由对象导入，并放置在`createBrowserRouter`内部。这个路由器中的第一个`element`是`<Layout
    />`组件，它渲染一个带有永不改变的数据的页面模板，并作为我们路由数据的位置。让我们看看`<Layout />`组件：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This component contains a small navigation toolbar with links and the `<Outlet
    />` component. It’s a built-in `react-router` component that will be replaced
    with matched route elements.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件包含一个带有链接和`<Outlet />`组件的小型导航工具栏。它是一个内置的`react-router`组件，它将被匹配的路由元素替换。
- en: 'The router only gets as big as the number of application features, instead
    of the number of routes, which could be substantially larger. Let’s take a look
    at one of the feature routes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 路由的大小仅与应用程序的功能数量相关，而不是路由的数量，这可能会大得多。让我们看看其中一个功能路由：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This module, `one/index.js`, exports a configuration object with three routes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块，`one/index.js`，导出了一个包含三个路由的配置对象：
- en: When the `/one` path is matched, redirect to `/one/1`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`/one`路径匹配时，重定向到`/one/1`。
- en: When the `/one/1` path is matched, render the `First` component.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当匹配到`/one/1`路径时，渲染`First`组件。
- en: When the `/one/2` path is matched, render the `Second` component.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当匹配到`/one/2`路径时，渲染`Second`组件。
- en: This means that when the app loads the URL, `/one`, the `<Redirect>` component,
    will send the user to `/one/1`. Like the `RouterProvider`, the `Redirect` component
    lacks UI elements inside; it solely manages logic.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当应用程序加载URL`/one`时，`<Redirect>`组件将用户发送到`/one/1`。与`RouterProvider`一样，`Redirect`组件内部没有UI元素；它仅管理逻辑。
- en: This aligns with React’s practice of embedding components in layouts to handle
    specific functionalities. This approach allows for a clean separation of concerns,
    with components focused solely on rendering UI elements and others, like `Redirect`,
    dedicated to handling routing logic. The `Redirect` component in `react-router`
    is responsible for programmatically navigating the user to a different route.
    It’s commonly used to redirect users from one URL to another based on certain
    conditions, such as authentication status or route parameters. By abstracting
    away the navigation logic into a separate component, it promotes code reusability
    and maintainability within the application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这与React将组件嵌入布局以处理特定功能的做法相一致。这种方法允许实现关注点的清晰分离，组件专注于渲染UI元素，而其他如`Redirect`等组件则专注于处理路由逻辑。`react-router`中的`Redirect`组件负责将用户程序性地导航到不同的路由。它通常用于根据某些条件（如身份验证状态或路由参数）将用户从一个URL重定向到另一个URL。通过将导航逻辑抽象到单独的组件中，它促进了应用程序中的代码重用和可维护性。
- en: 'You’re using `Redirect` here because we don’t have content on the root route.
    Often, your application doesn’t actually have content to render at the root of
    a feature, or at the root of the application itself. This pattern allows you to
    send the user to the appropriate route and the appropriate content. Here’s what
    you’ll see when you open the app and click on the **One** link:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您在这里使用`Redirect`是因为我们在根路由上没有内容。通常，您的应用程序实际上在功能的根或应用程序本身的根处没有要渲染的内容。这种模式允许您将用户发送到适当的路由和内容。以下是您打开应用程序并点击**One**链接时将看到的内容：
- en: '![](img/B19636_07_02.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_07_02.png)'
- en: 'Figure 7.2: The contents of page 1'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：第1页的内容
- en: 'The second feature follows the exact same pattern as the first. Here’s what
    the `First` component looks like:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个功能遵循与第一个完全相同的模式。以下是`First`组件的示例：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Each feature, in this example, uses the same minimal rendered content. These
    components are ultimately what the user needs to see when they navigate to a given
    route. By organizing routes this way, you’ve made your features self-contained
    with regard to routing.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每个功能都使用相同的最小渲染内容。这些组件是用户在导航到特定路由时最终需要看到的内容。通过这种方式组织路由，您已经使功能在路由方面具有自包含性。
- en: In the following section, you’ll learn how to further organize your routes into
    parent-child relationships.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何进一步将路由组织成父子关系。
- en: Handling route parameters
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理路由参数
- en: The URLs that you’ve seen so far in this chapter have all been static. Most
    applications will use both **static** and **dynamic** routes. In this section,
    you’ll learn how to pass dynamic URL segments to your components, how to make
    these segments optional, and how to get query string parameters.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中您所看到的URL都是静态的。大多数应用程序将同时使用**静态**和**动态**路由。在本节中，您将学习如何将动态URL段传递给组件，如何使这些段可选，以及如何获取查询字符串参数。
- en: Resource IDs in routes
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由中的资源ID
- en: One common use case is to make the ID of a resource part of the URL. This makes
    it easy for your code to get the ID and then make an **API** call that fetches
    the relevant resource data. Let’s implement a route that renders a user detail
    page. This will require a route that includes the user ID, which then needs to
    somehow be passed to the component so that it can fetch the user.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的用例是将资源的ID作为URL的一部分。这使得您的代码能够获取ID，然后执行一个**API**调用以获取相关资源数据。让我们实现一个渲染用户详情页的路由。这需要一个包含用户ID的路由，然后需要以某种方式将用户ID传递给组件，以便它可以获取用户信息。
- en: 'Let’s start with the `App` component that declares the routes:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从声明路由的`App`组件开始：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `:` syntax marks the beginning of a URL variable. The `id` variable will
    be passed to the `UserContainer` component. Before displaying the component, the
    `loader` function is triggered, asynchronously fetching data for the specified
    user ID. In the case of data loading errors, the `errorElement` prop provides
    a fallback to handle such situations effectively. Here’s how `UserContainer` is
    implemented:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`:` 语法标记了URL变量的开始。`id` 变量将被传递给 `UserContainer` 组件。在显示组件之前，`loader` 函数被触发，异步获取指定用户ID的数据。在数据加载错误的情况下，`errorElement`
    属性提供了一个回退来有效地处理这种情况。以下是 `UserContainer` 的实现方式：'
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `useParams()` hook is used to get any dynamic parts of the URL. In this
    case, you’re interested in the `id` parameter. Then, we get `user` from the loader
    function using the `useLoaderData` hook. If the URL is missing the segment completely,
    then this code won’t run at all; the router will revert us to the `errorElement`
    component.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`useParams()` 钩子用于获取URL的任何动态部分。在这种情况下，您对 `id` 参数感兴趣。然后，我们使用 `useLoaderData`
    钩子从 `loader` 函数中获取 `user`。如果URL完全缺少该部分，则此代码根本不会运行；路由器将使我们回退到 `errorElement` 组件。'
- en: 'Now, let’s take a look at the API functions that were used in this example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看在这个示例中使用的API函数：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `fetchUsers()` function is used by the `UsersContainer` component to populate
    the list of user links. The `fetchUser()` function will find and resolve a value
    from the `users` array of the mock data.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchUsers()` 函数由 `UsersContainer` 组件用于填充用户链接列表。`fetchUser()` 函数将从模拟数据的 `users`
    数组中查找并解析一个值。'
- en: 'Here is the `User` component, which is responsible for rendering the user details:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `User` 组件，它负责渲染用户详细信息：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When you run this app and navigate to `/`, you should see a list of users that
    looks like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此应用程序并导航到 `/` 时，您应该会看到一个用户列表，看起来像这样：
- en: '![](img/B19636_07_03.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_07_03.png)'
- en: 'Figure 7.3: The contents of the app home page'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：应用程序主页的内容
- en: 'Clicking on the first link should take you to `/users/0`, which looks like
    this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 点击第一个链接应将您带到 `/users/0`，看起来像这样：
- en: '![](img/B19636_07_04.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_07_04.png)'
- en: 'Figure 7.4: The contents of the user page'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：用户页面的内容
- en: 'If you navigate to a user that doesn’t exist, for example, `/users/2`, here’s
    what you’ll see:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您导航到一个不存在的用户，例如 `/users/2`，您将看到以下内容：
- en: '![](img/B19636_07_05.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_07_05.png)'
- en: 'Figure 7.5: When a user isn’t found'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：当找不到用户时
- en: 'The reason that you get this error message instead of a 500 error is that the
    API endpoint knows how to deal with missing resources:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您得到此错误消息而不是500错误的原因是API端点知道如何处理缺失的资源：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This rejection will be handled by `react-router` with the provided `errorElement`
    component.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此拒绝将由 `react-router` 使用提供的 `errorElement` 组件来处理。
- en: In the next section, we’ll look at defining optional route parameters.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨定义可选路由参数。
- en: Query parameters
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询参数
- en: Sometimes, we need optional URL path values or query parameters. URLs work best
    for simple options, and query parameters work best if there are many values that
    the component can use.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要可选的URL路径值或查询参数。对于简单的选项，URL效果最好；如果组件可以使用许多值，则查询参数效果最好。
- en: 'Let’s implement a user list component that renders a list of users. Optionally,
    you want to be able to sort the list in descending order. Let’s make this with
    the route that can accept a query string:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个用户列表组件，用于渲染用户列表。可选地，您希望能够按降序排序列表。让我们使用可以接受查询字符串的路由来实现这一点：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There is no special setup in the router for handling query parameters. It’s
    up to the component to handle any query strings provided to it. So, while the
    route declaration doesn’t provide a mechanism to define accepted query strings,
    the router will still pass the query parameters to the component. Let’s take a
    look at the user list container component:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器中没有特殊设置用于处理查询参数。处理任何提供的查询字符串的责任在于组件。因此，虽然路由声明没有提供定义接受查询字符串的机制，但路由器仍然会将查询参数传递给组件。让我们看看用户列表容器组件：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This component looks for either of the `order` query strings. It uses this as
    an argument to the `fetchUsers()` API to determine the sort order.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件查找任一 `order` 查询字符串。它使用此作为 `fetchUsers()` API 的参数来确定排序顺序。
- en: 'Here’s what the `Users` component looks like:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Users` 组件的外观：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is what’s rendered when you navigate to `/`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当您导航到 `/` 时，以下是渲染的内容：
- en: '![](img/B19636_07_06.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_07_06.png)'
- en: 'Figure 7.6: Rendering the user list in default order'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：按默认顺序渲染用户列表
- en: 'If you include the `order` query parameter by navigating to `/?order=desc`,
    here’s what you get:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过导航到`/?order=desc`包含`order`查询参数，你将得到以下内容：
- en: '![](img/B19636_07_07.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_07_07.png)'
- en: 'Figure 7.7: Rendering the user list in descending order'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：按降序渲染用户列表
- en: In this section, you learned about parameters in routes. Perhaps the most common
    pattern is to have the ID of a resource in your app as part of the URL, which
    means that components need to be able to parse out this information in order to
    interact with the API. You also learned about query parameters in routes, which
    are useful for dynamic content, filtering, or passing temporary data between components.
    Next, you’ll learn about link components.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了关于路由中的参数。可能最常见的一种模式是将应用中资源的ID作为URL的一部分，这意味着组件需要能够解析出这些信息以便与API交互。你还学习了关于路由中的查询参数，这对于动态内容、过滤或组件之间传递临时数据非常有用。接下来，你将学习关于链接组件的内容。
- en: Using link components
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用链接组件
- en: In this section, you’ll learn how to create links. You might be tempted to use
    the standard `<a>` elements to link to pages controlled by `react-router`. The
    problem with this approach is that these links, in simple terms, will try to locate
    the page on the backend by sending a `GET` request. This isn’t what you want because
    the route configuration is already in the app and we can handle routes locally.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何创建链接。你可能倾向于使用标准的`<a>`元素来链接到由`react-router`控制的页面。这种方法的缺点是，从简单来说，这些链接将尝试通过发送`GET`请求在后台定位页面。这不是你想要的，因为路由配置已经在应用中，并且我们可以本地处理路由。
- en: First, you’ll see an example that illustrates how `<Link>` components behave
    somewhat like `<a>` elements, except that they work locally. Then, you’ll see
    how to build links that use URL parameters and query parameters.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将看到一个示例，说明`<Link>`组件的行为与`<a>`元素类似，但它们是本地工作的。然后，你将学习如何构建使用URL参数和查询参数的链接。
- en: Basic linking
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本链接
- en: 'The idea of links in React apps is that they point to routes that point to
    components, which render new content. The `Link` component also takes care of
    the browser history API and looks up route-component mappings. Here’s an application
    component that renders two links:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: React应用中链接的概念是它们指向指向组件的路由，这些组件渲染新的内容。`Link`组件还负责浏览器历史API并查找路由-组件映射。以下是一个渲染两个链接的应用组件：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `to` property specifies the route to activate when clicked. In this case,
    the application has two routes: `/first` and `/second`. Here is what the rendered
    links look like:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`to`属性指定了点击时激活的路由。在这种情况下，应用程序有两个路由：`/first`和`/second`。以下是渲染的链接的外观：'
- en: '![](img/B19636_07_08.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_07_08.png)'
- en: 'Figure 7.8: Links to the first and second pages of the app'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：应用的第一页和第二页的链接
- en: 'When you click the **First** link, the page content changes to look like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击**第一个**链接时，页面内容将改变，看起来像这样：
- en: '![](img/B19636_07_09.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_07_09.png)'
- en: 'Figure 7.9: The first page when the app is rendered'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9：应用渲染时的第一页
- en: Now that you can use `Link` components to render links to basic paths, it’s
    time to learn about building dynamic links with parameters.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经可以使用`Link`组件渲染到基本路径的链接，是时候学习如何使用参数构建动态链接了。
- en: URL and query parameters
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: URL和查询参数
- en: Constructing the dynamic segments of a path that is passed to `<Link>` involves
    string manipulation. Everything that’s part of the path goes to the `to` property.
    This means that you have to write more code to construct the string, but it also
    means less behind-the-scenes magic happening in the router.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 构建传递给`<Link>`的路径的动态段涉及字符串操作。路径的任何部分都发送到`to`属性。这意味着你需要编写更多的代码来构建字符串，但也意味着在路由器中幕后发生的魔法更少。
- en: 'Let’s create a simple component that will echo back whatever is passed to the
    echo URL segment or the echo query parameter:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的组件，它将回显传递给echo URL段或echo查询参数的内容：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In order to get search parameters that were passed to a route, you can use the
    `useSearchParams()` hook, which gives you a `URLSearchParams` object. In this
    case, we can call `searchParams.get("msg")` to get the parameter we need.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取传递给路由的搜索参数，你可以使用`useSearchParams()`钩子，它给你一个`URLSearchParams`对象。在这种情况下，我们可以调用`searchParams.get("msg")`来获取所需的参数。
- en: 'Now, let’s take a look at the `App` component that renders two links. The first
    will build a string that uses a dynamic value as a URL parameter. The second will
    use `URLSearchParams` to build the query string portion of the URL:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看渲染两个链接的`App`组件。第一个将构建一个使用动态值作为URL参数的字符串。第二个将使用`URLSearchParams`构建URL的查询字符串部分：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here’s what the two links look like when they’re rendered:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是两个链接渲染后的样子：
- en: '![](img/B19636_07_10.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_07_10.png)'
- en: 'Figure 7.10: Different types of link parameters'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10：不同类型的链接参数
- en: 'The **Param** link takes you to `/echo/From%20Param`, which looks like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数**链接将你带到`/echo/From%20Param`，看起来像这样：'
- en: '![](img/B19636_07_11.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_07_11.png)'
- en: 'Figure 7.11: The param version of the page'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11：页面的参数版本
- en: 'The **Query** link takes you to `/echo?msg=From+Query`, which looks like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**查询**链接将你带到`/echo?msg=From+Query`，看起来像这样：'
- en: '![](img/B19636_07_12.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_07_12.png)'
- en: 'Figure 7.12: The query version of the page'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12：页面的查询版本
- en: In learning about the `Link` component and dynamic link construction, you’ve
    unlocked a more interactive and navigable web experience, empowering users to
    move through your application with URL and query parameters that enrich their
    journey.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解`Link`组件和动态链接构建的过程中，你解锁了更互动和可导航的网页体验，使用户能够通过包含丰富旅程的URL和查询参数在应用程序中移动。
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about routing in React applications. The job of
    a router is to render content that corresponds to a URL. The `react-router` package
    is the standard tool for this job. You learned how routes are JSX elements, just
    like the components they render. Sometimes, you need to split routes into feature-based
    modules. A common pattern for structuring page content is to have a parent component
    that renders the dynamic parts as the URL changes. Then, you learned how to handle
    the dynamic parts of URL segments and query strings. You also learned how to build
    links throughout your application using the `<Link>` element.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了React应用程序中的路由。路由器的工作是渲染与URL相对应的内容。`react-router`包是完成这项工作的标准工具。你学习了路由是如何像它们渲染的组件一样是JSX元素。有时，你需要将路由拆分成基于功能的模块。结构页面内容的一个常见模式是有一个父组件，它根据URL的变化渲染动态部分。然后，你学习了如何处理URL段和查询字符串的动态部分。你还学习了如何使用`<Link>`元素在你的应用程序中构建链接。
- en: Understanding routing in React applications lays the groundwork for building
    complex applications with efficient navigation, preparing you for the subsequent
    chapters that delve into performance optimization, state management, and integrating
    external APIs, ensuring a seamless user experience.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 理解React应用程序中的路由为构建具有高效导航的复杂应用程序奠定了基础，为后续章节深入性能优化、状态管理和集成外部API做好了准备，确保了无缝的用户体验。
- en: In the next chapter, you’ll learn how to split your code into smaller chunks
    using lazy components.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何使用懒组件将你的代码拆分成更小的块。
