- en: Chapter 4. Stateful Components and Events
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. 状态组件和事件
- en: In this chapter, we will exploit the React states and events in detail. This
    chapter will cover the components that have a state, the practices to communicate
    between them, and how to respond to users input/events in order to have the UI
    reflect this state. We will develop a web page where we can update the name of
    our liked pages from Facebook. This also covers how the state changes your React
    UI having enhanced performance using the virtual DOM.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细探讨 React 状态和事件。本章将涵盖具有状态的组件、它们之间的通信实践以及如何响应用户输入/事件，以便使 UI 反映这种状态。我们将开发一个网页，我们可以从中更新我们喜欢的
    Facebook 页面的名称。这也涵盖了状态如何通过使用虚拟 DOM 提高性能来改变你的 React UI。
- en: 'This chapter will cover the following items:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: React states
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 状态
- en: Event ecosystem
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件生态系统
- en: Properties versus states in ReactJS
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReactJS 中属性与状态的区别
- en: Let's glance through the differences between props and states in React.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地看一下 React 中 props 和 states 之间的区别。
- en: '**Properties** are declared when React components are created, while **states**
    are declared within the component definitions. Thus, during the component initialization
    phase props are declared.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性**是在创建 React 组件时声明的，而 **状态**是在组件定义内声明的。因此，在组件初始化阶段声明 props。'
- en: In most of the scenarios, React components take data and pass in the form of
    props. In the other cases, when you are required to take user input to have a
    server request, states are used.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大多数情况下，React 组件以 props 的形式接收数据。在其他情况下，当你需要接收用户输入以进行服务器请求时，使用状态。
- en: '`(this.props)` is used to access parameters passed from the parent component,
    while `(this.state)` is used to manage dynamic data. State should be considered
    private data.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(this.props)` 用于访问从父组件传递的参数，而 `(this.state)` 用于管理动态数据。状态应被视为私有数据。'
- en: Exploring the state property
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索状态属性
- en: In the last chapter, we explored React properties (**props**). Just as components
    can have properties, they can also have **states**. States are primarily set to
    those components where it is necessary to change, for example if the component
    has to be updated or replaced in future. Thus, it is not mandatory to have a state
    for the entire component.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了 React 属性（**props**）。正如组件可以有属性一样，它们也可以有 **states**。状态主要设置在那些需要改变的组件中，例如如果组件在未来需要更新或替换。因此，对于整个组件来说，拥有状态不是强制性的。
- en: 'Components can be both stateless and stateful:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以是无状态的或状态化的：
- en: '**Stateless components** are those where only props are present, but no state
    is defined. Thus, there will no change in these prop values for these components
    within the component life cycle. The only source of static data should be presented
    to the component instance via the props. Thus, props are immutable data for a
    React component.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态组件**是那些只有 props 的组件，但没有定义状态。因此，这些组件在其组件生命周期内这些 prop 值将不会发生变化。静态数据的唯一来源应通过
    props 呈现给组件实例。因此，对于 React 组件来说，props 是不可变数据。'
- en: '**Stateful components:** Stateless components, are meant to represent any React
    component declared as a function that has no state and returns the same markup
    given the same props. As the name implies, stateful components are those where
    both props and states are declared. Generally, any kind of such data-change communication
    is done via the state change `[setState(data, callback)]`. The updated state is
    then rendered in the UI. In case of interactive apps `[form submission etc]` where
    the data changes continuously, it''s necessary to have such stateful components.
    Otherwise, for non-interactive apps, it''s advisable to have fewer stateful components,
    because they increase complexity and redundancy in the app.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态化组件**：无状态组件是指那些被声明为没有状态且返回相同标记的函数的 React 组件。正如其名所示，状态化组件是那些声明了 props 和
    states 的组件。通常，这种数据更改通信是通过状态更改 `[setState(data, callback)]` 来完成的。然后更新后的状态将在 UI
    中渲染。在交互式应用程序 `[表单提交等]` 中，数据不断变化时，需要这样的状态化组件。否则，对于非交互式应用程序，建议拥有较少的状态化组件，因为它们会增加应用程序的复杂性和冗余。'
- en: Initializing a state
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化状态
- en: 'Initialization of a component state is done by the method `getInitialState()`,
    which returns an object:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 组件状态的初始化是通过 `getInitialState()` 方法完成的，它返回一个对象：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `getInitialState()` method is invoked once before the component is mounted.
    The return value will be used as the initial value of `this.state`
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`getInitialState()` 方法在组件挂载之前被调用一次。返回值将用作 `this.state` 的初始值。'
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For all the following examples, we have the same content in the `index.html`
    file. Thus, we can use the same `index.html` file and only change the contents
    of the corresponding JavaScript file based on the topic being discussed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有以下示例，我们在 `index.html` 文件中有相同的内容。因此，我们可以使用相同的 `index.html` 文件，并且只需根据讨论的主题更改相应的JavaScript文件的内容。
- en: 'We can create a React stateful component as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个如下所示的React有状态组件：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `getInitialState`() method initiates the component with the values (name:
    `Doel`, id: `1`), during the first render cycle. These values are persisted until
    the state values are changed and can be collected by running `{this.state.<VALUE>}`.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`getInitialState()` 方法在第一次渲染周期中用值（name: `Doel`，id: `1`）初始化组件。这些值在状态值更改之前保持不变，并且可以通过运行
    `{this.state.<VALUE>}` 来收集。'
- en: Setting a state
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置状态
- en: Data change in React is commonly done by invoking the method `setState(data,
    callback)`, which together with the data of `this.state` re-renders the component.
    If you provide an optional callback argument, React will call it when executing
    this method, although usually it's not required as React keeps the UI updated.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，数据更改通常是通过调用方法 `setState(data, callback)` 来实现的，该方法与 `this.state` 的数据一起重新渲染组件。如果你提供了一个可选的回调参数，React将在执行此方法时调用它，尽管通常不需要，因为React会保持UI更新。
- en: A state is set from inside the component.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 状态是在组件内部设置的。
- en: 'The following code shows how the state is updated/set:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何更新/设置状态：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is what we did:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的操作：
- en: Changed values in states are reflected only after the component is mounted.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态中的更改值仅在组件挂载后才会反映出来。
- en: Mounting of the component happens when it has been passed to `React.render(<Component
    />)`.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件的挂载发生在它被传递给 `React.render(<Component />)` 时。
- en: Our event handler `onClick` calls the `handleClick()` function, which is internally
    calling `this.state`(). So when the `onClick` event is initialized on the name
    `doel`, it will change its value from `doel` to `doel sengupta`.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的事件处理器 `onClick` 调用 `handleClick()` 函数，该函数内部调用 `this.state()`。因此，当 `onClick`
    事件在名称 `doel` 上初始化时，它将值从 `doel` 更改为 `doel sengupta`。
- en: 'In the React documentation ([http://facebook.github.io/react/docs/interactivity-and-dynamic-uis.html](http://facebook.github.io/react/docs/interactivity-and-dynamic-uis.html)),
    Facebook recommends:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在React文档([http://facebook.github.io/react/docs/interactivity-and-dynamic-uis.html](http://facebook.github.io/react/docs/interactivity-and-dynamic-uis.html))中，Facebook建议：
- en: Have many stateless components to render data and a stateful component as parent,
    which passes its states to the stateless children via props.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多无状态组件用于渲染数据，以及一个作为父组件的有状态组件，它通过属性将状态传递给无状态子组件。
- en: Essentially, the function of the stateful component is to contain the interaction
    logic and the stateless components render the data.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从本质上讲，有状态组件的功能是包含交互逻辑，而无状态组件渲染数据。
- en: The state of a component has the data that is manipulated by the component's
    event handlers.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件的状态包含由组件的事件处理器操作的数据。
- en: You should keep minimal data in `this.state` and perform all the computations
    within the `render` method. This reduces redundancy or storage of computed values
    and ensures more reliability on React's computational abilities.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该在 `this.state` 中保持最小数据，并在 `render` 方法中执行所有计算。这减少了冗余或计算值的存储，并确保对React的计算能力有更高的可靠性。
- en: React components should be built within `render`() based on the underlying props
    and states
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React组件应该在 `render()` 方法中基于底层属性和状态构建
- en: Props should be essentially used as the source of truth. Any data that can be
    changed via the user's input or otherwise, should be stored in states.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该将属性基本上用作真相的来源。任何可以通过用户的输入或其他方式更改的数据，都应该存储在状态中。
- en: Replacing a state
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换状态
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here''s the code for `replace_state.js`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `replace_state.js` 的代码：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `replaceState`() method is used when existing values are to be cleared and
    new ones have to be added.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要清除现有值并添加新值时，使用 `replaceState()` 方法。
- en: 'Here''s what the app looks like when it is run for the first time:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应用首次运行时的样子：
- en: '![Replacing a state](img/00014.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![替换状态](img/00014.jpeg)'
- en: App screenshot during initial page load
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 初始页面加载时的应用截图
- en: 'After the page initially loads, the value of the `first_name` attribute is
    `michael`, but when the `onClick` function is called the value changes to `undefined`.
    The component states with the attributes `first_name` and `last_name` have been
    replaced with only `last_name` when `replaceState`() is called. The following
    screenshot illustrates this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 页面最初加载后，`first_name`属性的值是`michael`，但当`onClick`函数被调用时，值变为`undefined`。当调用`replaceState()`时，具有`first_name`和`last_name`属性的组件状态被替换为只有`last_name`。以下截图说明了这一点：
- en: '![Replacing a state](img/00015.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![替换状态](img/00015.jpeg)'
- en: Re-rendering the component after replaceState() is called
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用replaceState()后重新渲染组件
- en: A React state example using an interactive form
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用交互表单的React状态示例
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When we first run the code we see:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次运行代码时，我们看到：
- en: '![A React state example using an interactive form](img/00016.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![使用交互表单的React状态示例](img/00016.jpeg)'
- en: User interactive form
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 用户交互表单
- en: 'After typing in the textbox, the value below automatically changes, as seen
    here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本框中输入后，下面的值会自动更改，如下所示：
- en: '![A React state example using an interactive form](img/00017.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![使用交互表单的React状态示例](img/00017.jpeg)'
- en: Form data updated using this.setState()
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用this.setState()更新的表单数据
- en: Let's now dig deeper into how events flow within a React ecosystem.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更深入地了解事件在React生态系统中的流动方式。
- en: Events
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: React uses `SyntheticEvent`, which is a cross-browser wrapper around the browser's
    native event. So all the event handlers in the react applications will be passed
    instances of `SyntheticEvent`. React's event ecosystem has the same interface
    as any of the browser's native events with the advantage that it works identically
    in all the browsers and provides `stopPropagation`() and `preventDefault`() too.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: React使用`SyntheticEvent`，这是一个围绕浏览器原生事件的跨浏览器包装器。因此，react应用程序中的所有事件处理程序都将传递`SyntheticEvent`的实例。React的事件生态系统具有与浏览器原生事件相同的接口，其优势在于它在所有浏览器中工作方式相同，并提供`stopPropagation`()和`preventDefault`()。
- en: 'If React is installed as an NPM module, then these `SyntheticEvent`-related
    files can be found in the following location within your app: `app/node_modules/react/lib`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果React作为NPM模块安装，那么这些与`SyntheticEvent`相关的文件可以在您的应用程序中的以下位置找到：`app/node_modules/react/lib`。
- en: 'All these events comply with the W3C standard. The main event flow happens
    as:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些事件都符合W3C标准。主要事件流程如下：
- en: 'Dispatching the event : `@param {object} dispatchConfig`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发事件：`@param {object} dispatchConfig`
- en: 'Marker identifying the event target: `@param {object} dispatchMarker`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识事件目标的标记：`@param {object} dispatchMarker`
- en: 'Native event: `@param {object} nativeEvent`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生事件：`@param {object} nativeEvent`
- en: The way React uses this event delegation is by listening to the nodes that have
    listeners. Depending on the event handlers on the particular node, the synthetic
    event system of React implements its own bubbling.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: React使用此事件委托的方式是通过监听具有监听器的节点。根据特定节点上的事件处理程序，React的合成事件系统实现了自己的冒泡。
- en: Some of the event names in the Synthetic Event system are as follows. Refer
    to the Facebook documentation for the complete list of the listed registered events.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 合成事件系统中的一些事件名称如下。有关注册事件的完整列表，请参阅Facebook文档。
- en: Form events
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单事件
- en: 'Event names for Form events are:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单事件的事件名称：
- en: '`onChange`, `onInput`, `onSubmit`'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onChange`, `onInput`, `onSubmit`'
- en: Note
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about the `onChange` event, refer to Forms ([https://facebook.github.io/react/docs/forms.html](https://facebook.github.io/react/docs/forms.html)).
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关`onChange`事件的更多信息，请参阅表单([https://facebook.github.io/react/docs/forms.html](https://facebook.github.io/react/docs/forms.html))。
- en: Mouse events
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 鼠标事件
- en: 'Event names for Mouse events are:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标事件的事件名称：
- en: '`onClick`, `onContextMenu`, `onDoubleClick`, `onDrag`, `onDragEnd`, `onDragEnter`,
    `onDragExit`'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onClick`, `onContextMenu`, `onDoubleClick`, `onDrag`, `onDragEnd`, `onDragEnter`,
    `onDragExit`'
- en: '`onDragLeave`, `onDragOver`, `onDragStart`, `onDrop`, `onMouseDown`, `onMouseEnter`,
    `onMouseLeave`'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDragLeave`, `onDragOver`, `onDragStart`, `onDrop`, `onMouseDown`, `onMouseEnter`,
    `onMouseLeave`'
- en: '`onMouseMove`, `onMouseOut,` `onMouseOver`, `onMouseUp`'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onMouseMove`, `onMouseOut,` `onMouseOver`, `onMouseUp`'
- en: Let's show an example of some of the different events called by the `SyntheticEvent`
    system on a React component.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`SyntheticEvent`系统在React组件上调用的一些不同事件的示例。
- en: 'In the JavaScript file, we have the following code snippet:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript文件中，我们有以下代码片段：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The following code displays a textbox in the browser. As we type in the box,
    the corresponding event type prints out below. Since we are updating the state
    with `event.type`, the corresponding event is shown below as we type in the box.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码在浏览器中显示一个文本框。当我们输入框中时，相应的事件类型会打印出来。由于我们使用 `event.type` 更新状态，因此当我们在框中输入时，相应的事件会显示在下面。
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![Mouse events](img/00018.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![鼠标事件](img/00018.jpeg)'
- en: User interactive form
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 用户交互表单
- en: nativeEvent
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: nativeEvent
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here''s the source code for the corresponding HTML page:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相应 HTML 页面的源代码：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: From the following screenshots, we can see that as we resize the browser window,
    the width and height values change. The first image shows the full size [1311/681]
    of the browser.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下屏幕截图可以看出，当我们调整浏览器窗口大小时，宽度和高度值会改变。第一张图片显示了浏览器的完整大小 [1311/681]。
- en: '![nativeEvent](img/00019.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![nativeEvent](img/00019.jpeg)'
- en: App showing browser's native attributes
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 显示浏览器原生属性的 App
- en: The second image from the preceding application code shows that after resizing
    the browser window, the pixel values changed to 497/219.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个应用程序代码的第二张图片显示，在调整浏览器窗口大小后，像素值变为 497/219。
- en: '![nativeEvent](img/00020.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![nativeEvent](img/00020.jpeg)'
- en: Native DOM attributes changing with browser window changes
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 原生 DOM 属性随浏览器窗口变化而变化
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'According to the Facebook developer team ([http://facebook.github.io/react/tips/dom-event-listeners.html](http://facebook.github.io/react/tips/dom-event-listeners.html)):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Facebook 开发者团队 ([http://facebook.github.io/react/tips/dom-event-listeners.html](http://facebook.github.io/react/tips/dom-event-listeners.html))：
- en: '*"The event callbacks which are declared in a React app, are all bound to the
    React components. These event callbacks are not tied to the original elements.
    By autobinding, these methods are automatically bounded to the current element."*'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"在 React 应用中声明的回调事件都绑定到 React 组件上。这些事件回调与原始元素无关。通过自动绑定，这些方法会自动绑定到当前元素。"*'
- en: 'Also, every `SyntheticEvent` object has the following attributes:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个 `SyntheticEvent` 对象都有以下属性：
- en: '`boolean bubbles`: All event handlers are triggered in the event bubbling phases;
    it can be `true`/`false`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean bubbles`: 所有事件处理程序都在事件冒泡阶段触发；可以是 `true`/`false`'
- en: '`boolean cancelable`: Whether the SyntheticEvent object can be cancelled or
    not (true/false)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean cancelable`: 合成事件对象是否可以被取消（true/false）'
- en: '`DOMEventTarget currentTarget`: As per W3C recommendations, the `currentTarget`
    event property returns the element whose event listeners triggered the event'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOMEventTarget currentTarget`: 根据 W3C 建议，`currentTarget` 事件属性返回触发事件的元素'
- en: This is particularly useful during capturing and bubbling.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这在捕获和冒泡期间特别有用。
- en: The `currentTarget` property always refers to the element whose event listener
    triggered the event, as opposed to the `target` property, which returns the element
    that triggered the event.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`currentTarget` 属性始终指向触发事件的元素，而不是 `target` 属性，后者返回触发事件的元素。'
- en: '`boolean defaultPrevented`: Whether the `SyntheticEvent` object can be prevented
    by default or not (true/false)'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean defaultPrevented`: 是否可以默认阻止 `SyntheticEvent` 对象（true/false）'
- en: '`number eventPhase`: The `eventPhase` event property returns a number that
    indicates which phase of the event flow is currently being evaluated (see: [https://developer.mozilla.org/en-US/docs/Web/API/Event/eventPhase](https://developer.mozilla.org/en-US/docs/Web/API/Event/eventPhase))'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number eventPhase`: `eventPhase` 事件属性返回一个数字，表示当前正在评估的事件流的哪个阶段（见：[https://developer.mozilla.org/en-US/docs/Web/API/Event/eventPhase](https://developer.mozilla.org/en-US/docs/Web/API/Event/eventPhase)）'
- en: 'The number is represented by four constants:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数字由四个常量表示：
- en: '`0` – `NONE`.'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`0` – `NONE`。'
- en: '`1` – `CAPTURING_PHASE`: The event flow is within the capturing phase.'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`1` – `CAPTURING_PHASE`: 事件流处于捕获阶段。'
- en: '`2` – `AT_TARGET`: The event flow is in the target phase, that is, it is being
    evaluated at the event target.'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`2` – `AT_TARGET`: 事件流处于目标阶段，即正在事件目标处评估。'
- en: '`3` – `BUBBLING_PHASE`: The event flow is in the bubbling phase.'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`3` – `BUBBLING_PHASE`: 事件流处于冒泡阶段。'
- en: '`boolean isTrusted`: As per JS recommendations, in Chrome, Firefox, and Opera,
    the event is trusted (returns true) if it is invoked by the user, and not trusted
    if it is invoked by a script ((returns false)).'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean isTrusted`: 根据 JS 建议，在 Chrome、Firefox 和 Opera 中，如果事件是由用户触发的，则认为是可信的（返回
    true），如果是由脚本触发的，则不可信（返回 false）。'
- en: '`DOMEvent nativeEvent`: `nativeEvent` is a kind of `DOMEvent`.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOMEvent nativeEvent`: `nativeEvent` 是一种 `DOMEvent`。'
- en: '`void preventDefault()`: The `preventDefault()` method does cancel the event
    if it is cancellable (it cancels the default action of the method) but it does
    not prevent further propagation of an event through the DOM. The return type of
    `preventDefault()` in React is void.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void preventDefault()`: 如果事件可取消，`preventDefault()`方法将取消事件（取消方法的默认操作），但它不会防止事件通过DOM进一步传播。React中`preventDefault()`的返回类型为void。'
- en: '`void stopPropagation()`: `stopPropagation` is called to prevent events from
    bubbling up to their parent elements, which thereby prevents any parent event
    handlers from being invoked.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void stopPropagation()`: 调用`stopPropagation`以防止事件冒泡到其父元素，从而防止任何父事件处理器被调用。'
- en: '`boolean isDefaultPrevented()`: `isDefaultPrevented` is used to check whether
    the `preventDefault()` method is called (true) or not (false).'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean isDefaultPrevented()`: `isDefaultPrevented`用于检查是否调用了`preventDefault()`方法（true）或未调用（false）。'
- en: '`boolean isPropagationStopped()`: `isPropagationStopped` is used to check whether
    the `stopPropagation()` method is called (true) or not (false).'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean isPropagationStopped()`: `isPropagationStopped`用于检查是否调用了`stopPropagation()`方法（true）或未调用（false）。'
- en: '`DOMEventTarget target`: It is used to identify the target of the `SyntheticEvent`
    object declared, which returns the element that triggered the event. The return
    type is in `DOMEventTarget`.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOMEventTarget target`: 它用于识别声明的`SyntheticEvent`对象的目标，返回触发事件的元素。返回类型为`DOMEventTarget`。'
- en: '`number timeStamp`: This is used to identify the timestamp of the `SyntheticEvent`
    object declared. The return type is in the form number.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number timeStamp`: 这用于识别声明的`SyntheticEvent`对象的时间戳。返回类型为数字。'
- en: '`string type`: This is used to identify a kind of `SyntheticEvent` object declared.
    The return type is in the form string.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string type`: 这用于识别声明的`SyntheticEvent`对象类型。返回类型为字符串。'
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: As of v0.14, returning false from an event handler will no longer stop
    event propagation. Instead, `e.stopPropagation()` or `e.preventDefault()` should
    be triggered manually, as appropriate.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：从v0.14版本开始，从事件处理器返回false将不再停止事件传播。相反，应根据需要手动触发`e.stopPropagation()`或`e.preventDefault()`。
- en: Event pooling
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件池
- en: A **pool** is a place where events/objects are kept, so that they can be reused
    at a later stage, after being garbage collected. In the React ecosystem, the event
    objects (`SyntheticEvent`) that are received in callbacks are pooled. As mentioned
    before, after the event callback has been called, `SyntheticEvent` will be put
    back in the pool with empty attributes, which thereby reduces the pressure on
    the Garbage Collector. Next are some key highlights for event pooling as mentioned
    in the Facebook documentation as well.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**池**是一个存储事件/对象的地方，以便在稍后阶段，在垃圾回收后可以重用。在React生态系统中，回调函数中接收的事件对象（`SyntheticEvent`）被池化。如前所述，在事件回调函数被调用后，`SyntheticEvent`将被放回池中，属性为空，从而减轻垃圾回收器的压力。以下是在Facebook文档中提到的关于事件池的一些关键要点。'
- en: The `SyntheticEvent` system in React is pooled.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: React中的`SyntheticEvent`系统是池化的。
- en: '*"This means that the `SyntheticEvent` object will be reused.*'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"这意味着`SyntheticEvent`对象将被重用。"*'
- en: ''
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*All properties will be nullified after the event callback has been invoked.*'
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在事件回调函数被调用后，所有属性都将被置为null。*'
- en: ''
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*This is for performance reasons.*'
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*这是出于性能考虑。*'
- en: ''
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*We cannot access the event in an asynchronous way.*'
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*我们无法以异步方式访问事件。*'
- en: ''
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In order to access the event properties in an asynchronous way, we should
    call `event.persist`() on the event, which will remove the synthetic event from
    the pool and allow references to the event to be retained by user code."*'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*为了以异步方式访问事件属性，我们应该在事件上调用`event.persist()`，这将移除合成事件从池中，并允许用户代码保留对事件的引用。*'
- en: Supported events
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持的事件
- en: React normalizes events so that they have consistent properties across different
    browsers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: React标准化事件，以确保在不同浏览器中具有一致的属性。
- en: According to the Facebook documentation ([http://facebook.github.io/react/docs/events.html](http://facebook.github.io/react/docs/events.html))
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Facebook文档([http://facebook.github.io/react/docs/events.html](http://facebook.github.io/react/docs/events.html))
- en: '*"The event handlers of the Synthetic Events of the React ecosystem are triggered
    by an event in the bubbling phase."*'
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"React生态系统中的合成事件的事件处理器在冒泡阶段的事件触发。"*'
- en: Now that we have covered what a state is in the React component and how event
    handling happens, let's see how we can use these in the app that we were building
    in the last chapter.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了React组件中的状态以及事件处理是如何发生的，让我们看看我们如何在上一章中构建的应用中使用这些功能。
- en: 'Until the last chapter, we were able to display the likes of a user, using
    the Graph-API and Facebook login into our app. Based on its props, each component
    has rendered itself once. Props are immutable: they are passed from the parent
    and are *owned* by the parent. Now, we will be able to update the name of the
    liked component `onClick` on any part of the particular `div` where the React
    component resides.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经能够使用Graph-API和Facebook登录到我们的应用程序中显示用户的点赞。基于其props，每个组件都渲染了自己一次。Props是不可变的：它们是从父组件传递的，并且由父组件拥有。现在，我们将在React组件所在的特定`div`的任何部分更新喜欢组件的`onClick`名称。
- en: 'The `index.html` code snippet for the following example is:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例的`index.html`代码片段是：
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following code is within the `js` file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码位于`js`文件中：
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The highlighted part shows the changes we made, in order to save the state.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的部分显示了我们所做的更改，以保存状态。
- en: '`getInitialState()`: is declared by initializing the value of the liked data
    name''s value from the props data. `getInitialState()` executes exactly once during
    the lifecycle of the component and sets up the initial state of the component.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getInitialState()`：通过从props数据初始化喜欢数据名称的值来声明。`getInitialState()`在组件的生命周期中恰好执行一次，并设置组件的初始状态。'
- en: 'The reason for the *mutable state* (the state that can be changed) is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*可变状态*（可以改变的状态）的原因如下：'
- en: The **mutable state** is introduced to the component (`UserLikedItem`). In order
    to implement interactions, `this.state` can be changed by calling `this.setState()`
    and is private to the component. When the state updates, the component (`UserLikedItem`)
    re-renders itself.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件（`UserLikedItem`）中引入了**可变状态**。为了实现交互，可以通过调用`this.setState()`来更改`this.state`，并且它是私有的。当状态更新时，组件（`UserLikedItem`）会重新渲染自己。
- en: '`render()` methods are written by the Facebook developer team, declaratively
    as functions of `this.props` and `this.state`. They ensure that the framework
    guarantees the UI is always consistent with the inputs.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render()`方法是由Facebook开发团队编写的，以声明性方式作为`this.props`和`this.state`的函数。它们确保框架保证UI始终与输入保持一致。'
- en: This is a perfect example of how data flows between components in the React
    ecosystem. The property (data) is passed from the React component `UserLikesList`
    to another component, `UserLikedItem`.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个完美的例子，说明了在React生态系统中组件之间数据是如何流动的。属性（数据）从React组件`UserLikesList`传递到另一个组件，`UserLikedItem`。
- en: '![Supported events](img/00021.jpeg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![支持的事件](img/00021.jpeg)'
- en: App fetching user's liked pages from Facebook
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序从Facebook获取用户的喜欢页面
- en: React attaches event handlers to components using a camelCase naming convention.
    We attach an `onClick` handler to the `div` element, so that whenever a user clicks
    at any portion of the image or the image name or category, it will change to **I
    liked it**.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: React使用驼峰命名约定将事件处理器附加到组件上。我们将`onClick`处理器附加到`div`元素上，这样当用户点击图像的任何部分、图像名称或类别时，它都会变为**我喜欢它**。
- en: '![Supported events](img/00022.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![支持的事件](img/00022.jpeg)'
- en: React this.setState() replacing liked item's name
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: React this.setState()替换喜欢项目的名称
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: According to Facebook's Reconciliation documentation ([https://facebook.github.io/react/docs/reconciliation.html](https://facebook.github.io/react/docs/reconciliation.html))
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Facebook的Reconciliation文档([https://facebook.github.io/react/docs/reconciliation.html](https://facebook.github.io/react/docs/reconciliation.html))
- en: '*"React''s key design decision is to make the API seem like it re-renders the
    whole app on every update."*'
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"React的关键设计决策是使API看起来在每次更新时都会重新渲染整个应用程序。"*'
- en: Thus, whenever the `setState`() method is called on an object, that particular
    node is marked. At the end of the event loop, all the nodes are re-rendered where
    the `setState`() method is called.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当在对象上调用`setState()`方法时，该特定节点就会被标记。在事件循环结束时，所有在调用`setState()`方法的节点都会重新渲染。
- en: React is fast because it never talks to the DOM directly. It maintains an in-memory
    representation of the actual DOM. Whenever the `render()` method is called, it
    returns a mapping of the actual DOM. React can detect (using a diff algorithm)
    changes in the mapped DOM compared to the in-memory representation. It then re-renders
    the changes and updates the UI likewise.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: React之所以快速，是因为它从不直接与DOM交谈。它维护实际DOM的内存表示。每当调用`render()`方法时，它返回实际DOM的映射。React可以检测（使用差异算法）映射的DOM与内存表示之间的变化。然后重新渲染更改并相应地更新UI。
- en: The event ecosystem in React is implemented by a full synthetic event system
    (`SyntheticEvent()`). Cross-browser efficiency is achieved as all the events bubble
    up consistently.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: React中的事件生态系统是通过一个完整的合成事件系统（`SyntheticEvent()`）实现的。由于所有事件都一致地冒泡，因此实现了跨浏览器的效率。
- en: In the current chapter, we have explored the stateful components in React and
    how the synthetic event system is handled in React applications. States are used
    for those properties in React components that are mutable. In the next chapter,
    we will explore the component lifecycle and how these lifecycle methods interact
    with various events and the DOM as a whole.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了React中的有状态组件以及合成事件系统在React应用程序中的处理方式。在React组件中，状态用于那些可变属性。在下一章中，我们将探讨组件的生命周期以及这些生命周期方法如何与各种事件以及整个DOM交互。
