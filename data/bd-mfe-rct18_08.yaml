- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Server-Rendered Microfrontends
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端渲染微前端
- en: Most JavaScript frameworks, including React, are primarily used to build **client-side-rendered**
    (**CSR**) applications. Client-rendered apps are great for certain use cases,
    such as admin dashboards or banking apps where users interact with the app in
    a logged-in area. CSR apps are not ideal for use cases where users access a site
    via a search engine or for anonymous short user journeys, such as news sites,
    blogs, or guest checkouts on e-commerce sites. This is because many search engine
    bots are not capable of indexing CSR-based web apps. CSR apps also have a poor
    **Largest Contentful Paint** (**LCP**) score – that is, their first-time page
    load performance scores are bad, leading to higher bounce rates.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数JavaScript框架，包括React，主要用于构建**客户端渲染**（**CSR**）应用。客户端渲染应用在某些用例中非常好，例如管理仪表板或银行应用，用户在登录区域与应用交互。CSR应用对于用户通过搜索引擎访问网站或进行匿名简短用户旅程（如新闻网站、博客或电子商务网站的客户结账）的用例并不理想。这是因为许多搜索引擎机器人无法索引基于CSR的Web应用。CSR应用也有较差的**最大内容渲染时间**（**LCP**）得分——即它们首次页面加载的性能得分很差，导致更高的跳出率。
- en: To overcome these drawbacks, it is now an accepted practice to have a web app’s
    pages rendered on a Node.js server and serve the rendered HTML pages to the browser.
    This is commonly known as **Server-Side Rendering** (**SSR**), or a Server-Side-Rendered
    (SSR) app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些缺点，现在有一个被广泛接受的做法，即在Node.js服务器上渲染Web应用的页面，并将渲染后的HTML页面提供给浏览器。这通常被称为**服务器端渲染**（**SSR**），或服务器端渲染应用（SSR）。
- en: In this chapter, we will look at how to build a module-federated microfrontend
    for a server-side-rendered app. While the process for implementing module federation
    is very similar to what we saw in the previous chapter, the fact that the pages
    are server-side-rendered brings a bit of complexity, and we will look at some
    of the nuances that we need to deal with when it comes to implementing a microfrontend
    with SSR.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何为服务器端渲染应用构建一个模块联邦微前端。虽然实现模块联邦的过程与上一章中看到的过程非常相似，但由于页面是服务器端渲染的，这带来了一些复杂性，我们将探讨在实现具有SSR的微前端时需要处理的一些细微差别。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: A quick look at how CSR and SSR apps differ
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速了解CSR和SSR应用的区别
- en: Learning about Next.js and Turbo repo
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Next.js和Turborepo
- en: Learning how to set up hosts and remote apps with Next.js and module federation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用Next.js和模块联邦设置主机和远程应用
- en: See how to expose multiple components as remotes that can be consumed into different
    apps
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看如何将多个组件暴露为远程组件，以便可以被不同的应用消费
- en: Looking into issues relating to hydration of state in SSRs and also how to go
    about reflecting the changes made in one micro app in the main app
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探讨与SSR（静态服务器渲染）中状态保持相关的问题，以及如何在主应用中反映一个微应用所做的更改
- en: By the end of this chapter, we will have a server-side-rendered microfrontend
    built using Next.js.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将使用Next.js构建一个服务器端渲染的微前端。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As we go through the code examples in this chapter, we will need the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们浏览本章中的代码示例时，我们需要以下条件：
- en: A PC, Mac, or Linux desktop/laptop with at least 8 GB of RAM (16 GB is preferred)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台至少有8 GB RAM（16 GB更佳）的PC、Mac或Linux桌面/笔记本电脑
- en: An Intel chipset i5+ or a Mac M1 + chipset
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英特尔i5+芯片组或Mac M1+芯片组
- en: At least 256 GB of free hard disk storage
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少256 GB的空闲硬盘存储空间
- en: A basic understanding of Next.js and Turborepo would be ideal
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对Next.js和Turborepo有基本了解是理想的
- en: A basic understanding of Node.js would be helpful
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对Node.js有基本了解将有所帮助
- en: You will also need the following software installed on your computer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在你的计算机上安装以下软件。
- en: Node.js version 18+ (use **nvm** to manage different versions of Node.js if
    you have to).
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js版本18+（如果你必须管理不同版本的Node.js，请使用**nvm**）。
- en: '**Terminal**: iTerm2 with OhMyZsh (you will thank me later).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终端**：iTerm2与OhMyZsh（你以后会感谢我的）。'
- en: '**IDE**: We strongly recommend VS Code, as we will make use of some of the
    plugins that come with it for an improved developer experience.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IDE**：我们强烈推荐VS Code，因为我们将会使用它的一些插件来提升开发者体验。'
- en: NPM, Yarn, or PNPM; we recommend PNPM because it’s fast and storage-efficient.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPM、Yarn或PNPM；我们推荐PNPM，因为它速度快且存储效率高。
- en: '**Browser**: Chrome, Microsoft Edge, or Firefox.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浏览器**：Chrome、Microsoft Edge或Firefox。'
- en: 'The code files for this chapter can be found here: https://github.com/PacktPublishing/Building-Micro-Frontends-with-React.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：https://github.com/PacktPublishing/Building-Micro-Frontends-with-React。
- en: We also assume you have a basic working knowledge of Git, such as branching
    and committing code and raising a pull request.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还假设您对Git有基本的了解，例如分支、提交代码和发起拉取请求。
- en: How do Client Rendered and Server Rendered Apps differ?
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端渲染和服务器渲染应用有何不同？
- en: When it comes to building web apps with JavaScript, there are two primary methods
    in terms of how a user interface gets built and served to the user. They are referred
    to as **Client-Side-Rendered** (**CSR**) and **Server-Side-Rendered** (**SSR**).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到使用JavaScript构建Web应用时，在用户界面构建和向用户提供服务方面有两种主要方法。它们被称为**客户端渲染**（**CSR**）和**服务器端渲染**（**SSR**）。
- en: From a development standpoint, coding a CSR or an SSR app predominantly remains
    the same, except for some additional steps for SSR. However, there are differences
    in the internal working of these apps in terms of how they are rendered, and also
    in how they can be deployed on the cloud.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发角度来看，编写CSR或SSR应用的主要过程基本相同，只是SSR需要一些额外的步骤。然而，这些应用在渲染方式和云部署方式上存在一些差异。
- en: In this section, we will look a bit deeper into these differences.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更深入地探讨这些差异。
- en: Client Side Rendered Apps (CSR)
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端渲染应用 (CSR)
- en: 'Let us have a look at how a Client Side app works. As its full name suggests,
    the CSR app is “rendered” on the client. In short, the app runs within the user’s
    browser, makes a call to fetch data, and the page is generated on the browser.
    The following diagram illustrates this better:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来了解一下客户端应用是如何工作的。正如其全名所暗示的，CSR应用是在客户端“渲染”的。简而言之，应用在用户的浏览器中运行，调用数据获取，并在浏览器中生成页面。以下图表更好地说明了这一点：
- en: '![Figure 6.1 – The request and response flow for a CSR app](img/Figure_6.01_B18987.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – CSR应用的请求和响应流程](img/Figure_6.01_B18987.jpg)'
- en: Figure 6.1 – The request and response flow for a CSR app
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – CSR应用的请求和响应流程
- en: The preceding *Figure 6**.1* illustrates the request flow in a CSR application.
    Here, the browser makes a first call to the server for a given URL, and the server
    (or sometimes the CDN itself) will respond back with a nearly empty HTML shell,
    containing the link to the app’s JavaScript bundle. The browser parses the bundle
    and then makes a second AJAX call to the server API, receiving the JSON response
    for the given URL. The browser then parses the response and, based on the views
    in the client-side app, renders the HTML page in the browser before serving it
    to the user. For every other call, the browser continues to make AJAX calls to
    the API endpoint and parses the page on the browser.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的*图6**.1*展示了CSR应用中的请求流程。在这里，浏览器对给定URL进行第一次调用，服务器（有时是CDN本身）将返回一个几乎为空的HTML外壳，其中包含应用JavaScript包的链接。浏览器解析包，然后对服务器API进行第二次AJAX调用，接收给定URL的JSON响应。浏览器然后解析响应，并根据客户端应用中的视图，在浏览器中渲染HTML页面，然后再将其提供给用户。对于其他每次调用，浏览器继续对API端点进行AJAX调用，并在浏览器中解析页面。
- en: With this flow, note that for the very first request from the user, there are
    two round trips to the server – first, to fetch the JavaScript bundle, and second,
    to get the page data and render the page.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个流程中，请注意，对于用户的第一次请求，有两个往返服务器的过程——首先，获取JavaScript包，其次，获取页面数据和渲染页面。
- en: Due to the nature of how CSR apps work, they are ideally suited for user experiences
    where users generally stay logged into an app and navigate through multiple pages
    per session.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CSR应用的工作性质，它们非常适合用户体验，用户通常在应用中保持登录状态，并在会话中浏览多个页面。
- en: 'Some of the drawbacks of Client side Rendered apps are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端渲染应用的缺点如下：
- en: For the very first request, users have to wait a bit longer due to the additional
    round trip to the server
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第一次请求，由于额外的往返服务器，用户需要等待更长的时间。
- en: Since the server response doesn’t contain any actual HTML data, search engine
    bots that are not optimized to parse JavaScript will have difficulty in indexing
    content from a client-rendered app
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于服务器响应不包含任何实际的HTML数据，未针对解析JavaScript进行优化的搜索引擎爬虫在索引客户端渲染应用的内容时将遇到困难。
- en: CSR apps are not suited for scenarios where the user journey is short, such
    as e-commerce websites where a user arrives via a search result link, buys a product
    or two, and leaves, or a blog site where users generally read only one to two
    articles at a time.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: CSR应用不适合用户旅程短的场景，例如用户通过搜索结果链接到达的电子商务网站，购买一两个产品后离开，或者博客网站，用户通常一次只阅读一到两篇文章。
- en: Now, let us see how an Server Side Rendered app works.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个服务器端渲染的应用程序是如何工作的。
- en: Server Side Rendered Apps (SSR)
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端渲染应用程序（SSR）
- en: 'In a Server Side Rendered app, as the full name suggests, for the very first
    request the page is generated on the server, and the rendered HTML page is sent
    to the browser. Let us look at it in a bit more in detail:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端渲染的应用程序中，正如其全名所暗示的，对于第一次请求，页面是在服务器上生成的，并且渲染的HTML页面被发送到浏览器。让我们更详细地看看：
- en: '![Figure 6.2 – The request and response flow for an SSR app](img/Figure_6.02_B18987.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 服务器端渲染应用程序的请求和响应流程](img/Figure_6.02_B18987.jpg)'
- en: Figure 6.2 – The request and response flow for an SSR app
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 服务器端渲染应用程序的请求和响应流程
- en: The working of an SSR app is illustrated in the preceding *Figure 6**.2*. What
    we see here is when the first request for a page is made from the browser to the
    Node.js server, it in turn makes a call to the API server to fetch the data. Then,
    the HTML page is generated on the server itself and sent back to the browser,
    along with the initial state and the JavaScript bundles. The state hydrates on
    the browser, then all subsequent calls are made from the browser to the API server,
    and the pages are rendered on the browser itself.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: SSR应用程序的工作原理在先前的*图6*.2中进行了说明。我们在这里看到的是，当浏览器从浏览器向Node.js服务器发出对页面的第一个请求时，它反过来调用API服务器以获取数据。然后，HTML页面在服务器本身上生成并发送到浏览器，包括初始状态和JavaScript包。状态在浏览器上恢复，然后所有后续调用都是从浏览器到API服务器的，页面在浏览器本身上渲染。
- en: Since the browser receives a fully rendered HTML page on the first request itself,
    the perceived performance for end users is good. It also helps with **Search Engine
    Optimization** (**SEO**), especially where search engine bots are not very good
    at parsing CSR pages.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浏览器在第一次请求时就接收到了完全渲染的HTML页面，因此最终用户感知的性能良好。它还有助于**搜索引擎优化**（**SEO**），尤其是在搜索引擎爬虫不太擅长解析CSR页面的情况下。
- en: Server-rendered apps are preferred for web apps where user journeys are short,
    such as B2C e-commerce apps, or content-heavy apps such as news sites or blogs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染的应用程序适用于用户旅程短的网络应用程序，例如B2C电子商务应用程序，或者内容丰富的应用程序，如新闻网站或博客。
- en: We now have a good understanding of how SSR and CSR apps work, what their pros
    and cons are, and what use cases are most suited for each of them. With this information,
    let us start building our SSR microfrontend in the next section.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对SSR和CSR应用程序的工作原理有了很好的理解，了解了它们的优缺点，以及哪些用例最适合它们。有了这些信息，让我们在下一节开始构建我们的SSR微前端。
- en: Building out our Server Rendered Microfrontend
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的服务器端渲染微前端
- en: In this section, we will look at how to build SSR apps using a meta framework
    such as Next.js, and then we will take it further to build a module-federated
    microfrontend using webpack’s module federation plugin. While doing so, we will
    explore another monorepo tool called Turborepo.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用像Next.js这样的元框架构建SSR应用程序，然后我们将进一步构建一个使用webpack的模块联邦插件的模块联邦微前端。在这个过程中，我们将探索另一个monorepo工具，即Turborepo。
- en: Important Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: At the time of writing this book the Module Federation Plugin doesn’t support
    Next.js 13 and the App Router and hence for this chapter we will use Next.js version
    12
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，模块联邦插件不支持Next.js 13和应用程序路由，因此在本章中，我们将使用Next.js版本12
- en: 'When it comes to building an SSR app in React, there are two common approaches:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到在React中构建SSR应用程序时，有两种常见的方法：
- en: '**A custom build using Node.js**: Here, we set up a Node.js server, render
    the React app on Node.js, stringify the response using the **renderToString**
    or **renderToPipeableStream** methods, and then use the **hydrateRoot** method,
    which are all part of the **react-dom/server** module to attach React to the rendered
    HTML'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用Node.js进行自定义构建**：在这里，我们设置一个Node.js服务器，在Node.js上渲染React应用程序，使用**renderToString**或**renderToPipeableStream**方法将响应字符串化，然后使用**hydrateRoot**方法，这些都是**react-dom/server**模块的一部分，将React附加到渲染的HTML上。'
- en: '**Use an SSR meta-framework**: Meta-frameworks such as Next.js, Remix, or Shopify’s
    Hydrogen can abstract away all the complexities of setting up an SSR app and provide
    a simple interface to build performant SSR React apps'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用服务器端渲染元框架**：例如Next.js、Remix或Shopify的Hydrogen这样的元框架可以抽象出设置服务器端渲染应用程序的所有复杂性，并提供一个简单的接口来构建高性能的SSR
    React应用程序'
- en: For this chapter, we will use Next.js to build our SSR app. Next.js is one of
    the oldest and most popular frameworks to build SSR React apps.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将使用Next.js来构建我们的SSR应用程序。Next.js是构建SSR React应用程序中最古老和最受欢迎的框架之一。
- en: For the mono repo, we will use another tool called Turborepo. While we can build
    Next.js apps with Nx monorepos as well, we will choose Turborepo so that we can
    also learn about the nuances of the different monorepo tools and how they operate.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单一代码仓库，我们将使用另一个名为 Turborepo 的工具。虽然我们也可以使用 Nx 单一代码仓库构建 Next.js 应用程序，但我们将选择
    Turborepo，这样我们也可以了解不同单一代码仓库工具的细微差别以及它们是如何运作的。
- en: Getting started with Turborepo and Next.js
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Turborepo 和 Next.js 入门
- en: Next.js is the most popular meta-framework that allows you to build SSR apps
    with React. Turborepo is another new monorepo framework that is gaining popularity,
    and it was recently acquired by Vercel, the company that builds and maintains
    Next.js.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 是最流行的元框架，允许你使用 React 构建 SSR 应用程序。Turborepo 是另一个正在获得流行的新单一代码仓库框架，它最近被
    Next.js 的构建和维护公司 Vercel 收购。
- en: While we will cover the essentials of Turborepo and Next.js in this chapter,
    I strongly encourage you to spend time going through their docs to get a deeper
    understanding of how these frameworks work.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们将在本章中介绍 Turborepo 和 Next.js 的基础知识，但我强烈建议你花时间阅读它们的文档，以更深入地了解这些框架是如何工作的。
- en: 'We will start from a clean slate here; let us begin by creating our monorepo
    with Turborepo:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一张白纸开始；让我们首先使用 Turborepo 创建我们的单一代码仓库：
- en: 'Run the following command in the terminal:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行以下命令：
- en: '[PRE0]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, you can run the following:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，你也可以运行以下命令：
- en: '[PRE1]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will download a bunch of libraries and then prompt you to decide where
    you’d like your monorepo to be created. Let’s call it **ebuy-ssr**.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将下载一些库，然后提示你选择你希望创建单一代码仓库的位置。让我们称它为 **ebuy-ssr**。
- en: On the next prompt to assign a package manager, you can choose the one you prefer.
    For the purpose of this chapter, we will choose **pnpm**.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个分配包管理器的提示中，你可以选择你喜欢的。为了本章的目的，我们将选择 **pnpm**。
- en: 'Let Turborepo go and do its stuff, and after the process is complete, you can
    **cd** into the **ebuy-ssr** folder and run the following command:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让 Turborepo 去执行其任务，并在过程完成后，你可以在 **ebuy-ssr** 文件夹中执行以下命令：
- en: '[PRE2]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that it launches two apps, **web** and **docs**, on ports **3000** and
    **3001**, respectively. In the browser, open up **http://localhost:3000** and
    **http://localhost:3001** and have a look at the really minimalistic default pages.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意它会在 **3000** 和 **3001** 端口分别启动两个应用程序，**web** 和 **docs**。在浏览器中打开 **http://localhost:3000**
    和 **http://localhost:3001**，查看真正简约的默认页面。
- en: Open up the **ebuy-ssr** folder within your IDE and take a look at the folder
    structure.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 IDE 中打开 **ebuy-ssr** 文件夹，查看文件夹结构。
- en: 'It will look something like this:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它看起来可能像这样：
- en: '[PRE3]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The key files and folders that we need to consider are as follows:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要考虑的关键文件和文件夹如下：
- en: '**apps**: This is the folder that will hold all our micro apps.'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**apps**：这个文件夹将存放我们所有的微应用。'
- en: '**packages**: This is the folder where we keep all our utilities, shared components,
    libraries, and so on. It is the equivalent of the **libs** folder in Nx.'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**packages**：这是我们存放所有实用工具、共享组件、库等的文件夹。它相当于 Nx 中的 **libs** 文件夹。'
- en: '**package.json**: The **package.json** files play a crucial role in how the
    turbo monorepo functions.'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**package.json**：**package.json** 文件在 turbo 单一代码仓库的功能中起着至关重要的作用。'
- en: '**turbo.json**: This is the file where we define the configurations for Turborepo.'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**turbo.json**：这是我们定义 Turborepo 配置的文件。'
- en: The differences between Turborepo and Nx
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Turborepo 和 Nx 之间的差异
- en: While both Turborepo and Nx do the same job of managing a monorepo for us, there
    are differences in their approach. Nx feels like a thin layer of abstraction that
    allows us to manage our monorepos, mainly via configurations. We tend to heavily
    rely on NX and its commands to build and manage our mono repos; Nx really doing
    all the heavy lifting for us. Turborepo, on the other hand, is quite lightweight
    and relies more on the npm package manager’s standards to manage the monorepo.
    Turborepo’s approach is to stay invisible in the background and let the developers
    have full control over how they manage their monorepos. This also means you need
    to do a bit more work when managing your monorepo with Turborepo.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Turborepo 和 Nx 都为我们管理单一代码仓库，但它们的方法有所不同。Nx 像是一层薄薄的抽象层，使我们能够通过配置来管理我们的单一代码仓库；我们倾向于高度依赖
    NX 及其命令来构建和管理我们的单一代码仓库；NX 真正为我们承担了所有的重活。另一方面，Turborepo 非常轻量级，更多地依赖于 npm 包管理器的标准来管理单一代码仓库。Turborepo
    的方法是在后台保持隐形，让开发者完全控制他们如何管理单一代码仓库。这也意味着当你使用 Turborepo 管理单一代码仓库时，你需要做更多的工作。
- en: Setting up our Micro Apps
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的微应用
- en: 'As we can see, we have two apps created by default within our apps folder,
    `web` and `docs`. We will start by renaming the web folder to `home` let us delete
    the docs folder for now:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在我们的**apps**文件夹中默认创建了两个应用，`web`和`docs`。我们将首先将`web`文件夹重命名为`home`，暂时删除`docs`文件夹：
- en: 'Rename the **web** folder **home**, delete the docs folder. Make sure that
    you update the name property in **apps/home/package.json** to **"name": "home"**,
    as this is what Turborepo uses to recognize the app.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将**web**文件夹重命名为**home**，删除**docs**文件夹。确保您在**apps/home/package.json**中更新名称属性为**"name":
    "home"**，因为这是Turborepo用来识别应用的方式。'
- en: 'While we have the file open, let us define the port in which it will run in
    dev mode. Update the dev script in **apps/home/package.json** to **"dev": "next
    dev --****port 3000"**.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '当我们打开文件时，让我们定义它在开发模式中运行的端口。更新**apps/home/package.json**中的开发脚本为**"dev": "next
    dev --****port 3000"**。'
- en: Note that with Turborepo, we have multiple `package.json` files. The `package.json`
    file in the root folder is used to manage the `dev` dependencies that are needed
    to manage the monorepo, and also the common `dev` dependencies needed for all
    the apps in the monorepo. We can also define our common script commands there.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用Turborepo，我们有多个`package.json`文件。根文件夹中的`package.json`文件用于管理管理monorepo所需的`dev`依赖项，以及monorepo中所有应用所需的通用`dev`依赖项。我们也可以在那里定义我们的通用脚本命令。
- en: The `package.json` file in each of the apps’ folders is used to manage the workspace
    and the dependencies for each of the apps. The primary advantage here is that
    each of your micro apps has its own `npm_modules` folder, thereby ensuring that
    each team is fully independent in managing their packages and dependencies.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用文件夹中的`package.json`文件用于管理每个应用的工作空间和依赖项。这里的主要优势是每个微应用都有自己的`npm_modules`文件夹，从而确保每个团队在管理他们的包和依赖项方面完全独立。
- en: Creating pages and components in Next.js
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Next.js中创建页面和组件
- en: Let us get started with creating a few components in our respective micro apps.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始在我们的各自的微应用中创建一些组件。
- en: Creating components with Next.js is very similar to how you’d do it with other
    React apps; we generally create a **components** folder and keep our components
    in it.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Next.js创建组件与在其他React应用中创建组件的方式非常相似；我们通常创建一个**components**文件夹，并将我们的组件保存在其中。
- en: When it comes to routing, Next.js 12 uses a filesystem-based router; what this
    means is to create a new route. We need to create a file with the route name in
    the `/``pages/about-us.tsx`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当涉及到路由时，Next.js 12使用基于文件系统的路由器；这意味着要创建一个新的路由。我们需要在`/``pages/about-us.tsx`中创建一个带有路由名称的文件。
- en: Let us create our components. Since we will use **semantic-ui** to build out
    our components, let us go ahead and add them as dependencies in our micro apps’
    package managers.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建我们的组件。由于我们将使用**semantic-ui**来构建我们的组件，让我们继续在我们的微应用包管理器中添加它们作为依赖项。
- en: Run **pnpm add semantic-ui-react semantic-ui-css** in **apps/home** of the micro
    apps folder.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在微应用的**apps/home**文件夹中运行**pnpm add semantic-ui-react semantic-ui-css**。
- en: Then, create a folder called **/components** within the home folder, and then
    create the **Header** component in there.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在主页文件夹中创建一个名为**/components**的文件夹，并在其中创建**Header**组件。
- en: 'In the **/apps/components/Header.tsx** file, add the following code:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**/apps/components/Header.tsx**文件中，添加以下代码：
- en: '[PRE4]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code is very similar to the code we used for the `Header` component
    in the previous chapter. It’s simply a markup to display the menu items and the
    mini basket in the `Header` component.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码与我们之前章节中使用的`Header`组件的代码非常相似。它只是用于显示菜单项和迷你篮子的标记。
- en: Next, let us include the header in our home app.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们将标题包含在我们的主页应用中。
- en: With Next.js, if we want code to be available within all the pages, we can create
    a file called `_app.tsx` within the `/pages` folder and put our relevant code
    in there, which is exactly what we will do to get our `Header` component to display
    across all the pages.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用Next.js，如果我们想让代码在所有页面中可用，我们可以在`/pages`文件夹中创建一个名为`_app.tsx`的文件，并将我们的相关代码放在那里，这正是我们将要做的，以便让`Header`组件在所有页面中显示。
- en: 'Create a new file called **_app.tsx** in the **apps/home/pages** folder with
    the following code:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**apps/home/pages**文件夹中创建一个名为**_app.tsx**的新文件，并包含以下代码：
- en: '[PRE5]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run **pnpm dev** and verify that the **Header** component shows up on **http://localhost:3000**.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行**pnpm dev**并验证**Header**组件是否显示在**http://localhost:3000**上。
- en: Now, we will create our catalog micro app. Simply create a copy of the home
    app and rename the folder **catalog**.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们的目录微应用。只需复制主页应用并重命名文件夹为**catalog**。
- en: Open up the catalog’s **package.json** file, located in **apps/catalog/package.json**
    file, and make a few minor changes.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于 **apps/catalog/package.json** 文件中的 catalog 的 **package.json** 文件，并进行一些小的修改。
- en: 'Change the app name to **"name": "catalog"**; let us also change the port to
    run on **3001**:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将应用名称更改为 **"name": "catalog"**；同时，让我们也将端口更改为运行在 **3001**：'
- en: '[PRE6]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, let us create our product card component in the **components** folder.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在 **components** 文件夹中创建我们的产品卡片组件。
- en: 'Create a new file in **apps/catalog/components/ProductCard.tsx** with the following
    code:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **apps/catalog/components/ProductCard.tsx** 文件中创建一个新文件，以下是其代码：
- en: '[PRE7]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Again, this is very similar to the `ProductCard` component we created in [*Chapter
    5*](B18987_05.xhtml#_idTextAnchor073). This is a basic markup to display the product
    image, product name, and price, along with the add to cart button.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次强调，这与我们在 [*第5章*](B18987_05.xhtml#_idTextAnchor073) 中创建的 `ProductCard` 组件非常相似。这是一个基本的标记，用于显示产品图片、产品名称和价格，以及添加到购物车按钮。
- en: Feel free to delete the **Header.tsx** file from **catalog/components** and
    remove its reference from the **_app.tsx** file, as we already have it in the
    home app and will not be using it here.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随意删除 **catalog/components** 中的 **Header.tsx** 文件，并从 **_app.tsx** 文件中移除其引用，因为我们已经在主页应用中有了它，并且在这里不会使用它。
- en: Next, to save us some time, let us copy and paste the **product-list-mocks.tsx**
    file from [*Chapter 4*](B18987_04.xhtml#_idTextAnchor061)into the **apps/catalog/mocks**
    folder. While we are here, let us also copy the **assets** folder containing the
    product images from [https://github.com/PacktPublishing/Building-Micro-Frontends-with-React-18/tree/main/ch4/ebuy/apps/catalog/src/assets](https://github.com/PacktPublishing/Building-Micro-Frontends-with-React-18/tree/main/ch4/ebuy/apps/catalog/src/assets)
    and paste it into **/apps/catalog/public/assets**.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为了节省我们一些时间，让我们将 **product-list-mocks.tsx** 文件从 [*第4章*](B18987_04.xhtml#_idTextAnchor061)
    复制粘贴到 **apps/catalog/mocks** 文件夹中。当我们在这里时，也让我们将包含产品图片的 **assets** 文件夹从 [https://github.com/PacktPublishing/Building-Micro-Frontends-with-React-18/tree/main/ch4/ebuy/apps/catalog/src/assets](https://github.com/PacktPublishing/Building-Micro-Frontends-with-React-18/tree/main/ch4/ebuy/apps/catalog/src/assets)
    复制并粘贴到 **/apps/catalog/public/assets**。
- en: 'Next, in the **apps/catalog/pages/index.tsx** file, let us add the following
    code:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 **apps/catalog/pages/index.tsx** 文件中，让我们添加以下代码：
- en: '[PRE8]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run **pnpm dev** from the root of the **ebuy-ssr** folder and verify that the
    **home** and **catalog** apps work as expected. These are the URLs for our apps:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **ebuy-ssr** 文件夹的根目录运行 **pnpm dev** 并验证 **home** 和 **catalog** 应用是否按预期工作。以下是我们的应用URL：
- en: 'The **home** app: **http://localhost:3000**'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主页** 应用：**http://localhost:3000**'
- en: 'The **catalog** app: **http://localhost:3001**'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目录** 应用：**http://localhost:3001**'
- en: '![Figure 6.3 – The home micro app running on port 3000](img/Figure_6.03_B18987.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 在端口3000上运行的首页微应用](img/Figure_6.03_B18987.jpg)'
- en: Figure 6.3 – The home micro app running on port 3000
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 在端口3000上运行的首页微应用
- en: '![Figure 6.4 – The catalog micro app running on port 3001](img/Figure_6.04_B18987.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – 在端口3001上运行的目录微应用](img/Figure_6.04_B18987.jpg)'
- en: Figure 6.4 – The catalog micro app running on port 3001
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 在端口3001上运行的目录微应用
- en: Now that we have our individual apps running, let us work toward loading the
    catalog micro app into the home app via module federation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让我们的独立应用运行，让我们努力通过模块联邦将目录微应用加载到主页应用中。
- en: Setting up Module Federation
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置模块联邦
- en: 'Now that we have our apps running independently, it’s time to embed the catalog
    app into the home app via module federation. For module federation with Next.js,
    we will use the dedicated `nextjs-mf npm` module. Follow these steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让我们的应用独立运行，是时候通过模块联邦将目录应用嵌入到主页应用中了。对于使用 Next.js 的模块联邦，我们将使用专门的 `nextjs-mf
    npm` 模块。按照以下步骤操作：
- en: 'Let us first install the **nextjs-mf** npm module along with webpack in the
    catalog app:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先在目录应用中安装 **nextjs-mf** npm 模块以及 webpack：
- en: '[PRE9]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We now need to expose the catalog app as a remote; we do this in the **app/catalog/next.config.js**
    file.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要将目录应用作为远程暴露出来；我们在 **app/catalog/next.config.js** 文件中这样做。
- en: 'We replace the contents of the **next.config.js** file with the following:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们用以下内容替换 **next.config.js** 文件的内容：
- en: '[PRE10]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Looking through the code, we first import `NextFederationPlugin`, and then we
    define the remote with its name and the path where its `remoteEntry.js` file can
    be located. Next.js creates two builds of its app – one for the server and the
    other for the client. Note that we conditionally load the `remoteEntry.js` file
    from either the `ssr` or `chunks` folder, depending on where it is executed.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查看代码，我们首先导入`NextFederationPlugin`，然后定义远程，包括其名称和`remoteEntry.js`文件所在路径。Next.js为其应用创建两个构建版本——一个用于服务器，另一个用于客户端。请注意，我们根据执行位置从`ssr`或`chunks`文件夹有条件地加载`remoteEntry.js`文件。
- en: 'Next, we define the webpack config where we set the properties of **NextFederationPlugin**,
    namely the name and what it exposes, like so:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义webpack配置，在其中设置**NextFederationPlugin**的属性，即名称和它暴露的内容，如下所示：
- en: '[PRE11]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can define an array of remotes and have different components or pages from
    within the catalog micro app load in other apps. This completes the setup on the
    catalog side.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义远程数组，并让目录微应用中的不同组件或页面在其他应用中加载。这完成了目录端的设置。
- en: Creating the checkout micro app
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建结账微应用
- en: 'For the sake of completeness, let us also create the `checkout` micro app by
    creating a copy of the catalog app and renaming the folder to `checkout`. Follow
    these steps:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，让我们通过复制目录应用并重命名文件夹为`checkout`来创建`checkout`微应用。按照以下步骤操作：
- en: 'Let us make the necessary changes to the **apps/checkout/package.json** file,
    as follows:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们对**apps/checkout/package.json**文件进行必要的更改，如下所示：
- en: '[PRE12]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, update the port number:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，更新端口号：
- en: '[PRE13]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, create a file called **Basket.tsx** in **apps/checkout/components/Basket.tsx**
    with the following code:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在**apps/checkout/components/Basket.tsx**中创建一个名为**Basket.tsx**的文件，并包含以下代码：
- en: '[PRE14]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let us also change the content of the **apps/checkout/pages/****index.tsx**
    file to ensure that the checkout app loads the **basket** component by passing
    the right set of information:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们还将**apps/checkout/pages/index.tsx**文件的内容进行更改，以确保结账应用通过传递正确的信息集加载**basket**组件：
- en: '[PRE15]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, let us update the module federation configuration in the **apps/checkout/next.config.js**
    to set up the checkout app as a remote.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们更新**apps/checkout/next.config.js**中的模块联邦配置，以将结账应用设置为远程。
- en: 'Let us update the remote array to reflect the name checkout and update the
    port to **3002**, as highlighted in the following code snippet:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更新远程数组以反映名称结账，并将端口更新为**3002**，如下代码片段所示：
- en: '[PRE16]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let’s quickly check the app to see whether the checkout app loads properly by
    running `pnpm dev` in the root folder and by visiting the following URL in the
    browser – `http://localhost:3002`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速检查应用，看看结账应用是否正确加载，通过在根目录运行`pnpm dev`并在浏览器中访问以下URL——`http://localhost:3002`。
- en: Setting up the host app
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置主机应用
- en: 'Now, let us focus on the home app:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于主应用：
- en: 'We will need to again install the **module-federation/nextjs-mf npm** package
    and webpack:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要再次安装**module-federation/nextjs-mf npm**包和webpack：
- en: '[PRE17]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once done, set up the host app as the host by updating the **apps/home/next.config.js**
    file, as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，通过更新**apps/home/next.config.js**文件，将主机应用设置为主机，如下所示：
- en: '[PRE18]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Since we want to load the catalog micro app within the catalog route, we will
    create a new file called **catalog.tsx** in **apps/home/pages/** with the following
    code:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们希望在目录路由中加载目录微应用，我们将在**apps/home/pages/**下创建一个名为**catalog.tsx**的新文件，并包含以下代码：
- en: '[PRE19]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let us create a similar file called **checkout** in **apps/home/pages/checkout.tsx**
    with the following similar code:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在**apps/home/pages/checkout.tsx**中创建一个类似的文件名为**checkout**，并包含以下类似代码：
- en: '[PRE20]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, we import Next.js’s dynamic module for the first time, which
    is the recommended way to import dynamically with Next.js.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，我们首次导入Next.js的动态模块，这是使用Next.js动态导入的推荐方式。
- en: You can choose to dynamically import the module to execute the client side by
    setting up `ssr:false`; this will execute the module on the client side and be
    bypassed by SSR. This is suitable when your module contains personalized content,
    for example, recommendations, order history, and so on.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以选择动态导入模块以执行客户端，通过设置`ssr:false`；这将使模块在客户端执行并绕过SSR。这适用于您的模块包含个性化内容时，例如推荐、订单历史等。
- en: Then, we define the `const` called `Catalog` and import it from the `catalog/Module`.
    Note that the TypeScript throws an error. That’s because we’ve not defined the
    types for it.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们定义名为`Catalog`的`const`并从`catalog/Module`导入它。请注意，TypeScript抛出一个错误。这是因为我们没有为其定义类型。
- en: 'So, let us quickly create the **/apps/home/remotes.d.ts** file with the following
    lines:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们快速创建以下内容的 **/apps/home/remotes.d.ts** 文件：
- en: '[PRE21]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let’s test out everything by shutting down all running servers.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过关闭所有运行的服务器来测试一切。
- en: '`killall node` is a really helpful command to kill all node processes.'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`killall node` 是一个非常有用的命令，可以杀死所有节点进程。'
- en: Run **pnpm dev** and visit **http://localhost:3000**. Click on the catalog and
    checkout apps to see the respective micro apps load.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 **pnpm dev** 并访问 **http://localhost:3000**。点击目录并检查应用以查看相应的微应用加载。
- en: Note
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may need to copy the **public/assets** folder from the catalog into the
    host app.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要将目录中的 **public/assets** 文件夹复制到宿主应用中。
- en: '![Figure 6.5 – The catalog micro app loaded in the catalog route](img/Figure_6.05_B18987.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5 – 在目录路由上加载的目录微应用](img/Figure_6.05_B18987.jpg)'
- en: Figure 6.5 – The catalog micro app loaded in the catalog route
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 在目录路由上加载的目录微应用
- en: 'The following screenshot shows the checkout micro app loaded on the checkout
    route:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在检查路由上加载的检查微应用：
- en: '![Figure 6.6 – The checkout micro app loaded on the checkout route](img/Figure_6.06_B18987.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6 – 在检查路由上加载的检查微应用](img/Figure_6.06_B18987.jpg)'
- en: Figure 6.6 – The checkout micro app loaded on the checkout route
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – 在检查路由上加载的检查微应用
- en: Congratulations!! We now have a full server side rendered microfrontend.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！！我们现在拥有了一个完整的服务器端渲染微前端。
- en: Let’s recap what we’ve learned so far. We started off by creating our individual
    micro apps using Turborepo and Next.js, and we learned about Turborepo’s folder
    structure and how it differs from Nx. We then created our micro apps using Next.js,
    and finally, we saw how to set up module federation to load the different micro
    apps in different routes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下到目前为止我们所学的。我们首先使用 Turborepo 和 Next.js 创建了各自的微应用，并了解了 Turborepo 的文件夹结构以及它与
    Nx 的区别。然后我们使用 Next.js 创建了微应用，最后我们看到了如何设置模块联邦以在不同的路由中加载不同的微应用。
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We’ve come to the end of this chapter, where we learned about the differences
    between Client side rendered and server side rendered apps, and which one is suitable
    for which type of application. We looked at the various options to build an SSR
    app and zeroed in on Next.js and Turborepo to build out our module-federated app.
    We then saw how to set up module federation using the `next.js-mf` plugin, and
    we went about setting up our remote and host apps. Finally, we saw how to import
    these modules dynamically into the host app and set up routing between the different
    apps.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了本章的结尾，我们学习了客户端渲染和服务器端渲染应用之间的区别，以及哪种类型的应用适合哪种。我们探讨了构建 SSR 应用程序的各种选项，并专注于使用
    Next.js 和 Turborepo 构建我们的模块联邦应用。然后我们看到了如何使用 `next.js-mf` 插件设置模块联邦，并着手设置我们的远程和宿主应用。最后，我们看到了如何将这些模块动态导入到宿主应用中，并设置不同应用之间的路由。
- en: As a stretch goal for this chapter, you can explore setting up a shared state
    management solution or a shared component library, following the same approach
    we took in [*Chapter 5*](B18987_05.xhtml#_idTextAnchor073).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的一个挑战目标，你可以探索设置共享状态管理解决方案或共享组件库，按照我们在 [*第五章*](B18987_05.xhtml#_idTextAnchor073)
    中采取的方法进行。
- en: In the next chapter, we will learn how to go about deploying our apps to the
    cloud. See you on the other side!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何将我们的应用部署到云端。另一边见！
