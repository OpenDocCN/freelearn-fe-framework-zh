<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Using React for the Client-Side</h1>
                </header>
            
            <article>
                
<p class="mce-root">So far, we have seen how to build web applications and microservices with Angular as the client-side framework. AngularJS was the most popular client-side framework until the new Angular 2 framework was released. Angular 2 caused a m<span>ajor disruption due to its backward incompatible architecture and gave way to more people migrating to React. Hence, the tides have shifted and now  React is the most popular and sought-after client-side framework, followed by Angular. JHipster added experimental support for React with version 4.11 and with JHipster Version 5.0; React support will become BETA and ready for mainstream use.</span></p>
<p class="mce-root"><span>In this chapter, we will cover the following topics:</span><br/></p>
<ul>
<li class="mce-root"><span>Generating an application with React client-side</span></li>
<li class="western">Technical stack and source code</li>
<li class="western"><span><span>Generating an entity with React client side</span></span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating an application with React client side</h1>
                </header>
            
            <article>
                
<p>Let's dive in straight away and create a React application with JHipster. You will need to open a Terminal to run the commands:</p>
<ol>
<li>Create a new folder and navigate to it by running <kbd>mkdir jhipster-react &amp;&amp; cd <span>jhipster-react</span></kbd>.</li>
<li>Now run the <kbd>jhipster</kbd> command in the Terminal. If you are running JHipster version 4.x instead of 5.x, then you will have to pass the experimental flag by running <kbd>jhipster <span>--experimental</span></kbd>.</li>
</ol>
<p> </p>
<ol start="3">
<li>JHipster will start with prompts; let's select default options for everything except for the question <span class="packt_screen">Which *Framework* would you like to use for the client?</span> For this question, choose <span class="packt_screen"><strong>[BETA] React</strong></span> and proceed.</li>
<li>Once all the prompts are completed, JHipster will generate the application and start installing dependencies before formatting the code using Prettier (<a href="https://prettier.io/">https://prettier.io/</a>) and starting the webpack build.</li>
</ol>
<div class="packt_tip">You can run <kbd>yarn prettier:format</kbd> to format the client-side code anytime. It will also be automatically run whenever you commit something with a git pre-commit hook.</div>
<p>Our selected options will look as follows:</p>
<pre>? Which *type* of application would you like to create? <strong>Monolithic application (recommended for simple projects)</strong><br/>? What is the base name of your application? <strong>jhreact</strong><br/>? What is your default Java package name? <strong>com.jhipsterbook.demo</strong><br/>? Do you want to use the JHipster Registry to configure, monitor and scale your application? <strong>No</strong><br/>? Which *type* of authentication would you like to use? <strong>JWT authentication (stateless, with a token)</strong><br/>? Which *type* of database would you like to use? <strong>SQL (H2, MySQL, MariaDB, PostgreSQL, Oracle, MSSQL)</strong><br/>? Which *production* database would you like to use? <strong>MySQL</strong><br/>? Which *development* database would you like to use? <strong>H2 with disk-based persistence</strong><br/>? Do you want to use the Spring cache abstraction? <strong>Yes, with the Ehcache implementation (local cache, for a single node)</strong><br/>? Do you want to use Hibernate 2nd level cache? <strong>Yes</strong><br/>? Would you like to use Maven or Gradle for building the backend? <strong>Maven</strong><br/>? Which other technologies would you like to use? <br/>? Which *Framework* would you like to use for the client? <strong>[BETA] React</strong><br/>? Would you like to enable *SASS* support using the LibSass stylesheet preprocessor? <strong>No</strong><br/>? Would you like to enable internationalization support? <strong>Yes</strong><br/>? Please choose the native language of the application <strong>English</strong><br/>? Please choose additional languages to install <strong>Chinese (Simplified)</strong><br/>? Besides JUnit and Karma, which testing frameworks would you like to use? <br/>? Would you like to install other generators from the JHipster Marketplace? <strong>No</strong></pre>
<p>That's it; we are done. Our first JHipster React application was created successfully. Now let's start the application to play around.</p>
<p>We will choose the default Maven build option which JHipster created a wrapper for already, so let's start our server by running <kbd>./mvnw</kbd> in a Terminal.</p>
<p>Maven will download the necessary dependencies and will start the Spring Boot application using the embedded Undertow container. You could choose Gradle instead of Maven if you prefer. Once the application successfully starts, we will see the following in the console:</p>
<pre><strong>2018-03-04 16:37:48.096 INFO 4730 --- [ restartedMain] com.jhipsterbook.demo.JhreactApp : </strong><br/><strong>----------------------------------------------------------</strong><br/><strong>  Application 'jhreact' is running! Access URLs:</strong><br/><strong>  Local: http://localhost:8080</strong><br/><strong>  External: http://192.168.2.7:8080</strong><br/><strong>  Profile(s): [swagger, dev]</strong><br/><strong>----------------------------------------------------------</strong></pre>
<p>Visit the URL(<kbd>http://localhost:8080</kbd>) in your favorite browser to see the application in action:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f4770fb9-2961-45b2-9fee-b47583320aed.png"/></div>
<p>You will see the home screen with the hipster dude looking back at you. Notice the React tattoo on his neck.</p>
<p>Go ahead and log in using the default admin user and play around.</p>
<p>The application looks exactly same as the Angular application we built earlier, except for the image, of course, and has all the same account and administration modules. This will make it more interesting for us to see the technical stack and source code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical stack and source code</h1>
                </header>
            
            <article>
                
<p>Before we dive into the generated code, let's talk about the technical stack. We already looked at React in <a href="7fc7275a-b035-4a45-9b55-3a3310572b3a.xhtml" target="_blank">Chapter 2</a>, <em>Getting Started with JHipster</em>, but let's recap. </p>
<p>React is a view rendering library created by Jordan Walke in 2011, and was open sourced in May 2013. It is maintained and backed by Facebook and has a huge community behind it. React follows the JS approach for HTML, where the markup code is written using JavaScript. To reduce verbosity, React uses a syntax sugar for Javascript called JSX (<a href="https://reactjs.org/docs/introducing-jsx.html">https://reactjs.org/docs/introducing-jsx.html</a>) to describe view elements. It looks similar to HTML, but it is not exactly HTML as some of the standard HTML attributes such as class, for example, is renamed to className, and attribute names are written using camelCase rather than dash-case.</p>
<p>For example, the following is a JSX snippet. You always need to have to use React in context for JSX to work:</p>
<pre>const element = &lt;div&gt;&lt;strong&gt;Hello there&lt;/<span>strong</span>&gt;&lt;/div&gt;</pre>
<p>When it comes to TypeScript, the JSX extension becomes TSX.</p>
<p>React uses a concept called Virtual DOM to improve the rendering efficiency. Virtual DOM is a lightweight copy of the actual DOM, and by comparing the virtual DOM after an update against the <span>virtual</span> DOM snapshot before the update, React can decide what exactly changed and render only that on to the actual DOM, hence making render cycles efficient and fast.</p>
<p>React components can have their own state and you can pass properties to a component, which are available to the component as props.</p>
<p>Unlike Angular, React is not a full-fledged MVVM framework. It is just a view rendering library and hence when building React applications, we would always have to add a few more libraries for things like state management, routing, and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical stacks</h1>
                </header>
            
            <article>
                
<p>The following are the technical stacks used by JHipster when React is chosen as the client side framework:</p>
<ul>
<li><strong>Rendering</strong>: React written using TypeScript</li>
<li><strong>State management</strong>: Redux + React Redux  + Redux Promise Middleware + Redux Thunk </li>
<li><strong>Routing</strong>: React router</li>
<li><strong>HTTP</strong>: <span>Axios</span></li>
<li><strong>Responsive design</strong>: Bootstrap 4 + Reactstrap</li>
<li><strong>Linting</strong>: Tslint</li>
<li><strong>Utilities</strong>: Lodash</li>
<li><strong>Unit testing</strong>: Karma + Mocha + Chai + Enzyme</li>
<li><strong>Build</strong>: Webpack</li>
</ul>
<p>Let's look at some of the most important components of the stack.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using TypeScript</h1>
                </header>
            
            <article>
                
<p>The client side is built using React, but instead of going with the traditional Javascript ES6, we are using TypeScript as the language of choice. This gives you the flexibility to use some of the concepts that you may be already familiar with if you come from a server-side background. It also provides static type checking, which makes development more efficient and less error-prone.</p>
<div class="packt_tip">Visit <a href="https://github.com/piotrwitek/react-redux-typescript-guide">https://github.com/piotrwitek/react-redux-typescript-guide</a> to learn about how to make the most out of Typescript + React.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">State management with Redux and friends</h1>
                </header>
            
            <article>
                
<p>React provides basic state management within React components, but sometimes it is not sufficient, especially when your application needs to share state between multiple components. State management solutions like Flux, Redux, and MobX and quite popular in the React world and JHipster uses Redux as the state management layer.</p>
<div class="packt_tip"><span class="packt_screen">When should you use the React component state?</span>
<ul>
<li><strong>If the variable can always be calculated using a prop</strong>: Don't use component state, calculate the variable during rendering</li>
<li><strong>If the variable is not used in rendering but to hold data</strong>: Don't use <span>component </span>state, use private class fields</li>
<li><strong>If the variable is obtained from an API and is required by more than one component</strong>: Don't use <span>component </span>state, use Redux global state and pass the variable as a prop</li>
</ul>
</div>
<p>Redux (<a href="https://redux.js.org/">https://redux.js.org/</a>) is a predictable state management solution for JavaScript, evolved from the Flux concept (<a href="https://facebook.github.io/flux/">https://facebook.github.io/flux/</a>). Redux provides a global immutable store which can only be updated by emitting or dispatching actions. An action is an object which describes what changed, and it uses a pure<span> reducer function to transform the state. A reducer is a pure function which takes in the current state and action and returns a new state.</span></p>
<p><span>React Redux is a binding for Redux that provides a higher order component called</span> <kbd>connect</kbd> <span>for React, which is used to connect React components to the Redux store. Let's take a look at </span><kbd>src/main/webapp/app/modules/home/home.tsx</kbd>, for example:</p>
<pre>export class Home extends React.Component&lt;IHomeProp, IHomeState&gt; {<br/>  ...<br/>}<br/><br/>const <strong>mapStateToProps</strong> = storeState =&gt; ({<br/>  account: storeState.authentication.account,<br/>  isAuthenticated: storeState.authentication.isAuthenticated<br/>});<br/>const <strong>mapDispatchToProps</strong> = { getSession };<br/><br/>export default <strong>connect</strong>(mapStateToProps, mapDispatchToProps)(Home);</pre>
<p>The <kbd>mapStateToProps</kbd> function is used to map properties from the global Redux store to the components props. The <kbd>mapDispatchToProps</kbd> function is used to wrap the given functions with the Redux dispatch call.</p>
<p>Redux Promise Middleware (<a href="https://github.com/pburtchaell/redux-promise-middleware">https://github.com/pburtchaell/redux-promise-middleware</a>) is used to handle asynchronous action payloads. It accepts a Promise and dispatches pending, fulfilled, and rejected actions based on the Promise state. It is useful when Redux actions are making HTTP requests or performing async operations.</p>
<p>Redux Thunk (<a href="https://github.com/gaearon/redux-thunk">https://github.com/gaearon/redux-thunk</a>) is another middleware used to chain actions. It is useful when an action has to call another action based on certain conditions or in general to handle side effects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Routing with React Router</h1>
                </header>
            
            <article>
                
<p>React Router (<a href="https://reacttraining.com/react-router/web/guides/philosophy">https://reacttraining.com/react-router/web/guides/philosophy</a>) is used for client-side routing. The default setup with JHipster is to use Hash History-based routing. It provides a simple component-based routing along with a flexible API for advanced routing setups. Routes can be defined anywhere in the application alongside the normal React rendering code. JHipster provides some custom wrappers such as <kbd>PrivateRoute</kbd> to enable authorization-based routing.</p>
<p>Let's take a look at <kbd>src/main/webapp/app/routes.tsx</kbd>, for example:</p>
<pre>const Routes = () =&gt; (<br/>  &lt;div className="view-routes"&gt;<br/>    &lt;<strong>Route</strong> exact path="/" component={Home} /&gt;<br/>    &lt;Route path="/login" component={Login} /&gt;<br/>    &lt;Route path="/logout" component={Logout} /&gt;<br/>    &lt;Route path="/register" component={Register} /&gt;<br/>    &lt;Route path="/activate/:key?" component={Activate} /&gt;<br/>    &lt;Route path="/reset/request" component={PasswordResetInit} /&gt;<br/>    &lt;Route path="/reset/finish/:key?" component={PasswordResetFinish} /&gt;<br/>    &lt;<strong>PrivateRoute</strong> path="/admin" component={Admin} /&gt;<br/>    &lt;PrivateRoute path="/account" component={Account} /&gt;<br/>    &lt;Route path="**" component={Entities} /&gt;<br/>  &lt;/div&gt;<br/>);<br/><br/>export default Routes;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HTTP requests using Axios</h1>
                </header>
            
            <article>
                
<p>Axios (<a href="https://github.com/axios/axios">https://github.com/axios/axios</a>) is a Promise-based HTTP client. It is a powerful and flexible library with a very straightforward API. It is used to fetch data from the JHipster application's server-side REST endpoints from Redux actions. The resulting Promise is resolved by the Redux Promise Middleware to provide data to the reducer.</p>
<p>The following shows a Redux action with an asynchronous payload:</p>
<pre>export const getRoles = () =&gt; ({<br/>  type: ACTION_TYPES.FETCH_ROLES,<br/>  payload: axios.get(`${apiUrl}/authorities`)<br/>});</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bootstrap components using Reactstrap</h1>
                </header>
            
            <article>
                
<p>JHipster uses Bootstrap 4 as its UI framework and since we are building a React application, it makes sense to use a Native React binding instead of Bootstrap's JQuery-based components. Reactstrap (<a href="https://reactstrap.github.io/">https://reactstrap.github.io/</a>) provides pure React components for Bootstrap 4. We also make use of the Availity reactstrap Validation (<a href="https://availity.github.io/availity-reactstrap-validation/">https://availity.github.io/availity-reactstrap-validation/</a>) library, which provides form validation support for Reactstrap form elements.</p>
<p>Let's take a look at <kbd>src/main/webapp/app/modules/login/login-modal.tsx</kbd>, for example:</p>
<pre>&lt;Modal isOpen={this.props.showModal} toggle={handleClose} backdrop="static" id="login-page"&gt;<br/>  &lt;AvForm onSubmit={this.handleSubmit}&gt;<br/>    &lt;ModalHeader toggle={handleClose} id="login-title"&gt;<br/>      ...<br/>    &lt;/ModalHeader&gt;<br/>    &lt;ModalBody&gt;<br/>      &lt;div className="row"&gt;<br/>        ...<br/>        &lt;div className="col-md-12"&gt;<br/>          &lt;AvField<br/>            name="username"<br/>            label={...}<br/>            placeholder={...}<br/>            required<br/>            errorMessage="Username cannot be empty!"<br/>          /&gt;<br/>          ...<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>      &lt;Alert color="warning"&gt;<br/>        ...<br/>      &lt;/Alert&gt;<br/>      ...<br/>    &lt;/ModalBody&gt;<br/>    &lt;ModalFooter&gt;<br/>      ...<br/>    &lt;/ModalFooter&gt;<br/>  &lt;/AvForm&gt;<br/>&lt;/Modal&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unit testing setup</h1>
                </header>
            
            <article>
                
<p>JHipster uses a combination of Karma, Mocha, Chai, and Enzyme to unit test the client-side components.</p>
<p>Karma (<a href="https://karma-runner.github.io/2.0/index.html">https://karma-runner.github.io/2.0/index.html</a>) is used as the test runner and Mocha (<a href="https://mochajs.org/">https://mochajs.org/</a>) is used as the testing framework. Chai (<a href="http://chaijs.com/">http://chaijs.com/</a>) is an assertion library with great plugin support. We use its BDD (Behavior-driven development) style assertions. Enzyme (<a href="http://airbnb.io/enzyme/">http://airbnb.io/enzyme/</a>) is a testing utility for React which makes it easy to unit test React components. In combination, these libraries provide a rich and intuitive testing environment for React.</p>
<p><span>Let'</span>s<span> run the generated unit tests. Run <kbd>yarn test</kbd> in a Terminal.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating source code</h1>
                </header>
            
            <article>
                
<p>Let's take a look at the generated code. Since we already saw the server-side code in previous chapters, we will only look at the client-side code here:</p>
<div class="CDPAlignCenter CDPAlign"><img height="668" src="assets/8bd704bd-2a60-4067-adf4-cede92f2035d.png" width="295"/></div>
<p>The structure is quite similar to what we saw for Angular, but the React code is organized slightly differently. We are concerned only about the code inside <kbd>src/main/webapp/app</kbd> as everything else is exactly the same as what we saw for the Angular application.</p>
<p>Let's take a look at some of the important parts of the code:</p>
<ul>
<li><kbd>index.tsx</kbd>: This is the entry point of our application. This is where we bootstrap React to the <kbd>root div</kbd> and initialize the Redux store:</li>
</ul>
<pre style="padding-left: 60px">...<br/>const devTools = process.env.NODE_ENV === 'development' ? &lt;DevTools /&gt; : null;<br/>const store = initStore();<br/>registerLocales(store);<br/><br/>const actions = bindActionCreators({ clearAuthentication }, store.dispatch);<br/>setupAxiosInterceptors(<br/>  () =&gt; actions.clearAuthentication('login.error.unauthorized')<br/>);<br/><br/>const rootEl = document.getElementById('root');<br/>const render = Component =&gt;<br/>  ReactDOM.render(<br/>    &lt;AppContainer&gt;<br/>      &lt;Provider store={store}&gt;<br/>        &lt;div&gt;<br/>          ...<br/>          {devTools}<br/>          &lt;Component /&gt;<br/>        &lt;/div&gt;<br/>      &lt;/Provider&gt;<br/>    &lt;/AppContainer&gt;,<br/>    rootEl<br/>  );<br/><br/>render(AppComponent);<br/>...</pre>
<ul>
<li><kbd>app.tsx</kbd>: This is our main application component. We declare the React router and the main application UI structure here:</li>
</ul>
<pre style="padding-left: 60px">...<br/>export class App extends React.Component&lt;IAppProps&gt; {<br/>  componentDidMount() {<br/>    this.props.getSession();<br/>  }<br/><br/>  handleLogout = () =&gt; {<br/>    this.props.logout();<br/>  };<br/><br/>  render() {<br/>    const paddingTop = '60px';<br/>    return (<br/>      &lt;Router&gt;<br/>        &lt;div className="app-container" style={{ paddingTop }}&gt;<br/>          &lt;Header<br/>            ...<br/>          /&gt;<br/>          &lt;div className="container-fluid view-container" id="app-view-container"&gt;<br/>            &lt;Card className="jh-card"&gt;<br/>              &lt;AppRoutes /&gt;<br/>            &lt;/Card&gt;<br/>            &lt;Footer /&gt;<br/>          &lt;/div&gt;<br/>          &lt;ModalContainer /&gt;<br/>        &lt;/div&gt;<br/>      &lt;/Router&gt;<br/>    );<br/>  }<br/>}<br/>...</pre>
<ul>
<li><kbd>routes.tsx</kbd>: The application's main parent routes are defined here and they are imported in the <kbd>app.tsx</kbd> from here.</li>
<li><kbd>config</kbd>: This is where framework level configurations are done:
<ul>
<li><kbd>axios-interceptor.ts</kbd>: HTTP interceptors are configured here. This is where the JWT tokens are set to requests and errors are handled.</li>
<li><kbd>constants.ts</kbd>: Application constants.</li>
<li><kbd>*-middleware.ts</kbd>: Error, Notification, and Logging middleware for Redux are configured here.</li>
<li><kbd>store.ts</kbd>: Redux store configuration is done here. Middlewares are registered during this stage.</li>
</ul>
</li>
</ul>
<p>The order of the middlewares in the array is important as they act like a pipeline, passing actions from one middleware to another as shown here:</p>
<pre>const defaultMiddlewares = [<br/>  thunkMiddleware,<br/>  errorMiddleware,<br/>  notificationMiddleware,<br/>  promiseMiddleware(),<br/>  loadingBarMiddleware(),<br/>  loggerMiddleware<br/>];</pre>
<ul>
<li style="list-style-type: none">
<ul>
<li><kbd>translation.ts</kbd>: i18n-related configurations are done here.</li>
</ul>
</li>
<li><kbd>entities</kbd>: The entity modules are present here.</li>
<li><kbd>modules</kbd>: Application UI modules are here:
<ul>
<li><kbd>account</kbd>: Account pages like settings, password reset, and so on are here</li>
<li><kbd>administration</kbd>: The admin screens like metric, health, user-management, and so on are here</li>
<li><kbd>home</kbd>: Home screen of the application</li>
<li><kbd>login</kbd>: Login and logout components</li>
</ul>
</li>
<li><kbd>shared</kbd>: Shared components and reducers:
<ul>
<li><kbd>layout</kbd>: Layout related components like header, footer, and so on</li>
<li><kbd>model</kbd>: Typescript model for entities</li>
<li><kbd>reducers</kbd>: shared reducers used by the application:
<ul>
<li><kbd>authentication.ts</kbd>: This is for authentication-related actions and reducers. Let's use the <kbd>LOGIN</kbd> action. The action accepts username, password, and rememberMe and dispatches the <kbd>ACTION_TYPES.LOGIN</kbd> with an asynchronous payload from an HTTP call to authenticate our credentials. We use the <strong>async/await</strong> feature from ES7 to avoid complex callbacks here. The result from the dispatch is obtained from when we extract the JWT <kbd>bearerToken</kbd> and store it in the local or session storage of the browser based on the remember me setting passed. The dispatch of <kbd>ACTION_TYPES.LOGIN</kbd> will trigger the appropriate case in the reducer based on the status of the promise:</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre style="padding-left: 150px">...<br/><br/>export const ACTION_TYPES = {<br/>  LOGIN: 'authentication/LOGIN',<br/>  ...<br/>};<br/><br/>const initialState = {<br/>  ...<br/>};<br/><br/>// Reducer<br/>export default (state = initialState, action) =&gt; {<br/>  switch (action.type) {<br/>    case REQUEST(ACTION_TYPES.LOGIN):<br/>    case REQUEST(ACTION_TYPES.GET_SESSION):<br/>      return {<br/>        ...state,<br/>        loading: true<br/>      };<br/>    case FAILURE(ACTION_TYPES.LOGIN):<br/>      return {<br/>        ...initialState,<br/>        errorMessage: action.payload,<br/>        showModalLogin: true,<br/>        loginError: true<br/>      };<br/>    ...<br/>    case SUCCESS(ACTION_TYPES.LOGIN):<br/>      return {<br/>        ...state,<br/>        loading: false,<br/>        loginError: false,<br/>        showModalLogin: false,<br/>        loginSuccess: true<br/>      };<br/>    ...<br/>    default:<br/>      return state;<br/>  }<br/>};<br/>...<br/>export const <strong>login</strong> = <br/>  (username, password, rememberMe = false) =&gt; async (dispatch, getState) =&gt; {<br/>  const result = await dispatch({<br/>    type: <strong>ACTION_TYPES.LOGIN</strong>,<br/>    payload: axios.post('<strong>/api/authenticate</strong>', { username, password, rememberMe })<br/>  });<br/>  const <strong>bearerToken</strong> = result.value.headers.authorization;<br/>  if (bearerToken &amp;&amp; bearerToken.slice(0, 7) === 'Bearer ') {<br/>    const <strong>jwt</strong> = bearerToken.slice(7, bearerToken.length);<br/>    if (rememberMe) {<br/>      <strong>Storage.local.set('jhi-authenticationToken', jwt);</strong><br/>    } else {<br/>      <strong>Storage.session.set('jhi-authenticationToken', jwt);</strong><br/>    }<br/>  }<br/>  <strong>dispatch(getSession());</strong><br/>};<br/>...</pre>
<ul>
<li style="list-style-type: none">
<ul>
<li><kbd>util</kbd>: Utility functions.</li>
</ul>
</li>
</ul>
<p>The folder structure of the unit test code is also quite similar:</p>
<div class="CDPAlignCenter CDPAlign"><img height="272" src="assets/f7382a4c-1090-4947-b0ce-f4e4e3f10586.png" width="274"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating an entity with React client side</h1>
                </header>
            
            <article>
                
<p>Let's see how we can create an entity using the JHipster entity generator with a React client side. We will create a simple Employee entity with the name, age, and date of birth fields:</p>
<ol>
<li>Open a Terminal and navigate to the folder of the React app and run <kbd>jhipster entity employee</kbd>.</li>
<li>Create the fields<span> one by one, select yes for the question <span class="packt_screen">Do you want to add a field to your entity?,</span> and start filling in the field name for the next question, <span class="packt_screen">What is the name of your field?</span></span></li>
<li>Select <span class="packt_screen">String</span> as the field type for the next question, <span class="packt_screen">What is the type of your field?</span></li>
<li><span>For the question <span class="packt_screen">Which validation rules do you want to add?,</span> choose <span class="packt_screen">Required</span> for name field and proceed.</span></li>
<li>Continue the process for the following fields. <kbd>age</kbd> and <kbd>dob. age</kbd> are of type Integer and <kbd>dob</kbd> is of type Instant.</li>
<li>When asked again, <span><span class="packt_screen">Do you want to add a field to your entity?</span>, choose no.</span></li>
<li>For the next question, <span class="packt_screen">Do you want to add a relationship to another entity?</span>, choose yes.</li>
</ol>
<p> </p>
<ol start="8">
<li>Provide <kbd>user</kbd> as the name of the other entity and as the name of the relationship for the following questions.</li>
<li><span>For the next question, <span class="packt_screen">What is the type of the relationship?,</span> let's create a </span>one-to-one relationship <span>with the user.</span></li>
<li>Choose no for the next question and no again when asked to add another relationship.</li>
<li>For the following questions, select the default options and proceed.</li>
</ol>
<p style="padding-left: 60px">The command will produce the following console output:</p>
<pre style="padding-left: 60px">Using JHipster version installed globally<br/>Executing jhipster:entity employee<br/>Options:<br/><br/>The entity employee is being created.<br/><br/>...<br/><br/>================= Employee =================<br/>Fields<br/>name (String) required<br/>age (Integer)<br/>dob (Instant)<br/><br/>Relationships<br/>user (User) one-to-one<br/><br/>? Do you want to use separate service class for your business logic? <strong>No, the REST controller should use the repository directly</strong><br/>? Do you want pagination on your entity? <strong>No</strong></pre>
<p style="padding-left: 60px">JHipster will generate the entity and run Prettier and the webpack build.</p>
<ol start="12">
<li>If your server is not running, start it in a Terminal by running <kbd>./mvnw</kbd>. If it is already running, then just compile the new code by running <kbd>./mvnw compile</kbd>, and Spring DevTools will restart the app automatically.</li>
</ol>
<p> </p>
<ol start="13">
<li>Start BrowserSync in another Terminal by running <kbd>yarn start</kbd> and check the employee entity we just created:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="350" src="assets/8be985b1-c5a9-463b-ae41-62f7391c6c32.png" width="546"/></div>
<ol start="14">
<li>Create an entity to check everything works fine:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bbd46aae-8a9e-4b10-8791-b51d77707319.png"/></div>
<p>For the entity we created, JHipster generated/updated the following files:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a74d2eb8-9f8b-4cf9-8590-59ec5498f7ee.png"/></div>
<p>On the React client side, we have the following files:</p>
<pre>   src/main/webapp/app/entities/employee/employee-delete-dialog.tsx<br/>   src/main/webapp/app/entities/employee/employee-detail.tsx<br/>   src/main/webapp/app/entities/employee/employee-dialog.tsx<br/>   src/main/webapp/app/entities/employee/employee.tsx<br/>   src/main/webapp/app/entities/employee/employee.reducer.ts<br/>   src/main/webapp/app/shared/model/employee.model.ts<br/>   src/main/webapp/app/entities/employee/index.tsx</pre>
<p>The <kbd>index.ts</kbd> file declares the routes for the entity:</p>
<pre>    &lt;Switch&gt;<br/>      &lt;Route exact path={match.url} component={Employee} /&gt;<br/>      &lt;ModalRoute exact parentPath={match.url} path={`${match.url}/new`} <br/>        component={EmployeeDialog} /&gt;<br/>      &lt;ModalRoute exact parentPath={match.url} path={`${match.url}/:id/delete`} <br/>        component={EmployeeDeleteDialog} /&gt;<br/>      &lt;ModalRoute exact parentPath={match.url} path={`${match.url}/:id/edit`} <br/>        component={EmployeeDialog} /&gt;<br/>      &lt;Route exact path={`${match.url}/:id`} component={EmployeeDetail} /&gt;<br/>    &lt;/Switch&gt;</pre>
<p><kbd>employee.reducer.ts</kbd> declares the actions and reducer for the entity, for example, let's use the action and reducer to create an entity. The <kbd>createEntity</kbd> action dispatches the <kbd>ACTION_TYPES.CREATE_EMPLOYEE</kbd> with the HTTP payload and metadata for notifications. Once the HTTP request resolves, we dispatch the <kbd>getEntities</kbd> action to fetch the updated entity list.</p>
<p>The reducer is common for create and update actions. Let's take a look at the create action and reducer:</p>
<pre>...<br/>export const ACTION_TYPES = {<br/>  ...<br/>  <strong>CREATE_EMPLOYEE: 'employee/CREATE_EMPLOYEE</strong>',<br/>  ...<br/>};<br/><br/>const initialState = {<br/>  ...<br/>};<br/><br/>// Reducer<br/>export default (state = initialState, action) =&gt; {<br/>  switch (action.type) {<br/>    ...<br/>    case REQUEST(<strong>ACTION_TYPES.CREATE_EMPLOYEE</strong>):<br/>    ...<br/>      return {<br/>        ...<br/>      };<br/>    ...<br/>    case FAILURE(<strong>ACTION_TYPES.CREATE_EMPLOYEE</strong>):<br/>    ...<br/>      return {<br/>        ...<br/>      };<br/>    ...<br/>    case SUCCESS(<strong>ACTION_TYPES.CREATE_EMPLOYEE</strong>):<br/>    case SUCCESS(ACTION_TYPES.UPDATE_EMPLOYEE):<br/>      return {<br/>        ...<br/>      };<br/>    ...<br/>    default:<br/>      return state;<br/>  }<br/>};<br/><br/>const apiUrl = SERVER_API_URL + '/api/employees';<br/>...<br/><br/>export const <strong>createEntity</strong>: ICrudPutAction = entity =&gt; <strong>async</strong> dispatch =&gt; {<br/>  const result = <strong>await</strong> dispatch({<br/>    type: <strong>ACTION_TYPES.CREATE_EMPLOYEE</strong>,<br/>    meta: {<br/>      successMessage: messages.DATA_CREATE_SUCCESS_ALERT,<br/>      errorMessage: messages.DATA_UPDATE_ERROR_ALERT<br/>    },<br/>    payload: <strong>axios.post(apiUrl, entity)</strong><br/>  });<br/>  dispatch(<strong>getEntities()</strong>);<br/>  return result;<br/>};<br/>...</pre>
<p><kbd>employee.tsx</kbd>, <kbd>employee-dialog.tsx</kbd>, <kbd>employee-detail.tsx</kbd>, and  <kbd>employee-delete-dialog.tsx</kbd> declare the entity listing, entity model dialog, entity detail, and entity delete dialog respectively. Let's look at <kbd>employee.tsx</kbd>, for example. We define the type for the props using a TypeScript interface, <kbd>IEmployeeProps</kbd>, which is passed as the generic for the <kbd>React.Component</kbd> type. We trigger the actions to fetch entities and users when our component mounts using the <kbd>componentDidMount</kbd> lifecycle method. The render method returns the JSX for the UI.</p>
<p>The component is connected to the Redux store using the higher-order component. Let's take a look:</p>
<pre>...<br/>export interface <strong>IEmployeeProps</strong> {<br/>  getEntities: ICrudGetAllAction;<br/>  employees: any[];<br/>  getusers: ICrudGetAllAction;<br/>  match: any;<br/>}<br/><br/>export class <strong>Employee</strong> extends <strong>React.Component&lt;IEmployeeProps&gt;</strong> {<br/>  <strong>componentDidMount</strong>() {<br/>    this.props.getEntities();<br/>    this.props.getusers();<br/>  }<br/><br/>  <strong>render</strong>() {<br/>    ...<br/>  }<br/>}<br/><br/>const mapStateToProps = storeState =&gt; ({<br/>  employees: storeState.employee.entities<br/>});<br/><br/>const mapDispatchToProps = { getusers, getEntities };<br/><br/>export default <strong>connect</strong>(mapStateToProps, mapDispatchToProps)(Employee);</pre>
<p>The other components also follow a similar approach. Codewise React code has much less boilerplate and is more concise compared to Angular.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned general concepts about React, Redux, and other libraries on the React ecosystem. We also learned how to create a React app using JHipster and generated entities for it. We saw how we can make use of TypeScript with React and also walked through the generated code. We also ran and tested our created application. In the next chapter, we will conclude the book with best practices from the JHipster community and next steps to make use of what you've learned so far.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>