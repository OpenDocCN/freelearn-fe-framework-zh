- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Latest Trends in Microfrontends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The world of frontend engineering is constantly evolving, and as we go about
    building microfrontends following the currently available tools, approaches, and
    best practices, it is important to keep an eye on the latest trends that are evolving
    in this space and keep exploring and experimenting with them to see how they can
    help us become more efficient and build better apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover some trends that can influence how we build
    microfrontends in the future. Some of the trends we will explore are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The name *microfrontends* itself and what is a better term for it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The island pattern of mixing static content with dynamic content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at other build tools beyond Webpack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebAssembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud or edge functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How generative AI can influence our work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will have learned about the latest trends in
    the frontend engineering space that impact how we build microfrontends.
  prefs: []
  type: TYPE_NORMAL
- en: Microfrontends – decoupled modular frontends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term *microfrontends* has obviously become very popular, and this entire
    book uses it, but to be honest, I’ve always felt it was poorly coined and unfortunately,
    it has stuck within the community. As mentioned a couple of times, the word *microfrontend*
    has led to a lot of misinterpretation, leading to bad architectural patterns that
    cause more harm than good. A new proposal has been put forward to start calling
    them **composable decoupled frontends** ([https://microfrontend.dev/](https://microfrontend.dev/)),
    which I think is apt and clearly explains the intent and purpose of what we are
    building. I really hope the community starts picking this term up and that we
    collectively all start moving to building and calling microfrontends what they
    really are and defining what they are really supposed to do.
  prefs: []
  type: TYPE_NORMAL
- en: I’m sure many of you will wonder how simply changing the name helps and what’s
    really in a name; however, I feel that, in this case, a name that clearly articulates
    the architecture pattern greatly reduces the misconceptions, misinterpretation,
    and complications arising from wrongly architected systems. As you will have realized
    through the course of this book, it is all about building modular applications
    that are decoupled from each other and hence they should be rightfully called
    **Decoupled** **Modular Frontends**.
  prefs: []
  type: TYPE_NORMAL
- en: The island pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Statically generated pages are gaining a lot of popularity as they ship very
    little to no JavaScript; however, the challenge with them has always been on how
    to serve dynamic content.
  prefs: []
  type: TYPE_NORMAL
- en: The **island pattern** aims to solve this problem. It was made popular by the
    Astro build framework, wherein we have our application published as a set of statically
    generated HTML pages, within which the dynamic parts of the page are imported
    as islands.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example of how this can be achieved using Astro, a popular framework
    for building statically generated sites.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about this at [https://docs.astro.build/en/concepts/islands/](https://docs.astro.build/en/concepts/islands/):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Run the Astro build command, test the app locally, and look into your `Inspect`
    command; you will notice that while the rest of the page is plain HTML with little
    to no JavaScript, `MyReactComponent` is a small JavaScript element and executes
    on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, with the island pattern, we get a clear distinction between
    static and dynamic content with the potential added benefit of not being locked
    down to a single framework for all parts of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having said that, there are a few differences between the island pattern and
    microfrontends, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Islands in Astro are components that are hydrated/rendered on the client side,
    while microfrontends are independent applications with their own code bases, routing,
    and backends. Microfrontends are more isolated and decoupled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Astro builds the entire app and islands at build time. Microfrontends are built
    and deployed independently. Astro has a unified build, while microfrontends can
    have separate builds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing in Astro happens in the shell, while each microfrontend manages its
    own routing. Astro islands don’t have independent routing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Astro islands can communicate with each other via Astro integration, while microfrontends
    typically communicate via well-defined APIs and events. Islands have tighter coupling
    and integration with the Astro app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beyond Webpack with ES Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the dawn of JavaScript-based frameworks, Webpack rose in popularity, and
    it became the de facto module bundler for all JavaScript frameworks. However,
    bundling/compiling large applications with Webpack can be very slow, and manually
    configuring it to efficiently bundle an app is very complex. Recently, a new breed
    of bundler tools that takes advantage of ES modules has taken the frontend world
    by storm, promising compilation over 20 times faster than Webpack.
  prefs: []
  type: TYPE_NORMAL
- en: ES modules are a standardized way to define and import modules in JavaScript.
    They allow for modular code organization, which can make it easier to develop
    and maintain large applications. ES modules also provide a clear and explicit
    syntax for importing and exporting code, making it easier to reason about the
    dependencies between different modules.
  prefs: []
  type: TYPE_NORMAL
- en: Each of our micro apps can be exported as ES modules, and by using dynamic imports,
    we can embed them into our host application.
  prefs: []
  type: TYPE_NORMAL
- en: The entire microfrontend application can be bundled using an ES build-based
    module bundler such as Vite ([https://vitejs.dev/](https://vitejs.dev/)). Monorepo
    frameworks such as Nx allow you to easily configure using Vite as your module
    bundler.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can scaffold out a React app using Vite as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a rough example of how this can be achieved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the host app, we use the classic React `suspense` and `lazy` functions to
    load in `CatalogApp` at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you will have noticed, we have managed to get our app working without using
    Webpack or Webpack’s module federation, and I’m sure you will also notice how
    fast the app builds after any changes that you make.
  prefs: []
  type: TYPE_NORMAL
- en: We believe ES modules and ES build systems will soon replace Webpack to become
    the de facto tools of choice for building all modern frontends. What is also interesting
    to note is that while React’s `lazy` and `suspense` functions are commonly thought
    of as performance optimization techniques, we take advantage of their ability
    to load modules in real time to build microfrontends.
  prefs: []
  type: TYPE_NORMAL
- en: Using WebAssembly Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**WebAssembly** (**Wasm**) has been around for many years now. Despite its
    huge benefits in terms of performance and low bundle size, it hasn’t gained much
    popularity, primarily because it wasn’t easy for developers to build a WASM module.
    However, now that people are starting to work with tools such as Rust, it gets
    fairly easy to build WebAssembly modules with Rust. We anticipate that WebAssembly
    will become mainstream when building applications that require a high level of
    computation on the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: WASM modules can work really well in a microfrontend architecture, where the
    critical compute-intensive modules are built in WASM wrapped as a micro app and
    imported into a microfrontend architecture in which the rest of the micro apps
    in the microfrontend are built using the standard React.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a rough approach of how you could set this up in your module federated
    Next.js app. Use our module federation code from [*Chapter 6*](B18987_06.xhtml#_idTextAnchor093).
    First build a Rust app using `wasm_bindgen` within a `/rust` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile the rust app to wasm we need to install the `wasm-pack-plugin` as
    using `pnpm install @wasm-tool/wasm-pack-plugin` and use it in the `next.config.js`
    configuration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Then using dynamic imports, import the wasm module into the index page of the
    remote app. And finally using the approaches we used in [*Chapter 6*](B18987_06.xhtml#_idTextAnchor093)
    import the remote app into the host app.
  prefs: []
  type: TYPE_NORMAL
- en: 'WASM is already being used in some very popular web-based tools such as Figma,
    AutoCAD, Google Earth, the Unity game engine, and so on. Combining WebAssembly
    modules with microfrontends helps bring the best of both worlds: the power and
    performance of WASM, and the ease of use and modularity of microfrontends.'
  prefs: []
  type: TYPE_NORMAL
- en: Edge Functions or Cloud functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Edge functions are gaining a lot of popularity, as they provide the power to
    compute on the edge. Think of them like a **Content Delivery Network** (**CDN**)
    but with the power and ability to run computations.
  prefs: []
  type: TYPE_NORMAL
- en: The primary benefits of edge functions are that they provide very low latency,
    which greatly helps improve performance, and they use an automatic distributed
    deployment, which mitigates single points of failure and helps improve scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Edge functions and microfrontends work quite well hand in hand, where you can
    have each micro app deployed within a cloud function; this automatically allows
    for modular deployments, and each team can manage its cloud functions independently.
  prefs: []
  type: TYPE_NORMAL
- en: Cloudflare is one of the most popular providers that support cloud functions.
    Cloudflare Workers and most recently Cloudflare Pages support computing on the
    edge. Here is an example of how to deploy a Next.js App on Cloudflare Pages using
    Edge Runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Start with any of the existing Next.js apps we’ve built.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Commit your changes and push them into a Git repo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Login into the Cloudflare dashboard and go to **Workers & Pages | Create Application
    | Pages | Connect** **to Git**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4\. Select the repo where you pushed the code and in the Setup builds and deployments,
    select Next.js as your Framework. Leave the rest of the settings as default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next we need to set the Compatibility Flags which we do by going into the `nodejs_compat`.
  prefs: []
  type: TYPE_NORMAL
- en: From the Deployment Details section go to the **Manage Deployment** and select
    **Retry deployment** from the dropdown.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the low costs and ease of deployments, we believe there is a great
    potential to deploy all frontend applications, irrespective of whether they are
    microfrontends or not, on platforms such as Vercel, Cloudflare, Fastly, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most edge function providers have very good support for the JavaScript ecosystem;
    however, it is important to keep in mind that based on the vendor/platform you
    are working on, there may be certain restrictions. For example, Cloudflare limits
    the size of each worker to be under 1 MB, or it explicitly supports package versions
    that are compatible with the broader Node.js runtime environments. For Cloudflare,
    you can read more about Node.js compatibility here: [https://developers.cloudflare.com/pages/framework-guides/](https://developers.cloudflare.com/pages/framework-guides/).'
  prefs: []
  type: TYPE_NORMAL
- en: Generative AI and Microfrontends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generative AI has clearly taken the world by storm. We are seeing amazing examples
    of generative AI being able to generate complete end-to-end applications.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to building microfrontends, it will be very interesting to see
    how things evolve. While I believe generative AI can’t take over a developer’s
    job, I do see interesting use cases of how generative AI can work hand in hand
    with microfrontends in building unique customer experiences.
  prefs: []
  type: TYPE_NORMAL
- en: Generative AI can be leveraged to dynamically generate and assemble various
    parts of a web application. By intelligently analyzing user behavior, preferences,
    and real-time context, AI can create microfrontends that are tailor-made for individual
    users, resulting in a highly personalized and optimized user experience. This
    approach also simplifies the development process by allowing developers to focus
    on creating modular, composable micro apps, while the AI system takes care of
    the overall assembly and rendering of the web application.
  prefs: []
  type: TYPE_NORMAL
- en: New AI-powered tools such as GPT-Engineer, smol-ai, and Auto-GPT are emerging,
    which allow developers to describe application requirements using plain text or
    Markdown. These tools then scaffold and generate code for the full application
    based on the developer’s specifications. This removes the need for manually writing
    all of the code, and instead, lets the AI handle much of the initial setup. These
    kinds of AI developer assistants are still at quite an early stage; developers
    will need to learn skills such as crafting effective prompts to get the most consistent
    and accurate results from the AI, but the potential is there for AI to significantly
    enhance and accelerate development workflows. The key will be continuing to improve
    the AI’s code generation abilities while also helping developers provide the right
    input and guidance.
  prefs: []
  type: TYPE_NORMAL
- en: The use of AI in microfrontends can lead to more efficient resource utilization
    and improved performance, as the system can adaptively load and unload components
    based on user interactions and needs. This innovative integration of AI and microfrontends
    has the potential to revolutionize the way web applications are designed, developed,
    and delivered to users.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this, we have come to the end of this chapter and the book. We really hope
    you’ve enjoyed the journey.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we looked at a few new trends that will influence the way we
    build and deploy microfrontends. We saw how concepts such as the island pattern
    can help interlace dynamic content blocks within a statically generated multipage
    app. We saw how the new Rust-based bundler can be many times faster than Webpack.
    We learned about WebAssembly and how it can be used within microfrontends, and
    finally, we looked at cloud functions, which have the potential to become the
    default solution for deploying all modern frontend applications.
  prefs: []
  type: TYPE_NORMAL
- en: I’m truly excited about how quickly technology is evolving and how it affects
    the way we build our applications. I can’t wait to see you go out in the wild
    and build things that make this world a better place.
  prefs: []
  type: TYPE_NORMAL
- en: In closing, it is essential to remember that the world of microfrontends, much
    like our dynamic digital landscape, is in a constant state of evolution. The concepts,
    techniques, and technologies we have unraveled throughout this journey, such as
    Module Federation and the intriguing practice of deploying microfrontends to the
    cloud, are just the beginning of this ever-evolving tapestry. They provide us
    with the building blocks to construct high-performing, scalable, and maintainable
    frontend architectures. Yet, the future beckons with promises of newer trends
    and advancements that will continue to redefine the horizon.
  prefs: []
  type: TYPE_NORMAL
- en: I encourage you, the next generation of developers, to step into this exciting
    journey and build upon the foundational knowledge this book has attempted to provide.
    Challenge the status quo, experiment with the latest trends, and mold them to
    fit the unique demands of your projects. It’s a grand time to be a frontend engineer,
    and the world awaits the innovative solutions you will create using React and
    microfrontends. Remember, every line of code you write is an opportunity to improve,
    innovate, and inspire. So, go forth and build for the future.
  prefs: []
  type: TYPE_NORMAL
