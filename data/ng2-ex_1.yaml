- en: Chapter 1. Getting Started
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。入门
- en: Developing applications in JavaScript is always a challenge. Due to its malleable
    nature and lack of type checking, building a decent-sized application in JavaScript
    is difficult. Moreover, we use JavaScript for all types of processes, such as
    user interface (UI) manipulation, client-server interaction, and business processing/validations.
    As a result, we end up with spaghetti code that is difficult to maintain and test.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中开发应用程序总是一个挑战。由于其可塑性和缺乏类型检查，用JavaScript构建一个体量较大的应用程序是困难的。此外，我们使用JavaScript进行各种类型的处理，如用户界面（UI）操作、客户端-服务器交互和业务处理/验证。因此，我们最终得到了难以维护和测试的意大利面代码。
- en: Libraries, such as jQuery, do a great job of taking care of various browser
    quirks and providing constructs that can lead to an overall reduction in the lines
    of code. However, these libraries lack any structural guidance that can help us
    when the codebase grows.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 图书馆，如jQuery，非常擅长处理各种浏览器怪癖，并提供可以减少代码行数的构造。然而，这些库缺乏任何可以在代码库增长时帮助我们的结构指导。
- en: In recent years, JavaScript frameworks have emerged to manage this complexity.
    Many of these frameworks, including earlier versions of Angular, use a design
    pattern called **Model-View-Controller** to separate the elements of the application
    into more manageable pieces. The success of these frameworks and their popularity
    in the developer community have established the value of using this pattern.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，JavaScript框架已经出现来管理这种复杂性。其中许多框架，包括早期版本的Angular，使用了一种称为**模型-视图-控制器**的设计模式，将应用程序的元素分离成更易管理的部分。这些框架的成功以及它们在开发者社区中的流行已经确立了使用这种模式的价值。
- en: Web development, however, is constantly evolving and a lot has changed since
    Angular was first introduced in 2009\. Technologies such as Web Components, the
    new version of JavaScript (ES2015), and TypeScript have all emerged. Taken together,
    they offer the opportunity to build a new, forward-looking framework. And with
    this new framework comes a new design pattern—the component pattern.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Web开发不断发展，自2009年首次推出Angular以来，许多事情已经发生了变化。诸如Web组件、新版本的JavaScript（ES2015）和TypeScript等技术都已经出现。综合起来，它们提供了构建一个新的、前瞻性框架的机会。随着这个新框架的出现，也带来了一种新的设计模式——组件模式。
- en: This chapter is dedicated to understanding the component pattern and how to
    put it into practice as we build a simple app using Angular.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门讨论组件模式的理解以及如何在构建一个简单的应用程序时将其付诸实践。
- en: 'The topics that we will cover in this chapter are as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主题如下：
- en: '**Angular basics**: We will briefly talk about the component pattern that is
    used to build Angular applications'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular基础知识**：我们将简要讨论用于构建Angular应用的组件模式'
- en: '**Building our first Angular app**: We will build a small game, *Guess the
    Number!*, in Angular'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建我们的第一个Angular应用**：我们将在Angular中构建一个小游戏，*猜数字！*'
- en: '**An introduction to some Angular constructs**: We will review some of the
    constructs that are used in Angular, such as interpolation, expressions, and the
    data binding syntax'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一些Angular构造的介绍**：我们将回顾在Angular中使用的一些构造，如插值、表达式和数据绑定语法'
- en: '**Change detection**: We will discuss how change detection is managed in an
    Angular app'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变更检测**：我们将讨论在Angular应用中如何管理变更检测'
- en: '**App initialization**: We will talk about the app initialization process in
    Angular; this is also known as **bootstrapping**'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用初始化**：我们将讨论Angular中的应用初始化过程；这也被称为**引导**'
- en: '**Tools and resources**: Lastly, we will provide some resources and tools that
    will come in handy during Angular development and debugging'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具和资源**：最后，我们将提供一些在Angular开发和调试过程中会派上用场的资源和工具'
- en: Angular basics
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular基础知识
- en: Let's get started by looking at how Angular implements the component pattern.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始看一下Angular如何实现组件模式。
- en: The component pattern
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件模式
- en: Angular applications use the component pattern. You may not have heard of this
    pattern, but it is all around us. It is used not only in software development
    but also in manufacturing, construction, and other fields. Put simply, it involves
    combining smaller, discrete building blocks into larger finished products. For
    example, a battery is a component of an automobile.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Angular应用程序使用组件模式。你可能没有听说过这种模式，但它无处不在。它不仅在软件开发中使用，还在制造业、建筑业和其他领域使用。简而言之，它涉及将更小、离散的构建块组合成更大的成品。例如，电池是汽车的一个组件。
- en: In software development, components are logical units that can be combined into
    larger applications. Components tend to have internal logic and properties that
    are shielded or hidden from the larger application. The larger application then
    consumes these building-blocks through specific gateways, called interfaces, which expose
    only what is needed to make use of the component. In this way, the component's
    internal logic can be modified without affecting the larger application, as long
    as the interfaces are not changed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，组件是可以组合成更大应用程序的逻辑单元。组件往往具有内部逻辑和属性，这些逻辑和属性对于较大的应用程序是被屏蔽或隐藏的。然后，较大的应用程序通过特定的接口（称为接口）消耗这些构建块，这些接口只暴露组件使用所需的内容。通过这种方式，只要不改变接口，组件的内部逻辑就可以被修改而不影响较大的应用程序。
- en: Getting back to our battery example, the car consumes the battery through a
    series of connectors. If the battery dies, however, it can be replaced by an entirely
    new battery, as long as that battery has the same connectors. This means that
    the builder of the car does not have to worry about the internals of the battery,
    which simplifies the process of building the car. Even more importantly, the car
    owner does not have to replace his or her car every time the battery dies.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的电池例子，汽车通过一系列连接器消耗电池。然而，如果电池耗尽，可以用全新的电池替换，只要那个电池有相同的连接器。这意味着汽车制造商不必担心电池的内部，这简化了汽车的制造过程。更重要的是，车主不必在电池耗尽时每次都更换汽车。
- en: To extend the analogy, manufacturers of batteries can market them for a range
    of different vehicles, for example, ATVs, boats, or snowmobiles. So the component
    pattern enables them to realize even greater economies of scale.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 延伸这个类比，电池制造商可以将它们推广给一系列不同的车辆，例如ATV、船或雪地摩托车。因此，组件模式使它们能够实现更大规模的经济效益。
- en: Using the component pattern in web applications
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Web应用程序中使用组件模式
- en: As web applications continue to become more sophisticated, the need to be able
    to construct them out of smaller and discrete components becomes more compelling.
    Components allow applications to be built in a way that prevents them from becoming
    messes of spaghetti code. Instead, component-based design allows us to reason
    about specific parts of the application in isolation from the other parts, and
    then we can stitch the application together into a finished, whole through agreed-upon
    points of connection.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Web应用程序变得越来越复杂，需要能够由更小、离散的组件构建它们的需求变得更加迫切。组件允许应用程序以一种方式构建，可以防止它们变成一团乱麻的代码。相反，基于组件的设计允许我们独立地思考应用程序的特定部分，然后我们可以通过约定的连接点将应用程序组合成一个完整的整体。
- en: Also, maintenance costs are less because each component's internal logic can
    be managed separately without affecting the other parts of the application. And
    putting applications together using self-describing components makes the application
    easier to understand at a higher level of abstraction.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，维护成本更低，因为每个组件的内部逻辑可以单独管理，而不会影响应用程序的其他部分。使用自描述组件组合应用程序使得应用程序在更高层次的抽象中更容易理解。
- en: Why weren't components used before in Angular?
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么之前的Angular版本没有使用组件？
- en: If this idea makes so much sense, why was the component pattern not adopted
    in earlier versions of Angular? The answer is that the technologies that existed
    when Angular was first released did not fully support the implementation of this
    pattern in web applications.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个想法这么有道理，为什么之前的Angular版本没有采用组件模式？答案是，当Angular首次发布时存在的技术并不完全支持在Web应用程序中实现这种模式。
- en: Earlier versions of Angular, however, made substantial steps in the direction
    of enabling more intelligent web application design and organization. For example,
    they implemented the MVC pattern, which separates an application into a model,
    view, and controller (you will see the use of the MVC pattern continuing within
    the components that we will build in Angular).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，早期版本的Angular在实现更智能的Web应用程序设计和组织方面迈出了重要的步伐。例如，它们实现了MVC模式，将应用程序分为模型、视图和控制器（你将在我们在Angular中构建的组件中看到MVC模式的使用）。
- en: With the MVC pattern, the model is the data, the view is a web page (or a mobile
    app screen or even a Flash page), and the controller populates the view with data
    from the model. In this way, separation of concerns is achieved. Following this
    pattern along with an intelligent use of directives will get you pretty close
    to components.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVC模式中，模型是数据，视图是一个网页（或移动应用程序屏幕，甚至是Flash页面），控制器用模型的数据填充视图。通过这种方式，实现了关注点的分离。遵循这种模式以及智能使用指令，可以让你接近组件。
- en: So, the earlier versions of Angular allowed applications to be designed and
    built more logically. However, this approach was limited by the fact that the
    technologies used were not truly isolated. Instead, they all ended up being rendered
    without any true separation from other elements on the screen.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，早期版本的Angular允许更合乎逻辑地设计和构建应用程序。然而，这种方法受到限制，因为使用的技术并不真正隔离。相反，它们最终都在屏幕上与其他元素没有真正的分离而呈现出来。
- en: What's new that enables Angular to use this pattern?
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使得Angular能够使用这种模式的新特性是什么？
- en: By contrast, the newest version of Angular embraces recently emerging technologies,
    which make it possible to implement the component pattern more fully. These technologies
    include Web Components, ES2015 (the new version of JavaScript), and TypeScript.
    Let's discuss what each of these technologies brings to the mix that makes this
    possible.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，最新版本的Angular采用了最近出现的技术，这些技术使得完全实现组件模式成为可能。这些技术包括Web组件、ES2015（JavaScript的新版本）和TypeScript。让我们讨论一下这些技术各自带来的可能性。
- en: Web Components
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Web组件
- en: 'Web Components is an umbrella term that actually covers four emerging standards
    for web browsers:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Web组件是一个总称，实际上涵盖了Web浏览器的四个新兴标准：
- en: Custom elements
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义元素
- en: Shadow DOM
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 影子DOM
- en: Templates
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板
- en: HTML imports
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML导入
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information on Web Components can be found at [http://webcomponents.org](http://webcomponents.org).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Web组件的更多信息，请访问[http://webcomponents.org](http://webcomponents.org)。
- en: 'Let''s now discuss each of these in detail:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们详细讨论一下这些：
- en: Custom elements enable new types of element to be created other than the standard
    HTML tag names such as `<div>` and `<p>`. The ability to add custom tags provides
    a location on the screen that can be reserved for binding a component. In short,
    this is the first step towards separating a component from the rest of the page
    and making it possible to become truly self-contained.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义元素使得除了标准的HTML标签名（如`<div>`和`<p>`）之外，可以创建新类型的元素。添加自定义标签的能力提供了一个屏幕上可以保留用于绑定组件的位置。简而言之，这是将组件与页面其余部分分离并使其成为真正自包含的第一步。
- en: Shadow DOM provides a hidden area on the page for scripts, CSS, and HTML. Markup
    and styles that are within this hidden area will not affect the rest of the page,
    and equally important they will not be affected by the markup and styles on other
    parts of the page. Our component can use this hidden area to render its display.
    So, this is the second step in making our component self-contained.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shadow DOM为页面提供了一个隐藏区域，用于脚本、CSS和HTML。在这个隐藏区域内的标记和样式不会影响页面的其余部分，同样重要的是它们也不会受到页面其他部分的标记和样式的影响。我们的组件可以利用这个隐藏区域来渲染其显示。因此，这是使我们的组件自包含的第二步。
- en: Templates are repeatable chunks of HTML that have tags that can be replaced
    with dynamic content at runtime using JavaScript. Many JavaScript frameworks already
    support some form of templating. Web Components standardize this templating and
    provide direct support for it in the browser. Templates can be used to make the
    HTML and CSS inside the Shadow DOM used by our component dynamic. So, this is
    the third step in making our component.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板是可重复使用的HTML块，其中的标记可以在运行时使用JavaScript替换为动态内容。许多JavaScript框架已经支持某种形式的模板。Web组件标准化了这种模板，并在浏览器中直接支持它。模板可以用于使我们组件中使用的Shadow
    DOM内的HTML和CSS变得动态。因此，这是使我们的组件的第三步。
- en: The final standard that makes up Web Components is HTML imports. They provide
    a way to load resources such as HTML, CSS, and JavaScript in a single bundle.
    Angular does not use HTML imports. Instead, it relies on JavaScript module loading,
    which we will discuss a little later in this chapter.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构成Web组件的最终标准是HTML导入。它们提供了一种加载HTML、CSS和JavaScript等资源的方式。Angular不使用HTML导入。相反，它依赖于JavaScript模块加载，我们将在本章稍后讨论。
- en: Angular and Web Components
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Angular和Web组件
- en: Web Components are not fully supported in current web browsers. For that reason,
    Angular components are not strictly Web Components. It is probably more accurate
    to say that Angular components implement the design principles behind Web Components.
    They also make it possible to build components that can run on today's browsers.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的Web浏览器并不完全支持Web组件。因此，Angular组件并不严格属于Web组件。更准确地说，Angular组件实现了Web组件背后的设计原则。它们还使得可以构建可以在今天的浏览器上运行的组件。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing this book, Angular supports evergreen browsers, such
    as Chrome, Firefox, Edge, as well as IE 7 and later. It also has mobile support
    for Android 4.1 and later. For a list of browsers supported by Angular, visit
    [https://github.com/angular/angular](https://github.com/angular/angular).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，Angular支持最新版本的浏览器，如Chrome、Firefox、Edge，以及IE 7及更高版本。它还支持Android 4.1及更高版本的移动设备。有关Angular支持的浏览器列表，请访问[https://github.com/angular/angular](https://github.com/angular/angular)。
- en: Therefore, throughout the rest of this book, we will focus on building Angular
    components and not Web Components. Despite this distinction, Angular components
    align closely with Web Components and can even interoperate with them. As browsers
    begin to support Web Components more fully, the differences between Angular components
    and Web Components will begin to disappear. So, if you want to begin adopting
    the Web Component standards of the future, Angular provides you with the opportunity
    to do so today.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本书的其余部分，我们将专注于构建Angular组件而不是Web组件。尽管有这种区别，Angular组件与Web组件紧密配合，甚至可以与它们互操作。随着浏览器开始更全面地支持Web组件，Angular组件和Web组件之间的差异将开始消失。因此，如果您想开始采用未来的Web组件标准，Angular为您提供了今天这样做的机会。
- en: Language support in Angular
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Angular中的语言支持
- en: You can develop components with ES5, but Angular enhances the ability to develop
    components by adding support for key features that are found in the latest languages,
    such as ES2015 and TypeScript.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用ES5开发组件，但Angular通过添加对最新语言（如ES2015和TypeScript）中找到的关键功能的支持，增强了开发组件的能力。
- en: ES2015
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ES2015
- en: 'ES2015 is the new version of JavaScript; it was approved in June 2015\. It
    adds many improvements to the language, which we will see throughout this book,
    but the two that interest us the most at this point are the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ES2015是JavaScript的新版本；它于2015年6月获得批准。它为语言添加了许多改进，我们将在本书中看到，但在这一点上，我们最感兴趣的是以下两点：
- en: Classes
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Module loading
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块加载
- en: '**Classes** did not previously exist in JavaScript. The key advantage of using
    them, now that they do exist, is that they provide a convenient container for
    the code in our component.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**类**以前在JavaScript中不存在。现在它们存在的主要优势是，它们为我们组件中的代码提供了一个方便的容器。'
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To be clear, JavaScript classes do not introduce something that is completely
    new. The **Mozilla Developer Network** (**MDN**) describes them as
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 明确一点，JavaScript类并没有引入完全新的东西。**Mozilla开发者网络**（**MDN**）将它们描述为
- en: '"syntactical sugar over JavaScript''s existing prototype-based inheritance.
    . . [that] provide a much simpler and clearer syntax to create objects and deal
    with inheritance."'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"对JavaScript现有基于原型的继承的一种语法糖。. . [提供了]一个更简单和更清晰的语法来创建对象和处理继承。"'
- en: For more information visit [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请访问[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)。
- en: We'll ecplore these throughout the examples in this book. If you have not worked
    with object-oriented languages, you may not be familiar with classes, so we will
    cover them as we work through the examples in this chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的示例中探索这些内容。如果您之前没有使用过面向对象的语言，可能不熟悉类，因此我们将在本章的示例中逐步介绍它们。
- en: ES2015 also introduces a new approach to **module loading**. A module provides
    a way for JavaScript files to be encapsulated. When they are encapsulated, they
    do not pollute the global namespace and can interact with other modules in a controlled
    manner. We will cover modules in more details in later chapters.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ES2015还引入了一种新的**模块加载**方法。模块提供了一种将JavaScript文件封装的方式。当它们被封装时，它们不会污染全局命名空间，并且可以以受控的方式与其他模块进行交互。我们将在后面的章节中更详细地介绍模块。
- en: Once we have our modules defined, we need a way to load them into our application
    for execution. Module loading allows us to select just what we need for our application
    from the modules that make up Angular and other components that we create or use.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了模块，我们需要一种方法将它们加载到我们的应用程序中以执行。模块加载允许我们从组成Angular和其他组件的模块中选择我们应用程序所需的内容。
- en: Currently, a range of approaches and libraries exists to support module loading
    in JavaScript. ES2015 adds a new, consistent syntax for loading modules as part
    of the language. The syntax is straightforward and involves prefixing modules
    with the `export` keyword (or using the default export) and then using `import`
    to consume them elsewhere in our application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，存在一系列方法和库来支持JavaScript中的模块加载。ES2015添加了一种新的、一致的语法来加载模块作为语言的一部分。这种语法很简单，涉及到用`export`关键字（或使用默认导出）给模块加前缀，然后在应用程序的其他地方使用`import`来消费它们。
- en: ES 2015 module loading enables us to combine components into useful bundles
    or features that can be imported or exported within our applications. In fact,
    modules are at the core of Angular itself. We will see that modules are used extensively
    both in Angular itself and in the applications that we are building throughout
    this book.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ES 2015模块加载使我们能够将组件组合成有用的包或功能，可以在我们的应用程序中导入或导出。事实上，模块是Angular本身的核心。我们将看到，模块在Angular本身以及我们在本书中构建的应用程序中被广泛使用。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to understand that, while Angular uses syntax that has similarities
    to ES2015 module-loading syntax, Angular modules (which we will discuss a little
    later in this chapter) are not the same as JavaScript modules. For further details
    on these differences see the Angular documentation at [https://angular.io/docs/ts/latest/guide/architecture.html](https://angular.io/docs/ts/latest/guide/architecture.html).
    From this point on we will be focusing on Angular modules.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，虽然Angular使用的语法与ES2015模块加载语法相似，但Angular模块（我们将在本章稍后讨论）与JavaScript模块并不相同。有关这些差异的更多细节，请参阅Angular文档[https://angular.io/docs/ts/latest/guide/architecture.html](https://angular.io/docs/ts/latest/guide/architecture.html)。从这一点开始，我们将专注于Angular模块。
- en: Because ES2015 is not fully supported by today's browsers, we will need to convert
    ES2015 into ES5 in order to use features such as classes and module loading in
    our applications. We do this through a process called **transpilation**.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于今天的浏览器并不完全支持ES2015，我们需要将ES2015转换为ES5，以便在我们的应用程序中使用类和模块加载等功能。我们通过一个称为**转译**的过程来实现这一点。
- en: Transpilation is like compilation, except that instead of converting our code
    into a machine language as compilation does, transpilation converts one type of
    source code to another type of source code. In this case, it converts ES2015 to
    ES5\. There are several tools called **transpilers** that enable us to do that.
    Common transpilers include Traceur and Babel. TypeScript (which we will discuss
    next) is also a transpiler, and it is the one that we will use for the examples
    in this book.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 转译类似于编译，不同之处在于，转译将我们的代码转换为机器语言，而转译将一种类型的源代码转换为另一种类型的源代码。在这种情况下，它将ES2015转换为ES5。有几种工具称为**转译器**使我们能够做到这一点。常见的转译器包括Traceur和Babel。TypeScript（我们将在下面讨论）也是一个转译器，它是我们在本书中使用的示例。
- en: Once ES2015 is transpiled to ES5, we can then use a module loader such as **SystemJS**
    to load our modules. SystemJS follows the ES2015 syntax for module loading and
    gives us the ability to do module loading in today's browsers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦ES2015被转译为ES5，我们就可以使用诸如**SystemJS**之类的模块加载器来加载我们的模块。SystemJS遵循ES2015模块加载的语法，并使我们能够在今天的浏览器中进行模块加载。
- en: TypeScript
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: TypeScript
- en: 'TypeScript was created by Microsoft as a superset of JavaScript, which means
    that it contains the features of ES2015 (such as classes and module loading) and
    adds the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript是由微软创建的JavaScript的超集，这意味着它包含了ES2015的特性（如类和模块加载），并添加了以下内容：
- en: Types
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型
- en: Decorators
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器
- en: '**Types** allow us to mark variables, properties, and parameters in our classes
    to indicate that they are numbers, strings, Booleans, or various structures such
    as arrays and objects. This enables us to perform type checking at design time
    to make sure that the proper types are being used in our application.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型**允许我们在类中标记变量、属性和参数，以指示它们是数字、字符串、布尔值或各种结构，如数组和对象。这使我们能够在设计时执行类型检查，以确保在我们的应用程序中使用了正确的类型。'
- en: '**Decorators** are simple annotations that we can add to our classes using
    the @ symbol along with a function. They provide instructions (called metadata)
    for the use of our classes. In the case of Angular, decorators allow us to identify
    our classes as Angular components. Decorators can specify modules to be used with
    a component and how to implement various bindings and directives, including attaching
    an HTML view to the component. We will cover much more about the use of decorators
    as we go through this book.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**装饰器**是我们可以使用@符号和函数添加到我们的类中的简单注释。它们为我们的类的使用提供指令（称为元数据）。在Angular的情况下，装饰器允许我们将我们的类标识为Angular组件。装饰器可以指定要与组件一起使用的模块，以及如何实现各种绑定和指令，包括将HTML视图附加到组件。随着我们在本书中的学习，我们将更多地涵盖装饰器的使用。'
- en: Decorators form a part of the ES2017 proposal and are not part of ES2015\. They
    were added to TypeScript as part of a collaboration between Microsoft and Google.
    As mentioned earlier, TypeScript compiles into ES5, so we are able to use both
    types and decorators in browsers that do not fully support ES2015 or the proposed
    standard for decorators.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是ES2017提案的一部分，不是ES2015的一部分。它们作为微软和谷歌之间合作的一部分被添加到TypeScript中。正如前面提到的，TypeScript编译成ES5，因此我们可以在不完全支持ES2015或装饰器的浏览器中使用类型和装饰器。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意：…
- en: As mentioned previously, it is not necessary to use either ES2015 or TypeScript
    with Angular. However, we think that you will see the advantages of using them
    as we work through the examples in this book.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用Angular不需要使用ES2015或TypeScript。然而，我们认为随着我们在本书中的示例的进行，您将看到使用它们的优势。
- en: Putting it all together
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: By following the Web Component standards and adding support for ES2015 and TypeScript,
    Angular gives us the ability to create web applications that implement the component
    design pattern. These components help realize the vision behind the standards
    of building large-scale applications through collections of self-describing and
    self-contained building blocks.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循Web组件标准并支持ES2015和TypeScript，Angular使我们能够创建实现组件设计模式的Web应用程序。这些组件有助于实现构建大型应用程序的标准的愿景，通过自描述和自包含的构建块集合。
- en: We hope you will see in the examples in this book that Angular enables components
    to be constructed in a straightforward and declarative way that makes it easier
    for developers to implement them. As we proceed through the examples in this book,
    we will highlight where each of these technologies is being used.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望您能在本书的示例中看到，Angular使组件能够以直观和声明性的方式构建，这使得开发人员更容易实现它们。随着我们在本书中的示例的进行，我们将强调每种技术的使用位置。
- en: Angular modules
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular模块
- en: Components are the basic building block of an Angular application. But how do
    we then organize these building blocks into complete applications? Angular modules
    provide the answer to this question. They enable us to combine our components
    into reusable groups of functionality that can be exported and imported throughout
    our application. For example, in a more sophisticated application we would want
    to have modules for things such as authentication, common utilities, and external
    service calls. At the same time, modules enable us to group features within an
    application in a way that allows us to load them on demand. This is called lazy
    loading, a topic we will cover in [Chapter 4](part0045.xhtml#1AT9A1-edca168d36254bda8a21f611a95615c3
    "Chapter 4.  Personal Trainer"), *Building Personal Trainer*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是Angular应用程序的基本构建块。但是我们如何将这些构建块组织成完整的应用程序呢？Angular模块提供了这个问题的答案。它们使我们能够将组件组合成可重用的功能组，并可以在整个应用程序中导出和导入。例如，在更复杂的应用程序中，我们希望为身份验证、常用工具和外部服务调用等事物创建模块。同时，模块使我们能够以一种允许按需加载它们的方式对应用程序中的功能进行分组。这被称为惰性加载，这是我们将在[第4章](part0045.xhtml#1AT9A1-edca168d36254bda8a21f611a95615c3
    "第4章。个人教练")中介绍的主题，*构建个人教练*。
- en: Each Angular application will have one or more modules that contain its components.
    Angular has introduced `NgModule` as a way to conveniently specify the components
    that make up a module. Every Angular application must have at least one of these
    modules—the root module.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Angular应用程序都将包含一个或多个包含其组件的模块。Angular引入了`NgModule`作为一种方便地指定组成模块的组件的方式。每个Angular应用程序必须至少有一个这样的模块——根模块。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Angular itself is built as modules that we import into our application. So you
    will see the use of modules all over as you build Angular apps.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Angular本身是作为模块构建的，我们将其导入到我们的应用程序中。因此，当您构建Angular应用程序时，您将在各处看到模块的使用。
- en: The basic steps to building Angular applications
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建Angular应用程序的基本步骤
- en: 'To sum up: at a basic level, you will see that to develop applications in Angular,
    you will do the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 总之：在基本层面上，您将看到在Angular中开发应用程序时，您将执行以下操作：
- en: Create components.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建组件。
- en: Bundle them into modules.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们捆绑到模块中。
- en: Bootstrap your application.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动您的应用程序。
- en: The best way to understand Angular and the component design pattern is by seeing
    it in action. Hence, we are going to build our first Hello World app in Angular.
    This app will help you become familiar with the Angular framework and see the
    component design pattern in action.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Angular和组件设计模式的最佳方法是通过实际操作。因此，我们将在Angular中构建我们的第一个Hello World应用程序。这个应用程序将帮助您熟悉Angular框架，并看到组件设计模式的实际应用。
- en: Let's get started doing that.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始做这件事。
- en: The customary Hello Angular app - Guess the Number!
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统的Hello Angular应用程序-猜数字！
- en: As our first exercise, we want to keep things simple but still showcase the
    framework's capabilities. Therefore, we are going to build a very simple game
    called *Guess the Number!*. The objective of the game is to guess a random computer-generated
    number in as few tries as possible.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们的第一个练习，我们希望保持简单，但仍然展示框架的能力。因此，我们将构建一个非常简单的游戏，名为*猜数字*。游戏的目标是以尽可能少的尝试次数猜出一个随机生成的计算机数字。
- en: 'This is how the game looks:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是游戏的样子：
- en: '![The customary Hello Angular app - Guess the Number!](../Images/image00430.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![传统的Hello Angular应用程序-猜数字！](../Images/image00430.jpeg)'
- en: Setting up a development server
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置开发服务器
- en: The development web server that we choose greatly depends on the platform we
    work on and the backend we support. However, since apps in this book target purely
    client-side development, any web server will do.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择的开发Web服务器在很大程度上取决于我们所工作的平台和我们支持的后端。然而，由于本书中的应用程序纯粹针对客户端开发，任何Web服务器都可以。
- en: Our recommendation is to use `live-server`, a simple HTTP server with live reload
    capability. You can install it using Node.js. Since Node.js is available cross-platform,
    you can install Node.js from [http://nodejs.org/](http://nodejs.org/).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用`live-server`，这是一个带有实时重新加载功能的简单HTTP服务器。您可以使用Node.js安装它。由于Node.js可跨平台使用，您可以从[http://nodejs.org/](http://nodejs.org/)安装Node.js。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For this book, we are using Node.js version 4.4.2 and npm version 3.8.6\. You
    can find more information about installing Node and updating npm to the latest
    version at [https://docs.npmjs.com/getting-started/installing-node](https://docs.npmjs.com/getting-started/installing-node).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书，我们使用的是Node.js版本4.4.2和npm版本3.8.6。您可以在[https://docs.npmjs.com/getting-started/installing-node](https://docs.npmjs.com/getting-started/installing-node)找到有关安装Node和更新npm到最新版本的更多信息。
- en: 'Once Node.js is installed, installing the `live-server` module and running
    the HTTP server is easy. Open the command line and type the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了Node.js，安装`live-server`模块并运行HTTP服务器就很容易。打开命令行并输入以下命令：
- en: '[PRE0]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This installs `live-server` at the global level.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在全局级别安装`live-server`。
- en: 'To run the server, we just navigate to the folder where the app code resides,
    or open the folder from where we want to serve static files. Then type this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行服务器，我们只需导航到应用代码所在的文件夹，或者打开要提供静态文件的文件夹。然后输入这个：
- en: '[PRE1]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: And that's it!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！
- en: We have an HTTP server running at `http://localhost:8080`. It can serve files
    from the current directory.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`http://localhost:8080`上运行着一个HTTP服务器。它可以从当前目录中提供文件。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `live-server` module does support some startup configurations. Check out
    the documentation at [https://github.com/tapio/live-server](https://github.com/tapio/live-server).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`live-server`模块确实支持一些启动配置。请查看[https://github.com/tapio/live-server](https://github.com/tapio/live-server)上的文档。'
- en: Depending on the platform we are on, we can also try Python's `SimpleHTTPServer`
    module, Mongoose, or any such web server.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们所在的平台，我们还可以尝试Python的`SimpleHTTPServer`模块，Mongoose或任何类似的Web服务器。
- en: Let's now build *Guess the Number!*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来构建*猜数字*游戏。
- en: Building Guess the Number!
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建猜数字游戏！
- en: The standard practice while building user interfaces is to build them top-down.
    Start by designing the UI and then plug in the data and behavior according to
    your needs. With such an approach, the UI, data, and behavioral aspects of the
    app are all tightly coupled, which is a less than ideal situation!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 构建用户界面的标准做法是自上而下地构建它们。首先设计UI，然后根据需要插入数据和行为。采用这种方法，应用的UI、数据和行为方面都是紧密耦合的，这是一个不太理想的情况！
- en: With component-based design, we work differently. We start by looking at the
    UI and expected behavior, and then we encapsulate all of this into a building
    block that we call a **component**. This component is then hosted on our page.
    Within the component, we separate the UI into a view and the behavior into a class,
    with the appropriate properties and methods needed to support the behavior. If
    you are not familiar with classes, don't worry. We'll be discussing what they
    are in detail as we move through the example.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于组件的设计，我们的工作方式不同。我们首先查看UI和预期行为，然后将所有这些封装到我们称之为**组件**的构建块中。然后在我们的页面上托管这个组件。在组件内部，我们将UI分离为视图，将行为分离为一个类，具有支持行为所需的适当属性和方法。如果你不熟悉类，不用担心。随着我们在示例中的深入讨论，我们将详细讨论它们是什么。
- en: Okay, so let's identify the UI and behavior that we will need for our application.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们确定我们的应用程序所需的UI和行为。
- en: Designing our first component
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计我们的第一个组件
- en: 'To determine what needs to go into our component, we will start by detailing
    the features that we want the app to support:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定我们的组件需要什么，我们将从详细说明我们希望应用程序支持的功能开始：
- en: Generating random numbers (`original`)
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成随机数（`original`）
- en: Providing input for a user to guess the value (`guess`)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为用户提供猜测值的输入（`guess`）
- en: Tracking the number of guesses already made (`noOfTries`)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪已经猜测的次数（`noOfTries`）
- en: Giving the user hints to improve their guess based on their input (`deviation`)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据用户的输入提供提示以改进他们的猜测（`deviation`）
- en: Giving a success message if the user guesses the number correctly (`deviation`)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户正确猜测了数字，则提供成功消息（`deviation`）
- en: Now that we have our features, we can determine what we need to display to the
    user and what data we need to track. For the preceding feature set, the elements
    in parentheses denote the properties that will support those features and will
    need to be included in our component.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的功能，我们可以确定需要向用户显示什么数据以及需要跟踪什么数据。对于前面的功能集，括号中的元素表示将支持这些功能并且需要包含在我们的组件中的属性。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Designing the component is a very crucial process. If it is done right, we can
    logically organize our application in a way that makes it understandable and easy
    to maintain.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 设计组件是一个非常关键的过程。如果做得好，我们可以以一种使其易于理解和易于维护的方式逻辑地组织我们的应用程序。
- en: While building any app, we urge you to first think about the functionality you
    want to offer, and then the data and behavior that can support the functionality.
    Lastly, think about how to build a user interface for it. This is a good practice
    irrespective of the library or framework you use to build your app.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建任何应用程序时，我们建议您首先考虑要提供的功能，然后考虑支持功能的数据和行为。最后，考虑如何为其构建用户界面。无论您使用哪种库或框架构建应用程序，这都是一个很好的实践。
- en: The host file
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主机文件
- en: Let's start by creating files for our component. We'll start by creating a directory
    for our application. We'll name it `guessthenumber` (but you can name it anything
    that suits you). We'll use that to add our files.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为我们的组件创建文件开始。我们将首先创建一个目录用于我们的应用程序。我们将其命名为`guessthenumber`（但您可以根据需要命名）。我们将使用它来添加我们的文件。
- en: An HTML page
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个HTML页面
- en: 'First, open your favorite editor and create an HTML page with the following
    `html `and `script` tags:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开您喜欢的编辑器，并创建一个包含以下`html`和`script`标签的HTML页面：
- en: '[PRE2]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: 'The code in this book is available on GitHub at [https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample).
    It is organized in checkpoints that allow you to follow along step by step as
    we build our sample projects in this book. The branch to download for this chapter
    is GitHub''s **Branch: checkpoint1.1**. Look in the `guessthenumber` folder for
    the code we are covering here. If you are not using Git, download the snapshot
    of Checkpoint 1.1 (a ZIP file) from the following GitHub location: [https://github.com/chandermani/angular2byexample/tree/checkpoint1.1](https://github.com/chandermani/angular2byexample/tree/checkpoint1.1).
    Refer to the `readme.md` file in the `guessthenumber` folder when setting up the
    snapshot for the first time.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码可以在GitHub上找到：[https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample)。它按照检查点进行组织，允许您一步一步地跟随我们在本书中构建示例项目。本章的下载分支是GitHub的**分支：checkpoint1.1**。在`guessthenumber`文件夹中查找我们在此处涵盖的代码。如果您不使用Git，请从以下GitHub位置下载Checkpoint
    1.1的快照（ZIP文件）：[https://github.com/chandermani/angular2byexample/tree/checkpoint1.1](https://github.com/chandermani/angular2byexample/tree/checkpoint1.1)。首次设置快照时，请参考`guessthenumber`文件夹中的`readme.md`文件。
- en: Script tags
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 脚本标签
- en: 'There are several things to note in this file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中有几点需要注意：
- en: 'The first five `<script>` tags reference the following:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前五个`<script>`标签引用以下内容：
- en: '`shim`: This provides ES2015 features for older browsers'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shim`：这为旧版浏览器提供了ES2015功能'
- en: '`reflect-metadata`: This adds decorator support'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reflect-metadata`：这添加了装饰器支持'
- en: '`zone.js`: This manages change detection'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zone.js`：这管理变更检测'
- en: '`typescript.js`: This is the current version of TypeScript'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typescript.js`：这是当前版本的TypeScript'
- en: '`system.js`: This loads our modules'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system.js`：这加载我们的模块'
- en: 'The next `<script>` tag references a JavaScript file within our application:
    `systemjs.config.js`. Be sure to add that file from the example code files. We
    will be discussing this file a little later. Essentially, it provides instructions
    to SystemJS as to which modules it should load and directs it to dynamically transpile
    our TypeScript files to ES5 at runtime.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的`<script>`标签引用了我们应用程序中的一个JavaScript文件：`systemjs.config.js`。确保从示例代码文件中添加该文件。我们稍后将讨论这个文件。基本上，它为SystemJS提供了指令，告诉它应该加载哪些模块，并指示它在运行时动态转译我们的TypeScript文件为ES5。
- en: 'The final `<script>` tag calls SystemJS to import our component directory:
    `app`.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后的`<script>`标签调用SystemJS来导入我们的组件目录：`app`。
- en: We will discuss how the latter two script tags work together to enable module
    loading a little later in the chapter.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论后两个脚本标签如何一起工作以启用模块加载。
- en: Custom elements
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义元素
- en: 'There is one more important tag on the page:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 页面上还有一个更重要的标签：
- en: '[PRE3]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This tag is a **custom element**. It instructs Angular where to inject the component
    that we will be building.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标签是一个**自定义元素**。它指示Angular在哪里注入我们将要构建的组件。
- en: The rest of the app's HTML code is self-explanatory. We reference the Twitter
    Bootstrap CSS in the `<head>` section and add a title, which is `Guess the Number!`,
    for our page.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的其余HTML代码是不言自明的。我们在`<head>`部分引用了Twitter Bootstrap CSS，并为我们的页面添加了一个标题，即`猜数字游戏！`。
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Guess the Number!* and all the other apps that are part of this book have
    been tested against the Angular final release.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*猜数字游戏*和本书中的所有其他应用程序都已针对Angular最终版本进行了测试。'
- en: The component file
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件文件
- en: Now let's create a file for our component.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为我们的组件创建一个文件。
- en: Add a subdirectory to our application called `app`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的应用程序中添加一个名为`app`的子目录。
- en: Then, using your editor, create a file with the name `guess-the-number.component.ts`
    and place it in that subdirectory. The `.ts` extension identifies our file as
    a TypeScript file that will be compiled into ES5 at runtime.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用您的编辑器，创建一个名为`guess-the-number.component.ts`的文件，并将其放在该子目录中。`.ts`扩展名将我们的文件标识为将在运行时编译为ES5的TypeScript文件。
- en: The import statement
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入语句
- en: 'At the top of the page, place the following line:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面顶部放置以下行：
- en: '[PRE4]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is an import statement. It tells us what modules we will be loading and
    using in our component. In this case, we are selecting one module that we need
    to load from Angular: `Component`. Angular has many other modules, but we load
    only what we need.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个导入语句。它告诉我们在我们的组件中将加载和使用哪些模块。在这种情况下，我们正在选择需要从Angular加载的一个模块：`Component`。Angular有许多其他模块，但我们只加载我们需要的。
- en: You'll notice that the location from which we are importing is not identified
    as a path or directory within our application. Instead, it is identified as `@angular/core`.
    Angular has been divided into barrel modules that are prefixed with `@angular`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们导入的位置并未被标识为我们应用程序中的路径或目录。相反，它被标识为`@angular/core`。Angular已被分成了以`@angular`为前缀的桶模块。
- en: These barrels combine several modules that are logically related. In this case,
    we are indicating that we want to import the `core` barrel module, which in turn
    brings in the `Component` module. This naming convention ties into the loading
    of our modules, which we will discuss in more detail later in this chapter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这些桶组合了几个逻辑相关的模块。在这种情况下，我们指示要导入`core`桶模块，这将带入`Component`模块。这种命名约定与我们模块的加载相关联，我们将在本章后面更详细地讨论。
- en: Decorators
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 装饰器
- en: 'Next, add the following block of script to your `guess-the-number.component.ts`
    file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在你的`guess-the-number.component.ts`文件中添加以下脚本块：
- en: '[PRE5]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is the decorator for our component and is placed directly above the class
    definition, which we will discuss soon. The `@` symbol is used to identify a decorator.
    The `@Component` decorator has a property called selector, and you may not be
    surprised to see that it is set to the `<my-app>` tag in our HTML page. This setting
    tells Angular to inject this component into that tag on the HTML page.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们组件的装饰器，直接放在类定义的上面，我们很快会讨论。`@`符号用于标识装饰器。`@Component`装饰器有一个名为selector的属性，您可能不会感到惊讶，它设置为我们HTML页面中的`<my-app>`标签。这个设置告诉Angular将这个组件注入到HTML页面上的那个标签中。
- en: The decorator also has a property called template, and this property identifies
    the HTML markup for our component. Notice the use of back ticks (introduced by
    ES2015) for rendering the template string over multiple lines. Alternatively,
    we can set a `templateUrl` property that would point to a separate file.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器还有一个名为template的属性，该属性标识了我们组件的HTML标记。请注意在模板字符串上使用反引号（由ES2015引入）来渲染多行。或者，我们可以设置一个`templateUrl`属性，指向一个单独的文件。
- en: Defining the class
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义类
- en: 'Now, add the following block of code to your `guess-the-number.component.ts`
    file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将以下代码块添加到您的`guess-the-number.component.ts`文件中：
- en: '[PRE6]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you have been developing in ES5, the version of JavaScript that is supported
    in all current browsers, you may not be familiar with the use of classes here.
    So, we will take a few moments to walk through what makes up a class (for those
    of you who have developed using an object-oriented programming language, such
    as C# or Java, this should be familiar territory).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一直在ES5中开发，这是所有当前浏览器支持的JavaScript版本，您可能不熟悉这里使用类的方式。因此，我们将花一些时间来介绍什么是类（对于那些使用面向对象编程语言（如C#或Java）开发的人来说，这应该是熟悉的领域）。
- en: The class file holds the code that we will use to run our component. At the
    top, we give the class a name, which is `GuessTheNumberComponent`. Then, inside
    the curly braces, we have four lines that declare the properties for our class.
    These are similar to ES5 variables, and we will use them to hold the values that
    we will need to run the application (you'll notice that these are the four values
    that we identified when we designed our component).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 类文件保存了我们将用来运行组件的代码。在顶部，我们给类一个名字，即`GuessTheNumberComponent`。然后，在花括号内，我们有四行声明我们类的属性。这些类似于ES5变量，我们将使用它们来保存我们运行应用程序所需的值（您会注意到这些是我们设计组件时确定的四个值）。
- en: What makes these properties different from standard JavaScript variables is
    that each property name is followed by `:` and number. These set the type of the
    property. In this case, we are indicating that each of these four properties will
    be set to the number type, which means we are expecting the values of all of these
    properties to be numbers. The ability to specify types for our properties is provided
    by TypeScript and is not available in standard JavaScript.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性与标准JavaScript变量的不同之处在于，每个属性名称后面都跟着`:`和数字。这些设置了属性的类型。在这种情况下，我们指示这四个属性将被设置为数字类型，这意味着我们期望所有这些属性的值都是数字。为我们的属性指定类型的能力是由TypeScript提供的，在标准JavaScript中是不可用的。
- en: As we move down, we will see three blocks of script that have names, followed
    by parentheses, and then curly braces with several lines of script inside them.
    These are the methods for our class, and they contain the operations that our
    component will support. They are a lot like standard JavaScript functions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向下移动时，我们会看到三个脚本块，它们有名称，后面跟着括号，然后是花括号，里面包含几行脚本。这些是我们类的方法，它们包含了我们组件将支持的操作。它们很像标准的JavaScript函数。
- en: The first of these methods is `constructor()`, which is a special method that
    will run when an instance of our component is first created. In our example, the
    constructor does only one thing when the class is created; it calls another method
    in our class, called `initializeGame()`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的第一个是`constructor()`，这是一个特殊的方法，当我们的组件实例首次创建时将运行。在我们的例子中，构造函数在类创建时只做了一件事；它调用了我们类中的另一个方法，叫做`initializeGame()`。
- en: The `initializeGame()` method sets the starting values of the four properties
    in the class using the assignment operator `=`. We set these values to `null`
    or `zero`, except for `original`, in which we use a random number generator to
    create the number to be guessed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`initializeGame()`方法使用赋值运算符`=`来设置类中四个属性的起始值。我们将这些值设置为`null`或`zero`，除了`original`，我们使用随机数生成器来创建要猜测的数字。'
- en: The class holds one more method called `verifyGuess()`, which updates the `deviation`
    and `noOfTries` properties. This method is not being called from within the component
    class; instead, it will be called from the view, as we will see when we examine
    the view more closely later. You'll also notice that our methods refer to properties
    in the same class by prepending `this` to them.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 该类还包含一个名为`verifyGuess()`的方法，它更新了`deviation`和`noOfTries`属性。这个方法不是从组件类内部调用的；相反，它将从视图中调用，我们稍后在更仔细地检查视图时会看到。您还会注意到我们的方法通过在属性前加上`this`来引用同一类中的属性。
- en: The module file
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块文件
- en: As we mentioned earlier, every Angular component must be contained within an
    Angular module. This means that at a minimum we must add at least one Angular
    module file to the root of our application. We call this the **root module**.
    For a simple application like Guess the Number!, the root module may be the only
    module we will need. However, as an Angular application increases in size, it
    will often make sense to have multiple Angular module files broken down by features.
    We will cover that situation as we move into building more complex applications
    in later chapters in this book.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，每个Angular组件必须包含在一个Angular模块中。这意味着至少我们必须在应用程序的根目录中添加至少一个Angular模块文件。我们称之为**根模块**。对于像Guess
    the Number!这样的简单应用程序，根模块可能是我们唯一需要的模块。然而，随着Angular应用程序的规模增大，通常会有多个按功能拆分的Angular模块文件是有意义的。随着我们在本书的后续章节中构建更复杂的应用程序，我们将涵盖这种情况。
- en: 'Let''s go ahead and create our Angular module file. First, create a new file
    named `app.module.ts` in the same directory as `guess-the-number.component.ts`
    and add the following code to it:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建我们的Angular模块文件。首先，在与`guess-the-number.component.ts`相同的目录中创建一个名为`app.module.ts`的新文件，并将以下代码添加到其中：
- en: '[PRE7]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first two statements import `NgModule` and `BrowserModule`. Notice that,
    while `NgModule` is being imported from `@angular/core`, `BrowserModule` is being
    imported from a different module: `@angular/platform-browser`. What''s significant
    here is that the import is not coming from `@angular/core` but from a separate
    module that is specific to browser-based applications. This is a reminder that
    Angular can support devices other than browsers, such as mobile devices, hence
    the need to place `BrowserModule` into a separate module.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个语句导入了`NgModule`和`BrowserModule`。请注意，虽然`NgModule`是从`@angular/core`导入的，但`BrowserModule`是从不同的模块`@angular/platform-browser`导入的。这里重要的是导入不是来自`@angular/core`，而是来自一个特定于基于浏览器的应用程序的单独模块。这提醒我们Angular可以支持除浏览器之外的设备，比如移动设备，因此需要将`BrowserModule`放入一个单独的模块中。
- en: The other import in this file is our component `GuessTheNumberComponent`, which
    we just built. If you go back to that component you will notice that we added
    `export` in front of the class definition, which means we are using module loading
    within our own application.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件中的另一个导入是我们刚刚构建的组件`GuessTheNumberComponent`。如果你回到那个组件，你会注意到我们在类定义前面添加了`export`，这意味着我们在我们自己的应用程序中使用模块加载。
- en: 'We next define a new component `AppModule`. This component looks different
    from `GuessTheNumberComponent`, which we just defined. There is nothing in the
    class itself other than a few imports and a decorator: `@ngModule`. We can use
    this decorator to configure the module in our application. We first add imports,
    which in this case include the `BrowserModule`. As the name suggests, this module
    will provide the functionality needed to run our application in a browser. The
    next property is declarations and with that property we provide an array of the
    components that will be used in our application. In this case, we have just one
    component: `GuessTheNumberComponent`.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们定义一个新的组件`AppModule`。这个组件看起来不同于我们刚刚定义的`GuessTheNumberComponent`。在类本身中除了一些导入和一个装饰器`@ngModule`之外没有任何东西。我们可以使用这个装饰器来配置我们应用程序中的模块。我们首先添加导入，这种情况下包括`BrowserModule`。顾名思义，这个模块将提供在浏览器中运行我们应用程序所需的功能。下一个属性是声明，通过这个属性，我们提供了一个将在我们应用程序中使用的组件数组。在这种情况下，我们只有一个组件：`GuessTheNumberComponent`。
- en: Finally, we set the `bootstrap` property. This indicates the first component
    that will be loaded when our application starts up. Again this is the `GuessTheNumberComponent`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们设置了`bootstrap`属性。这表示我们应用程序启动时将加载的第一个组件。同样，这是`GuessTheNumberComponent`。
- en: With this configuration in place, we are now ready to bootstrap our component.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个配置，我们现在可以准备启动我们的组件了。
- en: Bootstrapping
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引导
- en: The class definition for `GuessTheNumberComponent` operates as a blueprint for
    the component, but the script inside it does not run until we have created an
    instance of the component. In order to run our application then, we need something
    in our application that creates this instance. The process of doing that requires
    us to add code that bootstraps our component.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`GuessTheNumberComponent`的类定义作为组件的蓝图，但其中的脚本在我们创建组件实例之前不会运行。因此，为了运行我们的应用程序，我们需要在应用程序中添加一些内容来创建这个实例。这个过程需要我们添加引导我们组件的代码。'
- en: 'In the `app` subdirectory, create another file named `main.ts` and add the
    following code to it:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app`子目录中，创建另一个名为`main.ts`的文件，并添加以下代码：
- en: '[PRE8]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, we are first importing the `platformBrowserDynamic` module from
    `@angular/platform-browser-dynamic`. Like the import of `BrowseModule` in the
    `appModule` file, this import is specifically for browser-based applications.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们首先从`@angular/platform-browser-dynamic`中导入了`platformBrowserDynamic`模块。就像在`appModule`文件中导入`BrowseModule`一样，这个导入是专门用于基于浏览器的应用程序的。
- en: Next we add an import of our `AppModule`, which we have just defined.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加了我们刚刚定义的`AppModule`的导入。
- en: 'Finally, we assign `platformBrowserDynamic()`, which we just imported, to a
    constant: platform. Then we call its `bootstrapModule` method with our `AppModule`
    as a parameter. The `bootstrapModule` method then creates a new instance of our
    `AppModule` component, which in turn initializes our `GuessTheNumberComponent`,
    which we have marked as the component to bootstrap. It does that by calling the
    component''s constructor method and setting the starting values for our game.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将刚刚导入的`platformBrowserDynamic()`赋值给一个常量：platform。然后我们调用它的`bootstrapModule`方法，并将我们的`AppModule`作为参数。`bootstrapModule`方法然后创建了`AppModule`组件的一个新实例，然后初始化了我们的`GuessTheNumberComponent`，我们标记为要启动的组件。它通过调用组件的构造方法并设置我们游戏的初始值来实现这一点。
- en: We will discuss in greater detail how this `bootstrap` method fits into the
    entire process of app initialization a little later in this chapter.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章稍后更详细地讨论`bootstrap`方法如何适应整个应用程序初始化过程。
- en: We're up-and-running!
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们已经开始运行了！
- en: 'Well, the app is complete and ready to be tested! Navigate to the directory
    where the file is located and type this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，应用程序已经完成并准备好进行测试！转到文件所在的目录并输入以下内容：
- en: '[PRE9]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The app should appear on your browser.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序应该出现在您的浏览器上。
- en: Note
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are having trouble running the app, you can check out a working version
    available on GitHub at [https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample). If
    you are not using Git, download the snapshot of Checkpoint 1.1 (a ZIP file) from
    the following GitHub location: [https://github.com/chandermani/angular2byexample/tree/checkpoint1.1](https://github.com/chandermani/angular2byexample/tree/checkpoint1.1).
    Refer to the `readme.md` file in the `guessthenumber` folder when setting up the
    snapshot for the first time.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在运行应用程序时遇到问题，可以在GitHub上查看可用的工作版本[https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample)。如果您不使用Git，请从以下GitHub位置下载Checkpoint
    1.1的快照（ZIP文件）：[https://github.com/chandermani/angular2byexample/tree/checkpoint1.1](https://github.com/chandermani/angular2byexample/tree/checkpoint1.1)。在首次设置快照时，请参考`guessthenumber`文件夹中的`readme.md`文件。
- en: If we glance at our component file now, we should be mightily impressed with
    what we have achieved with these 43 lines. We are not writing any code to update
    the UI when the application is running. Still, everything works perfectly.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在查看我们的组件文件，我们应该对我们用这43行代码实现的成果感到非常印象深刻。当应用程序正在运行时，我们没有编写任何代码来更新UI。但一切都运行得很完美。
- en: Digging deeper
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入挖掘
- en: To understand how this app functions in the Angular context, we need to delve
    a little deeper into our component. While the class definition in the component
    is pretty simple and straightforward, we need to look more closely at the HTML
    in the template that is inside the `@Component` decorator to understand how Angular
    is working here. It looks like standard HTML with some new symbols, such as `[
    ]`, `( )`, `{{`, and `}}`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这个应用程序在Angular上下文中的功能，我们需要更深入地研究我们的组件。虽然组件中的类定义非常简单和直接，但我们需要更仔细地查看模板中的HTML，该HTML位于`@Component`装饰器内，以了解Angular在这里的工作原理。它看起来像标准的HTML，但有一些新的符号，比如`[
    ]`、`( )`、`{{`和`}}`。
- en: 'In the Angular world, these symbols mean the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular世界中，这些符号的含义如下：
- en: '`{{` and `}}` are interpolation symbols'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{`和`}}`是插值符号'
- en: '`[ ]` represents property bindings'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ ]`表示属性绑定'
- en: '`( )` represents event bindings'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( )`表示事件绑定'
- en: Clearly, these symbols have some behavior attached to them and seem to be linking
    the view HTML and component code. Let's try to understand what these symbols actually
    do.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这些符号具有一些与它们相关的行为，并且似乎将视图HTML和组件代码联系起来。让我们试着理解这些符号实际上是做什么的。
- en: Interpolation
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插值
- en: 'Look at this HTML fragment from the Guess the Number! code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下猜数字游戏代码中的这个HTML片段：
- en: '[PRE10]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The term `noOfTries` is sandwiched between two interpolation symbols. Interpolation
    works by replacing the content of the interpolation markup with the value of the
    expression (`noOfTries`) inside the interpolation symbol. In this case, `noOfTries`
    is the name of a component property. So the value of the component property will
    be displayed as the contents inside the interpolation tags.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 术语`noOfTries`被夹在两个插值符号之间。插值通过用插值标记的内容替换插值符号内部的表达式（`noOfTries`）的值来工作。在这种情况下，`noOfTries`是组件属性的名称。因此，组件属性的值将显示为插值标记内的内容。
- en: 'Interpolations are declared using this syntax: `{{expression}}`. This expression
    looks similar to a JavaScript expression but is always evaluated in the context
    of the component. Notice that we did not do anything to pass the value of the
    property to the view. Instead, the interpolation tags read the value of the property
    directly from the component without any need for additional code.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 插值使用以下语法声明：`{{expression}}`。这个表达式看起来类似于JavaScript表达式，但始终在组件的上下文中进行评估。请注意，我们没有做任何事情来将属性的值传递给视图。相反，插值标签直接从组件中读取属性的值，而无需额外的代码。
- en: Tracking changes in the number of tries
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪尝试次数的更改
- en: 'Another interesting aspect of interpolation is that changes made to component
    properties are automatically synchronized with the view. Run the app and make
    some guesses; the `noOfTries` value changes after every guess and so does the
    view content:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 插值的另一个有趣方面是，对组件属性的更改会自动与视图同步。运行应用程序并猜测一些东西；每次猜测后，`noOfTries`的值都会更改，视图内容也会更改：
- en: '![Tracking changes in the number of tries](../Images/image00432.jpeg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![跟踪尝试次数的更改](../Images/image00432.jpeg)'
- en: Interpolation is an excellent debugging tool in scenarios where we need to see
    the state of the model. With interpolation, we don't have to put a breakpoint
    in code just to know the value of a component property. Since interpolation can
    take an expression, we can pass a component's method call or a property and see
    its value.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 插值是在需要查看模型状态的情况下的一个很好的调试工具。通过插值，我们不必在代码中设置断点，就可以知道组件属性的值。由于插值可以接受一个表达式，我们可以传递一个组件的方法调用或属性，并查看其值。
- en: Expressions
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式
- en: Before going any further, we need to spend a few moments understanding what
    template expressions are in Angular.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要花一些时间了解Angular中的模板表达式是什么。
- en: 'Template expressions in Angular are nothing but pieces of plain JavaScript
    code that are evaluated in the context of the component instance associated with
    the template instance in which they are used. But as the documentation at [https://angular.io/docs/ts/latest/guide/template-syntax.html#template-expressions](https://angular.io/docs/ts/latest/guide/template-syntax.html#template-expressions) makes
    it clear, there are some differences:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，模板表达式只是一些普通的JavaScript代码片段，在与它们一起使用的模板实例相关联的组件实例的上下文中进行评估。但正如[https://angular.io/docs/ts/latest/guide/template-syntax.html#template-expressions](https://angular.io/docs/ts/latest/guide/template-syntax.html#template-expressions)的文档所澄清的那样，存在一些差异：
- en: Assignment is prohibited, except in event bindings
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了在事件绑定中，不允许赋值
- en: The new operator is prohibited
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁止使用new运算符
- en: The bitwise operators `|` and `&` are not supported
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持位运算符`|`和`&`
- en: Increment and decrement operators, `++` and `--`, aren't supported
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持递增和递减运算符`++`和`--`
- en: Template expression operators, such as `|` and `?.` add new meanings
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板表达式运算符，如`|`和`?.`添加了新的含义
- en: 'In the light of our discussion on component-based design, you probably won''t
    be surprised to learn that the documentation also makes some more things clear;
    template expressions cannot:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们对基于组件的设计的讨论，你可能不会感到惊讶地了解，文档还澄清了一些更多的事情；模板表达式不能：
- en: Refer to anything in the global namespace
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用全局命名空间中的任何内容
- en: Refer to a window or document
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用窗口或文档
- en: Call `console.log`
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`console.log`
- en: Instead, these expressions are confined to the expression context, which is
    typically the component instance supporting a particular template instance.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，这些表达式被限制在表达式上下文中，通常是支持特定模板实例的组件实例。
- en: 'However, these limitations do not stop us from doing some nifty stuff with
    expressions. As we can see in the following examples, these all are valid expressions:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些限制并不妨碍我们用表达式做一些巧妙的事情。正如我们在以下示例中所看到的，这些都是有效的表达式：
- en: '[PRE11]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Having looked into expressions, we strongly advise you to keep your expressions
    simple, thus keeping the HTML readable. The `*ngIf="formHasErrors()"` expression
    is always better than `*` `ng-if="name==null || email==null || emailformatInValid(email)
    || age < 18"`. So, when an expression starts to become complex, move it into a
    method in your component.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究表达式之后，我们强烈建议您保持表达式简单，从而保持HTML的可读性。`*ngIf="formHasErrors()"`表达式总是比`*` `ng-if="name==null
    || email==null || emailformatInValid(email) || age < 18"`更好。因此，当一个表达式开始变得复杂时，将其移到组件中的一个方法中。
- en: The safe navigation operator
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全导航运算符
- en: 'Before we move on there is one other expression that we should touch on: the
    Angular safe navigation operator (`?.`). This operator provides a convenient way
    to check for null values in lengthy property paths like so:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，还有一个表达式我们应该提及：Angular安全导航运算符(`?.`)。这个运算符提供了一种方便的方式来检查冗长的属性路径中的空值，如下所示：
- en: '[PRE12]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If the safe navigation operator finds a null value (here the customer), it stops
    processing the path but lets the application continue running. Without it, the
    application will crash when it reaches anything after the first null (here the
    customer name) and the view will not display. The safe navigation operator is
    especially helpful in situations where you are loading data asynchronously and
    it might not be immediately available to the view. The safe navigation operator
    will prevent the application from crashing and then load the data when it is available.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安全导航运算符发现了一个空值（这里是customer），它会停止处理路径，但让应用程序继续运行。如果没有它，应用程序将在到达第一个空值之后的任何地方崩溃（这里是customer
    name），并且视图将不会显示。安全导航运算符在异步加载数据并且可能不会立即可用于视图的情况下特别有帮助。安全导航运算符将防止应用程序崩溃，然后在数据可用时加载数据。
- en: Data binding
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据绑定
- en: Learning interpolation and expressions was easy; now let's look at another framework
    construct that is being used by our sample app-data binding. We will be covering
    data binding in far more detail in the upcoming chapters. At this point, we will
    just touch briefly on the bindings that are used in the sample app we are building.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 学习插值和表达式很容易；现在让我们来看看另一个框架构造，即我们的示例应用程序数据绑定所使用的。我们将在接下来的章节中更详细地介绍数据绑定。在这一点上，我们只会简要涉及我们正在构建的示例应用程序中使用的绑定。
- en: Property binding
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性绑定
- en: If we look through the HTML for the view, we will see several places where square
    brackets `[ ]` are used. These are **property bindings**.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看视图的HTML，我们会看到有几个地方使用了方括号`[ ]`。这些是**属性绑定**。
- en: 'Let''s look at the first of the bindings that we created:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们创建的第一个绑定：
- en: '[PRE13]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This binding works by linking the value of the `guess` property in our component
    class to the `value` of the input field in the view. The binding is dynamic; so,
    as the value of the `guess` property changes, the `value` of the input field will
    be synchronized to the same value. And, we do not have to write any code to do
    that.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这种绑定通过将组件类中的`guess`属性的值与视图中输入字段的`value`链接起来。绑定是动态的；因此，当`guess`属性的值发生变化时，输入字段的`value`将与相同的值同步。而且，我们不需要编写任何代码来实现这一点。
- en: At the outset, when we initialize the game, this property is set to null in
    the initialization method of the component class, so we will not see anything
    in the input field. However, as the game progresses, this number will be updated
    with the value of the guess as it changes.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，当我们初始化游戏时，这个属性在组件类的初始化方法中被设置为null，所以我们在输入字段中看不到任何东西。然而，随着游戏的进行，这个数字将随着猜测的值的变化而更新。
- en: Event binding
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件绑定
- en: Looking again at the HTML view, we find several places where parentheses `(
    )` appear. These are **event bindings**.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看 HTML 视图，我们会发现括号 `( )` 出现在几个地方。这些是 **事件绑定**。
- en: 'Let''s look at the HTML code line that we created for the first of these event
    bindings. It should be familiar since the event binding is on the same tag that
    we first looked at for property binding: the `input` tag:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下我们为第一个事件绑定创建的 HTML 代码行。这应该很熟悉，因为事件绑定在我们首先查看的属性绑定相同的标签上：`input` 标签：
- en: '[PRE14]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this case, the `input` event of the input element is bound to an expression.
    The expression sets the `guess` property in our component class to `$event.target.value`,
    which is the value being entered by the user. Behind the scenes, when we use this
    syntax, Angular sets up an event handler for the event that we are binding to.
    In this case, the handler updates the `guess` property in our component class
    whenever the user enters a number in the `input` field.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输入元素的 `input` 事件绑定到一个表达式。该表达式将我们组件类中的 `guess` 属性设置为 `$event.target.value`，这是用户输入的值。在幕后，当我们使用这种语法时，Angular
    为我们绑定的事件设置了一个事件处理程序。在这种情况下，处理程序在用户在 `input` 字段中输入数字时更新我们组件类中的 `guess` 属性。
- en: 'There are a couple of other places in your code where the `( )` parentheses
    appear:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的代码中还有一些地方出现了 `( )` 括号：
- en: '[PRE15]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These two event bindings tie the `click` events for the buttons on the screen
    to methods in our component. So in this case, behind the scenes, Angular sets
    up event handlers that bind directly to the methods in our component. When the
    **Verify** button is clicked, the `verifyGuess` method is called, and when the
    **Restart** button is clicked, the `initializeGame` method is called.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个事件绑定将屏幕上按钮的 `click` 事件与我们组件中的方法绑定在一起。因此，在这种情况下，Angular 在幕后设置了直接绑定到我们组件方法的事件处理程序。当单击
    **Verify** 按钮时，将调用 `verifyGuess` 方法，当单击 **Restart** 按钮时，将调用 `initializeGame` 方法。
- en: As you work through the samples in this book, you will see many places where
    the `[]` tags for property bindings are combined with the `()` tags for events.
    In fact, this pairing is so common that, as we will see later, Angular has come
    up with a shorthand syntax to combine these tags into one.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当您阅读本书中的示例时，您会看到许多地方，属性绑定的 `[]` 标签与事件的 `()` 标签结合在一起。事实上，这种配对是如此常见，以至于后面我们将看到，Angular
    提出了一种简化的语法来将这些标签合并为一个。
- en: Structural directives
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构指令
- en: 'Next, we''ll examine something that looks similar to data binding but incorporates
    an Angular feature we have haven''t seen before: **structural directives**:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将研究一些看起来类似于数据绑定但包含了我们以前没有见过的 Angular 特性：**结构指令**：
- en: '[PRE16]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`*ngIf` inside the `<p>` tags is the `NgIf` structural directive. Structural
    directives allow us to manipulate the structure of DOM elements. The `NgIf` directive
    removes or adds DOM elements based on the result of an expression that is assigned
    to it.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`<p>` 标签中的 `*ngIf` 是 `NgIf` 结构指令。结构指令允许我们操纵 DOM 元素的结构。`NgIf` 指令根据分配给它的表达式的结果来删除或添加
    DOM 元素。'
- en: Note
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The asterisk `*` in front of `ngIf` is a simplified syntax that Angular, under
    the hood, expands into an HTML5 `<template>`. We'll be learning a lot more about
    this syntax and about structural directives in the next chapter.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngIf` 前面的星号 `*` 是 Angular 在幕后扩展为 HTML5 `<template>` 的简化语法。在下一章中，我们将学习更多关于这种语法和结构指令的知识。'
- en: In this case we are using `NgIf` with a simple expression, similar to the types
    of expression we saw with interpolation. The expression resolves to either `true`
    or `false` based on the value of the guess being made and its relation (higher,
    lower, or equal) to the correct number. It then assigns that result to `NgIf`,
    which will either add the DOM element if the result is `true` or remove it if
    it is `false`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在使用`NgIf`与一个简单的表达式，类似于我们在插值中看到的类型的表达式。该表达式根据所做的猜测的值及其与正确数字的关系（更高、更低或相等）解析为`true`或`false`。然后将该结果分配给`NgIf`，如果结果为`true`，则将添加DOM元素，如果为`false`，则将删除DOM元素。
- en: Revisiting our app
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视我们的应用
- en: 'So now that we have looked more closely at what makes up our view, let''s take
    another look at our app when it is up-and-running. When we run our app, Angular
    binding starts up once the browser has rendered the raw HTML in our view. The
    framework then compiles this view template and, in the process, sets up the necessary
    binding. Next, it does the necessary synchronization between our component class
    and the view template that produces the final rendered output. The following screenshot
    depicts the transformations that happen to the view template after data binding
    is done for our app:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们更仔细地看了一下构成我们视图的内容，让我们再次看看我们的应用程序在运行时的情况。当我们运行应用程序时，一旦浏览器渲染了我们视图中的原始HTML，Angular绑定就会启动。然后，框架编译这个视图模板，并在这个过程中设置必要的绑定。接下来，它在组件类和生成最终渲染输出的视图模板之间进行必要的同步。以下屏幕截图描述了在我们的应用程序的数据绑定完成后视图模板发生的转换。
- en: '![Revisiting our app](../Images/image00429.jpeg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![重新审视我们的应用](../Images/image00429.jpeg)'
- en: We can ourselves see the untransformed view template of the app (what is shown
    on the left-hand side of the preceding screenshot) by removing the three `*ngIf` directives
    and the expressions assigned to them from the paragraphs below the input box and
    refreshing the app in the browser.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过从输入框下面的段落中删除三个`*ngIf`指令和分配给它们的表达式，并在浏览器中刷新应用程序，来看到应用程序的未转换视图模板（即在前一个屏幕截图的左侧显示的内容）。
- en: Angular differs from other template frameworks, in that these bindings between
    a component and its view are live. Changes made to the properties of the component
    update the view. Angular never regenerates the HTML; it just works on the relevant
    part of the HTML and updates only the HTML elements that need to change as component
    properties change. This data binding capability makes Angular an exceptional view
    templating engine too.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Angular与其他模板框架不同，因为组件与其视图之间的这些绑定是实时的。对组件属性的更改会更新视图。Angular从不重新生成HTML；它只是处理HTML的相关部分，并且仅在组件属性更改时更新需要更改的HTML元素。这种数据绑定能力也使Angular成为一个出色的视图模板引擎。
- en: Looking at how our code handles updates
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看我们的代码如何处理更新
- en: If we go back and look at the code for our class, we will see that the properties
    and methods in the class do not directly reference the view. Instead, the methods
    simply operate on the properties in the class. As a consequence, the code for
    our class is more readable, hence more maintainable (and of course, testable).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回过头来看看我们类的代码，我们会发现类中的属性和方法并没有直接引用视图。相反，方法只是在类中的属性上操作。因此，我们类的代码更易读，因此更易维护（当然也更易测试）。
- en: '![Looking at how our code handles updates](../Images/image00433.jpeg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![查看我们的代码如何处理更新](../Images/image00433.jpeg)'
- en: So far, we have discussed how Angular updates the view based on changes in a
    component's properties. This is an important concept to understand as it can save
    us from countless hours of debugging and frustration. The next section is dedicated
    to learning about change detection and how these updates are managed.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了Angular如何根据组件属性的变化更新视图。这是一个重要的概念，因为它可以帮助我们节省无数小时的调试和挫折。接下来的部分将专门学习变化检测以及如何管理这些更新。
- en: Maintaining the state
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维护状态
- en: First, let's look at how we maintain the state in our Angular application. Since
    Angular apps are dynamic and not static, we need to understand the mechanisms
    that are used to make sure that these dynamic values are kept up-to-date as the
    data in an application gets updated. For example, in our application, how does
    the number of guesses get updated on the screen? How does the application decide
    to display the correct message about whether the guess is correct based on the
    user input?
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何在我们的Angular应用中维护状态。由于Angular应用是动态的而不是静态的，我们需要了解用于确保这些动态值随着应用程序中的数据更新而保持最新的机制。例如，在我们的应用程序中，屏幕上的猜测次数如何更新？应用程序如何决定根据用户输入显示关于猜测是否正确的正确消息？
- en: Component as the container for the state
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件作为状态的容器
- en: Since we have been emphasizing so far that Angular uses the component design
    pattern, you will probably not be surprised to know that the basic container for
    the application state is the component itself. This means that when we have a
    component instance, all the properties in the component and their values are available
    for the template instance that is referenced in the component. At a practical
    level, this means that we can use these values directly in expressions and bindings
    in the template without having to write any plumbing code to wire them up.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们一直强调Angular使用组件设计模式，你可能不会感到惊讶，基本的应用状态容器就是组件本身。这意味着当我们有一个组件实例时，组件中的所有属性及其值都可以在模板实例中使用，而模板实例是在组件中引用的。在实际层面上，这意味着我们可以直接在模板中使用这些值，而不需要编写任何连接它们的代码。
- en: 'In the sample app, for example, to determine what message to display, we can
    use `deviation` directly in the template expression. Angular will scan our component
    to find a property with that name and use its value. The same is true for `noOfTries`;
    Angular will look for the value of this property within our component and then
    use it to set its value in the interpolation within the template. We don''t have
    to write any other code:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在示例应用中，为了确定要显示的消息，我们可以直接在模板表达式中使用`deviation`。Angular将扫描我们的组件以找到具有该名称的属性，并使用其值。对于`noOfTries`也是如此；Angular将在我们的组件中查找此属性的值，然后将其用于在模板中的插值中设置其值。我们不需要编写任何其他代码：
- en: '[PRE17]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Change detection
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变化检测
- en: So how does Angular keep track of changes in our component as it runs? So far,
    it appears as if this is all done by magic. We just set up our component properties
    and methods, and then we bind them to the view using interpolation along with
    property and event binding. Angular does the rest!
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Angular在运行时如何跟踪组件的变化呢？到目前为止，似乎这一切都是由魔术完成的。我们只需设置组件的属性和方法，然后使用插值以及属性和事件绑定将它们绑定到视图中。Angular会处理剩下的事情！
- en: But this does not happen by magic, of course, and in order to make effective
    use of Angular, you need to understand how it updates these values as they change.
    This is called **change detection**, and Angular has a very different approach
    to doing this than what previously existed.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是魔术，为了有效地使用Angular，你需要了解它如何在值发生变化时更新这些值。这被称为**变化检测**，Angular在这方面的处理方式与以前存在的方式非常不同。
- en: 'If you use the debugger tool in your browser to walk through the application,
    you will see how change detection works. Here, we are using Chrome''s developer
    tools and setting a watch for the `noOfTries` property. If you place a breakpoint
    at the end of the `verifyGuess()` method, you will see that when you enter a guess,
    the `noOfTries` property is first updated as soon as you hit the breakpoint, like
    this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在浏览器中使用调试工具来浏览应用程序，你会看到变更检测是如何工作的。在这里，我们使用Chrome的开发者工具，并设置了一个对`noOfTries`属性的监视。如果你在`verifyGuess()`方法的末尾设置一个断点，你会看到当你输入一个猜测时，`noOfTries`属性会在你触发断点时首先更新，就像这样：
- en: '![Change detection](../Images/image00434.jpeg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![变更检测](../Images/image00434.jpeg)'
- en: 'Once you move past the breakpoint, the display on the screen updates with the
    correct number of guesses, as seen in the following screenshot:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你移过断点，屏幕上的显示会更新为正确的猜测次数，如下面的截图所示：
- en: '![Change detection](../Images/image00435.jpeg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![变更检测](../Images/image00435.jpeg)'
- en: What is really going on under the hood is that Angular is reacting to events
    in the application and using change detectors, which go through every component
    to determine whether anything has changed that affects the view. In this case,
    the event is a button click. The event generated by the button click calls the
    `verifyGuess()` method on the component that updates the `noOfTries` property.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在幕后发生的是Angular对应用程序中的事件做出反应，并使用变更检测器，它会遍历每个组件，以确定是否有任何影响视图的变化。在这种情况下，事件是按钮点击。按钮点击生成的事件调用了组件上的`verifyGuess()`方法，更新了`noOfTries`属性。
- en: That event triggers the change detection cycle, which identifies that the `noOfTries`
    property that is being used in the view has changed. As a result, Angular updates
    the element in the view that is bound to `noOfTries` with the new value of that
    property.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 该事件触发了变更检测循环，该循环确定了在视图中使用的`noOfTries`属性已经发生了变化。因此，Angular会使用该属性的新值更新与`noOfTries`绑定的视图中的元素。
- en: As you can see, this is a multistep process where Angular first updates the
    components and domain objects in response to an event, then runs change detection,
    and finally rerenders elements in the view that have changed. And, it does this
    on every browser event (as well as other asynchronous events, such as XHR requests
    and timers). Change detection in Angular is reactive and one way.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这是一个多步骤的过程，Angular首先在响应事件时更新组件和领域对象，然后运行变更检测，最后重新渲染视图中已更改的元素。而且，它会在每个浏览器事件（以及其他异步事件，如XHR请求和计时器）上执行此操作。Angular中的变更检测是反应式的，是单向的。
- en: This approach allows Angular to make just one pass through the change detection
    graph. It is called **one-way data binding**, and it vastly improves the performance
    of Angular.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使得Angular只需通过一次变更检测图。这被称为**单向数据绑定**，它极大地提高了Angular的性能。
- en: Note
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We'll be covering Angular change detection in depth in [Chapter 8](part0080.xhtml#2C9D01-edca168d36254bda8a21f611a95615c3
    "Chapter 8.  Some Practical Scenarios"), *Some Practical Scenarios*. For a description
    of this process by the Angular team, visit [https://vsavkin.com/two-phases-of-angular-2-applications-fda2517604be#.fabhc0ynb](https://vsavkin.com/two-phases-of-angular-2-applications-fda2517604be#.fabhc0ynb).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第8章](part0080.xhtml#2C9D01-edca168d36254bda8a21f611a95615c3 "第8章。一些实际场景")*一些实际场景*中深入讨论Angular变更检测。有关Angular团队对此过程的描述，请访问[https://vsavkin.com/two-phases-of-angular-2-applications-fda2517604be#.fabhc0ynb](https://vsavkin.com/two-phases-of-angular-2-applications-fda2517604be#.fabhc0ynb)。
- en: Initializing the app
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化应用程序
- en: We touched on app initialization earlier when we created the `app.module.ts`
    and `main.ts` files. The first file wraps our application in a module and the
    second file bootstraps that module. Now we will take a more detailed look at the
    initialization process.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在创建`app.module.ts`和`main.ts`文件时已经涉及了应用程序初始化。第一个文件将我们的应用程序封装在一个模块中，而第二个文件则引导该模块。现在我们将更详细地了解初始化过程。
- en: Loading the modules needed by our application
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载应用程序所需的模块
- en: 'Let''s go back to the `index.html` page again and take a look at the following
    script tags on this page:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次回到`index.html`页面，看一下该页面上的以下脚本标签：
- en: '[PRE18]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first tag indicates that we will be using a JavaScript library called SystemJS
    in our application. The second tag references a file within our application that
    sets the configuration for SystemJS.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个标签表示我们将在我们的应用程序中使用一个名为SystemJS的JavaScript库。第二个标签引用了我们应用程序中设置SystemJS配置的文件。
- en: As we mentioned earlier, ES2015 introduced a new syntax for module loading.
    One attractive feature of ES2015 module loading syntax is that it allows for modules
    to be loaded selectively and asynchronously. We will be using module loading throughout
    our application.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，ES2015引入了一个新的模块加载语法。ES2015模块加载语法的一个吸引人的特性是它允许模块被选择性地和异步地加载。我们将在整个应用程序中使用模块加载。
- en: 'TypeScript supports the ES2015 module loading syntax, and SystemJS allows us
    to add module loading to applications that run ES5\. Putting the two together:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript支持ES2015模块加载语法，而SystemJS允许我们向运行ES5的应用程序添加模块加载。将两者结合起来：
- en: TypeScript will transpile (compile) our application's components to ES5
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript将我们应用程序的组件转译（编译）为ES5
- en: SystemJS will load them as ES5 modules
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SystemJS将它们作为ES5模块加载
- en: As part of this process, each of our TypeScript files will be compiled to a
    SystemJS module. SystemJS will then load all the related dependencies and when
    requested the module itself.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个过程的一部分，我们的每个TypeScript文件都将被编译为一个SystemJS模块。SystemJS然后将加载所有相关的依赖项，并在请求模块本身时加载它们。
- en: Note
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Other module loaders exist, including Webpack, so you are not limited in your
    choice of module loaders to SystemJS. For more information on using Webpack with
    Angular refer to the following documentation on the Angular site: [https://angular.io/docs/ts/latest/guide/webpack.html](https://angular.io/docs/ts/latest/guide/webpack.html).'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他模块加载器，包括Webpack，因此您在选择模块加载器时并不受限于SystemJS。有关在Angular中使用Webpack的更多信息，请参阅Angular网站上的以下文档：[https://angular.io/docs/ts/latest/guide/webpack.html](https://angular.io/docs/ts/latest/guide/webpack.html)。
- en: 'Open `systemjs.config.js`. You will see that it contains mappings that indicate
    where SystemJS should look for the files that are needed in our application:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`systemjs.config.js`。您会看到它包含的映射，指示SystemJS应该在哪里查找我们应用程序中需要的文件：
- en: '[PRE19]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First, we map our own application, app, to the directory in which it resides.
    Then we add mappings for RxJS and several Angular modules. They are being downloaded
    from a **content delivery network** (**CDN**), the **Node Package Manager** ([https://unpkg.com/#/](https://unpkg.com/#/))
    CDN. As you can see, we are using the `@` notation with the Angular modules. As
    we mentioned before, this means we will be importing Angular barrels containing
    multiple modules.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将我们自己的应用程序`app`映射到它所在的目录。然后我们为RxJS和几个Angular模块添加映射。它们是从**内容传送网络**（**CDN**）的**Node
    Package Manager**（[https://unpkg.com/#/](https://unpkg.com/#/)）CDN下载的。正如您所看到的，我们在Angular模块中使用了`@`符号。正如我们之前提到的，这意味着我们将导入包含多个模块的Angular桶。
- en: Note
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The module bundles that Angular identifies as barrels are referred to as scoped
    packages in NPM. For a description of how Angular is using NPM scoped packages,
    visit [https://www.reddit.com/r/Angular2/comments/4hk0f8/the_angular2_team_is_changing_the_repository_on/](https://www.reddit.com/r/Angular2/comments/4hk0f8/the_angular2_team_is_changing_the_repository_on/).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Angular标识为barrels的模块捆绑包在NPM中被称为作用域包。有关Angular如何使用NPM作用域包的描述，请访问[https://www.reddit.com/r/Angular2/comments/4hk0f8/the_angular2_team_is_changing_the_repository_on/](https://www.reddit.com/r/Angular2/comments/4hk0f8/the_angular2_team_is_changing_the_repository_on/)。
- en: 'Next, we identify the packages that we will be importing and their main entry
    points. In the case of our `app` package, we indicate that `main.ts` will be the
    entry point and `ts` will be the default extension since we are using TypeScript
    for it. Then we identify the specific Angular `@barrels` that we will be using
    in our application:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们确定要导入的包及其主要入口点。在我们的`app`包的情况下，我们指出`main.ts`将是入口点，`ts`将是默认扩展名，因为我们在其中使用TypeScript。然后我们确定我们将在应用程序中使用的特定Angular
    `@barrels`：
- en: '[PRE20]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These packages will be all we need to run our application. As you move to more
    sophisticated applications, more packages will be required. But you only need
    to add what is required to get the application running and this is what we are
    doing here. The flexibility to select just the packages that you need helps to
    minimize the size of the download, always a good thing for performance.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包将是我们运行应用程序所需的全部内容。当您转向更复杂的应用程序时，将需要更多的包。但您只需要添加所需的内容来运行应用程序，这就是我们在这里所做的。选择所需的包的灵活性有助于最小化下载大小，这对性能来说总是一件好事。
- en: 'The file also contains the following script that directs SystemJS to transpile
    our TypeScript files:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件还包含以下脚本，指示SystemJS转译我们的TypeScript文件：
- en: '[PRE21]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This script will transpile our TypeScript files in the browser, which we would
    typically not do in a production app. Also, in order to keep the setup of our
    application as simple as possible, we are downloading the Angular modules and
    other libraries on-the-fly as the browser loads. In a production application,
    we would move both these steps into a build process that takes place before the
    application is launched in the browser. This will reduce the download size of
    the application and improve performance. We will be exploring setting up such
    a build process in [Chapter 2](part0028.xhtml#QMFO1-edca168d36254bda8a21f611a95615c3
    "Chapter 2.  Building Our First App - 7 Minute Workout"), *Building Our First
    App – 7 Minute Workout*.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本将在浏览器中转译我们的TypeScript文件，这在生产应用中通常是不会做的。另外，为了尽可能简化我们应用程序的设置，我们会在浏览器加载时动态下载Angular模块和其他库。在生产应用中，我们会将这两个步骤移到应用程序在浏览器中启动之前进行的构建过程中。这将减少应用程序的下载大小并提高性能。我们将在[第2章](part0028.xhtml#QMFO1-edca168d36254bda8a21f611a95615c3
    "第2章。构建我们的第一个应用 - 7分钟锻炼")中探讨设置这样一个构建过程，*构建我们的第一个应用 - 7分钟锻炼*。
- en: 'We then implement the module loading for our app by adding the following script
    to our `index.html` file:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过将以下脚本添加到我们的`index.html`文件来实现我们应用程序的模块加载：
- en: '[PRE22]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The parameter being passed to our import statement `app` is the location of
    our application, which in this case is the `app` directory. Because we have indicated
    in `systemjs.config.js` that `main.ts` will be the entry point for our app, SystemJS
    will look for that file in the `app` directory when the application first starts.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给我们的导入语句`app`的参数是我们应用程序的位置，在这种情况下是`app`目录。因为我们在`systemjs.config.js`中指出`main.ts`将是我们应用程序的入口点，所以当应用程序首次启动时，SystemJS将在`app`目录中查找该文件。
- en: Bootstrapping our app
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动我们的应用程序
- en: 'The next step in the initialization process is to bootstrap our application.
    As the entry point for our app, `main.ts` does that by executing the following
    code:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化过程的下一步是引导我们的应用程序。作为我们应用程序的入口点，`main.ts`通过执行以下代码来实现这一点：
- en: '[PRE23]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Not surprisingly, we are bootstrapping `AppModule`. As we already know, bootstrapping
    instantiates `GuessTheNumberComponent` because it has been assigned to the bootstrap
    property within `AppModule`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，我们正在引导`AppModule`。正如我们已经知道的那样，引导实例化`GuessTheNumberComponent`，因为它已被分配给`AppModule`中的bootstrap属性。
- en: Note
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This makes `GuessTheNumberComponent` the root component for our application.
    While our app has only one component, every Angular application typically starts
    off with one root component.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这使`GuessTheNumberComponent`成为我们应用程序的根组件。虽然我们的应用程序只有一个组件，但每个Angular应用程序通常都从一个根组件开始。
- en: 'We identify where this component will appear using the following syntax in
    our `index.html` file:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下语法在我们的`index.html`文件中确定这个组件将出现在哪里：
- en: '[PRE24]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you might recall, the `@Component` decorator for our component identifies
    the component''s selector:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能记得的，我们组件的`@Component`装饰器标识了组件的选择器：
- en: '[PRE25]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Taken together, these indicate to Angular that when our page is loaded, it needs
    to bind our component to the `my-app` tag in `index.html`. Note that here we are
    using a custom element based on the Web Components standard.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 综上所述，这些指示Angular，当我们的页面加载时，需要将我们的组件绑定到`index.html`中的`my-app`标签。请注意，这里我们使用的是基于Web组件标准的自定义元素。
- en: 'So, this starts the bootstrapping process, which continues as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这启动了引导过程，其继续如下进行：
- en: Angular scans our component definition and imports the modules that we have
    identified in the `import` statement of our component along with its related dependencies.
    These are the modules that we discussed earlier.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular扫描我们的组件定义，并导入我们在组件的`import`语句中标识的模块以及其相关的依赖项。这些是我们之前讨论过的模块。
- en: It compiles the HTML view, starting from where the `my-app` tag is declared.
    In this compilation process, the framework traverses the template, looks for all
    interpolations, and sets up the binding between the view and our class.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它编译HTML视图，从`my-app`标签声明的位置开始。在这个编译过程中，框架遍历模板，查找所有的插值，并建立视图和我们的类之间的绑定。
- en: Post compilation, it links the view and our component class where changes are
    synced across the model and viewed in real time as we interact with the app.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译后，它将视图和我们的组件类链接起来，其中更改会在模型中同步，并在我们与应用程序交互时实时显示。
- en: Tools
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具
- en: 'Tools make our lives easy, and we are going to share some tools that will help
    you with different aspects of Angular development, from code writing to debugging:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 工具使我们的生活变得更加轻松，我们将分享一些工具，这些工具将帮助您处理Angular开发的不同方面，从编写代码到调试：
- en: '**Augury (**[https://augury.angular.io/](https://augury.angular.io/)**)**:
    This is a Chrome Dev Tools extension for debugging Angular applications. While
    the developers of the tool, rangle.io, indicate that it should be treated as a
    preview, it does support the Angular final release.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Augury (**[https://augury.angular.io/](https://augury.angular.io/)**)**：这是一个用于调试Angular应用程序的Chrome
    Dev Tools扩展。虽然该工具的开发者rangle.io指出它应该被视为预览版本，但它支持Angular的最终版本。'
- en: '**Browser developer console**: All current browsers have excellent capabilities
    when it comes to JavaScript debugging. Since we are working with JavaScript, we
    can put in breakpoints, add a watch, and do everything that is otherwise possible
    with JavaScript. Remember that a lot of errors with code can be detected just
    by looking at the browser''s console window.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浏览器开发者控制台**：所有当前的浏览器在JavaScript调试方面都有出色的能力。由于我们正在使用JavaScript，我们可以设置断点，添加监视，并进行一切在JavaScript中可能的操作。请记住，通过查看浏览器的控制台窗口，可以检测到很多代码错误。'
- en: '**JSFiddle and Plunker**: JSFiddle ([http://jsfiddle.net/](http://jsfiddle.net/))
    and Plunker ([http://plnkr.co/](http://plnkr.co/)) are excellent playgrounds for
    trying out HTML, CSS, and JavaScript code. These tools also have great versioning
    and sharing capabilities that can come in handy if we want someone''s help.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSFiddle和Plunker**：JSFiddle（[http://jsfiddle.net/](http://jsfiddle.net/)）和Plunker（[http://plnkr.co/](http://plnkr.co/)）是尝试HTML、CSS和JavaScript代码的绝佳平台。这些工具还具有出色的版本控制和共享功能，如果我们需要帮助，这些功能会很有用。'
- en: '**IDE extensions**: Many of the popular IDEs on the market have plugins/extensions
    that make Angular development easy for us. Examples include:'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IDE扩展**：市场上许多流行的IDE都有插件/扩展，使Angular开发变得更加容易。例如：'
- en: '**JetBrains WebStorm 2016:2.3**: [https://www.jetbrains.com/webstorm/](https://www.jetbrains.com/webstorm/).'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JetBrains WebStorm 2016:2.3**：[https://www.jetbrains.com/webstorm/](https://www.jetbrains.com/webstorm/).'
- en: '**Angular2 Snippets for Sublime Text**: [https://github.com/evanplaice/angular2-snippets](https://github.com/evanplaice/angular2-snippets).'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sublime Text的Angular2代码片段**：[https://github.com/evanplaice/angular2-snippets](https://github.com/evanplaice/angular2-snippets).'
- en: '**Atom Angular 2 Snippets and Completions**: [https://github.com/d3viant0ne/angular2-atom-snippets](https://github.com/d3viant0ne/angular2-atom-snippets).'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Atom Angular 2 Snippets and Completions: [https://github.com/d3viant0ne/angular2-atom-snippets](https://github.com/d3viant0ne/angular2-atom-snippets).'
- en: '**Visual Studio Code**: This is a brand new IDE that Microsoft has come up
    with ([https://code.visualstudio.com/](https://code.visualstudio.com/)). It provides
    excellent IntelliSense and code completion support for Angular and TypeScript.
    Visual Studio 2015 ([https://www.visualstudio.com/](https://www.visualstudio.com/))
    also includes support for Angular and TypeScript.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**：这是微软推出的全新IDE（[https://code.visualstudio.com/](https://code.visualstudio.com/)）。它为Angular和TypeScript提供了出色的IntelliSense和代码完成支持。Visual
    Studio 2015（[https://www.visualstudio.com/](https://www.visualstudio.com/)）也包括对Angular和TypeScript的支持。'
- en: The Angular community is also developing CLI tools ([https://cli.angular.io/](https://cli.angular.io/))
    with the goal of taking the developer from the initial project setup all the way
    to the final deployment. We'll cover using Angular CLI in [Chapter 8](part0080.xhtml#2C9D01-edca168d36254bda8a21f611a95615c3
    "Chapter 8.  Some Practical Scenarios"), *Some Practical Scenarios*.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular社区还在开发CLI工具（[https://cli.angular.io/](https://cli.angular.io/)），旨在将开发人员从初始项目设置一直带到最终部署。我们将在[第8章](part0080.xhtml#2C9D01-edca168d36254bda8a21f611a95615c3
    "Chapter 8.  Some Practical Scenarios")中介绍如何使用Angular CLI，*一些实际场景*。
- en: 'Component vendors are starting to offer support for Angular as well. For example,
    Telerik has released Kendo UI for Angular: [http://www.telerik.com/kendo-angular-ui/](http://www.telerik.com/kendo-angular-ui/).'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件供应商也开始为Angular提供支持。例如，Telerik发布了Kendo UI for Angular：[http://www.telerik.com/kendo-angular-ui/](http://www.telerik.com/kendo-angular-ui/)。
- en: Resources
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源
- en: 'Angular is a new framework, but already a vibrant community is starting to
    emerge around it. Together with this book, there are also blogs, articles, support
    forums, and plenty of help. Some of the prominent resources that will be useful
    are explained as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: Angular是一个新的框架，但已经开始形成一个充满活力的社区。除了本书之外，还有博客、文章、支持论坛和大量的帮助。以下是一些有用的主要资源的解释：
- en: '**Framework code and documentation**: The Angular documentation can be found
    at [https://angular.io/docs/js/latest/](https://angular.io/docs/js/latest/). The
    documentation is a work-in-progress and not fully finalized. Then, there is always
    the Angular source code, a great source of learning. It can be found at [https://github.com/angular/angular](https://github.com/angular/angular).'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**框架代码和文档**：Angular文档可以在[https://angular.io/docs/js/latest/](https://angular.io/docs/js/latest/)找到。文档还在不断完善中，尚未最终确定。此外，还有Angular源代码，是一个很好的学习资源。可以在[https://github.com/angular/angular](https://github.com/angular/angular)找到。'
- en: '**The Angular team''s blog**: You can refer to the Angular team''s blog for
    more information about Angular 2 at [http://angularjs.blogspot.com/](http://angularjs.blogspot.com/).'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular团队的博客**：您可以在Angular团队的博客上获取有关Angular 2的更多信息：[http://angularjs.blogspot.com/](http://angularjs.blogspot.com/)。'
- en: '**Awesome Angular: A curated list of awesome Angular resources**: This is a
    new community resource at [https://angularclass.github.io/awesome-angular2/](https://angularclass.github.io/awesome-angular2/).'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**令人敬畏的Angular：精选的令人敬畏的Angular资源列表**：这是一个新的社区资源，网址是[https://angularclass.github.io/awesome-angular2/](https://angularclass.github.io/awesome-angular2/)。'
- en: '**The Angular Slack channel (**[https://angularchat.co/](https://angularchat.co/)**)
    and the gitter chat room (**[https://gitter.im/angular/angular](https://gitter.im/angular/angular)**)**:
    These are other great resources. Also check out Angular on Reddit: [https://www.reddit.com/r/Angular2](https://www.reddit.com/r/Angular2).'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular Slack频道（**[https://angularchat.co/](https://angularchat.co/)**）和gitter聊天室（**[https://gitter.im/angular/angular](https://gitter.im/angular/angular)**）**：这些都是其他很好的资源。还可以在Reddit上查看Angular：[https://www.reddit.com/r/Angular2](https://www.reddit.com/r/Angular2)。'
- en: '**The Angular Google group (**[https://groups.google.com/forum/#!forum/angular](https://groups.google.com/forum/#!forum/angular)**)
    and the Stack Overflow channel (**[http://stackoverflow.com/questions/tagged/Angular2](http://stackoverflow.com/questions/tagged/Angular2)**)**:
    Head over here if you have any questions or are stuck with some issue.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular Google组（**[https://groups.google.com/forum/#!forum/angular](https://groups.google.com/forum/#!forum/angular)**）和Stack
    Overflow频道（**[http://stackoverflow.com/questions/tagged/Angular2](http://stackoverflow.com/questions/tagged/Angular2)**）**：如果您有任何问题或遇到了一些问题，请前往这里。'
- en: '**Built with Angular (**[http://builtwithangular2.com/](http://builtwithangular2.com/)**)**:
    People have already created some amazing apps using Angular. This site showcases
    such apps, and most of them have source code available for us to take a look at.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用Angular构建（**[http://builtwithangular2.com/](http://builtwithangular2.com/)**）**：人们已经使用Angular创建了一些令人惊叹的应用程序。这个网站展示了这些应用程序，其中大部分都有源代码可供我们查看。'
- en: That's it! The chapter is complete and it's time to summarize what you've learned.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！本章已经完成，现在是时候总结一下你学到了什么。
- en: Summary
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The journey has started and we have reached the first milestone. Despite this
    chapter being named *Getting Started*, we have covered a lot of concepts that
    you will need to know in order to understand the bigger picture. Your learning
    was derived from our Guess the Number! app, which we built and dissected throughout
    the chapter.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 旅程已经开始，我们已经达到了第一个里程碑。尽管这一章被命名为“入门”，但我们涵盖了许多概念，这些概念您需要了解以理解更大的画面。您的学习源自我们在整个章节中构建和解剖的“猜数字！”应用程序。
- en: You learned how Angular implements the component design pattern using the emerging
    standards for Web Components, along with the latest versions of JavaScript and
    TypeScript. We also reviewed some of the constructs that are used in Angular,
    such as interpolation, expressions, and the data binding syntax. Finally, we took
    a look at change detection and app initialization.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 您学习了Angular如何使用Web组件的新兴标准以及JavaScript和TypeScript的最新版本来实现组件设计模式。我们还回顾了Angular中使用的一些构造，比如插值、表达式和数据绑定语法。最后，我们还研究了变更检测和应用程序初始化。
- en: The groundwork has been laid, and now we are ready for some serious app development
    on the Angular framework. In the next chapter, we will start working on a more
    complex exercise and expose ourselves to a number of new Angular constructs.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 基础工作已经奠定，现在我们准备在Angular框架上进行一些严肃的应用程序开发。在下一章中，我们将开始进行更复杂的练习，并接触到许多新的Angular构造。
