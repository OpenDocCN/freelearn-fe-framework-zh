- en: Chapter 13. Selecting and Sorting with jQuery UI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 13 章。使用 jQuery UI 进行选择和排序
- en: If you spend any time working with lists (in an application such as Microsoft
    Excel), then it is possible that you will need to select and sort items into some
    logical order, in a similar fashion to selecting and ordering icons on your computer's
    desktop.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你花费了任何时间与列表（比如 Microsoft Excel 这样的应用程序）打交道，那么你可能需要选择并按照某种逻辑顺序对项目进行排序，类似于在计算机桌面上选择和排序图标的方式。
- en: The selectable and sortable interaction helpers in jQuery UI allow you to define
    a series of elements that can be chosen by dragging a selection square around
    them, and then reordered into a new order.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery UI 中的可选择和可排序交互辅助程序允许您定义一系列可以通过拖动选择方框来选择的元素，然后重新排序为新顺序。
- en: 'Topics that will be covered in this section include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分将涵盖的主题包括：
- en: Creating the default selectable implementation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建默认的可选择实现
- en: How selectable class names reflect the state of selectable elements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选择类名称如何反映可选择元素的状态
- en: Filtering selectable elements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤可选择元素
- en: Working with selectables' built-in callback functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置回调函数处理可选择的元素
- en: A look at selectables' methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看可选择元素的方法
- en: Creating a default sortable widget
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建默认的可排序小部件
- en: Basic configurable properties
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本可配置属性
- en: Sortables' wide range of built-in event handlers and methods
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可排序的各种内置事件处理程序和方法
- en: Submitting the sorted result to a server
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将排序结果提交到服务器
- en: Adding drag elements to a sortable
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将拖动元素添加到可排序中
- en: Selecting and sorting has been a standard part of modern operating systems for
    a long time. For example, if you wanted to select and sort some of the icons on
    your desktop, you could hold the mouse button down on a blank part of the desktop
    and drag a square around the icons you wanted to select, or select the **Auto
    arrange icons** option from your desktop.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 选择和排序长期以来一直是现代操作系统的标准部分。例如，如果你想要选择和排序桌面上的一些图标，你可以在桌面的空白部分按住鼠标按钮并在你想要选择的图标周围画一个方框，或者从桌面中选择**自动排列图标**选项。
- en: The selectable and sortable interaction helpers add this same functionality
    to our web pages, which allows us to build more user-friendly interfaces without
    needing to use external environments, such as Flash or Silverlight.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 可选择和可排序的交互辅助程序将相同的功能添加到我们的网页中，这样我们就可以构建更加用户友好的界面，而无需使用外部环境，如 Flash 或 Silverlight。
- en: Introducing the selectable widget
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍可选择小部件
- en: The first thing we should do is invoke the default implementation to get a glimpse
    of the basic functionality provided by this component.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是调用默认实现，以了解此组件提供的基本功能。
- en: 'In a new file in your text editor, add the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本编辑器中的新文件中添加以下代码：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Save this as `selectable1.html` in the `jqueryui` folder. We simply call the
    `selectable` widget method on the parent `<ul>` element and then all of its child
    `<li>` elements are made selectable. This allows selection by clicking on them
    or using the selection square (like you would do on your desktop).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将其保存为`jqueryui`文件夹中的`selectable1.html`。我们只需在父`<ul>`元素上调用`selectable`小部件方法，然后所有子`<li>`元素都可以选择。这允许通过点击或使用选择方框（就像你在桌面上做的那样）进行选择。
- en: 'Note that there is no styling associated with the selectable component. Default
    behavior includes clicking on individual elements, causing them only to be selected,
    and clicking on one of the selected elements to deselect them. Holding down the
    *Ctrl* key will enable multiselect. The following screenshot shows the selection
    square enclosing the list items:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与可选择组件相关联的样式是不存在的。默认行为包括单击单个元素只会选择它们，并单击所选元素中的一个以取消选择它们。按住*Ctrl*键将启用多选。以下截图显示了选项方框包围的列表项：
- en: '![Introducing the selectable widget](img/2209OS_13_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![介绍可选择小部件](img/2209OS_13_01.jpg)'
- en: 'The minimum set of library files we need for a selectable implementation is
    as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于可选择实现的最小一组库文件如下：
- en: '`jquery-2.0.3.js`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery-2.0.3.js`'
- en: '`jquery.ui.core.js`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.core.js`'
- en: '`jquery.ui.widget.js`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.widget.js`'
- en: '`jquery.ui.mouse.js`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.mouse.js`'
- en: '`jquery.ui.selectable.js`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.selectable.js`'
- en: 'Along with building selectables from list items, we can also build them from
    other elements, such as a collection of `<div>` elements. Add the following link
    to the `<head>` of the `selectable1.html` file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '除了从列表项构建可选择项之外，我们还可以从其他元素构建可选择项，例如一组`<div>`元素。将以下链接添加到`selectable1.html`文件的`<head>`中：  '
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Also, replace the list elements in `selectable1.html` with the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，用以下代码替换`selectable1.html`中的列表元素：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Save this as `selectable2.html`. Everything is essentially the same as before.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存为`selectable2.html`。一切基本上与以前相同。
- en: We're just basing the example on different elements. However, due to the nature
    of these elements, we should add a little basic styling so that we can see what
    we're working with.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是基于不同元素的示例。然而，由于这些元素的性质，我们应该添加一些基本的样式，以便我们可以看到我们正在处理的内容。
- en: 'In a new file in your text editor, add the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本编辑器中的新文件中添加以下代码：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Save this as `selectable.css` in the `css` folder. It''s not much, but it helps
    to clarify the individual selectables in the example, as shown in the following
    screenshot:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存为`selectable.css`在`css`文件夹中。虽然不多，但它有助于澄清示例中的各个可选择项，如下图所示：
- en: '![Introducing the selectable widget](img/2209OS_13_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![介绍可选择小部件](img/2209OS_13_02.jpg)'
- en: Introducing the Selectee class names
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Selectee 类名
- en: The elements that are made selectable are all initially given the `ui-selectee`
    class, and the parent element that contains them is given the `ui-selectable`
    class. While elements are selected, they are given the `ui-selected` class.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可选择的元素最初都被赋予`ui-selectee`类，包含它们的父元素被赋予`ui-selectable`类。当元素被选择时，它们被赋予`ui-selected`类。
- en: While the selecting square is around selectable elements, they are given the
    `ui-selecting` class, and whilst an element is being deselected it is given the
    `ui-unselecting` class. These classnames are added purely for our benefit, so
    that we can highlight different states that the selectable may be in.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择方块围绕可选择元素时，它们被赋予`ui-selecting`类，并且在取消选择元素时，元素被赋予`ui-unselecting`类。这些类名纯粹是为了我们的方便，这样我们就可以突出显示可选择的不同状态。
- en: 'This extensive class system makes it very easy to add custom styling to show
    when elements are either in the process of being selected or have been selected.
    Let''s add some additional styling now to reflect the selecting and selected states.
    Add the following new selectors and rules to `selectable.css`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个广泛的类系统使得非常容易添加自定义样式来显示元素是正在被选择还是已被选择。现在让我们添加一些额外的样式来反映选择和已选择的状态。将以下新的选择器和规则添加到`selectable.css`中：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Save this `selectableStates.css` in the `css` folder. Change the link to the
    stylesheet reference in the `<head>` of `selectable2.html`, then save this file
    as `selectable3.html`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 将此`selectableStates.css`保存在`css`文件夹中。更改`selectable2.html`的`<head>`中的样式表引用链接，然后将此文件保存为`selectable3.html`：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With the addition of this very simple CSS, we can add visual cues to elements
    that are part of the current selection, both during and following a select interaction.
    The following screenshot shows some elements in the process of being selected
    on the left, and the same elements having been selected on the right:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 借助这个非常简单的 CSS，我们可以为当前选择的元素添加视觉提示，无论是在选择过程中还是在选择交互后。以下屏幕截图显示了左侧正在被选择的一些元素，以及右侧已被选择的相同元素：
- en: '![Introducing the Selectee class names](img/2209OS_13_03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![介绍 Selectee 类名](img/2209OS_13_03.jpg)'
- en: Configuring the selectable component
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置可选择组件
- en: The `selectable` class is quite compact, with relatively few configurable options
    compared to some of the other components that we've looked at.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`selectable` 类相当紧凑，与我们之前查看的一些其他组件相比，具有相对较少的可配置选项。'
- en: 'The following options are available for configuration:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下列选项可供配置：
- en: '| Option | Default value | Used to... |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 默认值 | 用于... |'
- en: '| --- | --- | --- |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `autoRefresh` | `True` | Automatically refresh the size and position of each
    selectable at the start of a select interaction. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `autoRefresh` | `True` | 在选择交互开始时自动刷新每个可选择项的大小和位置。 |'
- en: '| `cancel` | `":input, option"` | Prevent the specified elements from being
    selected with a click. The default string contains the `:input` jQuery filter,
    which matches all `<input>`, `<textarea>`, `<select>`, and `<button>` elements
    along with the standard option element selector. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `cancel` | `":input, option"` | 防止通过单击选择指定的元素。默认字符串包含`：input`jQuery 过滤器，它匹配所有`<input>`、`<textarea>`、`<select>`和`<button>`元素以及标准选项元素选择器。
    |'
- en: '| `delay` | `0` | Set the delay in milliseconds before the element is selected.
    The mouse button must be held down on the element before the selection will begin.
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `delay` | `0` | 设置在选择元素之前的毫秒延迟。必须在元素上按住鼠标按钮，然后选择才会开始。 |'
- en: '| `disabled` | `false` | Disable selection when the page initially loads. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `disabled` | `false` | 当页面首次加载时禁用选择。 |'
- en: '| `distance` | `0` | Set the distance the mouse pointer must travel, with the
    mouse button held down, before selection will begin. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `distance` | `0` | 设置鼠标指针必须移动的距离（按住鼠标按钮），然后选择才会开始。 |'
- en: '| `filter` | `"*"` | Specify child elements to make selectable. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `filter` | `"*"` | 指定要使可选择的子元素。 |'
- en: '| `tolerance` | `"touch"` | Set the tolerance of the selection square. Possible
    values are `touch` or `fit`. If `fit` is specified the element must be completely
    within the selection square before the element will be selected. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `tolerance` | `"touch"` | 设置选择框的容差。可能的值是`touch`或`fit`。如果指定了`fit`，则元素必须完全位于选择框内，才会被选中。
    |'
- en: Filtering selectables
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 筛选可选择项
- en: 'There may be situations when we don''t want to allow all of the elements within
    the targeted container to be made selectable. In this situation we can make use
    of the `filter` option to nominate specific elements, based on a CSS selector,
    that we want selecting to be enabled on. In `selectable3.html,` change the collection
    of `<div>` elements so that it appears as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在这样的情况，即我们不希望允许目标容器中的所有元素都可选择。在这种情况下，我们可以使用`filter`选项来指定我们希望启用选择的特定元素，基于CSS选择器。在`selectable3.html`中，更改`<div>`元素的集合，使其如下所示：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then change the final `<script>` element to the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将最后一个`<script>`元素更改为以下内容：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The width of each selectable needs to be increased, so in `selectableStates.css`,
    change the `#selectables div` rule to have a width of 190 px.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每个可选择项的宽度需要增加，所以在`selectableStates.css`中，将`#selectables div`规则的宽度更改为190像素。
- en: 'Save this version as `selectable4.html`. In the underlying markup, we have
    given a class to each element except for the first. In the JavaScript, we define
    a configuration object containing the `filter` option. The value of this option
    is the class selector of the elements that we want to be selectable; elements
    without this class name are filtered out of the selection:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将此版本保存为`selectable4.html`。在底层标记中，我们为每个元素除第一个元素外都添加了一个类。在JavaScript中，我们定义了一个包含`filter`选项的配置对象。此选项的值是我们希望可选择的元素的类选择器；没有此类名称的元素将被过滤出选择：
- en: '![Filtering selectables](img/2209OS_13_04.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![筛选可选择项](img/2209OS_13_04.jpg)'
- en: As shown in the previous screenshot, the selection square is over the unselectable
    element, but it's not picking up the `ui-selecting` class like the others. The
    component completely ignores the filtered selectable and it does not become part
    of the selection.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，选择框位于不可选择的元素上方，但它并没有像其他元素那样捕获`ui-selecting`类。该组件完全忽略了被过滤的可选择项，并且它不会成为选择的一部分。
- en: Canceling the selection
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消选择
- en: Along with indirectly making elements unselectable using the `filter` option,
    we can also directly make elements unselectable using the `cancel` option. This
    option was also exposed by the interaction helper we looked at in [Chapter 12](ch12.html
    "Chapter 12. The Resizable Component"), *The Resizable Component*, although we
    didn't look at it in any detail. Now is the perfect opportunity to play with it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 除了间接地使用`filter`选项使元素不可选择之外，我们还可以直接使用`cancel`选项使元素不可选择。这个选项也是我们在[第12章](ch12.html
    "第12章。可调整大小的组件")中看到的交互助手暴露出来的，*可调整大小的组件*，尽管我们没有详细研究它。现在是与它互动的绝佳机会。
- en: 'Add the class name `unselectable` to the first and second elements in the container
    in `selectable4.html`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在`selectable4.html`中的容器中向第一个和第二个元素添加类名`unselectable`：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Change the configuration object from the last example so that it uses the `cancel`
    option:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将上一个示例中的配置对象更改为使用`cancel`选项：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Save this as `selectable5.html`. Instead of passing the class name of the selectable
    elements to the configuration object, we pass the class name of the unselectable
    element to it. When we run the example, we can see that the first element, with
    the class name `unselectable`, is still given the class `ui-selectee`. However,
    it is only selectable with the selection square; it cannot be selected by clicking,
    even with the *Ctrl* key held down.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将其保存为`selectable5.html`。我们不是将可选择元素的类名传递给配置对象，而是将不可选择元素的类名传递给它。当我们运行示例时，我们可以看到具有类名`unselectable`的第一个元素仍然被赋予了类`ui-selectee`。然而，它只能通过选择框进行选择；即使按住*Ctrl*键，也无法通过单击选择。
- en: Handling selectable events
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理可选择项事件
- en: 'In addition to the standard configurable options of the selectable API, there
    are also a series of event callback options that can be used to specify functions
    that are executed at specific points during a select interaction. These options
    are listed in the following table:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可配置的标准可选API选项外，还有一系列事件回调选项，可以用来指定在选择交互期间特定时间点执行的函数。这些选项列在以下表中：
- en: '| Option | Triggered when |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| Option | 触发时机 |'
- en: '| --- | --- |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `selecte` | The select interaction ends and each element added to the selection
    triggers the callback. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `selecte` | 选择交互结束，并且每个添加到选择中的元素都触发回调。 |'
- en: '| `selecting` | Each selected element triggers the callback during the select
    interaction. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `selecting` | 每个选定的元素在选择交互期间触发回调函数。 |'
- en: '| `start` | A select interaction begins. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `start` | 选择交互开始。 |'
- en: '| `stop` | A selection operation ends. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `stop` | 选择操作结束。 |'
- en: '| `unselected` | Any elements that are part of the selectable, but are not
    selected during the interaction will fire this callback. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `unselected` | 在交互期间未被选中的任何元素都将触发此回调。 |'
- en: '| `unselecting` | Unselected elements will fire this during the select interaction.
    |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `unselecting` | 在选择交互期间取消选择的元素将触发此事件。 |'
- en: Selecting really only becomes useful when something happens to the elements
    once they have been selected, which is where this event model comes into play.
    Let's put some of these callbacks to work so that we can appreciate their use.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 选择真正变得有用的是一旦元素被选中后发生的事情，这就是事件模型发挥作用的地方。让我们使用其中一些回调函数来工作，以便我们能够欣赏它们的用途。
- en: 'Replace the configuration object in `selectable5.html` so that it contains
    the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 替换`selectable5.html`中的配置对象，使其包含以下代码：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Save this as `selectable6.html`. In the `<script>`, we've added functions to
    the selected, unselected, start, and stop options. These will be executed at the
    appropriate times during an interaction.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存为`selectable6.html`。在`<script>`中，我们添加了选定、未选定、开始和停止选项的函数。这些函数将在交互期间的适当时间执行。
- en: As with other components, these functions are automatically passed two objects.
    The first is the original browser event object (typically called `e`) and the
    other is an object containing useful properties of the selected element (often
    referred to as `ui`). However, not all callbacks can successfully work with the
    second object—start and stop, for example. In our example, we've left out the
    `ui` object; there is no need to include it, as it will be empty.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他组件一样，这些函数会自动传递两个对象。第一个是原始的浏览器事件对象（通常称为`e`），另一个是包含所选元素的有用属性的对象（通常称为`ui`）。然而，并不是所有的回调函数都能成功地使用第二个对象，例如start和stop。在我们的例子中，我们省略了`ui`对象；没有必要包含它，因为它将是空的。
- en: When a `<div>` is selected, we change its inner text to reflect the selection
    using the `selected` event callback. We can use the `selected` property to get
    the element that was selected in order to change its text content to a new message.
    When an element is deselected, we set the text to `The div was selected` using
    the same technique.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择一个`<div>`时，我们使用`selected`事件回调将其内部文本更改以反映选择。我们可以使用`selected`属性获取被选中的元素，以便将其文本内容更改为新消息。当一个元素被取消选择时，我们使用相同的技术将文本设置为`The
    div was selected`。
- en: We can also alter the text of any selectable that was previously selected using
    the `unselected` event.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`unselected`事件更改以前选中的任何可选择项的文本。
- en: 'At the start of any interaction, we create a tooltip that is appended to the
    `<body>` of the page, slightly offset from the mouse pointer, using the `start`
    event. We use a basic conditional to check that the tool tip does not already
    exist to prevent duplicate tips. We can make use of the framework classes `ui-corner-all`,
    `ui-widget`, and `ui-widget-header` to do most of the styling for us. The few
    styles we require that are not provided by the theme are added using the `css()`
    method. We can get the pointer coordinates using the `e` (event) object, which
    is passed as the first argument to our callbacks, in order to position the tool
    tip. At the end of the selection, we remove the tool tip using the `stop` property.
    The following screenshot shows the results of different interactions:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何交互开始时，我们创建一个工具提示，将其附加到页面的`<body>`中，略微偏离鼠标指针，使用`start`事件。我们使用基本条件来检查工具提示是否已经存在，以防止重复提示。我们可以利用框架类`ui-corner-all`、`ui-widget`和`ui-widget-header`大部分样式处理。我们使用`css()`方法添加了主题未提供的少量样式。我们可以使用传递给我们回调函数的第一个参数`e`（事件）对象获取指针坐标，以定位工具提示。在选择结束时，我们使用`stop`属性移除工具提示。以下屏幕截图显示了不同交互的结果：
- en: '![Handling selectable events](img/2209OS_13_05.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![处理可选事件](img/2209OS_13_05.jpg)'
- en: 'The `selecting` and `unselecting` callback options work exactly the same way
    as those we have just looked at, but are fired as elements are added or removed
    to the selection. To see those in action, replace the `selected` and `unselected`
    options in the configuration object in `selectable6.html` with the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`selecting`和`unselecting`回调选项的工作方式与我们刚刚查看的选项完全相同，但是在添加或移除元素时触发。要看到其实际操作，将`selectable6.html`中的配置对象中的`selected`和`unselected`选项替换为以下内容：'
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Save your work as `selectable7.html`. This time we use the `selecting` and `unselecting`
    properties to specify callback functions, which again change the text content
    of the elements at certain times during an interaction. We repeat the procedure
    from the last example, this time we're just using different callbacks and properties
    of the objects passed to them.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的工作保存为`selectable7.html`。这次，我们使用`selecting`和`unselecting`属性来指定回调函数，再次在交互过程中的特定时间更改元素的文本内容。我们重复上一个示例中的过程，这次我们只是使用不同的回调和传递给它们的对象的属性。
- en: The second object passed to any of the selectable callbacks contains a property
    relating to the type of custom event. For example, the selected callback receives
    an object with a `selected` property, which can be used to gain information about
    the element that was added to the selection. All callbacks have a matching property
    that can be used in this way.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给任何可选回调的第二个对象包含与自定义事件类型相关的属性。例如，选择的回调接收一个带有`selected`属性的对象，该属性可用于获取有关添加到选定项中的元素的信息。所有回调都有相匹配的属性可用于此种方式。
- en: Working with vast amounts of selectables
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理大量可选元素
- en: The jQuery UI library, such as jQuery itself, is already extremely efficient.
    It uses the ultra-effective **Sizzle selector engine** (via jQuery) and each component
    has been optimized as much as possible.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery UI库与jQuery本身一样，已经非常高效。它使用高效的**Sizzle选择器引擎**（通过jQuery），并且每个组件都已尽可能地进行了优化。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: Sizzle is a pure JavaScript CSS Selector engine, used by jQuery, which allows
    you to use JavaScript on CSS selectors, such as `$("<div>")`. If you would like
    to learn more, you can visit the project site at [http://sizzlejs.com/](http://sizzlejs.com/).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Sizzle是jQuery使用的纯JavaScript CSS选择器引擎，它允许您在CSS选择器上使用JavaScript，例如`$("<div>")`。如果您想了解更多，请访问项目网站[http://sizzlejs.com/](http://sizzlejs.com/)。
- en: However, there is only so much that the creators of the library can do. In our
    examples so far, we've used a maximum of five selectable elements, which aren't
    really many at all. What if we were to use 500 instead?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，库的创建者们只能做这么多。到目前为止，我们使用了最多五个可选元素，这实际上并不多。如果我们要使用500个又会怎样呢？
- en: When working with great numbers of selectables there is still something we can
    do to make sure that the select interactions are as efficient as possible. The
    `autoRefresh` option is set to `true` by default, which causes the sizes and positions
    of all selectable elements on the page to be recalculated at the beginning of
    every interaction.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用大量可选元素时，仍然有一些事情可以做，以确保选择交互尽可能高效。默认情况下，`autoRefresh`选项设置为`true`，这会导致页面上所有可选择元素的大小和位置在每次交互开始时重新计算。
- en: This can cause delays on pages with many selectable elements on it, so the `autoRefresh`
    option can be set to `false` when dealing with large collections of elements.
    We can also use the `refresh` method to manually refresh the selectables at appropriate
    times in order to improve the speed and responsiveness of the interactions. On
    most pages we would not need to worry about configuring this option and can leave
    it at its default setting.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面上有许多可选择元素时，这可能会导致延迟，因此当处理大量元素集合时，可以将 `autoRefresh` 选项设置为 `false`。我们还可以在适当的时候使用
    `refresh` 方法手动刷新可选择元素，以提高交互的速度和响应性。在大多数页面上，我们不需要担心配置此选项，可以将其保留为默认设置。
- en: 'Let''s take a look at how this option can help our pages in certain situations.
    In the `<head>` of `selectable7.html` change the `<link>` for the custom stylesheet
    to the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在某些情况下，此选项如何帮助我们的页面。在 `selectable7.html` 的 `<head>` 中，将自定义样式表的 `<link>`
    更改为以下内容：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then change the selectables container element so that it appears as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后修改可选择元素容器元素，使其显示如下：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We''re going to use a little jQuery to create our selectable elements automatically,
    so replace the existing script in `document.ready()` block with the following
    code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一点 jQuery 来自动创建我们的可选择元素，因此将 `document.ready()` 块中的现有脚本替换为以下代码：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Save this page as `selectable8.html`. Our page should now contain 100 individual
    selectables within the selectables container. We've also added a class name to
    the outer container so that the container is cleared properly when we float our
    selectables (which we will do in a moment). If the container is not cleared correctly,
    the selection square will not work. We added the `.ui-helper-clearfix` class to
    our selectables `div` to help cure this issue.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将此页面保存为 `selectable8.html`。我们的页面现在应该包含 `100` 个单独的可选择元素在可选择元素容器内。我们还为外部容器添加了一个类名，以便在浮动可选择元素时正确清除容器（我们稍后会这样做）。如果容器没有正确清除，选择框将无法工作。我们在可选择的
    `div` 中添加了 `.ui-helper-clearfix` 类来帮助解决此问题。
- en: 'We also need a new stylesheet in this example that consists of the following
    code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个新的样式表示例，代码如下：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Save this in the `css` folder as `selectableMany.css`. It's purely for layout
    purposes, so we don't need to discuss it further.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将其保存在 `css` 文件夹中，命名为 `selectableMany.css`。它纯粹用于布局目的，所以我们不需要进一步讨论它。
- en: We can use something like Chrome's Developer Tools to profile a selection of
    all 100 selectables with and without the `autoRefresh` option enabled; it's enabled
    by default, so our example will disable it. The results will probably vary between
    tests, but you should find that the profile (in both milliseconds and the number
    of calls) is consistently lower with `autoRefresh` set to disabled.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似 Chrome 的开发者工具来分析所有 `100` 个可选择元素的选择情况，分别启用和禁用 `autoRefresh` 选项；它默认是启用的，所以我们的示例会将其禁用。测试结果可能会有所不同，但你会发现，将
    `autoRefresh` 设置为禁用时，性能剖析结果（以毫秒和调用次数表示）通常会更低。
- en: Tip
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**How do I profile JavaScript performance?**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何剖析 JavaScript 性能？**'
- en: For details of how to perform profiling in a browser such as Chrome, you can
    view a useful tutorial at [https://developers.google.com/chrome-developer-tools/docs/cpu-profiling](https://developers.google.com/chrome-developer-tools/docs/cpu-profiling).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何在 Chrome 等浏览器中进行性能剖析的详细信息，您可以在 [https://developers.google.com/chrome-developer-tools/docs/cpu-profiling](https://developers.google.com/chrome-developer-tools/docs/cpu-profiling)
    上查看一个有用的教程。
- en: Working with selectable methods
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可选择元素方法
- en: 'The methods that we can use to control the selectables component from our code
    are similar to the methods found in other interaction helpers and follow the same
    pattern of usage. The only unique method exposed by the selectables component
    is listed as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似其他交互式辅助工具中找到的方法来控制代码中的可选择元素组件，使用模式相同。可选择元素组件唯一公开的唯一方法列在下面：
- en: '| Method | Usage |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 用法 |'
- en: '| --- | --- |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Refresh` | Manually refreshes the positions and sizes of all selectables.
    Should be used when `autoRefresh` is set to `false`. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `刷新` | 手动刷新所有可选择元素的位置和大小。当 `autoRefresh` 设置为 `false` 时应使用。 |'
- en: In addition to this unique method, the selectables component (like every other
    component) makes use of the common API methods `destroy`, `disable`, `enable`,
    `option`, and `widget`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个独特的方法之外，可选择元素组件（像每个其他组件一样）还使用了通用的 API 方法 `destroy`、`disable`、`enable`、`option`
    和 `widget`。
- en: Refreshing selectables
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刷新可选择元素
- en: Setting the `autoRefresh` property to `false` can yield performance gains when
    there are many selectables on the page, especially in Internet Explorer. However,
    there will still be times when you will need to refresh the size and positions
    of the selectables, such as when this component is combined with the draggables
    component.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `autoRefresh` 属性设置为 `false` 可以在页面上有许多可选择项时提高性能，特别是在Internet Explorer中。然而，仍然会有时候需要刷新可选择项的大小和位置，比如当此组件与可拖动组件结合使用时。
- en: 'Let''s take a look at the `refresh` method as it leads on perfectly from the
    last example. Add the following new `<button>` element directly after the selectables
    container:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `refresh` 方法，因为它完美地延续了上一个示例。直接在可选择的容器后添加以下新的 `<button>` 元素：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We''ll also need to link to the draggable source file for this example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此示例，我们还需要链接到可拖动源文件：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then change the final `<script>` element so that it appears as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后更改最终的 `<script>` 元素，使其如下所示：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Save this as `selectable9.html`. We've added a new `<button>` to the page and
    we now link to the draggable source file as well as the selectable's. Each of
    the 100 elements is made both draggable and selectable.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存为 `selectable9.html`。我们在页面上添加了一个新的 `<button>`，现在我们链接到了可拖动源文件以及可选择的源文件。这100个元素都可以同时拖动和选择。
- en: Our click handler that is attached to the `<button>` will simply call the `refresh`
    method manually on the selectables container. When we run the page in a browser
    we should first select some, but not all, of the selectable widgets. We should
    then deselect the elements and move some of them around. We can move other elements
    that weren't selected into the selection group as well. Really shuffle them up!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们附加到 `<button>` 的点击处理程序将在可选择项容器上手动调用 `refresh` 方法。当我们在浏览器中运行页面时，我们应该首先选择一些但不是所有的可选择小部件。然后我们应该取消选择元素并移动其中一些元素。我们还可以将未选择的其他元素移动到选择组中。真的要将它们混在一起！
- en: 'When we try to select the same group again, we find that the wrong elements
    are being selected:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试再次选择相同的组时，我们发现选择了错误的元素：
- en: '![Refreshing selectables](img/2209OS_13_06.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![刷新可选择项](img/2209OS_13_06.jpg)'
- en: The component hasn't refreshed the positions of the selectables, so it still
    thinks that all of the selectables are in the same place as they were when the
    first selection was made. If we click on the **refresh** button and make a third
    selection, the correct elements will now be selected.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 组件没有刷新可选择项的位置，所以它仍然认为所有可选择项的位置与第一次选择时的位置相同。如果我们点击 **refresh** 按钮并进行第三次选择，则现在将选择正确的元素。
- en: Creating a selectable image viewer
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可选择的图像查看器
- en: In our final selectable example, we're going to make a basic image viewer. Images
    can be chosen for viewing by selecting the appropriate thumbnail. Although this
    sounds like a relatively easy achievement, in addition to the actual mechanics
    of displaying the selected image, we'll also need to consider how to handle multiple
    selections.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最终可选择示例中，我们将制作一个基本的图像查看器。通过选择相应的缩略图来选择图像进行查看。尽管这听起来像是一个相对容易的成就，除了显示所选图像的实际机制之外，我们还需要考虑如何处理多个选择。
- en: 'The following screenshot shows an example of what we''ll end up with:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了我们将要完成的示例：
- en: '![Creating a selectable image viewer](img/2209OS_13_07.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![创建可选择的图像查看器](img/2209OS_13_07.jpg)'
- en: 'Let''s get started with the code. In a fresh page in your text editor, add
    the following page:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编码。在文本编辑器中的新页面中，添加以下页面：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Save this as `imageSelector.html`. On the page, we have a parent `<div>` with
    an `id` of `imageSelector` into which all of our other elements go.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存为 `imageSelector.html`。在页面上，我们有一个父级 `<div>`，其 `id` 为 `imageSelector`，其中包含我们的所有其他元素。
- en: Within the parent, we have a `<div>` that will act as a status bar to display
    the names of individually selected images, and a `<div>` that will act as the
    viewing panel and will display the full-sized version of the image. Finally, we
    have our thumbnail images, which will be made selectable.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在父元素内，我们有一个 `<div>` 作为状态栏来显示单独选择的图像的名称，和一个 `<div>` 作为查看面板，并显示图像的全尺寸版本。最后，我们有缩略图图像，将可以选择。
- en: Adding the behavior
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加行为
- en: 'Next we need to add the script that makes the image selector work, so directly
    after the final `<script>` element add the following code; throughout this section,
    we''ll walk through the code block by block, beginning with the configuration
    object for the selectables:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要添加使图像选择器工作的脚本，因此在最后一个`<script>`元素之后直接添加以下代码；在本节中，我们将逐块地解析这段代码，从选择项的配置对象开始：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We use the `stop callback` function to do some prep work, such as removing the
    contents of the image selector container (except for the thumbnails) and creating
    an empty viewer container. We then use an `if` conditional to call either the
    `singleSelect()` or `multiSelect()` functions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`stop callback`函数执行一些准备工作，例如删除图像选择器容器的内容（除了缩略图）并创建一个空的查看器容器。然后我们使用一个`if`条件来调用`singleSelect()`或`multiSelect()`函数中的一个。
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We then define the first of two functions, which is `singleSelect()`. This will
    be invoked every time a single thumbnail is selected. We first cache the `id`
    of the selected element; we'll be referring to this several times, so it's more
    efficient to store it in a variable.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义两个函数中的第一个，即`singleSelect()`。这将在每次选择单个缩略图时调用。我们首先缓存所选元素的`id`；我们将多次引用它，因此将其存储在一个变量中更有效。
- en: Next we create a new status bar and set its `innerText` to the `id` value that
    was cached a moment ago, which will be the `id` attribute of whichever thumbnail
    is selected. We give the new element some of the framework classes to style the
    element and then insert it into the image selector container.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们创建一个新的状态栏，并将其`innerText`设置为片刻前缓存的`id`值，该值将是所选缩略图的`id`属性。我们为新元素添加了一些框架类以样式化该元素，然后将其插入到图像选择器容器中。
- en: The last thing we do in this function is to create the full-sized version of
    the thumbnail. To do this, we create a new image and set its `src` attribute to
    match the large version of the thumbnail that was selected (both the large and
    thumbnail versions of each image have the same filename). The full-size image
    is then inserted into the viewer container.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中我们做的最后一件事是创建缩略图的全尺寸版本。为此，我们创建一个新的图像，并将其`src`属性设置为所选缩略图的大尺寸版本（每个图像的大尺寸和缩略图版本具有相同的文件名）。然后将全尺寸图像插入到查看器容器中。
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next we define the `multiSelect()` function, which is called when multiple thumbnails
    are selected. This time we start by creating a new `<div>` element, give it an
    `id` of tabs and insert it before the viewer container. Following this, we create
    a new `<ul>` element, as this is a required component of the tabs widget (which
    we looked at in [Chapter 3](ch03.html "Chapter 3. Using the Tabs Widget"), *Using
    the Tabs Widget*). This element is appended to the tabs container we created a
    moment ago.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们定义`multiSelect()`函数，当选择多个缩略图时调用该函数。这次我们首先创建一个新的`<div>`元素，为其设置一个`id`为tabs，并在查看器容器之前插入它。在此之后，我们创建一个新的`<ul>`元素，因为这是标签小部件的必需组件（我们在[第3章](ch03.html
    "Chapter 3. Using the Tabs Widget")中讨论过标签小部件，*使用标签小部件*）。此元素被附加到我们刚刚创建的标签容器中。
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We then use jQuery's `each()` method to iterate over each of the thumbnails
    that were selected. For each item we create a series of variables, which will
    hold the different elements that make up the tab headings. We cache the `id` attribute
    of each image and create a new `<li>` and a new `<a>` element. The link will form
    the clickable tab heading and is given the `id` of the thumbnail as its text content.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用jQuery的`each()`方法迭代所选择的每个缩略图。对于每个项目，我们创建一系列变量，用于保存组成选项卡标题的不同元素。我们缓存每个图像的`id`属性并创建一个新的`<li>`和一个新的`<a>`元素。链接将形成可点击的选项卡标题，并将缩略图的`id`作为其文本内容。
- en: We then create the new tab panel that will match the tab heading that we just
    created. Notice that we create a unique `id` for the content panel based on the
    thumbnail's `id` attribute and some hardcoded text. Note that the `id` will precisely
    match the `href` attribute that we set on the `<a>` element. Each new image is
    created in the same way as in the `singleSelect()` function.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建与我们刚刚创建的选项卡标题匹配的新选项卡面板。注意，我们根据缩略图的`id`属性和一些硬编码的文本创建了内容面板的唯一`id`。注意，`id`将精确匹配我们在`<a>`元素上设置的`href`属性。每个新图像都是以与`singleSelect()`函数相同的方式创建的。
- en: After the `each()` method, we set a CSS property on the viewer container to
    tidy up its appearance and then append it to the tabs container. Finally the `tabs()`
    method is called on the tabs container, transforming it into the tabs widget.
    At the end of the script the thumbnails are made selectable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在`each()`方法之后，我们设置了一个CSS属性来整理查看器容器的外观，然后将其附加到选项卡容器。最后，在选项卡容器上调用了`tabs()`方法，将其转换为选项卡小部件。在脚本的末尾，缩略图可以被选择。
- en: Styling the image selector
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置图像选择器的样式
- en: 'Our example is also heavily reliant on CSS to provide its overall appearance.
    In a new file in your text editor, create the following new stylesheet:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例还严重依赖CSS来提供其整体外观。在您的文本编辑器中的新文件中，创建以下新样式表：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Save this in the `css` folder as `selectableViewer.css`. Most of the styles
    are arbitrary and are required purely for layout or visual appearance. We're using
    some of the framework classes in our mark up in order to add the rounded corners,
    so the amount of CSS we need to write is minimal. The last few selectors are required
    in order to override some of the tab widget's default styling.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将其保存在`css`文件夹中，命名为`selectableViewer.css`。大部分样式是任意的，纯粹用于布局或视觉外观。我们在标记中使用了一些框架类来添加圆角，因此我们需要编写的CSS量很小。最后几个选择器是为了覆盖某些选项卡小部件的默认样式而必需的。
- en: 'When we run the example in a browser, we should see something similar to what
    is shown in the previous screenshot. When a single thumbnail is selected the full-size
    version of the image will be displayed. When multiple images have been selected,
    tabs are recreated at the top of the viewer, which allow all of the selected images
    to be shown:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中运行示例时，应该会看到与前一截图类似的内容。当选择单个缩略图时，将显示图像的全尺寸版本。当选择了多个图像时，将在查看器顶部重新创建选项卡，这些选项卡允许显示所有选定的图像：
- en: '![Styling the image selector](img/2209OS_13_08.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![设置图像选择器的样式](img/2209OS_13_08.jpg)'
- en: Getting started with the sortable widget
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用sortable小部件
- en: The final interaction helper that we're going to look at is the sortables component.
    This component allows us to define one or more list of elements (not necessarily
    actual `<ul>` or `<ol>` elements), where the individual items in the list(s) can
    be reordered by dragging. The sortables component is like a specialized implementation
    of drag-and-drop, with a very specific role. It has an extensive API, which caters
    for a wide range of behaviors.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要查看的最终交互助手是sortable小部件。此组件允许我们定义一个或多个元素列表（不一定是实际的`<ul>`或`<ol>`元素），其中列表中的个别项目可以通过拖动重新排序。sortable组件类似于拖放的专门实现，具有非常具体的角色。它有一个广泛的API，适用于各种行为。
- en: 'A basic sortable list can be enabled with no additional configuration. Let''s
    do this first, so that you can get an idea of the behavior enabled by this component.
    In a new file in your text editor, add the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过不需要额外配置来启用基本的可排序列表。首先，让我们这样做，以便您可以了解此组件启用的行为。在您的文本编辑器中的新文件中，添加以下代码：
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Save this as `sortable1.html`. On the page, we have a simple unordered list
    with five list items. Thanks to the sortables component, we should find that the
    individual list items can be dragged to different positions in the list, as shown
    in the following screenshot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将其保存为`sortable1.html`。在页面上，我们有一个简单的无序列表，其中有五个列表项。由于sortable组件的存在，我们应该发现可以将单个列表项拖动到列表中的不同位置，如下截图所示：
- en: '![Getting started with the sortable widget](img/2209OS_13_8A.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用sortable小部件](img/2209OS_13_8A.jpg)'
- en: Code-wise, the default implementation is the same as it has been for each of
    the other components. We simply call the sortable widget method on the parent
    `<ul>` element of the list items that we want to make sortable.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 代码上，默认实现与其他组件的实现相同。我们只需在要排序的列表项的父`<ul>`元素上调用sortable小部件方法即可。
- en: A lot of behaviors are added to the page to accommodate this functionality.
    As we drag one of the list items up or down in the list, the other items automatically
    move out of the way, creating a slot for the item that is currently being sorted
    to be dropped on.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 页面添加了许多行为以适应此功能。当我们将列表项中的一个上下拖动时，其他项目会自动让路，为当前正在排序的项目创建一个放置位置。
- en: 'Additionally, when a sortable item is dropped, it will slide quickly, but smoothly
    into its new position in the list. The library files that were needed for the
    basic implementation are as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，当可排序项目被放置时，它将快速而平滑地滑动到列表中的新位置。基本实现所需的库文件如下：
- en: '`jquery-2.0.3.js`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery-2.0.3.js`'
- en: '`jquery.ui.core.js`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.core.js`'
- en: '`jquery.ui.widget.js`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.widget.js`'
- en: '`jquery.ui.mouse`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.mouse`'
- en: '`jquery.ui.sortable.js`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.sortable.js`'
- en: 'As I mentioned earlier, the sortables component is a flexible addition to the
    library that can be applied to many different types of elements. For example,
    instead of using a list, we could use a series of `<div>` elements as the sortable
    list items, in place of the `<ul>` element in the previous example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，可排序组件是库的一个灵活的补充，可以应用到许多不同类型的元素上。例如，我们可以使用一系列 `<div>` 元素作为可排序列表项，而不是前面示例中的
    `<ul>` 元素：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This can be saved as `sortable2.html`. As you can see, the behavior exhibited
    by this version is exactly the same as it was before. All that's changed is the
    underlying markup. We've added some of the CSS framework classes in order to add
    some basic styling to our elements, and we can also use a custom stylesheet to
    add a few extra styles.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以保存为`sortable2.html`。正如你所看到的，这个版本展示的行为与以前完全一样。改变的只是底层标记。我们添加了一些 CSS 框架类，以添加一些基本样式到我们的元素，我们也可以使用自定义样式表添加一些额外的样式。
- en: 'Create a new file and add the following styles:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，并添加以下样式：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Save this in the `css` folder as `sortable.css`. Link to the CSS file in the
    `<head>` of `sortable2.html`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存在 `css` 文件夹中，命名为 `sortable.css`。在 `sortable2.html` 的 `<head>` 中链接到 CSS 文件：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'With our new stylesheet, the page should now appear as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的新样式表，页面现在应该如下所示：
- en: '![Getting started with the sortable widget](img/2209OS_13_09.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![使用可排序小部件入门](img/2209OS_13_09.jpg)'
- en: Styling the sortable widget
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为可排序小部件设置样式
- en: Now that we have styled our first set of sortable elements, it's a good point
    in journey at which to examine the style classes used by the sortable widget.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的第一组可排序元素设置了样式，这是我们在旅程中的一个好时机，可以检查可排序小部件使用的样式类。
- en: 'The sortable widget uses a number of styles. They are shown in the following
    table:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 可排序小部件使用了许多样式。它们在下面的表格中显示：
- en: '| Class name | Used to… |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 类名 | 用于… |'
- en: '| --- | --- |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ui-widget ui-sortable` | Used on the container element; this first sets
    the generic classes from `ui-widget`, followed by those in `ui-sortable`. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `ui-widget ui-sortable` | 用于容器元素；首先设置来自 `ui-widget` 的通用类，然后是 `ui-sortable`
    中的类。 |'
- en: '| `ui-widget-header` | Style each sortable element; this is by default with
    rounded corners, using the `ui-corner-all` style. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `ui-widget-header` | 为每个可排序元素设置样式；这是默认的带有圆角的，使用 `ui-corner-all` 样式。 |'
- en: '| `ui-sortable-helper –` | Show a clone of the element being sorted, during
    the dragging process. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `ui-sortable-helper –` | 在拖动过程中显示被排序元素的克隆。 |'
- en: '| `ui-sortable-placeholder –` | Act as the placeholder element, ready to accept
    the element being sorted. This is hidden by default, but can be changed, as we
    will see later in the chapter. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `ui-sortable-placeholder –` | 作为占位符元素，准备接受正在排序的元素。默认情况下，它是隐藏的，但可以根据需要更改，我们将在本章后面看到。
    |'
- en: Configuring sortable options
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置可排序选项
- en: The sortables component has a huge range of configurable options, much more
    than any of the other interaction components (but not as many as some of the widgets).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 可排序组件有大量可配置的选项，比任何其他交互组件都多（但不及一些小部件多）。
- en: 'The following table shows the range of options at our disposal:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了我们可以使用的范围内的各种选项：
- en: '| Option | Default value | Used to… |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 默认值 | 用于… |'
- en: '| --- | --- | --- |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `appendTo` | `"parent"` | Set the element that helpers are appended to, during
    a sort. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `appendTo` | `"parent"` | 在排序期间，设置助手要附加到的元素。 |'
- en: '| `axis` | `false` | Constrain sortables to one axis of movement. Possible
    values are the strings x or y. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `axis` | `false` | 限制可排序元素在一个轴上的移动。可能的值是字符串 x 或 y。 |'
- en: '| `cancel` | `":input, button"` | Specify elements that cannot be sorted, if
    they are the elements being sorted. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `cancel` | `":input, button"` | 指定不能排序的元素，如果它们是正在排序的元素。 |'
- en: '| `connectWith` | `false` | Enable one-way sorting from the current list to
    the specified list. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `connectWith` | `false` | 启用从当前列表到指定列表的单向排序。 |'
- en: '| `containment` | `false` | Constrain sortables to their container while they
    are being sorted. Values can be the string''s parent, window, or document, or
    can be a jQuery selector or element node. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `containment` | `false` | 在排序过程中将排序限制在它们的容器中。值可以是字符串的 parent、window 或 document，也可以是一个
    jQuery 选择器或元素节点。 |'
- en: '| `cursor` | `"auto"` | Define the CSS cursor to apply while dragging a sortable
    element. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `cursor` | `"auto"` | 定义拖动可排序元素时要应用的 CSS 光标。 |'
- en: '| `cursorAt` | `false` | Specify the coordinates that the mouse pointer should
    be at, while a sort is taking place. Accepts an object with the keys `top`, `right`,
    `bottom`, or `left` with integers as the values. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `cursorAt` | `false` | 指定在进行排序时鼠标指针应该在的坐标。接受一个带有键 `top`、`right`、`bottom`
    或 `left` 以及整数值的对象。'
- en: '| `delay` | `0` | Set the time delay in milliseconds before the sort begins,
    once a sortable item has been clicked (with the mouse button held down). |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `delay` | `0` | 设置在可排序项被点击（鼠标按键按住）后开始排序之前的时间延迟，以毫秒为单位。'
- en: '| `disabled` | `false` | Disable the widget on page load. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `disabled` | `false` | 在页面加载时禁用小部件。'
- en: '| `distance` | `1` | Set how far in pixels the mouse pointer should move, while
    the left button is held down before the sort begins. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `distance` | `1` | 设置左键按下后在排序开始之前鼠标指针应该移动的像素距离。'
- en: '| `dropOnEmpty` | `true` | Allow linked items from linked sortables to be dropped
    onto empty slots. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `dropOnEmpty` | `true` | 允许从链接的可排序项被放置到空槽中。'
- en: '| `forceHelperSize` | `false` | Force the `helper` to have a size when set
    to `true`. |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `forceHelperSize` | `false` | 当设置为 `true` 时，强制 `helper` 具有大小。'
- en: '| `forcePlaceholderSize` | `false` | Force the `placeholder` to have a size
    when set to `true`. The placeholder is the empty space that a sortable can be
    dropped on to. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `forcePlaceholderSize` | `false` | 当设置为 `true` 时，强制 `placeholder` 具有大小。占位符是可排序项可以放置的空白空间。'
- en: '| `grid` | `false` | Set sortables to snap to a grid while being dragged. Accepts
    an array with two items—the x and y distances between gridlines. |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `grid` | `false` | 设置可排序项目在拖动时捕捉到网格。接受一个包含两个项目的数组——网格线之间的 x 和 y 距离。'
- en: '| `handle` | `false` | Specify an element to be used as the drag handle on
    sortable items. Can be a selector or an element node. |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `handle` | `false` | 指定要用作可排序项上拖动手柄的元素。可以是选择器或元素节点。'
- en: '| `helper` | `original"` | Specify a helper element that will be used as a
    proxy, while the element is being sorted. Can accept a function that returns an
    element. |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `helper` | `original"` | 指定在元素被排序时将用作代理的助手元素。可以接受返回元素的函数。'
- en: '| `items` | `">*"` | Specify the items that should be made sortable. The default
    makes all children sortable. |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `items` | `">*"` | 指定应该进行排序的项目。默认情况下，所有子项都可以进行排序。'
- en: '| `opacity` | `false` | Specify the CSS opacity of the element being sorted.
    Value should be an integer from `0.01` to `1`, with `1` being fully opaque. |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `opacity` | `false` | 指定被排序元素的 CSS 不透明度。值应为从 `0.01` 到 `1` 的整数，`1` 表示完全不透明。'
- en: '| `placeholder` | `false` | Specify a CSS class to be added to empty slots.
    |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `placeholder` | `false` | 指定要添加到空槽中的 CSS 类。'
- en: '| `revert` | `false` | Enable animation when moving sortables into their new
    slots, once they have been dropped. |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `revert` | `false` | 在可排序项被放置到新位置后启用动画。'
- en: '| `scroll` | `true` | Enable page scrolling when a sortable is moved to the
    edge of the viewport. |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `scroll` | `true` | 当可排序项被移动到视口边缘时，启用页面滚动。'
- en: '| `scrollSensitivity` | `20` | Set how close a sortable must get, in pixels,
    to the edge of the viewport, before scrolling should begin. |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `scrollSensitivity` | `20` | 设置在像素中可排序项必须靠近视口边缘，然后滚动应该开始的距离。'
- en: '| `scrolSpeed` | `20` | Set the distance in pixels that the viewport should
    scroll, when a sortable is dragged within the sensitivity range. |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `scrolSpeed` | `20` | 设置在灵敏度范围内拖动可排序项时视口应该滚动的像素距离。'
- en: '| `tolerance` | `"intersect"` | Control how much of the element being sorted
    must overlap other elements, before the placeholder is moved. Another possible
    value is the string pointer. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `tolerance` | `"intersect"` | 控制必须重叠其他元素的被排序元素的多少，然后占位符被移动。另一个可能的值是字符串 pointer。'
- en: '| `zIndex` | `1000` | Set the CSS `zIndex` of the `sortable` or `helper`, while
    it is being dragged. |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `zIndex` | `1000` | 在拖动期间设置 `sortable` 或 `helper` 的 CSS `zIndex`。'
- en: 'Let''s work some of these properties into our previous example to get a feel
    for the effect they have on the behavior of the component. First wrap the `#sortables`
    container in a new `<div>`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其中一些属性融入到我们之前的示例中，以便了解它们对组件行为的影响。首先，在一个新的`<div>`中包装`#sortables`容器：
- en: '[PRE29]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then change the final `<script>` element in `sortable2.html`, so that it appears
    as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将 `sortable2.html` 中的最终 `<script>` 元素更改为以下内容：
- en: '[PRE30]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Save this as `sortable3.html`. We also need to add a little padding to our
    new container element. Update `sortable.css`, so that it contains the following
    new code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存为 `sortable3.html`。我们还需要为新容器元素添加一点内边距。更新 `sortable.css`，使其包含以下新代码：
- en: '[PRE31]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Resave this file as `sortableContainer.css` and update the `<link>` in the `<head>`
    of `sortable3.html`, so that it points to the new stylesheet.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件另存为`sortableContainer.css`，并在`sortable3.html`的`<head>`中更新`<link>`，使其指向新样式表。
- en: 'We use four options in our configuration object: `axis`, `containment`, `resize,`and
    `distance`. Let''s take a look at the role they perform:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配置对象中使用了四个选项：`axis`、`containment`、`resize`和`distance`。让我们看看它们的作用：
- en: The `axis` option is set to `y`, to constrain the motion of the sortable currently
    being dragged to just up-and-down.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`axis`选项设置为`y`，以限制当前被拖动的可排序元素的运动只在上下方向。'
- en: The `containment` option specifies the element that the sortables should be
    contained within, to limit the bounds of their movement.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`containment`选项指定了可排序元素应该被包含在其中的元素，以限制它们的移动范围。'
- en: The `cursor` option that automatically adds the CSS `ns-resize` cursor. In a
    similar fashion to the draggable component that we looked at in [Chapter 11](ch11.html
    "Chapter 11. Drag and Drop"), *Drag and Drop*, the cursor is not actually displayed
    until the sort begins.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cursor`选项会自动添加CSS `ns-resize`光标。与我们在[第11章](ch11.html "Chapter 11. Drag and
    Drop")中讨论的拖放组件*拖放*类似，光标实际上直到排序开始才显示。'
- en: The `distance` option is configured with a value of `30`, which specifies that
    the mouse pointer should move `30` pixels before the sort begins. It works in
    the same way with sortables as it did with draggables, and is great for preventing
    unwanted sorts, but in practice, we'd probably use a much lower threshold than
    30 pixels.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distance`选项配置为`30`，表示鼠标指针在排序开始之前应该移动`30`像素。它与可拖动的元素一样工作，非常适合防止不必要的排序，但在实践中，我们可能会使用比30像素更低的阈值。'
- en: Tip
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Sortable spacing**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**可排序的间距**'
- en: Care should be taken when using the `containment` option. This is specifically
    why we added some padding to the container element in our stylesheet. Without
    this padding, the first sortable element is flushed against the top of the container
    and the last element is flushed against the bottom. In order to be able to push
    a sortable element out of the way, there must be some space above or below it.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`containment`选项时应格外小心。这就是为什么我们在样式表中为容器元素添加了一些填充的原因。没有这些填充，第一个可排序元素与容器顶部贴合，最后一个元素与底部贴合。为了能够将一个可排序元素挤开，必须在它上面或下面留出一些空间。
- en: Let's look at some more options. In this next example, we'll adapt the code
    from `sortable3.html` to restrict the handle of each item to a specific part of
    the item. We will also prevent jQuery UI from allow sorting until a certain time
    has passed.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看更多的选项。在这个示例中，我们将从`sortable3.html`中的代码调整，以限制每个项目的操作手柄到特定的部分。我们还将阻止jQuery
    UI在一定时间过去之前允许排序。
- en: 'Change the underlying `<div>` elements in `sortable3.html`, so that they appear
    as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`sortable3.html`中的基础`<div>`元素，使其显示如下：
- en: '[PRE32]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can get rid of the `#container` element for this example. We also need a
    modified stylesheet for this example. Change `sortable.css`, so that it includes
    the following new styles:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们可以去掉`#container`元素。我们还需要一个修改过的样式表。修改`sortable.css`，使其包含以下新样式：
- en: '[PRE33]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Save the new stylesheet as `sortableHandles.css` in the `css` folder and update
    the `<link>` element to point to the new stylesheet.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将新的样式表另存为`sortableHandles.css`在`css`文件夹中，并更新`<link>`元素指向新样式表。
- en: 'Finally, change the configuration object as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将配置对象修改如下：
- en: '[PRE34]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Save this as `sortable4.html`. We've made a slight change to the page. Within
    each sortable element is a new `<span>` element that will be used as the sort
    handle. We give this element some CSS Framework classes in order to reduce the
    CSS we need to add manually.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 另存为`sortable4.html`。我们对页面进行了轻微的更改。在每个可排序元素内部是一个新的`<span>`元素，将用作排序操作手柄。我们给这个元素添加了一些CSS框架类，以减少我们需要手动添加的CSS。
- en: The `revert` option has a default value of `true`, but can also take one of
    the speed integer or string values (`slow`, `normal`, or `fast`) that we've seen
    in other animation options in other components.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`revert`选项的默认值为`true`，但也可以采用我们在其他组件的其他动画选项中见过的速度整数或字符串值（`slow`、`normal`或`fast`）。'
- en: The `delay` option accepts a value in milliseconds that the component should
    wait, before allowing the sort to begin. If the mouse pointer is moved away from
    the handle while the left-button is held down, the sort will still occur after
    the specified time. If the mouse-button is released, however, the sort will be
    canceled.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`delay`选项接受一个以毫秒为单位的值，组件应该在允许排序开始之前等待的时间。如果鼠标指针在按住左键的同时移动到手柄以外，排序仍将在指定的时间后发生。然而，如果释放鼠标按钮，则排序将被取消。'
- en: The value of the `opacity` option is used to specify the CSS opacity of the
    element that is being sorted, while the sort takes place. The value should be
    a floating-point number between `0` and `1`, with `1` corresponding to full opacity
    and `0` specifying no opacity.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`opacity`选项的值用于指定在排序进行时正在排序的元素的 CSS 不透明度。该值应为介于`0`和`1`之间的浮点数，其中`1`对应于完全不透明，`0`指定不透明度为零。'
- en: Another option we've used is the `handle` option, which allows us to define
    a region within the sortable that must be used to initiate the sort. Dragging
    on other parts of the sortable will not cause the sort to begin.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的另一个选项是`handle`选项，它允许我们定义一个在可排序内必须用于启动排序的区域。在可排序的其他部分拖动将不会导致排序开始。
- en: 'You can see how the handle will appear in the following screenshot:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下屏幕截图中看到手柄的外观：
- en: '![Configuring sortable options](img/2209OS_13_10.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![配置可排序选项](img/2209OS_13_10.jpg)'
- en: Tip
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Make my handles bigger**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**使我的手柄更大**'
- en: For usability reasons, we should probably use a bigger handle than the one used
    in the previous example.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 出于可用性原因，我们可能应该使用比上一个示例中使用的更大的手柄。
- en: Placeholders
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 占位符
- en: A placeholder defines the empty space or slot that is left, while one of the
    sortables is in the process of being moved to its new position. The placeholder
    isn't rigidly positioned. It will dynamically move to whichever sortable has been
    displaced by the movement of the sortable that is being sorted.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符定义了在将一个可排序元素移动到新位置的过程中留下的空白区域或插槽。占位符位置不是固定的。它将动态移动到任何被正在排序的可排序元素的移动所取代的可排序元素。
- en: 'There are two options that are specifically concerned with placeholders the
    very aptly named `placeholder` option and the `forcePlaceholderSize` option. Let''s
    take a look at these two options in action. Remove the `<span>` elements from
    the sortable `<div>` elements in `sortable4.html` and then change the configuration
    object, so that it appears as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个选项专门涉及占位符，非常贴切地命名为`placeholder`选项和`forcePlaceholderSize`选项。让我们看看这两个选项是如何运作的。从`sortable4.html`中的可排序`<div>`元素中删除`<span>`元素，然后更改配置对象，使其显示如下：
- en: '[PRE35]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Save this as `sortable5.html`. Next, we should add the new selector and rules
    to a CSS file. Change `sortable.css`, so that it contains the following styles:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存为`sortable5.html`。接下来，我们应该将新的选择器和规则添加到一个 CSS 文件中。修改`sortable.css`，使其包含以下样式：
- en: '[PRE36]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Save this as `sortablePlaceholder.css` in the `css` folder.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存为`css`文件夹中的`sortablePlaceholder.css`。
- en: The `placeholder` option allows us to define a CSS class that should be added
    to the placeholder element. This is a useful property that we can use often in
    our implementations. Remember this is a class name, not a class selector, so no
    period is used at the start of the string. It can accept multiple classnames.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`placeholder`选项允许我们定义一个应该添加到占位符元素的 CSS 类。这是一个我们在实现中经常可以使用的有用属性。请记住这是一个类名，而不是类选择器，因此字符串开头不使用句点。它可以接受多个类名。'
- en: The `forcePlaceholderSize` option ensures that the placeholder is the same size
    as the actual sortables. If we left this option at its default value of `false`,
    in this example, the placeholder would just be a thin line made up of the padding
    that we applied to the sortable `<div>` elements.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`forcePlaceholderSize`选项确保占位符与实际可排序元素的大小相同。如果我们将此选项保持默认值`false`，在这个示例中，占位符将只是由我们应用于可排序`<div>`元素的填充组成的一条细线。'
- en: 'When we run the new HTML file in a browser, we should be able to see the specified
    styles applied to the placeholder, while the sort is taking place:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中运行新的 HTML 文件时，应该能够看到指定的样式应用于占位符，在排序进行时：
- en: '![Placeholders](img/2209OS_13_11.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![占位符](img/2209OS_13_11.jpg)'
- en: Sortable helpers
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可排序助手
- en: We looked at helper/proxy elements back when we looked at the draggables component
    earlier in the book. Helpers can also be defined for sortables that function in
    a similar way to those of the draggable component, although there are some subtle
    differences in this implementation.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书前面看可拖动组件时，我们已经了解了助手/代理元素。助手也可以为可排序元素定义，其功能方式与可拖动组件的方式类似，尽管在此实现中存在一些细微差异。
- en: With sortables, the original sortable is hidden when the sort interaction begins,
    and a clone of the original element is dragged instead. So with sortables, helpers
    are an inherent feature.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可排序组件时，原始的可排序元素在排序交互开始时被隐藏，而是拖动原始元素的克隆。因此，使用可排序组件时，助手是一个固有的特性。
- en: Like with draggables, the `helper` option of sortables may take a function as
    its value. The function, when used, will automatically receive the `event` object
    and an object containing useful properties from the sortable element as arguments.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 与可拖动项一样，可排序的`helper`选项可能将函数作为其值。当使用时，该函数将自动接收`event`对象和包含来自可排序元素的有用属性的对象作为参数。
- en: 'The function must return the element to use as a helper. Although it''s very
    similar to the draggable helper example, let''s take a quick look at it when used
    in conjunction with sortables. In `sortable5.html`, change the last `<script>`
    block, so that it appears as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 函数必须返回要用作助手的元素。虽然与可拖动助手示例非常相似，但让我们快速看一下在与可排序一起使用时。在`sortable5.html`中，更改最后一个`<script>`块，使其如下所示：
- en: '[PRE37]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Save this file as `sortable6.html`. We define a `helperMaker` function that
    creates and returns the element to be used as the helper, while the sort is in
    progress. We set some basic CSS properties on the new element, so that we don't
    need to provide additional rules in the stylesheet.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`sortable6.html`。我们定义了一个`helperMaker`函数，该函数创建并返回在排序进行时要使用的元素。我们在新元素上设置了一些基本的CSS属性，这样我们就不需要在样式表中提供额外的规则了。
- en: 'The following screenshot shows how the helper will appear while a sort is taking
    place:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了排序进行时助手的外观：
- en: '![Sortable helpers](img/2209OS_13_12.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![可排序助手](img/2209OS_13_12.jpg)'
- en: Sortable items
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可排序项
- en: By default, all children of the element that the method is called on are turned
    into sortables. While this is a useful feature of the component, there may be
    times when we don't necessarily want all child elements to become sortable.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，调用该方法的元素的所有子元素都会变成可排序。虽然这是组件的一个有用功能，但有时我们不一定希望所有子元素都变为可排序。
- en: 'The `items` option controls which child elements of the specified element should
    be made sortable. It makes all child elements sortable using the string `>*` as
    its default value, but we can alter this to specify only the elements we want.
    Change the sortable `<div>` elements in `sortable6.html`, so that the last element
    has a new class name:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`items`选项控制应将指定元素的哪些子元素设置为可排序。它使用字符串`>*`作为其默认值使所有子元素可排序，但我们可以更改此值以指定我们想要的元素。更改`sortable6.html`中的可排序`<div>`元素，以便最后一个元素具有新的类名：'
- en: '[PRE38]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, change the configuration object to make use of the `items` option:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，更改配置对象以利用`items`选项：
- en: '[PRE39]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Save this as `sortable7.html`. In the `<script>`, we've specified the selector
    `">:not(.unsortable)"` as the value of the `items` option, so the element with
    the classname `unsortable` will not be made sortable, while the rest of the `<div>`
    elements will.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存为`sortable7.html`。在`<script>`中，我们指定了选择器`">:not(.unsortable)"`作为`items`选项的值，因此具有类名`unsortable`的元素将不会被设置为可排序，而其他`<div>`元素将会被设置为可排序。
- en: When we run the page in a browser, we should find that the last item in the
    collection cannot be sorted, and other sortable items cannot be moved into the
    space that the last item occupies.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中运行页面时，我们应该发现集合中的最后一个项目无法排序，并且其他可排序项目无法移动到最后一个项目占用的空间中。
- en: Connecting lists
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接列表
- en: So far, the examples that we have looked at have all centered on a single list
    of sortable items. What happens when we want to have two lists of sortable items,
    and more importantly, can we move items from one list to another?
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所看到的示例都集中在单个可排序项目列表上。当我们想要有两个可排序项目列表时会发生什么，更重要的是，我们是否可以将项目从一个列表移动到另一个列表？
- en: Having two sortable lists is of course extremely easy and involves simply defining
    two containers and their child elements, and then passing a reference to each
    container to the `sortable()` method.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，拥有两个可排序列表非常容易，只需要简单地定义两个容器及其子元素，然后将对每个容器的引用传递给`sortable()`方法即可。
- en: Allowing separate lists of sortables to exchange and share sortables is also
    extremely easy. This is thanks to the `connectWith` option, which allows us to
    define an array of sortable containers, who can share their sortable contents.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 允许单独的可排序列表交换和共享可排序项也非常容易。这要归功于 `connectWith` 选项，它允许我们定义一个可排序容器数组，这些容器可以共享它们的可排序内容。
- en: 'Let''s look at this in action. Change the underlying markup on the page, so
    that it appears as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何起作用的。更改页面上的底层标记，使其如下所示：
- en: '[PRE40]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Everything on the page is pretty similar to what we have worked with before.
    We also need a new stylesheet for this example. In a new file, add the following
    styles:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 页面上的一切与我们之前使用的内容非常相似。对于此示例，我们还需要一个新的样式表。在一个新文件中，添加以下样式：
- en: '[PRE41]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Save this as `sortableConnected.css` in the `css` folder. Don''t forget to
    point to the new stylesheet in the `<head>` of the new page. Finally, change the
    last `<script>` element, so that it appears as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存为 `sortableConnected.css` 在 `css` 文件夹中。不要忘记在新页面的 `<head>` 中指向新样式表。最后，更改最后一个
    `<script>` 元素，使其如下所示：
- en: '[PRE42]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Save this as `sortable8.html`. We still define a single configuration object,
    which can be shared between both sets of sortable elements. The `connectWith`
    option is able to accept multiple selectors if they are passed in as an array,
    and it's this option that allows us to share individual sortables between the
    two sortable containers.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存为 `sortable8.html`。我们仍然定义一个单一的配置对象，可以在两组可排序元素之间共享。`connectWith` 选项能够接受多个选择器，如果它们作为数组传递，正是这个选项允许我们在两个可排序容器之间共享个别可排序项。
- en: This configuration option only provides a one-way transmission of sortables,
    so if we were to only use the configuration object with `sortablesA` and specify
    just the selector `#sortablesB`, we would only be able to move items from `sortablesA`
    to `sortablesB`, not the other way.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置选项仅提供可排序的单向传输，因此如果我们只使用配置对象与 `sortablesA` 并仅指定选择器 `#sortablesB`，我们只能从 `sortablesA`
    移动项目到 `sortablesB`，而不能反之。
- en: Specifying both sortables' `id` attributes in the option and selecting both
    of the containers when calling the `sortable()` method allows us to move items
    between both elements, and allows us to cut down on coding.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在选项中同时指定可排序的 `id` 属性，并在调用 `sortable()` 方法时选择两个容器，允许我们在两个元素之间移动项目，并且可以减少编码量。
- en: 'When we run the page in a browser, we find that not only can the individual
    items be sorted in their respective elements, but that items can also be moved
    between elements, as shown in the following screenshot:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行页面时，我们发现不仅可以对各个项目在各自的元素中进行排序，还可以在元素之间移动项目，如下面的屏幕截图所示：
- en: '![Connecting lists](img/2209OS_13_13.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![连接列表](img/2209OS_13_13.jpg)'
- en: Reacting to sortable events
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对可排序事件作出反应
- en: 'In addition to the already large list of configurable options defined in the
    sortables class, there are also a whole lot more in the form of event callbacks,
    which can be passed as functions to execute at different points during a sortable
    interaction. These are listed in the following table:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在可排序类中已定义的可配置选项的大列表外，还有更多的事件回调形式的选项，它们可以作为函数传递，在可排序交互的不同点执行。这些列在下表中列出：
- en: '| Event | Fired when… |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 事件 | 当……时触发 |'
- en: '| --- | --- |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `activate` | Sorting starts on a connected list. |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| `activate` | 在连接的列表上开始排序。 |'
- en: '| `beforeStop` | The sort has stopped, but the original slot is still available.
    |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `beforeStop` | 排序已停止，但原始插槽仍然可用。'
- en: '| `change` | The DOM position of a sortable has changed and the sort is still
    in progress. |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `change` | 可排序的 DOM 位置已更改，排序仍在进行中。 |'
- en: '| `create` | The widget is initialized. |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `create` | 小部件已初始化。 |'
- en: '| `deactivate` | Sorting stops on a connected list. |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `deactivate` | 在连接的列表上停止排序。 |'
- en: '| `out` | A sortable is moved out of a connected list. |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `out` | 可排序已从连接的列表中移出。 |'
- en: '| `over` | A sortable is over a connected list. This is great for providing
    visual feedback while a sort is taking place. |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `over` | 可排序是指与连接列表一起使用。这在排序进行时提供视觉反馈非常有用。'
- en: '| `receive` | A sortable is received from a connected list. |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `receive` | 从连接的列表中接收到可排序。 |'
- en: '| `remove` | A sortable is moved from a connected list. |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| `remove` | 可排序从连接的列表中移动。 |'
- en: '| `sort` | A sort is taking place. |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `sort` | 排序正在进行。 |'
- en: '| `start` | A sort starts. |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `start` | 开始排序。 |'
- en: '| `stop` | A sort ends. |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `stop` | 结束排序。 |'
- en: '| `update` | The sort has ended and the DOM position has changed. |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `update` | 排序已结束，DOM 位置已更改。 |'
- en: Each of the components that we've looked at in the preceding chapters has defined
    its own suite of custom events, and the sortables component is no exception.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面章节中查看的每个组件都定义了自己一套自定义事件，并且可排序组件也不例外。
- en: 'Many of these events will fire during any single sort interaction. The following
    list shows the order in which they will fire:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何单个排序交互过程中，许多这些事件都会触发。以下列表显示了它们触发的顺序：
- en: start
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: start
- en: sort
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sort
- en: change
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: change
- en: beforeStop
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: beforeStop
- en: stop
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: stop
- en: update
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: update
- en: As soon as one of the sortables is picked up, the `start` event is triggered.
    Following this, on every single mouse move, the `sort` event will fire, making
    this event very intensive.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦拿起其中一个可排序项，就会触发 `start` 事件。随后，在每次鼠标移动时，都会触发 `sort` 事件，使此事件非常密集。
- en: As soon as another item is displaced by the current sortable, the `change` event
    is fired. Once the sortable is dropped, the `beforeStop` and `stop` events fire,
    and if the sortable is now at a different position, the `update` event is fired
    last of all.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦当前可排序项排开了另一个项目，就会触发 `change` 事件。一旦可排序项被放下，就会触发 `beforeStop` 和 `stop` 事件，如果可排序项现在处于不同位置，则最后触发
    `update` 事件。
- en: 'For the next few examples, we''ll work some of these event handling options
    into the previous example, starting with the `start` and `stop` events. Change
    the configuration object in `sortable8.html`, so that it appears as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个示例中，我们将把其中一些事件处理选项整合到之前的示例中，从 `start` 和 `stop` 事件开始。将 `sortable8.html`
    中的配置对象更改为以下内容：
- en: '[PRE43]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Save this as `sortable9.html`. Our event usage in this example is minimal. When
    the sort starts, we simply create a new paragraph element and add some text to
    it, including the text content of the element that is being sorted. The text message
    is then duly appended to the `<body>` of the page. When the sort stops, we remove
    the text. Using the second object passed to the callback function is very easy,
    as you can see. The object itself refers to the parent sortables container, and
    the `helper` property refers to the actual item being sorted (or its helper).
    As this is a jQuery object, we can call jQuery methods, such as `text`, on it.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存为 `sortable9.html`。我们在此示例中对事件的使用很少。当排序开始时，我们只需创建一个新的段落元素并向其添加一些文本，其中包括正在排序的元素的文本内容。然后将文本消息追加到页面的
    `<body>`。当排序结束时，我们将删除文本。如您所见，使用传递给回调函数的第二个对象非常容易。该对象本身指的是父级可排序的容器，`helper` 属性指的是实际被排序的项目（或其辅助程序）。由于这是一个
    jQuery 对象，因此我们可以在其上调用 jQuery 方法，例如 `text`。
- en: When we run the page, the message should appear briefly until the sort ends,
    at which point it's removed.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行页面时，消息应该会在排序结束之前短暂出现，然后被移除。
- en: '![Reacting to sortable events](img/2209OS_13_14.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![对可排序事件的反应](img/2209OS_13_14.jpg)'
- en: Let's look at one more of these simple callbacks, before we move on to look
    at the additional callbacks used with connected sortables. In our next example,
    we will take a look at how we can track movement of sortable items between lists,
    and use a callback function to display the results on screen.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在继续查看与连接的可排序项一起使用的附加回调函数之前，再看一个这样简单的回调函数。在我们的下一个示例中，我们将看看如何跟踪可排序项在列表之间的移动，并使用回调函数将结果显示在屏幕上。
- en: 'Change the final `<script>` element in `sortable9.html` to the following:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `sortable9.html` 中的最终 `<script>` 元素更改为以下内容：
- en: '[PRE44]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Save this as `sortable10.html`. In this example, we work with the `receive`
    and `beforeStop` callbacks to provide a message, indicating the position within
    the list that any sortable is moved to, as well as which list it is in. We also
    make use of the `ui.item` property from the object, which is automatically passed
    to any callback functions used by the events.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存为 `sortable10.html`。在此示例中，我们使用 `receive` 和 `beforeStop` 回调来提供一条消息，指示可排序项移动到列表中的位置，以及它位于哪个列表中。我们还利用了自动传递给事件使用的任何回调函数的对象的
    `ui.item` 属性。
- en: We first define a variable called `extraMessage`, which is initially set to
    an empty string. We then define a function called `getPlaces`. This function will
    be used as a callback function for sortable events and will, therefore, automatically
    receive `e` and `ui` objects.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个名为 `extraMessage` 的变量，最初将其设置为空字符串。然后我们定义一个名为 `getPlaces` 的函数。该函数将用作可排序事件的回调函数，并因此会自动接收
    `e` 和 `ui` 对象。
- en: Within the function, we first check whether the event object's type property
    has a value of `sortreceive`; if it does, we know that a sortable has moved lists
    and can, therefore, set the extra part of the message.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我们首先检查事件对象的 `type` 属性是否具有值 `sortreceive`；如果是，则我们知道可排序已经移动到其他列表中，因此可以设置消息的额外部分。
- en: We then remove any pre-existing messages, before creating a new `<p>` element
    and setting a message, indicating its new position in the list. We can obtain
    the new position of the element that was sorted using the `item` property of the
    second object passed to our callback in conjunction with jQuery's `index()` method,
    which we convert to a string and concatenate into a message.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们移除任何现有消息，然后创建一个新的 `<p>` 元素并设置一条消息，指示其在列表中的新位置。我们可以使用传递给我们回调函数的第二个对象的 `item`
    属性以及 jQuery 的 `index()` 方法获取已排序元素的新位置，然后将其转换为字符串并连接成一条消息。
- en: In our configuration object, we connect the two lists using the `connectWith`
    option as before, and make use of both the `receive` and `beforeStop` options,
    which both point to our `getPlaces` function.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配置对象中，我们使用与之前相同的 `connectWith` 选项连接两个列表，并利用 `receive` 和 `beforeStop` 选项，它们都指向我们的
    `getPlaces` 函数。
- en: The `receive` event is fired whenever a sortable container receives a new sortable
    element from a connected list. The `beforeStop` event is fired just before the
    sort interaction ends. In terms of event order, in this example the `beforeStop`
    event is fired first, followed by the `receive` event.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当可排序容器从连接列表接收到新的可排序元素时，`receive` 事件才会触发。在事件顺序方面，在此示例中，`beforeStop` 事件首先触发，然后是
    `receive` 事件。
- en: 'The `receive` event will only be fired if a sortable element moves to a new
    sortable container. The following screenshot shows how the page should look following
    a sort interaction:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当可排序元素移动到新的可排序容器时，`receive` 事件才会触发。以下截图显示了在排序交互后页面应该呈现的样子：
- en: '![Reacting to sortable events](img/2209OS_13_15.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![对可排序事件的反应](img/2209OS_13_15.jpg)'
- en: Connecting callbacks
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接回调
- en: Six of the available callbacks can be used in conjunction with connected sortables.
    These events fire at different times during an interaction, alongside the events
    that we have already looked at.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 六个可用的回调函数可以与连接的可排序元素一起使用。这些事件在交互过程中的不同时间触发，与我们已经查看过的事件一起触发。
- en: Like the standard unconnected events, not all of the connected events will fire
    in any single interaction. Some events, such as `over`, `off`, `remove`, and `receive`
    will fire only if a sort item moves to a new list.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 像标准未连接的事件一样，不是所有连接的事件都会在任何单个交互中触发。某些事件，如 `over`、`off`、`remove` 和 `receive`，只有在排序项目移动到新列表时才会触发。
- en: 'Other events, such as `activate` and `deactivate`, will fire in all executions,
    whether any sort items change lists or not. Additionally, some connected events,
    such as `activate` and `deactivate`, will fire for each connected list on the
    page. Provided at least one item is moved between lists, events will fire in the
    following order:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 其他事件，如 `activate` 和 `deactivate`，将在所有执行中触发，无论排序项是否更改列表。此外，一些连接事件，如 `activate`
    和 `deactivate`，将为页面上的每个连接列表触发。只要至少有一个项目在列表之间移动，事件将按以下顺序触发：
- en: start
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始
- en: activate
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活
- en: sort
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 排序
- en: change
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改
- en: beforeStop
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止前
- en: stop
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止
- en: remove
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除
- en: update
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新
- en: receive
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收
- en: deactivate
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停用
- en: 'Let''s now see some of these connected events in action. Change the final `<script>`
    element in `sortable10.html`, so that it appears as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看这些连接事件如何发挥作用。将 `sortable10.html` 中的最后一个 `<script>` 元素更改为以下内容：
- en: '[PRE45]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Save this as `sortable11.html`. The `activate` and `deactivate` events are fired
    for each connected list at the start of any sort interaction. Within our callback
    functions, `$(this)` refers to each sortable container. We can easily determine
    which sortable list the item originated in using the `sender` property of the
    second object, passed to our function.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 将其保存为 `sortable11.html`。`activate` 和 `deactivate` 事件会在任何排序交互开始时为每个连接的列表触发。在我们的回调函数中，`$(this)`
    指的是每个可排序容器。我们可以使用传递给我们函数的第二个对象的 `sender` 属性轻松确定项目源自哪个可排序列表。
- en: 'When we run the page in a browser, we see that as soon as a sort begins, both
    of the sortables are activated, and when the sort ends, both of them are deactivated.
    If an item is moved between lists, the message generated by the `receive` callback
    is shown in the following screenshot:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中运行页面时，我们会看到一旦排序开始，两个可排序元素都被激活，当排序结束时，它们都被停用。如果一个项目在列表之间移动，`receive`
    回调生成的消息如下截图所示：
- en: '![Connecting callbacks](img/2209OS_13_16.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![连接回调](img/2209OS_13_16.jpg)'
- en: Listing the sortable methods
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出可排序方法
- en: 'The sortables component exposes the usual set of methods for making the component
    perform actions. Like the selectables component that we looked at before, it also
    defines a couple of unique methods not seen in any of the other components. The
    following table lists sortables'' unique methods:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 可排序组件提供了一套通常用于使组件执行操作的方法。与之前查看过的可选择组件一样，它还定义了一些其他组件中没有的独特方法。以下表格列出了可排序的独特方法：
- en: '| Method | Used to… |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 用途 |'
- en: '| --- | --- |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `cancel` | Cancel the sort and cause elements to return to their original
    positions. |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| `cancel` | 取消排序并使元素返回到原始位置。 |'
- en: '| `refresh` | Reload the set of sortables. |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| `refresh` | 重新加载可排序集合。 |'
- en: '| `refreshPositions` | Trigger a cache refresh of the set of sortables. |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| `refreshPositions` | 触发可排序集合的缓存刷新。 |'
- en: '| `serialize` | Construct a query string that can be used to send a new sort
    order to the server, for further processing or storage. |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| `serialize` | 构造一个查询字符串，可用于将新的排序顺序发送到服务器进行进一步处理或存储。 |'
- en: '| `toArray` | Serialize the sortables into an array of strings. |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| `toArray` | 将可排序序列化为字符串数组。 |'
- en: Serializing
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化
- en: The `serialize` and `toArray` methods are great for storing the new order of
    the sortables. Let's see this in action. We will create a series of sortable elements,
    and then set Sortable to display their order. This will be updated on screen each
    time you move one of the elements around.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`serialize` 和 `toArray` 方法非常适合存储可排序的新顺序。让我们看看这是如何实现的。我们将创建一系列可排序元素，然后设置 Sortable
    来显示它们的顺序。每次移动其中一个元素时，屏幕上将更新显示这个顺序。'
- en: 'Change the underlying markup on the `<body>` of the page in `sortable11.html`
    to as follows:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 更改 `sortable11.html` 页面的 `<body>` 下面的底层标记如下：
- en: '[PRE46]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then change the final `<script>` element, so that it appears as follows:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 然后更改最后的 `<script>` 元素，使其显示如下：
- en: '[PRE47]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Save this as `sortable12.html`. We've dropped the second set of sortables for
    this example and have added `id` attributes to each of the sortable items in the
    format of the name of the parent sortable and a number, separated by an underscore.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存为 `sortable12.html`。在此示例中，我们删除了第二组可排序，并为每个可排序项目添加了以父可排序名称和数字以下划线分隔的 `id`
    属性。
- en: We use the `stop` event to execute an anonymous function, after each sort interaction.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `stop` 事件在每次排序交互后执行匿名函数。
- en: 'Within this function, we store the result of the `serialize` method in the
    `order` variable, and then display this variable in a new `<p>` element on the
    page:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数内，我们将 `serialize` 方法的结果存储在 `order` 变量中，然后在页面上的新 `<p>` 元素中显示此变量：
- en: '![Serializing](img/2209OS_13_17.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![序列化](img/2209OS_13_17.jpg)'
- en: 'As you can see, the format of the serialized string is quite straightforward.
    The sortable items appear in the order that the items appear on the page, and
    are separated by an ampersand. Each serialized item is made up of two parts: a
    hash of the `id` attribute of each sortable item followed by an integer representing
    the item''s new order.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，序列化字符串的格式非常简单明了。可排序项目按照它们在页面上出现的顺序排列，并用和号分隔。每个序列化的项目由两部分组成：每个可排序项目的 `id`
    属性的哈希，后跟表示项目新顺序的整数。
- en: In the previous example, all we do is display the serialized string on the page,
    but the string is in the perfect format for use with jQuery's `ajax` method to
    pass to a server for further processing.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们只是在页面上显示了序列化的字符串，但该字符串的格式非常适合与 jQuery 的 `ajax` 方法一起使用，以将其传递给服务器进行进一步处理。
- en: 'The `serialize` method is also able to accept a configuration object to tailor
    how the serialization occurs. The options we can configure are listed in the following
    table:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`serialize` 方法还能接受一个配置对象以定制序列化的方式。我们可以配置的选项列在下表中：'
- en: '| Option | Default value | Used to… |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 默认值 | 用途 |'
- en: '| --- | --- | --- |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `attribute` | `id` | Specify the attribute to use when parsing each item
    in the list of sortables and generating the hash. |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| `attribute` | `id` | 指定用于解析可排序列表中每个项目并生成哈希的属性。 |'
- en: '| `connected` | `false` | Include all connected lists in the serialization.
    |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| `connected` | `false` | 包括所有连接列表在序列化中。 |'
- en: '| `expression` | `"(.+)[-=_](.+)"` | Specify the `regexp` to use to parse the
    sortable list. |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| `expression` | `"(.+)[-=_](.+)"` | 指定用于解析可排序列表的正则表达式。 |'
- en: '| `key` | `The first part of the id attribute of each sortable item` | Specify
    the string to be used as the first part of each item in the serialized output.
    |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| `key` | `每个可排序项的id属性的第一部分` | 指定在序列化输出中每个项目的第一部分要使用的字符串。'
- en: The `toArray` method works in a similar way to serialize, except that with `toArray`,
    the output is not a string, but an array of strings.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`toArray`方法的工作方式与`serialize`类似，不同之处在于`toArray`的输出不是一个字符串，而是一组字符串的数组。'
- en: Exploring widget compatibility
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索小部件兼容性
- en: 'In the previous chapter, we saw that both the resizable and the selectable
    components worked well with the tabs widget (and we already know how well the
    dialog and resizables components go together). The sortable component is also
    highly compatible with other widgets. Let''s look at a basic example. In a new
    file in your text editor, add the following code:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到可调整大小和可选组件与选项卡小部件一起工作得很好（我们已经知道对话框和可调整大小组件是多么完美的组合）。可排序组件也与其他小部件高度兼容。让我们看一个基本的例子。在你的文本编辑器中新建一个文件，添加如下代码：
- en: '[PRE48]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Save this page as `sortable13.html`. There is nothing in the code that we haven't
    seen before, so we won't go into any great detail about it. Note that only the
    `tabs()` and `sortable()` methods are called on the same element—the outer containing
    the `<div>` element.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 将此页面保存为`sortable13.html`。在代码中没有什么是我们之前没有见过的，所以我们不会详细解释。请注意，`tabs()`和`sortable()`方法仅在相同的元素上调用——外部包含`<div>`元素。
- en: When we run the page in a browser, we should find that the components work in
    exactly the way that we want them to. The tabs can be sorted horizontally to any
    order, but as the tabs are linked to their panel by `href`, they will still show
    the correct panel, when selected.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中运行页面时，应该会发现组件的工作方式正是我们想要的。选项卡可以按水平顺序排序，但由于选项卡通过`href`链接到它们的面板，所以当被选中时，它们仍会显示正确的面板。
- en: 'Sorting the tabs works on the `mousedown` event and selecting the tabs works
    on the `mouseup` event, so there are no event collisions and no situations arising
    where you want to select a tab, but end up sorting it. The following screenshot
    shows how the tabs may appear after sorting:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 对选项卡进行排序在`mousedown`事件上工作，而选择选项卡在`mouseup`事件上工作，因此不存在事件冲突，也不会在您想要选择选项卡的时候却最终对其进行排序的情况发生。以下屏幕截图展示了排序后选项卡的外观：
- en: '![Exploring widget compatibility](img/2209OS_13_18.jpg)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![探索小部件兼容性](img/2209OS_13_18.jpg)'
- en: Adding draggables
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加可拖动元素
- en: When we looked at draggables and droppables, earlier in the book, we saw that
    there was a configuration option for draggables called `connectToSortable`. Let's
    take a look at that option now that we've been introduced to the fundamentals
    of the sortables component. In this example, we'll create a sortable task list
    that can have new tasks dragged into it.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本书前面看过可拖动和可放置组件时，我们看到了可拖动组件的`connectToSortable`配置选项。现在我们已经介绍了可排序组件的基本知识，让我们来看一下这个选项。在这个例子中，我们将创建一个可排序的任务列表，可以将新任务拖放进去。
- en: 'The resulting page will appear as follows:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 结果页面将如下所示：
- en: '![Adding draggables](img/2209OS_13_19.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![添加可拖动元素](img/2209OS_13_19.jpg)'
- en: 'In a new file in your text editor, add the following code:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的文本编辑器中新建一个文件，添加如下代码：
- en: '[PRE49]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Save this as `sortable14.html`. On the page, we have a couple of `<ul>` elements:
    the first contains a single item that provides an instruction to the visitor and
    the second is the task list. The second list is wrapped in a container `<div>`,
    mostly for styling purposes.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 将其保存为`sortable14.html`。在页面中，我们有两个`<ul>`元素：第一个包含一项指示访问者的指令，第二个是任务列表。第二个列表被包裹在一个`<div>`容器中，大部分是为了样式目的。
- en: 'We also use a new stylesheet for this example. Add the following code to a
    new page in your text editor:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为这个例子使用一个新的样式表。将以下代码添加到文本编辑器中的新页面：
- en: '[PRE50]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Save this as `sortableTasks.css` in the `css` folder. Mostly this is just decorative,
    superficial stuff for the purposes of the example.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 将其保存为`sortableTasks.css`，放在`css`文件夹中。大部分都是用于示例装饰和表面上的东西。
- en: 'Finally, we can add the script that wires it all up. Add the following `<script>`
    element, after the library resources:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以添加连接所有内容的脚本。在库资源之后添加以下`<script>`元素：
- en: '[PRE51]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We first cache a couple of selectors that we''ll be using frequently throughout
    the script:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先缓存了一些我们脚本中将经常使用的选择器：
- en: '[PRE52]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We then define and initialize the configuration object for the sortables. Sorting
    is restricted to the vertical axis and a callback function specified for the `stop`
    event.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义和初始化可排序的配置对象。排序被限制在垂直轴上，并为`stop`事件指定了一个回调函数。
- en: Within this function, we hide the `add` button and reset any text that has been
    added to the draggable, then use the `option` method of the draggable to disable
    dragging on the element, so that the text label cannot be dragged into the task
    list.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数内部，我们隐藏了`add`按钮，并重置了添加到可拖动元素的任何文本，然后使用可拖动的`option`方法禁用了元素的拖动，以便文本标签无法拖动到任务列表中。
- en: 'Additionally, when we set the disabled option of the draggable, it adds a CSS
    framework class that reduces the opacity of the draggable. This is not necessary
    for our example, so we also remove this class name:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当我们设置可拖动的`disabled`选项时，它会添加一个CSS框架类，降低可拖动元素的不透明度。对于我们的示例来说，这是不必要的，因此我们还将删除此类名：
- en: '[PRE53]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Following this, we define and initialize the draggable configuration object
    and set the `connectToSortable` option to an `id` selector that matches the parent
    sortables container, and the `helper` option to clone. The dragging is initially
    disabled:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们定义并初始化了可拖动的配置对象，并将`connectToSortable`选项设置为与父排序容器匹配的`id`选择器，将`helper`选项设置为克隆。拖动最初被禁用：
- en: '[PRE54]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We need to create two helper functions: the first to count the number of items
    in the list, and the second to work out if the `<input>` field has any content:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建两个辅助函数：第一个函数用于计算列表中的项目数量，第二个函数用于判断`<input>`字段是否有任何内容：
- en: '[PRE55]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We add a click handler to the draggable element using jQuery''s `on()` method.
    When the draggable `<li>` is clicked, it checks that there aren''t too many tasks
    in the list already, and if not, it will create a new `<input>` field and append
    it to the `<li>` in the first `<ul>`. The hidden `add` button is also displayed.
    The visitor can then enter a new task and make the new task draggable, by clicking
    on the button:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用jQuery的`on()`方法为可拖动的元素添加了点击处理程序。当点击可拖动的`<li>`时，它会检查列表中是否有太多的任务，如果没有，它将在第一个`<ul>`中创建一个新的`<input>`字段并将其附加到`<li>`中。隐藏的`add`按钮也会显示出来。然后访问者可以输入新任务并使新任务可拖动，方法是点击按钮：
- en: '[PRE56]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We also add a click handler for the `add` button that we create, again using
    jQuery's `on()` method. This function checks that the `<input>` contains some
    text, and provided it does, it then gets the text and then removes the `text`
    field. The text is then added to the draggable `<li>` element, and the `<li>`
    is made draggable by setting the `disabled` option to `false`. Finally, the `<input>`
    is removed, and the message and button are set back to their original state.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为我们创建的`add`按钮添加了一个点击处理程序，再次使用jQuery的`on()`方法。该函数检查`<input>`包含一些文本，并在它确实包含时获取文本，然后删除`text`字段。然后，将文本添加到可拖动的`<li>`元素中，并通过将`disabled`选项设置为`false`来使`<li>`可拖动。最后，移除`<input>`，并将消息和按钮设置回其原始状态。
- en: '[PRE57]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The text box and icon will appear as shown in the following screenshot:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 文本框和图标将显示如下截图所示：
- en: '![Adding draggables](img/2209OS_13_20.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![添加可拖动元素](img/2209OS_13_20.jpg)'
- en: We also add a click handler for the `add` button that we create, again using
    jQuery's `on()` method. This function checks that the `<input>` contains some
    text, and provided it does, it then gets the text and then removes the `text`
    field. The text is then added to the draggable `<li>` element, and the `<li>`
    is made draggable by setting the `disabled` option to `false`. Finally, the `<input>`
    is removed, and the message and button are set back to their original state.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为我们创建的`add`按钮添加了一个点击处理程序，再次使用jQuery的`on()`方法。该函数检查`<input>`包含一些文本，并在它确实包含时获取文本，然后删除`text`字段。然后，将文本添加到可拖动的`<li>`元素中，并通过将`disabled`选项设置为`false`来使`<li>`可拖动。最后，移除`<input>`，并将消息和按钮设置回其原始状态。
- en: Summary
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've finished our tour of the interaction components of the library, by looking
    at the selectable and sortable components. Similar to the other modules that we
    looked at before, both have a wide range of properties and methods that allow
    us to configure and control their behavior and appearance in both simple and more
    complex implementations.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了对库的交互组件的巡回，通过查看可选择和可排序的组件。与之前查看的其他模块类似，这两个模块都具有广泛的属性和方法，允许我们在简单和更复杂的实现中配置和控制其行为和外观。
- en: We started off the chapter with a look at a simple, default implementation of
    the selectable with no configuration to see the most basic level of functionality
    added by the component.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从查看了一个简单的默认可选择实现开始，该实现没有进行任何配置，以查看组件添加的最基本功能水平。
- en: We first looked at the default implementation of a selectable and then moved
    on to look at the configurable options, along the numerous callback properties,
    which can be used to perform different actions at different points in an interaction.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看了可选择内容的默认实现，然后继续研究了可配置选项，以及许多回调属性，这些属性可用于在交互过程中的不同时间执行不同的操作。
- en: Next we looked at how the performance of a page can be improved when there are
    a large number of selectables on the page, and how the single unique method exposed
    by the component, refresh, is used.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看了页面上有大量可选择内容时如何改善页面的性能，以及组件公开的单个唯一方法`refresh`的使用。
- en: Lastly we looked at a fun example that brought together what we had learned
    throughout the chapter and combined the selectables component with the tabs component
    to create an image viewer capable of handling single or multiple selections.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看了一个有趣的例子，将本章学到的内容结合起来，将可选择组件与选项卡组件结合起来，创建了一个能够处理单个或多个选择的图像查看器。
- en: We then moved on to look at some of the different elements that can be made
    sortable and added some basic styling to the page.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续研究了一些可排序的不同元素，并向页面添加了一些基本样式。
- en: Following this, we looked at the range of configurable options that are exposed
    by the sortable API. The list is extensive and provides a wide range of functionality
    that can be enabled or disabled with ease.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们看了可排序 API 公开的一系列可配置选项。列表很长，提供了各种可以轻松启用或禁用的功能。
- en: We moved on to look at the extensive event model used by this component that
    gives us the ability to react to different events, as they occur in any sort operation,
    initiated by the visitor.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续研究了此组件使用的广泛事件模型，这使我们能够对不同事件做出反应，因为它们在由访问者发起的任何排序操作中发生。
- en: Connected lists offer the ability to be able to exchange sortable items between
    lists or collections of sortables. We saw the additional options and events that
    are used specifically with connected sortable lists.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 连接列表提供了在列表或可排序集合之间交换可排序项目的能力。我们看到了专门与连接的可排序列表一起使用的附加选项和事件。
- en: In the last part of the chapter, we looked at the methods available for use
    with the sortables component, and focused on the highly useful `serialize` method,
    and also had a quick look at its compatibility with other members of the jQuery
    UI library in the form of the sortable tabs example. We've now looked at all of
    the current interaction components found in the library. In the next and final
    chapter, we'll look at all of the different animation effects that jQuery UI brings
    to the table.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们看了一下可与可排序组件一起使用的方法，并重点关注了非常有用的`serialize`方法，并快速了解了它与 jQuery UI 库中其他成员的兼容性，例如可排序标签示例。我们现在已经查看了库中找到的所有当前交互式组件。在接下来的最后一章中，我们将看看
    jQuery UI 带来的所有不同动画效果。
