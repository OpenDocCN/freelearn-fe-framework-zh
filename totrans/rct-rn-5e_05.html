<html><head></head><body>
  <div id="_idContainer054" class="Basic-Text-Frame">
    <h1 class="chapterNumber">4</h1>
    <h1 id="_idParaDest-71" class="chapterTitle">Event Handling in the React Way</h1>
    <p class="normal">The focus of this chapter is <strong class="keyWord">event handling</strong>. React has a unique approach to handling events: declaring <a id="_idIndexMarker153"/>event handlers in JSX. We’ll get things started by looking at how event handlers for particular elements are declared in JSX. Then, we’ll explore <strong class="keyWord">inline</strong> and <strong class="keyWord">higher-order event handler</strong> functions.</p>
    <p class="normal">Afterward, you’ll learn <a id="_idIndexMarker154"/>how React maps event handlers <a id="_idIndexMarker155"/>to DOM elements under the hood. Finally, you’ll learn about the synthetic events that React passes to event handler functions and how they’re pooled for performance purposes. Once you’ve completed this chapter, you’ll be comfortable implementing event handlers in your React components. At that point, your applications come to life for your users because they are then able to interact with them.</p>
    <p class="normal">The following topics are covered in this chapter:</p>
    <ul>
      <li class="bulletList">Declaring event handlers</li>
      <li class="bulletList">Declaring inline event handlers</li>
      <li class="bulletList">Binding handlers to elements</li>
      <li class="bulletList">Using synthetic event objects</li>
      <li class="bulletList">Understanding event pooling</li>
    </ul>
    <h1 id="_idParaDest-72" class="heading-1">Technical requirements</h1>
    <p class="normal">The code presented in this chapter can be found at the following link: <a href="https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter04"><span class="url">https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter04</span></a></p>
    <h1 id="_idParaDest-73" class="heading-1">Declaring event handlers</h1>
    <p class="normal">The differentiating factor with event handling in React components is that it’s declarative. Compare this <a id="_idIndexMarker156"/>with something such as <strong class="keyWord">jQuery</strong>, where you have to write imperative code that selects the relevant DOM elements and attaches event handler functions to them.</p>
    <p class="normal">The advantage of <a id="_idIndexMarker157"/>the declarative approach to event handlers in JSX markup is that they’re part of the UI structure. Not having to track down code that assigns event handlers is mentally liberating.</p>
    <p class="normal">In this section, you’ll write a basic event handler so that you can get a feel for the declarative event handling syntax found in React applications. Then, you’ll learn how to use generic event handler functions.</p>
    <h2 id="_idParaDest-74" class="heading-2">Declaring handler functions</h2>
    <p class="normal">Let’s take a <a id="_idIndexMarker158"/>look at a basic component that declares an event handler for the click event of an element:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span> <span class="hljs-title">MyButton</span>(<span class="hljs-params">props</span>) {
  <span class="hljs-keyword">const</span> <span class="hljs-title">clickHandler</span> = () =&gt; {
    <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-string">"clicked"</span>);
  };
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{clickHandler}</span><span class="hljs-tag">&gt;</span>{props.children}<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>;
}
</code></pre>
    <p class="normal">The event handler <code class="inlineCode">clickHandler</code> function is passed to the <code class="inlineCode">onClick</code> property of the <code class="inlineCode">&lt;button&gt;</code> element. By looking at this markup, you can see exactly which code will run when the button is clicked.</p>
    <div class="note">
      <p class="normal">View the official React documentation for the full list of supported event property names at <a href="https://react.dev/reference/react-dom/components/common"><span class="url">https://react.dev/reference/react-dom/components/common</span></a>.</p>
    </div>
    <p class="normal">Next, let’s take <a id="_idIndexMarker159"/>a look at how to respond to more than one type of event using different event handlers with the same element.</p>
    <h2 id="_idParaDest-75" class="heading-2">Multiple event handlers</h2>
    <p class="normal">What I really like about the declarative event handler syntax is that it’s easy to read when there’s <a id="_idIndexMarker160"/>more than one handler assigned to an element. Sometimes, for example, there are two or three handlers for an element. Imperative <a id="_idIndexMarker161"/>code is difficult to work with for a single event handler, let alone several of them. When an element needs more handlers, it’s just another JSX attribute. This scales well from a code-maintainability perspective, as this example shows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span> <span class="hljs-title">MyInput</span>() {
  <span class="hljs-keyword">const</span> <span class="hljs-title">onChange</span> = () =&gt; {
    <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-string">"changed"</span>);
  };
  <span class="hljs-keyword">const</span> <span class="hljs-title">onBlur</span> = () =&gt; {
    <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-string">"blured"</span>);
  };
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span><span class="hljs-tag"> </span><span class="hljs-attr">onChange</span><span class="hljs-tag">=</span><span class="hljs-string">{onChange}</span><span class="hljs-tag"> </span><span class="hljs-attr">onBlur</span><span class="hljs-tag">=</span><span class="hljs-string">{onBlur}</span><span class="hljs-tag"> /&gt;</span>;
}
</code></pre>
    <p class="normal">This <code class="inlineCode">&lt;input&gt;</code> element could have several more event handlers and the code would be just as readable.</p>
    <p class="normal">As you keep adding more event handlers to your components, you’ll notice that a lot of them do the same thing. Next, you’ll learn about inline event handler functions.</p>
    <h1 id="_idParaDest-76" class="heading-1">Declaring inline event handlers</h1>
    <p class="normal">The typical <a id="_idIndexMarker162"/>approach to assigning handler functions to JSX properties is to use a <strong class="keyWord">named</strong> function. However, sometimes, you might want to use an <strong class="keyWord">inline</strong> function, where the function is defined as part of the markup. This is done by assigning an arrow function directly to the event property in the JSX markup:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span> <span class="hljs-title">MyButton</span>(<span class="hljs-params">props</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{(e)</span><span class="hljs-tag"> =&gt;</span> console.log("clicked", e)}&gt;
      {props.children}
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
  );
}
</code></pre>
    <p class="normal">The main use of inlining event handlers like this is when you have a <strong class="keyWord">static parameter</strong> value that you want to pass to another function. In this example, you’re calling <code class="inlineCode">console.log</code> with the clicked string. You could have set up a special function for this purpose outside <a id="_idIndexMarker163"/>of the JSX markup by creating a new function or by using a higher-order function. But then you would have to think of yet another name for yet another function. Inlining is just easier sometimes.</p>
    <p class="normal">Next, you’ll learn about how React binds handler functions to the underlying DOM elements in the browser.</p>
    <h1 id="_idParaDest-77" class="heading-1">Binding handlers to elements</h1>
    <p class="normal">When you assign an event handler function to an element in JSX, React doesn’t actually attach an event <a id="_idIndexMarker164"/>listener to the underlying DOM element. Instead, it adds the function to an internal mapping of functions. There’s a single event listener on the document for the page. As events bubble up through the DOM tree to the document, the React handler checks to see whether any components have matching handlers. The process is illustrated here:</p>
    <figure class="mediaobject"><img src="../Images/B19636_04_01.png" alt="" role="presentation"/></figure>
    <figure class="mediaobject">Figure 4.1: The event handler cycle</figure>
    <p class="normal">Why does React go through all of this trouble, you might ask? It’s the same principle that I’ve been <a id="_idIndexMarker165"/>covering in the last few chapters: keep the declarative UI structures separated from the DOM as much as possible. The DOM is merely a render target; React’s architecture allows it to remain agnostic about the final rendering destination and event system.</p>
    <p class="normal">For example, when a new component is rendered, its event handler functions are simply added to the internal mapping maintained by React. When an event is triggered and it hits the document object, React maps the event to the handlers. If a match is found, it calls the handler. Finally, when the <strong class="keyWord">React component</strong> is removed, the handler is simply removed from the list of handlers.</p>
    <p class="normal">None of these DOM operations actually touch the DOM. It’s all abstracted by a single event listener. This is good for performance and the overall architecture (in other words, keeping the render target separate from the application code).</p>
    <p class="normal">In the following section, you’ll learn about the synthetic event implementation used by React to ensure good performance and safe asynchronous behavior.</p>
    <h1 id="_idParaDest-78" class="heading-1">Using synthetic event objects</h1>
    <p class="normal">When you attach <a id="_idIndexMarker166"/>an event handler function to a DOM element using the native <code class="inlineCode">addEventListener</code> function, the callback will get an event argument passed to it. Event handler functions in React are also passed an event argument but it’s not the standard event instance. It’s called <code class="inlineCode">SyntheticEvent</code> and it’s a simple wrapper for native event instances.</p>
    <p class="normal"><strong class="keyWord">Synthetic events</strong> serve two <a id="_idIndexMarker167"/>purposes in React:</p>
    <ul>
      <li class="bulletList">They provide a consistent event interface, normalizing browser inconsistencies.</li>
      <li class="bulletList">They contain information that’s necessary for propagation to work.</li>
    </ul>
    <p class="normal">Here’s a diagram of the synthetic event in the context of a <strong class="keyWord">React component</strong>:</p>
    <figure class="mediaobject"><img src="../Images/B19636_04_02.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 4.2: How synthetic events are created and processed</p>
    <p class="normal">When a DOM <a id="_idIndexMarker168"/>element that is part of a <strong class="keyWord">React component</strong> dispatches an event, React will handle the event because it sets up its own listeners for them. Then, it will either create a new <strong class="keyWord">synthetic event</strong> or reuse one from the pool, depending on availability. If there are any event handlers declared for the component that match the DOM event that was dispatched, they will run with the synthetic event passed to them.</p>
    <p class="normal">The event object in React has properties and methods similar to those in native JavaScript events. You can access properties such as <code class="inlineCode">event.target</code> to retrieve the DOM element that triggered the event, or <code class="inlineCode">event.currentTarget</code> to refer to the element to which the event handler is attached.</p>
    <p class="normal">Additionally, the event object provides methods like <code class="inlineCode">event.preventDefault()</code> to prevent the default behavior associated with the event, such as form submissions or link clicks. You can also use <code class="inlineCode">event.stopPropagation()</code> to stop the event from propagating further up the component tree, preventing event bubbling.</p>
    <p class="normal"><strong class="keyWord">Event propagation</strong> works differently <a id="_idIndexMarker169"/>in React compared to traditional JavaScript event handling. In the traditional approach, events typically bubble up through the DOM tree, triggering handlers on ancestor elements.</p>
    <p class="normal">In React, event propagation is based on the component hierarchy rather than the DOM hierarchy. When an event occurs in a child component, React captures the event at the root of the component tree and then traverses down to the specific component that triggered the event. This approach, known as event delegation, simplifies event handling by centralizing the event logic at the root of the component tree.</p>
    <p class="normal">React’s event <a id="_idIndexMarker170"/>delegation provides several benefits. First, it reduces the number of event listeners attached to individual DOM elements, resulting in improved performance. Second, it allows you to handle events for dynamically created or removed elements without worrying about attaching or detaching event listeners manually.</p>
    <p class="normal">In the next section, you’ll see how these synthetic events are pooled for performance reasons and the implications of this on asynchronous code.</p>
    <h1 id="_idParaDest-79" class="heading-1">Understanding event pooling</h1>
    <p class="normal">One challenge of wrapping native event instances is that it can cause performance issues. Every synthetic <a id="_idIndexMarker171"/>event wrapper that’s created will also need to be garbage collected at some point, which can be expensive in terms of CPU time.</p>
    <div class="note">
      <p class="normal">When the garbage collector is running, none of your JavaScript code is able to run. This is why it’s important to be memory-efficient; frequent garbage collection means less CPU time for code that responds to user interactions.</p>
    </div>
    <p class="normal">For example, if your application only handles a few events, this wouldn’t matter much. But even by modest standards, applications respond to many events, even if the handlers don’t actually do anything with them. This is problematic if React constantly has to allocate new synthetic event instances.</p>
    <p class="normal">React deals with <a id="_idIndexMarker172"/>this problem by allocating a <strong class="keyWord">synthetic instance pool</strong>. Whenever an event is triggered, it takes an instance from the pool and populates its properties. When the event handler has finished running, the <strong class="keyWord">synthetic event</strong> instance is released back into the pool, as shown here:</p>
    <figure class="mediaobject"><img src="../Images/B19636_04_03.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 4.3: Synthetic events are reused to save memory resources</p>
    <p class="normal">This prevents the garbage collector from running frequently when a lot of events are triggered. The pool keeps a reference to the synthetic event instances, so they’re never eligible for garbage collection. React never has to allocate new instances either.</p>
    <p class="normal">However, there is one <a id="_idIndexMarker173"/>gotcha that you need to be aware of. It involves accessing the synthetic event instances from asynchronous code in your event handlers. This is an issue because, as soon as the handler has finished running, the instance goes back into the pool. When it goes back into the pool, all of its properties are cleared.</p>
    <p class="normal">Here’s an example that shows how this can go wrong:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchData</span>() {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Promise</span>(<span class="hljs-function">(</span><span class="hljs-params">resolve</span><span class="hljs-function">) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title">resolve</span>();
    }, <span class="hljs-number">1000</span>);
  });
}
<span class="hljs-keyword">function</span> <span class="hljs-title">MyButton</span>(<span class="hljs-params">props</span>) {
  <span class="hljs-keyword">function</span> <span class="hljs-title">onClick</span>(<span class="hljs-params">e</span>) {
    <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-string">"clicked"</span>, e.<span class="hljs-property">currentTarget</span>.<span class="hljs-property">style</span>);
    <span class="hljs-title">fetchData</span>().<span class="hljs-title">then</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-string">"callback"</span>, e.<span class="hljs-property">currentTarget</span>.<span class="hljs-property">style</span>);
    });
  }
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{onClick}</span><span class="hljs-tag">&gt;</span>{props.children}<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>;
}
</code></pre>
    <p class="normal">The second call to <code class="inlineCode">console.log</code> is attempting to access a synthetic event property from an asynchronous callback that doesn’t run until the event handler completes, which causes the event <a id="_idIndexMarker174"/>to empty its properties. This results in a warning and an undefined value.</p>
    <div class="note">
      <p class="normal">The aim of this example is to illustrate how things can break when you write asynchronous code that interacts with events. Just don’t do it!</p>
    </div>
    <p class="normal">In this section, you learned that events are pooled for performance reasons, which means that you should never access event objects in an asynchronous way.</p>
    <h1 id="_idParaDest-80" class="heading-1">Summary</h1>
    <p class="normal">This chapter introduced you to event handling in React. The key differentiator between React and other approaches to event handling is that handlers are declared in JSX markup. This makes tracking down which elements handle which events much simpler.</p>
    <p class="normal">You learned that having multiple event handlers on a single element is a matter of adding new JSX properties. Then, you learned about inline event handler functions and their potential use, as well as how React actually binds a single DOM event handler to the document object. </p>
    <p class="normal">Synthetic events are abstractions that wrap native events; you learned why they’re necessary and how they’re pooled for efficient memory consumption.</p>
    <p class="normal">In the next chapter, you’ll learn how to create components that are reusable for a variety of purposes. Instead of writing new components for each use case that you encounter, you’ll learn the skills necessary to refactor existing components so that they can be used in more than one context.</p>
  </div>
</body></html>