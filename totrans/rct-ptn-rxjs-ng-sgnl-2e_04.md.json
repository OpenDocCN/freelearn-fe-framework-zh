["```js\nstream$.subscribe({\n    next: (value) => console.log('Value Emitted', value),\n    error: (error) => console.log('Error Occurred', error),\n    complete: () => console.log('Stream Completed'),\n});\n```", "```js\n    try {\n      // risky statements\n  }\n  catch(error) {\n      // handle exceptions\n   }\n```", "```js\nimport { catchError} from 'rxjs/operators';\n//stream$ is the source Observable that might error out\nstream$.pipe(\n      catchError(error => {\n          //handle the error received\n      })\n).subscribe()\n```", "```js\nimport { from, of } from 'rxjs';\nimport { catchError, map } from 'rxjs/operators';\nconst stream$ = from(['5', '10', '6', 'Hello', '2']);\nstream$\n  .pipe(\n    map((value) => {\n      if (isNaN(value as any)) {\n        throw new Error('This is not a number');\n      }\n      return parseInt(value);\n    }),\n    catchError((error) => {\n      console.log('Caught Error', error);\n      return of();\n    })\n  )\n  .subscribe({\n    next: (res) => console.log('Value Emitted', res),\n    error: (err) => console.log('Error Occurred', err),\n    complete: () => console.log('Stream Completed'),\n  });\n//output\nValue Emitted 5\nValue Emitted 10\nValue Emitted 6\nCaught Error Error: This is not a number\nStream Completed\n```", "```js\nimport { from, throwError } from 'rxjs';\nimport { catchError, map } from 'rxjs/operators';\nconst stream$ = from(['5', '10', '6', 'Hello', '2']);\nstream$\n  .pipe(\n    map((value) => {\n      if (isNaN(value as any)) {\n        throw new Error('This is not a number');\n      }\n      return parseInt(value);\n    }),\n    catchError((error) => {\n      console.log('Caught Error', error);\n      return throwError(() => error);\n    })\n  )\n  .subscribe({\n    next: (res) => console.log('Value Emitted', res),\n    error: (err) => console.log('Error Occurred', err),\n    complete: () => console.log('Stream Completed'),\n  });\n//output\nValue Emitted 5\nValue Emitted 10\nValue Emitted 6\nCaught Error Error: This is not a number\nError Occurred Error: This is not a number\n```", "```js\nimport { catchError, map, retry } from 'rxjs/operators';\nimport { from, throwError } from 'rxjs';\nconst stream$ = from(['5', '10', '6', 'Hello', '2']);\nstream$\n  .pipe(\n    map((value) => {\n      if (isNaN(value as any)) {\n        throw new Error('This is not a number');\n      }\n      return parseInt(value);\n    }),\n    retry(2),\n    catchError((error) => {\n      console.log('Caught Error', error);\n      return throwError(() => error);\n    })\n  )\n  .subscribe({\n    next: (res) => console.log('Value Emitted', res),\n    error: (err) => console.log('Error Occurred', err),\n    complete: () => console.log('Stream Completed'),\n  });\n//output\nValue Emitted 5\n10\n6\n5\n10\n6\n5\n10\n6\nCaught Error Error: This is not a number\nError Occurred Error: This is not a number\n```", "```js\nexport declare function retryWhen<T>(notifier: (errors:\nObservable<any>) => Observable<any>):\nMonoTypeOperatorFunction<T>;\n```", "```js\nimport { from} from 'rxjs';\nimport { map, retryWhen, tap } from 'rxjs/operators';\nconst stream$ = from(['5', '10', '6', 'Hello', '2']);\nstream$\n  .pipe(\n    map((value) => {\n      if (isNaN(value as any)) {\n        throw new Error('This is not a number');\n      }\n      return parseInt(value);\n    }),\n    retryWhen((errors) => {\n      return errors.pipe(\n        tap(() => console.log('Retrying the source\n                              Observable...'))\n      );\n    })\n  )\n  .subscribe({\n    next: (res) => console.log('Value Emitted', res),\n    error: (err) => console.log('Error Occurred', err),\n    complete: () => console.log('Stream Completed'),\n  });\n//Code runs infinitely\n```", "```js\nexport declare function timer(dueTime?: number | Date,\nperiodOrScheduler?: number | SchedulerLike, scheduler?:\nSchedulerLike): Observable<number>;\n```", "```js\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Recipe } from '../model/recipe.model';\nimport { catchError, delayWhen, of, retryWhen, tap, timer } from 'rxjs';\n@Injectable({\n  providedIn: 'root'\n})\nexport class RecipesService {\nrecipes$ =\nthis.http.get<Recipe[]>('http://localhost:3001/recipes')\n.pipe(\n       retryWhen(errors => {\n         return errors\n           .pipe(\n             delayWhen(() => timer(5000)),\n             tap(() => console.log('Retrying the HTTP\n                                   request...'))\n           );\n       }),\n);\nconstructor(private http: HttpClient) { }\n}\n```", "```js\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Recipe } from '../model/recipe.model';\nimport { environment } from 'src/environments/environment';\nimport { catchError, of } from 'rxjs';\nconst BASE_PATH = environment.basePath\n@Injectable({\n  providedIn: 'root'\n})\nexport class RecipesService {\n  recipes$ = this.http.get<Recipe[]>(\n    `${BASE_PATH}/recipes`).pipe(\n      catchError(()=> of([])));\n  constructor(private http: HttpClient) { }\n}\n```", "```js\n@if (recipes$ | async; as recipes) {\n<div class=\"card\">\n    <div>{{recipes.length}} Results</div>\n    <p-dataView #dv [value]=\"recipes\" [paginator]=\"true\"\n    [rows]=\"9\" filterBy=\"name\" layout=\"grid\">\n        <ng-template let-recipes pTemplate=\"gridItem\">\n            <div class=\"grid grid-nogutter\">\n                @for (recipe of recipes; track recipe.id) {\n                    <div class=\"col-12\" class=\"recipe-grid-\n                        item card\">\n                        /** Extra code here **/\n                    </div>\n                } @empty {\n                    <div>There are no recipes</div>\n                }\n            </div>\n        </ng-template>\n    </p-dataView>\n</div>\n} @else {\n    <div>There are no recipes</div>\n}\n```"]