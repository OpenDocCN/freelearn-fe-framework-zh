- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Event Handling in the React Way
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React方式的事件处理
- en: The focus of this chapter is `higher-order event handler` functions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是`高阶事件处理器`函数。
- en: Afterward, you’ll learn how React maps event handlers to DOM elements under
    the hood. Finally, you’ll learn about the synthetic events that React passes to
    event handler functions and how they’re pooled for performance purposes. Once
    you’ve completed this chapter, you’ll be comfortable implementing event handlers
    in your React components. At that point, your applications come to life for your
    users because they are then able to interact with them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你将学习React如何在底层将事件处理器映射到DOM元素。最后，你将了解React传递给事件处理器函数的合成事件以及它们如何为了性能目的而被池化。一旦你完成这一章，你将能够轻松地在你的React组件中实现事件处理器。到那时，你的应用程序将因为用户能够与之交互而变得生动起来。
- en: 'The following topics are covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Declaring event handlers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明事件处理器
- en: Declaring inline event handlers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明内联事件处理器
- en: Binding handlers to elements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将处理器绑定到元素上
- en: Using synthetic event objects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用合成事件对象
- en: Understanding event pooling
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解事件池化
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code presented in this chapter can be found at the following link: [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter04](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter04)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的代码可以在以下链接找到：[https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter04](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter04)
- en: Declaring event handlers
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明事件处理器
- en: The differentiating factor with event handling in React components is that it’s
    declarative. Compare this with something such as **jQuery**, where you have to
    write imperative code that selects the relevant DOM elements and attaches event
    handler functions to them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与React组件中的事件处理相比，其区分因素在于它是声明式的。将此与例如**jQuery**进行比较，在jQuery中，你必须编写命令式代码来选择相关的DOM元素并将事件处理器函数附加到它们上。
- en: The advantage of the declarative approach to event handlers in JSX markup is
    that they’re part of the UI structure. Not having to track down code that assigns
    event handlers is mentally liberating.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: JSX标记中声明式事件处理器方法的优点是它们是UI结构的一部分。不必追踪分配事件处理器的代码，这在心理上是一种解放。
- en: In this section, you’ll write a basic event handler so that you can get a feel
    for the declarative event handling syntax found in React applications. Then, you’ll
    learn how to use generic event handler functions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将编写一个基本的事件处理器，以便你可以感受到在React应用程序中找到的声明式事件处理语法。然后，你将学习如何使用通用事件处理器函数。
- en: Declaring handler functions
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明处理器函数
- en: 'Let’s take a look at a basic component that declares an event handler for the
    click event of an element:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个基本的组件，它声明了一个元素的点击事件处理器：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The event handler `clickHandler` function is passed to the `onClick` property
    of the `<button>` element. By looking at this markup, you can see exactly which
    code will run when the button is clicked.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`clickHandler`函数被传递到`<button>`元素的`onClick`属性。通过查看这个标记，你可以确切地看到当按钮被点击时将运行哪些代码。'
- en: View the official React documentation for the full list of supported event property
    names at [https://react.dev/reference/react-dom/components/common](https://react.dev/reference/react-dom/components/common).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://react.dev/reference/react-dom/components/common](https://react.dev/reference/react-dom/components/common)查看官方React文档，以获取支持的完整事件属性名称列表。
- en: Next, let’s take a look at how to respond to more than one type of event using
    different event handlers with the same element.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何使用同一元素的不同事件处理器来响应多种类型的事件。
- en: Multiple event handlers
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个事件处理器
- en: 'What I really like about the declarative event handler syntax is that it’s
    easy to read when there’s more than one handler assigned to an element. Sometimes,
    for example, there are two or three handlers for an element. Imperative code is
    difficult to work with for a single event handler, let alone several of them.
    When an element needs more handlers, it’s just another JSX attribute. This scales
    well from a code-maintainability perspective, as this example shows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常喜欢声明式事件处理器语法的是，当分配给一个元素多个处理器时，它很容易阅读。有时，例如，一个元素有两个或三个处理器。对于单个事件处理器，命令式代码就很难处理，更不用说多个处理器了。当一个元素需要更多处理器时，它只是另一个JSX属性。从代码可维护性的角度来看，这一点从以下示例中可以看出：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This `<input>` element could have several more event handlers and the code would
    be just as readable.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`<input>`元素可以有更多的事件处理器，代码的可读性仍然很好。
- en: As you keep adding more event handlers to your components, you’ll notice that
    a lot of them do the same thing. Next, you’ll learn about inline event handler
    functions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你继续向你的组件添加更多的事件处理器时，你会注意到其中很多都在做同样的事情。接下来，你将学习关于内联事件处理器函数的内容。
- en: Declaring inline event handlers
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明内联事件处理器
- en: 'The typical approach to assigning handler functions to JSX properties is to
    use a **named** function. However, sometimes, you might want to use an **inline**
    function, where the function is defined as part of the markup. This is done by
    assigning an arrow function directly to the event property in the JSX markup:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将处理函数分配给JSX属性的传统方法是使用**命名**函数。然而，有时你可能想使用**内联**函数，其中函数作为标记的一部分被定义。这是通过将箭头函数直接分配给JSX标记中的事件属性来完成的：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The main use of inlining event handlers like this is when you have a **static
    parameter** value that you want to pass to another function. In this example,
    you’re calling `console.log` with the clicked string. You could have set up a
    special function for this purpose outside of the JSX markup by creating a new
    function or by using a higher-order function. But then you would have to think
    of yet another name for yet another function. Inlining is just easier sometimes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种内联事件处理器的最主要用途是当你有一个想要传递给另一个函数的**静态参数**值时。在这个例子中，你正在调用`console.log`并传入点击的字符串。你可以通过创建一个新的函数或使用高阶函数，在JSX标记之外设置一个特殊函数来达到这个目的。但那样你就需要为另一个函数想一个新的名字。有时候内联处理器的使用会更简单一些。
- en: Next, you’ll learn about how React binds handler functions to the underlying
    DOM elements in the browser.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习React是如何将处理函数绑定到浏览器中底层的DOM元素上的。
- en: Binding handlers to elements
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将处理器绑定到元素上
- en: 'When you assign an event handler function to an element in JSX, React doesn’t
    actually attach an event listener to the underlying DOM element. Instead, it adds
    the function to an internal mapping of functions. There’s a single event listener
    on the document for the page. As events bubble up through the DOM tree to the
    document, the React handler checks to see whether any components have matching
    handlers. The process is illustrated here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在JSX中将事件处理器函数分配给一个元素时，React实际上并没有将事件监听器附加到底层的DOM元素上。相反，它将函数添加到内部函数映射中。页面上有一个文档级别的单一事件监听器。当事件通过DOM树向上冒泡到文档时，React处理器会检查是否有任何组件具有匹配的处理器。这个过程在这里被展示出来：
- en: '![](img/B19636_04_01.png)Figure 4.1: The event handler cycle'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1：事件处理器周期](img/B19636_04_01.png)'
- en: 'Why does React go through all of this trouble, you might ask? It’s the same
    principle that I’ve been covering in the last few chapters: keep the declarative
    UI structures separated from the DOM as much as possible. The DOM is merely a
    render target; React’s architecture allows it to remain agnostic about the final
    rendering destination and event system.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么React要费这么大的劲？这与我在前几章中一直在讲述的相同原则：尽可能地将声明性UI结构从DOM中分离出来。DOM仅仅是一个渲染目标；React的架构允许它对最终的渲染目的地和事件系统保持中立。
- en: For example, when a new component is rendered, its event handler functions are
    simply added to the internal mapping maintained by React. When an event is triggered
    and it hits the document object, React maps the event to the handlers. If a match
    is found, it calls the handler. Finally, when the **React component** is removed,
    the handler is simply removed from the list of handlers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当一个新组件被渲染时，它的处理函数被简单地添加到React维护的内部映射中。当一个事件被触发并击中文档对象时，React将事件映射到处理器。如果找到匹配项，它将调用处理器。最后，当**React组件**被移除时，处理器将从处理器列表中简单地移除。
- en: None of these DOM operations actually touch the DOM. It’s all abstracted by
    a single event listener. This is good for performance and the overall architecture
    (in other words, keeping the render target separate from the application code).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些DOM操作实际上并没有触及DOM。这一切都被一个单独的事件监听器抽象了。这对性能和整体架构（换句话说，保持渲染目标与应用代码的分离）是有好处的。
- en: In the following section, you’ll learn about the synthetic event implementation
    used by React to ensure good performance and safe asynchronous behavior.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，你将学习React如何使用合成事件实现来确保良好的性能和安全的异步行为。
- en: Using synthetic event objects
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用合成事件对象
- en: When you attach an event handler function to a DOM element using the native
    `addEventListener` function, the callback will get an event argument passed to
    it. Event handler functions in React are also passed an event argument but it’s
    not the standard event instance. It’s called `SyntheticEvent` and it’s a simple
    wrapper for native event instances.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用原生的 `addEventListener` 函数将事件处理函数附加到DOM元素时，回调将获得一个事件参数传递给它。React中的事件处理函数也传递一个事件参数，但它不是标准的事件实例。它被称为
    `SyntheticEvent`，它是原生事件实例的简单包装。
- en: '**Synthetic events** serve two purposes in React:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**合成事件**在React中具有两个目的：'
- en: They provide a consistent event interface, normalizing browser inconsistencies.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供了一个一致的事件接口，标准化了浏览器的不一致性。
- en: They contain information that’s necessary for propagation to work.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们包含传播所需的信息。
- en: 'Here’s a diagram of the synthetic event in the context of a **React component**:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个**React组件**上下文中合成事件的图示：
- en: '![](img/B19636_04_02.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_04_02.png)'
- en: 'Figure 4.2: How synthetic events are created and processed'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：合成事件是如何创建和处理的
- en: When a DOM element that is part of a **React component** dispatches an event,
    React will handle the event because it sets up its own listeners for them. Then,
    it will either create a new **synthetic event** or reuse one from the pool, depending
    on availability. If there are any event handlers declared for the component that
    match the DOM event that was dispatched, they will run with the synthetic event
    passed to them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个DOM元素作为**React组件**的一部分派发事件时，React将处理该事件，因为它为它们设置了自有的监听器。然后，根据可用性，它将创建一个新的**合成事件**或从池中重用其中一个。如果为该组件声明了任何与派发的DOM事件匹配的事件处理程序，它们将使用传递给它们的合成事件运行。
- en: The event object in React has properties and methods similar to those in native
    JavaScript events. You can access properties such as `event.target` to retrieve
    the DOM element that triggered the event, or `event.currentTarget` to refer to
    the element to which the event handler is attached.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: React中的事件对象具有与原生JavaScript事件类似的属性和方法。您可以通过 `event.target` 访问属性来检索触发事件的DOM元素，或通过
    `event.currentTarget` 来引用事件处理程序附加到的元素。
- en: Additionally, the event object provides methods like `event.preventDefault()`
    to prevent the default behavior associated with the event, such as form submissions
    or link clicks. You can also use `event.stopPropagation()` to stop the event from
    propagating further up the component tree, preventing event bubbling.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，事件对象提供了如 `event.preventDefault()` 这样的方法来阻止与事件关联的默认行为，例如表单提交或链接点击。您还可以使用 `event.stopPropagation()`
    来阻止事件进一步向上传播到组件树，防止事件冒泡。
- en: '**Event propagation** works differently in React compared to traditional JavaScript
    event handling. In the traditional approach, events typically bubble up through
    the DOM tree, triggering handlers on ancestor elements.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件传播**在React中与传统JavaScript事件处理不同。在传统方法中，事件通常通过DOM树向上冒泡，触发祖先元素上的处理程序。'
- en: In React, event propagation is based on the component hierarchy rather than
    the DOM hierarchy. When an event occurs in a child component, React captures the
    event at the root of the component tree and then traverses down to the specific
    component that triggered the event. This approach, known as event delegation,
    simplifies event handling by centralizing the event logic at the root of the component
    tree.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，事件传播基于组件层次结构而不是DOM层次结构。当一个事件在子组件中发生时，React会在组件树的根处捕获该事件，然后向下遍历到触发事件的特定组件。这种方法称为事件委托，通过在组件树的根处集中事件逻辑来简化事件处理。
- en: React’s event delegation provides several benefits. First, it reduces the number
    of event listeners attached to individual DOM elements, resulting in improved
    performance. Second, it allows you to handle events for dynamically created or
    removed elements without worrying about attaching or detaching event listeners
    manually.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: React的事件委托提供了几个好处。首先，它减少了附加到单个DOM元素上的事件监听器的数量，从而提高了性能。其次，它允许您处理动态创建或删除的元素的事件，而无需担心手动附加或移除事件监听器。
- en: In the next section, you’ll see how these synthetic events are pooled for performance
    reasons and the implications of this on asynchronous code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将看到这些合成事件如何为了性能原因而被池化，以及这对异步代码的影响。
- en: Understanding event pooling
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解事件池化
- en: One challenge of wrapping native event instances is that it can cause performance
    issues. Every synthetic event wrapper that’s created will also need to be garbage
    collected at some point, which can be expensive in terms of CPU time.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将原生事件实例包装起来的一大挑战是它可能会引起性能问题。每个创建的合成事件包装器最终都需要进行垃圾收集，这在 CPU 时间上可能代价高昂。
- en: When the garbage collector is running, none of your JavaScript code is able
    to run. This is why it’s important to be memory-efficient; frequent garbage collection
    means less CPU time for code that responds to user interactions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当垃圾收集器运行时，你的任何 JavaScript 代码都无法运行。这就是为什么内存效率很重要；频繁的垃圾收集意味着响应用户交互的代码有更少的 CPU
    时间。
- en: For example, if your application only handles a few events, this wouldn’t matter
    much. But even by modest standards, applications respond to many events, even
    if the handlers don’t actually do anything with them. This is problematic if React
    constantly has to allocate new synthetic event instances.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的应用程序只处理少量事件，这不会有多大影响。但即使按照适度标准，应用程序也会响应许多事件，即使处理程序实际上并没有对它们做任何事情。如果 React
    不断需要分配新的合成事件实例，这就会成为问题。
- en: 'React deals with this problem by allocating a **synthetic instance pool**.
    Whenever an event is triggered, it takes an instance from the pool and populates
    its properties. When the event handler has finished running, the **synthetic event**
    instance is released back into the pool, as shown here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: React 通过分配一个**合成实例池**来处理这个问题。每当一个事件被触发时，它会从池中取出一个实例并填充其属性。当事件处理程序运行完成后，**合成事件**实例被释放回池中，如下所示：
- en: '![](img/B19636_04_03.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_04_03.png)'
- en: 'Figure 4.3: Synthetic events are reused to save memory resources'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：合成事件被重复使用以节省内存资源
- en: This prevents the garbage collector from running frequently when a lot of events
    are triggered. The pool keeps a reference to the synthetic event instances, so
    they’re never eligible for garbage collection. React never has to allocate new
    instances either.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这防止了在触发大量事件时垃圾收集器频繁运行。池保留了合成事件实例的引用，因此它们永远不会符合垃圾收集的条件。React 也永远不会需要分配新实例。
- en: However, there is one gotcha that you need to be aware of. It involves accessing
    the synthetic event instances from asynchronous code in your event handlers. This
    is an issue because, as soon as the handler has finished running, the instance
    goes back into the pool. When it goes back into the pool, all of its properties
    are cleared.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个需要注意的陷阱。它涉及到从事件处理程序中的异步代码访问合成事件实例。这是一个问题，因为一旦处理程序运行完成，实例就会回到池中。当它回到池中时，所有属性都会被清除。
- en: 'Here’s an example that shows how this can go wrong:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，说明这可能会出错：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The second call to `console.log` is attempting to access a synthetic event property
    from an asynchronous callback that doesn’t run until the event handler completes,
    which causes the event to empty its properties. This results in a warning and
    an undefined value.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次调用 `console.log` 尝试从一个异步回调中访问合成事件属性，该回调直到事件处理程序完成才运行，这导致事件清空了其属性。这会产生一个警告和一个未定义的值。
- en: The aim of this example is to illustrate how things can break when you write
    asynchronous code that interacts with events. Just don’t do it!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的目的是说明当你编写与事件交互的异步代码时，事情可能会出错。只是不要这样做！
- en: In this section, you learned that events are pooled for performance reasons,
    which means that you should never access event objects in an asynchronous way.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你了解到事件被池化是为了性能原因，这意味着你永远不应该以异步方式访问事件对象。
- en: Summary
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to event handling in React. The key differentiator
    between React and other approaches to event handling is that handlers are declared
    in JSX markup. This makes tracking down which elements handle which events much
    simpler.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 React 中的事件处理。React 与其他事件处理方法的关键区别在于处理程序是在 JSX 标记中声明的。这使得追踪哪些元素处理哪些事件变得简单得多。
- en: You learned that having multiple event handlers on a single element is a matter
    of adding new JSX properties. Then, you learned about inline event handler functions
    and their potential use, as well as how React actually binds a single DOM event
    handler to the document object.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解到在单个元素上添加多个事件处理程序只是添加新的 JSX 属性的问题。然后，你学习了内联事件处理函数及其潜在用途，以及 React 实际上如何将单个
    DOM 事件处理程序绑定到文档对象。
- en: Synthetic events are abstractions that wrap native events; you learned why they’re
    necessary and how they’re pooled for efficient memory consumption.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 合成事件是封装原生事件的抽象；你已经了解到它们为何是必要的，以及它们是如何为了高效内存消耗而被池化的。
- en: In the next chapter, you’ll learn how to create components that are reusable
    for a variety of purposes. Instead of writing new components for each use case
    that you encounter, you’ll learn the skills necessary to refactor existing components
    so that they can be used in more than one context.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何创建适用于多种目的的可重用组件。而不是为每个遇到的使用案例编写新的组件，你将学会必要的技能来重构现有组件，以便它们可以在多个上下文中使用。
