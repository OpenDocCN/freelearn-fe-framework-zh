<html><head></head><body>
<div id="_idContainer074">
<h1 class="chapter-number" id="_idParaDest-144"><a id="_idTextAnchor322"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-145"><a id="_idTextAnchor323"/><span class="koboSpan" id="kobo.2.1">Best Practices in Unit Testing</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we learned about the concept of software testing. </span><span class="koboSpan" id="kobo.3.2">We learned what to test from an array of available components and methods. </span><span class="koboSpan" id="kobo.3.3">In addition, we learned about the best practices and industry-standard testing libraries and how to integrate them with </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">Vue.js 3.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we will explore everything related to unit testing. </span><span class="koboSpan" id="kobo.5.2">We will learn how to unit test a Vue.js 3 component and the component and page methods. </span><span class="koboSpan" id="kobo.5.3">We will also learn about unit testing tools such as Jest and Mocha and how to use them to effectively unit test an </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">enterprise project.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">We will cover the following key topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Introduction to </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">unit testing</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">What is </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">unit testing?</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">The importance of </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">unit testing</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">The benefits of </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">unit testing</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Best practices in </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">unit testing</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">JavaScript </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">unit testing</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Testing a basic </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">Vue.js app</span></span></li>
</ul>
<h1 id="_idParaDest-146"><a id="_idTextAnchor324"/><span class="koboSpan" id="kobo.23.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.24.1">To get started with this chapter, I recommend you read through </span><a href="B17237_08.xhtml#_idTextAnchor266"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.25.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.26.1">, </span><em class="italic"><span class="koboSpan" id="kobo.27.1">Testing and What to Test in Vue.js 3</span></em><span class="koboSpan" id="kobo.28.1">, first, where we explored the concept of software testing and what to test from an array of available components and methods. </span><span class="koboSpan" id="kobo.28.2">We will rely heavily on the knowledge from that chapter when learning about Vue.js 3 enterprise unit testing in </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">All the code files for this chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">at </span></span><a href="https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-9"><span class="No-Break"><span class="koboSpan" id="kobo.32.1">https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-9</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.33.1">.</span></span></p>
<h1 id="_idParaDest-147"><a id="_idTextAnchor325"/><span class="koboSpan" id="kobo.34.1">Introduction to unit testing</span></h1>
<p><span class="koboSpan" id="kobo.35.1">Unit testing is an important step in the development phase because it helps spot errors and defects at the development stage if </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">done correctly.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">Unit testing is </span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.38.1">a method of software testing in which the smallest testable parts of the software under test, called units, are individually or independently tested for proper operation and to make sure the output corresponds with the </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">required output.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">The units can be said to be individual functions, objects, methods, procedures, or modules in the software </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">under test.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">This software testing approach is developed by software engineers to test the units of the program. </span><span class="koboSpan" id="kobo.42.2">It helps software engineers to know whether individual units of the code are working properly </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">or not.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">In this section, we will examine the definition of unit testing and explore how developers can create and manage unit tests within their enterprise-ready Vue.js </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">3 applications.</span></span><a id="_idTextAnchor326"/></p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor327"/><span class="koboSpan" id="kobo.46.1">What is unit testing?</span></h2>
<p><span class="koboSpan" id="kobo.47.1">Unit testing is a method of verifying the smallest piece of testable code against its purpose or requirement. </span><span class="koboSpan" id="kobo.47.2">This method makes sure that the smallest part of your code base is tested and made to conform to </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">the requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">It is very important to discover and fix bugs during the development stage. </span><span class="koboSpan" id="kobo.49.2">Unit testing is the responsibility of developers because it is done in the development phase by the developers, and it is the developers that create unit tests for their </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">production-ready code.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">Software developers can approach unit testing in two different ways, either writing their code before writing unit tests or before writing their actual code, where the developer first creates </span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.52.1">a failing unit test. </span><span class="koboSpan" id="kobo.52.2">The second approach is called </span><strong class="bold"><span class="koboSpan" id="kobo.53.1">Test-Driven </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.54.1">Development</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.55.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.56.1">TDD</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.58.1">When exploring the </span><strong class="bold"><span class="koboSpan" id="kobo.59.1">Software Development Life Cycle</span></strong><span class="koboSpan" id="kobo.60.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.61.1">SDLC</span></strong><span class="koboSpan" id="kobo.62.1">) for software engineering </span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.63.1">and development, unit testing comes under development since it is the responsibility of the developers and serves as the base and first level of testing to ensure bug-free and </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">defect-free software.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer072">
<span class="koboSpan" id="kobo.65.1"><img alt="Figure 9.1 – SDLC" src="image/Figure_9.01_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.66.1">Figure 9.1 – SDLC</span></p>
<p><span class="koboSpan" id="kobo.67.1">In the next section, we will examine different best practices to create and manage </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">unit tests.</span></span><a id="_idTextAnchor328"/></p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor329"/><span class="koboSpan" id="kobo.69.1">The importance and benefits of unit testing</span></h2>
<p><span class="koboSpan" id="kobo.70.1">The importance </span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.71.1">of implementing unit testing in your development pipeline cannot be overemphasized. </span><span class="koboSpan" id="kobo.71.2">It has been proven to have tremendous benefits. </span><span class="koboSpan" id="kobo.71.3">It has also helped in detecting errors early in the development phase. </span><span class="koboSpan" id="kobo.71.4">We will go through some of the major benefits and the importance of unit testing in </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">this section.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">Unit testing is used to design robust and enterprise-ready software components that help maintain code and eliminate issues in code units. </span><span class="koboSpan" id="kobo.73.2">Finding and fixing bugs during development is important compared to discovering them in production. </span><span class="koboSpan" id="kobo.73.3">Unit testing helps in fixing these errors early in the </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">development phases.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">It is an integral part of the agile software development process. </span><span class="koboSpan" id="kobo.75.2">During the build process and deployment, the unit test suite is automated to run and generate reports. </span><span class="koboSpan" id="kobo.75.3">If any of the unit tests fail, then the QA team should not accept that build for verification and it should be returned to the development team for more checking </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">and validation.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">Unit testing saves the QA and software testing teams a lot of time. </span><span class="koboSpan" id="kobo.77.2">If there is a proper standard and a well-configured, automated software testing pipeline for the enterprise application, errors and defects will be caught during </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">development automatically.</span></span></p>
<p><span class="koboSpan" id="kobo.79.1">Developers may avoid writing unit tests due to time constraints and tight deadlines. </span><span class="koboSpan" id="kobo.79.2">In most cases, they may opt to write poor unit tests just to have a 100% pass rate. </span><span class="koboSpan" id="kobo.79.3">This is very bad practice; it is better to avoid writing any tests instead of writing bad unit tests just </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">to pass.</span></span></p>
<p><span class="koboSpan" id="kobo.81.1">Here are some of the benefits of writing good unit </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">test cases:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.83.1">Improved code quality</span></strong><span class="koboSpan" id="kobo.84.1">: The quality of code shipped to production is automatically improved if unit testing is strictly implemented into the development pipeline and it’s done right. </span><span class="koboSpan" id="kobo.84.2">Unit testing is the earliest form of testing; therefore, any bugs identified during this testing are fixed before they are sent to the integration testing phase. </span><span class="koboSpan" id="kobo.84.3">The result of this approach is a robust design and development as developers write test cases by understanding the specifications and tasks at </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">hand first.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.86.1">Detects bugs early</span></strong><span class="koboSpan" id="kobo.87.1">: Unit testing is the first level of testing in software development. </span><span class="koboSpan" id="kobo.87.2">Therefore, it helps in identifying and fixing bugs early. </span><span class="koboSpan" id="kobo.87.3">This includes flaws, missing parts in the software requirements and specifications, or bugs in the </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">developers’ implementation.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.89.1">Saves development time</span></strong><span class="koboSpan" id="kobo.90.1">: Code completion takes time, especially if proper software development practices are in use. </span><span class="koboSpan" id="kobo.90.2">Therefore, when there are fewer bugs and </span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.91.1">errors in the system due to the effectiveness of unit testing, the overall development time </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">is reduced.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.93.1">Easy debugging process</span></strong><span class="koboSpan" id="kobo.94.1">: Unit testing helps in simplifying the testing and debugging process of an enterprise-ready application because if the test fails at any stage, the code needs to be debugged; otherwise, the process can continue without </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">any obstacles.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.96.1">Lower cost</span></strong><span class="koboSpan" id="kobo.97.1">: The cost of development, including development time, is drastically reduced when bugs are detected and resolved during development rather than during production. </span><span class="koboSpan" id="kobo.97.2">Without this testing, if the same bugs are detected at a later stage after the code integration, they become more difficult to trace and resolve, thereby making the development more costly and </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">last longer.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.99.1">The benefits and importance of unit testing are endless. </span><span class="koboSpan" id="kobo.99.2">Therefore, it’s a good practice to adopt and implement it into your enterprise-ready Vue.js 3 application development pipeline. </span><span class="koboSpan" id="kobo.99.3">In the next section, we will explore the best practices for creating unit </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">test cas</span><a id="_idTextAnchor330"/><span class="koboSpan" id="kobo.101.1">es.</span></span></p>
<h1 id="_idParaDest-150"><a id="_idTextAnchor331"/><span class="koboSpan" id="kobo.102.1">Best practices in unit test creation</span></h1>
<p><span class="koboSpan" id="kobo.103.1">When creating </span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.104.1">unit test cases, you should follow the best practices to produce consistent unit test cases to test every possible case properly. </span><span class="koboSpan" id="kobo.104.2">Consider </span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.105.1">the following points to create good </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">test cases:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.107.1">Arrange, Act, and </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.108.1">Assert</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.109.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.110.1">AAA</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.112.1">Write </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">deterministic tests</span></span></li>
<li><span class="koboSpan" id="kobo.114.1">Write good test names </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">and descriptions</span></span></li>
<li><span class="koboSpan" id="kobo.116.1">Write tests before or during </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">development (TDD)</span></span></li>
<li><span class="koboSpan" id="kobo.118.1">Leverage </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">automated tests</span></span></li>
<li><span class="koboSpan" id="kobo.120.1">Using mocks </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">and stubs</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.122.1">Let’s understand </span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.123.1">each of these points in more detail in the </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">next subsec</span><a id="_idTextAnchor332"/><span class="koboSpan" id="kobo.125.1">tions.</span></span></p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor333"/><span class="koboSpan" id="kobo.126.1">Arrange, act, and assert</span></h2>
<p><span class="koboSpan" id="kobo.127.1">When structuring your unit test suite for enterprise applications, following the AAA approach </span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.128.1">is recommended to improve </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.129.1">readability and easy understanding of your unit test suite. </span><span class="koboSpan" id="kobo.129.2">It improves the test readability </span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.130.1">by giving it a logical flow. </span><span class="koboSpan" id="kobo.130.2">It can also be referred to as the </span><strong class="bold"><span class="koboSpan" id="kobo.131.1">Given/When/Then</span></strong><span class="koboSpan" id="kobo.132.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.133.1">GWT</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">) strategy.</span></span></p>
<p><span class="koboSpan" id="kobo.135.1">GWT is a semi-structured way of writing down test cases. </span><span class="koboSpan" id="kobo.135.2">These test cases can either be manually tested or automated using </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">LambdaTest (</span></span><a href="https://www.lambdatest.com/automation-testing?fp_ref=solomon26"><span class="No-Break"><span class="koboSpan" id="kobo.137.1">https://www.lambdatest.com/automation-testing?fp_ref=solomon26</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.138.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.139.1">You can use the AAA protocol to structure your unit test cases with the </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">following steps:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.141.1">Arrange</span></strong><span class="koboSpan" id="kobo.142.1">: Arrange the setup and initialization for </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">the test.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.144.1">Act</span></strong><span class="koboSpan" id="kobo.145.1">: Act on the unit for a </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">given test.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.147.1">Assert</span></strong><span class="koboSpan" id="kobo.148.1">: Assert or verify </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">the outcome.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.150.1">The following code snippet shows a basic example of using the AAA style to create a simple unit </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">test case:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.152.1">
it('test for positive number', async () =&gt; {
   // Arrange
   const positive = 6;
   // Act
   const answer = Math.abs(positive);
   // Assert
   assert.equal(answer, positive);
 });</span></pre>
<p><span class="koboSpan" id="kobo.153.1">The </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.154.1">preceding snippet shows where to initialize variables </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.155.1">and create the initial setup for the given test, then where we act on the given test, and lastly, where we assert the result of the </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">act</span><a id="_idTextAnchor334"/><span class="koboSpan" id="kobo.157.1">ed-on test.</span></span></p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor335"/><span class="koboSpan" id="kobo.158.1">Write deterministic tests</span></h2>
<p><span class="koboSpan" id="kobo.159.1">A unit test should have consistent output whenever and wherever tested to verify the desired function. </span><span class="koboSpan" id="kobo.159.2">A deterministic test should have a consistent behavior every time the test is run </span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.160.1">provided the test code </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">hasn’t changed.</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">Inconsistencies in testing can be called flakiness in tests. </span><span class="koboSpan" id="kobo.162.2">If your test works or passes in development and fails with continuous integration or during QA testing, it hinders development and slows </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">down progress.</span></span></p>
<p><span class="koboSpan" id="kobo.164.1">Flakiness in tests can be avoided if deterministic test cases are written as it helps in understanding the output of every test case quickly and reduces hours of debugging for new </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">t</span><a id="_idTextAnchor336"/><span class="koboSpan" id="kobo.166.1">eam members.</span></span></p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor337"/><span class="koboSpan" id="kobo.167.1">Write good test names and descriptions</span></h2>
<p><span class="koboSpan" id="kobo.168.1">In software engineering, one of the best practices for writing clean code is to always have a </span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.169.1">good naming ability. </span><span class="koboSpan" id="kobo.169.2">As a developer, your variables, functions, methods, or classes should have good and </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">descriptive names.</span></span></p>
<p><span class="koboSpan" id="kobo.171.1">This best practice is also extended to writing test case names. </span><span class="koboSpan" id="kobo.171.2">It is important to have a clean and clear description of your test case to capture exactly when the test is supposed to implemented and the </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">desired output.</span></span></p>
<p><span class="koboSpan" id="kobo.173.1">For example, your test case names should describe the purpose of your test cases, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">following examples:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.175.1">
describe("Test Names", () =&gt; {
 it("is a Vue instance", () =&gt; {});
 it("initializes with correct elements", () =&gt; {});
 it("test for positive number", async () =&gt; {});
 it('has a default message', async () =&gt; {});
 it('can change message', async ()</span><a id="_idTextAnchor338"/><span class="koboSpan" id="kobo.176.1"> =&gt; {});
)};</span></pre>
<h2 id="_idParaDest-154"><a id="_idTextAnchor339"/><span class="koboSpan" id="kobo.177.1">Write tests before or during development (TDD)</span></h2>
<p><span class="koboSpan" id="kobo.178.1">As a professional developer, you need to embed the concept of TDD into your development process </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">and workflow.</span></span></p>
<p><span class="koboSpan" id="kobo.180.1">TDD is </span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.181.1">a software development process that enhances our test cases and software code </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">in parallel.</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">The concept of TDD contradicts the traditional development process because in TDD, developers have to first write test code before writing the actual software code to pass the test </span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.184.1">case written. </span><span class="koboSpan" id="kobo.184.2">This approach ensures that when production code is written, it always complements the </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">test code.</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">Additionally, </span><strong class="bold"><span class="koboSpan" id="kobo.187.1">Behavior-Driven Development</span></strong><span class="koboSpan" id="kobo.188.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.189.1">BDD</span></strong><span class="koboSpan" id="kobo.190.1">) is another popular testing approach. </span><span class="koboSpan" id="kobo.190.2">This approach works well in rapid development settings and encourages more team collaboration to build a shared understanding of </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">the problem.</span></span></p>
<p><span class="koboSpan" id="kobo.192.1">Regardless of what approach you decide to adopt in your project, you can still integrate continuous integration into your development pipeline to automate your software </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">tes</span><a id="_idTextAnchor340"/><span class="koboSpan" id="kobo.194.1">ting processes.</span></span></p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor341"/><span class="koboSpan" id="kobo.195.1">Using mocks and stubs</span></h2>
<p><span class="koboSpan" id="kobo.196.1">When </span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.197.1">creating test </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.198.1">cases, you might be tempted </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.199.1">to perform </span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.200.1">operations on the actual code. </span><span class="koboSpan" id="kobo.200.2">For instance, if you made an API call to an external API, you might want to make such calls during testing, to make sure everything works as planned. </span><span class="koboSpan" id="kobo.200.3">But that wouldn’t be considered best practice. </span><span class="koboSpan" id="kobo.200.4">What you can do is use the mock and stub features of any </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">test framework.</span></span></p>
<p><span class="koboSpan" id="kobo.202.1">A stub is a dummy piece of code that lets the test run without worrying about what happens to it, while a mock is a dummy piece of code that you verify is called correctly as part of the test. </span><span class="koboSpan" id="kobo.202.2">In short, they are substitutes for real, </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">working code.</span></span></p>
<p><span class="koboSpan" id="kobo.204.1">The beauty </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.205.1">of this is </span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.206.1">that you can set them </span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.207.1">up and </span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.208.1">use them to test and verify your actual code works properly without making any expensive API calls or carrying out</span><a id="_idTextAnchor342"/> <span class="No-Break"><span class="koboSpan" id="kobo.209.1">database manipulation.</span></span></p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor343"/><span class="koboSpan" id="kobo.210.1">Leverage automation testing</span></h2>
<p><span class="koboSpan" id="kobo.211.1">As a developer, integrating automated testing into your workflow saves a lot of time when compared </span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.212.1">to manually executing your test case every </span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.213.1">time </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">before deployment.</span></span></p>
<p><span class="koboSpan" id="kobo.215.1">You can use different automated testing frameworks to set it up, but in this chapter, we will see how </span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.216.1">to automate unit testing with Selenium Cloud </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">Grid (</span></span><a href="https://www.lambdatest.com/selenium-grid-online?fp_ref=solomon26"><span class="No-Break"><span class="koboSpan" id="kobo.218.1">https://www.lambdatest.com/selenium-grid-online?fp_ref=solomon26</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.219.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.220.1">Before we delve into automating our test cases, let’s explore how to write a clean and proper </span><a id="_idTextAnchor344"/><span class="koboSpan" id="kobo.221.1">unit test </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">with JavaScript.</span></span></p>
<h1 id="_idParaDest-157"><a id="_idTextAnchor345"/><span class="koboSpan" id="kobo.223.1">JavaScript unit testing</span></h1>
<p><span class="koboSpan" id="kobo.224.1">As a developer, writing unit tests for your task is your responsibility. </span><span class="koboSpan" id="kobo.224.2">It should be part of your day-to-day </span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.225.1">activities as you code. </span><span class="koboSpan" id="kobo.225.2">In JavaScript, you can </span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.226.1">write unit tests the same way you write your real code with the use of different </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">testing libraries.</span></span></p>
<p><span class="koboSpan" id="kobo.228.1">With these testing libraries, testing the functionalities and features of your project becomes very easy because the libraries include different assertion methods to carry out </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">your checks.</span></span></p>
<p><span class="koboSpan" id="kobo.230.1">Let’s explore some of the most popular JavaScript testing frameworks you can use to write your unit tests, integration tests</span><a id="_idTextAnchor346"/><span class="koboSpan" id="kobo.231.1">, and even </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">end-to-end tests.</span></span></p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor347"/><span class="koboSpan" id="kobo.233.1">Popular JavaScript testing frameworks</span></h2>
<p><span class="koboSpan" id="kobo.234.1">Various </span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.235.1">frameworks are helpful for unit testing in JavaScript. </span><span class="koboSpan" id="kobo.235.2">They are </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">as follows:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.237.1">Jest</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.238.1">Mocha</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.239.1">Jasmine</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.240.1">Cypress</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.241.1">Vitest.js</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.242.1">Let’s explore these frameworks in more de</span><a id="_idTextAnchor348"/><span class="koboSpan" id="kobo.243.1">tail in the </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">next subsections.</span></span></p>
<h3><span class="koboSpan" id="kobo.245.1">Jest</span></h3>
<p><span class="koboSpan" id="kobo.246.1">Jest is one </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.247.1">of the most popular testing frameworks for </span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.248.1">JavaScript. </span><span class="koboSpan" id="kobo.248.2">It was designed to mostly work with React and React Native-based applications. </span><span class="koboSpan" id="kobo.248.3">It is open source and easy to get started with. </span><span class="koboSpan" id="kobo.248.4">Jest reduces the extensive time-consuming configuration needed to run software testing in the frontend </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">with JavaScript.</span></span></p>
<p><span class="koboSpan" id="kobo.250.1">It is an assertion library for JavaScript that runs on Node.js and the browser. </span><span class="koboSpan" id="kobo.250.2">Jest can be configured to work with any test runner and unit testing framework, such as Mocha </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">or Jasmine.</span></span></p>
<p><span class="koboSpan" id="kobo.252.1">The growth statistics of the Jest library according to GitHub, as of the time of writing, include more than </span><strong class="bold"><span class="koboSpan" id="kobo.253.1">40k GitHub stars</span></strong><span class="koboSpan" id="kobo.254.1"> and about </span><strong class="bold"><span class="koboSpan" id="kobo.255.1">6.3 million GitHub usage</span></strong><span class="koboSpan" id="kobo.256.1">, accumulating a total of </span><strong class="bold"><span class="koboSpan" id="kobo.257.1">6.4 million</span></strong><span class="koboSpan" id="kobo.258.1"> points, making Jest among the m</span><a id="_idTextAnchor349"/><span class="koboSpan" id="kobo.259.1">ost popular </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">testing frameworks.</span></span></p>
<h3><span class="koboSpan" id="kobo.261.1">Mocha</span></h3>
<p><span class="koboSpan" id="kobo.262.1">Mocha is a </span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.263.1">server-side and client-side testing framework for JavaScript and Node.js. </span><span class="koboSpan" id="kobo.263.2">The key </span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.264.1">features of Mocha are simplicity, flexibility, and fun. </span><span class="koboSpan" id="kobo.264.2">It makes asynchronous testing in JavaScript easy and fun. </span><span class="koboSpan" id="kobo.264.3">Mocha is designed to run serially, allowing for flexible and accurate test reporting </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">and coverage.</span></span></p>
<p><span class="koboSpan" id="kobo.266.1">The growth statistics of the Mocha library according to GitHub, as of the time of writing, include more than </span><strong class="bold"><span class="koboSpan" id="kobo.267.1">21.6k GitHub stars</span></strong><span class="koboSpan" id="kobo.268.1"> and about </span><strong class="bold"><span class="koboSpan" id="kobo.269.1">1.6 million GitHub usage</span></strong><span class="koboSpan" id="kobo.270.1">, accumulating a total of </span><strong class="bold"><span class="koboSpan" id="kobo.271.1">1.66 million</span></strong><span class="koboSpan" id="kobo.272.1">, points, making Mocha a</span><a id="_idTextAnchor350"/><span class="koboSpan" id="kobo.273.1"> very popular </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">testing framework.</span></span></p>
<h3><span class="koboSpan" id="kobo.275.1">Jasmine</span></h3>
<p><span class="koboSpan" id="kobo.276.1">Jasmine is a </span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.277.1">popular JavaScript BDD framework for </span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.278.1">unit testing JavaScript applications. </span><span class="koboSpan" id="kobo.278.2">It combines the power of speed and support for Node.js and the browser to become a robust testing framework </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">for BDD.</span></span></p>
<p><span class="koboSpan" id="kobo.280.1">The growth statistics of the Jasmine library according to GitHub, as of the time of writing, include more than </span><strong class="bold"><span class="koboSpan" id="kobo.281.1">15.4k GitHub stars</span></strong><span class="koboSpan" id="kobo.282.1"> and about </span><strong class="bold"><span class="koboSpan" id="kobo.283.1">2.4 million GitHub usage</span></strong><span class="koboSpan" id="kobo.284.1">, accumulating a total of </span><strong class="bold"><span class="koboSpan" id="kobo.285.1">2.5 million</span></strong><span class="koboSpan" id="kobo.286.1"> points, making Jasmine among th</span><a id="_idTextAnchor351"/><span class="koboSpan" id="kobo.287.1">e most popular </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">testing frameworks.</span></span></p>
<h3><span class="koboSpan" id="kobo.289.1">Cypress</span></h3>
<p><span class="koboSpan" id="kobo.290.1">Cypress is an </span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.291.1">end-to-end JavaScript-based testing framework that changes the way developers approach software testing. </span><span class="koboSpan" id="kobo.291.2">It is built on top of Mocha, making asynchronous </span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.292.1">testing simple and convenient. </span><span class="koboSpan" id="kobo.292.2">In Cypress, unit tests can be configured to execute without even having to run the </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">web server.</span></span></p>
<p><span class="koboSpan" id="kobo.294.1">This feature makes Cypress the ideal tool for testing a JavaScript/TypeScript library that is meant to be used in the browser, and setting up automated testing in your enterprise project is </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">a breeze.</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">The growth statistics of the Cypress library according to GitHub, as of the time of writing, include more than </span><strong class="bold"><span class="koboSpan" id="kobo.297.1">40.2k GitHub stars</span></strong><span class="koboSpan" id="kobo.298.1"> and about </span><strong class="bold"><span class="koboSpan" id="kobo.299.1">535k GitHub usage</span></strong><span class="koboSpan" id="kobo.300.1">, accumulating a total of </span><strong class="bold"><span class="koboSpan" id="kobo.301.1">575k</span></strong><span class="koboSpan" id="kobo.302.1"> points, making Cypress among</span><a id="_idTextAnchor352"/><span class="koboSpan" id="kobo.303.1"> the most popular </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">testing frameworks.</span></span></p>
<h3><span class="koboSpan" id="kobo.305.1">Vitest</span></h3>
<p><span class="koboSpan" id="kobo.306.1">Vitest is a </span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.307.1">blazing-fast unit test framework powered by Vite. </span><span class="koboSpan" id="kobo.307.2">It is a Vite-native unit test framework comprising Vite reusable configs, transformers, resolvers, and plugins. </span><span class="koboSpan" id="kobo.307.3">It is also Jest compatible and uses ESM, TypeScript, and JSX out of </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">the box.</span></span></p>
<p><span class="koboSpan" id="kobo.309.1">It’s fairly new and has gained popularity among developers using Vue.js and the Vite CLI. </span><span class="koboSpan" id="kobo.309.2">The growth statistics of the Vitest library according to GitHub, as of the time of writing, include more than </span><strong class="bold"><span class="koboSpan" id="kobo.310.1">6.4k GitHub stars</span></strong><span class="koboSpan" id="kobo.311.1"> and about </span><strong class="bold"><span class="koboSpan" id="kobo.312.1">24.3k GitHub usage</span></strong><span class="koboSpan" id="kobo.313.1">, accumulating a total of </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.314.1">30.7k</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.315.1"> points.</span></span></p>
<p><span class="koboSpan" id="kobo.316.1">In the </span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.317.1">next section, we will explore how to write your unit tests with JavaScript and how to run your tests manually. </span><span class="koboSpan" id="kobo.317.2">Additionally, we will explore how to automate your testin</span><a id="_idTextAnchor353"/><span class="koboSpan" id="kobo.318.1">g suite during the </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">deployment pipeline.</span></span></p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor354"/><span class="koboSpan" id="kobo.320.1">Unit testing a Vue.js 3 app</span></h1>
<p><span class="koboSpan" id="kobo.321.1">In the previous </span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.322.1">chapter, we created a Pinterest application using Strapi for the backend and Vue.js 3 for </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">the frontend.</span></span></p>
<p><span class="koboSpan" id="kobo.324.1">Previously, we added internationalization, structured the project, and built out a complete Pinterest clone. </span><span class="koboSpan" id="kobo.324.2">In this section, we will continue by using the official project we created for this book to set up unit testing, resulting in a full-blown enterprise-ready Pinterest </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">clone application.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">You can clone the project from this repository, </span><a href="https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications"><span class="koboSpan" id="kobo.327.1">https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications</span></a><span class="koboSpan" id="kobo.328.1">, to jump </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">right in.</span></span></p>
<p><span class="koboSpan" id="kobo.330.1">In the previous chapter, we set up basic unit testing using Vitest and demonstrated how to implement basic unit testing with a </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">helper file.</span></span></p>
<p><span class="koboSpan" id="kobo.332.1">In this chapter, we will explore more advanced ways of testing the units of the Pinterest clone application we are us</span><a id="_idTextAnchor355"/><span class="koboSpan" id="kobo.333.1">ing as the example throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">this book.</span></span></p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor356"/><span class="koboSpan" id="kobo.335.1">What to test</span></h2>
<p><span class="koboSpan" id="kobo.336.1">In the previous chapter, we explored in detail what to test when setting up your testing suites. </span><span class="koboSpan" id="kobo.336.2">In this </span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.337.1">section, we will examine our demo software under test and specify what should be </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">unit tested.</span></span></p>
<p><span class="koboSpan" id="kobo.339.1">In general, there are two things we could test for in Vue.js components</span><a id="_idTextAnchor357"/><span class="koboSpan" id="kobo.340.1">: presentation and (</span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">optionally) behavior.</span></span></p>
<h3><span class="koboSpan" id="kobo.342.1">Presentation</span></h3>
<p><span class="koboSpan" id="kobo.343.1">When fetching data using Apollo Client, components can be in either the </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">loading</span></strong><span class="koboSpan" id="kobo.345.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">success</span></strong><span class="koboSpan" id="kobo.347.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">error</span></strong><span class="koboSpan" id="kobo.349.1"> state. </span><span class="koboSpan" id="kobo.349.2">For each of these states, it’s a good idea to test that the presentation is what we intend it </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">to be.</span></span></p>
<p><span class="koboSpan" id="kobo.351.1">For example, consider </span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.352.1">having a component that presents details about a specific photo (performs a </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">GET_PIN</span></strong><span class="koboSpan" id="kobo.354.1"> query) from our Pinterest </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">clone application.</span></span></p>
<p><span class="koboSpan" id="kobo.356.1">We could have a simple component such as </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.358.1">
&lt;template&gt;
 &lt;div v-if="status === 'loading'"&gt;Loading photo...&lt;/div&gt;
 &lt;div v-else-if="status === 'error'"&gt;An error occurred
 &lt;/div&gt;
 &lt;div v-else&gt;
   &lt;img src="/src/assets/kunal-img.jpg" alt=""
     data-testid="pin"
     class="w-full h-full object-cover rounded-2xl" /&gt;
 &lt;/div&gt;
&lt;/template&gt;
&lt;script setup&gt;
import Button from '../atoms/Button.vue';
defineProps({
 photo: { type: Object, default: () =&gt; { } },
 status: { type: String, default: "Loading" }
});
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.359.1">In this scenario, we will likely want to test </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.361.1">Loading</span></strong><span class="koboSpan" id="kobo.362.1">: How the component renders when it’s fetching the </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">pin (photo)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.364.1">Success</span></strong><span class="koboSpan" id="kobo.365.1">: How the component renders after it’s successfully fetched the </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">pin (photo)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.367.1">Error</span></strong><span class="koboSpan" id="kobo.368.1">: How the component renders if it was unable to fetch the </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">pin (photo)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.370.1">To demonstrate this, let’s implement a unit test against each of the states mentioned in the preceding </span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.371.1">points. </span><span class="koboSpan" id="kobo.371.2">We will be using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">Pin(Photo)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.373.1"> component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.374.1">
import { render } from '@testing-library/vue';
import Card from '../../components/molecules/Card.vue';
test('displays a card with success status', async () =&gt; {
 const { getByTestId } = render(Card, {
   props: {
     status: 'success',
   },
 });
 const card = getByTestId('pin');
 expect(card).toBeDefined();
});
test('displays a card with error status', async () =&gt; {
 const { getByText } = render(Card, {
   props: {
     status: 'error',
   },
 });
 const card = getByText('An error occurred');
 expect(card.textContent).toEqual('An error occurred');
});
test('displays a card with loading status', async () =&gt; {
 const { getByText } = render(Card, {
   props: {
     status: 'loading',
   },
 });
 const card = getByText('Loading photo...');
 expect(card.tex</span><a id="_idTextAnchor358"/><span class="koboSpan" id="kobo.375.1">tContent).toEqual('Loading photo...');
});</span></pre>
<h3><span class="koboSpan" id="kobo.376.1">Behavior (optional)</span></h3>
<p><span class="koboSpan" id="kobo.377.1">We may also </span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.378.1">choose to place behavior in our Vue.js components. </span><span class="koboSpan" id="kobo.378.2">In client-side architecture, we call this interaction logic—a form of decision-making logic executed after the user interacts with the page somehow—such as a key press or a </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">button click.</span></span></p>
<p><span class="koboSpan" id="kobo.380.1">You can also unit test the behaviors of a single component by testing different actions that are performed on the component and making sure the component reacts to </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">it accordingly.</span></span></p>
<p><span class="koboSpan" id="kobo.382.1">Let’s test this </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">Photo</span></strong><span class="koboSpan" id="kobo.384.1"> component’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">click</span></strong><span class="koboSpan" id="kobo.386.1"> event to be sure it responds to the </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">appropriate action:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.388.1">
test('clicks a create pin button', async () =&gt; {
 const { getByTestId, emitted } = render(Card);
 await fireEvent.click(getByTestId('create_pin'));
 expect(emitted()).toHaveProperty('click');
});</span></pre>
<p><span class="koboSpan" id="kobo.389.1">You can follow the preceding sample code snippet to write unit tests for all the components you have created in your enterprise Vue.js </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">3 application.</span></span></p>
<p><span class="koboSpan" id="kobo.391.1">In the repository of this chapter (</span><a href="https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-9"><span class="koboSpan" id="kobo.392.1">https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-9</span></a><span class="koboSpan" id="kobo.393.1">), we have created different components and also written the unit test for them. </span><span class="koboSpan" id="kobo.393.2">You can clone the </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">repository here.</span></span></p>
<p><span class="koboSpan" id="kobo.395.1">In the next </span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.396.1">section, we will run the unit testing manually and how to automate the process using LambdaTest Cloud </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">Grid. </span><span class="koboSpan" id="kobo.397.2">(</span></span><a href="https://www.lambdatest.com/automation-testing/?fp_ref=solomon26"><span class="No-Break"><span class="koboSpan" id="kobo.398.1">https://www.lambdat</span><span id="_idTextAnchor359"/><span class="koboSpan" id="kobo.399.1">est.com/automation-testing/?fp_ref=solomon26</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.400.1">)</span></span></p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor360"/><span class="koboSpan" id="kobo.401.1">Running unit tests manually</span></h2>
<p><span class="koboSpan" id="kobo.402.1">To run </span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.403.1">your test, type the following command into your </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">root terminal:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.405.1">
npm run test:unit
// or
yarn test:unit</span></pre>
<p><span class="koboSpan" id="kobo.406.1">After successfully running the test, you should be greeted with green passes for your test, as in the </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<span class="koboSpan" id="kobo.408.1"><img alt="Figure 9.2 – Unit test passing sample" src="image/Figure_9.02_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.409.1">Figure 9.2 – Unit test passing sample</span></p>
<p><span class="koboSpan" id="kobo.410.1">In this section, we explored best practices in unit testing a Vue.js 3 component. </span><span class="koboSpan" id="kobo.410.2">We discussed, most importantly, what to test and how to implement unit testing in Vue.js 3. </span><span class="koboSpan" id="kobo.410.3">We demonstrated </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.411.1">how to unit test a Vue.js app using Vitest (</span><a href="https://vitest.dev/"><span class="koboSpan" id="kobo.412.1">https://vitest.dev/</span></a><span class="koboSpan" id="kobo.413.1">) and the </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.414.1">Vue.js testing </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">library. </span><span class="koboSpan" id="kobo.415.2">(</span></span><a href="https://github.com/testing-library/vue-testing-library"><span class="No-Break"><span class="koboSpan" id="kobo.416.1">https://</span><span id="_idTextAnchor361"/><span class="koboSpan" id="kobo.417.1">github.com/testing-library/vue-testing-library</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.418.1">)</span></span></p>
<h1 id="_idParaDest-162"><a id="_idTextAnchor362"/><span class="koboSpan" id="kobo.419.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.420.1">This chapter explored everything related to unit testing, including how to unit test a Vue.js 3 component and the component and page methods. </span><span class="koboSpan" id="kobo.420.2">We also learned about unit testing tools such as Jest, Mocha, and Vitest and how to use them to effectively unit test an </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">enterprise project.</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">In this chapter, we explored the benefits, importance, and best practices in writing and executing effective unit testing strategies. </span><span class="koboSpan" id="kobo.422.2">We also learned how to write unit test cases based on the presentation and behavior of the different units of the software </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">under test.</span></span></p>
<p><span class="koboSpan" id="kobo.424.1">This chapter shows you how to create, implement, and run your unit test cases manually during the build process </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">and deployment.</span></span></p>
<p><span class="koboSpan" id="kobo.426.1">In the next chapter, we will explore everything related to integration testing. </span><span class="koboSpan" id="kobo.426.2">We will cover in depth how to perform an integration test on a Vue.js 3 component and pages. </span><span class="koboSpan" id="kobo.426.3">We will also learn about integration testing tools such as Vue.js Testing Library and how to use them to test an enterprise </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">project effectively.</span></span></p>
</div>
</body></html>