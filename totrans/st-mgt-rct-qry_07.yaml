- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Server-Side Rendering with Next.js or Remix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not all of our applications are rendered on the client side. Using frameworks
    that leverage **server-side rendering** (**SSR**) is common nowadays. These frameworks
    have helped improve application performance, and their adoption is growing daily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when using these frameworks, most of the time, we tend to perform data
    fetching or mutations on the server side, which leads to the question:'
  prefs: []
  type: TYPE_NORMAL
- en: Do I still need React Query with an SSR framework?
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll understand how React Query fits with frameworks such
    as `initialData` and `hydrate`.
  prefs: []
  type: TYPE_NORMAL
- en: Once you are familiar with these patterns, you will see how to apply them to
    your Next.js and Remix applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why should I use React Query with server-side rendering frameworks?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `initialData` pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `hydrate` pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_7](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_7).
  prefs: []
  type: TYPE_NORMAL
- en: Why should I use React Query with server-side rendering frameworks?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSR has proven to be a good ally to web developers. With an increase in the
    popularity of full-stack frameworks such as Next.js and, most recently, Remix,
    the React ecosystem has changed, leading to new patterns being applied.
  prefs: []
  type: TYPE_NORMAL
- en: What is server-side rendering (SSR)?
  prefs: []
  type: TYPE_NORMAL
- en: SSR is a process that allows you to render your application on the server instead
    of the browser. During this process, the server sends the rendered page to the
    client. The client then makes the page fully interactive through a process called
    hydration.
  prefs: []
  type: TYPE_NORMAL
- en: Owing to the possibility of using SSR, one of the things that might make sense
    to do is fetch your data on the server. This has many advantages, but one of the
    best is giving your users their pages with the initial data already loaded. Now,
    just because you are loading data on the server side doesn’t invalidate the scenarios
    in which you might need to fetch your data on the client side. If your page contains
    frequently updated data on the client side, React Query continues to be your best
    friend.
  prefs: []
  type: TYPE_NORMAL
- en: But how does React Query fit within our code using frameworks such as Next.js
    or Remix? Will we fetch data on the server and then on the client again?
  prefs: []
  type: TYPE_NORMAL
- en: The short answer is no. If we did that, we would just be wasting memory on the
    server and not leveraging the advantages of SSR. What we can do instead is prefetch
    our data on the server side and feed it to React Query so that it can manage it
    on the client side. That way, when the user gets the page, the page will already
    have the data the user needs, and from that point on, React Query takes care of
    everything.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can apply two patterns to prefetch data on the server and send it to React
    Query on the client side. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `initialData` pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `hydrate` pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the next section, we will learn how to leverage the `initialData` pattern
    and apply it to the frameworks mentioned: Next.js and Remix.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the initialData pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `initialData` pattern is an option you can set in your `useQuery` hook.
    With this option, you can feed `useQuery` with the data that it will use to initialize
    a specific query.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the process of how to leverage the best of your server-side framework
    and React Query with the `initialData` option:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you do is prefetch your data on the server side and send it
    to your component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside your component, you render your query using the `useQuery` hook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this hook, you add the `initialData` option and pass the data you prefetched
    on the server to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s now see how to use this pattern in Next.js.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the initialData pattern in Next.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following snippet, we will fetch some data on the server using Next.js
    `getServerSideProps` and then leverage the `initialData` pattern to feed the data
    to React Query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we apply the `initialData` pattern to a Next.js application.
    Here, we have a component that will be server-side-generated. This is what we
    are doing:'
  prefs: []
  type: TYPE_NORMAL
- en: We do the necessary imports for this component. In this scenario, it’s `axios`
    and our `useQuery` hook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create our query function. In this function, we get access to our query key
    and destructure our username from the query key to perform our `GET` request.
    We then return our query data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we want this page to be server-side-rendered, we include the `getServerSideProps`
    function in it. This function will run on the server side, and in it, we call
    our `fetchData` function to get our server state data and return it as props,
    which will be sent to our `InitialData` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our `InitialData` component, we get access to our `props`. In these `props`,
    we can access the data returned from our `getServerSideProps` function. We then
    pass this data to our created `useQuery` instance as the `initialData` option.
    This means this hook will have the data we fetched at build time as its initial
    data before refetching it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you know how to apply this pattern in Next.js, let us do it in Remix.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the initialData pattern in Remix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following snippet, we will fetch some data on the server using the Remix
    `loader` and then leverage the `initialData` pattern to feed the data to React
    Query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we apply the `initialData` pattern to a Remix application.
    This is what we are doing here:'
  prefs: []
  type: TYPE_NORMAL
- en: We do the necessary imports for this component. In this scenario, it’s `axios`,
    our `useQuery` hook, Remix’s `useLoaderData` hook, and a `json` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create our query function. In this function, we get access to our query key
    and destructure our username from the query key to perform our `GET` request.
    We then return our query data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then create our `loader` function. This is the function Remix uses to allow
    you to load the data on the server side that will be needed in your components.
    Inside it, we fetch our data and then use the `json` function to send an `HTTP`
    response with `application/json content-type` as the header and our data included
    in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our `InitialData` component, we leverage `useLoaderData` to get access to
    the data returned by `loader`. We then pass this data to our created `useQuery`
    instance as the `initialData` option. This means this hook will have the data
    we fetched at build time as its initial data before refetching it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By now, you should be able to use the `initialData` pattern. There are a couple
    of things you need to be aware of to use it more effectively:'
  prefs: []
  type: TYPE_NORMAL
- en: If you have multiple instances of the same query in different places, you must
    always pass `initialData` to them. This means that even if you leverage your query
    at the top level and on a child component, you will have to prop-drill your `initialData`
    until it reaches the desired component that needs the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since you fetch the data on the server and pass it to your hook, React Query
    will base the information it needs to identify when your query was rendered on
    the initial page load instead of the time at which it was fetched on the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us now see the second pattern you can leverage when using React Query with
    server-side-rendered frameworks: the `hydrate` pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the hydrate pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the `hydrate` pattern, you can dehydrate your `QueryClient` with a previously
    prefetched query and send it to your client. On the client side, as soon as the
    page loads and JavaScript is available, React Query will hydrate your `QueryClient`
    with the existing data. After this process, React Query will also ensure your
    queries are up to date.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the process of how to leverage the best of your server-side framework
    and React Query with the `hydrate` pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you do is create a `QueryClient` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the previously created `QueryClient` instance, you leverage its `prefetchQuery`
    method to prefetch the data for that given query key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You dehydrate your `QueryClient` and send it to the client side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your client receives the dehydrated state, hydrates it, and merges it with the
    `QueryClient` in use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside your component, you render your query using the `useQuery` hook with
    the same query key you added in *step 2*. Your query will already have its data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the next section, we will learn how to leverage the `hydrate` pattern and
    apply it to the frameworks mentioned: Next.js and Remix.'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the hydrate pattern in Next.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next.js uses the `_app` component to initialize all your pages and allows you
    to keep some shared state or persist layouts between page changes. Due to this,
    we can leverage it to wrap all our components with `Hydrate`. The `Hydrate` wrapper
    is responsible for receiving `dehydratedState` and hydrating it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now see how to apply this wrapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We do all the necessary imports to set up our components. In this scenario,
    we get the `useState` function from React and `Hydrate`, `QueryClient`, and `QueryClientProvider`
    from React Query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside our `App` component, we do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We start by creating a new `QueryClient` instance and assigning it as a `state`
    variable by using the `useState` hook. This is because we need to make sure this
    data is not shared by different users of our application and requests. This will
    also make sure we only create `QueryClient` once.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then pass our `queryClient` to `QueryClientProvider` to initiate it and allow
    it to be accessed by our React Query hooks. `QueryClientProvider` will also wrap
    our `Component`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we also wrap our `Component` with `Hydrate`. Since `Hydrate` needs
    to receive `dehydratedState` whenever it exists, we get `pageProps` from our `App`
    and pass it to our `Hydrate` state property. This means that for every component
    that receives `dehydratedState` as `props`, these `props` will be passed to our
    `Hydrate` wrapper.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we are all set to start dehydrating data. Let us see how we can do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we prefetch some data, which will be dehydrated and
    then hydrated by React Query. Here is what we are doing:'
  prefs: []
  type: TYPE_NORMAL
- en: We do the necessary imports for this component. In this scenario, it’s `axios`,
    and from the React Query side, the `dehydrate` function, `QueryClient`, and the
    `useQuery` hook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create our query function. In this function, we get access to our query key,
    and destructure our username from the query key to perform our `GET` request.
    We then return our query data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `getServerSideProps`, we do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a new `QueryClient` instance.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then leverage the previously created instance to prefetch a query that will
    be cached under the `[{ queryIdentifier: "api", username: "danieljcafonso" }]`
    query key and use `fetchData` as the query function.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We use `dehydrate` on `queryClient` and return it as `props` so it can be picked
    up in our `App` component.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our `SSR` component, we create a `useQuery` hook with `[{ queryIdentifier:
    "api", username: "danieljcafonso" }]` as the query key and `fetchData` as the
    query function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given that we returned `dehydratedState` from our `getServerSideProps` function,
    this will be passed as `pageProps` and picked up by the `Hydrate` wrapper wrapping
    our component. This means that React Query will pick up our dehydrated state,
    hydrate it, and merge this new data with the current data in `QueryClient`. This
    means that when the hook inside `SSR` first runs, it will already have the data
    prefetched from `getServerSidePros`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to apply this pattern to Next.js, let us do it in Remix.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the hydrate pattern in Remix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remix uses the `root` component to define the root layout of all your pages
    and to allow you to keep some shared state between page changes. The way this
    is done is by using the `Outlet` component. Due to this component and `Outlet`
    at the root level, we can leverage it to wrap all our components with `Hydrate`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, unlike Next.js, there is no way to access `pageProps` to access `dehydratedState`
    at the root level. Therefore, we need to install a third-party package called
    `use-dehydrated-state`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how to add `use-dehydrated-state` to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are running npm in your project, run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you are using Yarn, run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you are using pnpm, run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`use-dehydrated-state` allows us to access our dehydrated state at our root-level
    component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can do the necessary setup to leverage the `Hydrate` and `QueryClientProvider`
    wrappers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We do all the necessary imports to set up our components. In this scenario,
    we get the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remix’s `Outlet`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `useState` function from React
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Hydrate`, `QueryClient`, and `QueryClientProvider` from React Query'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `useDehydratedState` hook from `use-dehydrated-state`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside our `App` component, we do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We start by creating a new `QueryClient` instance and assigning it as a `state`
    variable by using the `useState` hook. This is because we need to make sure this
    data is not shared by different users of our application and requests. This will
    also make sure we only create `QueryClient` once.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then pass our `queryClient` to `QueryClientProvider` to initiate it and allow
    it to be accessed by our React Query hooks. `QueryClientProvider` will also wrap
    the component rendered by `Outlet`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we also wrap `Outlet` with `Hydrate`. Since `Hydrate` needs to receive
    `dehydratedState` whenever it is received from the server, we get it from the
    `useDehydratedState` hook. This means that for every component that receives `dehydratedState`
    from its `loader`, this data will be passed to our `Hydrate` wrapper.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we are all set to start dehydrating data. Let us see how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we are prefetching some data, which will be dehydrated
    and then hydrated by React Query. Here is what we are doing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We do the necessary imports for this component. In this scenario, they are
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `axios` client
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `dehydrate` function, `QueryClient`, and the `useQuery` hook from the React
    Query side
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `json` function from Remix
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We create our query function. In this function, we get access to our query key
    and destructure our username from the query key to perform our `GET` request.
    We then return our query data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `loader`, we do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a new `QueryClient` instance.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then leverage the previously created instance to prefetch a query that will
    be cached under the `[{ queryIdentifier: "api", username: "danieljcafonso" }]`
    query key and use `fetchData` as the query function.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then use `dehydrate` for `queryClient` and return it as an `HTTP` response.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our `Index` component, we create a `useQuery` hook with `[{ queryIdentifier:
    "api", username: "danieljcafonso" }]` as the query key and `fetchData` as the
    query function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given that we returned `dehydratedState` from our `loader` function, this will
    be picked up by `useDehydratedState` and passed to our `Hydrate` wrapper, wrapping
    our component. This means that React Query will pick up `dehydratedState`, hydrate
    it, and merge this new data with the current data in `QueryClient`. Due to this
    process, when the hook inside `Index` first runs, it will already have the data
    that we prefetched from `loader`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter taught us how React Query can complement our server-side-rendered
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how React Query enables you to prefetch data on the server and send
    it to React Query on the client side. To do this, you got to know two patterns,
    `initialData` and `hydrate`. In the `initialData` pattern, you prefetch the data
    on the server and pass it to the `initialData` option in the `useQuery` hook on
    the client side. In the `hydrate` pattern, you prefetch your query on the server,
    dehydrate the query cache, and hydrate it on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 8*](B18501_08.xhtml#_idTextAnchor184), *Testing React Query Hooks
    and Components*, we will focus on one of the things that will help you sleep better
    at night: testing. You will get to know how you can test your component, that
    is, using React Query, as well as some custom hooks for improving your developer
    experience.'
  prefs: []
  type: TYPE_NORMAL
