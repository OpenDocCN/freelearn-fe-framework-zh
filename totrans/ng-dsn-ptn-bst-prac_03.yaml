- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript Patterns for Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since version 2 of the framework, Angular is based on TypeScript for its development,
    both internally and for those who use it to build applications.
  prefs: []
  type: TYPE_NORMAL
- en: This was a controversial decision at the time, as this JavaScript superset,
    created by Microsoft, was new. Nowadays, most web frameworks, such as React, Vue.js,
    and Svelte, support TypeScript, and some web frameworks actively recommend TypeScript
    as the language to use.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will study the best practices and patterns for using TypeScript
    with Angular and beyond; these techniques can be applied to Node.js backend development
    and even other web frameworks, such as React and Vue.js.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll learn how to better declare our application’s methods and functions and
    how to leverage TypeScript’s type inference mechanism to make our classes less
    verbose.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating classes and types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating methods and functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Decreasing verbosity: type inference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Validating types: type guards'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a better alternative to the `any` type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be able to better apply TypeScript resources
    in your projects, improving the quality of your code and the productivity of your
    team.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the instructions in this chapter, you’ll need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visual Studio Code** (**VS** **Code**) ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js 18 or higher ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for this chapter are available at [https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch3](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch3).
  prefs: []
  type: TYPE_NORMAL
- en: Creating classes and types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basis of application development using Angular is object-oriented programming,
    so it is important for us to delve into how to create classes and instantiate
    objects. Using TypeScript instead of pure JavaScript, we have another powerful
    element in our toolbox of types.
  prefs: []
  type: TYPE_NORMAL
- en: By typifying variables and objects, the TypeScript transpiler is able to carry
    out checks and alerts, preventing errors that could occur at runtime during development
    if this process did not exist.
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that after transpiling (a process that transforms TypeScript code
    into JavaScript), the code delivered to the client’s browser is pure JavaScript,
    including some optimizations; that is, code written in TypeScript is no less performant
    than code written directly in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: To start with the fundamentals, let’s explore primitive and basic types.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive and basic types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript, despite not being a strongly typed language, has three types called
    primitives:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean`: Represents the two binary values `false` and `true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string`: Represents a set of characters such as words'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number`: Represents numerical values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each of these primitive types, TypeScript already has a datatype that represents
    them, namely, `Boolean`, `String`, and `Number`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Important
  prefs: []
  type: TYPE_NORMAL
- en: The first letter of the primitive types in TypeScript is in uppercase to differentiate
    it from the primitive JavaScript types. If you want to check a type at runtime
    using the `typeof` function, use the names of the primitives in lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare the variables of these types, just use the `:` symbol in front of
    the variable declaration, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we declare the `name`, `age`, and `isAlive` variables
    as `string`, `number`, and `boolean`, respectively. Note that we can use JavaScript
    type names in TypeScript because TypeScript allows both forms for these primitive
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, it is very common to use the array data structure. This structure
    allows us to store and manipulate a list of values for our applications. TypeScript
    has a type for this structure called `Array`, where it is possible not only to
    create a variable with that type but also to typify what kind of values the array
    will contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this function, we declare the `names` array using the `Array` type and declare
    that it is a `string` list because we are informing it between square braquets..
    In the `surnames` array declaration, we make the same declaration but use a TypeScript
    syntax sugar using `[]` after the `string` type. This way of declaring has the
    same effect; it’s just more succinct.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the example, we use `Array`’s `foreach` method to print the elements
    of the array. Finally, another basic type that is widely used is the `any` type.
    This type tells the TypeScript transpiler not to perform any type checking on
    it, and its content can be type-changed anywhere in the code, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `information` variable is declared as `any` and then we put the `Mario`
    `string` in it. We subsequently redefine the variable with the value `5`.
  prefs: []
  type: TYPE_NORMAL
- en: By default, in TypeScript, every variable that does not have its type declared,
    or that has its value defined in its declaration, is of type `any`.
  prefs: []
  type: TYPE_NORMAL
- en: This language rule allows, for example, a project with JavaScript code to be
    incrementally converted to TypeScript by initially declaring all variables of
    the `any` type. Another use of the `any` type is when your code needs the flexibility
    of JavaScript for some more general algorithm types.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is recommended that Angular developers avoid using `any` because
    it partially disables the checks that TypeScript performs in your code, without
    taking advantage of its power.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll see alternatives throughout the chapter, should you need the flexibility
    of the `any` type, without sacrificing type checking and TypeScript inference.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Building on our knowledge of basic types, let’s now create more complex data
    types. The first one we’re going to explore is **classes**. An essential element
    of object-oriented programming, the class represents a model, which can be real,
    such as a person or vehicle, or abstract, such as a text box on a web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the class, we create the objects that are the elements that our systems
    will manipulate to execute a business rule, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: First, we declare the `Person` class with the `name` and `age` properties by
    typing the properties, and then we create a method for the class called `constructor`.
    This method is special because it defines the rule for how the object will be
    instantiated from this class.
  prefs: []
  type: TYPE_NORMAL
- en: In the `basic_class` function, we instantiate an object called `client`, which
    is of the `Person` type with the `new` keyword. To retrieve the properties of
    this instantiated object, we use the notation `client.name` and `client.age`.
  prefs: []
  type: TYPE_NORMAL
- en: This declaration and use of class in TypeScript is almost the same as JavaScript
    except for typing the attributes of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same example in pure JavaScript would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the process of declaring the class and instantiating an object from
    it changes very little from TypeScript. However, as we will see in the following
    code block, TypeScript provides more resources for the use of the class in our
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to attributes, classes also define methods, which are functions
    that an object can perform. In the example we are working on, we are now going
    to add a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `toString` method returns a `string` that represents the object, so it accesses
    the attribute of the object instance using the reserved JavaScript word `this`.
  prefs: []
  type: TYPE_NORMAL
- en: There is a concept in object-oriented programming called the **encapsulation
    of attributes**. This consists of defining which attributes are accessible to
    the function that instantiates a given object.
  prefs: []
  type: TYPE_NORMAL
- en: 'This concept, important for the correct use of some design patterns, does not
    exist in its entirety in JavaScript. Every class attribute is public, but in TypeScript
    it is implemented and validated by the transpiler, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a property called `id` that is generated when the object is
    instantiated, and we use the reserved word `private`, indicating that it should
    not be accessed from outside the class. Note that in class methods, this attribute
    is accessed normally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try to force access from outside as in the following example to see what
    happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function, we instantiate a `client` object of the `Person` class and
    then we try to modify the `id` attribute. When trying to run the code, the TypeScript
    will indicate the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Error message when accessing a private attribute](img/B19562_03_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Error message when accessing a private attribute
  prefs: []
  type: TYPE_NORMAL
- en: Another object-oriented programming concept is inheritance. It defines an *is
    a* relationship between classes, as in, *a customer is* *a person*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, it makes a class have all the attributes and methods of the extended
    class, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are creating the `Client` class, which extends from the `Person` class.
    We add an attribute called `address` and create the constructor. As it is a class
    derived from `Person`, it is necessary to call the `super` method, which is the
    way we access the methods and attributes of the original class.
  prefs: []
  type: TYPE_NORMAL
- en: When using inheritance, we can optionally rewrite a method of the original class
    as we do with the `toString` method. This concept exists in JavaScript, but with
    TypeScript, the rules for the constructor and method rewrite are checked at compile
    time, giving us more confidence in our development.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In TypeScript, we have another way of typifying the structure of an object
    called an **interface**. The following example demonstrates its use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To declare an interface, we use the reserved word `interface` and declare its
    properties as a class as we saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `interface`, we can proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that to use a class, we just type the variable and declare its values,
    without using the reserved word `new`. This happens because the interface is not
    a JavaScript element and is only used by the TypeScript transpiler to check whether
    the object contains the defined properties.
  prefs: []
  type: TYPE_NORMAL
- en: To prove that the interface does not exist, if we transpile the `interface`
    file, a blank file will be generated by TypeScript!
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also make use of interfaces to create contracts for classes, should
    a class require certain methods and attributes. Let’s see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To define that a certain class follows the `DoSound` contract, we use the reserved
    word `implements`. TypeScript then requires that a method called `doASound` be
    defined and that this method returns a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'This feature of the interface facilitates the use of a very important capability
    of the object-oriented language, which is **polymorphism**. Let’s see the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We create the `makeSound` function, which receives an animal that implements
    the `DoSound` contract. The function is not concerned with the type of animal
    or its attributes; it just needs to follow the `DoSound` interface contract, as
    it will invoke one of its methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular uses this characteristic of TypeScript interfaces a lot, as we can
    see in the declaration of a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When we inform Angular that the component implements the `OnInit` interface,
    it will execute the `ngOnInit` method required at the beginning of the component’s
    lifecycle (we will study this in more detail in [*Chapter 4*](B19562_04.xhtml#_idTextAnchor141),
    *Components* *and Pages*).
  prefs: []
  type: TYPE_NORMAL
- en: Type aliases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last way to type a variable that we will see in this chapter is the simplest
    one, which is to create **type aliases**. Like interfaces, type aliases only exist
    in TypeScript, and we can use them as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we create the `Machine` type, describing the object we want to
    represent, and in the `basic_type` function, we instantiate a variable with that
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we use the attributes of this variable just like the previous examples.
    This demonstrates how much TypeScript maintains the flexibility of JavaScript
    while giving more possibilities to the developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'A well-used feature of type aliases is the creation of a type from other types.
    One of the most common is the union of types, as we can see in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are creating a type called `id`, which can be `string` or `number`.
    For this, we use the `|` symbol, which is the same as used in JavaScript to indicate
    the conditional *OR*.
  prefs: []
  type: TYPE_NORMAL
- en: This feature was important for the use of more advanced techniques, such as
    the `guard` type, which we will see in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: When to use classes, interfaces, or types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With all these ways of creating typed objects, you must be wondering in which
    situations we should use each one. Based on the characteristics of each form,
    we can categorize the use of each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Type alias**: The simplest form of creation, recommended for typing input
    parameters and function returns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`implements` keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Classes**: The basis of object orientation, also present in JavaScript. We
    should use it whenever we need an object with methods and attributes. In Angular,
    all components and services are ultimately objects created from classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that in TypeScript, it is possible to create an `alias` type that behaves
    as an interface, as well as indicate an interface as a parameter and return of
    a function, but the recommendations here advise you to use the best for each type
    of situation and also explain how they are normally used in Angular apps.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a good understanding of the different ways of creating more
    complex variables as objects, let’s get to know how to create functions and methods
    with TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Creating methods and functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the best ways used by TypeScript to improve the developer experience
    in Angular application development is through the ability to type parameters and
    return functions and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Both for developers who create libraries and frameworks and for those who consume
    these software components, knowing what a function expects and what the expected
    return is allows us to reduce the time spent reading and looking for documentation,
    especially the runtime bugs that our system may encounter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To carry out the typing of the parameters and the return of a function, let’s
    consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we start by defining an interface that represents an invoice
    item and then we create a type that will represent an invoice, which in this simplification
    is an array of items.
  prefs: []
  type: TYPE_NORMAL
- en: This demonstrates how we can use interfaces and types to better express our
    TypeScript code. Soon after, we create a function that returns the total value
    of the invoice; as an input parameter, we receive a value with the invoice type,
    and the return of the function will be a `number`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we create an example function to use the `getTotalInvoice` function.
    Here, in addition to type checking, if we use an editor with TypeScript support
    such as VS Code, we have basic documentation and autocomplete, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Documentation generated by TypeScript and visualized by VS Code](img/B19562_03_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Documentation generated by TypeScript and visualized by VS Code
  prefs: []
  type: TYPE_NORMAL
- en: In addition to primitive types and objects, functions must also be prepared
    to handle null data or undefined variables. In the next section, we will explore
    how to implement this.
  prefs: []
  type: TYPE_NORMAL
- en: Working with null values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In TypeScript, by default, all function and method parameters are required and
    checked by the transpiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'If any parameter is optional, we can define it in the type it represents, as
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Within this function of applying a discount to the invoice, we created an optional
    parameter that allows the user of the function to determine a product to apply
    the discount. If the parameter is not defined, the discount is applied to the
    entire invoice.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define an optional parameter, we use the `?` character. In TypeScript, optional
    parameters must be the last to be defined in a function. If we change the position
    of the function parameters the following error is thrown by the transpiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, TypeScript allows you to define a default value for the parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When assigning a value in the parameter declaration, if the function user does
    not use the parameter, a 10% discount will be applied to the invoice items.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen how we can use TypeScript to typify function parameters and returns.
    Now let’s discuss type inference and how we can use it to reduce the verbosity
    of our code.
  prefs: []
  type: TYPE_NORMAL
- en: Decreasing verbosity – type inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw the best TypeScript capabilities that help in the development
    of our Angular projects. We were typing all the variables and relying on the TypeScript
    transpiler to avoid errors that would otherwise occur in our user’s runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now explore TypeScript’s powerful inference mechanisms. Through it, TypeScript
    identifies the types of variables by content, not requiring you to define the
    type explicitly. Let’s observe the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This example is the same as in *Primitive and basic types*, but we directly
    inform the values in the variables. This way of declaring the variable has the
    same effect as the explicit method. If you change the value of a variable to another
    type, TypeScript will perform the validation as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript can also infer complex types, such as arrays and function returns.
    A good practice here is to use the inference capability to write less code and
    type only objects from interfaces, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Validating types – type guards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know the TypeScript inference mechanism, we can understand another
    feature present in it, **type guards**. Let’s consider these in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this function, we can receive a value that can be of the primitive types
    `string` or `number`.
  prefs: []
  type: TYPE_NORMAL
- en: As they are primitive types, we can use the `typeof` function to define whether
    the variable is numeric; otherwise, it is a string and we must convert it to numeric.
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript transpiler can interpret the context of this conditional and
    within each one, it treats the value as a `number` or `string`, including in VS
    Code’s autocomplete.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Inside the conditional TypeScript, which recognizes the variable
    as a number](img/B19562_03_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Inside the conditional TypeScript, which recognizes the variable
    as a number
  prefs: []
  type: TYPE_NORMAL
- en: The VS Code plugin in the figure is running the transpiler in the background
    and identifies that the variable inside the `if` statement can only be a `number`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Inside the conditional else TypeScript, which recognizes the
    variable as a string](img/B19562_03_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Inside the conditional else TypeScript, which recognizes the variable
    as a string
  prefs: []
  type: TYPE_NORMAL
- en: As they are primitive types, we can use the `typeof` function to define whether
    the variable is numeric; otherwise, it is a `string`, and we must convert it to
    numeric.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more complex data types such as objects, this guard using the `typeof`
    function is not possible because it will always recognize the variable of the
    `object` type. However, we can create our own custom type guard functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here we have two interfaces, `Person` and `Company`, and we create a type called
    `Client`. For each type of object that follows the interfaces, we have an `id`
    type `socialSecurityNumber` for people and `corporateNumber` for companies.
  prefs: []
  type: TYPE_NORMAL
- en: To carry out the `guard` type, we created the `isPerson` function. The difference
    regarding this function is that we put the `client is Person` expression in the
    definition of the return of the function.
  prefs: []
  type: TYPE_NORMAL
- en: In it, we define the rule to consider an object as a person and use it in the
    `getID` function. Not only do we have a function that checks the object at runtime,
    but in this way, the TypeScript transpiler checks at compile time whether the
    operation has reported an error.
  prefs: []
  type: TYPE_NORMAL
- en: Using a better alternative to the any type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the development of TypeScript applications, we may have situations where
    we do not know which type of parameter we are going to receive, such as the return
    of an API.
  prefs: []
  type: TYPE_NORMAL
- en: What is trafficked can be defined by creating an interface that represents the
    data, (for more details, see [*Chapter 5*](B19562_05.xhtml#_idTextAnchor163)*,
    Angular Services and the Singleton Pattern*). It is not possible to guarantee
    this because pure text is trafficked on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, we can use the `any` type, which prevents TypeScript from doing
    the type checking.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we can see the use of `any`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code sample, we create an interface that represents a product
    and a type that represents a list of products. We then create a function that
    receives an `id` of the `any` type and searches the `Array`, returning an item
    from the list of products.
  prefs: []
  type: TYPE_NORMAL
- en: 'In these simple examples, we can assume that there is no bug, but let’s create
    a function that will use this snippet and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the item was not found because the variable we passed was a
    `string`. This could happen if the data we are passing to the function came from
    an API or external call, and the data was not properly formatted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the code, we get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Function returned No product found due to the id variable typing](img/B19562_03_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Function returned No product found due to the id variable typing
  prefs: []
  type: TYPE_NORMAL
- en: When we use the `any` type, we give up the advantage of type checking and this
    type of bug can occur in our application. But how can we have the flexibility
    of the `any` type without losing TypeScript’s type checking?
  prefs: []
  type: TYPE_NORMAL
- en: 'In these cases, we use the `unknown` type. This type has the same flexibility
    as the `any` type, but with one detail: TypeScript forces you to perform type
    guarding before using the variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s refactor our example function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here we declare that `id` will be of an `unknown` type and, right after that,
    we make a `guard` type in this variable, dealing with the possible scenario of
    the variable being numerical.
  prefs: []
  type: TYPE_NORMAL
- en: The `any` type will still be used in your application, but consider using the
    `unknown` type to ensure correct type handling when you are not sure who will
    call your function.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how we can use TypeScript to create better-quality code
    with less effort, increasing our productivity. We learned about basic TypeScript
    types, such as `number`, `string`, and `Array`.
  prefs: []
  type: TYPE_NORMAL
- en: We also studied creating classes, interfaces, and type aliases, and how we can
    choose and mix these types of structures to make our code cleaner and more maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned about TypeScript’s type inference mechanism and how we can
    use the concept of type guards to further improve the type-checking mechanism.
    With these concepts, we also became familiar with the `unknown` type, which provides
    a better alternative to the `any` type.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will learn about the basics of the interfaces of an Angular
    project, that is, the Components.
  prefs: []
  type: TYPE_NORMAL
