- en: Our Second Project - The Budgeting App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Staying within a monthly budget is something that I've found difficult to do
    in the past. For our second project, we will build an app that keeps track of
    our budget by letting us set a goal for how much we'd like to spend in a month,
    and then lets us enter expenses into the application and categorize them under
    simple labels. At any point, we can go and look at how we're doing for the month
    and look at our previous months' results.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Planning our second app, `Expenses`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing a popular vector icon library for React Native
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a series of helper methods that will be used throughout our app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a modal that lets us enter our expenses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering a list for the current month, showing the month's progress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like always, let''s begin by initializing a new React Native project using
    the following statement in our command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: While the React Native CLI is doing its work in scaffolding our project, we
    should plan out the functionality of the app.
  prefs: []
  type: TYPE_NORMAL
- en: App planning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once this app is complete, we would like for it to function in the following
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Upon launching the app, if a budget for the month has not yet been set, it should
    ask the user to input their monthly goal and save it in `AsyncStorage`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a budget for the month has been set, the user should be shown a screen
    that contains a button to add their expenses for the month.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Upon tapping on that button, the user should be shown a modal that allows them
    to input details for their expenses: the name, amount, date the purchase was made
    on, and an icon to categorize the item. The modal should allow the user to either
    cancel or save the entry that they make.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the expense is saved, it should then be rendered in a list on the main screen
    that contains the button to add further expenses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list should also prominently display the user's set budget for the month
    along a progress indicator showing how close they are to hitting their budget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The app should also contain a second tab, where the user can view their previous
    months' histories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users should be able to add expenses to any month and delete any expenses as
    well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the first part of this project, we'll tackle the top half of the list.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by installing the vector icon library as we'll be using it in this
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Installing vector icons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most popular vector icon packs for React Native is `react-native-vector-icons`.
    It includes a plethora of icons from different sources, including FontAwesome
    and Google's Material icons pack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing this vector icons pack takes a couple of steps, but we''ll start
    by pulling it down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is now installed as a module, but we still need to link it to our project
    so that this app knows where to look for the files. This is because not every
    app we build will utilize all the native capabilities of the iOS and Android platforms.
    Including all the binaries to support every imaginable native capability will increase
    the size of our applications; instead, any components that rely on native iOS
    and Android code will have to be manually linked to our application, thus giving
    our application access to those pieces of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simple way to link this vector icon library is with the following command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will automatically link libraries with native dependencies
    to your project.
  prefs: []
  type: TYPE_NORMAL
- en: Folder structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following structure includes components that we will wind up building in
    this very chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `utils` folder stores helper methods that we will be using in our application.
    The `dateMethods` deals with the different methods that we will use to get different
    parts of the date, while `storageMethods` handles access to `AsyncStorage`.
  prefs: []
  type: TYPE_NORMAL
- en: Our first bullet point from app planning says that upon launching the app, if
    a budget for this month has not yet been set, it should ask the user to input
    their monthly goal and save it into `AsyncStorage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the preceding intent, we want to do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Grab the current month and year
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve the object storing our expenses in `AsyncStorage` and check the month
    and year to check whether a budget has been set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it hasn't, then prompt the user to enter a budget for the month and save
    it into `AsyncStorage`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's create some helper methods that deal with the dates.
  prefs: []
  type: TYPE_NORMAL
- en: Date methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the things that the `dateMethods.js` file should contain:'
  prefs: []
  type: TYPE_NORMAL
- en: An object that maps the number of the month to its name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Four methods get different parts of the date. Each should accept an optional
    date object or create a new instance of the `Date` object if one is not passed
    in the following ones:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getYear`: This grabs the year number and returns a stringified form of it'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getMonth`: This grabs the month number and returns a stringified form of it'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getDay`: This grabs the day number and returns a stringified form of it'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getMonthString`: This returns the name of the month using the object created
    previously'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how my `dateMethods` file looks after completing the preceding bullet
    points. This is an object mapping month numbers to the stringified name of the
    month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The next one grabs the current year and returns it as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This one gets the current month which is zero-indexed and returns which number
    it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following one gets the day and returns it as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This one returns the name of the month, given its number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, it is time to create some methods to access `AsyncStorage`.
  prefs: []
  type: TYPE_NORMAL
- en: Storage methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `listOfExpenses` we will store in our application will be a multi-layered
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visually, we will build it to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The methods we want to create for storage involve the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getAsyncStorage`: This retrieves the list of expenses in `AsyncStorage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setAsyncStorage`: This accepts an object and saves it into `AsyncStorage`
    as the list of expenses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`checkCurrentMonth`: This lets us accept a month and year as stringified numbers
    and finds out whether a budget has been set for that given month and year, returning
    `false` if it has not, and the budget, if it has been set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`saveMonthlyBudget`: This accepts a month and year as stringified numbers and
    a budget as a number, then creates that `month` object and stores it in the right
    year in our list of expenses, saving it to `AsyncStorage` at the end'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`saveExpenseToMonth`: This accepts a month and year as stringified numbers
    and a single `expense` object, then saves that to the budget for that month and
    year'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resetAsyncStorage`: This is a development-specific method that will erase
    the data in `AsyncStorage` so that we can clear our list whenever we need to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logAsyncStorage`: This is another development-specific method to log the object
    currently stored in `AsyncStorage` so that we can view it whenever needed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Import the `AsyncStorage` API from React Native and the `dateMethods` utility
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Grab the object in storage under the key `expenses` and return it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the `expenses` object in storage with the object passed in as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Grab the `month` and `year` from `dateMethods`, then grab the `expenses` object
    in storage. If that object does not exist or does not have any data for the given
    `year` and/or `month`, return `false`, otherwise return the `budget`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In `saveMonthlyBudget`, we grab the `expenses` object, then we check to see
    whether the result exists; this is so that we can seed `AsyncStorage` with a default
    empty object if we need to, which is important for a new user who hasn''t entered
    data into the app before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We also make checks along the way to see whether our `expenses` object has an
    object pertaining to the specific year passed to it, and then whether that `year`
    object has an object pointing to the specific `month` we're pointing to; if not,
    we create it. After setting up the `month` object with an entered `budget`, `expenses`
    array, and amount already `spent` (number defaulting to zero), we save it right
    back to `AsyncStorage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code calls `setAsyncStorage` and passes it an empty object, erasing
    the `expenses` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Grab the `expenses` object in storage and log it to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: App.js and index.ios.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`App.js` will serve as the initial route for our app''s navigation. It will
    handle the logic that decides whether to show the current month''s expenses or
    a prompt to enter a budget for the month.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The root `index.ios.js` file will be modified in the same way as we structured
    it in the first project of this book, `Tasks`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create the `App.js` file and have it do the following things during
    its `componentDidMount` lifecycle:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On load, we should use our `storageMethods` file to find out whether a budget
    has been set for the current month:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the budget for the current month has been set, we should render it on the
    screen using a `Text` component for the user to see
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If it has not been set, let's throw a basic alert stating the same for the user
    to see
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how i built the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the current month’s budget and set it in state. If there is no budget,
    alert the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Render a `Text` element that states the current month’s budget, if set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `marginTop` property offsets the height of the navigation bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s create a component that will let the user know their budget for
    the month.
  prefs: []
  type: TYPE_NORMAL
- en: The EnterBudget component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The component to enter a budget should do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Prompt the user to enter their budget for the month with a numerical input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Include a button that lets them save the budget. When saved, we will do the
    following things:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have the parent `App.js` component use `saveMonthlyBudget`, created in our `storageMethods`
    file, to save the entered budget
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the parent `App.js` component to reflect the entered budget
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Pop out of the `EnterBudget` component and go back to the `App.js` component
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We should also modify the `App.js` component so that it does the following
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: Pushes the `EnterBudget` component to the navigator in the event that a budget
    has not been set. This should replace the current call to alert the user that
    they have not yet set a budget. This component should not contain a back button
    so that the user is required to enter a budget for the month.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passes the name of the current month in string form to the `EnterBudget` component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stores the current month and year in numerical form in its local state so that
    it can refer to them when required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contains a method that updates itself with the new budget once the user saves
    a number in the `EnterBudget` component. This should be in the form of a prop
    passed into it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like always, spend some time building out this component yourself. When you're
    finished, keep reading and check out the solution I came up with.
  prefs: []
  type: TYPE_NORMAL
- en: EnterBudget component example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building and linking this component involved changing the `App.js` file. Let''s
    take a look at that one first since it passes props down to the `EnterBudget`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the `month` and `year` in state, then call `_updateBudget`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Push `EnterBudget` to the navigator and pass it two props. Hide the navigation
    bar so that the user cannot leave without entering a budget for the month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the budget into storage. The argument is passed from the `EnterBudget`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously found in `componentWillMount`, set the `budget` in state if it exists
    and render `EnterBudget` if it does not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's take a look at the new `EnterBudget` component.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Explicitly define the `props` this component expects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Store the value of the `TextInput` field in state. Prompt the user to enter
    their budget for the month with a numeric `TextInput`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Button` calls `_saveAndUpdateBudget` on press and is disabled if `TextInput`
    is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code calls `saveAndUpdateBudget` from the `App` component and
    `pop` on the navigator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `_setBudgetValue` sets the value of the `TextInput`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This component also received some styling shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Like in the previous containers, we import `Navigator` so that we can offset
    the top margin by its `height`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Styling for the header, text, and input field in `EnterBudget` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'By the end of this section, you should have an `EnterBudget` component that
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_03_001.png)'
  prefs: []
  type: TYPE_IMG
- en: Great job! In the next section, let’s style `App.js` and add a button to open
    a modal.
  prefs: []
  type: TYPE_NORMAL
- en: The AddExpenses container and modal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When planning this app, I wrote that once a budget for the month has been set,
    the user should be shown a screen that contains a button to add their expenses
    for the month.
  prefs: []
  type: TYPE_NORMAL
- en: The button's behavior was also detailed, and we said that upon tapping on that
    button, the user should be shown a modal that allows them to input details for
    their expenses--the name, amount, date the purchase was made on, and an icon to
    categorize the item. The modal should allow the user to either cancel or save
    the entry they make.
  prefs: []
  type: TYPE_NORMAL
- en: We can create one component to add expenses that will contain both the `Button`
    and `Modal`, with the `Modal` defaulting to a hidden state unless activated by
    the `Button`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a component, titled `AddExpenses`, which will start
    off by doing the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Accepting the `month` and `year` as props
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering a `Button` that, when pressed, will alert the user for now
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, we should render the `AddExpenses` component within `App.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Modal` we render will take advantage of these props. I also rendered a
    `Button` that will eventually launch this modal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the changes to the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Pass in the `month` and `year` to `AddExpenses`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you should have a button rendered on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_03_002.png)'
  prefs: []
  type: TYPE_IMG
- en: Great work! Next, we will create a modal that opens when the button is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at modals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modals let us present content over another view. In React Native, we can render
    one using the `Modal` tag. Any child elements within a `Modal` tag are rendered
    within it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modals have a couple of props that we can take advantage of. The ones listed
    as follows will be used in this project, though there are more available in the
    React Native documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`animationType`: This controls how a modal animates when it appears for the
    user. The three options are slide (from bottom), fade, and none.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onRequestClose`: This is a callback that is fired when a modal is dismissed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transparent`: This is a Boolean that determines modal transparency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`visible`: This is a Boolean to determine whether a modal is visible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since this modal will encapsulate a large amount of logic, let''s create a
    new `AddExpensesModal` component that will return this modal. It should do the
    following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Contains a hidden `Modal` component that starts off hidden
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accept the `month` and `year` props from the `AddExpenses` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accept a `modalVisible` Boolean as a prop from `AddExpenses`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render a string with the current month and year
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We should also update the existing `AddExpenses` component to do the following
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: Render the `AddExpensesModal` component when the `AddExpenses` button is pressed,
    passing the `month`, `year`, and `modalVisible` props
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the existing button to toggle the modal’s visibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start by looking at `AddExpenses`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Track the `modalVisible` Boolean in state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Render `AddExpensesModal`, passing it a Boolean for visibility, the `month`,
    and `year`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the `Button` to call `_toggleModal` instead of `alert`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Flip the `modalVisible` Boolean in state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how I built the `AddExpensesModal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Explicitly declare the expected `props` and their datatypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Render a modal with a `slide` animation. Visibility is controlled by the `modalVisible`
    Boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Render a `View` with `Text` within the `Modal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the styling for `AddExpensesModal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Header and TextInput fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may note that we currently don''t have a way to close this modal or add
    any data to create new expenses for our list. Let''s change that by adding the
    following things:'
  prefs: []
  type: TYPE_NORMAL
- en: A header that prompts the user to add an expense
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A normal `TextInput` field that prompts the user for the name of the expense
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A numeric `TextInput` field, set to a numeric keyboard, that prompts the user
    for the cost of the expense
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the changes I made to `AddExpensesModal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Store the `amount` and `description` values for the two `TextInput` fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `render` method of `AddExpensesModal` wraps any components that the Modal
    displays as its children:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `TextInput` field specifically for numeric `amount` input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `TextInput` field specifically for the description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'These two methods set the `amount` and `description` values in state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'New styling has also been added to this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The three amount-related styles are for the row where the `expense` amount is
    entered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `amountRow` has a `justifyContent` property of `space-between` to evenly
    space the `Text` and `TextInput` components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'These styles deal with the `description` and `header` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Your `AddExpensesModal` should resemble something like this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_03_003.png)'
  prefs: []
  type: TYPE_IMG
- en: DatePickerIOS plus ExpandableCell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the next step, you should modify the `AddExpensesModal` component to contain
    the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `DatePickerIOS` component that sets only the date--without time--the expense
    was made on. It should default to today''s date if not specified:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should import and wrap `DatePickerIOS` around the `ExpandableCell` component
    we built for `Tasks`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A line of text that explains the date on which the expense was made.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how I added `ExpandableCell` to `AddExpensesModal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Two new properties are now saved in state: the current `date` and the `expanded`
    Boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: There is no new code in the `ExpandableCell` module from [Chapter 2](ca59eac5-a24f-4ac1-8b42-f1c28d149d74.xhtml),
    *Advanced Functionality and Styling the To-Do List App*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Placement of the `ExpandableCell` component comes right after the `TextInput`
    for the expense''s description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DatePickerIOS` component’s `mode` is set to `date` so that time cannot
    be selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The logic to get the height of `DatePickerIOS` is unchanged from, [Chapter
    2](ca59eac5-a24f-4ac1-8b42-f1c28d149d74.xhtml): *Advanced Functionality and Styling
    the To-Do List App*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Three new methods can be found in this component, all of which are reused from
    our earlier project, `Tasks`, handled by the `ExpandableCell` and its `DatePickerIOS`
    child.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Styling for this component involves just one new property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'By this point, your app will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_03_004.png)'
  prefs: []
  type: TYPE_IMG
- en: Great job with the updates! The `AddExpensesModal` will end up with a lot of
    fields for the user to interact with.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noted that the keyboard does not dismiss itself when `ExpandableCell`
    is interacted with, which can lead to information that the user is unable to access.
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to look at the `ScrollView` component to learn how to dismiss the
    keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: ScrollView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, the *return* key on the software keyboard handles a dismiss action
    for our apps. However, a *return* key does not exist on a numeric keyboard. Instead,
    we can replace our top-level `View` with the `ScrollView` component.
  prefs: []
  type: TYPE_NORMAL
- en: The `ScrollView` component wraps around the rest of your component, providing
    scrolling capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: An important thing to know is that `ScrollView` requires all its children to
    have a `height` property in its styling. If it does not have one, then the child
    element will not render.
  prefs: []
  type: TYPE_NORMAL
- en: Let's quickly replace the `View` that `AddExpensesModal` encapsulates around
    its `Modal` component with a `ScrollView`.
  prefs: []
  type: TYPE_NORMAL
- en: ScrollView example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is how I updated `AddExpensesModal` to include a `ScrollView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the modal''s `View` with `ScrollView`. The `maxHeight` of the `View`
    inside is now `height`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The outer `View` container that was the direct child of the `Modal` component
    has been swapped out with a `ScrollView`.
  prefs: []
  type: TYPE_NORMAL
- en: The `maxHeight` property in the `View` that encapsulates `ExpandableCell` has
    been changed into a `height` property so that it renders in the `ScrollView`.
  prefs: []
  type: TYPE_NORMAL
- en: Saving expenses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to allow entries to be saved to the app. Let''s modify `AddExpensesModal`
    again and add the following features; you will also need to add some methods into
    `storageMethods` as well as the `AddExpenses` component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A button to save the expense, with the following conditions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should only be enabled if all the fields of the modal are filled out.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When pressed, the expense name, amount, and date should be saved into `AsyncStorage`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The date should be formatted with Moment the same way we formatted it for the
    `ExpandableCell` title.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When this logic finishes, the modal should be closed and the information entered
    should be cleared. The closing of the modal should be passed in as a prop from
    the parent `AddExpenses` component since it already has a method to toggle the
    modal:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A new helper method in `storageMethods` should be created to handle the logic
    of saving an expense into `AsyncStorage`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Another helper method in `storageMethods` should be written to tally each expense
    for the month and set it to the `spent` property of that specific month. It should
    be fired when a new expense is added to the month's `expenses` array, and then
    modify that month's `spent` property with the tally before the expense is saved
    into `AsyncStorage`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Another button to cancel the expense, closing the `AddExpensesModal` and clearing
    any information previously entered. It should also have access to the same method
    from `AddExpenses` to toggle the modal.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a reminder, earlier in the chapter, we visualized a single object in our
    list of expenses to be structured in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Do not worry about the `category` key for now; that will come in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing I did was go to `storageMethods` and create two new methods: `getTotalSpentForMonth`
    and `saveItemToBudget`. The first function, `getTotalSpentForMonth`, takes in
    an array and iterates through it. It returns the total amount spent by converting
    the strings to numbers with `parseInt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The second function, `saveItemToBudget`, is an asynchronous one and starts
    by taking in the `month`, `year`, and `expenseObject` as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: It grabs the `expenses` object stored in `AsyncStorage`, creates a new array
    with the array spread operator (`...`) to add the new `expenseObject` argument
    to it, and then calls `getTotalSpentForMonth` with the new array.
  prefs: []
  type: TYPE_NORMAL
- en: Afterwards, it assigns the new array to the `expenses` property for the month
    and the total is calculated as the new total amount spent. Finally, it saves it
    to `AsyncStorage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next file I modified was `AddExpenses`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, I'm passing `_toggleModal` into the `AddExpensesModal`
    component so that it can toggle the modal between its visible and invisible states.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The two `Buttons` are rendered after the `View` that encapsulates `ExpandableCell`.
    The Save button is disabled unless each field contains a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code sets the `amount` and `description` values to empty strings,
    clearing them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code creates an `expense` object and calls `saveItemToBudget`
    from `storageMethods`, passing it in. Then, it clears the `amount` and `description`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'By this point, your `AddExpensesModal` should be nearly complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_03_005.png)'
  prefs: []
  type: TYPE_IMG
- en: Good job on your progress! Let's switch gears and begin to address the rendering
    of our month's expenses. We will revisit this component in the next chapter so
    that we can add the functionality of categorizing expenses by icons.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the current month's expenses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next feature we wrote about earlier in this chapter was that if the expense
    is saved, it should then be rendered in a list on the main screen that contains
    the button to add further expenses.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will create that list. We should create a component called
    `CurrentMonthExpenses` and make modifications to the existing files to support
    it.
  prefs: []
  type: TYPE_NORMAL
- en: You should add a new function to `storageMethods` that accepts a month and year,
    returning the budget, list of expenses, and the amount spent for that month and
    year.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CurrentMonthExpenses` component should do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Render a header that shows the current month's name and budget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display a `ListView` of the month's expenses, retrieved from `AsyncStorage`,
    with some styling and formatting. At the very least, it should include the description
    of the expense as well as the dollar amount.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ListView` being rendered should be its own component so that we can reuse
    it in the next chapter for the prior months.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The rows being rendered in the `ListView` should be written as its component
    as well.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, your `App.js` file should do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Render `CurrentMonthExpenses` right before the `AddExpenses` component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load this list when the component is mounted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update `ListView` in `CurrentMonthExpenses` when a new expense has been added
    by `AddExpenses`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a result, you may need to modify `AddExpenses` to do as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Accept a callback as a prop that will propagate up to `App.js` when the modal
    is toggled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you have finished the preceding procedure, come back and check out the
    code I wrote.
  prefs: []
  type: TYPE_NORMAL
- en: CurrentMonthExpenses example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing I did was add and export a function called `getMonthObject`
    into `storageMethods.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getMonthObject` method grabs the `expenses` object from `AsyncStorage`,
    checks for the existence of the `year` and `month` object, then returns it if
    possible. Here is how I used that method within the new `currentMonthExpenses`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'I start by setting up a `ListView.DataSource` instance in anticipation of the
    `ListView` being rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The `render` method of `CurrentMonthExpenses` creates a header for our `month`
    and `budget`, then creates a `ListView`. This `ListView` is also using the `renderSeparator`
    prop, which renders a horizontal line to separate the items on the list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Data pertaining to the `expenses` array and `budget` are obtained as props
    passed down to this component from its parent, `App.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_renderRowData` function renders a single expense row using the `ExpenseRow`
    component, which we will look at in the following section. Then, `_renderRowSeparator`
    returns a simple view that contains a style for the separator. Check this out
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the styling for `CurrentMonthExpenses`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Styling is standard for our component, though `rowSeparator` is a new one. The
    `height` for this component is set to the `hairlineWidth` property of the `StyleSheet`.
    This is how we render the thin line that separates each individual row in a `ListView`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: This syntax might look new to you, and it’s worth taking a moment to cover it.
    What you are seeing here is a **stateless functional component**. It is a function
    that takes in any number of props passed into it, and returns a component that
    can be used in React applications.
  prefs: []
  type: TYPE_NORMAL
- en: The reason `ExpenseRow` is being written as a stateless functional component
    is because we don’t intend on adding any heavy logic to it or using any React
    life cycle events.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two big changes to the `render` method of `App.js`: First, we are
    rendering `CurrentMonthExpenses` prior to `AddExpenses` and, second, we are passing
    a callback to `AddExpenses`, titled `updateCurrentMonthExpenses`, pointing to
    the similarly named `_updateCurrentMonthExpenses` method in this component. We
    will look at that one shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The main change to `_updateBudget` is that we are firing `_updateCurrentMonthExpenses` so
    that when the app is opened by the user, we can populate the list of expenses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The following is the function that does the bulk of the legwork. As an asynchronous
    function, it starts using the `getMonthObject` function from `storageMethods`
    that we built earlier in this section and then checks to see whether it exists.
    If it does, then it will set the `budget`, `expenses` array, and `amount` spent
    to state. This in turn triggers a re-render, passing any changed values down to
    the `CurrentMonthExpenses` component.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `AddExpense` component, the `_toggleModal` method now fires the `updateCurrentMonthExpenses`
    callback so that when the modal is toggled, the most up-to-date list of expenses
    is passed to the `CurrentMonthExpenses` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how the `CurrentExpenses` modal should now look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_03_006.png)'
  prefs: []
  type: TYPE_IMG
- en: Great job on your progress so far! This is just the beginning of how we will
    build this app, and we will do even more in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started building our budgeting app. We installed a popular
    vector icon library, discovered how to link that library to our project in Xcode,
    and then wrote a basic version of our app.
  prefs: []
  type: TYPE_NORMAL
- en: This included a basic helper library that managed date methods and another to
    manage storage.
  prefs: []
  type: TYPE_NORMAL
- en: In the app, we created a prompt for the user to enter their budget for the month
    and ensured that it collected this data before letting them proceed to add in
    expenses. Then, we used a modal to show and hide the fields for a user to add
    a new expense into the app and updated the `ListView` component to reflect the
    newly added expense.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will get more advanced. We will finally put that vector icon
    library to good use by letting the user categorize their expenses by icon, and
    then let them look at the past months' data by creating a second section of our
    app, which is controlled by a tab bar. Additionally, we will create a progress
    view to track the total amount already spent by the user for the month, so that
    they can track their spending better.
  prefs: []
  type: TYPE_NORMAL
