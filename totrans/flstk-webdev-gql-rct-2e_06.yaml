- en: '*Chapter 4*: Hooking Apollo into React'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sequelize makes it easy to access and query our database. Posts, chats, and
    messages can be saved to our database in a snap. React helps us to view and update
    our data by building a **user interface** (**UI**).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will introduce Apollo's React client to our frontend to
    connect it with the backend. We will query, create, and update post data using
    our frontend.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Apollo Client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending requests with GQL and Apollo's Query component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutating data with Apollo Client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing chats and messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pagination in React and GraphQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging with the Apollo Client Devtools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available in the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter04)'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Apollo Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have tested our GraphQL **application programming interface** (**API**) multiple
    times during development. We can now start to implement the data layer of our
    frontend code. In later chapters, we will focus on other tasks, such as authentication
    and client-side routing. For now, we will aim to use our GraphQL API with our
    React app.
  prefs: []
  type: TYPE_NORMAL
- en: To start, we must install the React Apollo Client library. Apollo Client is
    a GraphQL client that offers excellent integration with React and the ability
    to easily fetch data from our GraphQL API. Furthermore, it handles actions such
    as caching and subscriptions, to implement real-time communication with your GraphQL
    backend. Although Apollo Client is named after the Apollo brand, it is not tied
    to Apollo Server. You can use Apollo Client with any GraphQL API or schema out
    there, as long as they follow the protocol standards. You will soon see how perfectly
    the client merges with our React setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, there are many alternatives out there. You can use any GraphQL client
    that you wish with the current API that we have built. This openness is the great
    thing about GraphQL: it uses an open standard for communication. Various libraries
    implement the GraphQL standard, and you are free to use any of them.'
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The most well-known alternatives are Relay (which is made by Facebook) and `graphql-request`
    (which is made by the people behind Prisma). All of these are great libraries
    that you are free to use. Personally, I mostly rely on Apollo, but Relay is highly
    recommended as well. You can find a long list of packages related to the GraphQL
    ecosystem at [https://github.com/chentsulin/awesome-graphql](https://github.com/chentsulin/awesome-graphql).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to special client libraries, you could also just use a plain `fetch`
    method or `XMLHttpRequest` requests. The disadvantage is that you need to implement
    caching, write `request` objects, and integrate the `request` method into your
    application on your own. I do not recommend doing this because it takes a lot
    of time and you want to put that time into your business, not into implementing
    existing functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Apollo Client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use `npm` to install our client dependencies, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to install the following two packages to get the GraphQL client running:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@apollo/client` is the wrapping package for all of the packages that we installed.
    Apollo Client relies on all the other packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`graphql` is a reference implementation for GraphQL and provides logic to parse
    GraphQL queries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will see how these packages work together in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with the manual setup of Apollo Client, create a new folder
    and file for the client, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We will set up Apollo Client in this `index.js` file. Our first setup will represent
    the most basic configuration to get a working GraphQL client.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The code that follows was taken from the official Apollo documentation. Generally,
    I recommend reading through the Apollo documentation as it is very well written.
    You can find this at [https://www.apollographql.com/docs/react/essentials/get-started.html](https://www.apollographql.com/docs/react/essentials/get-started.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Just insert the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code uses all of the new packages, apart from `react-apollo`.
    Let''s break down the code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, at the top of the file, we imported all required functions and classes
    from the `@apollo/client` package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We instantiated `ApolloClient`. For this to work, we passed some parameters,
    which are the `link` and `cache` properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `link` property is filled by the `from` command. This function walks through
    an array of links and initializes each of them, one by one. The links are described
    further here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a. The first link is the error link. It accepts a function that tells Apollo
    what should be done if an error occurs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. The second link is the **HyperText Transfer Protocol** (**HTTP**) link for
    Apollo. You have to offer a **Uniform Resource Identifier** (**URI**), under which
    our Apollo or GraphQL server is reachable. Apollo Client sends all requests to
    this URI. Notably, the order of execution is the same as the array that we just
    created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `cache` property takes an implementation for caching. One implementation
    can be the default package, `InMemoryCache`, or a different cache.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are many more properties that our links can understand (especially the
    HTTP link). They feature a lot of different customization options, which we will
    look at later. You can also find them in the official documentation, at [https://www.apollographql.com/docs/react/](https://www.apollographql.com/docs/react/).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the preceding code snippet, we exported the initialized Apollo Client using
    the `export default client` line. We are now able to use it in our React app.
  prefs: []
  type: TYPE_NORMAL
- en: The basic setup to send GraphQL requests using Apollo Client is finished. In
    the next section, we will send our first GraphQL request through Apollo Client.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Apollo Client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before inserting the GraphQL client directly into our React application tree,
    we should test it. We will write some temporary code to send our first GraphQL
    query. After testing our GraphQL client, we will remove the code again. Follow
    these next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the package at the top of the Apollo Client setup, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the following code before the client is exported:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code is almost the same as the example from the Apollo documentation,
    but I have replaced their query with one that matches our backend.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we used the `gql` tool from Apollo Client to parse a `gql` command parses
    this literal to an **abstract syntax tree** (**AST**). ASTs are the first step
    of GraphQL; they are used to validate deeply nested objects, the schema, and the
    query. The client sends our query after the parsing has been completed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you want to know more about ASTs, the people at *Contentful* wrote a great
    article about what ASTs mean to GraphQL, at [https://www.contentful.com/blog/2018/07/04/graphql-abstract-syntax-tree-new-schema/](https://www.contentful.com/blog/2018/07/04/graphql-abstract-syntax-tree-new-schema/).
  prefs: []
  type: TYPE_NORMAL
- en: To test the preceding code, we should start the server and the frontend. One
    option is to build the frontend now, and then start the server. In this case,
    the `npm run server` and then open a second terminal. Then, you can start the
    `webpack` development server by executing `npm run client`. A new browser tab
    should open automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we have forgotten something: the client is set up in our new file,
    but it is not yet used anywhere. Import it in the `index.js` root file of our
    client React app, below the import of the `App` component, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The browser should be reloaded, and the query sent. You should be able to see
    a new log inside the console of the developer tools of your browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Manual client response'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.01_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – Manual client response
  prefs: []
  type: TYPE_NORMAL
- en: 'The `data` object looks much like the response that we received when sending
    requests through Postman, except that it now has some new properties: `loading`
    and `networkStatus`. Each of these stands for a specific status, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`loading`, as you might expect, indicates whether the query is still running
    or has already finished.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`networkStatus` goes beyond this and gives you the exact status of what happened.
    For example, the number 7 indicates that there are no running queries that produce
    errors. The number 8 means that there has been an error. You can look up the other
    numbers in the official GitHub repository, at [https://github.com/apollographql/apollo-client/blob/main/src/core/networkStatus.ts](https://github.com/apollographql/apollo-client/blob/main/src/core/networkStatus.ts).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have verified that the query has run successfully, we can connect
    Apollo Client to the React `import` statement in the `App.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: Binding Apollo Client to React
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have tested Apollo Client and have confirmed that it works. However, React
    does not yet have access to it. Since Apollo Client is going to be used everywhere
    in our application, we can set it up in our root `index.js` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned in [*Chapter 1*](B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017),
    *Preparing Your Development Environment*, you should only edit this file when
    the whole application needs access to the new component. In the preceding code
    snippet, you can see that we import the last package that we installed at the
    beginning, from `@apollo/client/react`. The `ApolloProvider` component that we
    extracted from it is the first layer of our React application. It surrounds the
    `App` component, passing the Apollo Client that we wrote to the next level. To
    do this, we pass `client` to the provider as a property. Every underlying React
    component can now access Apollo Client.
  prefs: []
  type: TYPE_NORMAL
- en: We should be now able to send GraphQL requests from our React app.
  prefs: []
  type: TYPE_NORMAL
- en: Using Apollo Client in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apollo Client gives us everything that we need to send requests from our React
    components. We have already tested that the client works. Before moving on, we
    should clean up our file structure, to make it easier for us later in the development
    process. Our frontend is still displaying posts that come from static demo data.
    The first step is to move over to Apollo Client and fetch the data from our GraphQL
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these instructions to connect your first React component with Apollo
    Client:'
  prefs: []
  type: TYPE_NORMAL
- en: Clone the `App.js` file to another file, called `Feed.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove all parts where React `Helmet` is used, remove the `Feed` instead of
    `App`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `App.js` file, remove all of the parts that we have left in the `Feed`
    component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Furthermore, we must render the `Feed` component inside of the `App` component.
    It should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The corresponding `Feed` component should only include the parts where the news
    feed is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: We imported the `Feed` component and inserted it inside of the `return` statement
    of our `App` component so that it is rendered. The next chapter focuses on reusable
    React components and how to write well-structured React code. Now, let's take
    a look at why we split our `App` function into two separate files.
  prefs: []
  type: TYPE_NORMAL
- en: Querying in React with Apollo Client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apollo Client offers one primary way to request data from a GraphQL API. The
    `useQuery` function offered by the `@apollo/client` package provides the ability
    to request data via React Hooks within a functional React component. Beyond that,
    you can still rely on the plain `client.query` function for class-based components
    if required. There had been multiple ways to do this before, which were deprecated
    when the new version of Apollo Client was released. Before, you were able to use
    a `Query` component of Apollo, which is a special React component. Both approaches
    still exist but are deprecated, so it is not recommended to use them anymore.
    This is the reason why those approaches will not be explained in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Apollo useQuery Hook
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The newest version of Apollo Client comes with the `useQuery` Hook. You just
    need to pass the GraphQL query string to the `useQuery` Hook and it will return
    you an object that includes `data`, `error`, and `loading` properties that you
    can use to render your UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual way of implementing this `useQuery` Hook is very straightforward.
    Just follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the demo posts from the top of the `Feed.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the `useState(initialPosts)` line so that we can query the posts instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `gql` function and the `useQuery` Hook from Apollo and parse the
    query, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the `useQuery` Hook within the `Feed` function at the top, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before the actual `return` statement, add the following two statements, which
    will render loading and error messages if there have been any:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Beneath these statements and before the last `return` statement, add this line
    of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will make the `posts` property accessible from the data returned by the
    `useQuery` function if it is no longer loading and there is no error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that the function is now way cleaner because we only loop over the `posts`
    property and return the markup.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In comparison with the older approaches, the `useQuery` Hook is easy to understand
    and also allows us to write readable and understandable code.
  prefs: []
  type: TYPE_NORMAL
- en: The rendered output should look like that shown in [*Chapter 1*](B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017),
    *Preparing Your Development Environment*. The form to create a new post is not
    working at the moment because of our changes; let's fix this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Mutating data with Apollo Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have replaced the way we get data in our client. The next step is to switch
    the way in which we create new posts, too. Before Apollo Client, we had to add
    new fake posts to the array of demo posts manually, within the memory of the browser.
    Now, everything in our text area is sent with the `addPost` mutation to our GraphQL
    API, through Apollo Client.
  prefs: []
  type: TYPE_NORMAL
- en: As with the GraphQL queries, there is a `useMutation` Hook that you can use
    to send a mutation against our GraphQL API. Before, there was also an HOC method
    and a separate `Mutation` component, which have been deprecated as well. They
    still exist for backward compatibility, but we will not cover them in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Apollo useMutation Hook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The newest version of Apollo Client comes with the `useMutation` Hook. The method
    works equally to the `useQuery` Hook—you just need to pass the parsed mutation
    string to it. In response to that, the `useMutation` Hook will return a function
    equally named to the mutation, which you can use to trigger those GraphQL requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these instructions to implement the `useMutation` Hook and start using
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `useMutation` Hook from the `@apollo/client` package, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Parse the `addPost` mutation string below the `getPost` query with the `gql`
    function, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `Feed` component, add the following line of code to get the `addPost`
    function, which you can use in the `Feed` component wherever you want:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have got the `addPost` function, we can start making use of it.
    Just update the `handleSubmit` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we completely got rid of the `newPost` object and just send
    the post's text. Our GraphQL API will create an **identifier** (**ID**) on insert
    to the database. As mentioned in [*Chapter 3*](B17337_03_Final_ASB_ePub.xhtml#_idTextAnchor054),
    *Connecting to the Database*, we statically add the first user as the author of
    the post.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can try to add a new post through the frontend but you won't be able to
    see it immediately. The form will be empty, but the new post will not be shown.
    This happens because the current state (or cache) of our component has not yet
    received the new post. The easiest way to test that everything has worked is to
    refresh the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is not the way that it should work. After the mutation has been
    sent, the new post should be directly visible in the feed. We will fix this now.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the UI with Apollo Client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After running the `addPost` mutation, the request goes through to the server
    and saves the new post in our database without any problems. However, we still
    cannot see the changes take effect in the frontend immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two different ways to update the UI after a mutation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Refetching the dataset**: This is easy to implement but it refetches all
    of the data, which is inefficient.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Updating the cache according to the inserted data**: This is harder to understand
    and implement, but it attaches the new data to the cache of Apollo Client, so
    no refetching is needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use these solutions in different scenarios. Let's take a look at some examples.
    Refetching makes sense if further logic is implemented on the server that is hidden
    from the client when requesting a list of items and is not applied when inserting
    only one item. In these cases, the client cannot simulate the state of the typical
    response of a server.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the cache, however, makes sense when adding or updating items in a
    list, such as our post feed. The client can insert the new post at the top of
    the feed.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by simply refetching requests, and then we'll go over the cache
    update implementation. The following sections (and chapters) will assume that
    you are not using the HOC method.
  prefs: []
  type: TYPE_NORMAL
- en: Refetching queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As mentioned previously, this is the easiest method to update your UI. The
    only step is to set an array of queries to be refetched. The `useMutation` function
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Each object that you enter in the `refetchQueries` array needs a `query` property.
    Each component relying on one of those requests is rerendered when the response
    for its associated query arrives. It also includes components that are not inside
    of the `Feed` component. All components using the post's `GET_POSTS` query are
    rerendered.
  prefs: []
  type: TYPE_NORMAL
- en: You can also provide more fields to each query, such as variables to send parameters
    with the `refetch` request. Submitting the form resends the query, and you can
    see the new post directly in the feed. Refetching also reloads the posts that
    are already showing, which is unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at how we can do this more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Apollo Client cache
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We want to explicitly add only the new post to the cache of Apollo Client. Using
    the cache helps us to save data by not refetching the complete feed or rerendering
    the complete list. To update the cache, you should remove the `refetchQueries`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are technically at least two ways to update the cache on response of
    the mutation request. The first one is pretty straightforward and simple. You
    can then introduce a new property, called `update`, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The new property runs when the GraphQL `addPost` mutation has finished. The
    first parameter that it receives is the `cache` parameter of Apollo Client, in
    which the whole cache is saved. The second parameter is the returned response
    of our GraphQL API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Updating the cache works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `cache.readQuery` function by passing `query` as a parameter. It reads
    the data, which has been saved for this specific query inside of the cache. The
    `data` variable holds all of the posts that we have in our feed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have all of the posts in an array, we can add the missing post.
    Make sure that you know whether you need to prepend or append an item. In our
    example, we create a `newData` object with a `posts` array inside it that consists
    of the newly added post at the top of our list and a destructured list of the
    old posts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to save the changes back to the cache. The `cache.writeQuery` function
    accepts the `query` parameter that we used to send the request. This `query` parameter
    is used to update the saved data in our cache. The second parameter is the data
    that should be saved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the cache has been updated, our UI reactively renders the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In reality, you can do whatever you want in the `update` function, but we only
    use it to update the Apollo Client store.
  prefs: []
  type: TYPE_NORMAL
- en: The second way looks a bit more complicated but represents the way that is shown
    in the official documentation. The `update` function looks a bit more complex
    but comes with a small improvement of performance. It is your choice which one
    you like more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just replace the `update` function of the `useMutation` Hook, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: What the preceding code does is use the `cache.modify` function, which allows
    a more precise update than the one we did before. Instead of updating the whole
    `GET_POSTS` query within the Apollo Client, we are using the `cache.writeFragment`
    method of the `cache` object to update the cache and the UI only with the new
    post. This will improve the performance of our components, especially as the component
    logic grows.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be a bit more optimistic about the response of
    our server and will add the item before the request's response successfully arrives.
  prefs: []
  type: TYPE_NORMAL
- en: Optimistic UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apollo provides a great feature of being able to update the UI in an optimistic
    manner. An optimistic manner means that Apollo adds the new data or post to the
    storage before the request has finished. The advantage is that the user can see
    the new result, instead of waiting for the response of the server. This solution
    makes the application feel faster and more responsive.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section expects the `update` function of the `Mutation` component to already
    be implemented. Otherwise, this UI feature will not work. We need to add the `optimisticResponse`
    property to our mutation next to the `update` property of the `useMutation` configuration,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `optimisticResponse` property can be anything from a function to a simple
    object. The return value, however, needs to be a GraphQL `response` object. What
    you see here is an `addPost` object that looks as though our GraphQL API could
    return it, if our request is successful. You need to fill in the `__typename`
    fields, according to the GraphQL schema that you are using. That is why the `Post`
    and `User` type names are inside of this fake object.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, you can also add the `optimisticResponse` property on the actual
    call to `addPost` next to the `variables` property, but I think this is nothing
    that we need to pass with every call to this function but that actually should
    be set globally to the `useMutation` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: The `id` property of the optimistic response is set to `-1`. React expects that
    every component in a loop gets a unique `key` property. We usually use the `id`
    property of a post as the `key` value. -1 is never used by any other post because
    MySQL starts counting at 1\. Another advantage is that we can use this `id` property
    to set a special class to the post item in our list.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the username and the user's avatar are set to `loading`. That is
    because we don't have built-in authentication. React and Apollo do not have a
    user associated with the current session, so we cannot enter the user's data into
    the `optimisticResponse` property. We fix this once the authentication is ready.
    This is an excellent example of how to handle a situation in which you do not
    have all of the data until you receive a response from the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set a particular class on the list item, we conditionally set the correct
    `className` property in our `map` loop. Insert the following code into the `return`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'An example CSS style for this might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: CSS animations make your applications more modern and flexible. If you experience
    issues when viewing these in your browser, you may need to check whether your
    browser supports them.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the result in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Loading optimistic response'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.02_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – Loading optimistic response
  prefs: []
  type: TYPE_NORMAL
- en: The loading spinner and the username are removed once the response arrives from
    our API, and the `update` function is executed again with the real data. You do
    not need to take care of removing the loading post yourself as this is done by
    Apollo automatically. Any spinner component from an `npm` package or GIF file
    can be used where I have inserted the loading animation. The file that I am using
    needs to be saved under the `public` folder, with the name `loading.gif`, so that
    it can be used through the CSS we added in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: Everything is now set up for sending new posts. The UI responds immediately
    and shows you the new post.
  prefs: []
  type: TYPE_NORMAL
- en: However, what about new posts from your friends and colleagues? Currently, you
    need to reload the page to see them, which is not very intuitive. At the moment,
    we only add the posts that we send on our own but do not receive any information
    about new posts from other people. I will show you the quickest way to handle
    this in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Polling with Apollo Client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Polling** is nothing more than rerunning a request after a specified interval.
    This procedure is the simplest way to implement updates for our news feed. However,
    multiple issues are associated with polling, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It is inefficient to send requests without knowing whether there is any new
    data. The browser might send dozens of requests without ever receiving a new post.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we directly send the initial request again, we will get all of the posts,
    including those that we are already showing to the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When sending requests, the server needs to query the database and calculate
    everything. Unnecessary requests cost money and time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are some use cases in which polling makes sense. One example is a real-time
    graph, in which every axis tick is displayed to the user, whether there is data
    or not. You do not need to use an interrupt-based solution, since you want to
    show everything. Despite the issues that come with polling, let''s quickly run
    through how it works. All you need to do is fill in the `pollInterval` property
    in the configuration for the `useQuery` Hook, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The request is resent every 5 seconds (5,000 **milliseconds**, or **ms**).
  prefs: []
  type: TYPE_NORMAL
- en: As you might expect, there are other ways to implement real-time updates to
    your UI. One approach is to use **server-sent events**. A server-sent event is,
    as the name suggests, an event that is sent by the server to the client. The client
    needs to establish a connection to the server, but then the server can send messages
    to the client, in one direction. Another method is to use **WebSockets**, which
    allow for bidirectional communication between the server and the client. The most
    common method in relation to GraphQL, however, is to use **Apollo Subscriptions**.
    They are based on WebSockets and work perfectly with GraphQL. I will show you
    how Apollo Subscriptions work in [*Chapter 10*](B17337_10_Final_ASB_ePub.xhtml#_idTextAnchor183),
    *Real-Time Subscriptions*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue and integrate the rest of our GraphQL API.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing chats and messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we programmed a pretty dynamic way of creating chats
    and messages with your friends and colleagues, either one-on-one or in a group.
    There are some things that we have not discussed yet, such as authentication,
    real-time subscriptions, and friend relationships. First, however, we are going
    to work on our new skills, using React with Apollo Client to send GraphQL requests.
    It is a complicated task, so let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching and displaying chats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our news feed is working as we expected. Now, we also want to cover chats. As
    with our feed, we need to query for every chat that the current user (or, in our
    case, the first user) is associated with.
  prefs: []
  type: TYPE_NORMAL
- en: The initial step is to get the rendering working with some demo chats. Instead
    of writing the data on our own, as we did in the first chapter, we can now execute
    the `chats` query. Then, we can copy the result into the new file as static demo
    data, before executing the actual `useQuery` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Send the GraphQL query. The best options involve the Apollo Client Devtools
    if you already know how they work. Otherwise, you can rely on Postman, as you
    did previously. The code is illustrated in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The request looks a bit different from the one we tested with Postman. The chat
    panel that we are going to build only needs specific data. We do not need to render
    any messages inside of this panel, so we don't need to request them. A complete
    chat panel only requires the chat itself, the ID, the usernames, and the avatars.
    Later, we will retrieve all of the messages, too, when viewing a single chat.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, create a new file called `Chats.js`, next to the `Feed.js` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Copy the complete `chats` array from the response over to an array inside of
    the `Chats.js` file, as follows. Add it to the top of the file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import React ahead of the `chats` variable. Otherwise, we will not be able
    to render any React components. Here''s the code you''ll need to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up the functional React component. I have provided the basic markup here.
    Just copy it beneath the `chats` variable. I am going to explain the logic of
    the new component shortly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The component is pretty basic, at the moment. The component maps over all of
    the chats and returns a new list item for each chat. Each list item has an image
    that is taken from the second user of the array, since we defined that the first
    user in the list is the current user, as long as we have not implemented authentication.
    We use a group icon if there are more than two users. When we have implemented
    authentication and we know the logged-in user, we can take the specific avatar
    of the user that we are chatting with.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The title displayed inside of the `h2` tag at the top of the chat is the name
    of the user. For this, I have implemented the `usernamesToString` method, which
    loops over all of the usernames and concatenates them into a long string. The
    result is passed into the `shorten` function, which removes all of the characters
    of the string that exceed the size of the maximum-12 characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One thing you may notice is that these helper functions are not within the actual
    component. I personally recommend having helper functions outside of the component
    as they will be recreated on every render of the component. If the helper function
    needs the scope of the component, keep it inside, but if they are pure functions
    just doing transformations here, keep them outside.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our new component needs some styling. Copy the new CSS to our `style.css` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To save the file size in our CSS file, replace the two `.post .header` styles
    to also cover the style of the chats, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We must append the following CSS to the bottom of the `style.css` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get the code working, we must also import the `Chats` component into our
    `App.js` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Render the `Chats` component inside the return statement beneath the `Feed`
    component inside of the `App.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The current code generates the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Chats panel'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.03_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – Chats panel
  prefs: []
  type: TYPE_NORMAL
- en: On the right-hand side, you can see the chats panel that we have just implemented.
    Every chat is listed there as a separate row.
  prefs: []
  type: TYPE_NORMAL
- en: The result isn't bad, but it would be much more helpful to at least have the
    last message of every chat beneath the username so that you could directly see
    the last content of your conversations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just follow these instructions to get the last message into the chats panel:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to do this would be to add the messages to our query again,
    but querying all of the messages for every chat that we want to display in the
    panel would not make much sense. Instead, we will add a new property to the chat
    entity, called `lastMessage`. That way, we will only get the newest message. We
    will add the new field to the GraphQL schema of our chat type, in the backend
    code, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Of course, we must also implement a function that retrieves the `lastMessage`
    field.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Adding our new `resolvers.js` function inside the `Chats` property of the `resolvers`
    object orders all of the chat messages by ID and takes the first one. By definition,
    this should be the latest message in our chat. We need to resolve the promise
    on our own and return the first element of the array since we expect to return
    only one `message` object. If you return the promise directly, you will receive
    `null` in the response from the server because an array is not a valid response
    for a single message entity. The code is illustrated in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can add the new property to our static demo data inside `Chats.js`. for
    every array item or rerun the GraphQL query and copy the response again. The code
    is illustrated here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can render the new message with a simple `span` tag beneath the `h2` header
    of the username. Copy it directly into the `return` statement, inside of our `Chats`
    component, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result of the preceding changes renders every chat row with the last message
    inside of the chat. It should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Last message'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.04_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Last message
  prefs: []
  type: TYPE_NORMAL
- en: 'Since everything is displayed correctly from our test data, we can introduce
    the `useQuery` Hook in order to fetch all of the data from our GraphQL API. We
    can remove the `chats` array. Then, we will import all of the dependencies and
    parse the GraphQL query, as in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To make use of the preceding parsed GraphQL query we will execute the `useQuery`
    Hook in our functional component, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: When you have added the preceding lines of code to the beginning of the `Chats`
    function, it will then make use of the `chats` array returned within the GraphQL
    response. Before doing so it will, of course, check if the request is still loading
    or if there has been an error.
  prefs: []
  type: TYPE_NORMAL
- en: We render the loading and error state within the `div` tag with the `chats`
    class so that the messages are wrapped within the gray panel.
  prefs: []
  type: TYPE_NORMAL
- en: You should have run the `addChat` mutation from the previous chapter through
    Postman. Otherwise, there will be no chats to query for, and the panel will be
    empty. You have to also execute this mutation for any following chapter because
    we are not going to implement a special button for this functionality. The reason
    is that the logic behind it does not provide further knowledge about React or
    Apollo as it is just done by executing the `addChat` mutation at the correct location
    within Graphbook.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want to display chat messages after opening a specific chat.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching and displaying messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we have to store the chats that were opened by a click from the user.
    Every chat is displayed in a separate, small chat window, like on Facebook. Add
    a new state variable to save the IDs of all of the opened chats to the `Chats`
    component, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To let our component insert or remove something from the array of open chats,
    we will add the new `openChat` and `closeChat` functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When a chat is clicked on, we will first check that it is not already open,
    by searching the ID using the `indexOf` function inside of the `openChats` array.
  prefs: []
  type: TYPE_NORMAL
- en: Every time a new chat is opened, we will check whether there are three or more
    chats. If that is the case, we will remove the first opened chat from the array
    and exchange it with the new one by appending it to the array with the `push`
    function. We will only save the chat IDs, not the whole **JavaScript Object Notation**
    (**JSON**) object.
  prefs: []
  type: TYPE_NORMAL
- en: For the `closeChat` function, we just revert this by removing the ID from the
    `openChats` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to bind the `onClick` event to our component. In the `map`
    function, we can replace the wrapping `div` tag with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use `onClick` to call the `openChat` function, with the chat ID as
    the only parameter. At this point, the new function is already working but the
    updated state isn''t used. Let''s take care of that, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a surrounding wrapper `div` tag to the `div` tag with the `chats` class,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In order to not mess up, the complete code we have written will introduce our
    first child component. To do so, create a file called `Chat.js` next to the `Chats.js`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this new file, import React and Apollo and parse the GraphQL query to get
    all the chat messages that were just opened, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see in the preceding code snippet, we are passing the chat ID as
    a parameter to the GraphQL query.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The actual component will then make use of the parsed query to get all the
    messages and render them inside a small container. The component should be added,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We execute the `useQuery` Hook to send the GraphQL request. We pass the `chatId`
    property from the `props` property so that the chat ID must be passed to this
    child component from the parent component. We also extract the `closeChat` function
    to call it from the child component, as the actual close button is within the
    chat container and not within the parent component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the request arrives, we check again if the request is loading or has an
    error before actually rendering the complete chat. Then, we render a `div` tag
    with the `chatWindow` class name, in which all messages are displayed. Again,
    we are using the user ID to fake the class name of the messages. We will replace
    it when we get authentication running.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As we have prepared the child component, we only need to add one line to the
    `Chats.js` file to import it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, to make use of our new `Chat` component, just add these three lines of
    code inside the `div` tag with the `wrapper` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For each item in the `openChats` array, we will render the `Chat` component,
    which will then pass the `chatId` property and the `closeChat` function. The child
    component will then fetch the chat data on its own by the passed `chatId` property.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last thing missing is some styling. The CSS file is pretty big. Every message
    from the other users should be displayed on the left and our own messages on the
    right, to differentiate them. Insert the CSS code directly from the GitHub repository
    to save some time: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-2nd-Edition/blob/main/Chapter04/assets/css/style.css](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-2nd-Edition/blob/main/Chapter04/assets/css/style.css).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Chat window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.05_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – Chat window
  prefs: []
  type: TYPE_NORMAL
- en: We have forgotten something important. We can see all of the messages from our
    chat, but we are not able to add new messages, which is essential. Let's take
    a look at how to implement a chat message form in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages through mutations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `addMessage` mutation already exists in our backend, so we can add it to
    our `Chat` component. To implement this feature completely, follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before adding it straightaway to the frontend too, we need to change the `import`
    statements so that we also have the `useMutation` and `useState` functions, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, parse the mutation at the top, next to the other requests, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For now, we will keep it simple and just add the text input to the `Chat` component
    directly, but we will take a look at a better way to do this in [*Chapter 5*](B17337_05_Final_ASB_ePub.xhtml#_idTextAnchor123),
    *Reusable React Components and React Hooks*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we need to create a state variable where we save the current value of
    our new text input that we still need to create. We need to execute the `useMutation`
    Hook to send the GraphQL request to create a new chat message. Just add the following
    code for that:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The state variable and mutation function look familiar, as you already know
    them. One special thing we do for the `useMutation` Hook is to again provide an
    `update` function to efficiently update the Apollo Client cache with the newest
    data. To do so, we must provide an `id` property to the `cache.modify` function.
    The reason we need to do that is that we want to update the `messages` array of
    one specific chat, but there could be multiple within our cache. To update the
    correct chat in the message, we use the `cache.identify` function and provide
    the current `chat` object, and it will automatically detect which chat to update.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `handleKeyPress` function will handle the submission of the text input to
    trigger a mutation request.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We must insert the markup needed to render a fully functional input. Put the
    input below the messages list, inside of the chat window. The `onChange` property
    executes while typing and will update the state of the component with the value
    of the input. Insert the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use the `onKeyPress` event to handle *Enter* key hits so that we can send
    the chat message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s quickly add some CSS to our `style.css` file to make the input field
    look good, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following screenshot shows the chat window, with a new message inserted
    through the chat window input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Messaging in the chat window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.06_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.6 – Messaging in the chat window
  prefs: []
  type: TYPE_NORMAL
- en: There are many features that we have not implemented and that we won't cover
    in this book—for example, it would make sense to have the username next to the
    chat message if it is a group chat, to show the avatar next to the message, and
    to update the `lastMessage` field in the chats panel once a new message is sent.
    The workload required to achieve a fully-fledged social network, such as Facebook,
    is impossible to cover in this book, but you are going to learn all of the required
    techniques, tools, and tactics so that you can approach this on your own. The
    next important feature that we are going to cover is pagination.
  prefs: []
  type: TYPE_NORMAL
- en: Pagination in React and GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By **pagination**, most of the time, we mean the batch querying of data. Currently,
    we query for all posts, chats, and messages in our database. If you think about
    how much data Facebook stores inside one chat with your friends, you will realize
    that it is unrealistic to fetch all of the messages and data ever shared at once.
    A better solution is to use pagination. With pagination, we always have a page
    size, or a limit, of how many items we want to fetch per request. We also have
    a page or offset number, from which we can start to select data rows.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we're going to look at how to use pagination with the posts
    feed, as it is the most straightforward example. In [*Chapter 5*](B17337_05_Final_ASB_ePub.xhtml#_idTextAnchor123),
    *Reusable React Components and React Hooks*, we will focus on writing efficient
    and reusable React code. Sequelize offers the pagination feature by default. We
    can first insert some more demo posts so that we can paginate in batches of 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to adjust the backend a bit before implementing it on our frontend,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new `RootQuery` to our GraphQL schema, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `PostFeed` type only holds the `posts` field. Later on, in the development
    of the application, you can return more information, such as the overall count
    of items, the page count, and so on. The code is illustrated in the following
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we must implement the `PostFeed` entity in our `resolvers.js` file. Copy
    the new resolver function over to the `resolvers` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We build a simple `query` object that Sequelize understands, which allows us
    to paginate our posts. The `page` number is multiplied by the `limit` parameter,
    to skip the calculated number of rows. The `offset` parameter skips the number
    of rows, and the `limit` parameter stops selecting rows after a specified number
    (which, in our case, is 10).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our frontend needs some adjustments to support pagination. Install a new React
    package with `npm`, which provides us with an infinite scroll implementation,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Infinite scrolling is an excellent method to let a user load more content by
    scrolling to the bottom of the browser window.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are free to program this on your own, but we are not going to cover that
    here. Go back to the `Feed.js` file, replace the `GET_POSTS` query, and import
    the `react-infinite-scroll-component` package with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `postsFeed` query expects parameters other than the standard query
    from before, we need to edit our `useQuery` Hook and also introduce two new state
    variables. The changed lines are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we extract the `fetchMore` function from the
    `useQuery` Hook, which is used to run the pagination request to load more post
    items. We also create a `hasMore` state variable that will identify if there is
    more data to load from the GraphQL API, and the `page` variable will save the
    current page—or, to be exact, the number of pages we already scrolled.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the new data structure defined in our GraphQL schema, we extract
    the `posts` array from the `postsFeed` object. You can do that by replacing the
    code with these two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the markup of the `div` tag of our current feed to make use of our
    new infinite scroll package, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The only thing that the infinite scroll package does is run the `loadMore` function
    provided in the `next` property, as long as `hasMore` is set to `true` and the
    user scrolls to the bottom of the browser window. When `hasMore` is set to `false`,
    the event listeners are unbound and no more requests are sent. This behavior is
    great when no further content is available, as we can stop sending more requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to implement the `loadMore` function before running the infinite scroller.
    It relies on the `page` variable that we just configured. The `loadMore` function
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s quickly go through the preceding code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `fetchMore` function receives an object as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We specify the `variables` field, which is sent with our request, to query the
    correct page index of our paginated posts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `updateQuery` function is defined to implement the logic to add the new
    data that needs to be included in our news feed. We can check whether any new
    data is included in the response by looking at the returned array length. If there
    are no posts, we can set the `hasMore` state variable to `false`, which unbinds
    all scrolling events. Otherwise, we can continue and build a new `postsFeed` object
    inside of the `newData` variable. The `posts` array is filled by the previous
    `posts` query result and the newly fetched posts. In the end, the `newData` variable
    is returned and saved in the client's cache.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the `updateQuery` function is finished, the UI rerenders accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, your feed is able to load new posts whenever the user visits
    the bottom of the window. We no longer load all posts at once, but instead, we
    only get the 10 most recent from our database. Every time you build an application
    with large lists and many rows, you have to add some kind of pagination, with
    either infinite scrolling or simple page buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now created a new problem. We can submit a new post with the GraphQL
    mutation if the React Apollo cache is empty, but the `update` function of the
    `Mutation` component will throw an error. Our new query is stored not only under
    its name but also under the variables used to send it. To read the data of a specific
    paginated `posts` request from our client''s cache, we must also pass variables,
    such as the page index. Furthermore, we have a second layer, `postsFeed`, as the
    parent of the `posts` array. Change the `update` function to get it working again,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We actually just changed the `posts` property to `postsFeed` and updated the
    function to update the extracted `posts` array.
  prefs: []
  type: TYPE_NORMAL
- en: Complex code such as this requires some useful tools to debug it. Continue reading
    to learn more about the Apollo Client Devtools.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with the Apollo Client Devtools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you write or extend your own application, you have to test, debug,
    and log different things during development. In [*Chapter 1*](B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017),
    *Preparing Your Development Environment*, we looked at the React Developer Tools
    for Chrome, while in [*Chapter 2*](B17337_02_Final_ASB_ePub.xhtml#_idTextAnchor032),
    *Setting Up GraphQL with Express.js*, we explored Postman for testing APIs. Now,
    let's take a look at another tool.
  prefs: []
  type: TYPE_NORMAL
- en: The **Apollo Client Devtools** is another Chrome extension, allowing you to
    send Apollo requests. While Postman is great in many ways, it does not integrate
    with our application and does not implement all GraphQL-specific features. The
    Apollo Client Devtools rely on the Apollo Client that we set up very early on
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Every request, either a query or mutation, is sent through the Apollo Client
    of our application. The developer tools also provide features such as autocomplete,
    for writing requests. They can show us the schema as it is implemented in our
    GraphQL API, and we also can view the cache. We will go over all four of the main
    windows offered by the extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – The Apollo Client Devtools'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.07_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7 – The Apollo Client Devtools
  prefs: []
  type: TYPE_NORMAL
- en: 'The **GraphiQL** window is shown in the preceding screenshot. The three panels
    in the preceding screenshot are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You can enter a request that you want to send in the left-hand text area. It
    can be a mutation or query, including the markup for inputs, for example. You
    can also enter the variables at the bottom.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When sending a request, the response is shown in the middle panel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the panel on the right, you can find the schema against which you will run
    requests. You can search through the complete GraphQL schema or manually step
    into the tree by clicking on the root types. This feature is useful when you forget
    what a specific field or mutation is called or which parameters it accepts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the top bar, you will find the **Prettify** button, which tidies your query
    so that it is more readable. The **Load from cache** checkbox tries to retrieve
    any requested data directly from the cache, when possible. By clicking on the
    **Play** button, you run the query. These are all tools to test our GraphQL requests
    properly. The **Build** button will give you a small graphical interface to edit
    your query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, there is the **Queries** window, which is a helpful display. All of the
    queries that were ever run through the client are listed here, including the query
    string and variables. If you want to, you can rerun a query by clicking on the
    button at the top, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Apollo Queries window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.08_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.8 – Apollo Queries window
  prefs: []
  type: TYPE_NORMAL
- en: The **Mutations** window is actually the same as the **Queries** window, but
    for mutations. The list is empty, as long as you have not sent any mutations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last window is **Cache**. Here, you are able to see all of the data stored
    inside the Apollo cache, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Apollo Cache window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.09_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.9 – Apollo Cache window
  prefs: []
  type: TYPE_NORMAL
- en: In the left-hand panel, you can search through your data. The right-hand panel
    shows you the selected object in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: You can also see that I have tested the API a lot, as there are multiple `Post`
    objects in the left-hand panel.
  prefs: []
  type: TYPE_NORMAL
- en: Resetting the Apollo Cache
  prefs: []
  type: TYPE_NORMAL
- en: For testing purposes, I submitted multiple posts via a mutation, but I deleted
    them to make sure that the screenshots were clear. Apollo did not delete the old
    posts that were deleted in the database, so they are still inside of the cache.
    You should delete this data when a user logs out of your application so that unauthorized
    users cannot access it.
  prefs: []
  type: TYPE_NORMAL
- en: That is everything you need to know about the Apollo Client Devtools.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to connect your GraphQL API to React. To do
    this, we used Apollo Client to manage the cache and the state of our components
    and to update React and the actual DOM of the browser. We looked at how to send
    queries and mutations against our server. We also covered how to implement pagination
    with React and Apollo, and how to use the Apollo Client Devtools.
  prefs: []
  type: TYPE_NORMAL
- en: After this chapter, you should be able to integrate the Apollo Client into your
    React application at any time. Furthermore, you should be able to make use of
    Apollo in every component of your application and be able to debug it.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover how to write reusable React components. Up to this
    point, we have written the code, but we haven't thought about readability or good
    practices very much. We will address these issues in the next chapter.
  prefs: []
  type: TYPE_NORMAL
