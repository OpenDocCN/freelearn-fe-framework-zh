- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Building an Event-Based Backend Using Express and Socket.IO
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Express 和 Socket.IO 构建事件驱动后端
- en: In this chapter, we will learn about event-based applications and the tradeoffs
    of using such an architecture versus a more traditional one. Then, we are going
    to learn about WebSockets and how they work. Afterward, we are going to implement
    a backend using Socket.IO and Express. Finally, we are going to learn how to integrate
    authentication by using JWT with Socket.IO.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习关于事件驱动应用程序以及使用这种架构与更传统架构相比的权衡。然后，我们将学习关于 WebSockets 以及它们是如何工作的。之后，我们将使用
    Socket.IO 和 Express 实现后端。最后，我们将学习如何通过使用 JWT 与 Socket.IO 集成来实现身份验证。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: What are event-based applications?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是事件驱动应用程序？
- en: Setting up Socket.IO
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Socket.IO
- en: Creating a backend for a chat app using Socket.IO
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Socket.IO 创建聊天应用的后端
- en: Adding authentication by integrating JWT with Socket.IO
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将 JWT 与 Socket.IO 集成来添加身份验证
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before we start, please install all the requirements from [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016),
    *Preparing For Full-Stack Development*, and [*Chapter 2*](B19385_02.xhtml#_idTextAnchor028),
    *Getting to Know Node.js* *and MongoDB*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请从[*第 1 章*](B19385_01.xhtml#_idTextAnchor016)，*为全栈开发做准备*，以及[*第 2 章*](B19385_02.xhtml#_idTextAnchor028)，*了解
    Node.js 和 MongoDB*中安装所有要求。
- en: The versions listed in those chapters are the ones used in this book. While
    installing a newer version should not be an issue, please note that certain steps
    might work differently. If you are having an issue with the code and steps provided
    in this book, please try using the versions mentioned in *Chapters 1* and *2.*
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那些章节中列出的版本是本书中使用的版本。虽然安装较新版本不应有问题，但请注意，某些步骤可能有所不同。如果你在使用本书中提供的代码和步骤时遇到问题，请尝试使用
    *第 1 章* 和 *第 2 章* 中提到的版本。
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch13](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch13).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章的代码：[https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch13](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch13)。
- en: If you cloned the full repository for this book, Husky may not find the `.git`
    directory when running `npm install`. In that case, just run `git init` in the
    root of the corresponding chapter folder.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你克隆了本书的完整仓库，在运行 `npm install` 时 Husky 可能找不到 `.git` 目录。在这种情况下，只需在相应章节文件夹的根目录下运行
    `git init`。
- en: 'The CiA video for this chapter can be found at: [https://youtu.be/kHGvkopIHf4](https://youtu.be/kHGvkopIHf4).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 CiA 视频可以在以下位置找到：[https://youtu.be/kHGvkopIHf4](https://youtu.be/kHGvkopIHf4)。
- en: What are event-based applications?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是事件驱动应用程序？
- en: In contrast to traditional web applications, where we have a request-response
    pattern, in event-based applications, we are dealing with events. The server and
    client stay connected and each side can send events, which the other side listens
    to and reacts to.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的基于请求-响应模式的 Web 应用程序相比，在事件驱动应用程序中，我们处理的是事件。服务器和客户端保持连接，每一方都可以发送事件，另一方监听并做出反应。
- en: 'The following diagram shows the difference between implementing a chat app
    in a request-response pattern versus an event-based pattern:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了在请求-响应模式与事件驱动模式之间实现聊天应用的区别：
- en: '![Figure 13.1 – A chat app implementation with request-response and event-based
    patterns](img/B19385_13_1.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – 使用请求-响应和事件驱动模式的聊天应用实现](img/B19385_13_1.jpg)'
- en: Figure 13.1 – A chat app implementation with request-response and event-based
    patterns
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 使用请求-响应和事件驱动模式的聊天应用实现
- en: For example, to implement a chat application in a request-response pattern,
    we would need to regularly send a request to a `GET /chat/messages` endpoint to
    refresh the list of messages sent in a chat room. This process of periodically
    sending requests is called short polling. To send a chat message, we would make
    a request to `POST /chat/messages`. In an event-based pattern, we could instead
    send a `chat.message` event from the client to the server, which then sends a
    `chat.message` event to all connected users. The clients then listen to `chat.message`
    events and display the messages as they come in; no periodic requests are required!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在请求-响应模式中实现聊天应用，我们需要定期向`GET /chat/messages`端点发送请求以刷新聊天室中发送的消息列表。这种定期发送请求的过程称为短轮询。要发送聊天消息，我们会向`POST
    /chat/messages`发送请求。在事件驱动模式中，我们可以从客户端向服务器发送`chat.message`事件，然后服务器将`chat.message`事件发送给所有已连接的用户。然后客户端监听`chat.message`事件，并在消息到来时显示它们；不需要定期请求！
- en: 'Of course, each pattern comes with its advantages and disadvantages:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，每种模式都有其优缺点：
- en: 'REST/request-response:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST/请求-响应：
- en: Good for when data does not change frequently
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数据不经常变化时很有用
- en: Responses can be cached easily
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应可以轻松缓存
- en: Requests are stateless, making it easy to scale backends
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求是无状态的，这使得扩展后端变得容易
- en: Bad at real-time updates (requires periodic polling)
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实时更新方面表现不佳（需要定期轮询）
- en: More overhead per request (bad when sending many short responses)
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个请求的开销更大（在发送许多短响应时不好）
- en: 'WebSockets/event-based:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket/事件驱动：
- en: Good for applications that require frequent updates
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于需要频繁更新的应用很有用
- en: More efficient because a persistent connection between the client and server
    is re-used for multiple requests
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更高效，因为客户端和服务器之间的持久连接被重复用于多个请求
- en: Less overhead per request
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个请求的开销较小
- en: There might be connection issues with (corporate) proxies
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会与（企业）代理存在连接问题
- en: They are stateful, which can make it harder to scale an app
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是有状态的，这可能会使扩展应用更困难
- en: As we can see, for fetching data that does not change so frequently (and can
    be cached), such as blog posts, a request-response pattern fits better. For applications
    where data is frequently changing, such as a chat room, an event-based pattern
    fits better.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，对于获取不经常变化（并且可以缓存）的数据（如博客文章），请求-响应模式更合适。对于数据频繁变化的应用（如聊天室），事件驱动模式更合适。
- en: What are WebSockets?
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是WebSockets？
- en: The WebSocket API is a browser feature that allows web applications to create
    an open connection between the client and the server, similar to Unix-style sockets.
    With WebSockets, communication can happen in both directions at the same time.
    This is in contrast to HTTP requests, where both parties can communicate, but
    not simultaneously.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket API是一个浏览器功能，允许Web应用程序在客户端和服务器之间创建一个开放的连接，类似于Unix风格的套接字。使用WebSockets，通信可以同时双向进行。这与HTTP请求形成对比，在HTTP请求中，双方可以通信，但不能同时进行。
- en: WebSockets use HTTP to establish a connection between the client and the server,
    and then upgrade the protocol from HTTP to the WebSocket protocol. While both
    HTTP and WebSockets depend on the **Transmission Control Protocol** (**TCP**),
    they are distinct protocols on the application layer (Layer 7) of the **Open Systems
    Interconnection** (**OSI**) model.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets使用HTTP在客户端和服务器之间建立连接，然后将协议从HTTP升级到WebSocket协议。虽然HTTP和WebSockets都依赖于**传输控制协议**（**TCP**），但它们是**开放系统互联**（**OSI**）模型应用层（第7层）上的不同协议。
- en: 'A connection to a WebSocket is established by sending an HTTP request with
    the `Upgrade: websocket` header and other parameters to establish a secure WebSocket
    connection. The server then responds with an `HTTP 101 Switching Protocols` response
    code and information to establish the connection. Then, the client and server
    continue talking on the WebSocket protocol.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '通过发送带有`Upgrade: websocket`头和其他参数的HTTP请求来建立WebSocket连接。然后服务器响应以`HTTP 101 Switching
    Protocols`响应代码和建立连接的信息。然后，客户端和服务器继续在WebSocket协议上进行通信。'
- en: What is Socket.IO?
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是Socket.IO？
- en: Socket.IO is an implementation of an event-based server and client library.
    In most cases, it establishes a connection to the server using a WebSocket. If
    a WebSocket connection is not possible (due to lacking browser support or firewall
    settings), Socket.IO can also fall back to HTTP long-polling. However, Socket.IO
    isn’t a pure WebSocket implementation as it adds additional metadata to each packet.
    It only uses WebSockets internally to transmit data.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO 是一个基于事件的客户端和服务器库的实现。在大多数情况下，它使用 WebSocket 连接到服务器。如果 WebSocket 连接不可行（由于浏览器支持不足或防火墙设置），Socket.IO
    也可以回退到 HTTP 长轮询。然而，Socket.IO 并不是一个纯 WebSocket 实现，因为它为每个数据包添加了额外的元数据。它仅在内部使用 WebSocket
    传输数据。
- en: 'In addition to providing a way to send events between the client and server,
    Socket.IO offers the following features over plain WebSockets:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供客户端和服务器之间发送事件的方式之外，Socket.IO 还在普通 WebSocket 之上提供了以下功能：
- en: '**Fallback to HTTP long-polling**: This occurs if the WebSocket connection
    cannot be established. This can be especially useful for companies using proxies
    or firewalls that block WebSocket connections.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回退到 HTTP 长轮询**：如果 WebSocket 连接无法建立，则会发生这种情况。这对于使用代理或防火墙且阻止 WebSocket 连接的公司来说特别有用。'
- en: '**Automatic reconnection**: If the WebSocket connection is interrupted.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动重连**：如果 WebSocket 连接中断。'
- en: '**Buffering packets**: When the client gets disconnected, packets can be re-sent
    again automatically upon reconnection.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓冲数据包**：当客户端断开连接时，数据包可以在重新连接时自动重新发送。'
- en: '**Acknowledgments**: A convenient way to send events in a request-response
    pattern, which can sometimes be useful even in event-based applications.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确认**：在请求-响应模式中发送事件的一种便捷方式，这在某些情况下甚至在基于事件的程序中也可能很有用。'
- en: '**Broadcasting**: Sending an event to all (or a subset of all) connected clients.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**广播**：向所有（或所有连接客户端的子集）发送事件。'
- en: '**Multiplexing**: Socket.IO implements namespaces, which can be used to create
    “channels” that only certain users can send events to and receive events from,
    such as an “admin-only channel.”'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多路复用**：Socket.IO 实现了命名空间，可以用来创建“频道”，只有特定用户可以发送事件并接收事件，例如“仅管理员频道”。'
- en: Now that we have learned the essentials of what Socket.IO is, let’s dive deeper
    into how the connection and emitting/receiving events work.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了 Socket.IO 的基本知识，让我们深入了解连接以及发送/接收事件的工作原理。
- en: Connecting to Socket.IO
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到 Socket.IO
- en: 'The following diagram shows how a connection is established with Socket.IO:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了如何使用 Socket.IO 建立连接：
- en: '![Figure 13.2 – Establishing a connection with Socket.IO](img/B19385_13_2.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2 – 使用 Socket.IO 建立连接](img/B19385_13_2.jpg)'
- en: Figure 13.2 – Establishing a connection with Socket.IO
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – 使用 Socket.IO 建立连接
- en: First, Socket.IO sends a handshake from the client (on the frontend) to the
    server (on the backend), which can contain information to authenticate with the
    server, or query parameters to provide additional information when establishing
    the connection.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Socket.IO 从客户端（前端）向服务器（后端）发送一个握手信号，这个握手信号可以包含用于与服务器进行身份验证的信息，或者查询参数，以便在建立连接时提供额外的信息。
- en: If a connection via WebSockets cannot be established, Socket.IO connects to
    the server via HTTP long polling, which means making a request to the server that
    is kept active until an event occurs, at which point the server sends a response
    to the request. This allows waiting for events without having to periodically
    make a request to see if there are any new events. Of course, this is not as performant
    as WebSockets, but it is a good fallback for when WebSockets aren’t available.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法通过 WebSocket 建立连接，Socket.IO 将通过 HTTP 长轮询连接到服务器，这意味着向服务器发送一个保持活跃的请求，直到发生事件，此时服务器向请求发送响应。这允许等待事件，而无需定期发送请求以查看是否有新事件。当然，这不如
    WebSocket 性能好，但它是当 WebSocket 不可用时的一个很好的回退方案。
- en: Emitting and receiving events
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送和接收事件
- en: 'Once connected to Socket.IO, we can start **emitting** (sending) and receiving
    events. Events are handled by registering event handler functions, which are called
    when a certain type of event is received by either the client or the server. Both
    the client and the server can emit and receive events. Additionally, events can
    be **broadcast** from the server to multiple clients. The following diagram shows
    an example of how events are emitted and received in a chat application:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦连接到 Socket.IO，我们就可以开始 **发射**（发送）和接收事件。事件通过注册事件处理函数来处理，当客户端或服务器接收到某种类型的事件时，这些函数会被调用。客户端和服务器都可以发射和接收事件。此外，事件还可以从服务器广播到多个客户端。以下图示展示了在聊天应用程序中事件是如何发射和接收的：
- en: '![Figure 13.3 – Emitting and receiving events with Socket.IO](img/B19385_13_3.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.3 – 使用 Socket.IO 发射和接收事件](img/B19385_13_3.jpg)'
- en: Figure 13.3 – Emitting and receiving events with Socket.IO
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 – 使用 Socket.IO 发射和接收事件
- en: As we can see, **User 1** sends a **Hello everyone** message, which the server
    (backend) then broadcasts to all other clients (frontend). In this case, the message
    gets broadcast back to **User 1**, as well as to **User 2**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，**用户 1** 发送了一条 **大家好** 的消息，服务器（后端）随后将其广播给所有其他客户端（前端）。在这种情况下，消息被广播回 **用户
    1**，以及 **用户 2**。
- en: If we want to restrict the clients that receive certain events, Socket.IO allows
    the creation of **rooms**. Clients can join a room, and on the server, we can
    also broadcast events to only specific rooms. This concept can be used for chat
    rooms, but also for collaborating on a specific project (such as editing a document
    together in real time).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想限制接收特定事件的客户端，Socket.IO 允许创建 **rooms**。客户端可以加入一个房间，在服务器上，我们也可以向特定房间广播事件。这个概念可以用于聊天室，也可以用于在特定项目上协作（例如实时共同编辑文档）。
- en: In addition to emitting and receiving events asynchronously, Socket.IO offers
    a way to send an event that expects a response via `user.info` event and synchronously
    wait for the server response (acknowledgment). We can see this in the preceding
    diagram, where **User 2** requests information about a certain user, and then
    gets a response containing the user’s information.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了异步地发射和接收事件外，Socket.IO 还提供了一种通过 `user.info` 事件发送期望响应的事件的方式，并同步等待服务器响应（确认）。我们可以在前面的图中看到这一点，其中
    **用户 2** 请求有关某个用户的信息，然后收到包含用户信息的响应。
- en: Now that we’ve learned about event-based applications, WebSockets, and Socket.IO,
    let’s put this theory into practice and set up Socket.IO.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了基于事件的程序、WebSockets 和 Socket.IO，让我们将这个理论付诸实践并设置 Socket.IO。
- en: Setting up Socket.IO
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Socket.IO
- en: 'To set up the Socket.IO server, we are going to base our code on what we had
    in [*Chapter 6*](B19385_06.xhtml#_idTextAnchor119), *Adding Authentication and
    Roles with JWT*, as it already includes some boilerplate for a backend and frontend
    with JWT authentication. Later in this chapter, in the *Adding authentication
    by integrating JWT with Socket.IO* section, we are going to make use of JWT to
    add authentication to Socket.IO:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置 Socket.IO 服务器，我们将基于我们在 [*第 6 章*](B19385_06.xhtml#_idTextAnchor119) 中所学的代码，*使用
    JWT 添加身份验证和角色*，因为它已经包含了一些后端和前端 JWT 身份验证的样板代码。在本章的 *通过将 JWT 与 Socket.IO 集成来添加身份验证*
    部分，我们将使用 JWT 为 Socket.IO 添加身份验证：
- en: 'Copy the existing **ch6** folder to a new **ch13** folder, as follows:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的 **ch6** 文件夹复制到新的 **ch13** 文件夹中，如下所示：
- en: '[PRE0]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Open the **ch13** folder in VS Code.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开 **ch13** 文件夹。
- en: 'Now, we can start setting up Socket.IO. First, install the **socket.io** package
    in the backend folder by running the following commands:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以开始设置 Socket.IO。首先，通过运行以下命令在后端文件夹中安装 **socket.io** 包：
- en: '[PRE1]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Edit **backend/.env** and change **DATABASE_URL** so that it points to a new
    **chat** database:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **backend/.env** 并更改 **DATABASE_URL**，使其指向一个新的 **chat** 数据库：
- en: '[PRE2]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Edit **backend/src/app.js** and import the **createServer** function from **node:http**
    and the **Server** function from **socket.io**:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **backend/src/app.js** 并从 **node:http** 导入 **createServer** 函数，从 **socket.io**
    导入 **Server** 函数：
- en: '[PRE3]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We are going to need to create a `node:http` server as we cannot directly connect
    Socket.IO to Express. Instead, Socket.IO attaches to a `node:http` server.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要创建一个 `node:http` 服务器，因为我们不能直接将 Socket.IO 连接到 Express。相反，Socket.IO 附加到 `node:http`
    服务器上。
- en: 'Thankfully, Express can also be easily attached to a **node:http** server.
    Edit **backend/src/app.js** and, before **app** is exported, create a new **node:http**
    server from the Express app, as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 幸运的是，Express 也很容易附加到 **node:http** 服务器上。编辑 **backend/src/app.js** 并在 **app**
    导出之前，从 Express 应用程序创建一个新的 **node:http** 服务器，如下所示：
- en: '[PRE4]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, create a new Socket.IO server from the **node:http** server:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从 **node:http** 服务器创建一个新的 Socket.IO 服务器：
- en: '[PRE5]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Warning
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Setting the origin to ***** makes it possible for phishing sites to imitate
    your website and send requests to your backend. In production, the origin should
    be set to the deployed URL of your frontend.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 设置原点为 ***** 使得钓鱼网站可以模仿你的网站并向你的后端发送请求。在生产环境中，原点应设置为前端部署的 URL。
- en: 'We can use the Socket.IO server to listen to connections from clients and print
    a message:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 Socket.IO 服务器来监听来自客户端的连接并打印一条消息：
- en: '[PRE6]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The active client connection can be tracked by using the **socket** object.
    For example, we can listen to disconnect events from the client like so:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过使用 **socket** 对象来跟踪活跃的客户端连接。例如，我们可以像这样监听来自客户端的断开事件：
- en: '[PRE7]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Lastly, change the export so that it uses the **node:http** server instead
    of the Express app directly:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更改导出，使其使用 **node:http** 服务器而不是直接使用 Express 应用：
- en: '[PRE8]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Start the backend by running the following commands:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令来启动后端：
- en: '[PRE9]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Don’t forget to get Docker and the database container up and running before
    starting the backend. Keep the backend running for the rest of this chapter.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在启动后端之前，别忘了启动 Docker 和数据库容器。保持后端在本章的剩余部分运行。
- en: Now that we have set up a simple Socket.IO server, let’s continue by setting
    up the client.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个简单的 Socket.IO 服务器，让我们继续设置客户端。
- en: Setting up a simple Socket.IO client
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置简单的 Socket.IO 客户端
- en: 'We are going to use the existing frontend for now. In the next chapter, [*Chapter
    14*](B19385_14.xhtml#_idTextAnchor262), *Creating a Frontend to Consume and Send
    Events*, we are going to remove the blog components and create a new React frontend
    for our chat app. Let’s start setting up a simple Socket.IO client:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用现有的前端。在下一章，[*第 14 章*](B19385_14.xhtml#_idTextAnchor262)，*创建一个用于消费和发送事件的客户端前端*，我们将移除博客组件并为我们的聊天应用创建一个新的
    React 前端。让我们开始设置一个简单的 Socket.IO 客户端：
- en: 'In the root of the project, install the **socket.io-client** package for the
    frontend by running the following command:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录中，通过运行以下命令为前端安装 **socket.io-client** 包：
- en: '[PRE10]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Edit **src/App.jsx** and import the **io** function from **socket.io-client**:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/App.jsx** 并从 **socket.io-client** 中导入 **io** 函数：
- en: '[PRE11]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Define a new instance of the Socket.IO client by using the **io** function
    and passing a hostname and port:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用 **io** 函数并传递主机名和端口号来定义一个新的 Socket.IO 客户端实例：
- en: '[PRE12]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we will be passing `localhost:3001` through an environment variable. We
    cannot pass the HTTP URL here as Socket.IO will try to connect to the hostname
    and port using WebSockets.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们将通过环境变量传递 `localhost:3001`。我们无法在这里传递 HTTP URL，因为 Socket.IO 将尝试使用 WebSockets
    连接到主机名和端口号。
- en: 'Listen to the **connect** event and print out a message if we successfully
    connected to the Socket.IO server:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听 **connect** 事件，并在成功连接到 Socket.IO 服务器时打印一条消息：
- en: '[PRE13]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Additionally, listen to the **connect_error** event and log an error message
    in case connecting to the Socket.IO server failed:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，监听 **connect_error** 事件，并在连接到 Socket.IO 服务器失败时记录错误消息：
- en: '[PRE14]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Edit **.env** and add the following environment variable:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **.env** 并添加以下环境变量：
- en: '[PRE15]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run the frontend, as follows:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式运行前端：
- en: '[PRE16]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, open the frontend in your browser by going to **http://localhost:5173/**.
    Keep the frontend running for the rest of this chapter.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过访问 **http://localhost:5173/** 在浏览器中打开前端。保持前端在本章的剩余部分运行。
- en: 'You will see a message stating **connected to socket.io** in the browser console.
    In the server output, you will see that the client connected successfully. Try
    refreshing the page to see it disconnecting and connecting again (with a new socket
    ID):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在浏览器控制台中看到一个表示 **已连接到 socket.io** 的消息。在服务器输出中，你会看到客户端已成功连接。尝试刷新页面以查看它断开连接并再次连接（使用新的
    socket ID）：
- en: '![Figure 13.4 – Seeing the Socket.IO client connect to and disconnect from
    our server](img/B19385_13_4.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.4 – 观察Socket.IO客户端连接到并断开我们的服务器](img/B19385_13_4.jpg)'
- en: Figure 13.4 – Seeing the Socket.IO client connect to and disconnect from our
    server
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 – 观察 Socket.IO 客户端连接到并断开我们的服务器
- en: Now that we have successfully set up a Socket.IO server, let’s continue by creating
    a backend for a chat app using Socket.IO.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功设置了 Socket.IO 服务器，让我们继续创建一个使用 Socket.IO 的聊天应用的后端。
- en: Creating a backend for a chat app using Socket.IO
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Socket.IO 为聊天应用创建后端
- en: 'We can now start implementing a chat app using Socket.IO. We will be developing
    the following functionality for our chat app:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始使用 Socket.IO 实现聊天应用了。我们将为我们的聊天应用开发以下功能：
- en: '**Emitting** events to send chat messages from the client to the server'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从客户端向服务器发射** 聊天消息的事件'
- en: '**Broadcasting** chat messages from the server to all clients'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从服务器向所有客户端广播** 聊天消息'
- en: Joining **rooms** to send messages in
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加入 **房间** 以发送消息
- en: Using **acknowledgments** to get information about a user
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **确认** 获取关于用户的信息
- en: Let’s get started!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Emitting events to send chat messages from the client to the server
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从客户端向服务器发送聊天消息的事件发射
- en: 'We’ll start by `chat.message` event from the client to the server. For now,
    we are going to emit this event right after connecting. Later, we are going to
    integrate this into a frontend. Follow these steps to send chat messages from
    the client and receive them on the server:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从客户端到服务器的 `chat.message` 事件开始。目前，我们将在这个连接后立即发射此事件。稍后，我们将将其集成到前端。按照以下步骤从客户端发送聊天消息并在服务器上接收：
- en: 'Edit **backend/src/app.js** and *cut*/*remove* the following code:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **backend/src/app.js** 并 *剪切*/*删除* 以下代码：
- en: '[PRE17]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a new **backend/src/socket.js** file, define a **handleSocket** function
    there, and paste the following code inside it:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **backend/src/socket.js** 文件，在那里定义一个 **handleSocket** 函数，并在其中粘贴以下代码：
- en: '[PRE18]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, add a new listener that listens to the **chat.message** event and logs
    the message sent from the client:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加一个新的监听器，它监听 **chat.message** 事件并记录客户端发送的消息：
- en: '[PRE19]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Edit **backend/src/app.js** and import the **handleSocket** function:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **backend/src/app.js** 并导入 **handleSocket** 函数：
- en: '[PRE20]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once the Socket.IO server has been created, call the **handleSocket** function:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建好 Socket.IO 服务器，调用 **handleSocket** 函数：
- en: '[PRE21]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Edit **src/App.jsx** and emit a **chat.message** event with some text, as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/App.jsx** 并发射一个包含一些文本的 **chat.message** 事件，如下所示：
- en: '[PRE22]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Info
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Socket.IO allows us to send any kind of serializable data structures in an event,
    not just strings! For example, it is possible to send objects and arrays.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO 允许我们在事件中发送任何可序列化的数据结构，而不仅仅是字符串！例如，可以发送对象和数组。
- en: 'The backend and frontend should automatically refresh and the server will log
    the following message:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 后端和前端应该自动刷新，服务器将记录以下消息：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If not, make sure you (re-)start the backend and frontend and refresh the page
    manually.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，请确保你（重新）启动后端和前端，并手动刷新页面。
- en: As you can see, it is quite simple to send and receive events asynchronously
    in real time using Socket.IO.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用 Socket.IO 异步实时发送和接收事件相当简单。
- en: Broadcasting chat messages from the server to all clients
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从服务器向所有客户端广播聊天消息
- en: 'Now that the backend server can receive messages from a client, we need to
    **broadcast** the messages to all other clients so that others can see the chat
    messages that were sent. Let’s do that now:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在后端服务器可以接收来自客户端的消息，我们需要将这些消息 **广播** 给所有其他客户端，以便其他人可以看到发送的聊天消息。让我们现在就来做这件事：
- en: 'Edit **backend/src/socket.js** and extend the **chat.message** event listener
    so that it calls **io.emit** and sends the chat message to everyone:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **backend/src/socket.js** 并扩展 **chat.message** 事件监听器，使其调用 **io.emit** 并将聊天消息发送给所有人：
- en: '[PRE24]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Alternatively, you can use **socket.broadcast.emit** to send an event to every
    client except the one that sent the message.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用 **socket.broadcast.emit** 向除了发送消息的那个客户端以外的所有客户端发送事件。
- en: 'We also need to add a listener for chat messages on the client side. This works
    the same way as on the server. Edit **src/App.jsx** and add the following event
    listener:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在客户端添加一个用于聊天消息的监听器。这与服务器上的方式相同。编辑 **src/App.jsx** 并添加以下事件监听器：
- en: '[PRE25]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, you should see the message being logged on the server and the client. Try
    opening a second window; you will see messages from both clients in your browser!
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你应该能在服务器和客户端看到消息被记录。尝试打开第二个窗口；你将在浏览器中看到来自两个客户端的消息！
- en: '![Figure 13.5 – Receiving messages from another client](img/B19385_13_5.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.5 – 从另一个客户端接收消息](img/B19385_13_5.jpg)'
- en: Figure 13.5 – Receiving messages from another client
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 – 从另一个客户端接收消息
- en: Joining rooms to send messages in
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入房间以发送消息
- en: 'While having a working chat where messages get relayed to everyone is nice,
    often, we don’t want to broadcast our messages to everyone. Instead, we might
    want to only send messages to a certain group of people. To facilitate this, Socket.IO
    provides **rooms**. Rooms can be used to group clients together so that events
    are only sent to all other clients in the room. This feature can be used to create
    chat rooms, but also for collaborating on a project together (by creating a new
    room for each project). Let’s learn how rooms can be used in Socket.IO:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有一个可以传递消息给所有人的工作聊天室是件好事，但通常我们不想将我们的消息广播给所有人。相反，我们可能只想将消息发送给特定的一组人。为了实现这一点，Socket.IO
    提供了 **rooms**。房间可以用来将客户端分组，以便只将事件发送到房间中的所有其他客户端。这个功能可以用来创建聊天室，也可以用来共同协作完成项目（通过为每个项目创建一个新的房间）。让我们学习如何在
    Socket.IO 中使用房间：
- en: 'Socket.IO allows us to pass a query string during the handshake. We can access
    this query string to get the room that the client wants to join. Edit **backend/src/socket.js**
    and get the room from the handshake query:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Socket.IO 允许我们在握手过程中传递查询字符串。我们可以访问这个查询字符串来获取客户端想要加入的房间。编辑 **backend/src/socket.js**
    并从握手查询中获取房间：
- en: '[PRE26]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, use **socket.join** to join the client into the selected room:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 **socket.join** 将客户端加入所选房间：
- en: '[PRE27]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, inside the **chat.message** handler, use **.to(room)** to make sure chat
    messages from that client are only sent to a certain room:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 **chat.message** 处理程序内部，使用 **.to(room)** 确保来自该客户端的聊天消息只发送到特定的房间：
- en: '[PRE28]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the client, we need to pass a query string to tell the server which room
    we would like to join. Edit **src/App.jsx**, as follows:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端，我们需要传递一个查询字符串来告诉服务器我们想要加入哪个房间。编辑 **src/App.jsx**，如下所示：
- en: '[PRE29]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Open **http://localhost:5173/** and **http://localhost:5173/?room=test** in
    two separate browser windows and send messages from both. You will see that the
    message from the second window doesn’t get sent to the first window. However,
    if you open another window with the **?room=test** query string and send a message
    there, you will see the message being forwarded to the second window (but not
    the first).
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个不同的浏览器窗口中打开 **http://localhost:5173/** 和 **http://localhost:5173/?room=test**，并从两个窗口发送消息。你会看到第二个窗口的消息没有发送到第一个窗口。然而，如果你打开另一个带有
    **?room=test** 查询字符串的窗口并发送消息，你会看到消息被转发到第二个窗口（但不是第一个窗口）。
- en: As we can see, we can use rooms to have more fine-grained control over which
    clients receive certain events. As the server controls which rooms a client joins,
    we can also add permission checks before allowing a client to join a room.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们可以使用房间来对哪些客户端接收特定事件有更细粒度的控制。因为服务器控制客户端加入哪些房间，我们也可以在允许客户端加入房间之前添加权限检查。
- en: Using acknowledgments to get information about a user
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用确认信息来获取用户信息
- en: 'As we have seen, events are a great way to send asynchronous messages. Sometimes,
    however, we want a more traditional synchronous request-response API, like we
    had with REST. In Socket.IO, we can implement synchronous events by using **acknowledgments**.
    We can use acknowledgments to, for example, get more information about a user
    in the current chat room. For now, we are only going to return the rooms that
    the user is in. Later, when we add authentication, we are going to fetch the user
    object from the database here. Let’s get started implementing acknowledgments:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，事件是发送异步消息的好方法。然而，有时我们想要一个更传统的同步请求-响应 API，就像我们之前在 REST 中所做的那样。在 Socket.IO
    中，我们可以通过使用 **acknowledgments** 来实现同步事件。我们可以使用确认信息，例如，获取当前聊天室中用户的更多信息。目前，我们只将返回用户所在的房间。稍后，当我们添加身份验证时，我们将在这里从数据库中获取用户对象。让我们开始实现确认信息：
- en: 'Edit **backend/src/socket.js** and define a new event listener:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **backend/src/socket.js** 并定义一个新的事件监听器：
- en: '[PRE30]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note how we are passing a callback function as the last argument. This is what
    makes the event an acknowledgment.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们是如何将回调函数作为最后一个参数传递的。这就是使事件成为确认信息的原因。
- en: 'In this event listener, we are going to fetch all sockets in the room with
    the ID of our socket:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个事件监听器中，我们将获取具有我们 socket ID 的房间中的所有 socket：
- en: '[PRE31]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Internally, Socket.IO creates a room for each connected socket, to make it possible
    to send events to a single socket.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 内部，Socket.IO 为每个连接的 socket 创建一个房间，以便能够向单个 socket 发送事件。
- en: Note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We could directly access the sockets of the current instance, but that wouldn’t
    work anymore when we scale our service to multiple instances in a cluster. To
    make it work even in a cluster, we need to use the room functionality to get a
    socket by ID.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接访问当前实例的 socket，但当我们把我们的服务扩展到集群中的多个实例时，这就不起作用了。为了使其即使在集群中也能工作，我们需要使用房间功能通过
    ID 获取 socket。
- en: 'Now, we must check if we found a socket with the given ID. If not, we return
    **null**:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须检查是否找到了具有给定 ID 的 socket。如果没有找到，我们返回 **null**：
- en: '[PRE32]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Otherwise, we return the socket ID and a list of rooms that the user is in:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们返回 socket ID 和用户所在的房间列表：
- en: '[PRE33]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we can emit the **user.info** event on the client. Edit **src/App.jsx**
    and start by making the **connect** event listener an **async** function:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在客户端上发出 **user.info** 事件。编辑 **src/App.jsx** 并首先将 **connect** 事件监听器改为
    **async** 函数：
- en: '[PRE34]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To emit an event with an acknowledgment, we can use the **emitWithAck** function,
    which returns a Promise that we can **await**:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用确认发出事件，我们可以使用 **emitWithAck** 函数，它返回一个可以 **await** 的 Promise：
- en: '[PRE35]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After saving the code, go to the browser window; you will see the user’s information
    being logged in the console:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存代码后，转到浏览器窗口；你将看到用户信息在控制台中记录下来：
- en: '![Figure 13.6 – Getting user information with an acknowledgment](img/B19385_13_6.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.6 – 使用确认获取用户信息](img/B19385_13_6.jpg)'
- en: Figure 13.6 – Getting user information with an acknowledgment
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6 – 使用确认获取用户信息
- en: 'Now that we have learned how to send various kinds of events, let’s get into
    a more advanced topic: authentication with Socket.IO.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了如何发送各种类型的事件，让我们进入一个更高级的主题：使用 Socket.IO 进行身份验证。
- en: Adding authentication by integrating JWT with Socket.IO
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过将 JWT 与 Socket.IO 集成添加身份验证
- en: 'So far, all chat messages have been sent with the socket ID as the “username.”
    This is not a very good way to identify users in a chat room. To fix this, we
    are going to introduce user accounts by authenticating sockets with JWT. Follow
    these steps to implement JWT with Socket.IO:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有聊天消息都是使用 socket ID 作为“用户名”发送的。这不是在聊天室中识别用户的好方法。为了解决这个问题，我们将通过使用 JWT
    验证 socket 来引入用户账户。按照以下步骤在 Socket.IO 中实现 JWT：
- en: 'Edit **backend/src/socket.js** and import **jwt** from the **jsonwebtoken**
    package and **getUserInfoById** from our service functions:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **backend/src/socket.js** 并从 **jsonwebtoken** 包中导入 **jwt**，以及从我们的服务函数中导入
    **getUserInfoById**：
- en: '[PRE36]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Inside the **handleSocket** function, define a new Socket.IO middleware by
    using **io.use()**. Middleware in Socket.IO works similarly to middleware in Express
    – we define a function that runs before requests are processed, as follows:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **handleSocket** 函数内部，使用 **io.use()** 定义一个新的 Socket.IO 中间件。Socket.IO 中的中间件与
    Express 中的中间件类似 – 我们定义一个在请求处理之前运行的函数，如下所示：
- en: '[PRE37]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Inside this function, we check if the token was sent via the **auth** object
    (similar to how we passed **room** earlier via the query string). If no token
    was passed, we pass an error to the **next()** function and cause the connection
    to fail:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个函数内部，我们检查令牌是否通过 **auth** 对象发送（类似于我们之前如何通过查询字符串发送 **room**）。如果没有传递令牌，我们将错误传递给
    **next()** 函数并导致连接失败：
- en: '[PRE38]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is important not to pass a JWT via the query string since this is part of
    the URL. It is exposed in the browser address bar and thus potentially stored
    in the browser history, where it could be extracted by a potential attacker. Instead,
    the **auth** object is sent via the request payload during the handshake, which
    is not exposed in the address bar.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是不要通过查询字符串传递 JWT，因为这是 URL 的一部分。它在浏览器地址栏中暴露，因此可能被潜在攻击者存储在浏览器历史记录中。相反，**auth**
    对象在握手过程中通过请求有效载荷发送，这不会在地址栏中暴露。
- en: 'Otherwise, we call **jwt.verify** to verify the token by using the existing
    **JWT_SECRET** environment variable:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们调用 **jwt.verify** 通过现有的 **JWT_SECRET** 环境变量来验证令牌：
- en: '[PRE39]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If the token is invalid, we once again return an error in the **next()** function:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果令牌无效，我们再次在 **next()** 函数中返回一个错误：
- en: '[PRE40]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Otherwise, we save the decoded token to **socket.auth**:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们将解码的令牌保存到 **socket.auth**：
- en: '[PRE41]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Additionally, we fetch the user information from the database and, for convenience,
    store it in **socket.user**:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们从数据库中获取用户信息，为了方便，将其存储在 **socket.user**：
- en: '[PRE42]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure that **next()** is always called in Socket.IO middleware. Otherwise,
    Socket.IO will keep the connection open until it is closed after a given timeout.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在 Socket.IO 中间件中始终调用 **next()**。否则，Socket.IO 将保持连接打开，直到在给定超时后关闭。
- en: 'The **user** object contains a **username** value. Now, we can *replace* the
    socket ID in the chat message with the username:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**user**对象包含一个**username**值。现在，我们可以**替换**聊天消息中的 socket ID 为用户名：'
- en: '[PRE43]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can also return the user information from the **user.info** event:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以从**user.info**事件返回用户信息：
- en: '[PRE44]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We still need to send the auth object from the client side, edit **src/App.jsx**,
    and get the token from **localStorage**, as follows:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们仍然需要从客户端发送身份验证对象，编辑**src/App.jsx**，并从**localStorage**中获取令牌，如下所示：
- en: '[PRE45]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For simplicity, we store and read the JWT in **localStorage** for this example.
    However, it is not a good idea to store a JWT like this in production as **localStorage**
    could be read by an attacker if they find a way to inject JavaScript. A better
    way to store a JWT would be by using a cookie with the **Secure**, **HttpOnly**,
    and **SameSite="Strict"** attributes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们在这个例子中将 JWT 存储和读取到**localStorage**中。然而，在生产环境中将 JWT 以这种方式存储并不是一个好主意，因为如果攻击者找到了注入
    JavaScript 的方法，**localStorage**可能会被读取。存储 JWT 的更好方式是使用具有**Secure**、**HttpOnly**和**SameSite="Strict"**属性的
    cookie。
- en: 'Now that the server side is set up, we can try logging in on the client. Initially,
    we are going to see an error message:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在服务器端已设置好，我们可以在客户端尝试登录。最初，我们会看到一个错误消息：
- en: '![Figure 13.7 – An error message from Socket.IO because no JWT was provided](img/B19385_13_7.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.7 – 由于未提供 JWT 而从 Socket.IO 发出的错误消息](img/B19385_13_7.jpg)'
- en: Figure 13.7 – An error message from Socket.IO because no JWT was provided
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7 – 由于未提供 JWT 而从 Socket.IO 发出的错误消息
- en: 'To get a token, we can sign up and log in normally using the existing blog
    frontend. Then, we can check the **Network** tab of the inspector to find the
    **/login** request with a token inside the response:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取令牌，我们可以使用现有的博客前端正常注册和登录。然后，我们可以检查检查器的**网络**选项卡，以找到响应中包含令牌的**/login**请求：
- en: '![Figure 13.8 – Copying the JWT from the Network tab](img/B19385_13_8.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.8 – 从网络选项卡复制 JWT](img/B19385_13_8.jpg)'
- en: Figure 13.8 – Copying the JWT from the Network tab
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8 – 从网络选项卡复制 JWT
- en: 'Copy this token and add it to **localStorage** by running **localStorage.setItem(''token'',
    ''<JWT>'')** in the browser console (replacing **<JWT>** with the copied token).
    Upon refreshing the page, it should work! As we can see, when logged in with two
    different users, we can see their messages with their respective usernames:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此令牌复制并添加到**localStorage**中，通过在浏览器控制台中运行**localStorage.setItem('token', '<JWT>')**（将**<JWT>**替换为复制的令牌）。刷新页面后，它应该可以工作！正如我们所见，当我们用两个不同的用户登录时，我们可以看到他们带有各自用户名的消息：
- en: '![Figure 13.9 – Receiving messages from different users](img/B19385_13_9.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.9 – 从不同用户接收消息](img/B19385_13_9.jpg)'
- en: Figure 13.9 – Receiving messages from different users
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.9 – 从不同用户接收消息
- en: Our chat backend is now fully functional! In the next chapter, we are going
    to create a frontend to complete our chat app.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们聊天应用的后端现在完全功能正常！在下一章中，我们将创建一个前端来完善我们的聊天应用。
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about event-based applications, WebSockets, and
    Socket.IO. Then, we set up Socket.IO on the backend (server) and frontend (client).
    Afterward, we learned how to send messages between the server and client, how
    to join rooms, and how to broadcast messages. We also used acknowledgments to
    get information about a user in a request-response pattern with Socket.IO. Finally,
    we implemented authentication using JWT in Socket.IO, finalizing our chat app
    backend.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了基于事件的应用程序、WebSockets 和 Socket.IO。然后，我们在后端（服务器）和前端（客户端）上设置了 Socket.IO。之后，我们学习了如何在服务器和客户端之间发送消息，如何加入房间，以及如何广播消息。我们还使用确认来获取有关请求-响应模式中用户的信息。最后，我们在
    Socket.IO 中实现了使用 JWT 的身份验证，完成了我们的聊天应用后端。
- en: In the next chapter, [*Chapter 14*](B19385_14.xhtml#_idTextAnchor262), *Creating
    a Frontend to Consume and Send Events*, we are going to create a frontend for
    our chat app, which is going to interact with the backend we created in this chapter.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章[*第 14 章*](B19385_14.xhtml#_idTextAnchor262)，*创建用于消费和发送事件的客户端*，我们将创建我们的聊天应用的客户端，它将与我们本章创建的后端交互。
