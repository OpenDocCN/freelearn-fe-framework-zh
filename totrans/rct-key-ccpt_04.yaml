- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Events and State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add user event handlers (for example, for reacting to button clicks) to React
    apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the **user interface** ( **UI** ) via a concept called **state**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build real dynamic and interactive UIs (that is, so that they are not static
    anymore)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, you learned how to build UIs with the help of React
    **components** . You also learned about **props** —a concept and feature that
    enables React developers to build and reuse configurable components.
  prefs: []
  type: TYPE_NORMAL
- en: These are all important React features and building blocks, but with these features
    alone, you would only be able to build static React apps (that is, web apps that
    never change). You would not be able to change or update the content on the screen
    if you only had access to those features. You also would not be able to react
    to any user events and update the UI in response to such events (for instance,
    to show an overlay window upon a button click).
  prefs: []
  type: TYPE_NORMAL
- en: Put in other words, you would not be able to build real websites and web applications
    if you were limited to just components and props.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, in this chapter, a brand-new concept is introduced: state. State
    is a React feature that allows developers to update internal data and trigger
    a UI update based on such data adjustments. In addition, you will learn how to
    react (no pun intended) to user events such as button clicks or text being entered
    into input fields.'
  prefs: []
  type: TYPE_NORMAL
- en: What’s the Problem?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As outlined previously, at this point in the book, there is a problem with
    all React apps and sites you might be building: they’re static. The UI can’t change.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this issue a bit better, take a look at a typical React component,
    as you are able to build it up to this point in the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This component might look strange though. Why is there a `<p>` element that
    informs the user about an incorrect email address?
  prefs: []
  type: TYPE_NORMAL
- en: Well, the goal might be to show that paragraph only if the user *did* enter
    an incorrect email address. That is to say, the web app should wait for the user
    to start typing and evaluate the user input once the user is done typing (that
    is, once the input loses focus). Then, the error message should be shown if the
    email address is considered invalid (for example, an empty input field or a missing
    `@` symbol).
  prefs: []
  type: TYPE_NORMAL
- en: But at the moment, with the React skills picked up thus far, this is something
    you would not be able to build. Instead, the error message would always be shown
    since there is no way of changing it based on user events and dynamic conditions.
    In other words, this React app is a static app, not dynamic. The UI can’t change.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, changing UIs and dynamic web apps are things you might want to build.
    Almost every website that exists contains some dynamic UI elements and features.
    Therefore, that’s the problem that will be solved in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How Not to Solve the Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How could the component shown previously be made more dynamic?
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is one solution you could come up with ( *spoiler* , *the code
    won’t work, so you don’t need to try running it* ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code won’t work, because you can’t select React-rendered DOM elements from
    inside the same component file this way. This is just meant as a dummy example
    of how you could try to solve this. That being said, you could put the code below
    the component function some place where it does execute successfully (for example,
    into a `setTimeout()` callback that fires after a second, allowing the React app
    to render all elements onto the screen).
  prefs: []
  type: TYPE_NORMAL
- en: Put in the right place, this code will add the email validation behavior described
    earlier in this chapter. Upon the built-in `blur` event, the `evaluateEmail` function
    is triggered. This function receives the `event` object as an argument (automatically,
    by the browser), and therefore the `evaluateEmail` function is able to parse the
    entered value from that `event` object via `event.target.value` . The entered
    value can then be used in an `if` check to conditionally display or remove the
    error message.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: All the preceding code that deals with the `blur` event (such as `addEventListener`
    ) and the `event` object, including the code in the `if` check, is standard JavaScript
    code. It is not specific to React in any way.
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself struggling with this non-React code, it’s strongly recommended
    that you dive into more vanilla JavaScript resources (such as the guides on the
    MDN website at [https://developer.mozilla.org/en-US/docs/Web/JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript)
    ) first.
  prefs: []
  type: TYPE_NORMAL
- en: But what’s wrong with this code if it would work in some places of the overall
    application code?
  prefs: []
  type: TYPE_NORMAL
- en: It’s imperative code! That means you are writing down step-by-step instructions
    on what the browser should do. You are not declaring the desired end state; you
    are instead describing a way of getting there; and it’s not using React.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that React is all about controlling the UI and that writing React
    code is about writing declarative code—instead of imperative code. Revisit *Chapter
    2* , *Understanding React Components and JSX* , if that sounds brand new to you.
  prefs: []
  type: TYPE_NORMAL
- en: You could achieve your goal by introducing this kind of code, but you would
    be working against React and its philosophy (React’s philosophy being that you
    declare your desired end states and let React figure out how to get there). A
    clear indicator of this is the fact that you would be forced to find the right
    place for this kind of code in order for it to work.
  prefs: []
  type: TYPE_NORMAL
- en: This is not a philosophical problem, and it’s not just some weird hard rule
    that you should follow. Instead, by working against React like this, you will
    make your life as a developer unnecessarily hard. You are neither using the tools
    React gives you nor letting React figure out how to achieve the desired (UI) state.
  prefs: []
  type: TYPE_NORMAL
- en: That does not just mean that you spend time on solving problems you wouldn’t
    have to solve. It also means that you’re passing up possible optimizations React
    might be able to perform under the hood. Your solution is very likely not just
    leading to more work (that is, more code) for you; it also might result in a buggy
    result that could also suffer from suboptimal performance.
  prefs: []
  type: TYPE_NORMAL
- en: The example shown previously is a simple one. Think about more complex websites
    and web apps, such as online shops, vacation rental websites, or web apps such
    as Google Docs. There, you might have dozens or hundreds of (dynamic) UI features
    and elements. Managing them all with a mixture of React code and standard vanilla
    JavaScript code will quickly become a nightmare. Again, refer to *Chapter 2, Understanding
    React Components and JSX,* of this book to understand the merits of React.
  prefs: []
  type: TYPE_NORMAL
- en: A Better Incorrect Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The naïve approach discussed previously doesn’t work well. It forces you to
    figure out how to make the code run correctly (for example, by wrapping parts
    of it in some `setTimeout()` call to defer execution) and leads to your code being
    scattered all over the place (that is, inside of React component functions, outside
    of those functions, and maybe also in totally unrelated files). How about a solution
    that embraces React, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This code again would not work (even though it’s technically valid JavaScript
    code). Selecting JSX elements doesn’t work like this. It doesn’t work because
    `document.querySelector('input')` executes before anything is rendered to the
    DOM (when the component function is executed for the first time). Again, you would
    have to delay the execution of that code until the first render cycle is over
    (you would therefore be once again working against React).
  prefs: []
  type: TYPE_NORMAL
- en: But even though it still would not work, it’s closer to the correct solution.
  prefs: []
  type: TYPE_NORMAL
- en: It’s closer to the ideal implementation because it embraces React way more than
    the first attempted solution did. All the code is contained in the component function
    to which it belongs. The error message is handled via an `errorMessage` variable
    that is output as part of the JSX code.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind this possible solution is that the React component that controls
    a certain UI feature or element is also responsible for its state and events.
    You might identify two important keywords of this chapter here!
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach is definitely going in the right direction, but it still wouldn’t
    work for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the JSX `<input>` element via `document.querySelector('input')` would
    fail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if the input could be selected, the UI would not update as expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two problems will be solved next—finally leading to an implementation
    that embraces React and its features. The upcoming solution will avoid mixing
    React and non-React code. As you will see, the result will be easier code where
    you have to do less work (that is, write less code).
  prefs: []
  type: TYPE_NORMAL
- en: Improving the Solution by Properly Reacting to Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of mixing imperative JavaScript code such as `document.querySelector('input')`
    with React-specific code, you should fully embrace React and its features.
  prefs: []
  type: TYPE_NORMAL
- en: Since listening to events and triggering actions upon events is an extremely
    common requirement, React has a built-in solution. You can attach event listeners
    directly to the JSX elements to which they belong.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example would be rewritten like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This code still will not update the UI, but at least the event is handled properly.
  prefs: []
  type: TYPE_NORMAL
- en: The `onBlur` prop was added to the built-in input element. This prop is made
    available by React, just as all these base HTML elements (such as `<input>` and
    `<p>` ) are made available as components by React. In fact, all these built-in
    HTML components come with their standard HTML attributes as React props (plus
    some extra props, such as the `onBlur` event handling prop).
  prefs: []
  type: TYPE_NORMAL
- en: React exposes all standard events that can be connected to DOM elements as `onXYZ`
    props (where `XYZ` is the event name, such as `blur` or `click` , starting with
    a capital character). You can react to the `blur` event by adding the `onBlur`
    prop. You could listen to a `click` event via the `onClick` prop. You get the
    idea.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: For more information on standard events, see [https://developer.mozilla.org/en-US/docs/Web/Events#event_listing](https://developer.mozilla.org/en-US/docs/Web/Events#event_listing)
    .
  prefs: []
  type: TYPE_NORMAL
- en: These props require values to fulfill their job. To be precise, they need a
    pointer to the function that should be executed when the event occurs. In the
    preceding example, the `onBlur` prop receives a pointer to the `evaluateEmail`
    function as a value.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a subtle difference between `evaluateEmail` and `evaluateEmail()` .
    The first is a pointer to the function; the second actually executes the function
    (and yields the return value, if any). Again, this is not something specific to
    React but a standard JavaScript concept. If it’s not clear, this resource explains
    it in greater detail: [https://developer.mozilla.org/en-US/docs/Web/Events#event_listing](https://developer.mozilla.org/en-US/docs/Web/Events#event_listing)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'By using these event props, the preceding example code will now finally execute
    without throwing any errors. You could verify this by adding a `console.log(''Hello'');`
    statement inside the `evaluateEmail` function. This will display the `''Hello''`
    text in the console of your browser developer tools, whenever the input loses
    focus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the browser console, this looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_04_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Displaying some text in the browser console upon removing focus
    from the input field'
  prefs: []
  type: TYPE_NORMAL
- en: This is definitely one step closer to the best possible implementation, but
    it also still won’t produce the desired result of updating the page content dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Updating State Correctly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you understand how to correctly set up event listeners and execute functions
    upon certain events. What’s missing is a feature that forces React to update the
    visible UI on the screen and the content that is displayed to the app users.
  prefs: []
  type: TYPE_NORMAL
- en: That’s where React’s **state** concept comes into play. Like props, state is
    a key concept of React, but whereas props are about receiving external data inside
    a component, state is about managing and updating **internal data** . Most importantly,
    whenever state is updated, React goes ahead and updates the parts of the UI that
    are affected by the state change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how state is used in React (of course, the code will then be explained
    in detail afterward):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Compared to the example code discussed earlier in this chapter, this code doesn’t
    look much different. But there is a key difference: the usage of the `useState()`
    Hook.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hooks** are another key concept of React. These are special functions that
    can only be used inside of React components (or inside of other Hooks, as will
    be covered in *Chapter 12* , *Building Custom React Hooks* ). Hooks add special
    features and behaviors to the React components in which they are used. For example,
    the `useState()` Hook allows a component (and therefore, implicitly React) to
    set and manage some state that is tied to this component. React provides various
    built-in Hooks, and they are not all focused on state management. You will learn
    about other Hooks and their purposes throughout this book.'
  prefs: []
  type: TYPE_NORMAL
- en: The `useState()` Hook is an extremely important and commonly used Hook as it
    enables you to manage data inside a component, which, when updated, tells React
    to update the UI accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is the core idea behind state management and this state concept: state
    is data, which, when changed, should force React to re-evaluate a component and
    update the UI if needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Hooks, such as `useState()` , is pretty straightforward: you import them
    from `''react''` and you then call them like a function inside your component
    function. You call them like a function because, as mentioned, React Hooks are
    functions—just special functions (from React’s perspective).'
  prefs: []
  type: TYPE_NORMAL
- en: A Closer Look at useState()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How exactly does the `useState()` Hook work and what does it do internally?
  prefs: []
  type: TYPE_NORMAL
- en: 'By calling `useState()` inside a component function, you register some data
    with React. It’s a bit like defining a variable or constant in vanilla JavaScript.
    But there is something special: React will track the registered value internally,
    and whenever you update it, React will re-evaluate the component function in which
    the state was registered.'
  prefs: []
  type: TYPE_NORMAL
- en: React does this by checking whether the data used in the component changed.
    Most importantly, React validates whether the UI needs to change because of changed
    data (for example, because a value is output inside the JSX code). If React determines
    that the UI needs to change, it goes ahead and updates the real DOM in the places
    where an update is needed (for example, changing some text that’s displayed on
    the screen). If no update is needed, React ends the component re-evaluation without
    updating the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: React’s internal workings will be discussed in great detail *Chapter 10* , *Behind
    the Scenes of React and Optimization Opportunities* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire process starts with calling `useState()` inside a component. This
    creates a state value (which will be stored and managed by React) and ties it
    to a specific component. An initial state value is registered by simply passing
    it as a parameter value to `useState()` . In the preceding example, an empty string
    ( `''''` ) is registered as a first value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the example, `useState()` does not just accept a parameter
    value. It also returns a value: an array with exactly two elements.'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example uses **array destructuring** , which is a standard JavaScript
    feature that allows developers to retrieve values from an array and immediately
    assign them to variables or constants. In the example, the two elements that make
    up the array returned by `useState()` are pulled out of that array and stored
    in two constants ( `errorMessage` and `setErrorMessage` ). You don’t have to use
    array destructuring when working with React or `useState()` , though.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could also write the code like this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This works absolutely fine, but when using array destructuring, the code stays
    a bit more concise. That’s why you typically see the syntax using array destructuring
    when browsing React apps and examples. You also don’t have to use constants; variables
    (via `let` ) would be fine as well. As you will see throughout this chapter and
    the rest of the book, though, the variables won’t be reassigned, so using constants
    makes sense (but it is not required in any way).
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: If array destructuring or the difference between variables and constants sounds
    brand new to you, it’s strongly recommended that you refresh your JavaScript basics
    before progressing with this book. As always, MDN provides great resources for
    that (see [http://packt.link/3B8Ct](http://packt.link/3B8Ct) for array destructuring,
    [https://packt.link/hGjqL](https://packt.link/hGjqL) for information on the `let`
    variable, and [https://packt.link/TdPPS](https://packt.link/TdPPS) for guidance
    on the use of `const` ).
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, `useState()` returns an array with exactly two elements.
    It will always be exactly two elements—and always exactly the same kind of elements.
    The first element is always the current state value, and the second element is
    a function that you can call to set the state to a new value.
  prefs: []
  type: TYPE_NORMAL
- en: But how do these two values (the state value and the state-updating function)
    work together? What does React do with them internally? How are these two array
    elements used (by React) to update the UI?
  prefs: []
  type: TYPE_NORMAL
- en: A Look Under the Hood of React
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'React manages the state values for you, in some internal storage that you,
    the developer, can’t directly access. Since you often do need access to a state
    value (for instance, some entered email address, as in the preceding example),
    React provides a way of reading state values: the first element in the array returned
    by `useState()` . The first element of the returned array holds the current state
    value. You can therefore use this element in any place where you need to work
    with the state value (for example, in the JSX code to output it there).'
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you often also need to update the state—for example, because a
    user entered a new email address. Since you don’t manage the state value yourself,
    React gives you a function that you can call to inform React about the new state
    value. That’s the second element in the returned array.
  prefs: []
  type: TYPE_NORMAL
- en: In the example shown before, you call `setErrorMessage('Error!')` to set the
    `errorMessage` state value to a new string ( `'Error!'` ).
  prefs: []
  type: TYPE_NORMAL
- en: But why is this managed like this? Why not just use a standard JavaScript variable
    that you can assign and reassign as needed?
  prefs: []
  type: TYPE_NORMAL
- en: Because React must be informed whenever there’s a state that impacts the UI
    changes. Otherwise, the visible UI doesn’t change at all, even in cases where
    it should. React does not track regular variables and changes to their values,
    so they have no influence on the state of the UI.
  prefs: []
  type: TYPE_NORMAL
- en: The state-updating function exposed by React (that second array element returned
    by `useState()` ) *does* trigger some internal UI-updating effect though. This
    state-updating function does more than set a new value; it also informs React
    that a state value changed and that the UI might therefore be in need of an update.
  prefs: []
  type: TYPE_NORMAL
- en: So, whenever you call `setErrorMessage('Error!')` , React does not just update
    the value that it stores internally; it also checks the UI and updates it when
    needed. UI updates can involve anything from simple text changes up to the complete
    removal and addition of various DOM elements. Anything is possible there!
  prefs: []
  type: TYPE_NORMAL
- en: React determines the new target UI by rerunning (also called re-evaluating)
    any component functions that are affected by a state change. That includes the
    component function that executed the `useState()` function that returned the state-updating
    function that was called. But it also includes any child components, since an
    update in a parent component could lead to new state data that’s also used by
    some child components (the state value could be passed to child components via
    props).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need a visual of how all this fits together, consider the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a system  Description automatically generated](img/B31339_04_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: React state updating flow'
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to understand and keep in mind that React will re-execute (re-evaluate)
    a component function if a state-updating function is called in the component function
    or some parent component function. This also explains why the state value returned
    by `useState()` (that is, the first array element) can be a constant, even though
    you can assign new values by calling the state-updating function (the second array
    element). Since the entire component function is re-executed, `useState()` is
    also called again (because all the component function code is executed again)
    and hence a new array with two new elements is returned by React. The first array
    element is still the current state value.
  prefs: []
  type: TYPE_NORMAL
- en: However, as the component function was called because of a state update, the
    current state value is now the updated value.
  prefs: []
  type: TYPE_NORMAL
- en: This can be a bit tricky to wrap your head around, but it is how React works
    internally. In the end, it’s just about component functions being called multiple
    times by React, just as any JavaScript function can be called multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: Naming Conventions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `useState()` Hook is typically used in combination with array destructuring,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: But when using array destructuring, the names of the variables or constants
    ( `enteredEmail` and `setEnteredEmail` , in this case) are up to you, the developer.
    Therefore, a valid question is how you should name these variables or constants.
    Fortunately, there is a clear convention when it comes to React and `useState()`
    , and these variable or constant names.
  prefs: []
  type: TYPE_NORMAL
- en: The **first element** (that is, the current state value) should be named such
    that it describes what the state value is all about. Examples would be `enteredEmail`
    , `userEmail` , `providedEmail` , just `email` , or similar names. You should
    avoid generic names such as `a` or `value` or misleading names such as `setValue`
    (which sounds like it is a function—but it isn’t).
  prefs: []
  type: TYPE_NORMAL
- en: The **second element** (that is, the state-updating function) should be named
    such that it becomes clear that it is a function and that it does what it does.
    Examples would be `setEnteredEmail` or `setEmail` . In general, the convention
    for this function is to name it `setXYZ` , where `XYZ` is the name you chose for
    the first element, the current state value variable. (Note, though, that you start
    with an uppercase character, as in `setEnteredEmail` , not `setenteredEmail` .)
  prefs: []
  type: TYPE_NORMAL
- en: Allowed State Value Types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Managing entered email addresses (or user input in general) is indeed a common
    use case and example for working with state. However, you’re not limited to this
    scenario and value type.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of entered user input, you will often deal with string values such
    as email addresses, passwords, blog posts, or similar values. But any valid JavaScript
    value type can be managed with the help of `useState()` . You could, for example,
    manage the total sum of multiple shopping cart items—that is, a number—or a Boolean
    value (for example, *“Did a user confirm the terms of use?”* ).
  prefs: []
  type: TYPE_NORMAL
- en: Besides managing primitive value types, you can also store and update reference
    data types such as objects and arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the difference between primitive and reference data types is not entirely
    clear, it’s strongly recommended that you dive into this core JavaScript concept
    before proceeding with this book through the following link: [https://academind.com/tutorials/reference-vs-primitive-values](https://academind.com/tutorials/reference-vs-primitive-values)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: React gives you the flexibility of managing all these value types as state.
    You can even switch the value type at runtime (just as you can in vanilla JavaScript).
    It is absolutely fine to store a number as the initial state value and update
    it to a string at a later point in time.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with vanilla JavaScript, you should, of course, ensure that your program
    deals with this behavior appropriately, though there’s nothing technically wrong
    with switching types.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Multiple State Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building anything but very simple web apps or UIs, you will need multiple
    state values. Maybe users can not only enter their email but also a username or
    their address. Maybe you also need to track some error state or save shopping
    cart items. Maybe users can click a “like” button whose state should be saved
    and reflected in the UI. There are many values that change frequently and whose
    changes should be reflected in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this concrete scenario: you have a component that needs to manage
    both the value entered by a user into an email input field and the value that
    was inserted into a password field. Each value should be captured once a field
    loses focus.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you have two input fields that hold different values, you have two state
    values: the entered email and the entered password. Even though you might use
    both values together at some point (for example, to log a user in), the values
    are not provided simultaneously. In addition, you might also need every value
    to stand alone, since you use it to show potential error messages (for example,
    *“password too short”* ) while the user is entering data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenarios like this are very common, and therefore, you can also manage multiple
    state values with the `useState()` Hook. There are two main ways of doing that:'
  prefs: []
  type: TYPE_NORMAL
- en: Use multiple **state slices** (multiple state values)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using one single, *big* state object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Multiple State Slices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can manage multiple state values (also often called **state slices** ) by
    simply calling `useState()` multiple times in your component function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the example described previously, a (simplified) component function could
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, two state slices are managed by calling `useState()` twice.
    Therefore, React registers and manages two state values internally. These two
    values can be read and updated independently from each other.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: In the example, the functions that are triggered upon events start with `handle`
    ( `handleUpdateEmail` and `handleUpdatePassword` ). This is a convention used
    by some React developers. Event handler functions start with `handle…` to make
    it clear that these functions handle certain (user-triggered) events. This is
    not a convention you have to follow. The functions could have also been named
    `updateEmail` , `updatePassword` , `emailUpdateHandler` , `passwordUpdateHandler`
    , or anything else. If the name is meaningful and follows some stringent convention,
    it’s a valid choice.
  prefs: []
  type: TYPE_NORMAL
- en: You can register as many state slices (by calling `useState()` multiple times)
    as you need in a component. You could have one state value, but you could also
    have dozens or even hundreds. Typically, though, you will only have a couple of
    state slices per component since you should try to split bigger components (which
    might be doing lots of different things) into multiple smaller components to keep
    them manageable.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of managing multiple state values like this is that you can update
    them independently. If the user enters a new email address, you only need to update
    that email state value. The password state value doesn’t matter for your purposes.
  prefs: []
  type: TYPE_NORMAL
- en: A possible disadvantage could be that multiple state slices—and therefore multiple
    `useState()` calls—lead to lots of lines of code that might bloat your component.
    As mentioned before, though, you typically should try to break up big components
    (that handle lots of different slices of state) into multiple smaller components
    anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still, there is an alternative to managing multiple state values like this:
    you can also manage a single, *merged* state value object.'
  prefs: []
  type: TYPE_NORMAL
- en: Managing Merged State Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of calling `useState()` for every single state slice, you can go for
    one *big* state object that combines all the different state values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `useState()` is called only once (i.e., there’s only one state
    slice), and the initial value passed to `useState()` is a JavaScript object. The
    object contains two properties: `email` and `password` . The property names are
    up to you, but they should describe the values that will be stored in the properties.'
  prefs: []
  type: TYPE_NORMAL
- en: '`useState()` still returns an array with exactly two elements. That the initial
    value is an object does not change anything about that. The first element of the
    returned array is now just an object instead of a string (as it was in the examples
    shown earlier). As mentioned before, any valid JavaScript value type can be used
    when working with `useState()` . Primitive value types such as strings or numbers
    can be used just as you would reference value types such as objects or arrays
    (which, technically, are objects of course).'
  prefs: []
  type: TYPE_NORMAL
- en: The state-updating function ( `setUserData` , in the preceding example) is still
    a function created by React that you can call to set the state to a new value.
    Also, you wouldn’t have to set it to an object again, though that is typically
    the default. You don’t change value types when updating state unless you have
    a good reason for doing so (though, technically, you are allowed to switch to
    a different type at any time).
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the way the state-updating function is used is not
    entirely correct. It would work but it does violate recommended best practices.
    You will learn later in this chapter why this is the case and how you should use
    the state-updating function instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'When managing state objects as shown in the preceding example, there’s one
    crucial thing you should keep in mind: you must always set all properties the
    object contains, even the ones that didn’t change. This is required because, when
    calling the state-updating function, you *tell* React which new state value should
    be stored internally.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, any value you pass as an argument to the state-updating function will
    overwrite the previously stored value. If you provide an object that contains
    only the properties that changed, all other properties will be lost since the
    previous state object is replaced by the new one, which contains fewer properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a common pitfall and therefore something you must pay attention to.
    For this reason, in the example shown previously, the property that is not changed
    is set to the previous state value—for example, `email: userData.email` , where
    `userData` is the current state snapshot and the first element of the array returned
    by `useState()` , while setting `password` to `event.target.value` .'
  prefs: []
  type: TYPE_NORMAL
- en: It is totally up to you whether you prefer to manage one state value (that is,
    an object grouping together multiple values) or multiple state slices (that is,
    multiple `useState()` calls) instead. There is no right or wrong way and both
    approaches have their advantages and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is worth noting that you should typically try to break up *big*
    components into smaller ones. Just as regular JavaScript functions shouldn’t do
    too much work in a single function (it is considered a good practice to have separate
    functions for different tasks), components should focus on one or only a few tasks
    per component as well. Instead of having a huge `<App />` component that handles
    multiple forms, user authentication, and a shopping cart directly in one component,
    it would be preferable to split the code of that component into multiple smaller
    components that are then combined to build the overall app.
  prefs: []
  type: TYPE_NORMAL
- en: When following that advice, most components shouldn’t have too much state to
    manage anyway, since managing many state values is an indicator of a component
    doing *too much work* . That’s why you might end up using a few state slices per
    component, instead of large state objects.
  prefs: []
  type: TYPE_NORMAL
- en: Updating State Based on Previous State Correctly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When learning about objects as state values, you learned that it’s easy to accidentally
    overwrite (and lose) data because you might set the new state to an object that
    contains only the properties that changed—not the ones that didn’t. That’s why,
    when working with objects or arrays as state values, it’s important to always
    add the existing properties and elements to the new state value.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in general, setting a state value to a new value that is (at least partially)
    based on the previous state is a common task. You might set `password` to `event.target.value`
    but also set `email` to `userData.email` to ensure that the stored email address
    is not lost due to updating a part of the overall state (that is, because of updating
    the password to the newly entered value).
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s not the only scenario where the new state value could be based on the
    previous one, though. Another example would be a `counter` component—for example,
    a component like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a `click` event handler is registered for `<button>` (via the
    `onClick` prop). Upon every click, the counter state value is incremented by `1`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'This component would work, but the code shown in the example snippet is actually
    violating an important best practice and recommendation: state updates that depend
    on some previous state should be performed with the help of a function that’s
    passed to the state-updating function. To be precise, the example should be rewritten
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This might look a bit strange. It might seem like a function is now passed as
    the new state value to the state-updating function (that is, the number stored
    in `counter` is replaced with a function). But, indeed, that is not the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Technically, a function *is* passed as an argument to the state-updating function,
    but React won’t store that function as the new state value. Instead, when receiving
    a function as a new state value in the state-updating function, React will call
    that function for you and pass the latest state value to that function. Therefore,
    you should provide a function that accepts at least one parameter: the previous
    state value. This value will be passed into the function automatically by React
    when React executes the function (which it will do internally).'
  prefs: []
  type: TYPE_NORMAL
- en: The function should then also return a value—the new state value that should
    be stored by React. Also, since the function receives the previous state value,
    you can now derive the new state value based on the previous state value (for
    example, by adding the number 1 to it, but any operation could be performed here).
  prefs: []
  type: TYPE_NORMAL
- en: Why is this required if the app worked fine before this change as well? It’s
    required because, in more complex React applications and UIs, React could be processing
    many state updates simultaneously—potentially triggered from different sources
    at different times.
  prefs: []
  type: TYPE_NORMAL
- en: When *not* using the approach discussed in the last paragraphs, the order of
    state updates might not be the expected one and bugs could be introduced into
    the app. Even if you know that your use case won’t be affected and the app does
    its job without issue, it is recommended to simply adhere to the discussed best
    practice and pass a function to the state-updating function if the new state depends
    on the previous state.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this newly gained knowledge in mind, take another look at an earlier code
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Can you spot the error in this code?
  prefs: []
  type: TYPE_NORMAL
- en: It’s not a technical error; the code will execute fine, and the app will work
    as expected. But there is a problem with this code nonetheless. It violates the
    discussed best practice. In the code snippet, the state in both handler functions
    is updated by referring to the current state snapshot via `userData.password`
    and `userData.email` , respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code snippet should be rewritten like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: By passing an arrow function as an argument to `setUserData` , you allow React
    to call that function. React will do this automatically (that is, if it receives
    a function in this place, React will call it) and it will provide the previous
    state ( `prevState` ) automatically. The returned value (the object that stores
    the updated `email` or `password` and the currently stored `email` or `password`
    ) is then set as the new state. The result, in this case, might be the same as
    before, but now the code adheres to recommended best practices.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, an arrow function was used instead of a “regular” function.
    Both approaches are fine, though. You can use either of the two function types;
    the result will be the same.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, you should always pass a function to the state-updating function
    if the new state depends on the previous state. Otherwise, if the new state depends
    on some other value (for instance, user input), directly passing the new state
    value as a function argument is absolutely fine and recommended.
  prefs: []
  type: TYPE_NORMAL
- en: Two-Way Binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is one special usage of React’s state concept that is worth discussing:
    **two-way binding** .'
  prefs: []
  type: TYPE_NORMAL
- en: Two-way binding is a concept that is used if you have an input source (typically
    an `<input>` element) that sets some state upon user input (for instance, upon
    the `change` event) and outputs the input at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Compared to the other code snippets and examples, the difference here is that
    the component does not just store the user input (upon the `change` event, in
    this case) but that the entered value is also output in the `<input>` element
    (via the default `value` prop) thereafter.
  prefs: []
  type: TYPE_NORMAL
- en: This might look like an infinite loop, but React deals with this and ensures
    that it doesn’t become one. Instead, this is what’s commonly referred to as two-way
    binding as a value is both set and read from the same source.
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder why this is being discussed here, but it is important to know
    that it is perfectly valid to write code like this. Also, this kind of code could
    be necessary if you don’t just want to set a value (in this case, the `email`
    value) upon user input in the `<input>` field but also from other sources. For
    example, you might have a button in the component that, when clicked, should clear
    the entered email address.
  prefs: []
  type: TYPE_NORMAL
- en: 'It might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this updated example, the `handleClearInput` function is executed when `<button>`
    is clicked. Inside the function, the `email` state is set back to an empty string.
    Without two-way binding, the state would be updated, but the change would not
    be reflected in the `<input>` element. There, the user would still see their last
    input. The state reflected on the UI (the website) and the state managed internally
    by React would be different—a bug you absolutely must avoid.
  prefs: []
  type: TYPE_NORMAL
- en: Deriving Values from State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can probably tell by now, state is a key concept in React. State allows
    you to manage data that, when changed, forces React to re-evaluate a component
    and, ultimately, the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a developer, you can use state values anywhere in your component (and in
    your child components, by passing state to them via props). You could, for example,
    repeat what a user entered like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This component might not be too useful, but it will work, and it does use state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, in order to do more useful things, you will need to use a state value
    as a basis to derive a new (often more complex) value. For example, instead of
    simply repeating what the user entered, you could count the number of entered
    characters and show that information to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note the addition of the new `numChars` constant (it could also be a variable,
    via `let` ). This constant is derived from the `userInput` state by accessing
    the `length` property on the string value that’s stored in the `userInput` state.
  prefs: []
  type: TYPE_NORMAL
- en: This is important! You’re not limited to working with state values only. You
    can manage some key value as state (that is, the value that will change) and derive
    other values based on that state value—such as, in this case, the number of characters
    entered by the user. Indeed, this is something you will do frequently as a React
    developer.
  prefs: []
  type: TYPE_NORMAL
- en: You might also be wondering why `numChars` is a constant and outside of the
    `handleChange` function. After all, that is the function that is executed upon
    user input (that is, upon every keystroke the user makes).
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind what you learned about how React handles state internally. When
    you call the state-updating function ( `setUserInput` , in this case), React will
    re-evaluate the component to which the state belongs. This means that the `CharCounter`
    component function will be called again by React. All the code in that function
    is therefore executed again.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a component  Description automatically generated](img/B31339_04_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: The numChars value is derived from state when the component function
    executes again'
  prefs: []
  type: TYPE_NORMAL
- en: React does re-execute component functions to determine what the UI should look
    like after the state update; and, if it detects any differences compared to the
    currently rendered UI, React will go ahead and update the browser UI (that is,
    the DOM) accordingly. Otherwise, nothing will happen.
  prefs: []
  type: TYPE_NORMAL
- en: Since React calls the component function again, `useState()` will yield its
    array of values (current state value and state-updating function). The current
    state value will be the state to which it was set when `setUserInput` was called.
    Therefore, this new `userInput` value can be used to perform other calculations
    anywhere in the component function—such as deriving `numChars` by accessing the
    `length` property of `userInput` (as shown in *Figure 4.3* ).
  prefs: []
  type: TYPE_NORMAL
- en: That’s why `numChars` can be a constant. For this component execution, it won’t
    be re-assigned. A new value might only be derived when the component function
    is executed again in the future (that is if `setUserInput` is called again). In
    that case, a brand-new `numChars` constant would be created (and the old one would
    be discarded).
  prefs: []
  type: TYPE_NORMAL
- en: Working with Forms and Form Submission
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: State is commonly used when working with forms and user input. Indeed, most
    examples in this chapter dealt with some form of user input.
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, all examples focused on listening to user events that are
    directly attached to individual input elements. That makes sense because you will
    often want to listen to events such as keystrokes or an input losing focus. Especially
    when adding input validation (that is, checking entered values), you might want
    to use input events to give website users useful feedback while they’re typing.
  prefs: []
  type: TYPE_NORMAL
- en: But it’s also quite common to react to the overall form submission. For example,
    the goal could be to combine the input from various input fields and send the
    data to some backend server. How could you achieve this? How can you listen and
    react to the submission of a form?
  prefs: []
  type: TYPE_NORMAL
- en: You can do all these things with the help of standard JavaScript events and
    the appropriate event handler props provided by React. Specifically, the `onSubmit`
    prop can be added to `<form>` elements to assign a function that should be executed
    once a form is submitted. To then handle the submission with React and JavaScript,
    you must ensure that the browser won’t do its default thing and generate (and
    send) an HTTP request automatically.
  prefs: []
  type: TYPE_NORMAL
- en: As in vanilla JavaScript, this can be achieved by calling the `preventDefault()`
    method on the automatically generated event object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a full example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet handles form submission via the `handleSignup()` function
    that’s assigned to the built-in `onSubmit` prop. User input is still fetched with
    the help of two state slices ( `email` and `agreed` ), which are updated upon
    the inputs’ change events.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code example, you might’ve noticed a new prop that wasn’t
    used before in this book: `htmlFor` . This is a special prop, built into React
    and the core JSX elements it provides. It can be added to `<label>` elements in
    order to set the `for` attribute for these elements. The reason it is called `htmlFor`
    instead of just `for` is that, as explained earlier in the book, JSX looks like
    HTML but isn’t HTML. It’s JavaScript under the hood. In JavaScript, `for` is a
    reserved keyword for `for` loops. To prevent problems, the prop is therefore named
    `htmlFor` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `onSubmit` (combined with `preventDefault()` ) for handling form submissions
    is a very common way of dealing with user input and forms in React. But when working
    on projects that use React 19 or higher, you can also use an alternative way for
    handling form submissions: you can use a React feature called **Form Actions**
    , which will be covered in great detail in *Chapter 9* , *Handling User Input
    & Forms with Form Actions* .'
  prefs: []
  type: TYPE_NORMAL
- en: Lifting State Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s a common scenario and problem: you have two components in your React
    app and a change or event in component A should change the state in component
    B. To make this less abstract, consider the following simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `Overview` component should output the entered search term.
    However, the search term is actually managed in another component—namely, the
    `SearchBar` component. In this simple example, the two components could of course
    be merged into one single component, and the problem would be solved. But it’s
    very likely that when building more realistic apps, you’ll face similar scenarios
    but with way more complex components. Breaking components up into smaller pieces
    is considered a good practice since it keeps the individual components manageable.
  prefs: []
  type: TYPE_NORMAL
- en: Having multiple components depend on some shared piece of state is therefore
    a scenario you will face frequently when working with React.
  prefs: []
  type: TYPE_NORMAL
- en: This problem can be solved by *lifting state up* . When lifting state up, the
    state is not managed in either of the two components that use it—neither in `Overview`
    , which reads the state, nor in `SearchBar` , which sets the state—but in a shared
    ancestor component instead. To be precise, it is managed in the **closest** shared
    ancestor component. Keep in mind that components are nested into each other and
    thus a “tree of components” (with the `App` component as the root component) is
    built up in the end.
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: An example component tree'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous simple code example, the `App` component is the closest (and,
    in this case, only) ancestor component of both `SearchBar` and `Overview` . If
    the app was structured as shown in the figure, with state set in one of the `Product`
    components and used in `Cart` , `Products` would be the closest ancestor component.
  prefs: []
  type: TYPE_NORMAL
- en: 'State is lifted by using props in the components that need to manipulate (that
    is, set) or read state, and by registering state in the ancestor component that
    is shared by the two other components. Here’s the updated example from previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The code didn’t actually change that much; it mostly moved around a bit. The
    state is now managed inside of the shared ancestor and `App` component, and the
    two other components get access to it via props.
  prefs: []
  type: TYPE_NORMAL
- en: 'Three key things are happening in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: The `SearchBar` component receives a prop called `onUpdateSearch` , whose value
    is a function—a function created in the `App` component and passed down to `SearchBar`
    from `App` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `onUpdateSearch` prop is then set as a value to the `onChange` prop on the
    `<input>` element inside of the `SearchBar` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `searchTerm` state (that is, its current value) is passed from `App` to
    `Overview` via a prop named `currentTerm` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first two points could be confusing. But keep in mind that, in JavaScript,
    functions are first-class objects and regular values. You can store functions
    in variables and, when using React, pass functions as values for props. Indeed,
    you could already see that in action at the very beginning of this chapter. When
    introducing events and event handling, functions were provided as values to all
    these `onXYZ` props ( `onChange` , `onBlur` , and so on).
  prefs: []
  type: TYPE_NORMAL
- en: In this code snippet, a function is passed as a value for a custom prop (that
    is, a prop expected in a component created by you, not built into React). The
    `onUpdateSearch` prop expects a function as a value because the prop is then itself
    being used as a value for the `onChange` prop on the `<input>` element.
  prefs: []
  type: TYPE_NORMAL
- en: The prop is named `onUpdateSearch` to make it clear that it expects a function
    as a value and that it will be connected to an event. Any name could’ve been chosen
    though; it doesn’t have to start with `on` . But it’s a common convention to name
    props that expect functions as values and that are intended to be connected to
    events like this.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, `updateSearch` is not a default event, but since the function will
    effectively be called upon the `change` event of the `<input>` element, the prop
    acts like a custom event.
  prefs: []
  type: TYPE_NORMAL
- en: With this structure, the state was lifted up to the `App` component. This component
    registers and manages the state. However, it also exposes the state-updating function
    (indirectly, in this case, as it is wrapped by the `handleUpdateSearchTerm` function)
    to the `SearchBar` component. It also provides the current state value ( `searchTerm`
    ) to the `Overview` component via the `currentTerm` prop.
  prefs: []
  type: TYPE_NORMAL
- en: Since the child and descendent components are also re-evaluated by React when
    state changes in a component, changes in the `App` component will also lead to
    the `SearchBar` and `Overview` components being re-evaluated. Therefore, the new
    prop value for `searchTerm` will be picked up, and the UI will be updated by React.
  prefs: []
  type: TYPE_NORMAL
- en: No new React features are needed for this. It’s only a combination of state
    and props. However, depending on how these features are connected and where they
    are used, both simple and more complex app patterns can be achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Summary and Key Takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Event handlers can be added to JSX elements via `on[EventName]` props (for example,
    `onClick` , `onChange` ).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any function can be executed upon (user) events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to force React to re-evaluate components and (possibly) update the
    rendered UI, state must be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State refers to data managed internally by React, and a state value can be defined
    via the `useState()` Hook.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React Hooks are JavaScript functions that add special features to React components
    (for example, the state feature, in this chapter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useState()` always returns an array with exactly two elements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **first element** is the current state value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **second element** is a function to set the state to a new value (the *state-updating
    function* ).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When setting the state to a new value that depends on the previous value, a
    function should be passed to the state-updating function. This function then receives
    the previous state as a parameter (which will be provided automatically by React)
    and returns the new state that should be set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any valid JavaScript value can be set as state—besides primitive values such
    as strings or numbers. This also includes reference values such as objects and
    arrays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If state needs to change because of some event that occurs in another component,
    you should *lift the state up* and manage it on a higher, shared level (that is,
    a common ancestor component).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s Next?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: State is an extremely important building block because it enables you to build
    truly dynamic applications. With this key concept out of the way, the next chapter
    will dive into utilizing state (and other concepts learned thus far) to render
    content conditionally and to render lists of content.
  prefs: []
  type: TYPE_NORMAL
- en: These are common tasks that are required in almost any UI or web app you’re
    building, no matter whether it’s about showing a warning overlay or displaying
    a list of products. The next chapter will help you add such features to your React
    apps.
  prefs: []
  type: TYPE_NORMAL
- en: Test Your Knowledge!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Test your knowledge about the concepts covered in this chapter by answering
    the following questions. You can then compare your answers to examples that can
    be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/04-state-events/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/04-state-events/exercises/questions-answers.md)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Which “problem” does state solve?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the difference between props and state?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is state registered in a component?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which values does the `useState()` Hook provide?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many state values can be registered for a single component?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does state affect other components (than the component in which it was registered)
    as well?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How should state be updated if the new state depends on the previous state?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can state be shared across multiple components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply What You Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the new knowledge gained in this chapter, you are finally able to build
    truly dynamic UIs and React applications. Instead of being limited to hardcoded,
    static content and pages, you can now use state to set and update values and force
    React to re-evaluate components and the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Here, you will find an activity that allows you to apply all the knowledge,
    including this new state knowledge, you have acquired up to this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 4.1: Building a Simple Calculator'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you’ll build a very basic calculator that allows users to
    add, subtract, multiply, and divide two numbers with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Build the UI by using React components. Be sure to build four separate components
    for the four math operations, even though lots of code could be reused.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Collect the user input and update the result whenever the user enters a value
    into one of the two related input fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that when working with numbers and getting those numbers from user input,
    you will need to ensure that the entered values are treated as numbers and not
    as strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final result and UI of the calculator should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_04_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Calculator UI'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Styling will, of course, differ. To get the same styling as shown in the screenshot,
    use my prepared starting project, which you can find here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/04-state-events/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/04-state-events/activities/practice-1-start)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the `index.css` file in that project to determine how to structure your
    JSX code to apply the styles.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll find the full example solution here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/04-state-events/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/04-state-events/activities/practice-1)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 4.2: Enhancing the Calculator'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you’ll build upon *Activity 4.1* to make the calculator built
    there slightly more complex. The goal is to reduce the number of components and
    build one single component in which users can select the mathematical operation
    via a drop-down element. In addition, the result should be output in a different
    component—that is, not in the component where the user input is gathered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove three of the four components from the previous activity and use one single
    component for all mathematical operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a drop-down element ( `<select>` element) to that remaining component (between
    the two inputs) and add the four math operations as options ( `<option>` elements)
    to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use state to gather both the numbers entered by the user and the math operation
    chosen via the drop-down (it’s up to you whether you prefer one single state object
    or multiple state slices).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Output the result in another component. (Hint: choose a good place for registering
    and managing the state.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The result and UI of the calculator should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_04_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: UI of the enhanced calculator'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll find the full example solution here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/04-state-events/activities/practice-2](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/04-state-events/activities/practice-2)
    .'
  prefs: []
  type: TYPE_NORMAL
