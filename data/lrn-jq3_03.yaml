- en: Handling Events
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理事件
- en: JavaScript has several built-in ways of reacting to user interaction and other
    events. To make a page dynamic and responsive, we need to harness this capability
    so that we can, at the appropriate times, use the jQuery techniques you learned
    so far and the other tricks you'll learn later. While we could do this with vanilla
    JavaScript, jQuery enhances and extends the basic event-handling mechanisms to
    give them a more elegant syntax while making them more powerful at the same time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 有几种内置的方式来响应用户交互和其他事件。为了使页面动态和响应灵活，我们需要利用这种能力，以便在适当的时候使用你迄今为止学到的 jQuery
    技巧和你以后将学到的其他技巧。虽然我们可以用原生 JavaScript 来做到这一点，但 jQuery 增强和扩展了基本的事件处理机制，使其具有更优雅的语法，同时使其更加强大。
- en: 'In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Executing JavaScript code when the page is ready
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当页面准备就绪时执行 JavaScript 代码
- en: Handling user events, such as mouse clicks and keystrokes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理用户事件，如鼠标点击和按键
- en: The flow of events through the document, and how to manipulate that flow
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件通过文档的流动，以及如何操纵该流动
- en: Simulating events as if the user initiated them
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟事件，就像用户发起了它们一样
- en: Performing tasks on page load
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在页面加载时执行任务
- en: We have already seen how to make jQuery react to the loading of a web page.
    The `$(() => {})` event handler can be used to run code that depends on HTML elements,
    but there's a bit more to be said about it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使 jQuery 响应网页加载。 `$(() => {})` 事件处理程序可用于运行依赖于 HTML 元素的代码，但还有一些其他内容需要讨论。
- en: Timing of code execution
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码执行的时间
- en: In [Chapter 1](33c0dcc2-d368-4c19-b3aa-15fd462917f8.xhtml), *Getting Started*,
    we noted that `$(() => {})` was jQuery's primary way to perform tasks on page
    load. It is not, however, the only method at our disposal. The native `window.onload`
    event can do the same thing. While the two methods are similar, it is important
    to recognize their difference in timing, even though it can be quite subtle depending
    on the number of resources being loaded.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 1 章](33c0dcc2-d368-4c19-b3aa-15fd462917f8.xhtml)中，*入门*，我们注意到 `$(() => {})`
    是 jQuery 在页面加载时执行任务的主要方式。然而，这并不是我们唯一的选择。本地的 `window.onload` 事件也可以做同样的事情。虽然这两种方法相似，但重要的是要认识到它们在时间上的差异，尤其是依赖于加载的资源数量的情况下，这可能是相当微妙的。
- en: The `window.onload` event fires when a document is completely downloaded to
    the browser. This means that every element on the page is ready to be manipulated
    by JavaScript, which is a boon for writing feature-rich code without worrying
    about load order.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当文档完全下载到浏览器时，`window.onload` 事件将触发。这意味着页面上的每个元素都可以被 JavaScript 操纵，这对于编写功能丰富的代码而不用担心加载顺序是一个福音。
- en: On the other hand, a handler registered using `$(() => {})` is invoked when
    the DOM is completely ready for use. This also means that all elements are accessible
    by our scripts, but does not mean that every associated file has been downloaded.
    As soon as the HTML file has been downloaded and parsed into a DOM tree, the code
    can run.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用 `$(() => {})` 注册的处理程序在 DOM 完全准备就绪时被调用。这也意味着所有元素都可以被我们的脚本访问，但并不意味着每个相关文件都已经被下载。一旦
    HTML 文件被下载并解析成 DOM 树，代码就可以运行。
- en: Style loading and code execution
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 样式加载和代码执行
- en: To ensure that the page has also been styled before the JavaScript code executes,
    it is good practice to place the `<link rel="stylesheet">` and `<style>` tags
    prior to any `<script>` tags within the document's `<head>` element.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保页面在 JavaScript 代码执行之前也已经被样式化，将 `<link rel="stylesheet">` 和 `<style>` 标签放在文档的
    `<head>` 元素内的任何 `<script>` 标签之前是一种良好的做法。
- en: Consider, for example, a page that presents an image gallery; such a page may
    have many large images on it, which we can hide, show, move, and otherwise manipulate
    with jQuery. If we set up our interface using the `onload` event, users will have
    to wait until each and every image is completely downloaded before they can use
    those features. Even worse, if behaviors are not yet attached to elements that
    have default behaviors (such as links), user interactions could produce unintended
    outcomes. However, when we use `$(() => {})` for the setup, the interface is ready
    to be used earlier with the correct behavior.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个展示图库的页面；这样的页面上可能有许多大图，我们可以用 jQuery 隐藏、显示、移动和其他方式来操纵它们。如果我们使用 `onload`
    事件来设置我们的接口，用户将不得不等待每个图像完全下载后才能使用这些功能。更糟糕的是，如果行为尚未附加到具有默认行为的元素（如链接）上，用户交互可能会产生意想不到的结果。然而，当我们使用
    `$(() => {})` 进行设置时，界面更早地准备好使用，并具有正确的行为。
- en: What is loaded and what is not?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 什么被加载了，什么没有被加载？
- en: Using `$(() => {})` is almost always preferred over using an `onload` handler,
    but we need to keep in mind that, because supporting files may not have loaded,
    attributes such as image height and width are not necessarily available at this
    time. If these are needed, we may at times also choose to implement an `onload`
    handler; the two mechanisms can coexist peacefully.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`$(() => {})`几乎总是优于使用`onload`处理程序，但我们需要记住，因为支持文件可能尚未加载，因此此时可能不一定可用图像高度和宽度等属性。如果需要这些属性，有时我们也可以选择实现`onload`处理程序；这两种机制可以和平共处。
- en: Handling multiple scripts on one page
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理一个页面上的多个脚本
- en: 'The traditional mechanism for registering event handlers through JavaScript
    (rather than adding handler attributes right in the HTML content) is to assign
    a function to the DOM element''s corresponding property. For example, suppose
    we had defined the following function:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过JavaScript注册事件处理程序的传统机制（而不是直接在HTML内容中添加处理程序属性）是将函数分配给DOM元素的相应属性。例如，假设我们已定义了以下函数：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We could then either assign it within our HTML markup:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在HTML标记中分配它：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or, we could assign it from within JavaScript code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以从JavaScript代码中分配它：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Both of these approaches will cause the function to execute when the page is
    loaded. The advantage of the second is that the behavior is cleanly separated
    from the markup.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都会在页面加载时执行函数。第二种的优点是行为与标记清晰地分开。
- en: Referencing versus calling functions
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 引用与调用函数
- en: When we assign a function as a handler, we use the function name but omit the
    trailing parentheses. With the parentheses, the function is called immediately;
    without the parantheses, the name simply identifies, or *references*, the function,
    and can be used to call it later.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将函数分配为处理程序时，我们使用函数名但省略尾括号。带括号时，函数会立即调用；不带括号时，名称仅标识或*引用*函数，并且可以在以后调用它。
- en: 'With one function, this strategy works quite well. However, suppose we have
    a second function as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个函数，这种策略运行得相当不错。然而，假设我们有一个第二个函数如下：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We could then attempt to assign this function to run on page load:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以尝试将此函数分配为在页面加载时运行：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, this assignment trumps the first one. The `.onload` attribute can only
    store one function reference at a time, so we can't add to the existing behavior.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这个赋值会覆盖第一个。`.onload`属性一次只能存储一个函数引用，所以我们不能添加到现有的行为。
- en: The `$(() => {})` mechanism handles this situation gracefully. Each call adds
    the new function to an internal queue of behaviors; when the page is loaded, all
    of the functions will execute. The functions will run in the order in which they
    were registered.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(() => {})`机制优雅地处理了这种情况。每次调用都会将新函数添加到内部行为队列中；当页面加载时，所有函数都将执行。函数将按照注册的顺序运行。'
- en: To be fair, jQuery doesn't have a monopoly on workarounds to this issue. We
    can write a JavaScript function that calls the existing `onload` handler, then
    calls a passed-in handler. This approach avoids conflicts between rival handlers
    like `$(() => {})` does, but lacks some of the other benefits we have discussed.
    In modern browsers, the `DOMContentLoaded` event can be triggered with the W3C
    standard `document.addEventListener()` method. However, the `$(() => {})` is more
    concise and elegant.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，jQuery并不是唯一解决此问题的方法。我们可以编写一个JavaScript函数，调用现有的`onload`处理程序，然后调用传入的处理程序。这种方法避免了像`$(()
    => {})`这样的竞争处理程序之间的冲突，但缺少了我们讨论过的其他一些优点。在现代浏览器中，可以使用W3C标准的`document.addEventListener()`方法触发`DOMContentLoaded`事件。但是，`$(()
    => {})`更简洁而优雅。
- en: Passing an argument to the document ready callback
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将参数传递给文档准备好的回调
- en: In some cases, it may prove useful to use more than one JavaScript library on
    the same page. Since many libraries make use of the `$` identifier (since it is
    short and convenient), we need a way to prevent collisions between libraries.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，同时在同一页面上使用多个JavaScript库可能会被证明是有用的。由于许多库使用`$`标识符（因为它简短而方便），我们需要一种方法来防止库之间的冲突。
- en: 'Fortunately, jQuery provides a method called `jQuery.noConflict()` to return
    control of the `$` identifier back to other libraries. Typical usage of `jQuery.noConflict()`
    follows the following pattern:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，jQuery提供了一个名为`jQuery.noConflict()`的方法，将`$`标识符的控制权返回给其他库。`jQuery.noConflict()`的典型用法如下所示：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, the other library (`prototype.js` in this example) is included. Then,
    `jquery.js` itself is included, taking over `$` for its own use. Next, a call
    to `.noConflict()` frees up `$`, so that control of it reverts to the first included
    library (`prototype.js`). Now in our custom script, we can use both libraries,
    but whenever we want to use a jQuery method, we need to write `jQuery` instead
    of `$` as an identifier.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，包括其他库（本例中的`prototype.js`）。然后，`jquery.js`自身被包括，接管`$`以供自己使用。接下来，调用`.noConflict()`释放`$`，以便将其控制权恢复到第一个包括的库（`prototype.js`）。现在在我们的自定义脚本中，我们可以同时使用这两个库，但每当我们想使用jQuery方法时，我们需要将标识符写为`jQuery`而不是`$`。
- en: 'The `$(() => {})` document ready handler has one more trick up its sleeve to
    help us in this situation. The callback function we pass to it can take a single
    parameter--the `jQuery` object itself. This allows us to effectively rename it
    without fear of conflicts using the following syntax:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(() => {})` 文档准备就绪处理程序在这种情况下还有一个技巧可以帮助我们。我们传递给它的回调函数可以接受一个参数--`jQuery`对象本身。这使我们可以有效地重新命名它，而不必担心冲突，使用以下语法：'
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Handling simple events
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理简单事件
- en: There are other times, apart from the loading of the page, at which we might
    want to perform a task. Just as JavaScript allows us to intercept the page load
    event with `<body onload="">` or `window.onload`, it provides similar hooks for
    user-initiated events such as mouse clicks (`onclick`), form fields being modified
    (`onchange`), and windows changing size (`onresize`). When assigned directly to
    elements in the DOM, these hooks have similar drawbacks to the ones we outlined
    for `onload`. Therefore, jQuery offers an improved way of handling these events
    as well.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了页面加载之外，还有其他时间点，我们可能希望执行某些任务。就像JavaScript允许我们拦截页面加载事件一样，使用`<body onload="">`或`window.onload`，它为用户触发的事件提供了类似的挂钩，如鼠标点击（`onclick`）、表单字段被修改（`onchange`）和窗口尺寸变化（`onresize`）。当直接分配给DOM中的元素时，这些挂钩也具有类似于我们为`onload`概述的缺点。因此，jQuery也提供了处理这些事件的改进方式。
- en: A simple style switcher
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的样式切换器
- en: To illustrate some event handling techniques, suppose we wish to have a single
    page rendered in several different styles based on user input; we will present
    buttons that allow the user to toggle between a normal view, a view in which the
    text is constrained to a narrow column, and a view with large print for the content
    area.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明一些事件处理技术，假设我们希望根据用户输入以多种不同的样式呈现单个页面；我们将提供按钮，允许用户在正常视图、文本受限于窄列的视图和内容区域为大字体的视图之间切换。
- en: Progressive enhancement
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步增强
- en: In a real-world example, a good web citizen will employ the principle of progressive
    enhancement here. In [Chapter 5](fa35636a-37d4-49b9-ba72-aa6596bab015.xhtml),
    *Manipulating the DOM*, you will learn how we can inject content like this style
    switcher right from our jQuery code, so that users without JavaScript available
    will not see nonfunctional controls.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个真实的例子中，一个良好的网络公民将在这里应用逐步增强原则。在[第5章](fa35636a-37d4-49b9-ba72-aa6596bab015.xhtml)，*操作DOM*中，您将学到如何可以从我们的jQuery代码直接注入类似于这种样式切换器的内容，以便没有可用JavaScript的用户不会看到无效的控件。
- en: 'The HTML markup for the style switcher is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 样式切换器的HTML标记如下：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Getting the example code
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 获取示例代码
- en: You can access the example code from the following GitHub repository: [https://github.com/PacktPublishing/Learning-jQuery-3](https://github.com/PacktPublishing/Learning-jQuery-3).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问下面的GitHub存储库中的示例代码：[https://github.com/PacktPublishing/Learning-jQuery-3](https://github.com/PacktPublishing/Learning-jQuery-3)。
- en: 'Combined with the rest of the page''s HTML markup and some basic CSS, we get
    a page that looks like the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 结合页面的其余HTML标记和一些基本的CSS，我们得到了一个看起来像以下的页面：
- en: '![](img/5297_03_01.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_03_01.png)'
- en: 'To begin with, we''ll make the Large Print button operate. We need a bit of
    CSS to implement our alternative view of the page as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将让大字体按钮起作用。我们需要一些CSS来实现我们页面的另一种视图，如下所示：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our goal, then, is to apply the `large` class to the `<body>` tag. This will
    allow the stylesheet to reformat the page appropriately. Using what you learned
    in [Chapter 2](195342ed-f533-42e7-8a8d-f9a3462382b7.xhtml), *Selecting Elements*,
    we already know the statement needed to accomplish this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的目标是将`large`类应用于`<body>`标签。这将允许样式表适当地重新格式化页面。根据您在[第2章](195342ed-f533-42e7-8a8d-f9a3462382b7.xhtml)学到的，*选择元素*，我们已经知道完成这个任务所需的语句：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'However, we want this to occur when the button is clicked, not when the page
    is loaded as we have seen so far. To do this, we''ll introduce the `.on()` method.
    This method allows us to specify any DOM event and to attach a behavior to it.
    In this case, the event is called `click`, and the behavior is a function consisting
    of our previous one liner:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们希望这发生在按钮被点击时，而不是在页面加载时，就像我们迄今所见的那样。为此，我们将介绍`.on()`方法。该方法允许我们指定任何DOM事件并附加行为。在这种情况下，事件被称为`click`，而行为是由我们之前的一行函数组成：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Listing 3.1
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.1
- en: 'Now when the button gets clicked on, our code runs and the text is enlarged:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当按钮被点击时，我们的代码运行，文字被放大：
- en: '![](img/5297_03_02.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_03_02.png)'
- en: That's all there is to binding a behavior to an event. The advantages we discussed
    with the `$(() => {})` document ready handler apply here as well. Multiple calls
    to `.on()` coexist nicely, appending additional behaviors to the same event as
    necessary.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是将行为绑定到事件的全部内容。我们讨论的`$(() => {})`文档就绪处理程序的优势在这里同样适用。多次调用`.on()`可以很好地共存，根据需要向同一事件附加附加行为。
- en: This isn't necessarily the most elegant or efficient way to accomplish this
    task. As we proceed through this chapter, we will extend and refine this code
    into something we can be proud of.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不一定是实现此任务的最优雅或高效方式。随着我们继续学习本章，我们将扩展和完善这段代码，使之成为我们可以自豪的东西。
- en: Enabling the other buttons
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用其他按钮
- en: 'We now have a Large Print button that works as advertised, but we need to apply
    similar handling to the other two buttons (Default and Narrow Column) to make
    them perform their tasks. This is straightforward: we use `.on()` to add a `click`
    handler to each of them, removing and adding classes as necessary. The new code
    reads as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了有效运行的大字按钮，但我们需要对其他两个按钮（默认和窄栏）应用类似的处理以使它们执行其任务。这很简单：我们使用`.on()`为每个按钮添加一个`click`处理程序，根据需要删除和添加类。新代码如下所示：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Listing 3.2
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.2
- en: 'This is combined with a CSS rule for the `narrow` class:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`narrow`类的CSS规则相结合：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, after clicking the Narrow Column button, its corresponding CSS is applied
    and the text gets laid out differently:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在点击"窄栏"按钮后，其相应的CSS被应用，文本布局不同了：
- en: '![](img/5297_03_03.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_03_03.png)'
- en: Clicking on Default removes both class names from the `<body>` tag, returning
    the page to its initial rendering.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 点击"Default"按钮会从`<body>`标签中移除两个类名，使页面恢复到最初的渲染状态。
- en: Making use of event handler context
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用事件处理程序上下文
- en: 'Our switcher is behaving correctly, but we are not giving the user any feedback
    about which button is currently active. Our approach for handling this will be
    to apply the `selected` class to the button when it is clicked, and to remove
    this class from the other buttons. The `selected` class simply makes the button''s
    text bold:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的切换器行为正确，但我们没有向用户提供有关当前活动按钮的任何反馈。我们处理的方法是在点击时将`selected`类应用到按钮上，并从其他按钮上删除这个类。`selected`类只是使按钮的文字加粗：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We could accomplish this class modification as we did previously by referring
    to each button by ID and applying or removing classes as necessary, but, instead,
    we'll explore a more elegant and scalable solution that exploits the context in
    which event handlers run.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像之前一样通过引用每个按钮的ID并根据需要应用或移除类来实现此类修改，而是，我们将探讨一种更加优雅和可扩展的解决方案，利用事件处理程序运行的上下文。
- en: When any event handler is triggered, the keyword `this` refers to the DOM element
    to which the behavior was attached. Earlier we noted that the `$()` function could
    take a DOM element as its argument; this is one of the key reasons why that facility
    is available. By writing `$(this)` within the event handler, we create a jQuery
    object corresponding to the element, and we can act on it just as if we had located
    it with a CSS selector.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何事件处理程序被触发时，关键字`this`指代的是附加行为的DOM元素。早些时候我们注意到`$()`函数可以将DOM元素作为参数；这是为何该功能可用的关键原因之一。在事件处理程序中写入`$(this)`，我们创建了一个对应于该元素的jQuery对象，我们可以像使用CSS选择器定位一样对其进行操作。
- en: 'With this in mind, we can write the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个思路，我们可以写出以下内容：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Placing this line in each of the three handlers will add the class when a button
    is clicked. To remove the class from the other buttons, we can take advantage
    of jQuery''s implicit iteration feature, and write:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个处理程序中放置这行代码会在按钮被点击时添加类。要从其他按钮中移除类，我们可以利用jQuery的隐式迭代功能，并写入：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This line removes the class from every button inside the style switcher.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此行从样式切换器中的每个按钮中移除类。
- en: 'We should also add the class to the Default button when the document is ready.
    So, placing these in the correct order, the code is as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当文档准备就绪时，我们还应该向默认按钮添加类。因此，将这些放置在正确的顺序中，代码如下所示：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Listing 3.3
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.3
- en: Now the style switcher gives appropriate feedback.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在样式切换器提供了适当的反馈。
- en: 'Generalizing the statements by using the handler context allows us to be yet
    more efficient. We can factor the highlighting routine out into a separate handler,
    as shown in *Listing 3.4*, because it is the same for all three buttons:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用处理程序上下文概括语句，我们可以更加高效。我们可以将突出显示的例程提取到单独的处理程序中，如*列表3.4*所示，因为它对所有三个按钮都是相同的：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Listing 3.4
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.4
- en: This optimization takes advantage of three jQuery features we have already discussed.
    First, **implicit iteration** is once again useful when we bind the same `click`
    handler to each button with a single call to `.on()`. Second, **behavior queuing**
    allows us to bind two functions to the same click event without the second overwriting
    the first.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种优化利用了我们已经讨论过的三个jQuery功能。首先，当我们使用单个调用`.on()`将相同的`click`处理程序绑定到每个按钮时，**隐式迭代**再次非常有用。其次，**行为排队**允许我们将两个函数绑定到同一个点击事件，而不会第二个覆盖第一个。
- en: When an event handler function references its context using `this`, you can't
    use an arrow function (`() => {}`). These functions have a **lexical context**.
    This means that when jQuery attempts to set the context as the element that triggered
    the event, it doesn't work.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件处理程序函数使用`this`引用其上下文时，你不能使用箭头函数（`() => {}`）。这些函数具有**词法上下文**。这意味着当jQuery尝试将上下文设置为触发事件的元素时，它不起作用。
- en: Consolidating code using event context
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用事件上下文合并代码
- en: 'The code optimization we''ve just completed is an example of **refactoring**--modifying
    existing code to perform the same task in a more efficient or elegant way. To
    explore further refactoring opportunities, let''s look at the behaviors we have
    bound to each button. The `.removeClass()` method''s parameter is optional; when
    omitted, it removes all classes from the element. We can streamline our code a
    bit by exploiting this as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚完成的代码优化是**重构**的一个例子--修改现有代码以以更高效或更优雅的方式执行相同的任务。为了进一步探索重构机会，让我们看一下我们已经绑定到每个按钮的行为。`.removeClass()`方法的参数是可选的；当省略时，它会从元素中删除所有类。我们可以利用这一点稍微简化我们的代码，如下所示：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Listing 3.5
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.5
- en: Note that the order of operations has changed a bit to accommodate our more
    general class removal; we need to execute `.removeClass()` first so that it doesn't
    undo the call to `.addClass()`, which we perform in the same breath.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，操作顺序有些变化，以适应我们更一般的类移除；我们需要先执行`.removeClass()`，以免它撤消对`.addClass()`的调用，我们同时执行这个调用。
- en: We can only safely remove all classes because we are in charge of the HTML in
    this case. When we are writing code for reuse (such as for a plugin), we need
    to respect any classes that might be present and leave them intact.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能安全地删除所有类，因为在这种情况下我们负责HTML。当我们编写可重用的代码（例如用于插件）时，我们需要尊重可能存在的任何类，并保持其不变。
- en: 'Now we are executing some of the same code in each of the button''s handlers.
    This can be easily factored out into our general button `click` handler:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在每个按钮的处理程序中执行一些相同的代码。这可以很容易地提取出来到我们的通用按钮`click`处理程序中：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Listing 3.6
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6
- en: Note that we need to move the general handler above the specific ones now. The
    `.removeClass()` call needs to happen before `.addClass()` executes, and we can
    count on this because jQuery always triggers event handlers in the order in which
    they were registered.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，现在我们需要将通用处理程序移到特定处理程序之前。`.removeClass()`调用需要在`.addClass()`执行之前发生，我们可以依赖于此，因为jQuery总是按照注册顺序触发事件处理程序。
- en: 'Finally, we can get rid of the specific handlers entirely by, once again, exploiting
    **event context**. Since the context keyword `this` gives us a DOM element rather
    than a jQuery object, we can use native DOM properties to determine the ID of
    the element that was clicked. We can thus bind the same handler to all the buttons,
    and within the handler perform different actions for each button:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以完全摆脱特定的处理程序，再次利用**事件上下文**。由于上下文关键字`this`给了我们一个DOM元素而不是jQuery对象，我们可以使用原生DOM属性来确定被点击的元素的ID。因此，我们可以将相同的处理程序绑定到所有按钮上，并在处理程序内为每个按钮执行不同的操作：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Listing 3.7
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.7
- en: The value of the `bodyClass` variable will be `default`, `narrow`, or `large`,
    depending on which button is clicked. Here, we are departing somewhat from our
    previous code; in that we are adding a `default` class to `<body>` when the user
    clicks on `<button id="switcher-default">`. While we do not need this class applied,
    it isn't causing any harm either, and the reduction of code complexity more than
    makes up for an unused class name.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`bodyClass`变量的值将是`default`、`narrow`或`large`，具体取决于点击了哪个按钮。在这里，我们有些偏离了以前的代码；当用户单击`<button
    id="switcher-default">`时，我们为`<body>`添加了一个`default`类。虽然我们不需要应用这个类，但它也没有造成任何损害，代码复杂性的减少完全弥补了一个未使用的类名。'
- en: Shorthand events
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快捷事件
- en: Binding a handler for an event (such as a simple `click` event) is such a common
    task that jQuery provides an even terser way to accomplish it; shorthand event
    methods work in the same way as their `.on()` counterparts with fewer keystrokes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定事件处理程序（如简单的`click`事件）是一项非常常见的任务，jQuery提供了一个更简洁的方法来完成它；快捷事件方法与它们的`.on()`对应方法以更少的击键方式工作。
- en: 'For example, our style switcher could be written using `.click()` instead of
    `.on()` as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的样式切换器可以使用`.click()`而不是`.on()`来编写，如下所示：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Listing 3.8
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.8
- en: Shorthand event methods such as the previous one exist for the other standard
    DOM events such as `blur`, `keydown`, and `scroll` as well. Each shortcut method
    binds a handler to the event with the corresponding name.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 其他标准DOM事件（如`blur`、`keydown`和`scroll`）也存在类似的快捷事件方法。每个快捷方法都会使用相应的名称将处理程序绑定到事件上。
- en: Showing and hiding page elements
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示和隐藏页面元素
- en: 'Suppose that we wanted to be able to hide our style switcher when it is not
    needed. One convenient way to hide page elements is to make them collapsible.
    We will allow one click on the label to hide the buttons, leaving the label alone.
    Another click on the label will restore the buttons. We need another class that
    will hide buttons:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望在不需要时能够隐藏我们的样式切换器。隐藏页面元素的一种方便方法是使它们可折叠。我们将允许单击标签一次来隐藏按钮，只留下标签。再次单击标签将恢复按钮。我们需要另一个类来隐藏按钮：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We could implement this feature by storing the current state of the buttons
    in a variable and checking its value each time the label is clicked to know whether
    to add or remove the hidden class on the buttons. However, jQuery provides an
    easy way for us to add or remove a class depending on whether that class is already
    present--the `.toggleClass()` method:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将按钮的当前状态存储在变量中，并在每次单击标签时检查其值，以了解是否应在按钮上添加或删除隐藏类来实现此功能。然而，jQuery为我们提供了一种简单的方法，根据该类是否已经存在来添加或删除一个类——`.toggleClass()`方法：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Listing 3.9
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.9
- en: 'After the first click, the buttons are all hidden:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次点击后，所有按钮都被隐藏了：
- en: '![](img/5297_03_04.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_03_04.png)'
- en: 'A second click then returns them to visibility:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次点击然后将它们恢复到可见状态：
- en: '![](img/5297_03_05.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_03_05.png)'
- en: Once again, we rely on implicit iteration, this time to hide all the buttons
    - siblings of the `<h3>` - in one fell swoop.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们依赖隐式迭代，这次是为了一举隐藏所有按钮——`<h3>`的兄弟节点。
- en: Event propagation
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件传播
- en: 'In illustrating the ability of the `click` event to operate on normally non-clickable
    page elements, we have crafted an interface that doesn''t indicate that the style
    switcher label--just an `<h3>` element-is actually a *live* part of the page awaiting
    user interaction. To remedy this, we can give it a rollover state, making it clear
    that it interacts in some way with the mouse:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明`click`事件能够作用于通常不可点击的页面元素的能力，我们制作了一个界面，没有显示出样式切换器标签——只是一个`<h3>`元素——实际上是页面中等待用户交互的*活动*部分。为了纠正这一点，我们可以给它一个鼠标悬停状态，清楚地表明它以某种方式与鼠标交互：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The CSS specification includes a pseudo-class called `:hover`, which allows
    a stylesheet to affect an element's appearance when the user's mouse cursor hovers
    over it. This would certainly solve our problem in this instance, but instead,
    we will take this opportunity to introduce jQuery's `.hover()` method, which allows
    us to use JavaScript to change an element's styling--and indeed, perform any arbitrary
    action--both when the mouse cursor enters the element and when it leaves the element.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: CSS规范包括一个名为`:hover`的伪类，允许样式表在用户鼠标悬停在元素上时影响其外观。这在这种情况下肯定可以解决我们的问题，但是我们将利用这个机会介绍jQuery的`.hover()`方法，它允许我们使用JavaScript来改变元素的样式——事实上，执行任意操作——当鼠标光标进入元素时和离开元素时。
- en: 'The `.hover()` method takes two function arguments, unlike the simple event
    methods we have so far encountered. The first function will be executed when the
    mouse cursor enters the selected element, and the second is fired when the cursor
    leaves. We can modify the classes applied to the buttons at these times to achieve
    a rollover effect:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`.hover()`方法接受两个函数参数，与我们迄今为止遇到的简单事件方法不同。第一个函数将在鼠标光标进入所选元素时执行，第二个函数将在鼠标离开时执行。我们可以修改这些时间应用的类来实现鼠标悬停效果：'
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Listing 3.10
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.10
- en: 'We once again use implicit iteration and event context for short and simple
    code. Now when hovering over the `<h3>` element, we see our class applied:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用隐式迭代和事件上下文来编写简短简单的代码。现在当鼠标悬停在`<h3>`元素上时，我们看到我们的类被应用了：
- en: '![](img/5297_03_06.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_03_06.png)'
- en: The use of `.hover()` also means we avoid headaches caused by event propagation
    in JavaScript. To understand this, we need to take a look at how JavaScript decides
    which element gets to handle a given event.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.hover()`还意味着我们避免了JavaScript中事件传播引起的头痛。要理解这一点，我们需要看一下JavaScript如何决定哪个元素可以处理给定事件。
- en: The journey of an event
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件的旅程
- en: 'When an event occurs on a page, an entire hierarchy of DOM elements gets a
    chance to handle the event. Consider a page model like the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面上发生事件时，整个DOM元素层次结构都有机会处理事件。考虑以下页面模型：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We then visualize the code as a set of nested elements:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将代码可视化为一组嵌套元素：
- en: '![](img/5297_03_07.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_03_07.png)'
- en: For any event, there are multiple elements that could logically be responsible
    for reacting. When the link on this page is clicked, for example, the `<div>`,
    `<span>`, and `<a>` elements should all get the opportunity to respond to the
    click. After all, these three elements are all under the user's mouse cursor at
    the time. The `<p>` element, on the other hand, is not part of this interaction
    at all.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何事件，逻辑上都可能负责响应的多个元素。例如，当单击此页面上的链接时，`<div>`、`<span>`和`<a>`元素都应该有机会响应单击事件。毕竟，这三个元素都在用户鼠标指针下。另一方面，`<p>`元素根本不参与这个交互。
- en: 'One strategy for allowing multiple elements to respond to a user interaction
    is called **event capturing**. With event capturing, the event is first given
    to the most all-encompassing element, and then to progressively more specific
    ones. In our example, this means that first the `<div>` element gets passed the
    event, then the `<span>` element, and finally the `<a>` element, as shown in the
    following figure:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一种允许多个元素响应用户交互的策略称为**事件捕获**。使用事件捕获，事件首先传递给最全面的元素，然后逐渐传递给更具体的元素。在我们的示例中，这意味着首先传递事件给`<div>`元素，然后是`<span>`元素，最后是`<a>`元素，如下图所示：
- en: '![](img/5297_03_08.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_03_08.png)'
- en: 'The opposite strategy is called **event** **bubbling**. The event gets sent
    to the most specific element, and after this element has an opportunity to react,
    the event **bubbles up** to more general elements. In our example, the `<a>` element
    would be handed the event first, and then the `<span>` and `<div>` elements in
    that order, as shown in the following figure:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 相反的策略称为**事件冒泡**。事件被发送到最具体的元素，然后在此元素有机会响应后，事件向更一般的元素**冒泡**。在我们的示例中，`<a>`元素将首先处理事件，然后按顺序是`<span>`和`<div>`元素，如下图所示：
- en: '![](img/5297_03_09.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_03_09.png)'
- en: 'Unsurprisingly, different browser developers originally decided on different
    models for event propagation. The DOM standard that was eventually developed thus
    specified that both strategies should be used: first the event is captured from
    general elements to specific ones, and then the event bubbles back up to the top
    of the DOM tree. Event handlers can be registered for either part of the process.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，不同的浏览器开发者最初决定了不同的事件传播模型。最终开发的DOM标准规定应该同时使用这两种策略：首先从一般元素捕获事件到特定元素，然后事件冒泡回DOM树的顶部。可以为此过程的任一部分注册事件处理程序。
- en: To provide consistent and easy-to-understand behavior, jQuery always registers
    event handlers for the bubbling phase of the model. We can always assume that
    the most specific element will get the first opportunity to respond to any event.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一致且易于理解的行为，jQuery始终为模型的冒泡阶段注册事件处理程序。我们始终可以假设最具体的元素将首先有机会响应任何事件。
- en: Side effects of event bubbling
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件冒泡的副作用
- en: Event bubbling can cause unexpected behavior, especially when the wrong element
    responds to a `mouseover` or `mouseout` event. Consider a `mouseout` event handler
    attached to the `<div>` element in our example. When the user's mouse cursor exits
    the `<div>` element, the `mouseout` handler is run as anticipated. Since this
    is at the top of the hierarchy, no other elements get the event. On the other
    hand, when the cursor exits the `<a>` element, a `mouseout` event is sent to that.
    This event will then bubble up to the `<span>` element and then to the `<div>`
    element, firing the same event handler. This bubbling sequence is unlikely to
    be desired.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 事件冒泡可能会导致意外行为，特别是当错误的元素响应`mouseover`或`mouseout`事件时。考虑一个附加到我们示例中的`<div>`元素的`mouseout`事件处理程序。当用户的鼠标光标退出`<div>`元素时，`mouseout`处理程序按预期运行。由于这是在层次结构的顶部，没有其他元素获得事件。另一方面，当光标退出`<a>`元素时，`mouseout`事件被发送到该元素。然后，此事件将冒泡到`<span>`元素，然后到`<div>`元素，触发相同的事件处理程序。这种冒泡序列可能不是期望的。
- en: The `mouseenter` and `mouseleave` events, either bound individually or combined
    in the `.hover()` method, are aware of these bubbling issues and, when we use
    them to attach events, we can ignore the problems caused by the wrong element
    getting a `mouseover` or `mouseout` event.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`mouseenter`和`mouseleave`事件，无论是单独绑定还是结合在`.hover()`方法中，都意识到了这些冒泡问题，当我们使用它们来附加事件时，我们可以忽略由于错误的元素获取`mouseover`或`mouseout`事件而引起的问题。'
- en: The `mouseout` scenario just described illustrates the need to constrain the
    scope of an event. While `.hover()` handles this specific case, we will encounter
    other situations in which we need to limit an event spatially (preventing the
    event from being sent to certain elements) or temporally (preventing the event
    from being sent at certain times).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚描述的`mouseout`场景说明了限制事件范围的必要性。虽然`.hover()`处理了这种特殊情况，但我们将遇到其他需要在空间上（防止将事件发送到某些元素）或在时间上（在某些时间阻止事件发送）限制事件的情况。
- en: Altering the journey - the event object
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变旅程 - 事件对象
- en: We have already seen one situation in which event bubbling can cause problems.
    To show a case in which `.hover()` does not help our cause, we'll alter the collapsing
    behavior that we implemented earlier.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一种情况，其中事件冒泡可能会引起问题。为了展示一种情况，`.hover()`不能帮助我们的情况，我们将更改我们之前实现的折叠行为。
- en: 'Suppose we wish to expand the clickable area that triggers the collapsing or
    expanding of the style switcher. One way to do this is to move the event handler
    from the label, `<h3>`, to its containing `<div>` element. In *Listing 3.9*, we
    added a `click` handler to `#switcher h3`; we will attempt this change by attaching
    the handler to `#switcher` instead:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望扩大点击区域，触发样式切换器的折叠或展开。一种方法是将事件处理程序从标签`<h3>`移动到其包含的`<div>`元素中。在*列表3.9*中，我们向`#switcher
    h3`添加了一个`click`处理程序；我们将尝试通过将处理程序附加到`#switcher`而不是附加到`#switcher`来进行此更改：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Listing 3.11
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.11
- en: This alteration makes the entire area of the style switcher clickable to toggle
    its visibility. The downside is that clicking on a button also collapses the style
    switcher after the style on the content has been altered. This is due to event
    bubbling; the event is first handled by the buttons, then passed up through the
    DOM tree until it reaches the `<div id="switcher">` element, where our new handler
    is activated and hides the buttons.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种改变使得整个样式切换器区域都可点击以切换其可见性。缺点是点击按钮后，样式切换器也会折叠，这是因为事件冒泡；事件首先由按钮处理，然后通过DOM树传递，直到达到`<div
    id="switcher">`元素，在那里我们的新处理程序被激活并隐藏按钮。
- en: To solve this problem, we need access to the `event` object. This is a DOM construct
    that is passed to each element's event handler when it is invoked. It provides
    information about the event, such as where the mouse cursor was at the time of
    the event. It also provides some methods that can be used to affect the progress
    of the event through the DOM.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，我们需要访问`event`对象。这是一个传递给每个元素事件处理程序的DOM构造，当它被调用时。它提供了有关事件的信息，比如鼠标光标在事件发生时的位置。它还提供了一些可以用来影响事件在DOM中的进展的方法。
- en: Event object reference
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 事件对象参考
- en: For detailed information about jQuery's implementation of the event object and
    its properties, see [http://api.jquery.com/category/events/event-object/](http://api.jquery.com/category/events/event-object/).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有关jQuery对事件对象及其属性的实现的详细信息，请参见[http://api.jquery.com/category/events/event-object/](http://api.jquery.com/category/events/event-object/)。
- en: 'To use the event object in our handlers, we only need to add a parameter to
    the function:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要在处理程序中使用事件对象，我们只需要向函数添加一个参数：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that we have named this parameter `event` because it is descriptive, not
    because we need to. Naming it `flapjacks` or anything else for that matter would
    work just as well.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将此参数命名为`event`是因为它具有描述性，而不是因为我们需要。将其命名为`flapjacks`或其他任何东西都可以正常工作。
- en: Event targets
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件目标
- en: 'Now we have the event object available to us as `event` within our handler.
    The property `event.target` can be helpful in controlling *where* an event takes
    effect. This property is a part of the DOM API, but is not implemented in some
    older browser versions; jQuery extends the event object as necessary to provide
    the property in every browser. With `.target`, we can determine which element
    in the DOM was the first to receive the event. In the case of a `click` event,
    this will be the actual item clicked on. Remembering that `this` gives us the
    DOM element handling the event, we can write the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在处理程序中使用事件对象作为`event`。属性`event.target`可以帮助我们控制事件生效的*位置*。这个属性是DOM API的一部分，但在一些较旧的浏览器版本中没有实现；jQuery根据需要扩展事件对象，以在每个浏览器中提供这个属性。通过`.target`，我们可以确定DOM中的哪个元素首先接收到事件。对于`click`事件，这将是实际点击的项。记住`this`给我们提供了处理事件的DOM元素，我们可以编写以下代码：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Listing 3.12
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.12
- en: This code ensures that the item clicked on was `<div id="switcher">`, not one
    of its sub-elements. Now, clicking on buttons will not collapse the style switcher,
    but clicking on the switcher's background *will*. However, clicking on the label,
    `<h3>`, now does nothing, because it, too, is a sub-element. Instead of placing
    this check here, we can modify the behavior of the buttons to achieve our goals.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码确保所点击的项目是`<div id="switcher">`，而不是其子元素之一。现在，点击按钮将不会使样式切换器折叠，但点击切换器的背景*会*。然而，点击标签`<h3>`现在不起作用，因为它也是一个子元素。我们可以修改按钮的行为来达到我们的目标，而不是在这里放置这个检查。
- en: Stopping event propagation
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阻止事件传播
- en: The event object provides the `.stopPropagation()` method, which can halt the
    bubbling process completely for the event. Like `.target`, this method is a basic
    DOM feature, but using the jQuery implementation will hide any browser inconsistencies
    from our code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 事件对象提供了`.stopPropagation()`方法，它可以完全停止事件的冒泡过程。像`.target`一样，这个方法是基本的DOM特性，但使用jQuery实现会隐藏我们代码中的任何浏览器不一致性。
- en: 'We''ll remove the `event.target == this` check we just added, and instead add
    some code in our buttons'' `click` handlers:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将删除我们刚刚添加的`event.target == this`检查，并在我们的按钮的`click`处理程序中添加一些代码：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Listing 3.13
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.13
- en: 'As before, we need to add an event parameter to the function we''re using as
    the `click` handler: `e`. Then, we simply call `e.stopPropagation()` to prevent
    any other DOM element from responding to the event. Now our click is handled by
    the buttons, and only the buttons; clicks anywhere else on the style switcher
    will collapse or expand it.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，我们需要在我们用作`click`处理程序的函数中添加一个事件参数：`e`。然后，我们只需调用`e.stopPropagation()`来防止任何其他DOM元素对事件作出响应。现在我们的点击由按钮处理，只有按钮；在样式切换器的任何其他地方点击都会使其折叠或展开。
- en: Preventing default actions
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止默认操作
- en: If our `click` event handler was registered on a link element (`<a>`) rather
    than a generic `<button>` element outside of a form, we would face another problem.
    When a user clicks on a link, the browser loads a new page. This behavior is not
    an event handler in the same sense as the ones we have been discussing; instead,
    this is the default action for a click on a link element. Similarly, when the
    *Enter* key is pressed while the user is editing a form, the `submit` event may
    be triggered on the form, but then the form submission actually occurs after this.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的`click`事件处理程序是在一个链接元素(`<a>`)上注册的，而不是在一个表单之外的通用`<button>`元素上，我们将面临另一个问题。当用户点击链接时，浏览器会加载一个新页面。这种行为不是我们讨论的事件处理程序的一部分；相反，这是单击链接元素的默认操作。同样，当用户在编辑表单时按下*Enter*键时，可能会在表单上触发`submit`事件，但此后实际上会发生表单提交。
- en: If these default actions are undesired, calling `.stopPropagation()` on the
    event will not help. These actions don't occur in the normal flow of event propagation.
    Instead, the `.preventDefault()` method serves to stop the event in its tracks
    before the default action is triggered.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些默认操作是不希望的，调用事件上的`.stopPropagation()`将无济于事。这些操作不会发生在事件传播的正常流程中。相反，`.preventDefault()`方法用于在触发默认操作之前立即停止事件。
- en: Calling `.preventDefault()` is often useful after we have done some tests on
    the environment of the event. For example, during a form submission, we might
    wish to check that required fields are filled in and prevent the default action
    only if they are not. With links, we can check if some precondition has been met
    before allowing the `href` to be followed, in essence, disabling the link under
    some circumstances.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在对事件环境进行一些测试后调用`.preventDefault()`通常是有用的。例如，在表单提交期间，我们可能希望检查必填字段是否已填写，并且仅在它们未填写时阻止默认操作。对于链接，我们可以在允许`href`被跟踪之前检查某些前提条件，从本质上讲，在某些情况下禁用链接。
- en: Event propagation and default actions are independent mechanisms; either of
    them can be stopped while the other still occurs. If we wish to halt both, we
    can return `false` at the end of our event handler, which is a shortcut for calling
    both `.stopPropagation()` and `.preventDefault()` on the event.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 事件传播和默认操作是独立的机制；其中之一可以在另一个发生时停止。如果我们希望同时停止两者，我们可以在事件处理程序的末尾返回`false`，这是对事件同时调用`.stopPropagation()`和`.preventDefault()`的快捷方式。
- en: Delegating events
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件委托
- en: Event bubbling isn't always a hindrance; we can often use it to great benefit.
    One great technique that exploits bubbling is called **event delegation**. With
    it, we can use an event handler on a single element to do the work of many.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 事件冒泡并不总是一种阻碍；我们经常可以将其利用到极大的好处中。利用冒泡的一种伟大技术称为**事件委托**。通过它，我们可以使用单个元素上的事件处理程序来完成许多工作。
- en: In our example, there are just three `<button>` elements that have attached
    `click` handlers. But what if there were many more than three? This is more common
    than you might think. Consider, for example, a large table of information in which
    each row has an interactive item requiring a `click` handler. Implicit iteration
    makes assigning all of these `click` handlers easy, but performance can suffer
    because of the looping being done internally to jQuery, and because of the memory
    footprint of maintaining all the handlers.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，只有三个带有附加`click`处理程序的`<button>`元素。但是如果有多于三个呢？这比你想象的更常见。例如，考虑一个包含每行都有一个需要`click`处理程序的交互项的大型信息表格。隐式迭代使得分配所有这些`click`处理程序变得容易，但性能可能会因为jQuery内部的循环和维护所有处理程序的内存占用而受到影响。
- en: Instead, we can assign a single `click` handler to an ancestor element in the
    DOM. An uninterrupted `click` event will eventually reach the ancestor due to
    event bubbling, and we can do our work there.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以将单个`click`处理程序分配给DOM中的祖先元素。由于事件冒泡，无间断的`click`事件最终将到达祖先元素，我们可以在那里完成我们的工作。
- en: As an example, let's apply this technique to our style switcher (even though
    the number of items does not demand the approach). As seen in *Listing 3.12* previously,
    we can use the `e.target` property to check which element is under the mouse cursor
    when the `click` event occurs.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，让我们将这种技术应用于我们的样式切换器（即使项目数量不需要这种方法）。如前面所见的*清单 3.12*，我们可以使用`e.target`属性来检查在发生`click`事件时鼠标光标下的哪个元素。
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Listing 3.14
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3.14
- en: 'We''ve used a new method here called `.is()`. This method accepts the selector
    expressions we investigated in the previous chapter and tests the current jQuery
    object against the selector. If at least one element in the set is matched by
    the selector, `.is()` returns `true`. In this case, `$(e.target).is(''button'')`
    asks whether the element clicked is a `<button>` element. If so, we proceed with
    the previous code, with one significant alteration: the keyword `this` now refers
    to `<div id="switcher">`, so every time we are interested in the clicked button,
    we must now refer to it with `e.target`.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了一个新方法叫做`.is()`。该方法接受我们在上一章中研究的选择器表达式，并测试当前jQuery对象是否与选择器匹配。如果集合中至少有一个元素与选择器匹配，`.is()`将返回`true`。在这种情况下，`$(e.target).is('button')`询问被点击的元素是否是一个`<button>`元素。如果是，我们将继续以前的代码，但有一个重大变化：关键字`this`现在指的是`<div
    id="switcher">`，所以每次我们感兴趣的是点击的按钮时，现在必须使用`e.target`来引用它。
- en: .is() and .hasClass()
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: .is() 和 .hasClass()
- en: We can test for the presence of a class on an element with `.hasClass()`. The
    `.is()` method is more flexible, however, and can test any selector expression.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`.hasClass()`测试元素上类的存在。然而，`.is()`方法更灵活，可以测试任何选择器表达式。
- en: 'We have an unintentional side-effect from this code, however. When a button
    is clicked now, the switcher collapses, as it did before we added the call to
    `.stopPropagation()`. The handler for the switcher visibility toggle is now bound
    to the same element as the handler for the buttons, so halting the event bubbling
    does not stop the toggle from being triggered. To sidestep this issue, we can
    remove the `.stopPropagation()` call and instead add another `.is()` test. Also,
    since we''re making the entire switcher `<div>` element clickable, we ought to
    toggle the `hover` class while the user''s mouse is over any part of it:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，从这段代码中我们还有一个意外的副作用。现在，当单击按钮时，切换器会折叠，就像我们在添加调用`.stopPropagation()`之前的情况一样。切换器可见性切换器的处理程序现在绑定到与按钮的处理程序相同的元素上，因此停止事件冒泡不会阻止切换器触发。为了避开这个问题，我们可以删除`.stopPropagation()`调用，并且改为添加另一个`.is()`测试。另外，由于我们使整个切换器`<div>`元素可点击，所以应该在用户的鼠标位于其任何部分时切换`hover`类：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Listing 3.15
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 3.15**'
- en: 'This example is a bit over complicated for its size, but as the number of elements
    with event handlers increases, so does event delegation''s benefit. Also, we can
    avoid some of the code repetition by combining the two `click` handlers and using
    a single `if-else` statement for the `.is()` test:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子在大小上有点复杂了，但是随着具有事件处理程序的元素数量的增加，事件委托的好处也会增加。此外，通过组合两个`click`处理程序并使用单个`if-else`语句进行`.is()`测试，我们可以避免一些代码重复：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Listing 3.16
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 3.16**'
- en: While our code could still use some fine tuning, it is approaching a state at
    which we can feel comfortable using it for what we set out to do. Nevertheless,
    for the sake of learning more about jQuery's event handling, we'll back up to
    *Listing 3.15* and continue to modify that version of the code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的代码仍然需要一些微调，但它已经接近我们可以放心使用它的状态了。尽管如此，为了更多地了解 jQuery 的事件处理，我们将回到 *清单 3.15*
    并继续修改该版本的代码。
- en: Event delegation is also useful in other situations we'll see later, such as
    when new elements are added by DOM manipulation methods ([Chapter 5](fa35636a-37d4-49b9-ba72-aa6596bab015.xhtml),
    *Manipulating the DOM*) or Ajax routines ([Chapter 6](3a5a790f-4c0a-4b63-bb00-cc38e78309c6.xhtml),
    *Sending Data with Ajax*).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 事件委托在我们稍后会看到的其他情况下也很有用，比如当通过 DOM 操作方法（[第 5 章](fa35636a-37d4-49b9-ba72-aa6596bab015.xhtml)，*操作
    DOM*）或 Ajax 例程（[第 6 章](3a5a790f-4c0a-4b63-bb00-cc38e78309c6.xhtml)，*使用 Ajax 发送数据*）添加新元素时。
- en: Using built-in event delegation capabilities
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内置的事件委托功能
- en: 'Because event delegation can be helpful in so many situations, jQuery includes
    a set of tools to aid developers in using this technique. The `.on()` method we
    have already discussed can perform event delegation when provided with appropriate
    parameters:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因为事件委托在很多情况下都很有用，jQuery 包含了一组工具来帮助开发者使用这个技术。我们已经讨论过的`.on()`方法可以在提供适当参数时执行事件委托：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Listing 3.17
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 3.17**'
- en: This is looking pretty good now. We have two really simple handlers for all
    click events in switcher feature. We added a selector expression to the `.on()`
    method as the second argument. Specifically, we want to make sure that any elements
    that bubble click events up to `#switch` are in fact button elements. This is
    better than writing a bunch of logic in the event handler to determine how to
    handle the event based on the element that generated it.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来很不错了。对于切换器功能中的所有点击事件，我们有两个非常简单的处理程序。我们在`.on()`方法中添加了一个选择器表达式作为第二个参数。具体来说，我们要确保将点击事件上升到`#switch`的任何元素实际上都是按钮元素。这比在事件处理程序中编写一堆逻辑来根据生成它的元素处理事件更好。
- en: We did have to add a call to `e.stopPropagation()`. The reason is so that the
    second click handler, the one that handles toggling the button visibility, doesn't
    have to worry about checking where the event came from. It's often easier to prevent
    propagation than it is to introduce edge case handling into event handler code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实不得不添加一个调用`e.stopPropagation()`的方法。原因是为了使第二个点击处理程序，即处理切换按钮可见性的处理程序，无需担心检查事件来自何处。通常防止事件传播比在事件处理程序代码中引入边缘情况处理更容易。
- en: With a few minor trade offs, we now have a single button click handler function
    that works with 3 buttons, or with 300 buttons. It's the little things like this
    that make jQuery code scale well.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些小的折衷，我们现在有了一个单一的按钮点击处理函数，它可以处理 3 个按钮，也可以处理 300 个按钮。就是这些小细节使得 jQuery 代码能够很好地扩展。
- en: We'll fully examine this use of `.on()`, in [Chapter 10](d150ca06-e7dc-4100-8c91-060f0272ff67.xhtml),
    *Advanced Events*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第 10 章](d150ca06-e7dc-4100-8c91-060f0272ff67.xhtml)，*高级事件*中全面讨论`.on()`的使用。
- en: Removing an event handler
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除事件处理程序
- en: There are times when we will be done with an event handler we previously registered.
    Perhaps the state of the page has changed such that the action no longer makes
    sense. It is possible to handle this situation with conditional statements inside
    our event handlers, but it is more elegant to unbind the handler entirely.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们会完成之前注册的事件处理程序。也许页面的状态已经改变，使得这个动作不再合理。我们可以在事件处理程序内部使用条件语句处理这种情况，但是完全解绑处理程序会更加优雅。
- en: 'Suppose that we want our collapsible style switcher to remain expanded whenever
    the page is not using the normal style. While the Narrow Column or Large Print
    button is selected, clicking on the background of the style switcher should do
    nothing. We can accomplish this by calling the `.off()` method to remove the collapsing
    handler when one of the non-default style switcher buttons is clicked:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望我们的可折叠样式切换器在页面不使用正常样式时保持展开。当选择窄列或大号字按钮时，单击样式切换器的背景应该没有任何效果。我们可以通过调用 `.off()`
    方法来在点击非默认样式切换器按钮时移除折叠处理程序来实现这一点：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Listing 3.18
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.18
- en: Now when a button such as Narrow Column is clicked, the `click` handler on the
    style switcher `<div>` is removed, and clicking on the background of the box no
    longer collapses it. However, the buttons don't work anymore! They are affected
    by the `click` event of the style switcher `<div>` as well, because we rewrote
    the button-handling code to use event delegation. This means that when we call
    `$('#switcher').off('click')`, both behaviors are removed.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当单击诸如窄列之类的按钮时，样式切换器 `<div>` 上的 `click` 处理程序被移除，单击框的背景不再使其折叠。然而，按钮不再起作用！它们也受到样式切换器
    `<div>` 的 `click` 事件影响，因为我们重写了按钮处理代码以使用事件委托。这意味着当我们调用 `$('#switcher').off('click')`
    时，两种行为都被移除。
- en: Giving namespaces to event handlers
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给事件处理程序命名空间
- en: We need to make our `.off()` call more specific so that it does not remove both
    of the click handlers we have registered. One way of doing this is to use **event**
    **namespacing**. We can introduce additional information when an event is bound
    that allows us to identify that particular handler later. To use namespaces, we
    need to return to the non-shorthand method of binding event handlers, the `.on()`
    method itself.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使我们的 `.off()` 调用更加具体，以便不移除我们注册的两个点击处理程序。一种方法是使用**事件** **命名空间**。当事件绑定时，我们可以引入附加信息，以便稍后识别特定的处理程序。要使用命名空间，我们需要返回到绑定事件处理程序的非简写方法，即
    `.on()` 方法本身。
- en: 'The first parameter we pass to `.on()` is the name of the event we want to
    watch for. We can use a special syntax here, though, that allows us to subcategorize
    the event:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给 `.on()` 的第一个参数是我们要监听的事件的名称。在这里，我们可以使用一种特殊的语法，允许我们对事件进行子分类：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Listing 3.19
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.19
- en: The `.collapse` suffix is invisible to the event handling system; `click` events
    are handled by this function, just as if we wrote `.on('click')`. However, the
    addition of the namespace means that we can unbind just this handler without affecting
    the separate `click` handler we wrote for the buttons.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`.collapse` 后缀对事件处理系统不可见；`click` 事件由此函数处理，就像我们写了`.on(''click'')`一样。然而，添加命名空间意味着我们可以解绑这个处理程序而不影响我们为按钮编写的单独的
    `click` 处理程序。'
- en: There are other ways of making our `.off()` call more specific, as we will see
    in a moment. However, event namespacing is a useful tool in our arsenal. It is
    especially handy in the creation of plugins, as we'll see in later chapters.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他使我们的 `.off()` 调用更加具体的方法，我们马上就会看到。然而，事件命名空间是我们工具库中一个有用的工具。在后面的章节中，我们会看到它在插件的创建中是特别方便的。
- en: Rebinding events
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新绑定事件
- en: Now clicking on the Narrow Column or Large Print button causes the style switcher
    collapsing functionality to be disabled. However, we want the behavior to return
    when the Default button is pressed. To do this, we will need to **rebind** the
    handler whenever Default is clicked.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在单击窄列或大号字按钮会导致样式切换器折叠功能被禁用。然而，当单击默认按钮时，我们希望行为恢复。为了做到这一点，我们需要在单击默认按钮时**重新绑定**处理程序。
- en: 'First, we should give our handler function a name so that we can use it more
    than once without repeating ourselves:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该给我们的处理程序函数一个名称，这样我们就可以多次使用它而不重复自己：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Listing 3.20
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.20
- en: Recall that we are passing `.on()` a **function** **reference** as its second
    argument. It is important to remember when referring to a function that we must
    omit parentheses after the function name; parentheses would cause the function
    to be *called* rather than *referenced*.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们正在将`.on()`的第二个参数传递给一个**函数引用**。在引用函数时，重要的是要记住在函数名后省略括号；括号会导致调用函数而不是引用函数。
- en: 'Now that the `toggleSwitcher()` function can be referenced, we can bind it
    again later, without repeating the function definition:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`toggleSwitcher()`函数已经被引用，我们可以在稍后再次绑定它，而无需重复函数定义：
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Listing 3.21
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.21
- en: Now the toggle behavior is bound when the document is loaded, unbound when Narrow
    Column or Large Print is clicked, and rebound when Default is clicked after that.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，切换行为在文档加载时绑定，在点击“Narrow Column”或“Large Print”后取消绑定，并在此后再次点击“Default”时重新绑定。
- en: Since we have named the function, we no longer need to use namespacing. The
    `.off()` method can take a function as a second argument; in this case, it unbinds
    only that specific handler. However, we have run into another problem. Remember
    that when a handler is bound to an event in jQuery, previous handlers remain in
    effect. In this case, each time Default is clicked, another copy of the `toggleSwitcher`
    handler is bound to the style switcher. In other words, the function is called
    an extra time for each additional click until the user clicks Narrow or Large
    Print, which unbinds all of the `toggleSwitcher` handlers at once.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经命名了函数，因此不再需要使用命名空间。`.off()`方法可以接受一个函数作为第二个参数；在这种情况下，它只取消绑定那个特定的处理程序。但是，我们遇到了另一个问题。请记住，当在jQuery中将处理程序绑定到事件时，之前的处理程序仍然有效。在这种情况下，每次点击“Default”时，都会向样式切换器绑定`toggleSwitcher`处理程序的另一个副本。换句话说，每次额外点击，该函数都会多调用一次，直到用户点击“Narrow”或“Large
    Print”，这样一次性取消所有`toggleSwitcher`处理程序。
- en: 'When an even number of `toggleSwitcher` handlers are bound, clicks on the style
    switcher (but not on a button) appear to have no effect. In fact, the `hidden`
    class is being toggled multiple times, ending up in the same state it was when
    it began. To remedy this problem, we can unbind the handler when a user clicks
    on *any* button, and rebind only after ensuring that the clicked button''s ID
    is `switcher-default`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当绑定了偶数个`toggleSwitcher`处理程序时，在样式切换器上（而不是在按钮上）点击似乎没有效果。实际上，`hidden`类被多次切换，最终处于与开始时相同的状态。为了解决这个问题，当用户点击*任何*按钮时，我们可以取消绑定处理程序，并且只在确保点击的按钮的ID为`switcher-default`后再次绑定：
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Listing 3.22
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.22
- en: 'A shortcut is also available for the situation in which we want to unbind an
    event handler immediately after the first time it is triggered. This shortcut,
    called `.one()`, is used as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们希望在事件触发后立即取消绑定事件处理程序的情况下，也有一个快捷方式可用。这个快捷方式称为`.one()`，用法如下：
- en: '[PRE40]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This would cause the toggle action to occur only once.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致切换操作仅发生一次。
- en: Simulating user interaction
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟用户交互
- en: At times, it is convenient to execute code that we have bound to an event, even
    if the event isn't triggered directly by user input. For example, suppose we wanted
    our style switcher to begin in its collapsed state. We could accomplish this by
    hiding buttons from within the stylesheet, or by adding our `hidden` class or
    calling the `.hide()` method from a `$(() => {})` handler. Another way would be
    to simulate a click on the style switcher so that the toggling mechanism we've
    already established is triggered.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，即使事件不是直接由用户输入触发，执行我们绑定到事件的代码也很方便。例如，假设我们希望我们的样式切换器以折叠状态开始。我们可以通过从样式表中隐藏按钮，或者通过添加我们的`hidden`类或从`$(()
    => {})`处理程序调用`.hide()`方法来实现这一点。另一种方法是模拟点击样式切换器，以触发我们已经建立的切换机制。
- en: 'The `.trigger()` method allows us to do just this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`.trigger()`方法允许我们做到这一点：'
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Listing 3.23
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.23
- en: 'Now when the page loads, the switcher is collapsed just as if it had been clicked,
    as shown in the following screenshot:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面加载时，开关器的状态会折叠起来，就好像它已经被点击一样，如下截图所示：
- en: '![](img/5297_03_10.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_03_10.png)'
- en: If we were hiding content that we wanted people without JavaScript enabled to
    see, this would be a reasonable way to implement **graceful degradation**. Although,
    this is very uncommon these days.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要隐藏希望禁用JavaScript的人看到的内容，这将是实现**优雅降级**的一个合理方式。尽管，这在如今非常不常见。
- en: 'The `.trigger()` method provides the same set of shortcut methods that `.on()`
    does. When these shortcuts are used with no arguments, the behavior is to trigger
    the action rather than bind it:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`.trigger()` 方法提供了与 `.on()` 相同的快捷方法。当这些快捷方式没有参数时，行为是触发操作而不是绑定它：'
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Listing 3.24
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 例 3.24
- en: Reacting to keyboard events
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对键盘事件的反应
- en: As another example, we can add keyboard shortcuts to our style switcher. When
    the user types the first letter of one of the display styles, we will have the
    page behave as if the corresponding button was clicked. To implement this feature,
    we will need to explore **keyboard events**, which behave a bit differently from
    **mouse events**.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子，我们可以向我们的样式切换器添加键盘快捷方式。当用户键入其中一个显示样式的第一个字母时，我们将使页面表现得就像相应的按钮被点击一样。要实现此功能，我们需要探索**键盘事件**，它们与**鼠标事件**的行为有些不同。
- en: 'There are two types of keyboard events: those that react to the keyboard directly
    (`keyup` and `keydown`) and those that react to text input (`keypress`). A single
    character entry event could correspond to several keys, for example, when the
    *Shift* key in combination with the *X* key creates the capital letter *X*. While
    the specifics of implementation differ from one browser to the next (unsurprisingly),
    a safe rule of thumb is: if you want to know what key the user pushed, you should
    observe the `keyup` or `keydown` event; if you want to know what character ended
    up on the screen as a result, you should observe the `keypress` event. For this
    feature, we just want to know when the user presses the *D*, *N*, or *L* key,
    so we will use `keyup`.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的键盘事件：直接对键盘做出反应的事件（`keyup` 和 `keydown`）以及对文本输入做出反应的事件（`keypress`）。单个字符输入事件可能对应多个键，例如，当*Shift*键与*X*键结合创建大写字母*X*时。虽然具体的实现细节因浏览器而异（不出所料），但一个安全的经验法则是：如果你想知道用户按下了什么键，你应该观察
    `keyup` 或 `keydown` 事件；如果你想知道最终在屏幕上呈现了什么字符，你应该观察 `keypress` 事件。对于这个功能，我们只想知道用户何时按下了*D*、*N*
    或 *L* 键，所以我们将使用 `keyup`。
- en: Next, we need to determine which element should watch for the event. This is
    a little less obvious than with mouse events, where we have a visible mouse cursor
    to tell us about the event's target. Instead, the target of a keyboard event is
    the element that currently has the **keyboard focus**. The element with focus
    can be changed in several ways, including using mouse clicks and pressing the
    *Tab* key. Not every element can get the focus, either; only items that have default
    keyboard-driven behaviors such as form fields, links, and elements with a `.tabIndex`
    property are candidates.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确定哪个元素应该监听事件。这对于鼠标事件来说不太明显，因为我们有一个可见的鼠标光标来告诉我们事件的目标。相反，键盘事件的目标是当前具有**键盘焦点**的元素。焦点元素可以通过多种方式进行更改，包括使用鼠标点击和按下*Tab*键。而且，并非每个元素都可以获得焦点；只有具有默认键盘驱动行为的项，如表单字段、链接和具有
    `.tabIndex` 属性的元素，才是候选项。
- en: In this case, we don't really care what element has the focus; we want our switcher
    to work whenever the user presses one of the keys. Event bubbling will once again
    come in handy, as we can bind our `keyup` event to the `document` element and
    have assurance that eventually any key event will bubble up to us.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们并不真的关心哪个元素获得了焦点；我们希望我们的切换器在用户按下这些键时起作用。事件冒泡将再次派上用场，因为我们可以将我们的 `keyup`
    事件绑定到 `document` 元素，并确保最终任何键事件都会冒泡到我们这里来。
- en: 'Finally, we will need to know which key was pressed when our `keyup` handler
    gets triggered. We can inspect the `event` object for this. The `.which` property
    of the event contains an identifier for the key that was pressed, and for alphabetic
    keys, this identifier is the ASCII value of the uppercase letter. With this information,
    we can now create an **object literal** of letters and their corresponding buttons
    to click. When the user presses a key, we''ll see if its identifier is in the
    map, and if so, trigger the click:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们的 `keyup` 处理程序被触发时，我们需要知道按下了哪个键。我们可以检查 `event` 对象来获取这个信息。事件的 `.which`
    属性包含了按下的键的标识符，对于字母键，这个标识符是大写字母的 ASCII 值。有了这个信息，我们现在可以创建一个字母及其相应按钮的**对象文本**。当用户按下一个键时，我们将查看它的标识符是否在映射中，如果是，就触发点击：
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Listing 3.25
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 例 3.25
- en: Presses of these three keys now simulate mouse clicks on the buttons--provided
    that the key event is not interrupted by features such as Firefox's search for
    text when I start typing.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 连续按下这三个键现在模拟了对按钮的鼠标点击操作——前提是键盘事件没有被诸如 Firefox 在我开始输入时搜索文本这样的功能所中断。
- en: 'As an alternative to using `.trigger()` to simulate this click, let''s explore
    how to factor out code into a function so that more than one handler can call
    it--in this case, both `click` and `keyup` handlers. While not necessary in this
    case, this technique can be useful in eliminating code redundancy:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用`.trigger()`模拟此点击的替代方案，让我们探讨如何将代码因子化为一个函数，以便多个处理程序可以调用它——在这种情况下，`click`和`keyup`处理程序都可以调用它。虽然在本例中并不必要，但这种技术可以有助于消除代码的冗余：
- en: '[PRE44]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Listing 3.26
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.26
- en: This final revision consolidates all the previous code examples of this chapter.
    We have moved the entire block of code into a single `$(() => {})` handler and
    made our code less redundant.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最终修订版将本章所有先前的代码示例整合在一起。我们将整个代码块移入一个单独的`$(() => {})`处理程序，并使我们的代码不那么冗余。
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The abilities we've discussed in this chapter allow us to react to various user-driven
    and browser-initiated events. We have learned how to safely perform actions when
    the page loads, how to handle mouse events such as clicking on links or hovering
    over buttons, and how to interpret keystrokes.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的功能使我们能够对各种用户驱动和浏览器启动的事件作出反应。我们已经学会了如何在页面加载时安全执行操作，如何处理鼠标事件（如单击链接或悬停在按钮上），以及如何解释按键。
- en: In addition, we have delved into some of the inner workings of the event system,
    and can use this knowledge to perform event delegation and to change the default
    behavior of an event. We can even simulate the effects of an event as if the user
    initiated it.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们已经深入研究了事件系统的一些内部工作原理，并可以利用这些知识进行事件委托和更改事件的默认行为。我们甚至可以模拟用户发起事件的效果。
- en: We can use these capabilities to build interactive pages. In the next chapter,
    we'll learn how to provide visual feedback to the user during these interactions.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这些功能来构建交互式页面。在下一章中，我们将学习如何在这些交互过程中为用户提供视觉反馈。
- en: Further reading
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The topic of event handling will be explored in more detail in [Chapter 10](d150ca06-e7dc-4100-8c91-060f0272ff67.xhtml),
    *Advanced Events*. A complete list of jQuery's event methods is available in *Appendix
    C* of this book, or in the official jQuery documentation at [http://api.jquery.com/](http://api.jquery.com/).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理的主题将在[第 10 章](d150ca06-e7dc-4100-8c91-060f0272ff67.xhtml)“高级事件”中更详细地探讨。jQuery
    的事件方法的完整列表可在本书的附录 C 中找到，或者在官方 jQuery 文档中找到：[http://api.jquery.com/](http://api.jquery.com/)。
- en: Exercises
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Challenge exercises may require the use of the official jQuery documentation
    at [http://api.jquery.com/](http://api.jquery.com/).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战练习可能需要使用官方 jQuery 文档：[http://api.jquery.com/](http://api.jquery.com/)。
- en: When Charles Dickens is clicked, apply the `selected` style to it.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当点击查尔斯·狄更斯时，应用`selected`样式。
- en: When a chapter title (`<h3 class="chapter-title">`) is double-clicked, toggle
    the visibility of the chapter text.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击章标题（`<h3 class="chapter-title">`）时，切换章节文本的可见性。
- en: When the user presses the right arrow key, cycle to the next `body` class. The
    key code for the right arrow key is `39`.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户按下右箭头键时，循环到下一个`body`类。右箭头键的键码为`39`。
- en: 'Challenge: Use the `console.log()` function to log the coordinates of the mouse
    as it moves across any paragraph. (Note: `console.log()` displays its results
    via the Firebug extension for Firefox, Safari''s Web Inspector, or the Developer
    Tools in Chrome or Internet Explorer).'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挑战：使用`console.log()`函数记录鼠标在任何段落上移动时的坐标。（注意：`console.log()`通过 Firefox 的 Firebug
    扩展、Safari 的 Web Inspector 或 Chrome 或 Internet Explorer 的开发者工具显示其结果）。
- en: 'Challenge: Use `.mousedown()` and `.mouseup()` to track mouse events anywhere
    on the page. If the mouse button is released *above* where it was pressed, add
    the `hidden` class to all paragraphs. If it is released *below* where it was pressed,
    remove the `hidden` class from all paragraphs.'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挑战：使用`.mousedown()`和`.mouseup()`来跟踪页面上任何位置的鼠标事件。如果鼠标按钮在按下的地方*上方*释放，将`hidden`类添加到所有段落。如果在按下的地方*下方*释放，将从所有段落中移除`hidden`类。
