- en: Chapter 4. Working with Styles and Layout
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：使用样式和布局
- en: At this point, you may feel that the application is lacking a certain appeal.
    The success of any application relies greatly on how the user interface looks.
    Just like how React Native borrows from React on the web, the same thing goes
    for styles. In this chapter, you will learn how React Native styles and lays out
    the components with React CSS.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能觉得应用程序缺少一定的吸引力。任何应用程序的成功在很大程度上取决于用户界面的外观。就像React Native从Web上的React中借鉴一样，样式也是如此。在本章中，你将学习React
    Native如何使用React CSS样式化和布局组件。
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: What is React CSS?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是React CSS？
- en: Creating Style Sheets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建样式表
- en: Extending the `SimpleButton` to include custom styles
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展`SimpleButton`以包含自定义样式
- en: An introduction to layout with Flexbox
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flexbox布局简介
- en: Styling the `NavigationBar`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式化`NavigationBar`
- en: Styling the `NoteScreen`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式化`NoteScreen`
- en: React CSS
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React CSS
- en: If you have any experience in writing CSS for a browser then you will feel comfortable
    with the styles in React Native. Although, instead of the browser's implementation
    of cascading styles, Facebook has developed a subset version of CSS in JavaScript.
    The benefit of this approach is that the designer can fully utilize features in
    JavaScript, such as variables and conditionals, which CSS does not support natively.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有任何为浏览器编写CSS的经验，那么你将感到React Native中的样式很舒适。尽管如此，Facebook在JavaScript中开发了一个CSS子集版本，而不是浏览器中层叠样式的实现。这种方法的优点是设计师可以充分利用JavaScript中的功能，如变量和条件，这是CSS原生不支持的功能。
- en: Style Sheet
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样式表
- en: Style Sheet is the React Native abstraction to declare styles using object notation.
    The components can use any style, so if you find that you are not able to get
    the right look then refer to the React Native documentation on that component
    in its styles section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 样式表是React Native使用对象表示法声明样式的抽象。组件可以使用任何样式，所以如果你发现你无法获得正确的外观，请参考该组件在React Native文档中的样式部分。
- en: When inserting styles, it is common to include only those styles that you need
    for that specific component. It is similar to how JSX combines the JavaScript
    logic and markup into a single component; we are also going to define our styles
    in the same file.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入样式时，通常只包括特定组件所需的样式。这类似于JSX如何将JavaScript逻辑和标记合并到一个组件中；我们也将定义我们的样式在同一文件中。
- en: 'To create a Style Sheet, use the `Stylesheet.create({..})` method by passing
    in an object of objects:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建样式表，请使用`Stylesheet.create({..})`方法，传入一个对象的对象：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This looks similar to CSS but it uses commas instead of semicolons.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与CSS类似，但它使用逗号而不是分号。
- en: 'Styles are declared to be *inline* on a component using the style prop:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`style`属性在组件上声明样式为*内联*：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is also possible to pass normal JavaScript objects to the style prop. This
    is generally not recommended, since the Style Sheet ensures that each style is
    immutable and only created once throughout the lifecycle.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以将普通的JavaScript对象传递给`style`属性。这通常不推荐，因为样式表确保每个样式是不可变的，并且在整个生命周期中只创建一次。
- en: Styling the SimpleButton component
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样式化`SimpleButton`组件
- en: 'Let''s extend our `SimpleButton` component further to accept custom styles
    for the button background and text. In the `render` method, let''s set the `style`
    attribute of the `View` and `Text` components from the `props`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步扩展我们的`SimpleButton`组件，使其能够接受按钮背景和文本的自定义样式。在`render`方法中，让我们从`props`中设置`View`和`Text`组件的`style`属性：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Revisiting PropTypes**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**重新审视PropTypes**'
- en: To validate, the `View` or `Text` styles passed into your component use `View.propTypes.style`
    and `Text.propType.style`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证，将`View`或`Text`样式传递到你的组件中时，使用`View.propTypes.style`和`Text.propTypes.style`。
- en: 'On the `HomeScreen` we are going to style the `simpleButton` component to draw
    the user''s attention to the `NoteScreen` when there are no notes. We will start
    by adding it to the `StyleSheet` and defining some text styles:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在`HomeScreen`上，我们将对`simpleButton`组件进行样式设计，以便在没有笔记时吸引用户的注意力到`NoteScreen`。我们将首先将其添加到`StyleSheet`中，并定义一些文本样式：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we want the text on the button to be bold, white in color, and with size
    16\. To style the button, we need to add another object to the `StyleSheet` called
    `simpleButton` and also define a background color; the `simpleButton` code is
    as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们希望按钮上的文本是粗体的，颜色为白色，大小为16。为了样式化按钮，我们需要向`StyleSheet`中添加另一个名为`simpleButton`的对象，并定义一个背景颜色；`simpleButton`的代码如下：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s see the output of the preceding command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看上一个命令的输出：
- en: '![Styling the SimpleButton component](img/5162_04_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: 'It''s not that appealing yet; let''s add some padding so that it''s easier
    for the user to press the button:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`paddingVertical` is shorthand for `paddingTop` and `paddingBottom`. `paddingHorizontal`
    is shorthand for `paddingLeft` and `paddingRight`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'React CSS does not have a shorthand notion, such as `border: 1px solid #000`.
    Instead each item is declared individually:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To add a drop shadow, we define each property similar to borders:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Notice how the shadow offset requires an object with `width` and `height` properties.
    Since we are dealing with JavaScript objects, this is a perfectly acceptable notation.
    Now, we include the `SimpleButton` component in our `HomeScreen` render method:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Update the `renderScene` function of `ReactNotes` in `index.ios.js` and `index.android.js`
    to pass the navigator through the `props` to the `HomeScreen`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s see the output of the preceding command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling the SimpleButton component](img/5162_04_02.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: This is not too shabby for a typical call to action button. If you reload this
    in the simulator and press the button, it will still fade due to the `TouchableOpacity`
    feedback. For more information on React CSS or to contribute, visit the open source
    CSS-layout repository at [https://github.com/facebook/css-layout](https://github.com/facebook/css-layout).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Layout and Flexbox
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Flexbox is the foundation of React Native's layout, we are going to explore
    it in depth. If you are already familiar with the intricacies of Flexbox, feel
    free to jump to the *Styling the NavigationBar component* section. There we will
    focus more on the styling of the components that we made in the previous chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Flex container
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The flex container is the parent element that describes how children or flex
    items are laid out. The `flexDirection` property of the container specifies the
    `main-axis`; the primary direction in which the items are rendered. The line perpendicular
    to the `main-axis` is called the `cross-axis`. Different flex properties on the
    container affect how the items are aligned across each axis. The `flexDirection`
    property has two possible values; `row` values for horizontal layouts (left to
    right) and `column` for vertical layouts (top to bottom). The following figure
    shows the `flexDirection`: `row` items aligned from left to right:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![Flex container](img/5162_04_03.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: 'The next figure shows the items laid out from top to bottom when it''s set
    to `flexDirection`: `column`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![Flex container](img/5162_04_04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: 'We can move the items in the container along the established `main-axis` with
    the help of `justifyContent`. The following diagram shows the different options
    along the `main-axis`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![Flex container](img/5162_04_05.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice how `space-between` does not include white space along the left and right
    edges, whereas `space-around` does, but it is half the width of the white space
    included in between the items.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'To move items along the `cross-axis`, we use `alignItems`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '要沿`cross-axis`移动项目，我们使用`alignItems`:'
- en: '![Flex container](img/5162_04_06.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![弹性容器](img/5162_04_06.jpg)'
- en: Wrapping items is also possible, but it is disabled by default. Items within
    a container will all try to fit along the `main-axis`. If there are too many items
    or if they are too squeezed, you can apply `flexWrap`. The container will then
    calculate if it is necessary to put an item onto a new row or column.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 项目包装也是可能的，但默认情况下是禁用的。容器内的所有项目都将尝试沿`main-axis`排列。如果项目太多或太拥挤，你可以应用`flexWrap`。容器将计算是否需要将项目放置在新的一行或列上。
- en: Flex items
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 弹性项目
- en: 'By default, `flex` items will only be as wide as their internal content. The
    `flex` property dictates the amount of remaining space the item should take up.
    The available space is divided based on the ratio of each item''s `flex` value:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`flex`项目将只有其内部内容的宽度。`flex`属性决定了项目应占用的剩余空间量。可用空间根据每个项目的`flex`值比例进行划分：
- en: '![Flex items](img/5162_04_07.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![弹性项目](img/5162_04_07.jpg)'
- en: Make a note of how the items in row two are all of the same width, since their
    `flex` value is `1`. The item with `flex` value `2` in row three takes twice as
    much space as the rest of the items.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第二行的项目都是相同宽度，因为它们的`flex`值是`1`。第三行中`flex`值为`2`的项目比其他项目多占两倍的空间。
- en: Similar to `alignItems`, a `flex` item can align itself along the `cross-axis`
    with `alignSelf`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与`alignItems`类似，一个`flex`项目可以使用`alignSelf`沿`cross-axis`对齐自己。
- en: Horizontal and vertical centering
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 水平和垂直居中
- en: 'Let''s take a look at a quick example of how Flexbox makes layout easier. One
    of the biggest challenges in CSS is the vertically and horizontally centered elements
    (take five minutes and attempt to accomplish this in normal CSS). We''re going
    to start by creating our `Center` components and defining a `flex` container with
    three `flex` items:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下Flexbox如何使布局更简单。CSS中最大的挑战之一是水平和垂直居中的元素（花五分钟尝试用常规CSS完成这个任务）。我们将首先创建我们的`Center`组件，并定义一个包含三个`flex`项目的`flex`容器：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Initialize a new `StyleSheet` and define some simple styles for the items:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化一个新的`StyleSheet`并为项目定义一些简单的样式：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we want to control where the items are aligned along the `main-axis` and
    `cross-axis` with `justifyContent` and `alignItems`. Create a container style
    and set `justifyContent` and align items to `center`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，我们想要通过`justifyContent`和`alignItems`来控制项目沿`main-axis`和`cross-axis`的对齐位置。创建一个容器样式，并将`justifyContent`和`alignItems`设置为`center`:'
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![Horizontal and vertical centering](img/5162_04_08.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![水平和垂直居中](img/5162_04_08.jpg)'
- en: 'This does not seem like the `behaviour` was specified. The items are aligned
    along the `centre` of the `main-axis` but not the `cross-axis`. Let''s add a border
    around the container to visualize it:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎没有指定`behaviour`。项目沿`main-axis`的中心对齐，但没有沿`cross-axis`对齐。让我们在容器周围添加一个边框来可视化它：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![Horizontal and vertical centering](img/5162_04_09.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![水平和垂直居中](img/5162_04_09.jpg)'
- en: 'Now we can see that the height of the container does not span the entire screen.
    Since the default `flexDirection` in the root `View` container is `column`, the
    content will only span the height of the content. Luckily, we now know the property
    to take up the remaining space. Adding `flex 1` to our container will have its
    span in the vertical length of the screen, which gives us the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到容器的长度并没有覆盖整个屏幕。由于根`View`容器中的默认`flexDirection`是`column`，内容将只覆盖内容的高度。幸运的是，我们现在知道如何填充剩余空间。给我们的容器添加`flex
    1`将使其在垂直方向上覆盖屏幕长度，这给我们以下结果：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![Horizontal and vertical centering](img/5162_04_10.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![水平和垂直居中](img/5162_04_10.jpg)'
- en: This completes our overview of layout with Flexbox! For the entire list of supported
    Flexbox properties, check out the React Native documentation at [https://facebook.github.io/react-native/docs/flexbox.html#content](https://facebook.github.io/react-native/docs/flexbox.html#content).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对Flexbox布局的概述！有关支持的Flexbox属性的完整列表，请查看React Native文档[https://facebook.github.io/react-native/docs/flexbox.html#content](https://facebook.github.io/react-native/docs/flexbox.html#content)。
- en: Absolute positioning
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绝对定位
- en: Additionally, React Native gives you the option of positioning the items on
    your screen. This works the same way as it does in the browser by defining the
    `top`, `left`, `right`, and `bottom` properties. We recommend that you try to
    create your layout in Flexbox before resorting to absolute positioning.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，React Native还提供了将屏幕上的项目定位的选项。这通过定义`top`、`left`、`right`和`bottom`属性与浏览器中的方式相同。我们建议你在求助于绝对定位之前，尝试使用Flexbox创建你的布局。
- en: Styling the NavigationBar component
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计NavigationBar组件
- en: 'It''s time to give our `NavigationBar` the iOS and Android style treatment.
    There is a small difference between the two, except for how the font size and
    padding are rendered. We will start by giving our `NavigationBar` a background
    color and a bottom border. Add this to the `StyleSheet` in `index.ios.js` and
    `index.android.js` and define the `navbar` style:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候给我们的`NavigationBar`添加iOS和Android的样式处理了。两者之间只有细微的差别，除了字体大小和填充的渲染方式。我们将首先为`NavigationBar`添加背景颜色和底部边框。将以下内容添加到`index.ios.js`和`index.android.js`中的`StyleSheet`，并定义`navbar`样式：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, update the `Navigator.NavigatorBar` with the style prop:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用样式属性更新`Navigator.NavigatorBar`：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The last things to be updated are our `navbar` title and `SimpleButton` styles.
    We want the text to be `centered` vertically as well as to give the left-hand
    and right-hand buttons some padding from the sides of the screen:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要更新的是我们的`navbar`标题和`SimpleButton`样式。我们希望文本在垂直方向上居中，同时给屏幕的左右两侧按钮一些填充：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As we alluded to earlier, the `marginVertical` for iOS is different than the
    Android version to produce the same visual result.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，iOS的`marginVertical`与Android版本不同，以产生相同的视觉效果。
- en: 'Finally, update the `NavigationBarRouteMapper` to include the styles for the
    title and buttons:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新`NavigationBarRouteMapper`以包含标题和按钮的样式：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![Styling the NavigationBar component](img/5162_04_11.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![设计NavigationBar组件](img/5162_04_11.jpg)'
- en: 'Make a note of how the iOS version, for which we have changed the status bar
    text to appear white. React Native provides an API to interact with the status
    bar in iOS. In our `index.ios.js` we can toggle it to white in the `ReactNotes`
    constructor:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们更改了iOS版本的状态栏文本颜色为白色。React Native提供了一个API来与iOS中的状态栏交互。在我们的`index.ios.js`中，我们可以在`ReactNotes`构造函数中将它切换为白色：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The documentation for `StatusBarIOS` can be found in the React Native documentation
    at [https://facebook.github.io/react-native/docs/statusbarios.html](https://facebook.github.io/react-native/docs/statusbarios.html).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`StatusBarIOS`的文档可以在React Native文档中找到，链接为[https://facebook.github.io/react-native/docs/statusbarios.html](https://facebook.github.io/react-native/docs/statusbarios.html)。'
- en: Changing the Android Material Theme
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改Android Material主题
- en: 'The color of the status and navigation bar on our Android application appears
    to be solid black. Currently, there is no support system in React Native to style
    these from JavaScript like what the `StatusBarIOS` API provides on iOS. We can
    still use the Material Theme (available in Android 5.0 and above), located in
    `ReactNotes/android/app/src/6main/res/values/styles.xml`, to apply the colors
    we want. Change the contents of `styles.xml` to the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们Android应用程序的状态栏和导航栏颜色看起来是纯黑色。目前，React Native没有提供从JavaScript中样式化这些元素的支持系统，就像iOS上的`StatusBarIOS`
    API所提供的那样。我们仍然可以使用Android 5.0及以上版本中可用的Material Theme（位于`ReactNotes/android/app/src/6main/res/values/styles.xml`），来应用我们想要的颜色。将`styles.xml`的内容更改为以下内容：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `colorPrimaryDark` refers to the color of the status bar, whereas `navigationBarColor`
    is the color of the bottom navigation container. When you re-launch the application
    you should be able to see the status and navigation bars colored correctly.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`colorPrimaryDark`指的是状态栏的颜色，而`navigationBarColor`是底部导航容器的颜色。当你重新启动应用程序时，你应该能够看到状态栏和导航栏正确着色。'
- en: '![Changing the Android Material Theme](img/5162_04_12.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![更改Android Material主题](img/5162_04_12.jpg)'
- en: For more information on using the Material Theme, refer to the Android developers
    documentation at [https://developer.android.com/training/material/theme.html](https://developer.android.com/training/material/theme.html).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于使用Material主题的信息，请参考Android开发者文档中的[https://developer.android.com/training/material/theme.html](https://developer.android.com/training/material/theme.html)。
- en: Styling the NoteScreen
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计NoteScreen
- en: 'Our `NoteScreen` has two `TextInputs` without any styles. As of right now,
    it''s difficult to see where each input rests on the screen. It is common on iOS
    and Android to put an underline under each input. To achieve this, we are going
    to wrap our `TextInput` in `View` and apply `borderBottom` to it:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `NoteScreen` 有两个没有任何样式的 `TextInput`。到目前为止，很难看到每个输入在屏幕上的位置。在 iOS 和 Android
    上，通常会在每个输入下添加下划线。为了实现这一点，我们将 `TextInput` 包裹在 `View` 中，并对其应用 `borderBottom`：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The existing title and body styles define the height of each `TextInput`. Since
    each input will share the `flex` properties and text size, we can define a shared
    style:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的标题和正文样式定义了每个 `TextInput` 的高度。由于每个输入都将共享 `flex` 属性和文本大小，我们可以定义一个共享样式：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, in each input style we can pass an array to include both styles:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在输入样式中，我们可以传递一个数组来包含这两种样式：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![Styling the NoteScreen](img/5162_04_13.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![对 NoteScreen 进行样式设计](img/5162_04_13.jpg)'
- en: 'This doesn''t look right on Android yet. The `TextInputs` on Android have a
    default underline and they center the text vertically on multiline inputs. There
    are two Android only attributes that can be added to match the look of the iOS
    application. On each `TextInput` set the `underlineColorAndroid` as `transparent`
    and `textAlignVertical` on the body as `TextInput`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 上这看起来还不正确。Android 上的 `TextInput` 有一个默认的下划线，并且它们在多行输入中垂直居中文本。有两个仅适用于
    Android 的属性可以添加以匹配 iOS 应用程序的外观。在每个 `TextInput` 上设置 `underlineColorAndroid` 为 `transparent`，并在正文中将
    `textAlignVertical` 设置为 `TextInput`：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![Styling the NoteScreen](img/5162_04_14.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![对 NoteScreen 进行样式设计](img/5162_04_14.jpg)'
- en: With this we get the same look on both devices! This wraps up the styling of
    the components we created in the previous chapter. Henceforth, we are going to
    style as soon as we add new components to our application.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以在两个设备上获得相同的外观！这完成了我们在上一章中创建的组件的样式设计。从现在开始，每当我们向我们的应用程序添加新组件时，我们就会立即进行样式设计。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Styles in React Native are very similar to how CSS works in browser. In this
    chapter, you learned how to create and manage Style Sheets and add them to your
    components. If you ever find yourself frustrated with the layout then use the
    Flexbox section as a guide. Make sure to review where your `main-axis` and `cross-axis`
    are defined, as well as where the `flex` items are aligned along them. Feel free
    to go back to our components and play around with any of the styles before continuing
    with the next chapter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: React Native 中的样式与浏览器中 CSS 的工作方式非常相似。在本章中，你学习了如何创建和管理样式表并将它们添加到你的组件中。如果你在布局方面感到沮丧，请将
    Flexbox 部分作为指南。确保回顾你的 `main-axis` 和 `cross-axis` 的定义位置，以及 `flex` 项目沿着它们对齐的位置。在继续下一章之前，你可以自由地回到我们的组件中并尝试任何样式。
