- en: Chapter 3. TypeScript Crash Course
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 TypeScript Crash Course
- en: In this chapter, we are going to start working with TypeScript, the language
    Angular 2 recommends for scripting. All the features ECMAScript 2015 and respectively
    ECMAScript 2016 provides, such as functions, classes, modules, and decorators,
    are already implemented in or added to the roadmap of TypeScript. Because of the
    extra type annotations, there are some syntactical additions compared to JavaScript.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始使用TypeScript，这是Angular 2推荐的脚本语言。ECMAScript 2015和ECMAScript 2016提供的所有功能，如函数、类、模块和装饰器，已经在TypeScript中实现或添加到路线图中。由于额外的类型注解，与JavaScript相比，有一些语法上的补充。
- en: For smoother transition from the language we already know - ES5, we will start
    with some common features between ES2016 and TypeScript. Where there are differences
    between the ES syntax and TypeScript, we'll explicitly mention it. In the second
    half of the chapter, we'll add the type annotations to everything we've learned
    until this point.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更顺畅地从我们已经了解的语言ES5过渡，我们将从ES2016和TypeScript之间的一些共同特性开始。在ES语法和TypeScript之间存在差异的地方，我们将明确提到。在本章的后半部分，我们将为我们到目前为止学到的所有内容添加类型注解。
- en: Later in the chapter, we will explain the extra features TypeScript provides,
    such as static typing and extended syntax. We will discuss the different consequences
    based on these features, which will help us be more productive and less error-prone.
    Let's get going!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我们将解释TypeScript提供的额外功能，如静态类型和扩展语法。我们将讨论基于这些功能的不同后果，这将帮助我们更加高效和减少出错。让我们开始吧！
- en: Introduction to TypeScript
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript简介
- en: TypeScript is an open source programming language that is developed and maintained
    by Microsoft. Its initial public release was in October 2012\. TypeScript is a
    superset of ECMAScript, supporting all of the syntax and semantics of JavaScript
    with some extra features on top, such as static typing and richer syntax.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript是一种由微软开发和维护的开源编程语言。它最初是在2012年10月公开发布的。TypeScript是ECMAScript的超集，支持JavaScript的所有语法和语义，还有一些额外的功能，如静态类型和更丰富的语法。
- en: '*Fig. 1* shows the relationship between ES5, ES2015, ES2016, and TypeScript.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图1显示了ES5、ES2015、ES2016和TypeScript之间的关系。
- en: '![Introduction to TypeScript](../images/00009.jpeg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![TypeScript简介](../images/00009.jpeg)'
- en: Fig. 1
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图1
- en: Because TypeScript is statically typed, it can provide a number of benefits
    to us as JavaScript developers. Let's have a quick look at those benefits now.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于TypeScript是静态类型的，它可以为我们作为JavaScript开发人员提供许多好处。现在让我们快速看一下这些好处。
- en: Compile-time type checking
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译时类型检查
- en: Some of the most common mistakes we make while writing JavaScript code is to
    misspell a property or a method name. We'll find out about the mistake when we
    get a runtime error. This can happen during development as well as in production.
    Hoping we will know about the error before we deploy our code to production environment
    isn't a comfortable feeling! However, this is not a problem specific to JavaScript;
    it is something common to all the dynamic languages. Even with lots of unit tests,
    these errors can slip by.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在编写JavaScript代码时常犯的一些常见错误是拼错属性或方法名。当我们遇到运行时错误时，我们会发现这个错误。这可能发生在开发过程中，也可能发生在生产环境中。希望在部署代码到生产环境之前我们能知道错误并不是一种舒适的感觉！然而，这不是JavaScript特有的问题；这是所有动态语言共有的问题。即使有很多单元测试，这些错误也可能会漏掉。
- en: TypeScript provides a compiler, which takes care of such mistakes for us by
    using static code analysis. If we take advantage of static typing, TypeScript
    will be aware of the existing properties a given object has, and if we misspell
    any of them, the compiler will warn us with a compile-time error.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript提供了一个编译器，通过静态代码分析来为我们处理这些错误。如果我们利用静态类型，TypeScript将意识到给定对象具有的现有属性，如果我们拼错了其中任何一个，编译器将在编译时警告我们。
- en: Another great benefit of TypeScript is that it allows large teams to collaborate,
    since it provides formal, verifiable naming. This way, it allows us to write easy-to-understand
    code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的另一个巨大好处是它允许大型团队合作，因为它提供了正式的、可验证的命名。这样，它允许我们编写易于理解的代码。
- en: Better support by text editors and IDEs
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本编辑器和集成开发环境提供更好的支持
- en: There are a number of tools, such as **Tern** or **Google** **Closure Compiler**,
    that are trying to bring better autocompletion support for JavaScript in text
    editors and IDEs. However, as JavaScript is a dynamic language, it is impossible
    for the IDEs and text editors to make sophisticated suggestions without any metadata.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具，如Tern或Google Closure Compiler，它们试图为文本编辑器和集成开发环境提供更好的JavaScript自动补全支持。然而，由于JavaScript是一种动态语言，没有任何元数据，文本编辑器和集成开发环境无法提出复杂的建议。
- en: Annotating the code with such metadata is a built-in feature of TypeScript known
    as type annotations. Based on them, text editors and IDEs can perform better static
    analysis over our code. This provides better refactoring tools and autocompletion,
    which increases our productivity and allows us to make fewer mistakes while writing
    the source code for our applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 用这些元数据注释代码是TypeScript的内置特性，称为类型注解。基于它们，文本编辑器和集成开发环境可以对我们的代码进行更好的静态分析。这提供了更好的重构工具和自动补全，这增加了我们的生产力，使我们在编写应用程序源代码时犯更少的错误。
- en: There's even more to TypeScript
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript甚至更多
- en: 'TypeScript by itself has a number of other benefits:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript本身还有许多其他好处：
- en: '**It is a superset of JavaScript**: All JavaScript (ES5 and ES2015) programs
    are already valid TypeScript ones. In essence, you have already been writing TypeScript
    code. Since it is based on the latest version of the ECMAScript standard, it allows
    us to take advantage of the latest bleeding edge syntax provided by the language.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是JavaScript的超集：所有JavaScript（ES5和ES2015）程序已经是有效的TypeScript程序。实质上，您已经在编写TypeScript代码。由于它基于ECMAScript标准的最新版本，它允许我们利用语言提供的最新的前沿语法。
- en: '**Supports optional type checking**: If, for any reason, we decide that we
    don''t want to explicitly define the type of a variable or a method, we can just
    skip the type definition. However, we should be aware that this means we are no
    longer taking advantage of the static typing, so we are giving up on all the benefits
    mentioned earlier.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持可选类型检查：如果出于任何原因，我们决定不想明确定义变量或方法的类型，我们可以跳过类型定义。然而，我们应该意识到这意味着我们不再利用静态类型，因此放弃了前面提到的所有好处。
- en: '**Developed and maintained by Microsoft**: The quality of the implementation
    of the language is very high and it is unlikely that support will be dropped unexpectedly.
    TypeScript is based on the work of some of the world''s best experts in programming
    language development.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由微软开发和维护：语言实现的质量非常高，不太可能会突然停止支持。TypeScript基于世界上一些最优秀的编程语言开发专家的工作。
- en: '**It is open source**: This allows the community to freely contribute to the
    language and suggest features, which are discussed in an open manner. The fact
    that TypeScript is open source allows for the easier development of third-party
    extensions and tools, which extends further the scope of its usage.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它是开源的**：这允许社区自由地为语言做出贡献并提出功能，这些功能是以开放的方式讨论的。TypeScript是开源的事实使得第三方扩展和工具更容易开发，从而进一步扩展了其使用范围。'
- en: Since modern browsers do not support TypeScript natively, there is a compiler
    that translates the TypeScript code we write into readable JavaScript in a predefined
    target version of ECMAScript. Once the code is compiled, all the type annotations
    are removed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现代浏览器不支持TypeScript本地，因此有一个编译器将我们编写的TypeScript代码转换为预定义版本的ECMAScript可读的JavaScript。一旦代码编译完成，所有类型注释都将被移除。
- en: Using TypeScript
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TypeScript
- en: Let's start writing some TypeScript!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写一些TypeScript！
- en: In the following sections, we are going to take a look at different snippets
    showing some of the features of TypeScript. In order to be able to run the snippets
    and play with them yourself, you'll need to install the TypeScript compiler on
    your computer. Let's take a look at how to do this.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看一些展示TypeScript功能的不同片段。为了能够运行这些片段并自己玩耍，您需要在计算机上安装TypeScript编译器。让我们看看如何做到这一点。
- en: TypeScript is best installed using **Node Package Manager** (**npm**). I'd recommend
    you to use npm Version 3.0.0 or newer. If you don't have node.js and npm installed
    already, you can visit [https://nodejs.org](https://nodejs.org) and follow the
    instructions there.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最好使用**Node Package Manager**（**npm**）安装TypeScript。我建议您使用npm版本3.0.0或更新版本。如果您尚未安装node.js和npm，可以访问[https://nodejs.org](https://nodejs.org)并按照那里的说明进行操作。
- en: Installing TypeScript with npm
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用npm安装TypeScript
- en: 'Once you have npm installed and running, verify that you have the latest version
    by opening your terminal window and running the following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您安装并运行了npm，请通过打开终端窗口并运行以下命令来验证您是否拥有最新版本：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In order to install TypeScript 1.8, use:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装TypeScript 1.8，请使用：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding command will install the TypeScript compiler and add its executable
    (`tsc`) as global to your path.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将安装TypeScript编译器，并将其可执行文件（`tsc`）添加为全局路径。
- en: 'In order to verify that everything works properly, you can use:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证一切是否正常工作，您可以使用：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The output should be similar to the preceding one, though possibly with a different
    version.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于上面的输出，尽管可能使用不同的版本。
- en: Running our first TypeScript program
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行我们的第一个TypeScript程序
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code for this book on the following URL: [https://github.com/mgechev/switching-to-angular2](https://github.com/mgechev/switching-to-angular2).
    As a comment in most code snippets you''ll find a relative to the `app` directory
    file path where you can find them.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下URL找到本书的代码：[https://github.com/mgechev/switching-to-angular2](https://github.com/mgechev/switching-to-angular2)。在大多数代码片段中，您会找到一个相对于`app`目录的文件路径，您可以在那里找到它们。
- en: 'Now, let''s compile our first TypeScript program! Create a file called `hello.ts`
    and enter the following content:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编译我们的第一个TypeScript程序！创建一个名为`hello.ts`的文件，并输入以下内容：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Since you''ve already installed the TypeScript compiler, you should have a
    global executable command called `tsc`. You can use it in order to compile the
    file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您已经安装了TypeScript编译器，您应该有一个名为`tsc`的全局可执行命令。您可以使用它来编译文件：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, you should see the file `hello.js` in the same directory where `hello.ts`
    is. `hello.js` is the output of the TypeScript compiler; it contains the JavaScript
    equivalent to the TypeScript you wrote. You can run this file using the following
    command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该在`hello.ts`所在的同一目录中看到文件`hello.js`。`hello.js`是TypeScript编译器的输出；它包含了你编写的TypeScript的JavaScript等价物。你可以使用以下命令运行这个文件：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, you''ll see the string `Hello world!` printed on the screen. In order
    to combine the process of compiling and running the program, you can use the package
    `ts-node`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你会在屏幕上看到字符串`Hello world!`。为了结合编译和运行程序的过程，你可以使用`ts-node`包：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now you can run:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以运行：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You should see the same result, but without the `ts-node` file stored on the
    disk.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到相同的结果，但是没有存储在磁盘上的`ts-node`文件。
- en: TypeScript syntax and features introduced by ES2015 and ES2016
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript语法和特性是由ES2015和ES2016引入的。
- en: As TypeScript is a superset of JavaScript, before we start learning about its
    syntax, it's a little easier to start by introducing some of the bigger changes
    in ES2015 and ES2016; to understand TypeScript, we first must understand ES2015
    and ES2016\. We're going to have a whistle-stop tour through these changes before
    diving in to TypeScript proper later.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于TypeScript是JavaScript的超集，在我们开始学习它的语法之前，先介绍ES2015和ES2016中的一些重大变化会更容易一些；要理解TypeScript，我们首先必须理解ES2015和ES2016。在深入学习TypeScript之前，我们将快速浏览这些变化。
- en: 'A detailed explanation of ES2015 and ES2016 is outside the scope of this book.
    In order to get familiar with all the new features and syntaxes, I strongly recommend
    you to take a look at *Exploring ES6: upgrade to the next version of JavaScript*
    by *Dr. Axel Rauschmayer*.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '本书不涵盖ES2015和ES2016的详细解释。为了熟悉所有新特性和语法，我强烈建议你阅读*Exploring ES6: upgrade to the
    next version of JavaScript* by *Dr. Axel Rauschmayer*。'
- en: The next couple of pages will introduce new standards and allow you to take
    advantage of most of the features you're going to need in the development of Angular
    2 applications.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几页将介绍新的标准，并让你利用大部分你在开发Angular 2应用程序中需要的特性。
- en: ES2015 arrow functions
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ES2015箭头函数
- en: 'JavaScript has first class functions, which means that they can be passed around
    like any other value:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript具有一级函数，这意味着它们可以像其他值一样传递：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This syntax is great; however, it is a bit too verbose. ES2015 introduced a
    new syntax to define anonymous functions called the arrow function syntax. Using
    it, we can create anonymous functions, as seen in the following examples:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法很棒；但是有点太啰嗦了。ES2015引入了一种新的语法来定义匿名函数，称为箭头函数语法。使用它，我们可以创建匿名函数，就像下面的例子中所示：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the first example, we got the total sum of the elements in the array `[1,
    2, 3]`. In the second example, we got all the even numbers inside the array `[3,
    1, 56, 7]`. In the third example, we sorted an array by the properties' `price`
    and `total` in the ascending order.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们得到了数组`[1, 2, 3]`中元素的总和。在第二个例子中，我们得到了数组`[3, 1, 56, 7]`中所有的偶数。在第三个例子中，我们按照属性`price`和`total`的升序对数组进行了排序。
- en: 'Arrow functions have a few more features that we need to look at. The most
    important one of them is that they keep the context (`this`) from the surrounding
    code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数还有一些我们需要看看的特性。其中最重要的一个是它们会保持周围代码的上下文(`this`)。
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For example, when we invoke the function `MyComponent` with the operator `new`,
    this will point to the new object instantiated by the call. The arrow function
    will keep the context (`this`), in the callback of `setTimeout`, and print **43**
    on the screen.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们使用`new`操作符调用函数`MyComponent`时，`this`将指向调用实例化的新对象。箭头函数将保持上下文(`this`)，在`setTimeout`的回调中，屏幕上会打印**43**。
- en: This is extremely useful in Angular 2, since the binding context for a given
    component is its instance (that is, its `this`). If we define `MyComponent` as
    an Angular 2 component and we have a binding to the `age` property, the preceding
    code will be valid and all the bindings will work (notice that we don't have scope,
    neither do we have explicit calls to the `$digest` loop although we have called
    `setTimeout` directly).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这在Angular 2中非常有用，因为给定组件的绑定上下文是其实例（即其`this`）。如果我们将`MyComponent`定义为Angular 2组件，并且我们有一个绑定到`age`属性，前面的代码将是有效的，并且所有绑定将起作用（请注意，我们没有作用域，也没有显式调用`$digest`循环，尽管我们直接调用了`setTimeout`）。
- en: Using the ES2015 and ES2016 classes
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ES2015和ES2016类
- en: When developers new to JavaScript hear that the language empowers the **object-oriented**
    (**OO**) paradigm, they're normally confused when they discover that there's no
    syntax for the definition of classes. This perception was born by the fact that
    some of the most popular programming languages, such as Java, C#, and C++, have
    the concept of classes used for the construction of objects. However, JavaScript
    implements the OO paradigm differently. JavaScript has a prototype-based, object-oriented
    programming model, where we can instantiate objects using the object literal syntax
    or functions (also known as the constructor functions) and we can take advantage
    of the inheritance using the so-called prototype chain.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当初次接触JavaScript的开发人员听说语言赋予了**面向对象**（**OO**）范式的能力时，当他们发现没有类的定义语法时，他们通常会感到困惑。这种看法是由于一些最流行的编程语言，如Java、C#和C++，具有用于构建对象的类的概念。然而，JavaScript以不同的方式实现了面向对象范式。JavaScript具有基于原型的面向对象编程模型，我们可以使用对象字面量语法或函数（也称为构造函数）来实例化对象，并且我们可以利用所谓的原型链来实现继承。
- en: Though this is a valid way to implement the OO paradigm and the semantics are
    similar to the one in the classical object-oriented model, it is confusing for
    inexperienced JavaScript developers who are not sure how to process this properly.
    This is one of the reasons TC39 decided to provide an alternative syntax to exploit
    the object-oriented paradigm in the language. Behind the scenes, the new syntax
    has the same semantics as the one we're used to, like using the constructor functions
    and the prototype-based inheritance. However, it provides a more convenient syntax
    to empower the OO paradigm's features with less boilerplate.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一种实现面向对象范式的有效方式，语义与经典面向对象模型中的方式类似，但对于经验不足的JavaScript开发人员来说，他们不确定如何正确处理这一点，这是TC39决定提供一种替代语法来利用语言中的面向对象范式的原因之一。在幕后，新的语法与我们习惯的语法具有相同的语义，比如使用构造函数和基于原型的继承。然而，它提供了一种更方便的语法，以减少样板代码来增强面向对象范式的特性。
- en: ES2016 adds some extra syntax to the ES2015 classes, such as static and instance
    property declaration.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ES2016为ES2015类添加了一些额外的语法，例如静态和实例属性声明。
- en: 'Here is an example that demonstrates the syntax used to define the classes
    in ES2016:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，演示了ES2016中用于定义类的语法：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In ES2015, the explicit declaration of the `_name` property is not required;
    however, since the TypeScript compiler should be aware during compile-time of
    the existing properties of the instances of a given class, we would need to add
    the declaration of the property to the class declaration itself.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES2015中，不需要显式声明`_name`属性；然而，由于TypeScript编译器在编译时应该知道给定类的实例的现有属性，我们需要将属性的声明添加到类声明本身中。
- en: The preceding snippet is both a valid TypeScript and JavaScript code. In it,
    we defined a class called `Human`, which adds a single property to the objects
    instantiated by it. It does this by setting its value to the parameter name passed
    to its constructor.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段既是有效的TypeScript代码，也是JavaScript代码。 在其中，我们定义了一个名为`Human`的类，它向由它实例化的对象添加了一个属性。
    它通过将其值设置为传递给其构造函数的参数名称来实现这一点。
- en: 'Now, open the `ch3/es6-classes/sample-classes.ts` file and play around with
    it! You can create different instances of the classes the same way you create
    objects using constructor functions:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`ch3/es6-classes/sample-classes.ts`文件并进行操作！ 您可以以与使用构造函数创建对象相同的方式创建类的不同实例：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In order to execute the code, run the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行代码，请运行以下命令：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Classes are commonly used in Angular 2\. You can use them to define your components,
    directives, services, and pipes. However, you can also use the alternative ES5
    syntax, which takes advantage of the constructor functions. Under the hood, once
    the TypeScript code is compiled, there would be no such significant difference
    between both the syntaxes, because the ES2015 classes are being transpiled to
    constructor functions anyway.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 类通常在Angular 2中使用。 您可以使用它们来定义组件，指令，服务和管道。 但是，您还可以使用替代的ES5语法，该语法利用构造函数。 在幕后，一旦TypeScript代码被编译，两种语法之间将没有太大的区别，因为ES2015类最终被转译为构造函数。
- en: Defining variables with block scope
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用块作用域定义变量
- en: Another confusing point of JavaScript for developers with a different background
    is the variable scope in the language. In Java and C++, for example, we're used
    to the block lexical scope. This means that a given variable defined inside a
    specific block will be visible only inside that block and all of the nested blocks
    inside of it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript对具有不同背景的开发人员来说另一个令人困惑的地方是语言中的变量作用域。 例如，在Java和C ++中，我们习惯于块词法作用域。 这意味着在特定块内定义的给定变量只在该块内以及其中的所有嵌套块内可见。
- en: 'However, in JavaScript, things are a little bit different. ECMAScript defines
    a functional lexical scope that has similar semantics to the block lexical scope,
    but it uses functions instead of blocks. This means that we have the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在JavaScript中，情况有些不同。 ECMAScript定义了一个具有类似语义的函数词法作用域，但它使用函数而不是块。 这意味着我们有以下内容：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This has some weird implications. Once the code has been executed, it will log
    five times the number `5`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一些奇怪的含义。 一旦代码被执行，它将记录五次数字`5`。
- en: 'ES2015 added a new syntax to define the variables with block-scope visibility.
    The syntax is similar to the current one. However, instead of `var`, it uses the
    keyword `let`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ES2015添加了一种新的语法来定义具有块作用域可见性的变量。 语法与当前的语法类似。 但是，它使用关键字`let`而不是`var`：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Meta-programming with ES2016 decorators
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ES2016装饰器进行元编程
- en: 'JavaScript is a dynamic language that allows us to easily modify and/or alter
    the behavior to suit the programs we write. Decorators are a proposal to ES2016,
    which according to the design document [https://github.com/wycats/javascript-decorators](https://github.com/wycats/javascript-decorators):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种动态语言，允许我们轻松修改和/或改变行为以适应我们编写的程序。 装饰器是ES2016的一个提案，根据设计文档[https://github.com/wycats/javascript-decorators](https://github.com/wycats/javascript-decorators)：
- en: '*"…make it possible to annotate and modify classes and properties at design
    time."*'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“…使注释和修改类和属性在设计时成为可能。”*'
- en: Their syntaxes are quite similar to the annotations in Java, and they are even
    closer to the decorators in Python. ES2016 decorators are used commonly in Angular
    2 to define components, directives, and pipes, and to take advantage of the dependency
    injection mechanism of the framework. Essentially, most use cases of decorators
    involve altering the behavior to predefined logic or adding some metadata to different
    constructs.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的语法与Java中的注解非常相似，甚至更接近Python中的装饰器。ES2016装饰器在Angular 2中通常用于定义组件、指令和管道，并利用框架的依赖注入机制。基本上，装饰器的大多数用例涉及改变行为以预定义逻辑或向不同的结构添加一些元数据。
- en: ES2016 decorators allow us to do a lot of fancy things by changing the behavior
    of our programs. Typical use cases could be to annotate the given methods or properties
    as deprecated or read-only. A set of predefined decorators that can improve the
    readability of the code we produce can be found in a project by *Jay Phelps* called
    *core-decorators.js*. Another use case is taking advantage of the proxy-based
    aspect-oriented programming using a declarative syntax. The library providing
    this functionality is `aspect.js`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ES2016装饰器允许我们通过改变程序的行为来做很多花哨的事情。典型的用例可能是将给定的方法或属性标注为已弃用或只读。一组预定义的装饰器可以提高我们所生成的代码的可读性，可以在*Jay
    Phelps*的名为*core-decorators.js*的项目中找到。另一个用例是利用基于代理的面向方面编程，使用声明性语法。提供此功能的库是`aspect.js`。
- en: 'In general, ES2016 decorators are just another syntax sugar, which translates
    to the code we''re already familiar with from the previous versions of JavaScript.
    Let''s take a look at a simple example from the proposal''s draft:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，ES2016装饰器只是另一种语法糖，它转换成我们已经熟悉的来自JavaScript之前版本的代码。让我们看一个来自提案草案的简单示例：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this case, we have an ES2015 class called `Person` with a single getter
    called `kidCount`. Over the `kidCount` getter, we have applied the `nonenumerable`
    decorator. The decorator is a function that accepts a target (the `Person` class),
    the name of the target property we intend to decorate (`kidCount`), and the descriptor
    of the `target` property. After we change the descriptor, we need to return it
    in order to apply the modification. Basically, the decorator''s application could
    be translated into ECMAScript 5 in the following way:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有一个名为`Person`的ES2015类，其中有一个名为`kidCount`的单个getter。在`kidCount` getter上，我们应用了`nonenumerable`装饰器。装饰器是一个接受目标（`Person`类）、我们打算装饰的目标属性的名称（`kidCount`）和`target`属性的描述符的函数。在我们改变描述符之后，我们需要返回它以应用修改。基本上，装饰器的应用可以用以下方式转换成ECMAScript
    5：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using configurable decorators
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用可配置的装饰器
- en: 'Here is an example on using the decorators defined by Angular 2:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用Angular 2定义的装饰器的示例：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When decorators accept arguments (just like `Component`, `RouteConfig`, and
    `View` in the preceding example), they need to be defined as functions that accept
    arguments and return the actual decorator:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当装饰器接受参数（就像前面示例中的`Component`、`RouteConfig`和`View`一样），它们需要被定义为接受参数并返回实际装饰器的函数：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, we defined a configurable decorator called `Component` that
    accepts a single argument called `config` and returns a decorator.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了一个可配置的装饰器，名为`Component`，它接受一个名为`config`的单个参数并返回一个装饰器。
- en: Writing modular code with ES2015
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ES2015编写模块化代码
- en: Another problem that JavaScript professionals have experienced along the years
    is the lack of a module system in the language. Initially, the community developed
    different patterns, aiming to enforce the modularity and the encapsulation of
    the software we produce. Such patterns included the module pattern, which takes
    advantage of the functional lexical scope and closures. Another example is the
    namespace pattern, which represents the different namespaces as nested objects.
    AngularJS 1.x introduced its own module system that unfortunately doesn't provide
    features like lazy module loading. However, these patterns were more like workarounds
    rather than real solutions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript专业人士多年来经历的另一个问题是语言中缺乏模块系统。最初，社区开发了不同的模式，旨在强制执行我们生产的软件的模块化和封装。这些模式包括模块模式，它利用了函数词法作用域和闭包。另一个例子是命名空间模式，它将不同的命名空间表示为嵌套对象。AngularJS
    1.x引入了自己的模块系统，不幸的是它不提供懒加载模块等功能。然而，这些模式更像是变通办法，而不是真正的解决方案。
- en: '**CommonJS** (used in node.js) and **AMD** (**Asynchronous Module Definition**)
    were later invented. They are still in wide use today and provide features, such
    as handling of circular dependencies, asynchronous module loading (in AMD), and
    so on.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**CommonJS**（在node.js中使用）和**AMD**（**异步模块定义**）后来被发明。它们仍然广泛使用，并提供功能，如处理循环依赖，异步模块加载（在AMD中），等等。'
- en: 'TC39 took the best of the existing module systems and introduced this concept
    on a language level. ES2015 provides two APIs to define and consume modules. They
    are as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: TC39吸收了现有模块系统的优点，并在语言级别引入了这个概念。ES2015提供了两个API来定义和消费模块。它们如下：
- en: Declarative API.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式API。
- en: Imperative API using the module loader.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块加载器的命令式API。
- en: Angular 2 takes full advantage of the ES2015 module system, so let's dive into
    it! In this section, we are going to take a look at the syntax used for the declarative
    definition and consumption of modules. We are also going to peek at the module
    loader's API in order to see how we can programmatically load modules in an explicit
    asynchronous manner.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2充分利用了ES2015模块系统，让我们深入研究一下！在本节中，我们将看一下用于声明性定义和消费模块的语法。我们还将窥探模块加载器的API，以便了解如何以显式异步方式编程加载模块。
- en: Using the ES2015 module syntax
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ES2015模块语法
- en: 'Let''s take a look at an example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding snippet, we defined a simple ES2015 module in the file `math.ts`.
    We can think of it as a sample math Angular 2 utility module. Inside it, we defined
    and exported the functions `square` and `log10`, and the constant `PI`. The `const`
    keyword is another keyword brought by ES2015 that is used to define constants.
    As you can see, what we do is nothing more than prefixing the function''s definitions
    with the keyword `export`. If we want to export the entire functionality in the
    end and skip the duplicate explicit usage of `export`, we can:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的片段中，我们在文件`math.ts`中定义了一个简单的ES2015模块。我们可以将其视为一个样本数学Angular 2实用模块。在其中，我们定义并导出了函数`square`和`log10`，以及常量`PI`。`const`关键字是ES2015带来的另一个关键字，用于定义常量。正如你所看到的，我们所做的不过是在函数定义前加上`export`关键字。如果我们最终想要导出整个功能并跳过重复显式使用`export`，我们可以：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The syntax on the last line is nothing more than an enhanced object literal
    syntax, introduced by ES2015\. Now, let''s take a look at how we can consume this
    module:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行的语法只不过是ES2015引入的增强对象文字语法。现在，让我们看看如何消费这个模块：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As an identifier of the module, we used its relative path to the current file.
    By using destructuring, we imported the required functions—in this case, `square`
    and `log10`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 作为模块的标识符，我们使用了相对于当前文件的路径。通过解构，我们导入了所需的函数——在这种情况下是`square`和`log10`。
- en: Taking advantage of the implicit asynchronous behavior
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用隐式的异步行为
- en: It is important to note that the ES2015 module syntax has implicit asynchronous
    behavior.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，ES2015模块语法具有隐式的异步行为。
- en: Let's say we have modules `A`, `B`, and `C`. Module `A` uses modules `B` and
    `C`, so it depends on them. Once the user requires module `A`, the JavaScript
    module loader would need to load modules `B` and `C` before being able to invoke
    any of the logic that resides in module `A` because of the dependencies we have.
    However, modules `B` and `C` will be loaded asynchronously. Once they are loaded
    completely, the JavaScript virtual machine will be able to execute module `A`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有模块`A`，`B`和`C`。模块`A`使用模块`B`和`C`，所以它依赖于它们。一旦用户需要模块`A`，JavaScript模块加载器就需要在能够调用模块`A`中的任何逻辑之前加载模块`B`和`C`，因为我们有依赖关系。然而，模块`B`和`C`将被异步加载。一旦它们完全加载，JavaScript虚拟机将能够执行模块`A`。
- en: Using aliases
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用别名
- en: 'Another typical situation is when we want to use an alias for a given export.
    For example, if we use a third-party library, we may want to rename any of its
    exports in order to escape name collisions or just to have a more convenient naming:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种典型的情况是当我们想要为给定的导出使用别名。例如，如果我们使用第三方库，我们可能想要重命名其任何导出，以避免名称冲突或只是为了更方便的命名：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Importing all the module exports
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入所有模块导出
- en: 'We can import the entire `math` module using:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下方式导入整个`math`模块：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The semantics behind this syntax is quite similar to CommonJS, although in the
    browser, we have implicit asynchronous behavior.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法背后的语义与CommonJS非常相似，尽管在浏览器中，我们有隐式的异步行为。
- en: Default exports
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认导出
- en: 'If a given module defines an export, which would quite likely be used by any
    of its consumer modules, we can take advantage of the default export syntax:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定模块定义了一个导出，这个导出很可能会被任何消费模块使用，我们可以利用默认导出语法：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In order to consume this module, we can use the following `app.ts` file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这个模块，我们可以使用以下`app.ts`文件：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Or, if we want to import the default export as well as some other exports,
    we can use:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们想要导入默认导出以及其他一些导出，我们可以使用：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In general, the default export is nothing more than a named export named with
    the reserved word `default`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，默认导出只是一个用保留字`default`命名的命名导出：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ES2015 module loader
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES2015模块加载器
- en: The new version of the standard defines a programmatic API to work with modules.
    This is the so-called module loader API. It allows us to define and import modules,
    or configure the module loading.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的新版本定义了一个用于处理模块的编程API。这就是所谓的模块加载器API。它允许我们定义和导入模块，或配置模块加载。
- en: 'Let''s suppose we have the following module definition in the file `app.js`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在文件`app.js`中有以下模块定义：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'From the file `init.js`, we can programmatically load the `app` module and
    invoke its `main` function using:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件`init.js`中，我们可以以编程方式加载`app`模块，并使用以下方式调用其`main`函数：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The global object `System` has a method called `import` that allows us to import
    modules using their identifier. In the preceding snippet, we imported the module
    `app` defined in `app.js`. `System.import` returns a promise that could be resolved
    on success or rejected in case of an error. Once the promise is resolved as the
    first parameter of the callback passed to `then`, we will get the module itself.
    The first parameter of the callback registered in case of rejection is the error
    that happened.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 全局对象`System`有一个名为`import`的方法，允许我们使用它们的标识符导入模块。在前面的片段中，我们导入了在`app.js`中定义的`app`模块。`System.import`返回一个promise，该promise在成功时可以解析，或在发生错误时被拒绝。一旦promise作为传递给`then`的回调的第一个参数解析，我们将得到模块本身。在拒绝的情况下注册的回调的第一个参数是发生的错误。
- en: The code from the last snippet does not exist in the GitHub repository, since
    it requires some additional configuration. We are going to apply the module loader
    more explicitly in the Angular 2 examples in the next chapters of the book.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一段代码不存在于GitHub存储库中，因为它需要一些额外的配置。我们将在本书的下一章中更明确地应用模块加载器在Angular 2示例中。
- en: ES2015 and ES2016 recap
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES2015和ES2016回顾
- en: Congratulations! We're more than halfway toward learning TypeScript. All the
    features we've just seen are a part of TypeScript, since it implements a superset
    of JavaScript and since all these features are an upgrade on top of the current
    syntax, they are easy to grasp by experienced JavaScript developers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们已经超过学习TypeScript的一半了。我们刚刚看到的所有功能都是TypeScript的一部分，因为它实现了JavaScript的超集，并且所有这些功能都是当前语法的升级，对于有经验的JavaScript开发人员来说很容易掌握。
- en: In the next sections, we will describe all the amazing features of TypeScript
    that are outside the intersection with ECMAScript.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将描述TypeScript的所有令人惊奇的功能，这些功能超出了与ECMAScript的交集。
- en: Taking advantage of static typing
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用静态类型
- en: Static typing is what can provide better tooling for our development process.
    While writing JavaScript, the most that IDEs and text editors can do is syntax
    highlighting and providing some basic autocompletion suggestions based on the
    sophisticated static analysis of our code. This means that we can only verify
    that we haven't made any typos by running the code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型是可以为我们的开发过程提供更好工具支持的。在编写JavaScript时，IDE和文本编辑器所能做的最多就是语法高亮和基于我们代码的复杂静态分析提供一些基本的自动补全建议。这意味着我们只能通过运行代码来验证我们没有犯任何拼写错误。
- en: In the previous sections, we described only the new features provided by ECMAScript
    expected to be implemented by browsers in the near future. In this section, we
    will take a look at what TypeScript provides in order to help us be less error-prone
    and more productive. At the time of this writing, there're no plans to implement
    built-in support for static typing in the browsers.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们只描述了ECMAScript提供的新功能，这些功能预计将在不久的将来由浏览器实现。在本节中，我们将看看TypeScript提供了什么来帮助我们减少错误，并提高生产力。在撰写本文时，尚无计划在浏览器中实现静态类型的内置支持。
- en: The TypeScript code goes through intermediate preprocessing that performs the
    type checking and drops all the type annotations in order to provide valid JavaScript
    supported by modern browsers.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript代码经过中间预处理，进行类型检查并丢弃所有类型注释，以提供现代浏览器支持的有效JavaScript。
- en: Using explicit type definitions
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用显式类型定义
- en: 'Just like Java and C++, TypeScript allows us to explicitly declare the type
    of the given variable:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Java和C++一样，TypeScript允许我们明确声明给定变量的类型：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding line defines the variable `foo` in the current block using the
    `let` syntax. We explicitly declare that we want `foo` to be of the type `number`
    and we set the value of `foo` to `42`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行使用`let`语法在当前块中定义变量`foo`。我们明确声明要将`foo`设置为`number`类型，并将`foo`的值设置为`42`。
- en: 'Now let''s try to change the value of `foo`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试更改`foo`的值：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here, after the declaration of `foo`, we will set its value to the string `''42''`.
    This is a perfectly valid JavaScript code; however, if we compile it using the
    TypeScript''s compiler, we will get:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在声明`foo`之后，我们将其值设置为字符串`'42'`。这是完全有效的JavaScript代码；然而，如果我们使用TypeScript的编译器编译它，我们将得到：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once `foo` has been associated with the given type, we cannot assign it values
    belonging to different types. This is one of the reasons we can skip the explicit
    type definition in case we assign a value to the given variable:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`foo`与给定类型关联，我们就不能为其分配属于不同类型的值。这是我们可以跳过显式类型定义的原因之一，如果我们为给定变量分配一个值：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The semantics behind this code will be the same as the one with the explicit
    type definition because of the type inference of TypeScript. We'll further take
    a look at it at the end of this chapter.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码背后的语义将与显式类型定义的代码相同，因为 TypeScript 的类型推断。我们将在本章末进一步研究它。
- en: The type any
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任意类型
- en: 'All the types in TypeScript are subtypes of a type called `any`. We can declare
    variables belonging to the `any` type by using the `any` keyword. Such variables
    can hold the value of `any` type:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 中的所有类型都是称为 `any` 的类型的子类型。我们可以使用 `any` 关键字声明属于 `any` 类型的变量。这样的变量可以保存
    `any` 类型的值：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding code is a valid TypeScript, and it will not throw any error during
    compilation or runtime. If we use the type `any` for all of our variables, we
    will be basically writing the code with dynamic typing, which drops all the benefits
    of the TypeScript's compiler. That's why we have to be careful with `any` and
    use it only when it is necessary.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是有效的 TypeScript 代码，在编译或运行时不会抛出任何错误。如果我们对所有变量使用类型 `any`，基本上就是使用动态类型编写代码，这会丧失
    TypeScript 编译器的所有优势。这就是为什么我们必须小心使用 `any`，只有在必要时才使用它。
- en: 'All the other types in TypeScript belong to one of the following categories:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 中的所有其他类型都属于以下类别之一：
- en: '**Primitive types**: This includes Number, String, Boolean, Void, Null, Undefined,
    and Enum types.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始类型**：这包括 Number、String、Boolean、Void、Null、Undefined 和 Enum 类型。'
- en: '**Union types**: Union types are out of the scope of this book. You can take
    a look at them in the specification of TypeScript.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**联合类型**：联合类型超出了本书的范围。您可以在 TypeScript 规范中查看它们。'
- en: '**Object types**: This includes Function types, classes and interface type
    references, array types, tuple types, function types, and constructor types.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象类型**：这包括函数类型、类和接口类型引用、数组类型、元组类型、函数类型和构造函数类型。'
- en: '**Type parameters**: This includes Generics that are going to be described
    in the *Writing generic code by using type parameters* section.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型参数**：这包括将在 *使用类型参数编写通用代码* 部分中描述的泛型。'
- en: Understanding the Primitive types
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解原始类型
- en: 'Most of the primitive types in TypeScript are the ones we are already familiar
    with in JavaScript: Number, String, Boolean, Null, and Undefined. So, we are going
    to skip their formal explanation here. Another set of types that is handy while
    developing Angular 2 applications is the Enum types defined by users.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 中大多数原始类型都是我们在 JavaScript 中已经熟悉的类型：Number、String、Boolean、Null 和 Undefined。因此，我们将跳过它们的正式解释。另一组在开发
    Angular 2 应用程序时很方便的类型是用户定义的枚举类型。
- en: The Enum types
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举类型
- en: 'The Enum types are primitive user-defined types that, according to the specification,
    are subclasses of Number. The concept of `enums` exists in the Java, C++, and
    C# languages, and it has the same semantics in TypeScript—user-defined types consisting
    of sets of named values called elements. In TypeScript, we can define `enum` using
    the following syntax:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举类型是原始用户定义类型，根据规范，它们是 Number 的子类。`enums` 的概念存在于 Java、C++ 和 C# 语言中，在 TypeScript
    中具有相同的语义——由一组命名值元素组成的用户定义类型。在 TypeScript 中，我们可以使用以下语法定义 `enum`：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is going to be translated to the following JavaScript:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这将被翻译为以下 JavaScript：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can use the `enum` type as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下使用 `enum` 类型：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Understanding the Object types
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解对象类型
- en: In this section, we're going to take a look at the Array types and Function
    types, which belong to the more generic class of Object types. We will also explore
    how we can define classes and interfaces. Tuple types were introduced by TypeScript
    1.3, and their main purpose is to allow the language to begin typing the new features
    introduced by ES2015, such as destructuring. We will not describe them in this
    book. For further reading you can take a look at the language's specification
    at [http://www.typescriptlang.org](http://www.typescriptlang.org).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看一下数组类型和函数类型，它们属于更通用的对象类型类。我们还将探讨如何定义类和接口。元组类型是由TypeScript 1.3引入的，它们的主要目的是允许语言开始对ES2015引入的新功能进行类型化，比如解构。我们不会在本书中描述它们。想要进一步阅读可以查看语言规范[http://www.typescriptlang.org](http://www.typescriptlang.org)。
- en: The Array types
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组类型
- en: In TypeScript, arrays are JavaScript arrays with a common element type. This
    means that we cannot have elements from different types in a given array. We have
    different array types for all the built-in types in TypeScript, plus all the custom
    types that we define.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，数组是具有共同元素类型的JavaScript数组。这意味着我们不能在给定数组中有不同类型的元素。我们为TypeScript中的所有内置类型以及我们定义的所有自定义类型都有不同的数组类型。
- en: 'We can define an array of numbers as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个数字数组如下：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If we want to have an array, which seems heterogeneous, similar to the arrays
    in JavaScript, we can use the type reference to `any`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个看起来杂种的数组，类似于JavaScript中的数组，我们可以使用类型引用`any`：
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is possible, since the types of all the values we're pushing to the array
    are subtypes of the `any` type and the array we've declared contains values of
    the type `any`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可能的，因为我们推送到数组的所有值的类型都是`any`类型的子类型，我们声明的数组包含类型为`any`的值。
- en: 'We can use the array methods we''re familiar with in JavaScript with all the
    TypeScript Array types:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在TypeScript数组类型中使用我们熟悉的JavaScript数组方法：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We also have the square-brackets operator that gives us random access to the
    array''s elements:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有方括号运算符，它给我们提供对数组元素的随机访问：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The Function types
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数类型
- en: The function types are a set of all the functions with different signatures,
    including the different number of arguments, different arguments' types, or different
    types of the return result.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 函数类型是一组具有不同签名的所有函数，包括不同数量的参数、不同参数类型或不同返回结果类型。
- en: 'We''re already familiar with how to create a new function in JavaScript. We
    can use function expression or function declaration:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉如何在JavaScript中创建新函数。我们可以使用函数表达式或函数声明：
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Or, we can use the new arrow function syntax:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用新的箭头函数语法：
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The only thing TypeScript alters is the feature to define the types of the
    function''s arguments and the type of its return result. After the compiler of
    the language performs its type checking and transpilation, all the type annotations
    will be removed. If we use function expression and we assign a function to a variable,
    we will be able to define the variable type in the following way:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript唯一改变的是定义函数参数类型和返回结果类型的功能。语言编译器执行类型检查和转译后，所有类型注释都将被移除。如果我们使用函数表达式并将函数分配给变量，我们可以按照以下方式定义变量类型：
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In case of `function declaration`, we''ll have:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在`函数声明`的情况下，我们将有：
- en: '[PRE47]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we want to define a method in a object literal, we can process it in the
    following way:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在对象字面量中定义一个方法，我们可以按照以下方式处理它：
- en: '[PRE48]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the preceding example, we defined an object literal using the ES2015 syntax
    that defines the method `squareRoot`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了ES2015语法定义了一个对象字面量，其中定义了方法`squareRoot`。
- en: 'In case we want to define a function that produces some side effects instead
    of returning a result, we can define it as a `void` function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想定义一个产生一些副作用而不是返回结果的函数，我们可以将其定义为`void`函数：
- en: '[PRE49]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Defining classes
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义类
- en: 'TypeScript classes are similar to what ES2015 offers. However, it alters the
    type declarations and creates more syntax sugar. For example, let''s take the
    `Human` class we defined earlier and make it a valid TypeScript class:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript类与ES2015提供的类似。然而，它改变了类型声明并创建了更多的语法糖。例如，让我们把之前定义的`Human`类变成一个有效的TypeScript类：
- en: '[PRE50]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'There is no difference between the current TypeScript definition with the one
    we already introduced, however, in this case the declaration of the `_name` property
    is mandatory. Here is how we can use the class:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的TypeScript定义与我们已经介绍的定义没有区别，然而，在这种情况下，`_name`属性的声明是必需的。以下是如何使用这个类的方法：
- en: '[PRE51]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Using access modifiers
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用访问修饰符
- en: 'Similarly, for most conventional object-oriented languages that support classes,
    TypeScript allows definition of access modifiers. In order to deny direct access
    to the `_name` property outside the class it is defined in, we can declare it
    as private:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于大多数支持类的传统面向对象语言，TypeScript允许定义访问修饰符。为了拒绝在类外部直接访问`_name`属性，我们可以将其声明为私有：
- en: '[PRE52]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The supported access modifiers by TypeScript are:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript支持的访问修饰符有：
- en: '**Public**: All the properties and methods declared as public could be accessed
    anywhere.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共**：所有声明为公共的属性和方法可以在任何地方访问。'
- en: '**Private**: All the properties and methods declared as private can be accessed
    only from inside the class'' definition itself.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有**：所有声明为私有的属性和方法只能从类的定义内部访问。'
- en: '**Protected**: All the properties and methods declared as protected can be
    accessed from inside the class'' definition or the definition of any other class
    extending the one that owns the property or the method.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受保护**：所有声明为受保护的属性和方法可以从类的定义内部或扩展拥有该属性或方法的任何其他类的定义中访问。'
- en: 'Access modifiers are a great way to implement Angular 2 services with good
    encapsulation and a well-defined interface. In order to understand it better,
    let''s take a look at an example using the class'' hierarchy defined earlier,
    which is ported to TypeScript:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 访问修饰符是实现具有良好封装和明确定义接口的Angular 2服务的好方法。为了更好地理解它，让我们看一个使用之前定义的类层次结构的示例，该类层次结构已转换为TypeScript：
- en: '[PRE53]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Just like ES2015, TypeScript supports the `extends` keyword and desugars it
    to the prototypal JavaScript inheritance.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 就像ES2015一样，TypeScript支持`extends`关键字，并将其解析为原型JavaScript继承。
- en: 'In the preceding example, we set the access modifiers of the `name` and `age`
    properties directly inside the constructor function. The semantics behind this
    syntax differs from the one used in the previous example. It has the following
    meaning: define a protected property called `name` of the type `string` and assign
    the first value passed to the constructor call to it. It is the same for the private
    `age` property. This saves us from explicitly setting the value in the constructor
    itself. If we take a look at the constructor of the `Developer` class, we can
    see that we can use the mixture between these syntaxes. We can explicitly define
    the property in the constructor''s signature or we can only define that the constructor
    accepts the parameters of the given types.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们直接在构造函数内部设置了`name`和`age`属性的访问修饰符。这种语法背后的语义与前面示例中使用的语法不同。它的含义是：定义一个受保护的名为`name`的属性，类型为`string`，并将传递给构造函数调用的第一个值赋给它。私有的`age`属性也是一样的。这样可以避免我们在构造函数中显式设置值。如果我们看一下`Developer`类的构造函数，我们可以看到我们可以在这些语法之间使用混合。我们可以在构造函数的签名中明确定义属性，或者只定义构造函数接受给定类型的参数。
- en: 'Now, let''s create a new instance of the `Developer` class:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建`Developer`类的一个新实例：
- en: '[PRE54]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'During compilation, TypeScript will throw an error telling us that **Property
    languages is private and only accessible inside class "Developer"**. Now, let''s
    see what''s going to happen if we create a new `Human` class and try to access
    its properties from outside its definition:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译过程中，TypeScript将抛出一个错误，告诉我们**属性languages是私有的，只能在类"Developer"内部访问**。现在，让我们看看如果创建一个新的`Human`类并尝试从其定义外部访问其属性会发生什么：
- en: '[PRE55]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In this case, we''ll get the following two errors:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将得到以下两个错误：
- en: '**Property age is private and is only accessible inside class "Human"** and
    the **Property name is a protected and only accessible inside class "Human" and
    its subclasses**.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性age是私有的，只能在类"Human"内部访问**和**属性name是受保护的，只能在类"Human"及其子类内部访问**。'
- en: However, if we try to access the `_name` property from inside the definition
    of `Developer`, the compiler won't throw any errors.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试在`Developer`的定义内部访问`_name`属性，编译器不会抛出任何错误。
- en: 'In order to get a better sense of what the TypeScript compiler will produce
    out of a type annotated class, let''s take a look at the JavaScript produced by
    the following definition:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解TypeScript编译器将从类型注释的类产生什么，让我们看一下以下定义产生的JavaScript：
- en: '[PRE56]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The resulting ECMAScript 5 will be:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的ECMAScript 5将是：
- en: '[PRE57]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The defined property is added directly to the objects instantiated by calling
    the constructor function with the operator `new`. This means that once the code
    is compiled, we can directly access the private members of the created objects.
    In order to wrap this up, access modifiers are added in the language in order
    to help us enforce better encapsulation and get compile-time errors in case we
    violate it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`new`运算符调用构造函数实例化的对象直接添加了定义的属性。这意味着一旦代码编译完成，我们就可以直接访问创建的对象的私有成员。为了总结一下，访问修饰符被添加到语言中，以帮助我们强制实现更好的封装，并在我们违反封装时获得编译时错误。
- en: Defining interfaces
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义接口
- en: '**Subtyping** in programming languages allows us to treat objects in the same
    way based on the observation that they are specialized versions of a generic object.
    This doesn''t mean that they have to be instances of the same class of objects,
    or that they have complete intersection between their interfaces. The objects
    might have only a few common properties and still be treated the same way in a
    specific context. In JavaScript, we usually use duck typing. We may invoke specific
    methods for all the objects passed to a function based on the assumption that
    these methods exist. However, all of us have experienced the *undefined is not
    a function* error thrown by the JavaScript interpreter.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言中的**子类型**允许我们根据它们是通用对象的专门化版本这一观察来以相同的方式对待对象。这并不意味着它们必须是相同类的实例，或者它们的接口之间有完全的交集。这些对象可能只有一些共同的属性，但在特定上下文中仍然可以以相同的方式对待。在JavaScript中，我们通常使用鸭子类型。我们可以根据这些方法的存在假设，在函数中为所有传递的对象调用特定的方法。然而，我们都曾经历过JavaScript解释器抛出的*undefined
    is not a function*错误。
- en: Object-oriented programming and TypeScript come with a solution. They allow
    us to make sure our objects have similar behavior if they implement interfaces
    that declare the subset of the properties they own.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程和TypeScript提供了一个解决方案。它们允许我们确保如果它们实现了声明它们拥有属性子集的接口，那么我们的对象具有类似的行为。
- en: 'For example, we can define our interface `Accountable`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以定义我们的接口`Accountable`：
- en: '[PRE58]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, we can make sure both `Individual` and `Firm` implement this interface
    by doing as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过以下方式确保`Individual`和`Firm`都实现了这个接口：
- en: '[PRE59]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In case we implement a given interface, we need to provide implementation for
    all the methods defined inside it, otherwise the TypeScript compiler will throw
    an error. The methods we implement must have the same signature as the ones declared
    in the interface definition.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们实现了一个给定的接口，我们需要为其定义的所有方法提供实现，否则TypeScript编译器将抛出错误。我们实现的方法必须与接口定义中声明的方法具有相同的签名。
- en: 'TypeScript interfaces also support properties. In the `Accountable` interface,
    we can include a field called `accountNumber` with a type of string:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript接口还支持属性。在`Accountable`接口中，我们可以包含一个名为`accountNumber`的字段，类型为字符串：
- en: '[PRE60]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We can define it in our class as a field or a getter.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的类中定义它作为一个字段或一个getter。
- en: Interface inheritance
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接口继承
- en: 'Interfaces may also extend each other. For example, we may turn our `Individual`
    class into an interface that has a social security number:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接口也可以相互扩展。例如，我们可以将我们的`Individual`类转换为一个具有社会安全号码的接口：
- en: '[PRE61]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Since interfaces support multiple inheritances, `Individual` may also extend
    the interface `Human` that has the `name` and `age` properties:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于接口支持多重继承，`Individual`也可以扩展具有`name`和`age`属性的`Human`接口：
- en: '[PRE62]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Implementing multiple interfaces
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现多个接口
- en: 'In case the class''s behavior is a union of the properties defined in a couple
    of interfaces, it may implement all of them:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类的行为是在几个接口中定义的属性的并集，它可以实现它们所有：
- en: '[PRE63]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In this case, we need to provide the implementation of all the methods declared
    inside the interfaces our class implements, otherwise the compiler will throw
    a compile-time error.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要提供类实现的所有方法的实现，否则编译器将抛出编译时错误。
- en: Further expressiveness with TypeScript decorators
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TypeScript装饰器进一步增强表达能力
- en: 'In ES2015, we are able to decorate only classes, properties, methods, getters,
    and setters. TypeScript takes this further by allowing us to decorate functions
    or method parameters:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES2015中，我们只能装饰类、属性、方法、getter和setter。TypeScript通过允许我们装饰函数或方法参数来进一步扩展了这一点：
- en: '[PRE64]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: However, the parameter decorators should not alter any additional behavior.
    Instead, they are used to generate metadata. The most typical use case of these
    decorators is the dependency injection mechanism of Angular 2.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，参数装饰器不应该改变任何额外的行为。相反，它们用于生成元数据。这些装饰器最典型的用例是Angular 2的依赖注入机制。
- en: Writing generic code by using type parameters
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型参数编写通用代码
- en: 'In the beginning of the section on using static typing, we mentioned the type
    parameters. In order to get a better understanding of them, let''s begin with
    an example. Let''s suppose we want to implement the classical data-structure `BinarySearchTree`.
    Let''s define its interface using a class without applying any method implementations:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用静态类型的部分开头，我们提到了类型参数。为了更好地理解它们，让我们从一个例子开始。假设我们想要实现经典的数据结构`BinarySearchTree`。让我们使用一个类来定义它的接口，而不应用任何方法实现：
- en: '[PRE65]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In the preceding snippet, we defined a class called `Node`. The instances of
    this class represent the individual nodes in our tree. Each `node` has a left
    and a right child node and a value of the type `any`; we use `any` in order to
    be able to store data of `any` type inside our nodes and respectively inside `BinarySearchTree`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们定义了一个名为`Node`的类。这个类的实例代表了我们树中的个别节点。每个`node`都有一个左子节点和一个右子节点，以及一个`any`类型的值；我们使用`any`来能够在我们的节点和相应的`BinarySearchTree`中存储任意类型的数据。
- en: Although the earlier implementation looks reasonable, we're giving up on using
    the most important feature that TypeScript provides—static typing. By using `any`
    as a type of the value field inside the `Node` class, we can't take complete advantage
    of the compile-time type checking. This also limits the features that IDEs and
    text editors provide when we access the `value` property of the instances of the
    `Node` class.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管先前的实现看起来是合理的，但我们放弃了TypeScript提供的最重要的特性——静态类型。通过将`Node`类内的值字段的类型设置为`any`，我们无法充分利用编译时类型检查。这也限制了IDE和文本编辑器在访问`Node`类的实例的`value`属性时提供的功能。
- en: 'TypeScript comes with an elegant solution that is already widely popular in
    the world of static typing—type parameters. Using generics, we can parameterize
    the classes we create with the type parameters. For example, we can turn our `Node`
    class into the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript提供了一个优雅的解决方案，这在静态类型世界中已经广泛流行——类型参数。使用泛型，我们可以使用类型参数对我们创建的类进行参数化。例如，我们可以将我们的`Node`类转换为以下形式：
- en: '[PRE66]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`Node<T>` indicates that this class has a single type parameter called `T`
    that is used somewhere inside the class''s definition. We can use `Node` by doing
    as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`Node<T>`表示这个类有一个名为`T`的单一类型参数，在类的定义中的某个地方使用。我们可以通过以下方式使用`Node`：'
- en: '[PRE67]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In the preceding snippet, we created three nodes: `numberNode`, `stringNode`,
    and another node of the type `Node<number>`, assigning its value to the right
    child of `numberNode`. Notice that since `numberNode` is of the type `Node<number>`,
    we can set its value to `42`, but we can''t use the string `"42"`. The same is
    applicable to its left child. In the definition, we''ve explicitly declared that
    we want the left and right children to be of the type `Node<number>`. This means
    that we cannot assign values of the type `Node<string>` to them; that''s why we
    get the second compile-time error.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们创建了三个节点：`numberNode`，`stringNode`和另一个类型为`Node<number>`的节点，将其值分配给`numberNode`的右子节点。请注意，由于`numberNode`的类型是`Node<number>`，我们可以将其值设置为`42`，但不能使用字符串`"42"`。对其左子节点也是适用的。在定义中，我们明确声明了希望左右子节点的类型为`Node<number>`。这意味着我们不能将类型为`Node<string>`的值分配给它们；这就是为什么我们会得到第二个编译时错误。
- en: Using generic functions
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用泛型函数
- en: 'Another typical use of generics is for defining functions that operate over
    a set of types. For example, we may define an `identity` function that accepts
    an argument of type `T` and returns it:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型的另一个典型用途是定义操作一组类型的函数。例如，我们可以定义一个接受类型为`T`的参数并返回它的`identity`函数：
- en: '[PRE68]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'However, in some cases, we may want to use only the instances of the types
    that have some specific properties. For achieving this, we can use an extended
    syntax that allows us to declare subtypes of the types that should be the type
    parameters:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，我们可能只想使用具有特定属性的类型的实例。为了实现这一点，我们可以使用扩展语法，允许我们声明应该是类型参数的类型的子类型：
- en: '[PRE69]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: For example, here, we defined an interface called `Comparable`. It has a single
    operation called `compare`. The classes that implement the interface `Comparable`
    need to implement the operation `compare`. When `compare` is called with a given
    argument, it returns `1` if the target object is bigger than the passed argument,
    `0` if they are equal, and `-1` if the target object is smaller than the passed
    argument.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这里，我们定义了一个名为`Comparable`的接口。它有一个名为`compare`的操作。实现接口`Comparable`的类需要实现操作`compare`。当使用给定参数调用`compare`时，如果目标对象大于传递的参数，则返回`1`，如果它们相等，则返回`0`，如果目标对象小于传递的参数，则返回`-1`。
- en: Having multiple type parameters
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具有多个类型参数
- en: 'TypeScript allows us to use multiple type parameters:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript允许我们使用多个类型参数：
- en: '[PRE70]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In this case, we can create an instance of the class `Pair<K, V>` using the
    following syntax:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以使用以下语法创建`Pair<K, V>`类的实例：
- en: '[PRE71]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Writing less verbose code with TypeScript's type inference
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TypeScript的类型推断编写更简洁的代码
- en: Static typing has a number of benefits; however, it makes us write a more verbose
    code by adding all the required type annotations.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型具有许多好处；然而，它使我们编写更冗长的代码，需要添加所有必需的类型注释。
- en: 'In some cases, the TypeScript''s compiler is able to guess the types of expressions
    inside our code, for instance:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，TypeScript的编译器能够猜测我们代码中表达式的类型，例如：
- en: '[PRE72]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In the preceding example, we defined a variable `answer` and we assigned the
    value `42` to it. Since TypeScript is statically typed and the type of a variable
    cannot change once declared, the compiler is smart enough to guess that the type
    of `answer` is `number`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们定义了一个变量`answer`，并将值`42`赋给它。由于TypeScript是静态类型的，变量的类型一旦声明就不能改变，编译器足够聪明，能够猜测`answer`的类型是`number`。
- en: 'If we don''t assign a value to a variable within its definition, the compiler
    will set its type to `any`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在定义变量时不给变量赋值，编译器将把它的类型设置为`any`：
- en: '[PRE73]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The preceding snippet will compile without any compile-time errors.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码片段将在没有编译时错误的情况下编译。
- en: Best common type
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳通用类型
- en: 'Sometimes, the type inference could be a result of several expressions. Such
    is the case when we assign a heterogeneous array to a variable:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，类型推断可能是多个表达式的结果。当我们将异构数组分配给一个变量时就是这种情况：
- en: '[PRE74]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In this case, the type of `x` will be `any[]`. However, suppose we have the
    following:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`x`的类型将是`any[]`。然而，假设我们有以下情况：
- en: '[PRE75]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The type of `x` will then be `number[]`, since the type `Number` is a subtype
    of `Null`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`的类型将是`number[]`，因为`Number`类型是`Null`的子类型。'
- en: Contextual type inference
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文类型推断
- en: 'Contextual typing occurs when the type of an expression is implied from its
    location, for example:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当表达式的类型是从其位置暗示出来时，就发生了上下文类型推断，例如：
- en: '[PRE76]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In this case, the type of the argument of the callback `e` is *guessed* by the
    compiler based on the context in which it is used. The compiler understands what
    the type of `e` is based on the call of `addEventListener` and the arguments passed
    to the method. In case we were using a keyboard event (`keydown`, for example),
    TypeScript would have been aware that `e` is of the type `KeyboardEvent`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，回调函数`e`的参数类型是根据编译器根据其使用上下文“猜测”的。编译器根据`addEventListener`的调用和传递给该方法的参数理解`e`的类型。如果我们使用键盘事件（例如`keydown`），TypeScript会意识到`e`的类型是`KeyboardEvent`。
- en: Type inference is a mechanism that allows us to write less verbose code by taking
    advantage of the static analysis performed by TypeScript. Based on the context,
    TypeScript's compiler is able to guess the type of a given expression without
    explicit definition.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断是一种机制，使我们能够通过利用TypeScript执行的静态分析来编写更简洁的代码。根据上下文，TypeScript的编译器能够猜测给定表达式的类型，而无需显式定义。
- en: Using ambient type definitions
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用环境类型定义
- en: Although static typing is amazing, most of the frontend libraries we use are
    built with JavaScript, which is dynamically typed. Since we'd want to use TypeScript
    in Angular 2, not having compile-typing in the code that uses external libraries
    is a big issue; it prevents us from taking advantage of the compile-time type-checking.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管静态类型很棒，但我们使用的大多数前端库都是用JavaScript构建的，它是动态类型的。因此，我们希望在Angular 2中使用TypeScript，但在使用外部库的代码中没有编译时类型检查是一个大问题；这会阻止我们利用编译时的类型检查。
- en: TypeScript was built keeping these points in mind. In order to allow the TypeScript
    compiler to take care of what it does best, we can use the so-called ambient type
    definitions. They allow us to provide external type definitions of the existing
    JavaScript libraries. This way, they provide hints to the compiler.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript是根据这些要点构建的。为了让TypeScript编译器处理它最擅长的事情，我们可以使用所谓的环境类型定义。它们允许我们提供现有JavaScript库的外部类型定义。这样，它们为编译器提供了提示。
- en: Using predefined ambient type definitions
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用预定义的环境类型定义
- en: 'Fortunately, we don''t have to create ambient type definitions for all JavaScript
    libraries and frameworks we use. The community and/or the authors of these libraries
    have already published such definitions online; the biggest repository resides
    at: [https://github.com/DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped).
    There''s also a tool for managing them called **typings**. We can install it using
    `npm` by the following command:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不必为我们使用的所有JavaScript库和框架创建环境类型定义。这些库的社区和/或作者已经在网上发布了这样的定义；最大的存储库位于：[https://github.com/DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped)。还有一个用于管理它们的工具叫做**typings**。我们可以使用以下命令通过`npm`安装它：
- en: '[PRE77]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The configuration of typings is defined in a file called `typings.json` and
    all installed ambient typings, by default, will be in the directory`./typings`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 类型定义的配置在一个名为`typings.json`的文件中定义，默认情况下，所有已安装的环境类型定义将位于`./typings`目录中。
- en: 'In order to create `typings.json` file with basic configuration use:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建带有基本配置的`typings.json`文件，请使用：
- en: '[PRE78]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We can install new type definition using:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令安装新的类型定义：
- en: '[PRE79]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The preceding command will download the type definitions for AngularJS 1.x and
    save them in both `browser/ambient/angular/angular.d.ts` and `main/ambient/angular/angular.d.ts`
    under the `typings` directory.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将下载AngularJS 1.x的类型定义，并将它们保存在`typings`目录下的`browser/ambient/angular/angular.d.ts`和`main/ambient/angular/angular.d.ts`中。
- en: Note
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Having both `main/ambient` and `browser/ambient` directories is due to preventing
    type collisions. For instance, if we use TypeScript in both the `backend/build`
    of our project, and its frontend there could be introduced duplications of type
    definitions which will lead to compile-time errors. By having two directories
    for the ambient typings of the individual parts of the project, we can include
    only one of them using respectively `main.d.ts` and `browser.d.ts`. For further
    information on typings you can visit the official repository of the project on
    GitHub [https://github.com/typings/typings](https://github.com/typings/typings).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有`main/ambient`和`browser/ambient`目录是为了防止类型冲突。例如，如果我们在项目的`backend/build`和前端都使用TypeScript，可能会引入类型定义的重复，这将导致编译时错误。通过为项目的各个部分的环境类型定义拥有两个目录，我们可以分别使用`main.d.ts`和`browser.d.ts`来包含其中一个。有关类型定义的更多信息，您可以访问GitHub上项目的官方存储库[https://github.com/typings/typings](https://github.com/typings/typings)。
- en: 'In order to download a type definition and add entry for it inside `typings.json`
    you can use:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 为了下载类型定义并在`typings.json`中添加条目，您可以使用：
- en: '[PRE80]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'After running the preceding command your `typings.json` file should look similar
    to:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令后，您的`typings.json`文件应该类似于：
- en: '[PRE81]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now in order to use AngularJS 1.x with TypeScript create `app.ts` and enter
    the following content:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了在TypeScript中使用AngularJS 1.x，创建`app.ts`并输入以下内容：
- en: '[PRE82]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'To compile `app.ts` use:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译`app.ts`，请使用：
- en: '[PRE83]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The TypeScript compile will output the compiled content into `app.js`. In order
    to add extra automation and invoke the TypeScript compiler each time you change
    any of the files in your project, you can use a task runner like gulp or grunt,
    or pass the `-w` option to `tsc`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译将把编译后的内容输出到`app.js`中。为了添加额外的自动化并在项目中的任何文件更改时调用TypeScript编译器，您可以使用像gulp或grunt这样的任务运行器，或者将`-w`选项传递给`tsc`。
- en: Note
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since using the reference element for including type definitions is considered
    bad practice we can use a `tsconfig.json` file instead. There we can configure
    which directories need to be included in the compilation process by `tsc`. For
    more information visit [https://github.com/Microsoft/TypeScript/wiki/tsconfig.json](https://github.com/Microsoft/TypeScript/wiki/tsconfig.json).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用引用元素来包含类型定义被认为是不良实践，我们可以使用`tsconfig.json`文件代替。在那里，我们可以配置哪些目录需要在编译过程中被`tsc`包含。更多信息请访问[https://github.com/Microsoft/TypeScript/wiki/tsconfig.json](https://github.com/Microsoft/TypeScript/wiki/tsconfig.json)。
- en: Custom ambient type definitions
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义环境类型定义
- en: 'To understand how everything works together, let''s take a look at an example.
    Suppose we have the following interface of a JavaScript library:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解一切是如何协同工作的，让我们来看一个例子。假设我们有一个JavaScript库的以下接口：
- en: '[PRE84]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We have an object literal assigned to a variable called `DOM`. The object has
    the following methods:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个分配给名为`DOM`的变量的对象文字。该对象具有以下方法：
- en: '`selectElements`: Accepts a single argument with type string and returns a
    set of DOM elements.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selectElements`：接受一个类型为字符串的单个参数并返回一组DOM元素。'
- en: '`hide`: Accepts a DOM node as an argument and returns nothing.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hide`：接受一个DOM节点作为参数并返回空。'
- en: '`show`: Accepts a `DOM` node as an argument and returns nothing.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`show`：接受一个`DOM`节点作为参数并返回空。'
- en: 'In TypeScript, the preceding definition would look as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，前面的定义将如下所示：
- en: '[PRE85]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This means that we can define our library''s interface as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以如下定义我们的库接口：
- en: '[PRE86]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Defining ts.d files
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义ts.d文件
- en: 'After we have the interface of our library, it will be easy to create the ambient
    type definition; we just have to create a file with an extension `ts.d` called
    `dom` and enter the following content:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有了库的接口之后，创建环境类型定义将变得很容易；我们只需要创建一个名为`dom`的扩展名为`ts.d`的文件，并输入以下内容：
- en: '[PRE87]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In the preceding snippet, we defined the interface called `DOMLibraryInterface`
    and declared the variable `DOM` of the type `DOMLibraryInterface`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们定义了名为`DOMLibraryInterface`的接口，并声明了类型为`DOMLibraryInterface`的变量`DOM`。
- en: 'The only thing left before being able to exploit static typing with our JavaScript
    library is including the external type definition in the script files we want
    to use our library in. We can do it as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在能够利用静态类型的JavaScript库之前，唯一剩下的事情就是在我们想要使用我们的库的脚本文件中包含外部类型定义。我们可以这样做：
- en: '[PRE88]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The preceding snippet hints the compiler on where to find the ambient type definitions.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段提示编译器在哪里找到环境类型定义。
- en: Summary
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we peeked at the TypeScript language that is used for the implementation
    of Angular 2\. Although we can develop our Angular 2 applications using ECMAScript
    5, Google's recommendation is to use TypeScript in order to take advantage of
    the static typing it provides.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们窥探了用于实现Angular 2的TypeScript语言。虽然我们可以使用ECMAScript 5来开发我们的Angular 2应用程序，但谷歌建议使用TypeScript以利用其提供的静态类型。
- en: While exploring the language, we looked at some of the core features of ES2015
    and ES2016\. We explained the ES2015 and ES2016 classes, arrow functions, block
    scope variable definitions, destructuring, and modules. Since Angular 2 takes
    advantage of the ES2016 decorators and more accurately their extension in TypeScript,
    a section was dedicated to them.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索语言的过程中，我们看了一些ES2015和ES2016的核心特性。我们解释了ES2015和ES2016的类、箭头函数、块作用域变量定义、解构和模块。由于Angular
    2利用了ES2016的装饰器，更准确地说是它们在TypeScript中的扩展，我们专门介绍了它们。
- en: After this, we took a look at how we can take advantage of static typing by
    using explicit type definitions. We described some of the built-in types in TypeScript
    and how we can define classes in the language by specifying access modifiers for
    their members. Our next stop was the interfaces. We ended our adventures in TypeScript
    by explaining the type parameters and the ambient type definitions.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们看了一下如何通过使用显式类型定义来利用静态类型。我们描述了TypeScript中一些内置类型以及如何通过为类的成员指定访问修饰符来定义类。接下来我们介绍了接口。我们通过解释类型参数和环境类型定义来结束了我们在TypeScript中的冒险。
- en: In the next chapter, we are going to start exploring Angular 2 in depth by using
    the framework's components and directives.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始深入探索Angular 2，使用框架的组件和指令。
