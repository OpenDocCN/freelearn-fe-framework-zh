<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Details of JavaScript Testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Details of JavaScript Testing</h1></div></div></div><p>Practicing TDD is a great way to get good quality software with satisfactory accuracy, even with fewer people. For web applications, JavaScript has become the most popular scripting language and it has become a challenge to test JavaScript code. Browser-based testing is actually a time killer and is difficult to follow for TDD, but then the solution to this comes with some cool tools that support automated testing for JavaScript. Most web application projects were limited to unit tests only, and without automated test tools, end-to-end tests or functional tests were almost impossible.</p><p>A lot of tools and frameworks focusing on JavaScript testing are coming out, which serve different solutions, making developers' lives easy. Besides inventing new JavaScript frameworks, the developer's community invented some tool sets to make testing easy. Like the Angular team, they come with cool tools like <span class="strong"><strong>Karma</strong></span>. We also have the duplication of testing frameworks or tools, where both solve similar problems but in different ways. Which tools or frameworks to choose is up to the developer; they have to choose the tool that suits their requirements best.</p><p>In this chapter, we will cover the following: </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A brief about automated testing</li><li class="listitem" style="list-style-type: disc">Different types of testing focused on JavaScript</li><li class="listitem" style="list-style-type: disc">A brief idea about some testing tools and frameworks </li></ul></div><div class="section" title="The craft of JavaScript testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec12"/>The craft of JavaScript testing</h1></div></div></div><p>We all know that JavaScript is a dynamically typed, interpreted language. Therefore, there are no compilation steps that help you figure out errors, unlike other compiled languages similar to Java. So, a JavaScript developer should allocate more time to test code. However, life is easier now, as a developer can cover testing with minimal steps and time using the latest tool techniques. It's a part of an automated test, where the code will be automatically tested whenever it changes. In that process, a test could be a task running in the background, which could be integrated into the IDE or the CLI, and it will provide the test result during development.</p><p>In the subsequent sections, we will discuss how to automate the test process in multiple browsers with a test runner and a headless browser.</p><div class="section" title="Automated testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Automated testing</h2></div></div></div><p>Testing is fun, and writing a test will make the code better; it's a good practice, but the procedural manual testing is a bit time consuming, error prone, and irreproducible. In this process, there is a need to write the test spec, change the code to pass the test, refresh the browser to get the result, and repeat this process several times. As a programmer, it's kind of boring to repeat the same things.</p><p>Apart from being monotonous, it also slows down the development process a lot, which demotivates developers from practicing TDD. So, when the manual process slows down progress, we have to look for some automated process to do the job and save time for other tasks that could add more business value.</p><p>So, it would be great to have some tools or techniques that can help programmers get rid of these repetitive and boring manual steps that slow down the process and get things done automatically, faster, and save time to make them more valuable for the business. Fortunately, there are some tools to automate these tests. We will cover more about those tools and techniques, but not in this section.</p><p>Besides the issue of slowing down the development process, another important point comes in view when we talk about the testing features, and that is the cross-browser compatibility issue. As web applications should run perfectly on modern platforms and browsers, and it's almost impossible to test them one-by-one manually, automated testing could be the solution with a web driver and headless browser.</p><p>Let's recap the basic test flow that we explained in the previous chapter--test it, make it run, and make it better. To make this process automatic, a developer can implement the tool set in the CLI or even in the development IDE, and these tests will run continuously in a separate process without any input from the developer.</p><p>Let's think of a registering or signing up feature for any application, where we have to manually fill up the form and click on the submit button every time we want to test the feature and repeat the process by changing the data. This is actually known as a functional test (which we will discuss at the end of this chapter). To perform these processes automatically, we will use the tool set (the test runner, web driver, and headless browser) in the CLI and complete the process with a single command with some parameters.</p><p>Testing JavaScript in automated testing is not a new concept, indeed, it is the most commonly used automated browser. Selenium was invented for this in 2004, and after that, a lot of tools have emerged, including PhantomJS, Karma, Protractor, and CasperJS. In this chapter, we will discuss some of them.</p></div></div></div>
<div class="section" title="Types of testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Types of testing</h1></div></div></div><p>In TDD, developers have to follow a flow to fulfill the goal of the test. On this flow, every step has an individual goal of testing. For example, some tests are written just to test the behavior of each function in several ways and some are for testing the flow of a module/feature. Based on that, we will discuss two major types of testing here. They are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Unit testing</strong></span>: This is mostly used for behavior tests.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>End-to-end testing</strong></span>: This is mostly known as e2e testing and is used for functional tests.</li></ul></div><div class="section" title="Unit testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Unit testing</h2></div></div></div><p><span class="strong"><strong>Unit testing</strong></span> is a software development process, where the smallest testable part of any application is individually called a unit, and the behavior of that small part should be testable in isolation, without any dependency on the other parts. If we think of a JavaScript application as software, then every individual method/function of that application which has a specific behavior will be a unit of code. The behavior of these methods or units of code should be testable in an isolated way.</p><p>An important point about unit testing is that any unit of code should run/be testable in isolation and should run in any order, which means that if unit testing runs successfully in any application, it represents the isolation of the components or modules of that application.</p><p>For example, we had already shown a small test example in the previous chapter about how to get a method tested; though we showed that without using any test framework, the idea is the same. We called the method by passing some parameters, got a result of that method, and then we compared the result with the expected value.</p><p>Typically, we will write such tests using a unit testing framework of our choice. There are many testing frameworks and tools now, and we have to decide and pick the best one based on our requirements. The most commonly used frameworks are Jasmine, Mocha, and QUnit. We will discuss these tools in depth in this chapter and real-life examples will be covered in the subsequent chapters.</p><p>Tests should run fast and be automated with a clear output. For example, you can verify that if a function is called with particular arguments, it should return an expected result.</p><p>Unit testing can run the test anytime, such as in the following instances:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">From the very beginning of the development process, even with a failing test</li><li class="listitem" style="list-style-type: disc">After completing the development of any feature to verify that the behavior is correct</li><li class="listitem" style="list-style-type: disc">After modifying any existing feature to verify that the behavior hasn't changed</li><li class="listitem" style="list-style-type: disc">After adding a new feature in the existing application, we need to verify that the new feature is isolated and it's not breaking any other feature</li></ul></div></div><div class="section" title="End-to-end testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>End-to-end testing</h2></div></div></div><p>End-to-end testing is a methodology used to test whether the flow of an application is performing as designed from start to finish. For example, if a user clicks on a product from a product list, it should prompt the modal to display detailed information of the selected product. In this case, the product/project owner will define the project requirements step by step in the specification. The project will be tested based on the specification's workflow after the development process. This is called the function/flow test and is another name for an end-to-end test.</p><p>Besides unit testing, end-to-end testing is important for confirming that individual components are working together as an application, passing information, and communicating among them. The main difference with unit testing is that it does not test any components in isolation; instead, it is a combined test of the flow with all the dependent components together.</p><p>Consider a registration module where users should provide some valid information to complete the registration, and the function/flow test for that module/application should follow some steps to complete the testing.</p><p>The steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Load/compile the form</li><li class="listitem">Get the DOM of the form's elements</li><li class="listitem">Trigger the click event of the submit button</li><li class="listitem">Collect the value from the input fields for validation</li><li class="listitem">Validate the input fields</li><li class="listitem">Call the fake API to store data</li></ol></div><p>In every step, there will be some result which will be compared to the expected result set.</p><p>These kinds of functional/flow tests can be tested manually by a person filling out the forms by clicking on the buttons for the next steps, completing the application flow, and comparing the result with the specification that is defined earlier in the implementation process.</p><p>However, there are some techniques available to do this functional/flow testing in an automated way without getting input from any person, which is known as end-to-end testing. To make this test process easier, there are a few tools available; the ones used most commonly are Selenium, PhantomJS, and Protractor. These tools can easily integrate with any application test system. In this chapter, we will discuss these test tools in a bit more detail, and in the subsequent chapters, we will integrate these in an application's test suite.</p></div></div>
<div class="section" title="Testing tools and frameworks"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Testing tools and frameworks</h1></div></div></div><p>Knowing what the different testing tools are is half the battle. A few of them are very important to know in depth for Angular testing; we will learn them in detail throughout this book. However, in this section, we will learn about some well-known tools and frameworks that are used in different web applications for various kinds of testing and approaches. They are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Karma</strong></span>: This is the test runner for JavaScript</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Protractor</strong></span>: This is the end-to-end testing framework</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Jasmine</strong></span>: This refers to the behavior-driven JavaScript testing framework</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Mocha</strong></span>: This is the JavaScript testing framework</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>QUnit</strong></span>: This stands for the unit testing framework</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Selenium</strong></span>: This is the tool that automates the web browsers</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>PhantomJS</strong></span>: This is the headless webkit browser</li></ul></div><div class="section" title="Karma"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Karma</h2></div></div></div><p>Before discussing what Karma is, it is best to discuss what it isn't. It isn't a framework to write tests; it is a test runner. What this means is that Karma gives us the ability to run tests in several different browsers in an automated way. In the past, developers had to perform manual steps to do this, including the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Opening up a browser</li><li class="listitem" style="list-style-type: disc">Pointing the browser to the project URL</li><li class="listitem" style="list-style-type: disc">Running the tests</li><li class="listitem" style="list-style-type: disc">Confirming that all the tests have passed</li><li class="listitem" style="list-style-type: disc">Making changes</li><li class="listitem" style="list-style-type: disc">Refreshing the page</li></ul></div><p>With Karma, automation gives a developer the ability to run a single command and determine whether an entire test suite has passed or failed. From a TDD perspective, this gives us the ability to find and fix failing tests quickly.</p><p>Some of the pros of using Karma as compared to a manual process are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Ability to automate tests in multiple browsers and devices</li><li class="listitem" style="list-style-type: disc">Ability to watch files</li><li class="listitem" style="list-style-type: disc">Online documentation and support</li><li class="listitem" style="list-style-type: disc">Does one thing--running JavaScript tests--and does it well</li><li class="listitem" style="list-style-type: disc">Makes it easy to integrate with a continuous integration server</li></ul></div><p>Disadvantage of using Karma:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Requires an additional tool to learn, configure, and maintain</li></ul></div><p>Automating the process of testing and using Karma is extremely advantageous. In the TDD journey through this book, Karma will be one of our primary tools. We will learn about Karma in detail in <a class="link" href="ch03.html" title="Chapter 3. The Karma Way">Chapter 3</a>, <span class="emphasis"><em>The Karma Way</em></span>.</p></div><div class="section" title="Protractor"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Protractor</h2></div></div></div><p>Protractor is an end-to-end testing tool that allows developers to mimic user interactions. It automates the testing of functionality and features through the interaction of a web browser. Protractor has specific methods to assist in the testing of Angular, but they are not exclusive to Angular.</p><p>Some of the pros of using Protractor are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Configurable to test multiple environments</li><li class="listitem" style="list-style-type: disc">Easy integration with Angular</li><li class="listitem" style="list-style-type: disc">Syntax and testing can be similar to the testing framework chosen for unit testing</li></ul></div><p>Disadvantage of using Protractor:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Its documentation and examples are limited</li></ul></div><p>For end-to-end testing of the examples in this book, Protractor will be our main framework. Protractor will be further introduced in detail in <a class="link" href="ch04.html" title="Chapter 4. End-to-End Testing with Protractor">Chapter 4</a>, <span class="emphasis"><em>End-to-End Testing with Protractor</em></span>.</p></div><div class="section" title="Jasmine"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Jasmine</h2></div></div></div><p>Jasmine is a behavior-driven development framework for testing JavaScript code. It can be easily integrated and run for websites and is agnostic to Angular. It provides spies and other features. It can also be run on its own without Karma. In this chapter, we will learn details of the commonly used built-in global functions of Jasmine and will see how the Jasmine test suite serves the testing requirements for a web application. Also, throughout this book, we will use Jasmine as our testing framework.</p><p>Some of the pros of using Jasmine are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Default integration with Karma</li><li class="listitem" style="list-style-type: disc">Provides additional functions to assist with testing, such as test spies, fakes, and the pass-through functionality</li><li class="listitem" style="list-style-type: disc">Cleans readable syntax that allows tests to be formatted in a way that relates to the behavior being tested</li><li class="listitem" style="list-style-type: disc">Integration with several output reporters</li></ul></div><p>The following are some cons of using Jasmine:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">No file-watching feature is available when running tests. This means that tests have to be rerun by the user as they change.</li><li class="listitem" style="list-style-type: disc">The learning curve can be steep for all the Protractor methods and features.</li></ul></div></div><div class="section" title="Mocha"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Mocha</h2></div></div></div><p>Mocha is a testing framework originally written for Node.js applications, but it supports browser testing as well. It is very similar to Jasmine and mirrors much of its syntax. The main difference with Mocha is that it can't run standalone as a test framework--it needs some plugin and library to run as a test framework, while Jasmine is standalone. It's more configurable and flexible to use.</p><p>Let's discuss some of the pros of Mocha:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Easy to install</li><li class="listitem" style="list-style-type: disc">Good documentation available</li><li class="listitem" style="list-style-type: disc">Has several reporters</li><li class="listitem" style="list-style-type: disc">Plugs in with several node projects</li></ul></div><p>Here are a few cons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Separate plugins/modules are required for assertions, spies, and so on</li><li class="listitem" style="list-style-type: disc">Additional configuration required to use it with Karma</li></ul></div></div><div class="section" title="QUnit"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec24"/>QUnit</h2></div></div></div><p>QUnit is a powerful, easy-to-use JavaScript unit test suite. It's used by jQuery and the jQuery UI and jQuery Mobile projects and is capable of testing any generic JavaScript code. QUnit focuses on testing JavaScript in the browser, while providing as much convenience to the developer as possible.</p><p>Some of the pros of QUnit:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Easy to install</li><li class="listitem" style="list-style-type: disc">Good documentation available</li></ul></div><p>Here is a con of using QUnit:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Mostly developed for jQuery, not good for use with other frameworks</li></ul></div></div><div class="section" title="Selenium"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Selenium</h2></div></div></div><p>Selenium (<a class="ulink" href="http://www.seleniumhq.org/">http://www.seleniumhq.org/</a>) defines itself as follows:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"Selenium automates browsers. That's it!"</em></span></p></blockquote></div><p>Automation of browsers means that developers can interact with browsers easily. They can click on buttons or links, enter data, and so on. Selenium is a powerful toolset that, when used and set up properly, has lots of benefits; however, it can be confusing and cumbersome to set it up.</p><p>Some of the pros of Selenium are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Large feature set</li><li class="listitem" style="list-style-type: disc">Distributed testing</li><li class="listitem" style="list-style-type: disc">SaaS support through services such as <span class="strong"><strong>Sauce Labs </strong></span>(<a class="ulink" href="https://saucelabs.com/">https://saucelabs.com/</a>)</li><li class="listitem" style="list-style-type: disc">Documentation and resources available</li></ul></div><p>Here are some cons of Selenium:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Has to be run as a separate process</li><li class="listitem" style="list-style-type: disc">Several steps to configure</li></ul></div><p>As Protractor is a wrapper around Selenium, it won't be discussed in detail.</p></div><div class="section" title="PhantomJS"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec26"/>PhantomJS</h2></div></div></div><p>PhantomJS is a headless WebKit scriptable with a JavaScript API. It has <span class="emphasis"><em>fast</em></span> and <span class="emphasis"><em>native</em></span> support for various web standards; DOM handling, CSS selector, JSON, Canvas, and SVG. PhantomJS is used in the test workflow.</p><p>Simply put, PhantomJS is a browser that runs headlessly (that is, doesn't draw out the screen). The benefits that it brings are speed--if you're controlling an actual program on your computer, you've a certain overhead in booting up the browser, configuring a profile, and so on.</p><p>PhantomJS is not meant to replace a testing framework; it will work in conjunction with one.</p></div></div>
<div class="section" title="The choice is ours"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>The choice is ours</h1></div></div></div><p>As we have seen, there are a lot of toolsets and frameworks for testing JavaScript projects:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For the assertion framework, we will go with Jasmine as Angular itself uses Jasmine as assertions; but in some cases, mostly for Node.js projects, Mocha is fun as well</li><li class="listitem" style="list-style-type: disc">As long as we focus on the automated test suite, the test runner is of most importance to us, and nothing can be compared to Karma when it's about an Angular project</li><li class="listitem" style="list-style-type: disc">For end-to-end testing, Protractor is the best framework, and we will use that in this chapter.</li><li class="listitem" style="list-style-type: disc">As long as it's end-to-end testing, it must be automated, and Selenium is here to automate the browser for us.</li><li class="listitem" style="list-style-type: disc">It's important to run tests as cross-browser support, and PhantomJS is here for us to serve as a headless browser.</li></ul></div></div>
<div class="section" title="Say hello to Jasmine test suite"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Say hello to Jasmine test suite</h1></div></div></div><p>As long as we have to use a testing framework to build a test suite, there are some basic and common assertions on all frameworks. It's important to understand those assertions and spies and when to use them.</p><p>In this section we will explain the assertions and spies from Jasmine, as Jasmine will be our testing framework throughout the book.</p><div class="section" title="Suites"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Suites</h2></div></div></div><p>Any test suite begins with a global Jasmine <code class="literal">describe</code> function, which receives two parameters. The first one is a string and the second one is a function. The string is the suite name/title, and the function is for the code block that will be implemented in the suite.</p><p>Consider the following example:</p><pre class="programlisting">describe("A sample test suite to test jasmine assertion", function() {  &#13;
   // .. implemented code block &#13;
}); &#13;
</pre></div><div class="section" title="Spec"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Spec</h2></div></div></div><p>Any spec defined with Jasmine's global <code class="literal">it</code> function, similar to the suite's that receives two params, involves the first one being a string and the second one being a function. The string is the spec name/title and the function is for the code block that will be implemented in the spec. Take a look at the following example:</p><pre class="programlisting">describe("A sample test suite to test jasmine assertion", function() { &#13;
    var a; &#13;
    it("Title for a spec", function() { &#13;
        // .. implemented code block &#13;
    }); &#13;
}); &#13;
</pre></div><div class="section" title="Expectation"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>Expectation</h2></div></div></div><p>Any expectation defined with an <code class="literal">expect</code> function, which receives one param value that is called actual. This function is a chain with the matcher function, which takes an expected value as a parameter to match with the actual value.</p><p>There are a few commonly used matchers; all of them implement a Boolean comparison between the actual value and the expected value. Any matcher can evaluate a negative value by chaining the <code class="literal">expect</code> method with a <code class="literal">not</code> keyword.</p><p>Some common matchers are <code class="literal">toBe</code>, <code class="literal">toEqual</code>, <code class="literal">toMatch</code>, <code class="literal">toBeNull</code>, <code class="literal">toBeDefined</code>, <code class="literal">toBeUndefined</code>, and <code class="literal">toContain</code>.</p><p>Consider the given example:</p><pre class="programlisting">describe("A sample test suite to test jasmine assertion", function() {  &#13;
    var a, b; &#13;
    it("Title for a spec", function() { &#13;
        var a = true; &#13;
        expect(a).toBe(true); &#13;
        expect(b).not.toBe(true); &#13;
    }); &#13;
}); &#13;
</pre></div><div class="section" title="Setup and teardown"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Setup and teardown</h2></div></div></div><p>To improve the test suite by DRY (Don't repeat yourself) up duplicated setup and teardown code, Jasmine provides some global functions for the setup and teardown. Those global functions (<code class="literal">beforeEach</code>, <code class="literal">afterEach</code>, and so on) are as follows and they run as the name implies.</p><p>Every function runs against a test spec. Jasmine's global setup and the teardown functions are <code class="literal">beforeEach</code>, <code class="literal">afterEach</code>, <code class="literal">beforeAll</code>, and <code class="literal">afterAll</code>.</p><p>Consider the following example:</p><pre class="programlisting">describe("A sample test suite to test jasmine assertion", function() { &#13;
    var a=0;    &#13;
    beforeEach(function() { &#13;
        a +=1; &#13;
    }); &#13;
    afterEach(function() { &#13;
        a =0; &#13;
    }); &#13;
    it("Title for a spec 1", function() { &#13;
        expect(a).toEqual(1); &#13;
    }); &#13;
    it("Title for a spec 2", function() { &#13;
        expect(a).toEqual(1); &#13;
        expect(a).not.toEqual(0); &#13;
    }); &#13;
}); &#13;
</pre></div><div class="section" title="Spies"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Spies</h2></div></div></div><p>Spies are test double functions in Jasmine; they can stub any function and track calls on it and to all its arguments. There are a few matchers around to track if any spy has been called or not. These are <code class="literal">toHaveBeenCalled</code>, <code class="literal">toHaveBeenCalledTimes</code>, and so on.</p><p>There are some useful chained methods used with spy, such as <code class="literal">returnValue</code>/ <code class="literal">returnValues</code>, which will return one or more values when called by chaining with spy. There are a few more similar useful methods, such as <code class="literal">callThrough</code>, <code class="literal">call</code>, <code class="literal">stub</code>, <code class="literal">call.allArgs</code>, <code class="literal">call.first</code>, and <code class="literal">call.reset</code>.</p><p>Consider the following example:</p><pre class="programlisting">describe("A sample test suite to test jasmine assertion", function() { &#13;
    var myObj, a, fetchA; &#13;
    beforeEach(function() { &#13;
        myObj = { &#13;
            setA: function(value) { &#13;
                a = value; &#13;
            }, &#13;
            getA: function(value) { &#13;
                return a; &#13;
            }, &#13;
        }; &#13;
        spyOn(myObj, "getA").and.returnValue(789); &#13;
        myObj.setA(123); &#13;
        fetchA = myObj.getA(); &#13;
    }); &#13;
 &#13;
    it("tracks that the spy was called", function() { &#13;
         expect(myObj.getA).toHaveBeenCalled(); &#13;
    }); &#13;
    it("should not affect other functions", function() { &#13;
        expect(a).toEqual(123); &#13;
    }); &#13;
    it("when called returns the requested value", function() { &#13;
        expect(fetchA).toEqual(789); &#13;
    }); &#13;
}); &#13;
</pre></div><div class="section" title="The test suite of Jasmine"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec32"/>The test suite of Jasmine</h2></div></div></div><p>In the preceding section, we looked over some commonly used assertions that all test frameworks, including Jasmine, use in any kind of test suite.</p><p>Though in this book, we will build an automated test suite for Angular testing, let's try some assertion in a Jasmine test suite and see how it works. This sample test suite will give us some hands on experience of how the assertions work on a test suite.</p><p>For this test suite, we will use Jasmine's sample spec runner project (which is available in the Jasmine downloaded bundle in the example), and the project's folder structure will look as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_001.jpg" alt="The test suite of Jasmine"/></div><p>
</p><p>Let's take a quick look at the files that we have to update in the Jasmine's sample <code class="literal">SpecRunner</code> project:</p><pre class="programlisting">SpecRunner.html: &#13;
&lt;!DOCTYPE HTML&gt; &#13;
&lt;html&gt; &#13;
&lt;head&gt; &#13;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &#13;
    &lt;title&gt;Jasmine Spec Runner v2.4.1&lt;/title&gt; &#13;
    &lt;link rel="shortcut icon" type="image/png" href="lib/jasmine-2.4.1/jasmine_favicon.jpg"&gt; &#13;
    &lt;link rel="stylesheet" type="text/css" href="lib/jasmine-2.4.1/jasmine.css"&gt; &#13;
 &#13;
    &lt;script type="text/javascript" src="lib/jasmine-2.4.1/jasmine.js"&gt;&lt;/script&gt; &#13;
    &lt;script type="text/javascript" src="lib/jasmine-2.4.1/jasmine-html.js"&gt;&lt;/script&gt; &#13;
    &lt;script type="text/javascript" src="lib/jasmine-2.4.1/boot.js"&gt;&lt;/script&gt; &#13;
    &lt;!-- include source files here... --&gt; &#13;
    &lt;script type="text/javascript" src="src/mySource.js"&gt;&lt;/script&gt; &#13;
    &lt;!-- include spec files here... --&gt; &#13;
    &lt;script type="text/javascript" src="spec/mySpec.js"&gt;&lt;/script&gt; &#13;
&lt;/head&gt; &#13;
&lt;body&gt; &#13;
&lt;/body&gt; &#13;
&lt;/html&gt; &#13;
 &#13;
src/mySource.js: &#13;
var a, &#13;
myObj = { &#13;
    setA: function(value) { &#13;
        a = value; &#13;
    }, &#13;
    getA: function(value) { &#13;
        return a; &#13;
    }, &#13;
}; &#13;
 &#13;
Spec/mySpec.js: &#13;
describe("A sample test suite to test jasmine assertion", function() { &#13;
    var fetchA; &#13;
    beforeEach(function() { &#13;
        spyOn(myObj, "getA").and.returnValue(789); &#13;
        myObj.setA(123); &#13;
        fetchA = myObj.getA(); &#13;
    }); &#13;
 &#13;
    it("tracks that the spy was called", function() { &#13;
         expect(myObj.getA).toHaveBeenCalled(); &#13;
    }); &#13;
    it("should not affect other functions", function() { &#13;
        expect(a).toEqual(123); &#13;
    }); &#13;
    it("when called returns the requested value", function() { &#13;
        expect(fetchA).toEqual(789); &#13;
    }); &#13;
}); &#13;
</pre><p>As long as it's a browser-based test suite, we have to point <code class="literal">SpecRunner.html</code> to a web browser to get the test result. We will have all the tests passed and our test result will look as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_002-1.jpg" alt="The test suite of Jasmine"/></div><p>
</p></div></div>
<div class="section" title="The Jasmine test suite for Angular"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>The Jasmine test suite for Angular</h1></div></div></div><p>In the preceding example, we saw a Jasmine test suite for JavaScript testing, but what about for Angular, how should that look? Actually, there is no direct answer as, for the Angular project test suite, we will not use a browser-based test suite; we have a test runner with Karma for the test suite. But as we are familiar with the browser-based Jasmine test suite in the preceding example, let's see what that will look like if we make a similar one for the Angular project.</p><p>We will have to add a subfolder as <code class="literal">src</code> in the Angular project for the test spec, and then the project's folder structure will look like this:</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_003.jpg" alt="The Jasmine test suite for Angular"/></div><p>
</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note5"/>Note</h3><p>In the Angular project, we will use TypeScript rather than plain JavaScript as Angular officially suggests using TypeScript. So, we hope that we all know the TypeScript syntax and know how to compile to JS.</p><p>In this book, for the Angular test suite, we will use SystemJS as the module loader, as Angular officially suggests it; we will take a look at SystemJS.</p><p>This sample Angular test suite is just to show how easily we can make a test suite for an Angular project, though it's not following the best practices and the best way to load the modules.</p><p>In <a class="link" href="ch03.html" title="Chapter 3. The Karma Way">Chapter 3</a>, <span class="emphasis"><em>The Karma Way</em></span>, we will update this test suite with real-life examples and use SystemJS as the module loader.</p><p>There is a seed project from the Angular team in GitHub called as <code class="literal">Angular2-seed</code> to bootstrap any Angular project with test suite; we will follow that one for our real Angular project.</p></div></div><p>If we look at the folder structure, it's almost the same as the previous one, and there are minimum changes in the spec file as well; the only change in spec is with TypeScript:</p><pre class="programlisting">src/unit-tests.html: &#13;
 &#13;
&lt;!DOCTYPE html&gt; &#13;
&lt;html&gt; &#13;
&lt;head&gt; &#13;
    &lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt; &#13;
    &lt;title&gt;NG2 App Unit Tests&lt;/title&gt; &#13;
    &lt;link rel="stylesheet" href="node_modules/jasmine-core/lib/jasmine-core/jasmine.css"&gt; &#13;
    &lt;script src="node_modules/jasmine-core/lib/jasmine-core/jasmine.js"&gt;&lt;/script&gt; &#13;
    &lt;script src="node_modules/jasmine-core/lib/jasmine-core/jasmine-html.js"&gt;&lt;/script&gt; &#13;
    &lt;script src="node_modules/jasmine-core/lib/jasmine-core/boot.js"&gt;&lt;/script&gt; &#13;
    &lt;script src="../app/mysource.js"&gt;&lt;/script&gt; &#13;
    &lt;script src="my.spec.js"&gt;&lt;/script&gt; &#13;
 &#13;
&lt;/head&gt; &#13;
&lt;body&gt; &#13;
&lt;/body&gt; &#13;
&lt;/html&gt; &#13;
 &#13;
app/mysource.ts: &#13;
export class Source { &#13;
    // ...  &#13;
} &#13;
 &#13;
src/my.spec.ts: &#13;
describe('1st tests', () =&gt; { &#13;
    it('true is true', () =&gt; expect(true).toEqual(true)); &#13;
 &#13;
    it('null is not the same thing as undefined', &#13;
        () =&gt; expect(null).not.toEqual(undefined) &#13;
    ); &#13;
}); &#13;
</pre><p>As this is also a browser-based test suite, we have to point <code class="literal">unit-tests.html</code> in a web browser to get the test result. We will have all the tests passed, and our test result will look like this:</p><p>
</p><div class="mediaobject"><img src="graphics/image_02_004.jpg" alt="The Jasmine test suite for Angular"/></div><p>
</p></div>
<div class="section" title="Self-test questions"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Self-test questions</h1></div></div></div><p>Self-test questions will help you further test your knowledge of using TDD for JavaScript application testing.</p><p>Q1. End-to-end testing means what kind of test?</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Functional test</li><li class="listitem" style="list-style-type: disc">Behavior test</li></ul></div><p>Q2. Protractor is a Unit testing framework.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">True</li><li class="listitem" style="list-style-type: disc">False</li></ul></div><p>Q3. PhantomJS is a type of browser.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">True</li><li class="listitem" style="list-style-type: disc">False</li></ul></div><p>Q4. What is QUnit a test framework for?</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">jQuery</li><li class="listitem" style="list-style-type: disc">Angular</li><li class="listitem" style="list-style-type: disc">NodeJS</li></ul></div><p>Q5. Setup and teardown is a feature of Jasmine.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">True</li><li class="listitem" style="list-style-type: disc">False</li></ul></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Summary</h1></div></div></div><p>In this chapter, we reviewed different mechanisms of testing TDD and covered automated testing. We reviewed different kinds of JavaScript testing frameworks and tools and reviewed the uses of those frameworks with their pros and cons. We also reviewed some common assertions from Jasmine and tried, hands on, how they worked.</p><p>In the next chapter, we will learn about Karma and see how that works with the Angular test suite.</p></div></body></html>