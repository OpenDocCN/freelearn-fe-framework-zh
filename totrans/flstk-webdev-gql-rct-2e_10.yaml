- en: '*Chapter 8*: Routing in React'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, we have one screen and one path that our users can visit. When users
    visit Graphbook, they can log in and see their news feed and chats. Another requirement
    for a social network is that users have their own profile pages. We will implement
    this feature in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will introduce client-side routing for our React application.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up React Router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced routing with React Router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available in the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter08)'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up React Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Routing is essential to most web applications. You cannot cover all of the features
    of your application in just one page. It would be overloaded, and your user would
    find it difficult to understand. Sharing links to pictures, profiles, or posts
    is also very important for a social network such as Graphbook. One advantageous
    feature, for example, is being able to send links to specific profiles. This requires
    each profile to have its own **Uniform Resource Locator** (**URL**) and page.
    Otherwise, it will not be possible to share a direct link to a single item of
    your application. It is also crucial to split the content into different pages,
    due to **search engine optimization** (**SEO**).
  prefs: []
  type: TYPE_NORMAL
- en: At the moment, we render our complete application to **HyperText Markup Language**
    (**HTML**) in the browser, based on the authentication status. Only the server
    implements a simple routing functionality. Carrying out client-side routing can
    save a lot of work and time for the user if the router merely swaps out the correct
    parts in React, instead of reloading the page completely when following a link.
    It is vital that the application makes use of the HTML5 history implementation
    so that it handles the history of the browser. Importantly, this should also work
    for navigation in different directions. We should be able to go forward and backward
    with the arrow navigation buttons in the browser, without reloading the application.
    No unnecessary page reloads should happen with this solution.
  prefs: []
  type: TYPE_NORMAL
- en: Common frameworks that you may know about, such as Angular, Ember, and Ruby
    on Rails, use static routing. That is also the case for Express.js, which we covered
    in [*Chapter 2*](B17337_02_Final_ASB_ePub.xhtml#_idTextAnchor032)*,* *Setting
    Up GraphQL with Express.js*, of this book. **Static routing** means that you configure
    your routing flow and the components to render upfront. Your application then
    processes the routing table in a separate step, renders the required components,
    and presents the results to the user.
  prefs: []
  type: TYPE_NORMAL
- en: With the release of version 4 and also the current version 5 of React Router,
    which we are going to use, **dynamic routing** was introduced. The unique thing
    about it is that the routing takes place while the rendering of your application
    is running. It doesn't require the application to first process a configuration
    in order to show the correct components. This approach fits with React's workflow
    well. The routing happens directly in your application, not in a preprocessed
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Installing React Router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the past, there were a lot of React routers, with various implementations
    and features. As we mentioned previously, we are going to install and configure
    version 5 for this book. If you search for other tutorials on this topic, make
    sure that you follow the instructions for this version. Otherwise, you might miss
    some of the changes that React Router has gone through.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install React Router, simply run `npm` again, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: From the package name, you might assume that this is not the main package for
    React. The reason for this is that React Router is a multi-package library. That
    comes in handy when using the same tool for multiple platforms. The core package
    is called `react-router`.
  prefs: []
  type: TYPE_NORMAL
- en: There are two further packages. The first one is the `react-router-dom` package,
    which we installed in the preceding code snippet, and the second one is the `react-router-native`
    package. If at some point, you plan to build a React Native app, you can use the
    same routing instead of using the browser's **Document Object Model** (**DOM**)
    for a real mobile app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step that we will take introduces a simple router to get our current
    application working, including different paths for all of the screens. The routes
    that we are going to add are detailed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Our posts feed, chats, and the top bar, including the search box, should be
    accessible under the `/app` route of our application. The path is self-explanatory,
    but you could also use the `/` root as the main path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The login and signup forms should have a separate path, which will be accessible
    under the `/` root path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we do not have any further screens, we also have to handle a situation in
    which none of the preceding routes match. In that case, we could display a so-called
    404 page, but instead, we are going to redirect to the root path directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is one thing that we have to prepare before continuing. For development,
    we are using the webpack development server, as this is what we configured in
    [*Chapter 1*](B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017), *Preparing Your
    Development Environment*. To get the routing working out of the box, we will add
    two parameters to the `webpack.client.config.js` file. The `devServer` field should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `historyApiFallback` field tells `devServer` to serve the `index.html` file,
    not only for the root path, `http://localhost:3000/`, but also when it would typically
    receive a 404 error (such as for paths like `http://localhost:3000/app`). This
    happens when the path does not match a file or folder that is normal when implementing
    routing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `output` field at the top of the `config` file must have a `publicPath`
    property, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `publicPath` property tells webpack to prefix the bundle URL to an absolute
    path, instead of a relative path. When this property is not included, the browser
    cannot download the bundle when visiting the sub-directories of our application,
    as we are implementing client-side routing. Let's begin with the first path and
    bind the central part of our application, including the news feed, to the `/app`
    path.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing your first route
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before implementing the routing, we will clean up the `App.js` file. To do
    this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Main.js` file next to the `App.js` file in the `client` folder. Insert
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you might have noticed, the preceding code is pretty much the same as the
    logged-in condition inside the `App.js` file. The only change is that the `changeLoginState`
    function is taken from the properties and is not directly a method of the component
    itself. That is because we split this part out of the `App.js` file and put it
    in a separate file. This improves reusability for other components that we are
    going to implement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, open and replace the `return` statement of the `App` component to reflect
    those changes, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you compare the preceding method with the old one, you can see that we have
    inserted a `Router` component, instead of directly rendering either the posts
    feed or the login form. The original components of the `App.js` file are now in
    the previously created `Main.js` file. Here, we pass the `loggedIn` property and
    the `changeLoginState` function to the `Router` component. Remove the dependencies
    at the top, such as the `Chats` and `Feed` components, because we won't use them
    any more thanks to the new `Main` component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following line to the dependencies of our `App.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To get the routing working, we have to implement our custom `Router` component
    first. Generally, it is easy to get the routing running with React Router, and
    you are not required to separate the routing functionality into a separate file,
    but that makes it more readable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To do this, create a new `router.js` file in the `client` folder, next to the
    `App.js` file, with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the top, we import all of the dependencies. They include the new `Main`
    component and the `react-router` package. Here is a quick explanation of all of
    the components that we are importing from the React Router package:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BrowserRouter` (or `Router`, for short, as we called it here) is the component
    that keeps the URL in the address bar in sync with the **user interface** (**UI**);
    it handles all of the routing logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Switch` component forces the first matching `Route` or `Redirect` component
    to be rendered. We need it to stop re-rendering the UI if the user is already
    in the location to which a redirect is trying to navigate. I generally recommend
    that you use the `Switch` component, as it catches unforeseeable routing errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Route` is the component that tries to match the given path to the URL of the
    browser. If this is the case, the `component` property is rendered. You can see
    in the preceding code snippet that we are not setting the `Main` component directly
    as a parameter; instead, we return it from a stateless function. That is required
    because the `component` property of a `Route` component only accepts functions
    and not a component object. This solution allows us to pass the `changeLoginState`
    function to the `Main` component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Redirect` navigates the browser to a given location. The component receives
    a property called `to`, filled by a path starting with `/`. We are going to use
    this component in the next section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The problem with the preceding code is that we are only listening for one route,
    which is `/app`. If you are not logged in, there will be many errors that are
    not covered. The best thing to do would be to redirect the user to the root path,
    where they can log in.
  prefs: []
  type: TYPE_NORMAL
- en: Secured routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Secured routes** represent a way to specify paths that are only accessible
    if the user is authenticated or has the correct authorization.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The recommended solution to implement secure routes in React Router is to write
    a small, stateless function that conditionally renders either a `Redirect` component
    or the component specified on the route that requires an authenticated user. We
    extract the `component` property of the router into the `Component` variable,
    which is a renderable React object:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert the following code into the `router.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We call the `PrivateRoute` stateless function. It returns a standard `Route`
    component, which receives all of the properties initially given to the `PrivateRoute`
    function. To pass all properties, we use a destructuring assignment with the `...rest`
    syntax. Using the syntax inside of curly braces on a React component passes all
    fields of the `rest` object as properties to the component. The `Route` component
    is only rendered if the given path is matched.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Furthermore, the rendered component is dependent on the user's `loggedIn` state
    variable, which we have to pass. If the user is logged in, we render the `Component`
    variable without any problems. Otherwise, we redirect the user to the root path
    of our application using the `Redirect` component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the new `PrivateRoute` component in the `return` statement of the `Router`
    component and replace the old `Route` component, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we pass the `loggedIn` property by taking the value from the properties
    of the `Router` component itself. It initially receives the `loggedIn` property
    from the `App` component that we edited previously. The great thing is that the
    `loggedIn` variable can be updated from the parent `App` component at any time.
    That means that the `Redirect` component is rendered, and the user is automatically
    navigated to the login form if the user logs out, for example. We do not have
    to write separate logic to implement this functionality.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: However, we have now created a new problem. We redirect from `/app` to `/` if
    the user is not logged in, but we do not have any routes set up for the initial
    `'/'` path. It makes sense for this path to either show the login form or to redirect
    the user to `/app` if the user is logged in. The pattern for the new component
    is the same as the preceding code for the `PrivateRoute` component but in the
    opposite direction.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the new `LoginRoute` component to the `router.js` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding condition is inverted to render the original component. If the
    user is not logged in, the login form is rendered. Otherwise, they will be redirected
    to the posts feed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the new path to the router, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The code looks the same as that of the `PrivateRoute` component, except that
    we now have a new property, called `exact`. If we pass this property to a route,
    the browser''s location has to match 100%. The following table shows a quick example,
    taken from the official React Router documentation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B17337_08_Table_8.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For the root path, we set `exact` to `true` because otherwise, the path matches
    with any browser's location where `/` is included, as you can see in the preceding
    table.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are many more configuration options that React Router offers, such as
    enforcing trailing slashes, case sensitivity, and much more. You can find all
    of the options and examples in the official documentation at [https://v5.reactrouter.com/web/api/](https://v5.reactrouter.com/web/api/).
  prefs: []
  type: TYPE_NORMAL
- en: Catch-all routes in React Router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently, we have two paths set up, which are `/app` and `/`. If a user visits
    a non-existent path, such as `/test`, they will see an empty screen. The solution
    is to implement a route that matches any path. For simplicity, we redirect the
    user to the root of our application, but you could easily replace the redirection
    with a typical 404 page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `router.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `NotFound` component is minimal. It just redirects the user to the root
    path. Add the next `Route` component to the `Switch` component in the `Router`
    component. Ensure that it is the last one on the list. The code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are rendering a simple `Route` component in the preceding
    code. What makes the route special is that we are not passing a `path` property
    with it. By default, the `path` property is completely ignored, and the component
    is rendered every time, except if there is a match with a previous component.
    That is why we added the route to the bottom of the `Router` component. When no
    route matches, we redirect the user to the login screen in the root path, or,
    if the user is already logged in, we redirect them to a different screen using
    the routing logic of the root path. Our `LoginRoute` component handles this last
    case.
  prefs: []
  type: TYPE_NORMAL
- en: You can test all changes when starting the frontend with `npm run client` and
    the backend with `npm run server`. We have now moved the current state of our
    application from a standard, single-route application to an application that differentiates
    the login form and the news feed based on the location of the browser.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will have a look at how we can implement more complicated
    routing by adding parameterized routes and loading the data depending on those
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced routing with React Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary goal of this chapter is to build a profile page for your users.
    We need a separate page to show all of the content that a single user has entered
    or created. The content would not fit next to the posts feed. When looking at
    Facebook, we can see that every user has their own address, under which we can
    find the profile page of a specific user. We are going to create our profile page
    in the same way and use the username as the custom path.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to implement the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: We add a new parameterized route for the user profile. The path starts with
    `/user/` and follows a username.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We change the user profile page to send all GraphQL queries, including the `username`
    route parameter, inside of the `variables` field of the GraphQL request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We edit the `postsFeed` query to filter all posts by the `username` parameter
    provided.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We implement a new GraphQL query on the backend to request a user by their username,
    in order to show information about the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When all of the queries are finished, we render a new user profile header component
    and the posts feed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we enable navigation between each page without reloading the complete
    page, but only the changed parts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's start by implementing routing for the profile page in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters in routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have prepared most of the work required to add a new user route. Open up
    the `router.js` file again. Add the new route, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The code contains two new elements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The path that we entered is `/user/:username`. As you can see, the username
    is prefixed with a colon, telling React Router to pass the value of it to the
    underlying component being rendered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The component that we rendered previously was a stateless function that returned
    either the `LoginRegisterForm` component or the `Main` component. Neither of these
    received any parameters or properties from React Router. Now, however, it is required
    that all properties of React Router are transferred to the child component. That
    includes the `username` parameter that we just introduced. We use the same destructuring
    assignment with the `props` object to pass all properties to the `User` component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Those are all of the changes that we need to accept parameterized paths in
    React Router. We read out the value inside of the new user page component. Before
    implementing it, we import the dependency at the top of `router.js` to get the
    preceding route working, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the preceding `User.js` file next to the `Main.js` file. As with the
    `Main` component, we are collecting all of the components that we render on this
    page. You should stay with this layout, as you can directly see which main parts
    each page consists of. The `User.js` file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We have all common components including the `Bar` and `Chat` component. If a
    user visits the profile of a friend, they see the common application bar at the
    top. They can access their chats on the right-hand side, like on Facebook. It
    is one of the many situations in which React and the reusability of components
    come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: We removed the `Feed` component and replaced it with a new `UserProfile` component.
    Importantly, the `UserProfile` component receives the `username` property. Its
    value is taken from the properties of the `User` component. These properties were
    passed over by React Router. If you have a parameter, such as `username`, in the
    routing path, the value is stored in the `match.params.username` property of the
    child component. The `match` object generally contains all matching information
    of React Router.
  prefs: []
  type: TYPE_NORMAL
- en: From this point on, you can implement any custom logic that you want with this
    value. We will now continue with implementing the profile page.
  prefs: []
  type: TYPE_NORMAL
- en: One thing before building the user profile page is to extract the feed rendering
    logic to a separate component to reuse it. Create a `feedlist.js` file inside
    the `post` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert the following code in the `feedlist.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the following dependencies at the top, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, just copy the main parts of the feed list `return` statement, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'One thing that is missing now is the `loadMore` function, which we also can
    just copy. Just add it straight to the preceding component, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Just replace the part on the `Feed.js` file''s `return` statement. It should
    look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can use this `FeedList` component now where we need to display a feed of
    posts, such as on our user profile page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to build the user''s profile page:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder, called `user`, inside the `components` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file, called `index.js`, inside the `user` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the dependencies at the top of the file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first three lines should look familiar. Two imported files, however, do
    not exist at the moment, but we are going to change that shortly. The first new
    file is `UserHeader`, which takes care of rendering the avatar image, the name,
    and information about the user. Logically, we request the data that we will display
    in this header through a new Apollo query Hook, called `getUser`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Insert the code for the `UserProfile` component that we are building at the
    moment beneath the dependencies, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `UserProfile` component is not complex. We are running two Apollo queries
    simultaneously. Both have the `variables` property set. The `useGetPostsQuery`
    Hook receives the username, which initially came from React Router. This property
    is also handed over to `useGetUserQuery`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now edit and create Apollo queries, before programming the profile header component.
    Open the `getPosts.js` file from the `queries` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To use the username as input to the GraphQL query, we first have to change
    the query string from the `GET_POSTS` variable. Change the first two lines to
    match the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, replace the last line with the following code to provide a way to pass
    variables to the `useQuery` Hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the custom query component receives a `username` property, it is included
    in the GraphQL request. It is used to filter posts by the specific user that we
    are viewing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a new `getUser.js` file in the `queries` folder to create a query Hook,
    which we are missing at present.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import all of the dependencies and parse the new query schema with `gql`, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding query is nearly the same as the `currentUser` query. We are going
    to implement the corresponding `user` query later, in our GraphQL **application
    programming interface** (**API**).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last step is to implement the `UserProfileHeader` component. This component
    renders the `user` property, with all its values. It is just simple HTML markup.
    Copy the following code into the `header.js` file, in the `user` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you need help getting the **Cascading Style Sheets** (**CSS**) styling right,
    take a look at the official repository for this book. The preceding code only
    renders the user's data; you could also implement features such as a chat button,
    which would give the user the option to start messaging with other people. Currently,
    we have not implemented this feature anywhere, but it is not necessary to explain
    the principles of React and GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: We have finished the new frontend components, but the `UserProfile` component
    is still not working. The queries that we are using here either do not accept
    the `username` parameter or have not yet been implemented.
  prefs: []
  type: TYPE_NORMAL
- en: The next section will cover which parts of the backend have to be adjusted.
  prefs: []
  type: TYPE_NORMAL
- en: Querying the user profile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the new profile page, we have to update our backend accordingly. Let''s
    take a look at what needs to be done, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We have to add the `username` parameter to the schema of the `postsFeed` query
    and adjust the resolver function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have to create a schema and a resolver function for the new `UserQuery` component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will begin with the `postsFeed` query:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `postsFeed` query in the `RootQuery` type of the `schema.js` file
    to match the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, I have added `username` as an optional parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, head over to the `resolvers.js` file and take a look at the corresponding
    `resolver` function. Replace the signature of the function to extract the username
    from the variables, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make use of the new parameter, add the following lines of code above the
    `return` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have already covered the basic Sequelize API and how to query associated
    models by using the `include` parameter in [*Chapter 3*](B17337_03_Final_ASB_ePub.xhtml#_idTextAnchor054),
    *Connecting to the Database*. An important point is how we filter posts associated
    with a user by their username. We''ll do this in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we fill the `include` field of the `query` object with
    the Sequelize model that we want to join. This allows us to filter the associated
    `User` model in the next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we create a normal `where` object in which we write the filter condition.
    If you want to filter the posts by an associated table of users, you can wrap
    the model and field names that you want to filter by with dollar signs. In our
    case, we wrap `User.username` with dollar signs, which tells Sequelize to query
    the `User` model's table and filter by the value of the `username` column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No adjustments are required for the pagination part. The GraphQL query is now
    ready. The great thing about the small changes that we have made is that we have
    just one API function that accepts several parameters, either to display posts
    on a single user profile or to display a list of posts, such as a news feed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on and implement the new `user` query:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line to the `RootQuery` type in your GraphQL schema:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This query only accepts a `username` parameter, but this time it is a required
    parameter in the new query. Otherwise, the query would make no sense since we
    only use it when visiting a user's profile through their username.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `resolvers.js` file, implement the resolver function using Sequelize,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code snippet, we use the `findOne` method of the `User` model
    by using Sequelize and search for exactly one user with the username that we provided
    in the parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that the backend code and the user page are ready, we have to allow the
    user to navigate to this new page. The next section will cover user navigation
    using React Router.
  prefs: []
  type: TYPE_NORMAL
- en: Programmatic navigation in React Router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We created a new site with the user profile, but now we have to offer the user
    a link to get there. The transition between the news feed and the login and registration
    forms is automated by React Router, but not the transition from the news feed
    to a profile page. The user decides whether they want to view the profile of the
    user. React Router has multiple ways to handle navigation. We are going to extend
    the news feed to handle clicks on the username or the avatar image, in order to
    navigate to the user''s profile page. Open the `header.js` file in the `post`
    components folder. Import the `Link` component provided by React Router, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `Link` component is a tiny wrapper around a regular HTML `a` tag. Apparently,
    in standard web applications or websites, there is no complex logic behind hyperlinks;
    you click on them, and a new page is loaded from scratch. With React Router or
    most **single-page application** (**SPA**) **JavaScript** (**JS**) frameworks,
    you can add more logic behind hyperlinks. Importantly, instead of completely reloading
    the pages when navigating between different routes, this now gets handled by React
    Router. There won't be complete page reloads when navigating; instead, only the
    required parts are exchanged, and the GraphQL queries are run. This method saves
    the user expensive bandwidth because it means that we can avoid downloading all
    of the HTML, CSS, and image files again.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this, wrap the username and the avatar image in the `Link` component,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the rendered HTML, the `img` and `div` tags are surrounded by a common `a`
    tag but are handled inside React Router. The `Link` component receives a `to`
    property, which is the destination of the navigation. You have to copy one new
    CSS rule because the `Link` component has changed the markup. The code is illustrated
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If you test the changes now, clicking on the username or avatar image, you should
    notice that the content of the page dynamically changes but does not entirely
    reload. A further task would be to copy this approach to the user search list
    in the application bar and the chats. Currently, the users are displayed, but
    there is no option to visit their profile pages by clicking on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at another way to navigate with React Router. If the
    user has reached a profile page, we want them to navigate back by clicking on
    a button in the application bar. First of all, we will create a new `home.js`
    file in the `bar` folder, and we will enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We are using multiple React Router techniques here. We export the `Home` component
    through a `withRouter` HOC gives the `Home` component access to the `history`
    object of React Router. That is great because it means that we do not need to
    pass this object from the top of our React tree down to the `Home` component.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we use the `history` object to navigate the user to the news feed.
    In the `render` method, we return a button that, when clicked, runs the `history.push`
    function. This function adds the new path to the history of the browser and navigates
    the user to the `'/app'` main page. The good thing is that it works in the same
    way as the `Link` component and does not reload the entire website.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few things to do in order to get the button working, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the component into the `index.js` file of the `bar` folder, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, replace the `buttons` `div` tag with the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Wrap the two buttons in a separate `div` tag so that it is easier to align
    them correctly. You can replace the old CSS for the **Logout** button and add
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have everything together, the user can visit the profile page and
    navigate back again. Our final result looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – User profile'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.01_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – User profile
  prefs: []
  type: TYPE_NORMAL
- en: We have a big profile header for the user and their posts at the bottom of the
    window. At the top, you can see the top bar with the currently logged-in user.
  prefs: []
  type: TYPE_NORMAL
- en: Remembering the redirect location
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a visitor comes to your page, they have probably followed a link that was
    posted elsewhere. This link is likely to be a direct address for a user, a post,
    or anything else that you offer direct access to. For those that are not logged
    in, we configured the application to redirect that person to the login or signup
    forms. This behavior makes sense. However, once that person has either logged
    in or signed up with a new account, they are then navigated to the news feed.
    A better way of doing this would be to remember the initial destination that the
    person wanted to visit. To do this, we will make a few changes to the router.
    Open the `router.js` file. With all of the routing components provided by React
    Router, we always get access to the properties inside of them. We will make use
    of this and save the last location that we were redirected from.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PrivateRoute` component, swap out the `Redirect` component with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have added the `state` field. The value that it receives comes from
    the parent `Route` component, which holds the last matched path in the `props.location`
    field generated by React Router. The path can be a user's profile page or the
    news feed since both rely on the `PrivateRoute` component where authentication
    is required. When the preceding redirect is triggered, you receive the `from`
    field inside the router's state.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to use this variable when the user is logging in. Replace the `Redirect`
    component in the `LoginRoute` component with the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, I have introduced a small condition for the `pathname` parameter. If the
    `location.state` property is defined, we can rely on the `from` field. Previously,
    we stored the redirect path in the `PrivateRoute` component. If the `location.state`
    property does not exist, the user was not visiting a direct hyperlink but just
    wanted to log in normally. They will be navigated to the news feed with the `/app`
    path.
  prefs: []
  type: TYPE_NORMAL
- en: Your application should now be able to handle all routing scenarios, and this
    should allow your users to view your site comfortably.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we transitioned from our one-screen application to a multi-page
    setup. React Router, our main library for routing purposes now has three paths,
    under which we display different parts of Graphbook. Furthermore, we now have
    a catch-all route, in which we can redirect the user to a valid page.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue with this progression by implementing
    server-side rendering, which needs many adjustments on both the frontend and the
    backend.
  prefs: []
  type: TYPE_NORMAL
