- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing State in a Simple React App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we went over a brief history of web development, **JavaScript**,
    **ReactJS**, and **React Native**. Even though historical knowledge is not required
    to write great code, I find it useful. Once we learn why specific library creators
    encourage some patterns and discourage others, we can write code that is less
    error-prone and more performant. Ah yes! Writing code! That’s why you’re here,
    dear reader, isn’t it? Well, I have good news. In this chapter, we will dive into
    code examples. We will start by looking at the most basic data and state management
    strategies in React: using state and props. We will then dive into a comparison
    of stateful and stateless components. Once we have a good understanding of how
    state works in React applications, we will move on to talking about hooks. We
    will finish off this chapter by completing a setup and configuration of our own
    little app.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the bullet points of what we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: What is state and how is it different from props?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are stateful and stateless components?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are hooks and why use them?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the example app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should feel comfortable with React code. We
    will also set up the base for our application. Even though applications can be
    very different from one another, this basic setup will remain the same for most
    of them. Feel free to reuse it for any other project you may want to work on.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are familiar with **ReactJS** but you have not worked with **React Native**
    yet, you will be able to follow along with this section without any problem.
  prefs: []
  type: TYPE_NORMAL
- en: If you have never read or written any **ReactJS** or **React Native** code,
    it’s important that you learn the basic concepts. Please head over to the official
    **React Native** documentation at [https://reactnative.dev/docs/intro-react](https://reactnative.dev/docs/intro-react)
    and familiarize yourself with key concepts such as **components, JSX, state,**
    **and props**.
  prefs: []
  type: TYPE_NORMAL
- en: A minimum requirement for this chapter is knowledge of Git, basic knowledge
    of **command-line interfaces** (**CLIs**), and a working knowledge of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: What is state and how is it different from props?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every **React Native** application is created to display some sort of data.
    It can be weather data, images, market data, maps… Using **React Native**, we
    manage how this data is displayed on our users’ screens. **React Native** offers
    robust tools for styling and animating content. However, in this book, we are
    concentrating on the raw material of data used in your app.
  prefs: []
  type: TYPE_NORMAL
- en: In order to have a dynamic piece of data, existing **automagically** in sync
    with our component, we need to declare the list as a component state.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important thing to remember about state is this: state is managed
    within the component; it is the component **memory**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Any changes in state will cause your component and all its children to re-render.
    This is an expected behavior: if your data changes, you want your UI to change
    as well. However, multiple component re-renders may cause your app to encounter
    performance issues.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example to better understand state. We will start off with
    a very basic component, containing a `<Text>` element and a `<Pressable>` element.
    `<Pressable>` is the recommended component to use in React Native applications
    in places where a web developer would use a `<``button>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can probably observe, dear reader, nothing will happen when the `<Pressable>`
    component is tapped because we haven’t provided an `onPress` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now add state to this simple component. We will set a checked/unchecked
    text inside the `<Text>` component, linked to the component state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Testing React Native code is a little more complicated than testing code made
    to run in browsers (as with JavaScript or ReactJS). Lucky for us, the good people
    at Expo created an online tool for testing code snippets. It’s called Expo Snack
    and you can use it to test the preceding code at [https://snack.expo.dev/@p-syche/simplifying-state-management---chapter-2-example-1](https://snack.expo.dev/@p-syche/simplifying-state-management---chapter-2-example-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s walk through the changes one by one. We start by adding an import of
    the `useState` hook from the React library on the first line. Then, inside the
    component, we set this variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `useState` hook accepts an array, where the first item is the state value,
    and the second item is the function that will set the value. If you will not change
    the state in your component, you can omit the second argument. There is no official
    rule as per the names of the items in the array, but it is an accepted convention
    to name the setter function similarly to the state value, but with the `"set"`
    keyword. Last but not least, the `"unchecked"` string is passed to the `useState`
    hook. This is the default value of the `useState` hook. If you do not wish to
    set a default state, you may leave the parentheses empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the state hook imported and the component state set with the
    `useState` hook, we can use it in our component. Hence, this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The curly braces surrounding the state are part of **JSX**. **JSX** is a syntax
    extension to **JavaScript**, and it’s the syntax used to write all **React** components.
    "*What does that mean in regular English?"* you ask, dear reader. It means that
    when writing in **JSX**, you can write any **JavaScript** code, plus you can write
    additional stuff, such as **component state** wrapped in curly braces. You could
    look at **JSX** compared to **JavaScript** as if it were a pirate speaking as
    compared to plain English. All English pirates will understand all English phrases,
    but a regular Englishman will not understand all pirate phrases. All right, matey?
    Let’s move on then, yo ho ho!
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the state set up, but our `<Pressable>` component still doesn’t do
    anything, does it? Let’s add an `onPress` function, which will set the state.
    The simplest way to achieve this is to pass the `setCheckedState` function from
    the `useState` hook right into the `onPress` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, when the `<Pressable>` button is pressed, it will change the state of the
    component, which in turn will change the text displayed in the `<``Text>` component.
  prefs: []
  type: TYPE_NORMAL
- en: There is much more you can achieve with the `useState` hook. You can set it
    to any value you like, including an object. Every component can have multiple
    pieces of state, as many as you’d like, actually! If you would like to look at
    other examples of how state can be implemented in a React component, I invite
    you to check the first link from the *Further* *reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move on to the second hero of this section: props. Props is a short name
    for **properties**. Props are **JavaScript** objects just like state; the biggest
    difference between them is that props are read-only.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important thing to remember about props is this: props are immutable
    (or read-only).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A natural flow of a `"checked"`/`"unchecked"` state. The parent component has
    children: components with images or text, and so on, to whom we pass the state
    in the form of a prop. The children can `"checked"` or `"unchecked"`, in this
    case. But the children will never **change** the state of the text. The **state**
    of the text can only be changed within the parent component where state was declared.
    Let’s update our code example to include a parent and a child component, with
    state set in the parent and passed to the child through props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find the preceding code in this Expo Snack: [https://snack.expo.dev/@p-syche/simplifying-state-management---chapter-2-example-2](https://snack.expo.dev/@p-syche/simplifying-state-management---chapter-2-example-2).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with what remained the same as in the previous example. We have
    our `<ParentComponent>`, which, OK, was named `<ManagedButton>` before. But let’s
    be honest, this component didn’t change much from the previous version. The only
    change here is that instead of a `<Text>` component, we see a `<ManagedText>`
    component, with a mysterious `checkedState` property. This property is passed
    to the `<ManagedText>` component and then to the `<Text>` component inside it.
    Pressing the `<Pressable>` component will change the state of `<ParentComponent>`,
    which will also be reflected in the child component: `<ManagedText>`. I believe,
    dear reader, that the parent/child nomenclature is quite understandable and doesn’t
    need additional explanations. As per the `checkedState` property, or prop for
    short, you should know that you can name it whatever you would like; there is
    no need to set the name of the prop to be the same as its value. You could write
    something like this, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you’re curious to learn more about props and state, you can head over to
    articles recommended by the official React team. They are listed in the *Further*
    *reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know what state and props are and how they are different from each
    other, in the following section, we will look at stateful and stateless components.
  prefs: []
  type: TYPE_NORMAL
- en: What are stateful and stateless components?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether you’re completely new to the **React** world, or you’ve been here for
    a little while, you have probably heard the terms **stateful** and **stateless**
    components. These terms were especially useful before the introduction of hooks
    in **ReactJS** v16.8\. Don’t worry about hooks right now—we’ll get to them toward
    the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: From a high-level perspective, **ReactJS** and **React Native** components are
    nothing more than **JavaScript** functions. The **React** library adds some specific
    features to those functions. One of those features is **state**, a special kind
    of component memory that we looked at in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'A React component that can accept state may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This type of component is also commonly called a “class component” because of
    the way it needs to be declared. Class components, or stateful components, were
    first-class citizens until `componentDidMount()`, `componentWillUnmount()`, `shouldComponentUpdate()`,
    and a few others. These functions were a lifesaver for many developers facing
    edge cases. For example, they needed some data to be loaded before the rest of
    the **component**, or maybe they needed to make sure to clean up some side effect
    functions before the **component** unmounted. Unfortunately, this also meant that
    their **components** became increasingly complex logically. Trying to understand
    the flow of the code in a file containing multiple **“lifecycle methods”** is
    a real challenge. If you would like to learn more about lifecycle methods, please
    look at the *Further reading* section, where you will find a link to an article
    in the ReactJS documentation entitled *Adding Lifecycle Methods to* *a Class*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Stateful components** are also more difficult to test than **stateless components**,
    plus they compile slower and are bigger after compilation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stateless components**, also known as **functional components**, are the
    lightweight brothers of class components. Here’s an example of a stateless component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Comparing the two example **components** shown in the preceding snippet, you
    should notice a big difference in the number of lines of code needed to write
    the given **component**. Our simple stateful **component** needed nine lines for
    what the **functional component** achieved in three!
  prefs: []
  type: TYPE_NORMAL
- en: This means `constructor` or special `componentDidUpdate`. They do, of course,
    have the great downside of not being able to manage state. So, an ideal **ReactJS**
    or **React Native** app would include at least one parent, a stateful component,
    which then would pass props to all kinds of stateless children components. However,
    there are hardly any ideal apps in the real world. Developers would very often
    write stateful components and add lifecycle methods to manage when UI updates
    should and should not happen.
  prefs: []
  type: TYPE_NORMAL
- en: This trend changed with the aforementioned **ReactJS** v16.8 when the concept
    of hooks was introduced in the **ReactJS** world, which we are going to look at
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: What are hooks and why use them?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned before, stateless components are generally easier to write and
    test. They should be the go-to component of `useState` is a function that returns
    a stateful value and a function to update it. You may recognize it from our previous
    section about state in React components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go back to our example of a stateful component, change it to a functional
    one, and add the `useState` hook, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Ta-da! It looks so much cleaner than the previous example! We still have a component
    capable of holding and managing state changes, but it’s much shorter than the
    stateful class component. I also feel this type of component has a very nice logical
    flow, where we declare the state value and the state setter function on one line.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to see this code in action, you can go to [https://snack.expo.dev/@p-syche/example-of-functional-component-with-usestate](https://snack.expo.dev/@p-syche/example-of-functional-component-with-usestate).
  prefs: []
  type: TYPE_NORMAL
- en: This is an **Expo Snack**—an equivalent of code snippets for web development.
  prefs: []
  type: TYPE_NORMAL
- en: Which hooks should you know?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first hook we spoke about was `useState`, and that one is the absolute
    first you should familiarize yourself with. The second most used hook is `useEffect`.
    I also believe this is one of the best-named hooks. You can use it to add all
    sorts of side effects to your components. "*What is a side effect?"* you may ask,
    my dear reader. Let’s try to grasp this concept using examples: imagine a social
    media app (much like the app we will be building in this book!). Now, let’s imagine
    you are tasked with adding a likes counter. You have your parent `<Text>` **component**
    with a counter. It would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We are passing `counterNumber` from `<LikesParentComponent>` as a prop. Let’s
    assume this parent component handles retrieving the number of likes from an API
    using the very nicely named `someFunctionRetrievingDataFromAPI()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is looking pretty good so far, right? We load our components; they retrieve
    the likes data from an API and pass it to our `<LikesComponent>`, which displays
    it nicely. But wait! What happens if the user touches the `<Pressable>` component?
    We will set `<Text>` to `liked`, but the counter will not go up! We simply cannot
    leave it like this! This is a classic side effect: a user action requires additional
    changes in component state. First of all, we cannot change `counterNumber` from
    within `<LikesComponent>` because, as we learned in the previous section on state
    and props, props are immutable. What can we do, then? We can use the state setter
    function from the parent component. This function can be passed as a prop. This
    means `<LikesParentComponent>` will invoke its child, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good. Now, all we need to do is call this setter function at an
    appropriate time, which means when the button is pressed in `<LikesComponent>`.
    This is what it would look like using the `useEffect` hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you may notice, the `useEffect` hook looks very different from the `useState`
    hook. Don’t worry too much about this. These two hooks are the most used, and
    you will get used to the way they are conceived and consumed.
  prefs: []
  type: TYPE_NORMAL
- en: The inside of our example `useEffect` hook is a common `if`/`else` statement
    checking whether the value of the state equals `"liked"` or not. The most crucial
    and interesting part of this hook is the array at the very end. This array is
    called a dependency array. It is used to inform the hook function when it should
    run. In our case, the `useEffect` hook should run when the value of `likeState`
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `useEffect` hook can be used to update different pieces of the app, to
    help with data fetching, for user-driven interactions, and so on. This hook is
    very powerful, but it has a very big risk: it can cause many re-renders when written
    incorrectly.'
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing to remember about useEffect
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the dependency array of `useEffect` is correct!
  prefs: []
  type: TYPE_NORMAL
- en: As you may find in the official `useEffect`’s dependency array. If we set that,
    our effect will run *only* if any items in the dependency array change.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few other built-in hooks. You don’t have to know them all when starting
    to write `useState` and `useEffect`—will be enough to get you started. When you
    get to a point where those two hooks are not enough, you can go back to the **ReactJS**
    documentation and read about other hooks. You can also write your own custom hooks
    useful for your particular app.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what hooks are and why we use them, let’s get started with
    setting up our sample app!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the example app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ah! The moment you’ve probably been waiting for: actually creating an app!'
  prefs: []
  type: TYPE_NORMAL
- en: We will start by preparing our development environment. You will need an **integrated
    development environment** (**IDE**) such as VS Code, Sublime Text, Atom, or anything
    else you may prefer. An IDE is all you need to write **React Native** code. But
    we also need a way to see what the code renders, don’t we?
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of web development, we would simply use the browser to see and
    test our code. However, **React Native** apps cannot be easily tested in a web
    browser. They can and should be tested on real or simulated devices. In an ideal
    situation, you would have access to multiple phones, which you would plug into
    your computer via a USB in order to see your app. Most of us don’t have multiple
    phones, though. That’s why we can use phone simulators. There are two major players
    in the mobile world: Android and Apple. Android simulators are available for virtually
    any desktop platform thanks to the Android Studio app. Unfortunately, iPhone simulators
    can be run exclusively on Mac computers.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up simulators can be a daunting task, but don’t worry too much! There’s
    **Expo**!
  prefs: []
  type: TYPE_NORMAL
- en: 'I spoke about **Expo** in the first chapter. If you skipped that part, let
    me give you a quick rundown: **Expo** is **React Native** development tooling.
    It makes building, testing, and publishing apps much easier. **Expo** is a wrapper
    on top of **React Native**, aimed at making the developer experience smoother.'
  prefs: []
  type: TYPE_NORMAL
- en: Environment setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s make sure your development environment is ready. As listed on the Expo
    website, you will need the latest Node, Git, and Watchman. Links to all of these
    can be found in Expo’s documentation at [https://docs.expo.dev/get-started/installation/](https://docs.expo.dev/get-started/installation/).
    We will be using Yarn during development, so please make sure you have it installed.
    You can find detailed instructions here: [https://classic.yarnpkg.com/en/docs/install](https://classic.yarnpkg.com/en/docs/install).
    Once you have gone through the links, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re ready, go ahead and install Expo’s CLI tools:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Verify that the installation was successful by running `expo whoami`. You’re
    not logged in yet, so you will see `expo register`, or you can log in to an existing
    account with `expo login`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is to install the Expo Go app on your phone. You can find it in
    the Android Store at [https://play.google.com/store/apps/details?id=host.exp.exponent](https://play.google.com/store/apps/details?id=host.exp.exponent)
    and on the App Store at [https://apps.apple.com/app/expo-go/id982107779](https://apps.apple.com/app/expo-go/id982107779).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thanks to Expo, it does not matter if you have a Mac computer or a Windows computer
    and what kind of phone you have. The **Expo Go** app will “automagically” work
    on Android and Apple devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re all set—it’s time to create the app. Go to your terminal and run the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When prompted about templates, please choose **blank**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can choose any name you like for your app. I suggested using “`Funbook`”
    because it sounds a little like “Facebook” and we’ll be creating a social media
    app clone. Sticking with the same name as me will probably make it easier to follow
    along with code examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'After app initialization is successfully run, you can go to your app’s folder
    by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And run the development server, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or, if you’re using Yarn, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Expo CLI starts Metro Bundler, which is an HTTP server that compiles the JavaScript
    code of our app. You should see a QR code that you can now scan using the Expo
    Go app on your phone. You can run your Funbook app on as many devices as you’d
    like.
  prefs: []
  type: TYPE_NORMAL
- en: App development can seem a little daunting at first, but don’t worry if not
    everything works perfectly on the first try. There’s a big chance you will find
    the culprit in your terminal window. The terminal output is the best source of
    information for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you see any errors in the terminal, or you feel a little bit lost, make
    sure to check the Expo installation documentation: [https://docs.expo.dev/get-started/create-a-new-app/](https://docs.expo.dev/get-started/create-a-new-app/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'I set up a public repository that we will use throughout this book. You can
    find it here: [https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native).'
  prefs: []
  type: TYPE_NORMAL
- en: On the `main` branch of this repository, you will find an app that is already
    set up. Feel free to clone or fork this repository. Remember that if you want
    to run this app on your computer, you will still need to install `node`, `watchman`,
    and `yarn`).
  prefs: []
  type: TYPE_NORMAL
- en: App structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us consider which surfaces and components we will need for a simplistic
    social media app. By “surface," I mean what would be in web development a “page."
    That is a big building block of the app, composed of many components, presented
    together on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Our app will definitely need a login surface, a social media feed surface, and
    a personal profile surface. We will also add a screen containing favorited posts
    and another one where the user can add their post. We will use fake data for the
    feed and profile, and a single username and password for logging in. We won’t
    be implementing a registration flow in order to stay on the simple side of things.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to concentrate on data flows, so we will use a free social media UI
    kit to get the design “out of the way," so to speak. Here’s a link to the design
    file we will use: [https://www.pixeltrue.com/free-ui-kits/social-media-app](https://www.pixeltrue.com/free-ui-kits/social-media-app).'
  prefs: []
  type: TYPE_NORMAL
- en: App root
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app will consist of at least five surfaces, which means we need to set up
    navigation to be able to move between those surfaces. The user will start off
    on the login surface. They will fill in their information and they will be redirected
    to the social media feed surface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, we need a way for our users to move around the app. One of the most
    used navigation libraries is called **React Navigation**. This is a library created
    especially for **React Native** applications. It provides three types of navigation
    out of the box: Drawer navigation, Tab navigation, and Stack navigation. Drawer
    navigation is when you have a little drawer on the side of your app with links
    to different places in your app. Tab navigation will display tabs (either bottom
    or top) with links to different places. Stack navigation works like a stack of
    cards—each screen is a card having the ability to redirect to any other card.
    If you would like to know more about this library, you can find a link to the
    documentation in the *Further* *reading* section.'
  prefs: []
  type: TYPE_NORMAL
- en: There are other navigation libraries out there, but React Navigation is by far
    the most popular one in the **React Native** community. It is also actively maintained
    and updated to work with the newest **React** **Native** versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to start by adding the library as a dependency to our project. To do
    that, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add the library by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you visit the documentation website, you will notice there are different
    CLI commands for “**Expo** managed projects” and “bare **React Native** projects."
    Make sure to follow the instructions for Expo-managed projects. In our case, we
    need to run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will need to display a login surface first, which will redirect our users
    to the main app screen. In order to do that, we will use a Stack navigator. Let’s
    add its dependencies to our project, as listed here at [https://reactnavigation.org/docs/stack-navigator/](https://reactnavigation.org/docs/stack-navigator/):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last setup step for the stack navigator is importing the gesture handler
    library at the very top of our `App.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: The stack navigator will be very useful to manage the login state of our app,
    but we will also need bottom tab navigation to move between the other screens
    once the user is logged in. Tab navigation feels very natural for app users. It
    is visible on all screens and makes using the app easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for now, we will only need to run one command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This command adds bottom tab navigation as a dependency to our project so that
    we will be able to use it later.
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder why we needed to add so many different dependencies separately.
    This is caused by how the **React Navigation** authors decided to structure their
    library. They were certain most people will not need every kind of navigation
    in their **app**, so why should they include it in their app bundle? Every library
    user can decide which part of **React Navigation** will be useful to them and
    include only that part.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to adding a little bit of structure to our basic app. Every app
    is built with at least a couple of different surfaces, which in turn are built
    with components. Our basic social media clone app will need a login surface and
    a main surface, visible after login. Since we’re creating a social media app,
    we will go ahead and call the main surface “**Feed**”, since it will house the
    user’s newsfeed. As we progress, we will surely add more surfaces, but those two
    will be a good starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up surfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The login surface will need an input field for the username, an input field
    for the password, and a button to log in. But for now, we will create a dummy
    component with some text.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by creating the login surface. You may wonder what it means to
    “create a surface." What I mean by it is that some of the components will be wrappers
    for entire surfaces of the app. Some people prefer to call them screens, and in
    web development, you would call them sites or pages. From a coding standpoint,
    they are components just like any other component. But we decide that, logically,
    they represent a bigger piece of the app, and we put them in a special folder,
    called `surfaces`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s our login surface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you may notice it is, in fact, a dummy component, named `Login`, and placed
    in the `surfaces` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using that same logic, we will create a `Feed` surface, which should be displayed
    after the users log in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We have the two basic pieces of the app ready; now we need to put them together.
    This is where React Navigation comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: Every React Native app needs a root file, just as every website needs an `index.html`
    file at the root. This root file is usually called `App.js`. This is the **source
    of truth** (**SOT**) for displaying anything and everything. You can think of
    it as a trunk of a tree, with many branches sprouting from it. The branches are
    different app surfaces in this metaphor. You got that, right? I’m sure you did!
    You’re smart! After all, you *are reading* *my* book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s set up the parent component to display the correct flow—first, the login
    screen, and then, the feed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find the preceding code in this Expo Snack: [https://snack.expo.dev/@p-syche/simplifying-state-management---chapter-2-example-3](https://snack.expo.dev/@p-syche/simplifying-state-management---chapter-2-example-3).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, you will notice we used the `useState` hook. This way,
    we easily added state to our functional `App` component. We set up our initial
    state to be `false`—users opening the app for the first time are not supposed
    to be logged in. When the user logs in, they are redirected to the second “card”
    in our stack. This “card” is the `Home` component. This is a wrapper component
    used to hold the bigger part of our app: all other surfaces besides `Login` with
    tabbed bottom navigation. As you may notice, the navigators are nested: tabbed
    navigation is inside the stack navigator. This is a common and useful practice
    in **React Native** apps. You can read more about nesting navigators in the **React
    Navigation** documentation here: [https://reactnavigation.org/docs/nesting-navigators](https://reactnavigation.org/docs/nesting-navigators).'
  prefs: []
  type: TYPE_NORMAL
- en: And there we go! We have set up an app using **Expo**. We added multiple components
    representing the future surfaces of the app. We also added and configured the
    **React** **Navigation** library. Our app is not very pretty right now, but it
    should work. You can see it on your phone through the Expo Go app, or in phone
    simulators on your computer screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'I set up a public repository on GitHub so that you, dear reader, can more easily
    follow along with the code snippets and examples presented in this book. You can
    find the repo here: [https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native).
    Feel free to clone or fork it. The `main` branch includes the basic app setup.
    Every state management library implementation is on a different branch. We will
    discuss the details as we move forward. If you decide to use this repository,
    you will notice the styles from the UI kit are implemented. We will not focus
    on styling in this book, but it is a nice addition to any app.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have done some really good work here! We started out by looking at simple
    code examples necessary to understand some ReactJS coding concepts such as component
    state and props, lifecycle methods, and hooks. It is important to understand and
    internalize the differences between state and props, and stateful and stateless
    components. A good grasp of those concepts can determine whether your app will
    run smoothly or not.
  prefs: []
  type: TYPE_NORMAL
- en: After diving into important React concepts and examples, we moved on to actually
    setting up our app. This is a very exciting moment! We have our foundation, and
    we are ready to build a real-life social media clone app. In the next chapter,
    we will get comfortable previewing and debugging our app. We will set up all necessary
    surfaces, we will add example data, and finally, we will style the app. I can’t
    wait!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React Native’s documentation—example of components with state: [https://reactnative.dev/docs/intro-react#state.](https://reactnative.dev/docs/intro-react#state)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'State versus Props:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: https://lucybain.com/blog/2016/react-state-vs-pros/.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/uberVU/react-guide/blob/master/props-vs-state.md](https://github.com/uberVU/react-guide/blob/master/props-vs-state.md).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding Lifecycle Methods to a Class—ReactJS docs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: https://reactjs.org/docs/state-and-lifecycle.html#adding-lifecycle-methods-to-a-class.
  prefs: []
  type: TYPE_NORMAL
- en: 'A full blogpost about hooks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: https://pl.reactjs.org/blog/2019/02/06/react-v16.8.0.html.
  prefs: []
  type: TYPE_NORMAL
- en: 'ReactJS documentation on hooks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: https://reactjs.org/docs/hooks-reference.html#useeffect.
  prefs: []
  type: TYPE_NORMAL
- en: 'React Navigation documentation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: https://reactnavigation.org/docs/getting-started/.
  prefs: []
  type: TYPE_NORMAL
- en: 'React Navigation—bottom tab navigation: [https://reactnavigation.org/docs/tab-based-navigation.](https://reactnavigation.org/docs/tab-based-navigation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'React Navigation guide on authentication flow: [https://reactnavigation.org/docs/auth-flow.](https://reactnavigation.org/docs/auth-flow)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'React Navigation guide on nesting navigators: [https://reactnavigation.org/docs/nesting-navigators](https://reactnavigation.org/docs/nesting-navigators).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Part 2 – Creating a Real, Working App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we will concentrate on building a real, functioning mobile app.
    Readers will learn to plan out app features and configure the real setup of the
    Funbook app; then, they will learn how to style a React Native app so that it
    matches a given design, and how to pull in real data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B18396_03.xhtml#_idTextAnchor040), [*Planning and Setting Up
    the Funbook App*](https://epic.packtpub.services/index.php?module=oss_Chapters&action=DetailView&record=552b05fa-8391-bf2a-d8d5-61f378c66211)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B18396_04.xhtml#_idTextAnchor048), [*Styling and Populating the
    Funbook App*](https://epic.packtpub.services/index.php?module=oss_Chapters&action=DetailView&record=e4875054-2e9a-297d-67db-61f3786c1c05)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
