- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Utilizing Angular’s Features and Improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the exciting world of modern Angular development. With its rapid
    six-month release cycle, Angular has evolved dramatically, introducing new features
    and updates that change how we approach our applications in a really interesting
    way!
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore Angular 17, the latest version of the Angular
    framework at the time of writing, and discover how its new features and improvements
    empower developers to build cutting-edge web applications. We will also delve
    into the core features of Angular and understand how they enhance the development
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing modern Angular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about the core features and improvements in Angular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing an Angular project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter contains various code samples of Angular core features and concepts.
    You can find the related source code in the `chapter-03` folder of the following
    GitHub repository: [https://github.com/PacktPublishing/Next-Level-UI-Development-with-PrimeNG/tree/main/apps/chapter-03](https://github.com/PacktPublishing/Next-Level-UI-Development-with-PrimeNG/tree/main/apps/chapter-03).'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing modern Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we embark on this chapter, let’s take a moment to explore the Angular framework’s
    journey and understand how it has evolved over time to become a powerhouse in
    web development. From its inception to the latest version, Angular has continuously
    evolved to meet the changing needs of developers and provide a robust foundation
    for building complex web applications.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular framework was initially introduced by Google in 2010 as AngularJS
    (using JavaScript). It was a game-changer in the web development landscape, offering
    a declarative and powerful approach to building dynamic user interfaces. However,
    as web technologies advanced and developers demanded more scalability and performance,
    Angular underwent a significant transformation.
  prefs: []
  type: TYPE_NORMAL
- en: One of the pivotal moments in Angular’s evolution was the release of Angular
    2 (using TypeScript) in 2016\. Angular 2 introduced a complete rewrite of the
    framework, embracing modern concepts such as component-based architecture and
    reactive programming. This shift laid the groundwork for Angular’s future growth
    and set the stage for subsequent versions.
  prefs: []
  type: TYPE_NORMAL
- en: In subsequent releases, Angular continued to refine its features and introduce
    new capabilities such as bundle-size optimization, backward compatibility, animation,
    tree-shaking, and server-side rendering. Notably, Angular version 14 brought significant
    improvements to the framework. It emphasized a more modular approach with the
    introduction of standalone components, enabling developers to create reusable
    and encapsulated code. This modular architecture revolutionized the way developers
    approached Angular development, enhancing code maintainability and reusability.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding these changes allows you to leverage the latest features and best
    practices, leading to more efficient and scalable applications. In the next section,
    let’s have an overview of the existing features and new improvements introduced
    in recent versions of Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the core features and improvements in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, let’s explore some of the features and improvements that Angular
    brings to the table, including data binding, components, services, directives,
    pipes, signals, and control flow. It’s important to understand some core concepts
    of Angular, so we can have a better understanding of how Angular and PrimeNG work
    together in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Angular data binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Data binding** is a fundamental concept in Angular that enables the synchronization
    of data between the component and the view. It allows you to establish a connection
    between the data in your component and the HTML elements in the template. Data
    binding ensures that any changes in the component are automatically reflected
    in the view, and vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular supports several types of data binding. Let’s explore each type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{{}}`, to bind the component property to the view. Here’s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the code, the `username` property from the component is interpolated into
    the `<p>` element, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Interpolation example](img/B18805_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Interpolation example
  prefs: []
  type: TYPE_NORMAL
- en: '`[ ]`. Here’s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the previous code, the value of the `<input>` element is bound to the `username`
    property from the component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`()`. Here’s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the code, the `handleClick()` method from the component is bound to the `click`
    event of the `<``button>` element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`[(ngModel)]` directive, which synchronizes the value of a form control in
    the template with a property in the component class. Here’s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the code, the value of the `<input>` element is bound to the `username` property
    from the component. Any changes in the input field will update the component property,
    and vice versa.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To use data binding in Angular, you need to define the component property and
    bind it to the appropriate HTML element in the template. Let’s look at an example
    of using interpolation and property binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, `GreetingComponent` has a `username` property set to `'John Doe'`. The
    `{{ username }}` instance in the `<p>` element uses interpolation to display the
    value of `username` in the template. The `[value]="username"` instance in the
    `<input>` element uses property binding to set the initial value of the input
    field.
  prefs: []
  type: TYPE_NORMAL
- en: Angular components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When building applications with Angular, components play a central role in defining
    the user interface and behavior of different parts of the application. A **component**
    in Angular encapsulates the HTML template, CSS styles, and TypeScript code required
    to render a specific part of the user interface. It promotes reusability, maintainability,
    and modularity, by dividing the application into smaller, self-contained units.
  prefs: []
  type: TYPE_NORMAL
- en: 'In previous versions of Angular, components were typically registered and managed
    within Angular modules using the `@NgModule` decorator. The `@NgModule` decorator
    was used to define a module, which is a container for related components, directives,
    services, and other artifacts. Within `@NgModule`, you could specify the components
    that belong to it using the `declarations` property. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet, the `declarations` property includes three components:
    `AppComponent`, `HeaderComponent`, and `FooterComponent`. These components can
    be used within the module or exported to be used in other modules.'
  prefs: []
  type: TYPE_NORMAL
- en: Since Angular v14, we have had another concept, which is standalone components.
    A `declarations` array under `@NgModule`. Let’s create a new standalone component
    from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use Angular CLI to generate a new standalone component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are using an Angular version lower than v17, make sure to append `--standalone`
    when generating standalone components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command successfully generated the alert component in the specified directory,
    along with its associated files for styles, template, test, and component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`alert.component.scss`: This file is intended for defining styles specific
    to the alert component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alert.component.html`: This file is meant to contain the template code for
    the alert component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alert.component.spec.ts`: This file is used for writing tests for the alert
    component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alert.component.ts`: This file is the main file where the logic and behavior
    of the alert component will be implemented'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can further enhance your application’s size and maintainability by using
    the `--inline-style` and `--inline-template` options, enabling you to incorporate
    inline styles and templates. This approach reduces file dependencies, resulting
    in a more streamlined and manageable application. This approach will also encourage
    you to write smaller and more maintainable components since a big anti-pattern
    is to have singular complex and huge components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now look at the alert component in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The provided code defines an `AlertComponent` instance within an Angular application.
    Let’s break down the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Component({ ... })`: This is the decorator used to define an Angular component.
    It provides metadata about the component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selector: ''app-alert''`: This property specifies the HTML tag selector for
    this component. In this case, the component can be used in templates with the
    `<app-alert />` tag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`standalone: true`: This indicates that the component is self-contained and
    can be used by importing to another standalone component or `NgModule`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imports: [CommonModule]`: This property specifies the modules or components
    that should be imported for this component. In this case, it imports the `CommonModule`,
    which is required for using common Angular directives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`templateUrl: ''./alert.component.html''`: This property specifies the URL
    of the external HTML template file associated with this component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`styleUrls: [''./alert.component.scss'']`: This property specifies an array
    of external stylesheet URLs associated with this component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s recommended that when starting a new project, we should utilize standalone
    components since it will help simplify the way we build Angular applications.
    It’s also better for future migration since standalone components will be the
    default option when creating a new application in Angular 17.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Angular still supports `NgModule`, and you can also mix `NgModule` and standalone
    components without any issues. More than that, we can also create standalone directives
    or pipes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, Angular components are the building blocks of Angular applications,
    providing encapsulated functionality and UI representation. By leveraging the
    power of components, you can create reusable and modular code that promotes maintainability
    and code organization. Now, let’s explore another fundamental concept in Angular
    development: dependency injection.'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At its core, **dependency injection** (**DI**) is a design pattern that allows
    objects to receive their dependencies from an external source rather than creating
    them internally. In Angular, the DI system takes care of providing the required
    dependencies to the components, services, and other Angular constructs. DI plays
    a crucial role in decoupling components and promoting code reusability, maintainability,
    and testability.
  prefs: []
  type: TYPE_NORMAL
- en: With DI in Angular, dependencies are typically defined as services or other
    components that a class relies upon. These dependencies are declared in the constructor
    of the class, and Angular’s DI system automatically resolves and injects the appropriate
    instances when the class is instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some best practices when working with DI:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Singleton services**: By default, Angular services are singleton, meaning
    there’s only one instance of the service throughout the application. This is a
    good practice as it ensures data consistency and optimized memory usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`providedIn` property with the value `root`. This ensures that the service
    is available application-wide and gets tree-shaken if not used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hierarchical injectors**: Understand that Angular has a hierarchical injector
    system. While services provided in the root are available application-wide, services
    provided at a component level are available only within that component and its
    children.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface-based injection**: Sometimes, it’s beneficial to inject a service
    based on an interface rather than a concrete class. This makes the system more
    flexible and allows for easier testing and mocking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid complex logic in constructors**: Since constructors are the primary
    place for injection, keep them clean. Avoid placing complex logic or operations
    that can block the component’s initialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will delve into the specifics of how dependency injection
    works in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Angular services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Angular, a **service** is a class that provides a specific functionality
    or data to multiple components throughout an application. Services act as a bridge
    between components, facilitating the sharing of data, communication with external
    APIs, and performing various business logic operations. They promote code reusability,
    modularity, and separation of concerns within an application.
  prefs: []
  type: TYPE_NORMAL
- en: To use a service in Angular, we first need to create the service class. We can
    generate a new service using the `ng generate service` Angular CLI command. Once
    the service is created, we can inject it into any component or another service
    using dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take the example of a `UserService` instance that manages user-related
    operations, such as fetching user data from an API. Here’s how we can create the
    `UserService` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, `UserService` is created as an injectable service using the `@Injectable`
    decorator, which indicates that this class is eligible for DI. Then the `providedIn:
    ''root''` option ensures that Angular creates a single instance of the service
    that is shared across the entire application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s see how we can use `UserService` in a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The provided code demonstrates the usage of the DI of `UserService` in an Angular
    component, specifically in `UserListComponent`. Let’s break it down and explain
    its functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '`private userService = inject(UserService)`: This `inject` function manually
    injects an instance of `UserService`, so `UserListComponent` can assess its properties
    and methods. You can also run `inject` inside the `constructor`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`users$ = this.userService.getUsers()`: This line declares the `users$` property,
    which takes its value from the result of the `getUser()` method from the `UserService`
    instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*ngFor="let user of users$ | async"`: This line enables iterating over the
    collection of `users$` and generating the HTML elements for each item. The `async`
    pipe is used in conjunction to subscribe to the `users$` observable and handle
    the asynchronous nature of the data. The `async` pipe automatically unsubscribes
    from the observable when the component is destroyed, preventing memory leaks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The usage of `$` in `users$` is a pattern to indicate that the property is an
    observable. An **observable**, a core feature from the RxJS library, is a mechanism
    for handling streams of asynchronous events or data over time. You can read more
    at [https://rxjs.dev/guide/observable](https://rxjs.dev/guide/observable).
  prefs: []
  type: TYPE_NORMAL
- en: Angular directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Directives** are a powerful feature in Angular that allows you to extend
    the functionality of HTML elements. They are used to manipulate the DOM, apply
    custom behavior, and dynamically change the appearance or behavior of elements.
    Angular provides three types of directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<app-my-component>`, which Angular interprets to create an instance of the
    corresponding component, encapsulating its behavior, view, and data interactions.
    The difference between component directives and other directives is that components
    contain templates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngStyle` directive can be used to change multiple styles at the same time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*ngFor` directive can be used to render a list of items, and `*ngIf` can conditionally
    show or hide an element based on a boolean expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use a directive in Angular, you can either leverage the built-in directives
    provided by Angular or create your own custom directives. Let’s look at an example
    of using the built-in `ngIf` directive to conditionally show an element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the code, the `ngIf` directive is applied to the `<div>` element. The `showMessage`
    property is evaluated, and if it is truthy, the `<div>` element and its content
    will be rendered. Otherwise, they will be removed from the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create your own custom directives to encapsulate specific behavior
    or styling by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example of creating a custom directive called `FallbackImageDirective`
    that shows a fallback image when an existing image cannot be found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this code, `FallbackImageDirective` is created using the `@Directive` decorator.
    It defines a selector, `img[fallbackImage]`, which means the directive will be
    applied to an image element with the `fallbackImage` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to use `FallbackImageDirective`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `HostListener` decorator is used to listen to events on the host element.
    In this case, we listen to the `error` event and call the corresponding methods.
    `ElementRef` gives us access to the host element, allowing us to modify its properties,
    such as the `src` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Angular pipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Pipes** are a powerful feature in Angular that allows you to transform and
    format data right within your template. They provide a convenient way to perform
    data manipulation operations, such as filtering, sorting, formatting, and more.
    Plus, they are lightweight and reusable, and they can be chained together to create
    complex transformations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular provides a set of built-in pipes that you can use out of the box. Let’s
    take a look at a few examples of using these pipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`date` pipe is used to format dates. Here’s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the `today` variable represents the current date. The `date` pipe formats
    the date using the `'longDate'` format, which displays the date in a long format,
    such as `"January` `1, 2023"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`currency` pipe is used to format currency values. Here’s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the `price` variable represents a currency value. The `currency` pipe
    formats the value as a currency using the `'USD'` currency code, such as `"$10.99"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`uppercase` pipe is used to convert a string to uppercase. Here’s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In addition to the built-in pipes, you can also create your own custom pipes
    to perform custom data transformations. First, you can use the `ng` command to
    create a standalone pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are using an Angular version lower than v17, make sure to append `--standalone`
    when generating standalone pipes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can add logic to create a custom pipe called `ReversePipe` that reverses
    a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a custom Angular pipe named `ReversePipe` is created using
    the `@Pipe` decorator. The pipe takes a string, reverses it, and returns the reversed
    string. The `transform` method, required by the `PipeTransform` interface, is
    where this reversal operation is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, if we want to use this custom pipe, all we have to do is import the pipe
    to the component and use it as normal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this line of code, Angular’s pipe mechanism is being used to transform the
    string `abc` using a custom pipe named `reverse`. The line `Reverse of 'abc' is
    {{'abc' | reverse}}` will render as `Reverse of 'abc' is cba` in the HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Pipes are chainable, so you can combine different pipes to create the desired
    result. For example, `{{'abc' | reverse | uppercase}}` will reverse the string
    and make it uppercase. The final result is `CBA`.
  prefs: []
  type: TYPE_NORMAL
- en: Angular signals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Angular Signals** is a system that granularly tracks how and where your state
    is used throughout an application, allowing the framework to optimize rendering
    updates. This feature in Angular 16 is a native way of handling reactivity in
    Angular.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In most cases, signals are all you need to build a simple application. A **signal**
    is a function that holds a value and allows you to listen to changes to that value.
    Let’s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This code block shows how to use signals and effects from the `@angular/core`
    package to manage state and side effects. Here’s a breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public count: WritableSignal<number> = signal<number>(4)`: This line declares
    a signal `count`, which is a `WritableSignal` instance that holds a number. The
    initial value of `count` is set to `4`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setRandomCount() { ... }`: This is a method that sets `count` to a random
    number between 1 and 10\. The `this.count.set(...)` method is used to update the
    value of `count`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`effect()` is an operation that runs whenever one or more signal values change
    and prints the current value of `count` to the browser console log.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The template of the component displays the current value of `count` and a button
    that calls `setRandomCount` when clicked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Angular Signals is marked as stable since Angular 17\. You can read more on
    Angular Signals at [https://angular.io/guide/signals](https://angular.io/guide/signals).
  prefs: []
  type: TYPE_NORMAL
- en: Angular control flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In an effort to enhance the **developer experience** (**DX**), Angular 17 introduced
    a new feature called **Built-in control flow**. This feature allows you to use
    a familiar JavaScript-like syntax in Angular templates to easily show, hide, or
    repeat elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take the `NgIf` directive as an example. Suppose we have a list of products
    and we want to display different content when no products are available. Before
    the introduction of the control flow feature, here’s how we would handle it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Overall, this code snippet displays a `Show product list` message inside a `<div>`
    element if the `products` array has elements. If the `products` array is empty,
    the `Products are empty!` message from the `ng-template` block is displayed instead.
    This allows for conditional rendering based on the state of the `products` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s see how it’s done with the new `@if` control flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, you’ll notice that we can directly utilize `@if`, `@else`,
    and even `@else if` syntax, resulting in cleaner and more familiar code. This
    approach also exhibits a JavaScript-like coding style, enhancing the DX with a
    sense of familiarity and ease.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In addition to enhancing the DX, the new control flow also significantly improves
    the performance of your application compared to the previous implementation. You
    can refer to the community framework benchmarks available at [https://krausest.github.io/js-framework-benchmark/current.html](https://krausest.github.io/js-framework-benchmark/current.html)
    for further verification.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular team also provides a nice way to run migration to move existing
    syntax to the new control flow. All you need to do is to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This command will scan the existing implementations of `NgIf`, `NgFor`, and
    `NgSwitch` and upgrade them to the new control flow. It is important to thoroughly
    test and validate that everything functions as intended before finalizing and
    committing these changes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Angular control flow is still under Developer Preview in Angular 17\. You can
    read more on Angular control flow at [https://angular.io/guide/control_flow](https://angular.io/guide/control_flow).
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, we have explored several core features of Angular that serve
    as fundamental building blocks for developing functional Angular applications.
    In the next section, we will delve into valuable tips on effectively organizing
    your Angular project.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing an Angular project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of organizing and structuring an Angular application is to enhance
    its maintainability, scalability, and reusability. It involves making decisions
    about how to structure the code base, divide responsibilities among different
    files and folders, and establish conventions for naming and organizing files.
    Organizing an Angular project effectively not only improves the developer experience
    but also helps teams collaborate better and reduces the learning curve for new
    developers joining the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'When organizing an Angular project, it’s important to follow established best
    practices and leverage Angular’s recommended project structure. The Angular style
    guide provides several best practices for organizing an Angular project. You can
    find the style guide here: [https://angular.io/guide/styleguide](https://angular.io/guide/styleguide).'
  prefs: []
  type: TYPE_NORMAL
- en: 'One key principle emphasized in the style guide is the **LIFT approach**, which
    stands for *Locating* code quickly, *Identifying* the code at a glance, *Flattening*
    the structure, and *Trying* to be **DRY** (**Don’t Repeat Yourself**). Let’s go
    through each aspect of the LIFT principle and provide a code example for better
    understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Locating code quickly**: The goal is to organize the code base in a way that
    allows you to locate files and modules easily. One common approach is to group
    files based on their functionality or features. Here’s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, related files are grouped together within directories such as `components`,
    `services`, and `models`. This structure helps developers quickly find the files
    they need when working on a specific feature.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Identifying the code at a glance**: The focus is on using meaningful and
    descriptive names for files, classes, variables, and functions. This makes it
    easier to understand the purpose and functionality of the code. Here’s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using descriptive names such as `ProductComponent` clearly communicates the
    responsibility and purpose of the code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Flattening the structure**: The aim is to keep a flat directory structure
    instead of nesting directories too deeply. This simplifies navigation and maintenance.
    Here’s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the `product.component.ts` file is located directly under the `components`
    directory without unnecessary nesting.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Trying to be DRY**: The principle encourages code reuse and avoiding duplication.
    It promotes extracting common functionality into reusable components, services,
    or modules. Here’s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`LoadingSpinnerComponent` can be reused in multiple parts of the application
    to display a loading spinner, reducing code duplication, and improving consistency.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By adhering to the LIFT principle, Angular projects can benefit from a well-organized
    and maintainable code base, making development more efficient and enhancing collaboration
    among team members.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the LIFT approach, the style guide also provides the following
    best practices which are worth noting here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/app` for application-specific code and `src/assets` for assets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Separate concerns with directories**: Use directories to separate concerns
    and group related files. For example, place components, templates, styles, and
    tests for a feature in the same directory. This makes it easier to locate and
    maintain related code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`feature-name.component.ts` for component files, `feature-name.service.ts`
    for service files, and `feature-name.spec.ts` for test files. This consistency
    helps developers locate and identify files quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index.ts`) in directories to provide a central entry point for exporting multiple
    files. **Barrels** simplify imports and make it easier to locate and manage related
    files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AppModule`); feature-level code should be placed in feature modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consider a shared directory**: Create a shared directory to encapsulate commonly
    used components, directives, pipes, and services. The shared module simplifies
    importing shared resources and promotes code reuse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use lazy loading**: For large applications, consider using **lazy loading**
    to load feature modules on demand. This improves initial load times and separates
    code into manageable chunks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that the Angular style guide provides detailed explanations and examples
    for each of these best practices, and it’s a valuable resource for organizing
    an Angular project effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: These are just recommendations on best practices when organizing an Angular
    project. There’s no *one size fits all* approach in terms of architecting your
    Angular project. It will always depend on other factors such as the stage of the
    project, deadline, team size, and so on. Make sure that you pick the approach
    that is suitable for your project. A recommended strategy is to begin with the
    LIFT approach, which facilitates faster application development. As your application
    expands, it is advisable to apply best practices to optimize your code and ensure
    its efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered key aspects of modern Angular development.
    We began by introducing the evolution of Angular, highlighting its growth and
    advancements. Moving on, we discussed core features and improvements in recent
    Angular versions, including data binding, components, services, directives, pipes,
    and signals. We also emphasized the importance of organizing an Angular project
    effectively using best practices.
  prefs: []
  type: TYPE_NORMAL
- en: By gaining insights into modern Angular development, you are now equipped to
    take your skills to the next level. In the next chapter, we will focus on integrating
    PrimeNG into your Angular project. We will guide you through the process of incorporating
    PrimeNG into your Angular application and harnessing its power to enhance the
    user experience.
  prefs: []
  type: TYPE_NORMAL
