- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Introducing React and React Hooks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 React 和 React Hooks
- en: React is a JavaScript library used to build efficient and extensible web applications.
    React was developed by Meta and is used in many large-scale web applications,
    such as Facebook, Instagram, Netflix, Shopify, Airbnb, Cloudflare, and the BBC.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: React 是一个用于构建高效和可扩展 Web 应用的 JavaScript 库。React 由 Meta 开发，并被用于许多大型 Web 应用程序中，如
    Facebook、Instagram、Netflix、Shopify、Airbnb、Cloudflare 和 BBC。
- en: In this book, we are going to learn how to build complex and efficient user
    interfaces with React, while keeping the code simple and extensible. Using the
    paradigm of React Hooks, we can greatly simplify dealing with state and effects
    in web applications, ensuring the potential for growing and extending the application
    later. We are also going to learn about **React Context**, **React Suspense**,
    and **Form Actions**, as well as how they can be used with Hooks. Finally, we
    are going to learn how to build our own Hooks and how to migrate existing applications
    from React class components to a React Hooks-based architecture.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将学习如何使用 React 构建复杂且高效的用户界面，同时保持代码简单和可扩展。通过 React Hooks 的范式，我们可以极大地简化处理
    Web 应用程序中的状态和副作用，确保应用程序未来有增长和扩展的潜力。我们还将了解 **React Context**、**React Suspense**
    和 **表单操作**，以及它们如何与 Hooks 一起使用。最后，我们将学习如何构建自己的 Hooks 以及如何将现有应用程序从 React 类组件迁移到基于
    React Hooks 的架构。
- en: In this first chapter, we are going to learn about the fundamental principles
    of React and React Hooks. We will start by learning what React and React Hooks
    are, and why we should use them. Then, we will move on to learn about the inner
    workings of Hooks. Finally, you will be introduced to the Hooks that are provided
    by React, and a couple of Hooks provided by the community – such as data fetching
    and routing Hooks. By learning the fundamentals of React and React Hooks, we will
    be better able to understand the concepts that will be introduced throughout this
    book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 React 和 React Hooks 的基本原理。我们将从了解 React 和 React Hooks 是什么以及为什么我们应该使用它们开始。然后，我们将继续学习
    Hooks 的内部工作原理。最后，您将了解 React 提供的 Hooks 以及社区提供的几个 Hooks，例如数据获取和路由 Hooks。通过学习 React
    和 React Hooks 的基础知识，我们将更好地理解本书中将要介绍的概念。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Principles of React
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 原理
- en: Motivation to use React Hooks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React Hooks 的动机
- en: Setting up the development environment
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: Getting started with React Hooks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 React Hooks
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'A fairly recent version of Node.js should already be installed. The Node Package
    Manager (`npm`) also needs to be installed (it should come with Node.js). For
    more information on how to install Node.js, please check out their official website:
    [https://nodejs.org/](https://nodejs.org/).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 应该已经安装了相当新版本的 Node.js。Node 包管理器 (`npm`) 也需要安装（它应该随 Node.js 一起安装）。有关如何安装 Node.js
    的更多信息，请查看他们的官方网站：[https://nodejs.org/](https://nodejs.org/).
- en: 'We are going to use **Visual Studio Code** (**VS Code**) for the guides in
    this book, but everything should work similarly in any other editor. For more
    information on how to install VS Code, please refer to their official website:
    [https://code.visualstudio.com](https://code.visualstudio.com).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的指南中，我们将使用 **Visual Studio Code** （**VS Code**），但所有内容在任何其他编辑器中都应该类似。有关如何安装
    VS Code 的更多信息，请参阅他们的官方网站：[https://code.visualstudio.com](https://code.visualstudio.com).
- en: 'In this book, we use the following versions:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用以下版本：
- en: Node.js v22.14.0
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js v22.14.0
- en: '`npm` v10.9.2'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm` v10.9.2'
- en: Visual Studio Code v1.97.2
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code v1.97.2
- en: The versions mentioned in the preceding list are the ones used in the book.
    While installing a newer version should not be an issue, please note that certain
    steps might work differently on a newer version. If you are having an issue with
    the code and steps provided in this book, please try using the mentioned versions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 上列出的版本是本书中使用的版本。虽然安装较新版本不应有问题，但请注意，某些步骤在较新版本上可能会有所不同。如果您在使用本书中提供的代码和步骤时遇到问题，请尝试使用提到的版本。
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter01](https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter01).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章的代码：[https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter01](https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter01).
- en: It is highly recommended that you write the code on your own. Do not simply
    run the code examples that are provided with the book. It is important to write
    the code yourself to be able to learn and understand it properly. However, if
    you run into any issues, you can always refer to the code example.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议您自己编写代码。不要简单地运行书中提供的代码示例。自己编写代码对于正确学习和理解代码非常重要。然而，如果您遇到任何问题，您始终可以参考代码示例。
- en: Principles of React
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 原则
- en: Before we start learning how to set up a React project, let’s revisit the three
    fundamental principles of React. These principles allow us to easily write scalable
    web applications.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始学习如何设置 React 项目之前，让我们回顾一下 React 的三个基本原理。这些原理使我们能够轻松编写可扩展的 Web 应用程序。
- en: 'React is based on three fundamental principles:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: React 基于三个基本原理：
- en: '**Declarative**: Instead of telling React how to do things, we tell it what
    we want it to do. For example, if we change data, we don’t need to tell React
    which components need to be re-rendered. That would be complex and error-prone.
    Instead, we just tell React that data has changed and all components using this
    data will be efficiently updated and re-rendered for us. React takes care of the
    details so that we can focus on the tasks at hand to easily develop our web application.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明式**：我们不是告诉 React 如何做事，而是告诉它我们想要它做什么。例如，如果我们更改数据，我们不需要告诉 React 哪些组件需要重新渲染。这会很复杂且容易出错。相反，我们只需告诉
    React 数据已更改，所有使用此数据的相关组件都将被高效更新并为我们重新渲染。React 会处理细节，这样我们就可以专注于手头的任务，轻松开发我们的 Web
    应用程序。'
- en: '**Component-based**: React encapsulates components that manage their own state
    and views and then allows us to compose them in order to create complex user interfaces.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件化**：React 封装了管理自身状态和视图的组件，然后允许我们将它们组合起来以创建复杂用户界面。'
- en: '**Learn once, write anywhere**: React does not make assumptions about your
    technology stack and tries to ensure that you can develop apps without rewriting
    existing code as much as possible.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一次学习，到处编写**：React 不对您的技术栈做出假设，并试图确保您可以在不尽可能重写现有代码的情况下开发应用程序。'
- en: React’s three fundamental principles make it easy to write code, encapsulate
    components, and share code across multiple platforms. Instead of reinventing the
    wheel, React always tries to make use of existing JavaScript features as much
    as possible. As a result, we are going to learn about software design patterns
    that will be applicable in many more cases than just designing user interfaces.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: React 的三个基本原理使编写代码、封装组件以及在多个平台上共享代码变得容易。React 总是试图尽可能多地利用现有的 JavaScript 功能，而不是重新发明轮子。因此，我们将学习适用于许多更多情况的软件设计模式，而不仅仅是设计用户界面。
- en: 'We just learned that React is component-based. In React, there are two types
    of components:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚了解到 React 是基于组件的。在 React 中，有两种类型的组件：
- en: '**Function components**: JavaScript functions that take the props as an argument,
    and return the user interface (usually via JSX, which is an extension of the JavaScript
    syntax that allows us to write HTML-like markup directly within JavaScript code)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数组件**：接受 props 作为参数的 JavaScript 函数，并返回用户界面（通常通过 JSX，它是 JavaScript 语法的一个扩展，允许我们在
    JavaScript 代码中直接编写类似 HTML 的标记）'
- en: '**Class components**: JavaScript classes that provide a `render` method, which
    returns the user interface (usually via JSX)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类组件**：提供 `render` 方法的 JavaScript 类，该方法返回用户界面（通常通过 JSX）'
- en: While function components are easier to define and understand, in the past,
    class components were needed to deal with state, contexts, and many more of React’s
    advanced features. However, with React Hooks, we can use most of React’s advanced
    features without needing a class component!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然函数组件更容易定义和理解，但在过去，处理状态、上下文以及许多其他 React 高级功能需要类组件。然而，随着 React Hooks 的出现，我们可以使用
    React 的大多数高级功能，而无需类组件！
- en: There are certain features of React that, at the time of writing, are not possible
    with function components and Hooks yet. For example, defining error boundaries
    still requires class components and the `componentDidCatch` and `getDerivedStateFromError`
    lifecycle methods.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本文时，React 拥有一些特性，这些特性目前还不能通过函数组件和 Hooks 实现。例如，定义错误边界仍然需要类组件以及 `componentDidCatch`
    和 `getDerivedStateFromError` 生命周期方法。
- en: Motivation to use React Hooks
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React Hooks 的动机
- en: React always strives to make the developer experience as smooth as possible
    while ensuring to keep it performant enough, without the developer having to worry
    too much about how to optimize performance. However, throughout the years of using
    React, a couple of problems have been identified.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: React 总是努力使开发者体验尽可能顺畅，同时确保性能足够好，让开发者无需过多担心如何优化性能。然而，在多年的 React 使用过程中，已经识别出了一些问题。
- en: The code snippets in the following subsections are just intended to give you
    an understanding of why Hooks were needed, by giving examples of how developers
    previously dealt with certain problems in React. If you are not familiar with
    those old ways, do not worry, it’s not necessary to understand the old ways to
    follow along. In the upcoming sections, we are going to learn how to deal with
    these problems in a better way using React Hooks.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下子节中的代码片段仅旨在让您了解为什么需要 Hooks，通过给出开发者以前如何处理 React 中某些问题的示例。如果您不熟悉这些旧方法，请不要担心，了解旧方法并不是继续学习所必需的。在接下来的章节中，我们将学习如何使用
    React Hooks 以更好的方式处理这些问题。
- en: Let’s now take a look at these problems in the following subsections.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在以下子节中查看这些问题。
- en: Confusing classes
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 令人困惑的类
- en: In the past, we had to use class components with special functions called life
    cycle methods, such as `componentDidUpdate`, and special state-handling methods
    such as `this.setState`, to deal with state changes. React classes, and especially
    the `this` context, are hard to read and understand for both developers and machines.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，我们必须使用具有特殊函数的生命周期方法（如 `componentDidUpdate`）和特殊的状态处理方法（如 `this.setState`）来处理状态变化。React
    类，尤其是 `this` 上下文，对于开发者和机器来说都很难阅读和理解。
- en: '`this` is a special keyword in JavaScript that always refers to the object
    that it belongs to:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`this` 是 JavaScript 中一个特殊的保留字，它始终指向它所属的对象：'
- en: In a method, `this` refers to the class object (instance of the class).
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法中，`this` 指的是类对象（类的实例）。
- en: In an event handler, `this` refers to the element that received the event.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在事件处理程序中，`this` 指的是接收事件的元素。
- en: In a function or standing alone, `this` refers to the global object. For example,
    in a browser, the global object is the `Window` object.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数或独立存在时，`this` 指的是全局对象。例如，在浏览器中，全局对象是 `Window` 对象。
- en: In strict mode, `this` is `undefined` in a function.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在严格模式下，函数中的 `this` 是 `undefined`。
- en: Additionally, methods such as `call()` and `apply()` can change the object that
    `this` refers to, so it can refer to any object.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，`call()` 和 `apply()` 等方法可以改变 `this` 指向的对象，因此它可以指向任何对象。
- en: For developers, classes are hard, because `this` always refers to different
    things, so sometimes (for example, in event handlers) we need to manually rebind
    it to the class object. For machines, classes are hard, because they do not know
    which methods in a class will be called and how `this` will be modified, making
    it hard to optimize performance and remove unused code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发者来说，类很难，因为 `this` 总是指向不同的事物，所以有时（例如在事件处理程序中）我们需要手动将其重新绑定到类对象上。对于机器来说，类也很难，因为它们不知道类中哪些方法会被调用以及
    `this` 将如何被修改，这使得优化性能和删除未使用的代码变得困难。
- en: 'Additionally, classes sometimes require us to write code in multiple places
    at once. For example, if we want to fetch data when the component renders or props
    of a component change, we need to do this using two methods: once in `componentDidMount`,
    and once in `componentDidUpdate`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，类有时要求我们在多个地方同时编写代码。例如，如果我们想在组件渲染时获取数据或组件的 props 发生变化时，我们需要使用两种方法来完成：一次在 `componentDidMount`
    中，一次在 `componentDidUpdate` 中。
- en: 'To give an example, let’s define a class component that fetches data from an
    API:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，让我们定义一个从 API 获取数据的类组件：
- en: 'First, we define a class component by extending the `React.Component` class:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们通过扩展 `React.Component` 类来定义一个类组件：
- en: '[PRE0]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we define the `componentDidMount` life cycle method, where we pull data
    from an API:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义 `componentDidMount` 生命周期方法，在那里我们从 API 拉取数据：
- en: '[PRE1]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However, we also need to define the `componentDidUpdate` life cycle method
    in case the `name` prop changes. Additionally, we need to add a manual check here,
    to ensure that we only re-fetch data if the `name` prop changed, and not when
    other props change:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，我们还需要定义 `componentDidUpdate` 生命周期方法，以防 `name` prop 发生变化。此外，我们还需要在这里添加一个手动检查，以确保我们仅在
    `name` prop 发生变化时重新获取数据，而不是在其他 props 发生变化时：
- en: '[PRE2]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To make the code less repetitive, we could refactor our code by creating a
    separate method called `fetchData` and fetch the data as follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使代码不那么重复，我们可以通过创建一个名为`fetchData`的单独方法来重构我们的代码，并如下获取数据：
- en: '[PRE3]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we could call the method in `componentDidMount` and `componentDidUpdate`:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以在`componentDidMount`和`componentDidUpdate`中调用该方法：
- en: '[PRE4]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, even then we still need to call the method in two places. Whenever
    we update arguments that are passed to the method, we need to update them in two
    places, which makes this pattern very prone to errors and future bugs.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使如此，我们仍然需要在两个地方调用方法。每当我们需要更新传递给方法的参数时，我们都需要在两个地方更新它们，这使得这种模式非常容易出错，并且可能导致未来的错误。
- en: Wrapper hell
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包装地狱
- en: 'Let’s assume we already implemented an `authenticateUser` higher-order component
    function that adds authentication to one of our components, and a context called
    `AuthenticationContext` to provide information about the authenticated user via
    render props. We would then use this context as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已实现了一个添加认证到我们组件之一的`authenticateUser`高阶组件函数，以及一个名为`AuthenticationContext`的上下文，通过渲染属性提供有关认证用户的信息。然后，我们会如下使用此上下文：
- en: 'We start by importing the `authenticateUser` function to wrap our component
    with the context, and the `AuthenticationContext` component to be able to access
    the context:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先导入`authenticateUser`函数，用上下文包装我们的组件，并导入`AuthenticationContext`组件以便能够访问上下文：
- en: '[PRE5]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we define an `App` component, where we make use of the `AuthenticationContext.Consumer`
    component and the `user` render prop:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个`App`组件，在其中我们使用`AuthenticationContext.Consumer`组件和`user`渲染属性：
- en: '[PRE6]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Render props** are a way to pass props down to the children of a component.
    As we can see here, the render prop allowed us to pass `user` down to the children
    of the `AuthenticationContext.Consumer` component.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**渲染属性**是将属性传递到组件子组件的一种方式。正如我们所见，渲染属性允许我们将`user`传递给`AuthenticationContext.Consumer`组件的子组件。'
- en: 'Now, we display different texts depending on whether the user is logged in
    or not:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们根据用户是否登录显示不同的文本：
- en: '[PRE7]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we used two JavaScript concepts:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了两个JavaScript概念：
- en: 'A **ternary operator**, which is an inline version of the `if` conditional.
    It looks as follows: `ifThisIsTrue ? returnThis : otherwiseReturnThis`.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三元运算符**是`if`条件的内联版本。它看起来如下：`ifThisIsTrue ? returnThis : otherwiseReturnThis`。'
- en: A **template string**, which can be used to insert variables into a string.
    It is defined with backticks (`` ` ``) instead of normal single quotes (`'`).
    Variables can be inserted via the `${variableName}` syntax. We can also use any
    JavaScript expressions within the `${}` brackets – for example, `${someValue +
    1}`.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板字符串**可以用来在字符串中插入变量。它使用反引号（`` ` ``）而不是普通单引号（`''`）来定义。变量可以通过`${variableName}`语法插入。我们也可以在`${}`括号内使用任何JavaScript表达式——例如，`${someValue
    + 1}`。'
- en: 'Finally, we export the component after wrapping it with the `authenticateUser`
    context, by making use of the higher-order component pattern:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过使用高阶组件模式，我们在将`authenticateUser`上下文包装到组件后导出组件：
- en: '[PRE8]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Higher-order components** are functions that wrap components and add functionality
    to them. They were needed to encapsulate and reuse state management logic before
    Hooks.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**高阶组件**是包装组件并为其添加功能的函数。在Hooks出现之前，它们被用来封装和重用状态管理逻辑。'
- en: In this example, we used the `authenticateUser` higher-order component function
    to add authentication logic to our existing component. We then used `AuthenticationContext.Consumer`
    to inject the `user` prop into our component through its render props.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`authenticateUser`高阶组件函数来为我们现有的组件添加认证逻辑。然后，我们使用`AuthenticationContext.Consumer`通过其渲染属性将`user`属性注入到我们的组件中。
- en: 'As you can imagine, using many higher-order components will result in a large
    tree with many sub-trees, which is an anti-pattern called **wrapper hell**. For
    example, when we want to use three contexts, the wrapper hell looks as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，使用许多高阶组件会导致一个具有许多子树的庞大树，这是一种称为**包装地狱**的反模式。例如，当我们想要使用三个上下文时，包装地狱看起来如下：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is not very easy to read or write and is also prone to errors if we need
    to change something later on. The wrapper hell makes debugging hard because we
    need to look at a large component tree, with many components just acting as wrappers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不容易阅读或编写，如果以后需要更改某些内容，也容易出错。包装地狱使得调试变得困难，因为我们需要查看一个具有许多仅作为包装器的组件的大型组件树。
- en: Now that we have learned about some common problems with React, let’s learn
    about the Hook pattern to better deal with these problems!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 React 的一些常见问题，让我们学习 Hook 模式，以便更好地处理这些问题！
- en: Hooks to the rescue!
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hooks 来拯救！
- en: React Hooks are based on the same fundamental principles as React. They encapsulate
    state management by using existing JavaScript features. As a result, we do not
    need to learn and understand many specialized React features anymore; we can simply
    tap into our existing JavaScript knowledge to use Hooks.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: React Hooks 基于与 React 相同的基本原则。它们通过使用现有的 JavaScript 特性来封装状态管理。因此，我们不再需要学习和理解许多专门的
    React 特性；我们只需利用我们现有的 JavaScript 知识来使用 Hooks。
- en: Using Hooks, we can come up with better solutions to the previously mentioned
    problems. Hooks are simply functions that can be called in function components.
    We also do not need to use render props for contexts anymore, because we can simply
    use a **Context Hook** to get the data that we need. Additionally, Hooks allow
    us to reuse stateful logic between components, without creating higher-order components.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Hooks，我们可以为之前提到的问题提出更好的解决方案。Hooks 简单来说就是可以在函数组件中调用的函数。我们也不再需要使用 render props
    来处理上下文，因为我们可以直接使用 **Context Hook** 来获取所需的数据。此外，Hooks 允许我们在组件之间重用有状态的逻辑，而无需创建高阶组件。
- en: 'For example, the aforementioned problems with life cycle methods could be solved
    using an **Effect Hook**, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以使用 **Effect Hook** 解决前面提到的生命周期方法的问题，如下所示：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This Effect Hook will automatically trigger when the component mounts, and whenever
    the `name` prop changes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Effect Hook 将在组件挂载时自动触发，并且每当 `name` 属性发生变化时。
- en: 'The wrapper hell mentioned earlier could be solved using Context Hooks, as
    follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的包装地狱问题可以使用 Context Hooks 解决，如下所示：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we can see, by using Hooks, we can keep our code clean and concise, making
    sure that our code stays easy to read and maintain. Writing custom Hooks also
    makes it easy to reuse application logic in a project.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，通过使用 Hooks，我们可以保持代码的整洁和简洁，确保我们的代码易于阅读和维护。编写自定义 Hooks 也有助于在项目中重用应用程序逻辑。
- en: Now that we know which problems Hooks can solve, we can get started using them
    in practice. First, however, we need to quickly set up our development environment.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了 Hooks 可以解决哪些问题，我们可以开始在实际中使用它们。然而，首先，我们需要快速设置我们的开发环境。
- en: Setting up the development environment
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: In this book, we are going to use **VS Code** as our code editor. Feel free
    to use whichever editor you prefer, but keep in mind that the extensions used
    and settings configured may be slightly different in the editor of your choice.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用 **VS Code** 作为我们的代码编辑器。请随意使用您偏好的任何编辑器，但请注意，您选择的编辑器中使用的扩展和配置的设置可能略有不同。
- en: Let’s now install VS Code and some useful extensions, and then continue setting
    up all the tools needed for our development environment.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来安装 VS Code 和一些有用的扩展，然后继续设置我们开发环境所需的所有工具。
- en: Installing VS Code and extensions
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 VS Code 和扩展
- en: 'Before we can get started developing and setting up the other tools, we need
    to set up our code editor, by following these steps:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始开发和设置其他工具之前，我们需要按照以下步骤设置我们的代码编辑器：
- en: Download VS Code for your operating system from the official website (at the
    time of writing, the URL is [https://code.visualstudio.com/](https://code.visualstudio.com/)).
    We are going to use version 1.97.2 in this book.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请从官方网站（截至编写时，网址为 [https://code.visualstudio.com/](https://code.visualstudio.com/)）下载适用于您的操作系统的
    VS Code。本书中将使用版本 1.97.2。
- en: 'After downloading and installing the application, open it, and you should see
    the following window:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并安装应用程序后，打开它，您应该会看到以下窗口：
- en: '![Figure 1.1 – A fresh installation of Visual Studio Code (on macOS)](img/B31327_01_01.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 在 macOS 上 Visual Studio Code 的新安装](img/B31327_01_01.png)'
- en: Figure 1.1 – A fresh installation of Visual Studio Code (on macOS)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 在 macOS 上 Visual Studio Code 的新安装
- en: To make things easier later, we are going to install some extensions, so click
    on the **Extensions** icon, which is the fifth icon from the top left in the screenshot.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让事情更容易，我们将安装一些扩展，所以点击 **Extensions** 图标，这是截图左上角的第五个图标。
- en: 'A sidebar should open, where you can see **Search Extensions in Marketplace**
    at the top. Enter an extension name here and click on **Install** to install it.
    Let’s start by installing the **ESLint** extension:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 应该会打开一个侧边栏，您可以在顶部看到 **Search Extensions in Marketplace**。在此处输入扩展名称，然后点击 **Install**
    来安装它。让我们先安装 **ESLint** 扩展：
- en: '![Figure 1.2 – Installing the ESLint extension in Visual Studio Code](img/B31327_01_02.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2 – 在Visual Studio Code中安装ESLint扩展](img/B31327_01_02.png)'
- en: Figure 1.2 – Installing the ESLint extension in Visual Studio Code
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – 在Visual Studio Code中安装ESLint扩展
- en: 'Make sure to install the following extensions:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保安装以下扩展：
- en: ESLint (by Microsoft)
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ESLint（由Microsoft提供）
- en: Prettier – Code formatter (by Prettier)
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prettier – 代码格式化工具（由Prettier提供）
- en: Support for JavaScript and Node.js already comes built-in with VS Code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 支持JavaScript和Node.js已经内置在VS Code中。
- en: Create a folder for the projects made in this book (for example, you can call
    it `Learn-React-Hooks-Second-Edition`). Inside this folder, create a new folder
    called `Chapter01_1`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这本书中制作的项目创建一个文件夹（例如，您可以将其命名为`Learn-React-Hooks-Second-Edition`）。在这个文件夹内部，创建一个名为`Chapter01_1`的新文件夹。
- en: Open the empty `Chapter01_1` folder in VS Code.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开空的`Chapter01_1`文件夹。
- en: If you get a dialog asking **Do you trust the authors of the files in this folder?**,
    check **Trust the authors of all files in the parent folder ‘Learn-React-Hooks’**
    and then click on the **Yes, I trust the authors** button.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果出现一个对话框询问**你信任此文件夹中文件的作者吗？**，请选择**信任父文件夹‘Learn-React-Hooks’中的所有文件的作者**，然后点击**是，我信任作者**按钮。
- en: '![Figure 1.3 – Allowing VS Code to execute files in our project folder](img/B31327_01_03.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – 允许VS Code在项目文件夹中执行文件](img/B31327_01_03.png)'
- en: Figure 1.3 – Allowing VS Code to execute files in our project folder
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 允许VS Code在项目文件夹中执行文件
- en: You can safely ignore this warning in your own projects, as you can be sure
    that those do not contain malicious code. When opening folders from untrusted
    sources, you can press **No, I don’t trust the authors**, and still browse the
    code. However, when doing so, some features of VS Code will be disabled.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在您自己的项目中，您可以安全地忽略此警告，因为您可以确信这些项目中不包含恶意代码。当从不受信任的来源打开文件夹时，您可以按**不，我不信任作者**，仍然浏览代码。然而，这样做时，VS
    Code的一些功能将被禁用。
- en: We have now successfully set up VS Code and are ready to start setting up our
    project! If you cloned the folder from the GitHub code examples provided, a notification
    telling you that a Git repository was found will also pop up. You can simply close
    this one, as we only want to open the `Chapter01_1` folder.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经成功设置了VS Code，并准备好开始设置我们的项目！如果您从GitHub提供的代码示例中克隆了文件夹，也会弹出一个通知，告诉您找到了Git仓库。您可以简单地关闭它，因为我们只想打开`Chapter01_1`文件夹。
- en: Now that VS Code is ready, let’s continue by setting up a new project with Vite.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在VS Code已经准备好了，让我们继续通过使用Vite设置一个新的项目。
- en: Setting up a project with Vite
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Vite设置项目
- en: For this book, we are going to use **Vite** to set up our project, as it is
    the most popular and liked local development server, according to *The State of
    JS 2024* survey ([https://2024.stateofjs.com/](https://2024.stateofjs.com/)).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这本书，我们将使用**Vite**来设置我们的项目，因为它是最受欢迎和最受欢迎的本地开发服务器，根据*The State of JS 2024*调查([https://2024.stateofjs.com/](https://2024.stateofjs.com/))。
- en: 'Vite also makes it easy to set up a modern frontend project while still making
    it possible to extend the configuration later if needed. Follow these steps to
    set up your project with Vite:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Vite还使得设置现代前端项目变得容易，同时如果需要，还可以稍后扩展配置。按照以下步骤使用Vite设置您的项目：
- en: In the VS Code menu bar, go to **Terminal** | **New Terminal** to open a new
    terminal.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code菜单栏中，转到**终端** | **新建终端**以打开一个新的终端。
- en: 'Inside the terminal, run the following command:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端内部，运行以下命令：
- en: '[PRE12]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `$` symbol shows that this is a command that needs to be entered into a
    terminal. Enter everything after the `$` symbol into the terminal and confirm
    with *Return/Enter* to run the command. Make sure there is a period at the end
    of the command to create the project in the current folder instead of creating
    a new folder.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`$`符号表示这是一个需要输入到终端中的命令。将`$`符号之后的所有内容输入到终端中，并使用*Return/Enter*确认以运行命令。确保命令末尾有一个句点，以便在当前文件夹中创建项目，而不是创建一个新的文件夹。'
- en: To keep the instructions in this book working even when new versions are released,
    we pin all packages to a fixed version. Please follow the instructions with the
    given versions. After finishing this book, when starting new projects on your
    own, you should always try using the latest versions, but keep in mind that changes
    might be needed to get them working. Consult the documentation of the respective
    packages and follow the migration path from the book version to the latest version.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保即使新版本发布，本书中的说明仍然有效，我们将所有包固定到特定版本。请按照给定的版本执行说明。完成本书后，当你自己开始新项目时，你应该始终尝试使用最新版本，但请注意，可能需要进行一些更改才能使其工作。请查阅相应包的文档，并遵循从本书版本到最新版本的迁移路径。
- en: When asked whether `create-vite` should be installed, simply type `y` and press
    the *Return/Enter* key to proceed.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当被问及是否应安装 `create-vite` 时，只需输入 `y` 并按 *Return/Enter* 键继续。
- en: If you are asked about the current directory not being empty, select the option
    **Remove existing files and continue**, then press *Return/Enter* to confirm it.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果被询问当前目录不为空，选择 **删除现有文件并继续** 选项，然后按 *Return/Enter* 确认。
- en: When asked for a package name, confirm the default suggestion by pressing *Return/Enter*.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当被要求输入包名时，通过按 *Return/Enter* 确认默认建议。
- en: When asked about the framework, use the arrow keys to select **React** and press
    *Return/Enter*.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当被询问框架时，使用箭头键选择 **React** 并按 *Return/Enter*。
- en: When asked about the variant, select **JavaScript**.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当被问及变体时，选择 **JavaScript**。
- en: For simplicity and to cater to a wider audience, we are only using plain JavaScript
    in this book. It should be noted that, nowadays, TypeScript is widely used in
    many projects, so you may want to consider adopting TypeScript in your own projects
    later. However, learning about TypeScript is outside of the scope of this book.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了简单起见，并为了满足更广泛的受众，本书中我们只使用了纯JavaScript。需要注意的是，如今TypeScript在许多项目中得到了广泛应用，所以你可能希望在将来的项目中考虑采用TypeScript。然而，学习TypeScript超出了本书的范围。
- en: 'Edit `package.json` and make sure that the versions of `dependencies` and `devDependencies`
    are as follows:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `package.json` 并确保 `dependencies` 和 `devDependencies` 的版本如下：
- en: '[PRE13]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now our project is set up and we can run `npm install` in the terminal to install
    the dependencies.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的项目已设置好，我们可以在终端中运行 `npm install` 来安装依赖项。
- en: 'Afterward, run `npm run dev` to start the dev server, as shown in the following
    screenshot:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，运行 `npm run dev` 来启动开发服务器，如下截图所示：
- en: '![Figure 1.4 – The terminal after setting up a project with Vite and before
    starting the dev server](img/B31327_01_04.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – 使用Vite设置项目后的终端，在启动开发服务器之前](img/B31327_01_04.png)'
- en: Figure 1.4 – The terminal after setting up a project with Vite and before starting
    the dev server
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 使用Vite设置项目后的终端，在启动开发服务器之前
- en: For simplicity of setup, we just used `npm` directly. If you prefer `yarn` or
    `pnpm`, you can instead run `yarn create vite` or `pnpm create vite` respectively.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置简单，我们直接使用了 `npm`。如果你更喜欢 `yarn` 或 `pnpm`，你可以分别运行 `yarn create vite` 或 `pnpm
    create vite`。
- en: In the terminal, you will see a URL telling you where your app is running. You
    can either hold *Ctrl* (*Cmd* on macOS) and click on the link to open it in your
    browser, or manually enter the URL in a browser. Open the link in a browser now.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，你会看到一个URL，告诉你你的应用正在运行的位置。你可以通过按住 *Ctrl* (*Cmd* 在 macOS 上) 并点击链接在浏览器中打开它，或者手动在浏览器中输入URL。现在在浏览器中打开链接。
- en: To test whether your app is interactive, click the button with the text **count
    is 0**, and it should increase the count every time it is pressed.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试你的应用是否是交互式的，点击带有文本 **计数为0** 的按钮，每次点击它都应该增加计数。
- en: '![Figure 1.5 – Our first React app running with Vite](img/B31327_01_05.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5 – 使用Vite运行的我们的第一个React应用](img/B31327_01_05.png)'
- en: Figure 1.5 – Our first React app running with Vite
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – 使用Vite运行的我们的第一个React应用
- en: Alternatives to Vite
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Vite的替代方案
- en: Alternatives to Vite are bundlers, such as webpack, Rollup, and Parcel. These
    are highly configurable but often do not offer a great experience for dev servers.
    They first must bundle all our code together before serving it to the browser.
    Instead, Vite natively supports the **ECMAScript Module** (**ESM**) standard.
    Furthermore, Vite requires very little configuration to get started. A downside
    of Vite is that it can be hard to configure certain more complex scenarios with
    it. An upcoming bundler that is promising is Rolldown ([https://rolldown.rs](https://rolldown.rs));
    however, it is still very new at the time of writing.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Vite的替代品是webpack、Rollup和Parcel等打包器。这些打包器高度可配置，但通常不提供出色的开发服务器体验。它们必须首先将所有我们的代码打包在一起，然后再将其提供给浏览器。相反，Vite原生支持**ECMAScript
    Module**（**ESM**）标准。此外，Vite启动时几乎不需要配置。Vite的一个缺点是，用它配置某些更复杂的场景可能很困难。一个有希望的即将到来的打包器是Rolldown
    ([https://rolldown.rs](https://rolldown.rs))；然而，在撰写本文时，它仍然非常新。
- en: Now that our boilerplate project is up and running, let’s spend some time setting
    up tools that will enforce best practices and a consistent code style.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启动并运行了样板项目，让我们花些时间设置一些工具，这些工具将强制执行最佳实践和一致的代码风格。
- en: Setting up ESLint and Prettier to enforce best practices and code style
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置ESLint和Prettier以强制执行最佳实践和代码风格
- en: Now that our React app is set up, we are going to set up **ESLint** to enforce
    coding best practices with JavaScript and React. We are also going to set up **Prettier**
    to enforce a code style and automatically format our code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了React应用程序，我们将设置**ESLint**以使用JavaScript和React强制执行编码最佳实践。我们还将设置**Prettier**以强制执行代码风格并自动格式化我们的代码。
- en: Installing the necessary dependencies
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装必要的依赖项
- en: First, we are going to install all the necessary dependencies.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将安装所有必要的依赖项。
- en: In the terminal, click on the **Split Terminal** icon at the top right of the
    terminal pane to create a new terminal pane (alternatively, right-click on the
    terminal pane and select **Split Terminal**). This will keep our app running while
    we run other commands.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，点击终端面板右上角的**Split Terminal**图标以创建一个新的终端面板（或者，在终端面板上右键单击并选择**Split Terminal**）。这将保持我们的应用程序运行，同时我们可以运行其他命令。
- en: 'Click on this newly opened pane to focus it. Then, enter the following command
    to install Prettier and the Prettier config for ESLint:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击这个新打开的面板以将其聚焦。然后，输入以下命令来安装Prettier和Prettier的ESLint配置：
- en: '[PRE14]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `--save-dev` flag in `npm` saves those dependencies as `dev` dependencies,
    which means that they will only be installed for development. They will not be
    installed and included in a deployed app. The `--save-exact` flag ensures that
    the versions are pinned to the exact version provided by the book.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`npm`中使用`--save-dev`标志将那些依赖项保存为`dev`依赖项，这意味着它们将仅用于开发。它们不会被安装并包含在部署的应用程序中。`--save-exact`标志确保版本被固定为书中提供的确切版本。
- en: After the dependencies are installed, we need to configure Prettier and ESLint.
    We will start with configuring Prettier.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项安装完成后，我们需要配置Prettier和ESLint。我们将从配置Prettier开始。
- en: Configuring Prettier
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置Prettier
- en: 'Prettier will format the code for us and replace the default code formatter
    for JavaScript in VS Code. It will allow us to spend more time writing code, automatically
    formatting it for us properly when we save the file. Follow these steps to configure
    Prettier:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Prettier将为我们格式化代码，并替换VS Code中JavaScript的默认代码格式化器。它将允许我们花更多的时间编写代码，在保存文件时自动为我们正确地格式化代码。按照以下步骤配置Prettier：
- en: Right-click below the files list in the left sidebar of VS Code (if it is not
    opened, click the **Files** icon) and click on **New file...** to create a new
    file. Call it `.prettierrc.json` (do not forget the period at the beginning of
    the filename!).
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code左侧侧边栏的文件列表下方（如果未打开，请点击**Files**图标）右键单击，然后点击**New file...**来创建一个新文件。将其命名为`.prettierrc.json`（不要忘记文件名开头的点！）。
- en: 'The newly created file should open automatically; start writing the following
    configuration into it. We first create a new object and set the `trailingComma`
    option to `all` to make sure objects and arrays that span over multiple lines
    always have a comma at the end, even for the last element. This reduces the number
    of touched lines when committing a change via Git:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新创建的文件应自动打开；开始将以下配置写入其中。我们首先创建一个新的对象，并将`trailingComma`选项设置为`all`，以确保跨越多行的对象和数组始终在末尾有逗号，即使是最后一个元素。这减少了通过Git提交更改时需要修改的行数：
- en: '[PRE15]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we set the `tabWidth` option to two spaces:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将`tabWidth`选项设置为两个空格：
- en: '[PRE16]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Set `printWidth` to 80 characters per line to avoid long lines in our code:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Set the `semi` option to `false` to avoid semicolons where not necessary:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we enforce the use of single quotes instead of double quotes:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These settings for Prettier are just an example of a coding style convention.
    Of course, you are free to adjust these to your own preferences. There are many
    more options, all of which can be found in the Prettier docs ([https://prettier.io/docs/en/options.html](https://prettier.io/docs/en/options.html)).
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Configuring the Prettier extension
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have a configuration file for Prettier, we need to make sure the
    VS Code extension is properly configured to format the code for us:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Open the VS Code settings by going to **File | Preferences... | Settings** on
    Windows/Linux, or **Code | Settings... | Settings** on macOS.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the newly opened settings editor, click on the **Workspace** tab. This ensures
    that we save all our settings in a `.vscode/settings.json` file in our project
    folder. When other developers open our project, they will automatically be using
    those settings as well.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for `editor format on save` and check the checkbox to enable formatting
    code on save.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for `editor default formatter` and select **Prettier - Code formatter**
    from the list.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To verify that Prettier works, open the `.prettierrc.json` file, add some extra
    spaces to the beginning of a line, and save the file. You should notice that Prettier
    reformatted the code to adhere to the defined code style. It will reduce the number
    of spaces for indentation to 2.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that Prettier is set up properly, we do not need to worry about formatting
    our code manually anymore. Feel free to just type in code as you go and save the
    file to get it formatted for you!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Prettier ignore file
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To improve performance and avoid running Prettier on files that should not
    be automatically formatted, we can ignore certain files and folders by creating
    a Prettier ignore file. Follow these steps:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `.prettierignore` in the root of our project, similar
    to how we created the `.prettierrc.json` file.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following contents to it, to ignore the transpiled source code:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `node_modules/` folder is automatically ignored by Prettier.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have successfully set up Prettier, we are going to configure ESLint
    to enforce coding best practices.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Configuring ESLint
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While Prettier focuses on the style and formatting of our code, ESLint focuses
    on the actual code, avoiding common mistakes or unnecessary code. Let’s configure
    it now:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the automatically created `eslint.config.js` file and add the following
    import to it:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Scroll down to the bottom of the file, and add the Prettier config at the end
    of the array, as follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Additionally, disable the `react/prop-types` rule, as follows:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Since React 19, prop type checks are completely removed and will be silently
    ignored. The only way to add type checks to props is to use a full type-checking
    solution, such as TypeScript. Since we are focusing on learning plain React with
    Hooks in this book, using TypeScript is out of scope. However, if you haven’t
    yet, I strongly recommend learning TypeScript on your own after finishing this
    book.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Save the files and run `npx eslint src` in the terminal to run the linter. You
    will see that there is no output, which means that everything was linted successfully
    and there were no errors!
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `npx` command allows us to execute commands provided by `npm` packages,
    in a similar context as running them in `package.json` scripts would do. It can
    also run remote packages without installing them permanently. In the case that
    the package is not installed yet, it will ask you whether it should do this.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new script to run our linter
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section, we have been calling the linter by running `npx eslint
    src` manually. We are now going to add a `lint` script to our `package.json`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Terminal, run the following command to define a lint script in our `package.json`
    file:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, run `npm run lint` in the terminal. This should execute `eslint src` successfully,
    just like `npx eslint src` did:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.6 – The linter running successfully, with no errors](img/B31327_01_06.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – The linter running successfully, with no errors
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have successfully set up our development environment, let’s move
    on to learning about using React class components versus React Hooks in practice!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '**Example code**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The example code for this section can be found in the `Chapter01/Chapter01_1`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with React Hooks
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned earlier in this chapter, React Hooks solve many problems, especially
    in larger web applications. Hooks were added in React 16.8, and they allow us
    to use state, and various other React features, without writing a class. In this
    section, we will start by defining a class component, and then we will write the
    same component as a function component using Hooks. We will then discuss the advantages
    of Hooks and how to migrate from classes to a Hook-based solution.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Starting with a class component
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by creating a traditional React class component, which lets us
    enter a name; this is then displayed in our app:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the `Chapter01_1` folder to a new `Chapter01_2` folder, as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: On macOS, it is important to run the command with a capitalized `-R` flag, not
    `-r`. The `-r` flag deals differently with symlinks and causes the `node_modules/`
    folder to break. The `-r` flag only exists for historical reasons and should not
    be used on macOS. Always prefer using the `-R` flag instead.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the new `Chapter01_2` folder in VS Code.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Remove* the `src/assets/` folder and all its contents.'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Remove* the `src/App.css` and `src/index.css` files.'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `src/main.jsx` file and *remove* the following import:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Additionally, adjust the import of the `App` component from a default import
    to a named import, as follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In most cases, it’s preferable to use named exports/imports over default exports/imports.
    Using named exports/imports makes the code less error-prone when refactoring.
    For example, let’s imagine you have a `Login` component and you copy and paste
    it to a new `Register` component but forget to rename the component to `Register`.
    With default imports, it will still be possible to import it as `Register`, although
    the component is called `Login` internally. However, when debugging in React dev
    tools or trying to find the component in your project, you will see it named `Login`,
    which can be confusing, especially in large-scale projects. When dealing with
    functions, using named exports is even more useful because it allows you to move
    them around in different files easily.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the `src/App.jsx` file and *remove* all existing code from it.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we import React, as follows:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We then start defining a class component:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we have to define a `constructor` method, where we set the initial `state`
    object, which will be an empty string. Here, we also need to make sure to call
    `super(props)`, to let the `React.Component` constructor know about the `props`
    object:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we define a method to set the `name` variable, by using `this.setState`.
    As we will be using the method to handle input from a text field, we need to use
    `evt.target.value` to get the value from the input field:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, we define the `render` method, where we are going to display an input
    field and the name:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To get the `name` variable from the `this.state` object, we are going to use
    destructuring:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The previous statement is the equivalent of doing the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we display the currently entered `name` state variable:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We display an input field, passing the handler method to it:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If we were to run this code now, we would get the following error when entering
    text, because passing the handler method to `onChange` changes the `this` context:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Or, on some browsers, you may get the following error instead:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So, now we need to adjust the constructor method and rebind the `this` context
    of our handler method to the class. Edit `src/App.jsx` and add the following line
    in the constructor:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Run the dev server, by opening a terminal (**Terminal** | **New Terminal**
    menu option in VS Code), and executing the following command:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Open the link to the dev server in your browser, and you should see the component
    being rendered. Try entering some text now and it should work!
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alternatively, since ES6, it is possible to use arrow functions as class methods
    to avoid having to rebind the `this` context.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Finally, our component works! As you can see, there is a lot of code required
    to get state handling to work properly with class components. We also had to rebind
    the `this` context; otherwise, our handler method would not work. This is not
    very intuitive, and is easy to miss while developing, causing a frustrating developer
    experience.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '**Example code**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: The example code for this section can be found in the `Chapter01/Chapter01_2`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Using Hooks instead
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After using a traditional class component to create our app, we are going to
    write the same app using Hooks. As before, our app is going to let us enter a
    name, which we then display in the app.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: It is only possible to use Hooks in React function components. You cannot use
    Hooks in a React class component.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to get started:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the `Chapter01_2` folder to a new `Chapter01_3` folder, as follows:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Open the new `Chapter01_3` folder in VS Code.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `src/App.jsx` file and *remove* all existing code from it.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we import the `useState` Hook, as follows:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We start with the function definition. In our case, we do not pass any arguments,
    because our component does not have any props:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The next step would be to get the `name` variable from the component state.
    However, we cannot use `this.state` in function components. We have already learned
    that Hooks are just JavaScript functions, but what does that really mean? It means
    that we can simply use Hooks from function components, just like any other JavaScript
    function!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'To use state via Hooks, we call `useState()`, with our initial state as the
    argument. This function returns an array with two elements:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: The current state
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A setter function to set the state
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use destructuring to store these two elements in separate variables,
    as follows:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The previous code is equivalent to the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, we define the input handler function, where we make use of the `setName`
    setter function:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As we are not dealing with classes now, there is no need to rebind `this` anymore!
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we render our user interface, by returning it from the function:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: And that’s it – we have successfully used Hooks for the first time! As you can
    see, the `useState` Hook is a simple replacement for `this.state` and `this.setState`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run our app by executing `npm run dev` in the Terminal and opening the
    URL in a browser:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7 – Our first React app using Hooks!](img/B31327_01_07.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
- en: Figure 1.7 – Our first React app using Hooks!
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: After implementing the same app with a class component and a function component,
    let’s compare the solutions.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '**Example code**'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: The example code for this section can be found in the `Chapter01/Chapter01_3`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the solutions
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s compare our two solutions to see the differences between class components
    and function components using Hooks.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Class component
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The class component makes use of the `constructor` method to define state and
    needs to rebind `this` to be able to pass the handler method to the `input` field.
    The full class component code looks as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As we can see, the class component needs a lot of boilerplate code to initialize
    the `state` object and handler functions.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s take a look at the function component.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Function component with a Hook
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The function component makes use of the `useState` Hook instead, so that we
    do not need to deal with `this` or a `constructor` method. The full function component
    code looks as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As we can see, Hooks make our code much more concise and easier to reason about.
    We do not need to worry about how things work internally anymore; we can simply
    use state, by accessing the `useState` function!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of Hooks
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s remind ourselves about the first principle of React:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'Declarative: Instead of telling React how to do things, we tell it what we
    want it to do. As a result, we can easily design our applications, and React will
    efficiently update and render just the right components when the data changes.'
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As we have learned in this chapter, Hooks allow us to write code that tells
    React what we want. With class components, however, we need to tell React how
    to do things. As a result, Hooks are much more declarative than class components,
    making them a better fit in the React ecosystem.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Hooks being declarative also means that React can do various optimizations on
    our code, since it is easier to analyze functions and function calls rather than
    classes and their complex `this` behavior. Additionally, Hooks make it easier
    to abstract and share common stateful logic between components. By using Hooks,
    we can avoid render props and higher-order components.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: We can see that Hooks not only make our code more concise and are easier to
    reason about for developers but they also make the code easier to optimize for
    React.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Migrating to Hooks
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, you might be wondering whether that means class components are deprecated,
    and we need to migrate everything to Hooks now. Of course not – Hooks are completely
    opt-in. You can try Hooks in some of your components without rewriting any of
    your other code. The React team also does not plan on removing classes at the
    moment.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: There is no rush to migrate everything to Hooks right now. It is recommended
    that you gradually adopt Hooks in certain components where they will be most useful.
    For example, if you have many components that deal with similar logic, you can
    extract the logic to a Hook. You can also use function components with Hooks side
    by side with class components.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'Hooks are backward-compatible and provide a direct API to various React concepts
    that you already know about: **props**, **state**, **context**, **refs**, and
    the **life cycle**. Additionally, Hooks offer new ways to combine these concepts
    and encapsulate their logic in a much better way that does not lead to wrapper
    hell or similar problems.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: The Hooks mindset
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main goal of Hooks is to decouple stateful logic from rendering logic. Hooks
    allow us to define logic in separate functions and reuse them across multiple
    components. With Hooks, we do not need to change our component hierarchy to implement
    stateful logic. There is no need to define a separate component that provides
    the state logic to multiple components anymore, we can simply use a Hook instead!
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: However, Hooks require a completely different mindset from traditional React
    development. We should not think about the life cycle of components anymore. Instead,
    we should think about data flow. For example, we can tell Hooks to trigger when
    certain props or values from other Hooks change. We are going to learn more about
    this concept in [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor103), *Using the Reducer
    and Effect Hooks*. We should also not split components based on life cycle methods
    anymore. Instead, we can use Hooks to deal with common functionalities, such as
    fetching data or setting up a data subscription.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Rules of Hooks
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Hooks are very flexible. However, there are certain limitations to using Hooks,
    which we should always keep in mind:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Hooks can only be used in function components and inside other Hooks, not in
    class components or arbitrary functions
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order of Hook definitions matters and needs to stay the same; thus, we cannot
    put Hooks in `if` conditionals, loops, or nested functions
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thankfully, Vite already configured an ESLint plugin for us that ensures that
    the rules of Hooks are not violated.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: We are going to discuss these limitations in more detail, as well as how to
    work around them, throughout this book.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this first chapter of the book, we started by learning about the fundamental
    principles of React, and which types of components it provides. We then moved
    on to learn about common problems with class components, using existing features
    of React, and how they break the fundamental principles. Next, we implemented
    a simple application using class components and function components with Hooks,
    in order to be able to compare the differences between the two solutions. As we
    found out, function components with Hooks are a much better fit for React’s fundamental
    principles; they do not suffer from the same problems as class components, and
    they make our code much more concise and easy to understand! The React team now
    even recommends using function components instead of class components, making
    function components the state-of-the-art way to write React code. After reading
    this chapter, the basics of React and React Hooks are clear. We can now move on
    to learn about Hooks in detail.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to gain an in-depth knowledge of how the State
    Hook works, by reimplementing it from scratch. By doing so, we are going to get
    a grasp on how Hooks work internally, and what their limitations are. Afterward,
    we are going to create a small blog application using the State Hook!
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To recap what we have learned in this chapter, try to answer the following
    questions:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: What are React’s three fundamental principles?
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two types of components in React?
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the problems with class components in React?
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the problem when using higher-order components in React?
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which tool can we use to set up a React project, and what is the command that
    we need to run to use it?
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What do we need to do if we get the following error with class components:
    `Uncaught TypeError: Cannot read properties of undefined (reading ''setState'')`?'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we use React state with Hooks?
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the advantages of using function components with Hooks, in comparison
    to class components?
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do we need to replace all class components with function components using Hooks
    when updating React?
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are interested in more information about the concepts that we have learned
    in this chapter, take a look at the following links:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'Information about function components: [https://react.dev/reference/react/Component](https://react.dev/reference/react/Component)'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RFC for React Hooks: [https://github.com/reactjs/rfcs/blob/main/text/0068-react-hooks.md](https://github.com/reactjs/rfcs/blob/main/text/0068-react-hooks.md)'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Destructuring: [https://exploringjs.com/es6/ch_destructuring.html](https://exploringjs.com/es6/ch_destructuring.html)'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Template strings: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ternary operator: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_operator)'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '三元运算符: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_operator)'
- en: Learn more on Discord
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的 Discord 社区——在那里您可以分享反馈、向作者提问以及了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/wnXT0](Chapter_01.xhtml)'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/wnXT0](Chapter_01.xhtml)'
- en: '![](img/image_%283%29.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_%283%29.png)'
