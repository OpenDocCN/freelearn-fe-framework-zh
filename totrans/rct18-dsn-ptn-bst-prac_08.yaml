- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Hooks have revolutionized the way we write React applications, allowing
    us to use functional components instead of class components, and making coding
    faster and more efficient. Since their introduction in React 16.8, Hooks have
    become an essential part of React development and have greatly improved the performance
    of our applications. With Hooks, we can manage the state, handle side effects,
    and reuse code in a more concise and readable way. In the next chapter, we will
    explore the different types of Hooks and how to use them to enhance our React
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The new React Hooks and how to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rules of the Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to migrate a class component to React Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the component life cycle with Hooks and effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to fetch data with Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to memoize components, values, and functions with `memo`, `useMemo`, and
    `useCallback`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement `useReducer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js 19+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the code for this chapter in the book’s GitHub repository at [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing React Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Hooks are a new addition to **React 16.8**. They let you use state and
    other React features without writing a React class component. React Hooks are
    also backward-compatible, which means they do not contain any breaking changes
    or not replace your knowledge of React concepts. Over the course of this chapter,
    we will see an overview of Hooks for experienced React users, and we are also
    going to learn about some of the most common React Hooks such as `useState`, `useEffect`,
    `useMemo`, `useCallback`, and `memo`.
  prefs: []
  type: TYPE_NORMAL
- en: No breaking changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the context of React development, it’s a common misconception that the introduction
    of React Hooks has made class components obsolete. However, this is not true,
    as there are no plans to remove classes from React. The Hooks API does not replace
    your understanding of React concepts, but rather offers a more streamlined approach
    to working with those concepts, such as props, states, context, refs, and life
    cycles, which you are already familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: Using the State Hook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In old React code, we used `this.setState` to use the component state. Now we
    will use the `useState` hook to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to extract the `useState` Hook from React:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Since React 17, the `React` object is no longer required to render JSX code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you need to declare the state you want to use by defining the state and
    the setter for this specific state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are declaring the counter state with the `setCounter` setter
    and we are specifying that we will only accept numbers, and finally, we are setting
    the initial value to zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to test our state, we need to create a method that will be triggered
    by the `onClick` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can render the `counter` state and some buttons to increase or
    decrease the counter state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you click on the **+ Add** button once, you should see **1** for **Counter**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_08_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Counter 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'And if you click the **- Subtract** button twice, then you should see **-1**
    for **Counter**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_08_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Counter -1'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `useState` Hook is a game changer in React and makes it
    very easy to handle the state in a functional component.
  prefs: []
  type: TYPE_NORMAL
- en: After appreciating how the `useState` Hook has revolutionized state management
    in functional components within React, we are now ready to delve deeper into the
    nuances of Hooks. The following section will discuss the essential *rules of Hooks*
    that govern their usage in React applications.
  prefs: []
  type: TYPE_NORMAL
- en: Rules of Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React Hooks are basically JavaScript functions, but there are two rules that
    you need to follow in order to use them. React provides a linter plugin to enforce
    those rules for you, which you can install by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let’s look at these two rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 1: Only call Hooks at the top level'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To ensure the proper functioning of React Hooks, it is important to avoid calling
    them inside loops, conditions, or nested functions. Instead, it is recommended
    to always use Hooks at the top level of your React function. This practice ensures
    that Hooks are called in the same order every time a component is rendered, allowing
    React to correctly preserve the state of Hooks between multiple `useState` and
    `useEffect` calls. Following this rule will help you write more efficient and
    maintainable code with React Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 2: Only call Hooks from React functions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To ensure that all stateful logic in a component is clearly visible from its
    source code, avoid calling Hooks from regular JavaScript functions. Instead, use
    Hooks in React function components or custom Hooks (which we’ll learn about in
    the next section). By following this practice, you can ensure that all stateful
    logic is centralized and easily understandable.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to migrate a class component to use the
    new React Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating a class component to React Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s transform code that is currently using class components and is also using
    some life cycle methods. In this example, we are fetching the issues from a GitHub
    repository and listing them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, you will need to install `axios` to perform the fetch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the class component version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you render this component, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_08_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: ContentPI Issues'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s transform our code into a functional component using React Hooks.
    The first thing we need to do is to import some React functions and types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can remove the `Props` and `State` types we created previously and just
    leave the `Issue` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, you can change the class definition to use a functional component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FC` type is used to define a **functional component** in React. If you
    need to pass some props to the component, you can pass them like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we need to do is to replace our constructor and our state definition
    by using the `useState` Hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used the life cycle method called `componentDidMount` before, which
    is executed when the component is mounted and is going to run just once. The new
    React Hook, called `useEffect`, will now handle all the life cycle methods using
    different syntax for each one, but for now, let’s see how we can get the same
    *effect* of `componentDidMount` in our new functional component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we just render our JSX code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the new Hooks help us to simplify our code a lot and makes more
    sense. Also, we reduced our code by 10 lines (the class component code has 53
    lines, and the functional component has 43 lines).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen the transformative power of new Hooks in streamlining
    our code and reducing verbosity, let’s shift our focus to another foundational
    concept in React. In the next section, we will delve into the differences between
    component life cycle methods used in class components and the innovative React
    effects.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding React effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn the difference between the component life cycle
    methods that we used in class components and the new React effects. Even if you
    have read in other places that they are the same, just with a different syntax,
    this is not correct.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding useEffect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you work with `useEffect`, you need to *think in terms of effects*. If
    you want to perform the equivalent method of `componentDidMount` using `useEffect`,
    you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is the callback of the effect that you want to execute,
    and the second parameter is the dependencies array. If you pass an empty array
    (`[]`) to the dependencies, the state and props will have their original initial
    values.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is important to mention that even though this is the closest equivalent
    to `componentDidMount`, it does not have the same behavior. Unlike `componentDidMount`
    and `componentDidUpdate`, the function that we pass to `useEffect` fires after
    layout and paint, during a deferred event. This normally works for many common
    side effects, such as setting up subscriptions and event handlers, because most
    types of work shouldn’t block the browser from updating the screen.
  prefs: []
  type: TYPE_NORMAL
- en: However, not all effects can be deferred. For example, you will get a blink
    if you need to mutate the **Document Object Model** (**DOM**). This is the reason
    why you must fire the event synchronously before the next paint. React provides
    one Hook called `useLayoutEffect`, which works in the exact same way as `useEffect`.
  prefs: []
  type: TYPE_NORMAL
- en: Firing an effect conditionally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need to fire an effect conditionally, then you should add a dependency
    to the array of dependencies; otherwise, you will execute the effect multiple
    times and this may cause an infinite loop. If you pass an array of dependencies,
    the `useEffect` Hook will only run if one of those dependencies changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you understand how the React class life cycle methods work, basically, `useEffect`
    behaves in the same way as `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`
    combined.
  prefs: []
  type: TYPE_NORMAL
- en: The effects are very important, but let’s also explore some other important
    new Hooks, including `useCallback`, `useMemo`, and `memo`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding useCallback, useMemo, and memo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to understand the difference between `useCallback`, `useMemo`, and
    `memo`, we will do a to-do list example. You can create a basic application by
    using `create-react-app` and Typescript as a template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Right after that, you can remove all the extra files (`App.css, App.test.ts`,
    `index.css`, `logo.svg`, `reportWebVitals.ts`, and `setupTests.ts`). You just
    need to keep the `App.tsx` file, which will contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, we are defining some initial tasks and creating the `todoList` state,
    which we will pass to the `List` component. Then, you need to create the `List.tsx`
    file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are rendering each task of the `todoList` array by using
    the `Task` component and we pass the task as a prop. I also added a `useEffect`
    Hook to see how many renders we are performing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we create our `Task.tsx` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we should see the to-do list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_08_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: To-do list'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, when we render our to-do list, by default, we are performing
    two renders of the `Task` component, one render for `List`, and the other for
    the `App` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we try to write a new task in the input, we can see that for each letter
    we write, we will again see all of those renders:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_08_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: Searching in the to-do list'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, by just writing `Go`, we have two new batches of renders, so
    we can determine that this component does not have good performance, and this
    is where `memo` can help us to improve performance. In the next sections, we are
    going to learn how to implement `memo`, `useMemo`, and `useCallback` to memoize
    a component, a value, and a function.
  prefs: []
  type: TYPE_NORMAL
- en: Memoizing a component with memo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `memo` **High-Order Component** (**HOC**) is similar to `PureComponent`
    for a React class because it performs a shallow comparison of the props (meaning
    a superficial check), so if we try to render a component with the same props all
    the time, the component will render just once and will memoize. The only way to
    re-render the component is when a prop changes its value.
  prefs: []
  type: TYPE_NORMAL
- en: In order to fix our components to avoid multiple renders when we write in the
    input, we need to wrap our components in the `memo` **HOC**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first component we will fix is our `List` component, and you just need
    to affect `import memo` and wrap the component in `export default`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you need to do the same with the `Task` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we try to write `Go` again in the input, let’s see how many renders
    we get this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_08_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: Evaluating how many renders our to-do list is performing'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we just get the first batch of renders the first time, and then, when we
    write `Go`, we just get two more renders of the `App` component, which is totally
    fine because the task state (input value) that we are changing is actually part
    of the `App` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we can see how many renders we are performing when we create a new task
    by clicking on the **Create** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_08_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: Improving performance'
  prefs: []
  type: TYPE_NORMAL
- en: If you see, the first 16 renders are the word counting of the `Go to the doctor`
    string, and then, when you click on the **Create** button, you should see one
    render of the `Task` component, one render of `List`, and one render of the `App`
    component. As you can see, we have improved performance a lot, and we are just
    performing the exact need that it renders.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you’re probably thinking that the correct thing is to always
    add `memo` to our components, or maybe you’re thinking, why React doesn’t do this
    by default for us?
  prefs: []
  type: TYPE_NORMAL
- en: The reason is *performance*, which means *it is not a good idea to add* `memo`
    *to all our components unless it is totally necessary*; otherwise, the process
    of shallow comparisons and memorization will have inferior performance than if
    we don’t use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have a rule when it comes to establishing whether it is a good idea to use
    `memo`, and this rule is straightforward: **just don’t use it**. Normally, when
    we have small components or basic logic, we don’t need this *unless you’re working
    with large data from some API, your component needs to perform a lot of renders
    (normally huge lists), or when you notice that your app is going slow*. Only in
    that case would I recommend using `memo`.'
  prefs: []
  type: TYPE_NORMAL
- en: Memoizing a value with useMemo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s suppose that we now want to implement a search feature in our to-do list.
    The first thing we need to do is to add a new state called `term` to the `App`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to create a function called `handleSearch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Right before the return, we will create `filterTodoList`, which will filter
    the to-dos based on the task, and we will add a console there to see how many
    times it is being rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to add a new button next to the **Create** button that already
    exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, I recommend that you remove or comment `console.log` in the
    `List` and `Task` components so that we can focus on the performance of filtering:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_08_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: Reviewing filtering performance'
  prefs: []
  type: TYPE_NORMAL
- en: When you run the application again, you will see that filtering is being executed
    twice, and then the `App` component as well, and everything looks good here, but
    what’s the problem with this?
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to write `Go to the doctor` again in the input and let’s see how many counts
    of `Rendering…` and `Filtering…` you get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_08_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.9: Bad performance on filtering'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, for each letter you write, you will get two filtering calls
    and one `App` render. You don’t need to be a genius to see that this is bad performance;
    not to mention that if you are working with a large data array, this will be worse,
    so how can we fix this issue?
  prefs: []
  type: TYPE_NORMAL
- en: 'The `useMemo` Hook is our hero in this situation, and basically, we need to
    move our filter inside `useMemo`, but first, let’s see the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `useMemo` Hook will memoize the result (value) of a function and will have
    some dependencies to listen to. Let’s see how we can implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you write something again in the input, you will see that filtering
    won’t be executed all the time, as was the case previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_08_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.10: Improving the performance of filtering'
  prefs: []
  type: TYPE_NORMAL
- en: This is great, but there is still one small problem. If you try to click on
    the **Search** button, it won’t filter, and this is because we missed the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, if you see the console warnings, you will see this warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18414_08_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.11: react-hooks/exhaustive-deps'
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to add the `term` and `todoList` dependencies to the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It should now work if you write `Go` and click on the **Search** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_08_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.12: After fixing the warning'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have to use the same rule that we used for `memo`; *just don’t use
    it until absolutely necessary*.
  prefs: []
  type: TYPE_NORMAL
- en: Memoizing a function definition with useCallback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we will add a delete task feature to learn how `useCallback` works. The
    first thing we need to do is to create a new function called `handleDelete` in
    our `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And then you need to pass this function to the `List` component as a prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in our `List` component, you need to add the prop to the `Props` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you need to pull it from the props and pass it down to the `Task` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Task` component, you need to create a button that will execute `handleDelete`
    `onClick`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, I recommend that you remove or comment `console.log` in the
    `List` and `Task` components so that we can focus on the performance of filtering.
    Now you should see the **X** button next to the task:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_08_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.13: Let’s delete a task'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on the **X** for `Go shopping`, you should be able to remove it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_08_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.14: Deleting a task'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, so good, right? But again, we have a little issue with this implementation.
    If you now try to write something in the input, such as `Go to the doctor`, let’s
    see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_08_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.15: Bad performance'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we are performing `71` renders of all the components again.
    At this point, you are probably thinking about, *what is going on if we have already
    implemented the memo HOC to memoize the components?* But the problem now is that
    our `handleDelete` function is being passed to two components, from `App` to `List`
    and `Task`, and the issue is that this function is regenerated every time we have
    a new re-render, in this case, every time we write something. So how do we fix
    this problem?
  prefs: []
  type: TYPE_NORMAL
- en: 'The `useCallback` Hook is the hero in this case and is very similar to `useMemo`
    in the syntax, but the main difference is that instead of memorizing the result
    value of a function, as `useMemo` does, it is memorizing the **function definition**
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `handleDelete` function should be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it should work just fine if we write `Go to the doctor` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_08_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.16: Improving performance'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, instead of `71` renders, we just have `23`, which is normal, and we are
    also able to delete tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_08_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.17: Deleting tasks'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `useCallback` Hook helps us to improve performance significantly.
    In the next section, you will learn how to memoize a function passed as an argument
    in the `useEffect` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: Memoizing a function passed as an argument in effect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is a special case where we will need to use the `useCallback` Hook, and
    this is when we pass a function as an argument in a `useEffect` Hook, for example,
    in our `App` component. Let’s create a new `useEffect` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we are listening for changes to the `todoList` state. If you
    run this code and you create or remove a task, it will work just fine (remember
    to remove all the other consoles first):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface  Description automatically generated](img/B18414_08_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.18: Changing the to-do list'
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything works fine, but let’s add `todoList` to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re using Visual Studio Code, you will get the following warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_08_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.19: react-hooks/exhaustive-deps'
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, it is asking us to add the `printTodoList` function to the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'But now, after we do that, we get another warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18414_08_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.20: useCallback warning'
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason why we get this warning is that we are now manipulating the state
    (consoling the state), which is why we need to add a `useCallback` Hook to this
    function to fix this issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we delete a task, we can see that `todoList` updated correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18414_08_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.21: Changing to-do list data'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, this may be information overload for you, so let’s have a quick
    recap:'
  prefs: []
  type: TYPE_NORMAL
- en: '`memo`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memoizes a **component**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-memoizes when props change
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoids re-renders
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useMemo`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memoizes a calculated value
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For computed properties
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For heavy processes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useCallback`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memoizes a **function definition** to avoid redefining it on each render
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use it whenever a function is passed as an effect argument
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use it whenever a function is passed by props to a memoized component
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And finally, do not forget the golden rule: *Do not use them until absolutely
    necessary*.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to learn how to use the new `useReducer` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the useReducer Hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You probably have some experience using Redux (`react-redux`) with class components,
    and if that is the case, then you will understand how `useReducer` works. The
    concepts are basically the same: actions, reducers, dispatch, store, and state.
    Even if, in general, it seems very similar to react-redux, they have some differences.
    The main difference is that react-redux provides middleware and wrappers such
    as **thunk**, **sagas**, and many more besides, while `useReducer` just gives
    you a `dispatch` method that you can use to dispatch plain objects as actions.
    Also, `useReducer` does not have a store by default; instead, you can create one
    using `useContext`, but this is just reinventing the wheel.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a basic application to understand how `useReducer` works. You
    can start by creating a new React app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Then, as always, you can delete all files in your `src` folder except `App.tsx`
    and `index.tsx` to start a brand-new application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a basic `Notes` application where we can `list`, `delete`, `create`,
    or `update` our notes using `useReducer`. The first thing you need to do is import
    the `Notes` component, which we will create later, into your `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in our `Notes` component, you first need to import `useReducer` and `useState`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to define some TypeScript types that we need to use for our `Note`
    object, the `Redux` action, and the **action types**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we need to create `initialNotes` (also known as `initialState`)
    with some dummy notes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If you remember how the reducers work, then this will seem very similar to
    how we handle the reducer using a `switch` statement, so as to perform basic operations
    such as `ADD`, `DELETE`, and `UPDATE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the component is very straightforward. Basically, you get the notes
    and the dispatch method from the `useReducer` Hook (similar to `useState`), and
    you need to pass the `reducer` function and `initialNotes` `(initialState`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have a `handleSubmit` function to create a new note when we write
    something in the input. Then, we press *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we render our `Notes` list with `map`, and we also create two buttons,
    one for `delete` and one for `update`, and then the input should be wrapped into
    a `<form>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the application, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_08_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.22: React DevTools'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the **React DevTools**, the `Reducer` object contains the
    two notes that we have defined as our initial state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you write something in the input and you press *Enter*, you should
    be able to create a new note:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_08_23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.23: Creating a new note'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, if you want to delete a note, you just need to click on the **X** button.
    Let’s remove **Note 2**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18414_08_24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.24: Deleting a note'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can write anything you want in the input, and if you click on
    the **Update** button, you will change the note value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18414_08_25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.25: Updating a note'
  prefs: []
  type: TYPE_NORMAL
- en: Nice, huh? As you can see, the `useReducer` Hook is pretty much the same as
    `redux` in terms of the dispatch method, actions, and reducers, but the main difference
    is that this is limited just to the context of your component and its child, so
    if you need a global store to be accessible from your entire application, then
    you should use `react-redux` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope you enjoyed reading this chapter, which is full of very good information
    pertaining to the new React Hooks. So far, you have learned how the new React
    Hooks work; how to fetch data with Hooks; how to migrate a class component to
    **React Hooks**; how the effects work, the difference between `memo`, `useMemo`,
    and `useCallback`; and finally, you learned how the `useReducer` Hook works and
    the main difference compared with `react-redux`. This will help you to improve
    the performance of your React components.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about React Router v6 and how to implement
    it in our projects.
  prefs: []
  type: TYPE_NORMAL
