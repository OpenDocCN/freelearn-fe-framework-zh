<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer017">
<h1 class="chapter-number" id="_idParaDest-64"><a id="_idTextAnchor062"/>4</h1>
<h1 id="_idParaDest-65"><a id="_idTextAnchor063"/>Test-Driving Data Input</h1>
<p>In this chapter, you’ll explore React forms and controlled components.</p>
<p>Forms are an essential part of building web applications, being the primary way that users enter data. If we want to ensure our application works, then invariably, that’ll mean we need to write automated tests for our forms. What’s more, there’s a lot of plumbing required to get forms working in React, making it even more important that they’re well-tested.</p>
<p>Automated tests for forms are all about the user’s behavior: entering text, clicking buttons, and submitting the form when complete. </p>
<p>We will build out a new component, <strong class="source-inline">CustomerForm</strong>, which we will use when adding or modifying customers. It will have three text fields: first name, last name, and phone number.</p>
<p>In the process of building this form, you’ll dig deeper into testing complex DOM element trees. You’ll learn how to <a id="_idIndexMarker336"/>use parameterized tests to repeat a group of tests without duplicating code.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Adding a form element</li>
<li>Accepting text input</li>
<li>Submitting a form</li>
<li>Duplicating tests for multiple form fields</li>
</ul>
<p>By the end of this chapter, you’ll have a decent understanding of test-driving HTML forms with React.</p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor064"/>Technical requirements</h1>
<p>The code files for this chapter can be found here: <a href="https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter04">https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter04</a>.</p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor065"/>Adding a form element</h1>
<p>An HTML form is a bunch of fields wrapped in a <strong class="source-inline">form</strong> element. Even though we’re mostly interested in the fields, we need to start with the <strong class="source-inline">form</strong> element itself. That’s what we’ll build in this section.</p>
<p>Let’s create our first form by following these steps:</p>
<ol>
<li>Create a new file called <strong class="source-inline">test/CustomerForm.test.js</strong> and add the following scaffold. It contains all the usual imports and component test initialization that you’ve seen in the previous chapters:<p class="source-code">import React from "react";</p><p class="source-code">import {</p><p class="source-code">  initializeReactContainer,</p><p class="source-code">  render,</p><p class="source-code">  element,</p><p class="source-code">} from "./reactTestExtensions";</p><p class="source-code">import { CustomerForm } from "../src/CustomerForm";</p><p class="source-code">describe("CustomerForm", () =&gt; {</p><p class="source-code">  beforeEach(() =&gt; {</p><p class="source-code">    initializeReactContainer();</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Now you’re ready to create your first test. Add the following test to the <strong class="source-inline">describe</strong> block:<p class="source-code">it("renders a form", () =&gt; {</p><p class="source-code">  render(&lt;CustomerForm /&gt;);</p><p class="source-code">  expect(element("form")).not.toBeNull();</p><p class="source-code">});</p></li>
<li>We have a complete test, so let’s run it and see what happens:<p class="source-code">FAIL test/CustomerForm.test.js</p><p class="source-code">  ● Test suite failed to run</p><p class="source-code">    Cannot find module '../src/CustomerForm' from 'CustomerForm.test.js'</p></li>
</ol>
<p>The failure<a id="_idIndexMarker337"/> tells us that it can’t find the module. That’s because we haven’t created it yet. </p>
<ol>
<li value="4">So, create a blank file named <strong class="source-inline">src/CustomerForm.js</strong>. Running your test again should give you the following output:<p class="source-code">FAIL test/CustomerForm.test.js</p><p class="source-code"> ● CustomerForm › renders a form</p><p class="source-code">   Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: undefined. You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.</p><p class="source-code">       8 |</p><p class="source-code">       9 | export const render = (component) =&gt;</p><p class="source-code">    &gt; 10 |   act(() =&gt; </p><p class="source-code">      11 |     ReactDOM.createRoot(...).render(...)</p><p class="source-code">         |     ^</p><p class="source-code">      12 |   );</p><p class="source-code">      11 |</p><p class="source-code">      12 | export const click = (element) =&gt;</p><p class="source-code">      13 |   act(() =&gt; element.click());</p></li>
</ol>
<p class="callout-heading">Stack traces from test helper code</p>
<p class="callout">Jest’s stack trace points to a failure within our extensions code, not the test itself. If our code was in an npm module, Jest would have skipped those test lines from its output. Thankfully, the error message is helpful enough.</p>
<ol>
<li value="5">To fix this issue, we<a id="_idIndexMarker338"/> need to add an export that matches the import we wrote at the top of our test file. Add the following line to <strong class="source-inline">src/CustomerForm.js</strong>:<p class="source-code">export const CustomerForm = () =&gt; null;</p></li>
<li>Running some tests gives the actual expectation failure:<p class="source-code">● CustomerForm › renders a form</p><p class="source-code">  expect(received).not.toBeNull()</p><p class="source-code">  Received: null</p></li>
</ol>
<p>This can be fixed by making the component return something:</p>
<p class="source-code"><strong class="bold">import React from "react";</strong></p>
<p class="source-code">export const CustomerForm = () =&gt; <strong class="bold">&lt;form /&gt;</strong>;</p>
<p>Before moving on, let’s pull out a helper for finding the <strong class="source-inline">form</strong> element. As in the previous chapter, this is arguably premature as we have only one test using this code right now. However, we’ll appreciate having the helper when we come to write our form submission tests later. </p>
<ol>
<li value="7">Open <strong class="source-inline">test/reactTestExtensions.js</strong> and add the following function:<p class="source-code">export const form = (id) =&gt; element("form");</p></li>
<li>Modify your test file by adding the following <strong class="source-inline">import</strong>. You can leave the <strong class="source-inline">element</strong> <a id="_idIndexMarker339"/>import in place because we’ll use it later in the next section:<p class="source-code">import {</p><p class="source-code">  initializeReactContainer,</p><p class="source-code">  render,</p><p class="source-code">  element,</p><p class="source-code">  <strong class="bold">form</strong>,</p><p class="source-code">} from "./reactTestExtensions";</p></li>
<li>Finally, update your test to use the helper, as shown here. After this, your test should still be passing:<p class="source-code">it("renders a form", () =&gt; {</p><p class="source-code">  render(&lt;CustomerForm /&gt;);</p><p class="source-code">  expect(form()).not.toBeNull();</p><p class="source-code">});</p></li>
</ol>
<p>That’s all there is to creating the basic <strong class="source-inline">form</strong> element. With that wrapper in place, we’re now ready to add our first field element: a text box.</p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor066"/>Accepting text input</h1>
<p>In this section, we’ll <a id="_idIndexMarker340"/>add a text box to allow the customer’s first name to be added or edited.</p>
<p>Adding a text field is more complicated than adding the <strong class="source-inline">form</strong> element. First, there’s the element itself, which has a <strong class="source-inline">type</strong> attribute that needs to be tested. Then, we need to prime the element with the initial value. Finally, we’ll need to add a label so that it’s obvious what the field represents.</p>
<p>Let’s start by rendering<a id="_idIndexMarker341"/> an HTML text input field onto the page:</p>
<ol>
<li value="1">Add the following test to <strong class="source-inline">test/CustomerForm.test.js</strong>. It contains three expectations (there’s an exercise at the end of this chapter that you can follow to pull these out as a single matcher):<p class="source-code">it("renders the first name field as a text box", () =&gt; {</p><p class="source-code">  render(&lt;CustomerForm /&gt;);</p><p class="source-code">  const field = form().elements.firstName;</p><p class="source-code">  expect(field).not.toBeNull();</p><p class="source-code">  expect(field.tagName).toEqual("INPUT");</p><p class="source-code">  expect(field.type).toEqual("text");</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Relying on the DOM’s Form API</p>
<p class="callout">This test makes <a id="_idIndexMarker342"/>use of the Form API: any form element allows <a id="_idIndexMarker343"/>you to access all of its input elements using the <strong class="source-inline">elements</strong> indexer. You give it the element’s <strong class="source-inline">name</strong> attribute (in this case, <strong class="source-inline">firstName</strong>) and that<a id="_idIndexMarker344"/> element is returned.</p>
<p class="callout">This means we must check the returned element’s tag. We want to make sure it is an <strong class="source-inline">&lt;input&gt;</strong> element. If we hadn’t used the Form API, one alternative would have been to use <strong class="source-inline">elements("input")[0]</strong>, which<a id="_idIndexMarker345"/> returns the<a id="_idIndexMarker346"/> first input <a id="_idIndexMarker347"/>element on the page. This would make the expectation on the element’s <strong class="source-inline">tagName</strong> property unnecessary.</p>
<ol>
<li value="2">Let’s move a bit faster. We’ll make all the expectations pass at once. Update <strong class="source-inline">CustomerForm</strong> so that it includes a single input field, as shown here:<p class="source-code">export const CustomerForm = () =&gt; (</p><p class="source-code">  &lt;form</p><p class="source-code"> <strong class="bold">   &lt;input type="text" name="firstName" /&gt;</strong></p><p class="source-code">  &lt;/form&gt;</p><p class="source-code">);</p></li>
<li>Since this form will be used when modifying existing customers as well as adding new <a id="_idIndexMarker348"/>ones, we need to design a way to get the existing customer data into the component. We’ll do that by setting an <strong class="source-inline">original</strong> prop that contains the form data. Add the following test:<p class="source-code">it("includes the existing value for the first name", () =&gt; {</p><p class="source-code">  const customer = { firstName: "Ashley" };</p><p class="source-code">  render(&lt;CustomerForm original={customer} /&gt;);</p><p class="source-code">  const field = form().elements.firstName;</p><p class="source-code">  expect(field.value).toEqual("Ashley");</p><p class="source-code">});</p></li>
<li>To make this test pass, change the component definition to the following. We will use a prop to pass in the previous <strong class="source-inline">firstName</strong> value:<p class="source-code">export const CustomerForm = (<strong class="bold">{ original }</strong>) =&gt; (</p><p class="source-code">  &lt;form</p><p class="source-code">    &lt;input</p><p class="source-code">      type="text"</p><p class="source-code">      name="firstName"</p><p class="source-code"><strong class="bold">      value={original.firstName} </strong>/&gt;</p><p class="source-code">  &lt;/form&gt;</p><p class="source-code">);</p></li>
<li>Upon running the tests again, you’ll see that although this test now passes, the first two tests fail because they don’t specify the <strong class="source-inline">original</strong> prop. What’s more, we have a warning:<p class="source-code">Warning: You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.</p></li>
<li>To fix the initial<a id="_idIndexMarker349"/> tests, create a new constant, <strong class="source-inline">blankCustomer</strong>, that will act as our “base” customer. It’ll do just fine for tests that don’t care about specific field values, such as our first two tests. Add this definition just above the <strong class="source-inline">beforeEach</strong> block:<p class="source-code">const blankCustomer = {</p><p class="source-code">  firstName: "",</p><p class="source-code">};</p></li>
</ol>
<p class="callout-heading">What about specifying an empty object for the original prop?</p>
<p class="callout">In this object definition, we set the <strong class="source-inline">firstName</strong> value to an empty string. You may think that either <strong class="source-inline">undefined</strong> or <strong class="source-inline">null</strong> would be good candidates for the value. That way, we could sidestep having to define an object like this and just pass an empty object, <strong class="source-inline">{}</strong>. Unfortunately, React will<a id="_idIndexMarker350"/> warn you when you attempt to set a controlled component’s initial value to <strong class="source-inline">undefined</strong>, which we want to avoid. It’s no big deal, and besides that, an empty string is a more realistic default for a text box. </p>
<ol>
<li value="7">Update the first two tests so that they render with the <strong class="source-inline">original</strong> prop set, as shown here. With this change in place, you should have three passing tests, but the warning remains:<p class="source-code">it("renders a form", () =&gt; {</p><p class="source-code">  render(&lt;CustomerForm <strong class="bold">original={blankCustomer}</strong> /&gt;);</p><p class="source-code">  expect(form()).not.toBeNull();</p><p class="source-code">});</p><p class="source-code">it("renders the first name field as a text box", () =&gt; {</p><p class="source-code">  render(&lt;CustomerForm <strong class="bold">original={blankCustomer}</strong> /&gt;);</p><p class="source-code">  const field = form().elements.firstName;</p><p class="source-code">  expect(field).not.toBeNull();</p><p class="source-code">  expect(field.tagName).toEqual("INPUT");</p><p class="source-code">  expect(field.type).toEqual("text");</p><p class="source-code">});</p></li>
<li>To get rid of the <a id="_idIndexMarker351"/>warning, add the word <strong class="source-inline">readOnly</strong> to the<a id="_idIndexMarker352"/> input tag. You might be thinking: surely, we don’t want a read-only field? You’re right, but we need a further test, for modifying the input value, before we can avoid using the <strong class="source-inline">readOnly</strong> keyword. We’ll add that test a little further on:<p class="source-code">&lt;input</p><p class="source-code">  type="text"</p><p class="source-code">  name="firstName"</p><p class="source-code">  value={original.firstName}</p><p class="source-code"><strong class="bold">  readOnly</strong></p><p class="source-code">/&gt;</p></li>
</ol>
<p class="callout-heading">Tip</p>
<p class="callout">Always consider React warnings to be a test failure. Don’t proceed without first fixing any warnings.</p>
<ol>
<li value="9">The last two tests include the following line, which reaches inside the form to pull out the <strong class="source-inline">firstName</strong> field:<p class="source-code">const field = form().elements.firstName;</p></li>
</ol>
<p>Let’s promote this to be a function in <strong class="source-inline">test/reactTestExtensions.js</strong>. Open that file and add the following definition after the definition for <strong class="source-inline">form</strong>:</p>
<p class="source-code">export const field = (fieldName) =&gt;</p>
<p class="source-code">  form().elements[fieldName];</p>
<ol>
<li value="10">Then, import<a id="_idIndexMarker353"/> it into <strong class="source-inline">test/CustomerForm.js</strong>:<p class="source-code">import {</p><p class="source-code">  initializeReactContainer,</p><p class="source-code">  render,</p><p class="source-code">  element,</p><p class="source-code">  form,</p><p class="source-code"><strong class="bold">  field,</strong></p><p class="source-code">} from "./reactTestExtensions";</p></li>
<li>Change the last test you wrote so that it uses the new helper:<p class="source-code">it("includes the existing value for the first name", () =&gt; {</p><p class="source-code">  const customer = { firstName: "Ashley" };</p><p class="source-code">  render(&lt;CustomerForm original={customer} /&gt;);</p><p class="source-code">  expect(<strong class="bold">field("firstName")</strong>.value).toEqual("Ashley");</p><p class="source-code">});</p></li>
<li>Update the first test in the same way:<p class="source-code">it("renders the first name field as a text box", () =&gt; {</p><p class="source-code">  render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code">  expect(<strong class="bold">field("firstName")</strong>).not.toBeNull();</p><p class="source-code">  expect(<strong class="bold">field("firstName")</strong>).toEqual("INPUT");</p><p class="source-code">  expect(<strong class="bold">field("firstName")</strong>).toEqual("text");</p><p class="source-code">});</p></li>
<li>Next up, we’ll add a<a id="_idIndexMarker354"/> label to<a id="_idIndexMarker355"/> the field. Add the following test, which uses the <strong class="source-inline">element</strong> helper:<p class="source-code">it("renders a label for the first name field", () =&gt; {</p><p class="source-code">  render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code">  const label = element("label[for=firstName]");</p><p class="source-code">  expect(label).not.toBeNull();</p><p class="source-code">});</p></li>
<li>Make this pass by inserting the new element into your JSX for <strong class="source-inline">CustomerForm</strong>:<p class="source-code">&lt;form</p><p class="source-code">  <strong class="bold">&lt;label htmlFor="firstName" /&gt;</strong></p><p class="source-code">  ...</p><p class="source-code">&lt;/form&gt;</p></li>
</ol>
<p class="callout-heading">The htmlFor attribute</p>
<p class="callout">The JSX <strong class="source-inline">htmlFor</strong> attribute <a id="_idIndexMarker356"/>sets the HTML <strong class="source-inline">for</strong> attribute. <strong class="source-inline">for</strong> couldn’t be used in JSX because it is a reserved JavaScript keyword. The attribute is used to signify that the label matches a form element with the given ID – in this case, <strong class="source-inline">firstName</strong>.</p>
<ol>
<li value="15">Let’s add <a id="_idIndexMarker357"/>some text content to that label:<p class="source-code">it("renders 'First name' as the first name label content", () =&gt; {</p><p class="source-code">  render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code">  const label = element("label[for=firstName]");</p><p class="source-code">  expect(label).toContainText("First name");</p><p class="source-code">});</p></li>
<li>Update the<a id="_idIndexMarker358"/> <strong class="source-inline">label</strong> element to make the test pass:<p class="source-code">&lt;form</p><p class="source-code">  <strong class="bold">&lt;label htmlFor="firstName"&gt;First name&lt;/label&gt;</strong></p><p class="source-code">  ...</p><p class="source-code">&lt;/form&gt;</p></li>
<li>Finally, we need to ensure that our input has an ID that matches it with the label’s <strong class="source-inline">htmlFor</strong> value so that they match up. Add the following test:<p class="source-code">it("assigns an id that matches the label id to the first name field", () =&gt; {</p><p class="source-code">  render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code">  expect(field("firstName").id).toEqual("firstName");</p><p class="source-code">});</p></li>
<li>Making that pass is as simple as adding the new attribute:<p class="source-code">&lt;form&gt;</p><p class="source-code">  &lt;label htmlFor="firstName"&gt;First name&lt;/label&gt;</p><p class="source-code">  &lt;input</p><p class="source-code">    type="text"</p><p class="source-code">    name="firstName"</p><p class="source-code"><strong class="bold">    id="firstName"</strong></p><p class="source-code">    value={firstName}</p><p class="source-code">    readOnly</p><p class="source-code">  /&gt;</p><p class="source-code">&lt;/form&gt;</p></li>
</ol>
<p>We’ve now created <em class="italic">almost</em> everything we need for this field: the input field itself, its initial value, and its label. But we don’t have any behavior for handling changes to the value – that’s why we<a id="_idIndexMarker359"/> have the <strong class="source-inline">readOnly</strong> flag.</p>
<p>Change behavior only makes sense in the context of submitting the form with updated data: if you can’t<a id="_idIndexMarker360"/> submit the form, there’s no point in changing the field value. That’s what we’ll cover in the next section.</p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor067"/>Submitting a form</h1>
<p>For this chapter, we <a id="_idIndexMarker361"/>will define “submit the form” to mean “call the <strong class="source-inline">onSubmit</strong> callback function with the current <strong class="source-inline">customer</strong> object.” The <strong class="source-inline">onSubmit</strong> callback function is a prop we’ll be passing.</p>
<p>This section will introduce one way of testing form submission. In <a href="B18423_06.xhtml#_idTextAnchor099"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring Test Doubles</em>, we will update this to a call to <strong class="source-inline">global.fetch</strong> that sends our customer data to our application’s backend API.</p>
<p>We’ll need a few different tests to specify this behavior, each test building up the functionality we need in a step-by-step fashion. First, we’ll have a test that ensures the form has a submit button. Then, we’ll write a test that clicks that button without making any changes to the form. We’ll need another test to check that submitting the form does not cause page navigation to occur. Finally, we’ll end with a test submission after the value of the text box has been updated.</p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor068"/>Submitting without any changes</h2>
<p>Let’s start by <a id="_idIndexMarker362"/>creating a button in the form. Clicking it will cause the form to submit:</p>
<ol>
<li value="1">Start by adding a test to check whether a submit button exists on the page:<p class="source-code">it("renders a submit button", () =&gt; {</p><p class="source-code">  render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code">  const button = element("input[type=submit]");</p><p class="source-code">  expect(button).not.toBeNull();</p><p class="source-code">});</p></li>
<li>To make that pass, add the following single line at the bottom of the form’s JSX:<p class="source-code">&lt;form&gt;</p><p class="source-code">  ...</p><p class="source-code">  <strong class="bold">&lt;input type="submit" value="Add" /&gt;</strong></p><p class="source-code">&lt;/form&gt;</p></li>
<li>The following test introduces a new concept, so we’ll break it down into its component parts. To start, create a new test, <strong class="source-inline">starting</strong>, as follows:<p class="source-code">it("saves existing first name when submitted", () =&gt; {</p><p class="source-code">  expect.hasAssertions();</p><p class="source-code">});</p></li>
</ol>
<p>The <strong class="source-inline">hasAssertions</strong> expectation<a id="_idIndexMarker363"/> tells Jest that it should expect at least one assertion to occur. It tells Jest that at least one assertion must run within the scope of the test; otherwise, the test has failed. You’ll see why this is important in the next step.</p>
<ol>
<li value="4">Add the following part of the test into the outline, below the <strong class="source-inline">hasAssertions</strong> call:<p class="source-code">const customer = { firstName: "Ashley" };</p><p class="source-code">render(</p><p class="source-code">  &lt;CustomerForm</p><p class="source-code">    original={customer}</p><p class="source-code">    onSubmit={({ firstName }) =&gt;</p><p class="source-code">      expect(firstName).toEqual("Ashley")</p><p class="source-code">    }</p><p class="source-code">  /&gt;</p><p class="source-code">);</p></li>
</ol>
<p>This function call is a mix of the<strong class="bold"> Arrange</strong> and<strong class="bold"> Assert </strong>phases in one. The<strong class="bold"> Arrange</strong> phase is the <strong class="source-inline">render</strong> call itself, and the<strong class="bold"> Assert </strong>phase is the <strong class="source-inline">onSubmit</strong> handler. This is the handler that we want React to call on form submission.</p>
<ol>
<li value="5">Finish off the test<a id="_idIndexMarker364"/> by adding the following line just below the call to <strong class="source-inline">render</strong>. This is the<strong class="bold"> Act </strong>phase of our test, which in this test is the last phase of the test:<p class="source-code">const button = element("input[type=submit]");</p><p class="source-code">click(button);</p></li>
</ol>
<p class="callout-heading">Using hasAssertions to avoid false positives</p>
<p class="callout">You can now see why we need <strong class="source-inline">hasAssertions</strong>. The test is written out of order, with the assertions defined within the <strong class="source-inline">onSubmit</strong> handler. If we did not use <strong class="source-inline">hasAssertions</strong>, this test would pass right now because we never call <strong class="source-inline">onSubmit</strong>.</p>
<p class="callout">I don’t recommend writing tests like this. In <a href="B18423_06.xhtml#_idTextAnchor099"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring Test Doubles</em>, we’ll discover <strong class="bold">test doubles</strong>, which allow us to restore the usual <em class="italic">Arrange-Act-Assert</em> order to help us avoid the need for <strong class="source-inline">hasAssertions</strong>. The method we’re using here is a perfectly valid TDD practice; it’s just a little messy, so you will want to refactor it eventually.</p>
<ol>
<li value="6">Now, you need to import <strong class="source-inline">click</strong>:<p class="source-code">import {</p><p class="source-code">  initializeReactContainer,</p><p class="source-code">  render,</p><p class="source-code">  element,</p><p class="source-code">  form,</p><p class="source-code">  field,</p><p class="source-code">  <strong class="bold">click</strong>,</p><p class="source-code">} from "./reactTestExtensions";</p></li>
<li>Making this test <a id="_idIndexMarker365"/>pass is straightforward, despite the complicated test setup. Change the component definition so that it reads as follows:<p class="source-code">export const CustomerForm = ({</p><p class="source-code">  original<strong class="bold">,</strong></p><p class="source-code"><strong class="bold">  onSubmit</strong></p><p class="source-code">}) =&gt; (</p><p class="source-code">  &lt;form <strong class="bold">onSubmit={() =&gt; onSubmit(original)}</strong>&gt;</p><p class="source-code">    ...</p><p class="source-code">  &lt;/form&gt;</p><p class="source-code">);</p></li>
<li>Now, run the test with <strong class="source-inline">npm test</strong>. You’ll discover that the test passed but we have a new warning, as shown here:<p class="source-code">console.error</p><p class="source-code">Error: Not implemented: HTMLFormElement.prototype.submit</p><p class="source-code">    at module.exports (.../node_modules/jsdom/lib/jsdom/browser/not-implemented.js:9:17)</p></li>
</ol>
<p>Something is not quite right. This warning is highlighting something very important that we need to take <a id="_idIndexMarker366"/>care of. Let’s stop here and look at it in detail.</p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor069"/>Preventing the default submit action</h2>
<p>This <strong class="source-inline">Not implemented</strong> console <a id="_idIndexMarker367"/>error is coming from the JSDOM package. HTML forms have a default action when submitted: they navigate to another page, which is specified by the <strong class="source-inline">form</strong> element’s <strong class="source-inline">action</strong> attribute. JSDOM does not implement page navigation, which is why we get a <strong class="source-inline">Not implemented</strong> error.</p>
<p>In a typical React application like the one we’re building, we don’t want the browser to navigate. We want to stay on the same page and allow React to update the page with the result of the submit operation.</p>
<p>The way to do that is<a id="_idIndexMarker368"/> to grab the <strong class="source-inline">event</strong> argument from the <strong class="source-inline">onSubmit</strong> prop and call <strong class="source-inline">preventDefault</strong> on it:</p>
<pre class="source-code">
event.preventDefault();</pre>
<p>Since that’s production code, we need a test that verifies this behavior. We can do this by checking the<a id="_idIndexMarker369"/> event’s <strong class="source-inline">defaultPrevented</strong> property:</p>
<pre class="source-code">
expect(event.defaultPrevented).toBe(true);</pre>
<p>So, now the question becomes, how do we get access to this <strong class="source-inline">Event</strong> in our tests?</p>
<p>We need to create the <strong class="source-inline">event</strong> object ourselves and dispatch it directly using the <strong class="source-inline">dispatchEvent</strong> DOM<a id="_idIndexMarker370"/> function on the form element. This event needs to be marked as <strong class="source-inline">cancelable</strong>, which will allow us to call <strong class="source-inline">preventDefault</strong> on it.</p>
<p class="callout-heading">Why clicking the submit button won’t work</p>
<p class="callout">In the last couple <a id="_idIndexMarker371"/>of tests, we purposely built a submit button that we could click to submit the form. While that will work for all our other tests, for this specific test, it does <em class="italic">not</em> work. That’s because JSDOM will take a <strong class="source-inline">click</strong> event and internally convert it into a <strong class="source-inline">submit</strong> event. There is no way we can get access to that <strong class="source-inline">submit</strong> event object if JSDOM creates it. Therefore, we need to directly fire the <strong class="source-inline">submit</strong> event. </p>
<p class="callout">This isn’t a problem. Remember that, in our test suite, we strive to act as a real browser would – by clicking a submit button to submit the form – but having one test work differently isn’t the end of the world.</p>
<p>Let’s put all of this together and fix the warning:</p>
<ol>
<li value="1">Open <strong class="source-inline">test/reactTestExtensions.js</strong> and add the following, just below <a id="_idIndexMarker372"/>the <strong class="source-inline">click</strong> definition. We’ll use this in the next test:<p class="source-code">export const submit = (formElement) =&gt; {</p><p class="source-code">  const event = new Event("submit", {</p><p class="source-code">    bubbles: true,</p><p class="source-code">    cancelable: true,</p><p class="source-code">  });</p><p class="source-code">  act(() =&gt; formElement.dispatchEvent(event));</p><p class="source-code">  return event;</p><p class="source-code">};</p></li>
</ol>
<p class="callout-heading">Why do we need the bubbles property?</p>
<p class="callout">If all of this wasn’t complicated enough, we also need to make sure the event <em class="italic">bubbles</em>; otherwise, it won’t make it to our event handler.</p>
<p class="callout">When JSDOM (or the browser) dispatches an event, it traverses the element hierarchy looking for an event handler to handle the event, starting from the element the event was dispatched on, working upwards via parent links to the root node. This is known as bubbling.</p>
<p class="callout">Why do we need to ensure this event bubbles? Because React has its <em class="italic">own</em> event handling system that is triggered by events<a id="_idIndexMarker373"/> reaching the React root element. The <strong class="source-inline">submit</strong> event must bubble up to our <strong class="source-inline">container</strong> element before React will process it.</p>
<ol>
<li value="2">Import the new helper into <strong class="source-inline">test/CustomerForm.test.js</strong>:<p class="source-code">import {</p><p class="source-code">  ...,</p><p class="source-code"><strong class="bold">  submit,</strong></p><p class="source-code">} from "./reactTestExtensions";</p></li>
<li>Add the following test to the bottom of the <strong class="source-inline">CustomerForm</strong> test suite. It specifies<a id="_idIndexMarker374"/> that <strong class="source-inline">preventDefault</strong> should <a id="_idIndexMarker375"/>be called when the form is submitted:<p class="source-code">it("prevents the default action when submitting the form", () =&gt; {</p><p class="source-code">  render(</p><p class="source-code">    &lt;CustomerForm</p><p class="source-code">      original={blankCustomer}</p><p class="source-code">      onSubmit={() =&gt; {}}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  const event = submit(form());</p><p class="source-code">  expect(event.defaultPrevented).toBe(true);</p><p class="source-code">});</p></li>
<li>To make that pass, first, update <strong class="source-inline">CustomerForm</strong> so that it has an explicit return:<p class="source-code">export const CustomerForm = ({</p><p class="source-code">  original,</p><p class="source-code">  onSubmit</p><p class="source-code">}) =&gt;<strong class="bold"> {</strong></p><p class="source-code"><strong class="bold">  return (</strong></p><p class="source-code">    &lt;form onSubmit={() =&gt; onSubmit(original)}&gt;</p><p class="source-code">      ...</p><p class="source-code">    &lt;/form&gt;</p><p class="source-code">  <strong class="bold">);</strong></p><p class="source-code"><strong class="bold">};</strong></p></li>
<li>Just above the return, add a new function, <strong class="source-inline">handleSubmit</strong>, and update the form so that it<a id="_idIndexMarker376"/> calls that instead:<p class="source-code">export const CustomerForm = ({</p><p class="source-code">  original,</p><p class="source-code">  onSubmit</p><p class="source-code">}) =&gt; {</p><p class="source-code"><strong class="bold">  const handleSubmit = (event) =&gt; {</strong></p><p class="source-code"><strong class="bold">    event.preventDefault();</strong></p><p class="source-code"><strong class="bold">    onSubmit(original);</strong></p><p class="source-code"><strong class="bold">  };</strong></p><p class="source-code">  return (</p><p class="source-code">    &lt;form onSubmit={<strong class="bold">handleSubmit</strong>}&gt;</p><p class="source-code">    &lt;/form&gt;</p><p class="source-code">  );</p><p class="source-code">};</p></li>
<li>Run your <a id="_idIndexMarker377"/>tests and ensure they are all passing.</li>
</ol>
<h2 id="_idParaDest-72"><a id="_idTextAnchor070"/>Submitting changed values</h2>
<p>It’s finally the<a id="_idIndexMarker378"/> time to introduce some state into our component. We will specify what should happen when the text field is used to update the customer’s first name.</p>
<p>The most complicated part of what we’re about to do is <a id="_idIndexMarker379"/>dispatching the DOM <strong class="source-inline">change</strong> event. In the browser, this event is dispatched after every keystroke, notifying the JavaScript application that the text field value content has changed. An event handler receiving this event can query the <strong class="source-inline">target</strong> element’s <strong class="source-inline">value</strong> property to find out what the current value is.</p>
<p>Crucially, we’re responsible for setting the <strong class="source-inline">value</strong> property before we dispatch the <strong class="source-inline">change</strong> event. We do that by calling the <strong class="source-inline">value</strong> property setter.</p>
<p>Somewhat unfortunately for us testers, React has change tracking behavior that is designed for the browser environment, not the Node test environment. In our tests, this change tracking logic suppresses change events like the ones our tests will dispatch. We need to circumvent this logic, which we can do with a helper function<a id="_idIndexMarker380"/> called <strong class="source-inline">originalValueProperty</strong>, as shown here:</p>
<pre class="source-code">
const originalValueProperty = (reactElement) =&gt; {
  const prototype =
    Object.getPrototypeOf(reactElement);
  return Object.getOwnPropertyDescriptor(
    prototype,
    "value"
  );
};</pre>
<p>As you’ll see in the next section, we’ll use this function to bypass React’s change tracking and trick it into processing our event, just like a browser would.</p>
<p class="callout-heading">Only simulating the final change </p>
<p class="callout">Rather than <a id="_idIndexMarker381"/>creating a <strong class="source-inline">change</strong> event for each keystroke, we’ll manufacture just the final instance. Since the event handler always has access to the full value of the element, it can ignore all intermediate events and process just the last one that is received.</p>
<p>Let’s begin with a little bit of refactoring:</p>
<ol>
<li value="1">We’re going to use the submit button to submit the form. We figured out how to access that button in a previous test:<p class="source-code">const button = element("input[type=submit]");</p></li>
</ol>
<p>Let’s move this definition into <strong class="source-inline">test/reactTestExtensions.js</strong> so that we can use it on our future tests. Open that file now and add this definition to the <a id="_idIndexMarker382"/>bottom:</p>
<p class="source-code">export const submitButton = () =&gt;</p>
<p class="source-code">  element("input[type=submit]");</p>
<ol>
<li value="2">Move<a id="_idIndexMarker383"/> back to <strong class="source-inline">test/CustomerForm.test.js</strong> and add the new helper to the imports:<p class="source-code">import {</p><p class="source-code">  ...,</p><p class="source-code"><strong class="bold">  submitButton,</strong></p><p class="source-code">} from "./reactTestExtensions";</p></li>
<li>Update the <strong class="source-inline">renders a submit button</strong> test so that it uses that new helper, as shown here:<p class="source-code">it("renders a submit button", () =&gt; {</p><p class="source-code">  render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code">  expect(<strong class="bold">submitButton()</strong>).not.toBeNull();</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">The helper extraction dance</p>
<p class="callout">Why are we doing this dance of writing a variable in a test (such as <strong class="source-inline">const button = ...</strong>) only to then extract <a id="_idIndexMarker384"/>it as a function moments later, as we just did with <strong class="source-inline">submitButton</strong>?</p>
<p class="callout">Following this approach is a systematic way of building a library of helper functions, meaning you don’t have to think too heavily about the “right” design. First, start with a variable. If it turns out that you’ll use that variable a second or third time, then extract it into a function. No big deal.</p>
<ol>
<li value="4">It’s time to write the next test. This is very similar to the last test, except now, we need to<a id="_idIndexMarker385"/> make use of a new <strong class="source-inline">change</strong> helper function. We’ll define this in the next step:<p class="source-code">it("saves new first name when submitted", () =&gt; {</p><p class="source-code">  expect.hasAssertions();</p><p class="source-code">  render(</p><p class="source-code">    &lt;CustomerForm</p><p class="source-code">      original={blankCustomer}</p><p class="source-code">      onSubmit={({ firstName }) =&gt;</p><p class="source-code">        expect(firstName).toEqual("Jamie")</p><p class="source-code">      }</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  change(field("firstName"), "Jamie");</p><p class="source-code">  click(submitButton());</p><p class="source-code">});</p></li>
<li>This function uses the new <strong class="source-inline">change</strong> helper that was discussed at the beginning of this section. Add the<a id="_idIndexMarker386"/> following definitions<a id="_idIndexMarker387"/> to <strong class="source-inline">test/reactTestExtensions.js</strong>:<p class="source-code">const originalValueProperty = (reactElement) =&gt; {</p><p class="source-code">  const prototype = </p><p class="source-code">    Object.getPrototypeOf(reactElement);</p><p class="source-code">  return Object.getOwnPropertyDescriptor(</p><p class="source-code">    prototype,</p><p class="source-code">    "value"</p><p class="source-code">  );</p><p class="source-code">};</p><p class="source-code">export const change = (target, value) =&gt; {</p><p class="source-code">  originalValueProperty(target).set.call(</p><p class="source-code">    target,</p><p class="source-code">    value</p><p class="source-code">  );</p><p class="source-code">  const event = new Event("change", {</p><p class="source-code">    target,</p><p class="source-code">    bubbles: true,</p><p class="source-code">  });</p><p class="source-code">  act(() =&gt; target.dispatchEvent(event));</p><p class="source-code">};</p></li>
</ol>
<p class="callout-heading">Figuring out interactions between React and JSDOM</p>
<p class="callout">The implementation of<a id="_idIndexMarker388"/> the <strong class="source-inline">change</strong> function shown here is not obvious. As we saw earlier with the <strong class="source-inline">bubbles</strong> property, React does some pretty clever stuff on top<a id="_idIndexMarker389"/> of the DOM’s usual event system.</p>
<p class="callout">It helps to have a high-level awareness of how React works. I also find it helpful to use the Node debugger to step through JSDOM and React source code to figure out where the flow is breaking.</p>
<ol>
<li value="6">To make this pass, move to <strong class="source-inline">src/CustomerForm.js</strong> and import <strong class="source-inline">useState</strong> into the module by modifying the existing React import:<p class="source-code">import React<strong class="bold">, { useState }</strong> from "react";</p></li>
<li>Change the customer constant definition to be assigned via a call to <strong class="source-inline">useState</strong>. The default state is the original value of <strong class="source-inline">customer</strong>:<p class="source-code">const <strong class="bold">[</strong> customer<strong class="bold">, setCustomer ] = useState(original)</strong>;</p></li>
<li>Create a new arrow function that will act as our event handler. You can put this just after<a id="_idIndexMarker390"/> the <strong class="source-inline">useState</strong> line that you added in the previous step:<p class="source-code">const handleChangeFirstName = ({ target }) =&gt;</p><p class="source-code">  setCustomer((customer) =&gt; ({</p><p class="source-code">    ...customer,</p><p class="source-code">    firstName: target.value</p><p class="source-code">  }));</p></li>
<li>In the returned JSX, modify the <strong class="source-inline">input</strong> element, as shown here. We are replacing the <strong class="source-inline">readOnly</strong> property with an <strong class="source-inline">onChange</strong> property and hooking it up to the handler we<a id="_idIndexMarker391"/> just created. Now, the <strong class="source-inline">value</strong> property also needs to be updated so that it can use React’s component state rather than the component prop:<p class="source-code">&lt;input</p><p class="source-code">  type="text"</p><p class="source-code">  name="firstName"</p><p class="source-code">  id="firstName"</p><p class="source-code">  value={<strong class="bold">customer.</strong>firstName}</p><p class="source-code"><strong class="bold">  onChange={handleChangeFirstName}</strong></p><p class="source-code">/&gt;</p></li>
<li>Go ahead and run the test; it should now be passing.</li>
</ol>
<p>With that, you’ve learned how to<a id="_idIndexMarker392"/> test-drive the <strong class="source-inline">change</strong> DOM event, and how to hook it up with React’s<a id="_idIndexMarker393"/> component state to save the user’s input. Next, it’s time to repeat the process for two more text boxes.</p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor071"/>Duplicating tests for multiple form fields</h1>
<p>So far, we’ve <a id="_idIndexMarker394"/>written a set of tests that fully define the <strong class="source-inline">firstName</strong> text field. Now, we want to add two more fields, which are essentially the same as the <strong class="source-inline">firstName</strong> field but with different <strong class="source-inline">id</strong> values and labels.</p>
<p>Before you reach for copy and paste, stop and think about the duplication you could be about to add to both your tests and your production code. We have six tests that define the first name. This means we would end up with 18 tests to define three fields. That’s a lot of tests without any kind of grouping or abstraction.</p>
<p>So, let’s do both – that is, group our tests and abstract out a function that generates our tests for us.</p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor072"/>Nesting describe blocks</h2>
<p>We can<a id="_idIndexMarker395"/> nest <strong class="source-inline">describe</strong> blocks to break similar tests up into logical contexts. We can invent a convention for how to name these <strong class="source-inline">describe</strong> blocks. Whereas the top level is named after the form itself, the second-level <strong class="source-inline">describe</strong> blocks are named after the form fields.</p>
<p>Here’s how we’d like them to end up:</p>
<pre class="source-code">
describe("CustomerForm", () =&gt; {
  describe("first name field", () =&gt; {
    // ... tests ...
  };
  describe("last name field", () =&gt; {
    // ... tests ...
  };
  describe("phone number field", () =&gt; {
    // ... tests ...
  };
});</pre>
<p>With this structure in place, you can simplify the <strong class="source-inline">it</strong> descriptive text by removing the name of the field. For example, <strong class="source-inline">"renders the first name field as a text box"</strong> becomes <strong class="source-inline">"renders as a text box"</strong> because it has already been scoped by the <strong class="source-inline">"first name field"</strong> <strong class="source-inline">describe</strong> block. Because of the way Jest displays <strong class="source-inline">describe</strong> block names before test names in the test output, each of these still reads like a plain-English sentence, but without the verbiage. In the example just given, Jest will<a id="_idIndexMarker396"/> show us <strong class="source-inline">CustomerForm first name field renders as a text box</strong>.</p>
<p>Let’s do that now for the first name field. Wrap the six existing tests in a <strong class="source-inline">describe</strong> block, and then rename the tests, as shown here:</p>
<pre class="source-code">
<strong class="bold">describe("first name field", () =&gt; {</strong>
  it("renders as a text box" ... );
  it("includes the existing value" ... );
  it("renders a label" ... );
  it("assigns an id that matches the label id" ... );
  it("saves existing value when submitted" ... );
  it("saves new value when submitted" ... );
<strong class="bold">});</strong></pre>
<p>Be careful not to include the <strong class="source-inline">preventsDefault</strong> test out of this, as it’s not field-specific. You may need to adjust the positioning of your tests in your test file.</p>
<p>That covers <a id="_idIndexMarker397"/>grouping the tests. Now, let’s look at using test generator functions to remove repetition.</p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor073"/>Generating parameterized tests</h2>
<p>Some <a id="_idIndexMarker398"/>programming<a id="_idIndexMarker399"/> languages, such as <a id="_idIndexMarker400"/>Java and C#, require special framework support to build parameterized tests. But in JavaScript, we can very easily roll our own parameterization because our test definitions are just function calls. We can use this to our advantage by pulling out each of the existing six tests as functions that take parameter values.</p>
<p>This kind of change requires some diligent refactoring. We’ll do the first two tests together, and then you can either repeat these steps for the remaining five tests or jump ahead to the next tag in the GitHub repository:</p>
<ol>
<li value="1">Starting with <strong class="source-inline">renders as a text box</strong>, wrap the entirety of the <strong class="source-inline">it</strong> call in an arrow function, and then call that function straight after, as shown here:<p class="source-code"><strong class="bold">const itRendersAsATextBox = () =&gt;</strong></p><p class="source-code">  it("renders as a text box", () =&gt; {</p><p class="source-code">    render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code">    expect(field("firstName")).not.toBeNull();</p><p class="source-code">    expect(field("firstName").tagName).toEqual(</p><p class="source-code">      "INPUT"</p><p class="source-code">    );</p><p class="source-code">    expect(field("firstName").type).toEqual("text");</p><p class="source-code">  });</p><p class="source-code"><strong class="bold">itRendersAsATextBox();</strong></p></li>
<li>Verify that all your tests are passing.</li>
<li>Parameterize this function by promoting the <strong class="source-inline">firstName</strong> string to a function parameter. Then, you’ll<a id="_idIndexMarker401"/> need to pass in the <strong class="source-inline">firstName</strong> string into the function call itself, as shown here:<p class="source-code">const itRendersAsATextBox = (<strong class="bold">fieldName</strong>) =&gt;</p><p class="source-code">  it("renders as a text box", () =&gt; {</p><p class="source-code">    render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code">    expect(field(<strong class="bold">fieldName</strong>)).not.toBeNull();</p><p class="source-code">    expect(field(<strong class="bold">fieldName</strong>).tagName).toEqual("INPUT");</p><p class="source-code">    expect(field(<strong class="bold">fieldName</strong>).type).toEqual("text");</p><p class="source-code">  });</p><p class="source-code">itRendersAsATextBox(<strong class="bold">"firstName"</strong>);</p></li>
<li>Again, verify <a id="_idIndexMarker402"/>that your tests are passing.</li>
<li>Push the <strong class="source-inline">itRendersAsATextBox</strong> function up one level, into the parent <strong class="source-inline">describe</strong> scope. That will allow you to use it in subsequent <strong class="source-inline">describe</strong> blocks.</li>
<li>Use the same<a id="_idIndexMarker403"/> procedure for the next test, <strong class="source-inline">includes the existing value</strong>:<p class="source-code"><strong class="bold">const itIncludesTheExistingValue = (</strong></p><p class="source-code"><strong class="bold">  fieldName,</strong></p><p class="source-code"><strong class="bold">  existing</strong></p><p class="source-code"><strong class="bold">) =&gt;</strong></p><p class="source-code">  it("includes the existing value", () =&gt; {</p><p class="source-code"><strong class="bold">    const customer = { [fieldName]: existing };</strong></p><p class="source-code">    render(&lt;CustomerForm original={<strong class="bold">customer</strong>} /&gt;);</p><p class="source-code">    expect(field(<strong class="bold">fieldName</strong>).value).toEqual(existing);</p><p class="source-code">  });</p><p class="source-code"><strong class="bold">itIncludesTheExistingValue("firstName", "Ashley");</strong></p></li>
<li>Verify your tests are passing and then push <strong class="source-inline">itIncludesTheExistingValue</strong> up one level, into the parent <strong class="source-inline">describe</strong> scope.</li>
<li>Repeat this <a id="_idIndexMarker404"/>process for the label tests, which<a id="_idIndexMarker405"/> can be included in one function. The second test can use a parameter within its test definition, as shown here:<p class="source-code">const itRendersALabel = (fieldName, text) =&gt; {</p><p class="source-code">  it("renders a label for the text box", () =&gt; {</p><p class="source-code">    render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code">    const label = element(`label[for=${fieldName}]`);</p><p class="source-code">    expect(label).not.toBeNull();</p><p class="source-code">  });</p><p class="source-code">  it(`renders '${text}' as the label content`, () =&gt; {</p><p class="source-code">    render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code">    const label = element(`label[for=${fieldName}]`);</p><p class="source-code">    expect(label).toContainText(text);</p><p class="source-code">  });</p><p class="source-code">};</p></li>
<li>Repeat the <a id="_idIndexMarker406"/>same process for the three remaining tests:<p class="source-code">const itAssignsAnIdThatMatchesTheLabelId = (</p><p class="source-code">  fieldName</p><p class="source-code">) =&gt; </p><p class="source-code">   ...</p><p class="source-code">const itSubmitsExistingValue = (fieldName, value) =&gt;</p><p class="source-code">   ...</p><p class="source-code">const itSubmitsNewValue = (fieldName, value) =&gt;</p><p class="source-code">   ...</p></li>
</ol>
<p class="callout-heading">Important note</p>
<p class="callout">Check the completed solution for the full listing. This can be found in the <strong class="source-inline">Chapter04/Complete</strong> directory.</p>
<ol>
<li value="10"> With<a id="_idIndexMarker407"/> all that done, your <strong class="source-inline">describe</strong> block will succinctly describe what the first name field does:<p class="source-code">describe("first name field", () =&gt; {</p><p class="source-code">  itRendersAsATextBox("firstName");</p><p class="source-code">  itIncludesTheExistingValue("firstName", "Ashley");</p><p class="source-code">  itRendersALabel("firstName", "First name");</p><p class="source-code">  itAssignsAnIdThatMatchesTheLabelId("firstName");</p><p class="source-code">  itSubmitsExistingValue("firstName", "Ashley");</p><p class="source-code">  itSubmitsNewValue("firstName", "Jamie");</p><p class="source-code">});</p></li>
</ol>
<p>Take a step back and look at the new form of the <strong class="source-inline">describe</strong> block. It is now very quick to understand <a id="_idIndexMarker408"/>the specification for<a id="_idIndexMarker409"/> how this field should work. </p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor074"/>Solving a batch of tests</h2>
<p>Now, we want to <a id="_idIndexMarker410"/>duplicate those six tests for the last name field. But how do we approach this? We do this test by test, just as we did with the first name field. However, this time, we should go much faster as our tests are one-liners, and the production code is a copy and paste job.</p>
<p>So, for example, the first test will be this:</p>
<pre class="source-code">
describe("last name field", () =&gt; {
  itRendersAsATextBox("lastName");
});</pre>
<p>You’ll need to update <strong class="source-inline">blankCustomer</strong> so that it includes the new field:</p>
<pre class="source-code">
const blankCustomer = {
  firstName: "",
  <strong class="bold">lastName: "",</strong>
};</pre>
<p>That test can be made to pass by adding the following line to our JSX, just below the <strong class="source-inline">firstName</strong> input field:</p>
<pre class="source-code">
&lt;input type="text" name="lastName" /&gt;</pre>
<p>This is just the start for the input field; you’ll need to complete it as you add the next few tests.</p>
<p>Go ahead and add the remaining five tests, along with their implementation. Then, repeat this process for the phone number field. When adding the submit tests for the phone number, make sure that you provide a string value made up of numbers, such as <strong class="source-inline">"012345"</strong>. Later in this book, we’ll add validations to this field that will fail if you don’t use the right values now.</p>
<p class="callout-heading">Jumping ahead</p>
<p class="callout">You might be tempted to try to solve all 12 new tests at once. If you’re feeling confident, go for it!</p>
<p>If you want to see a listing of all the tests in a file, you must invoke Jest with a single file. Run the <strong class="source-inline">npm test test/CustomerForm.test.js</strong> command to see what that looks like. Alternatively, you can run <strong class="source-inline">npx jest --verbose</strong> to run all the tests with full test <a id="_idIndexMarker411"/>listings:</p>
<pre class="source-code">
PASS test/CustomerForm.test.js
  CustomerForm
    ✓ renders a form (28ms)
    first name field
      ✓ renders as a text box (4ms)
      ✓ includes the existing value (3ms)
      ✓ renders a label (2ms)
      ✓ saves existing value when submitted (4ms)
      ✓ saves new value when submitted (5ms)
    last name field
      ✓ renders as a text box (3ms)
      ✓ includes the existing value (2ms)
      ✓ renders a label (6ms)
      ✓ saves existing value when submitted (2ms)
      ✓ saves new value when submitted (3ms)
    phone number field
      ✓ renders as a text box (2ms)
      ✓ includes the existing value (2ms)
      ✓ renders a label (2ms)
      ✓ saves existing value when submitted (3ms)
      ✓ saves new value when submitted (2ms)</pre>
<h2 id="_idParaDest-77"><a id="_idTextAnchor075"/>Modifying handleChange so that it works with multiple fields</h2>
<p>Time for a<a id="_idIndexMarker412"/> small refactor. After adding all three fields, you will have ended up with three very similar <strong class="source-inline">onChange</strong> event handlers:</p>
<pre class="source-code">
const handleChangeFirstName = ({ target }) =&gt;
  setCustomer((customer) =&gt; ({
    ...customer,
    firstName: target.value
  }));
const handleChangeLastName = ({ target }) =&gt;
  setCustomer((customer) =&gt; ({
    ...customer,
    lastName: target.value
  }));
const handleChangePhoneNumber = ({ target }) =&gt;
  setCustomer((customer) =&gt; ({
    ...customer,
    phoneNumber: target.value
  }));</pre>
<p>You can simplify these down into one function by making use of the <strong class="source-inline">name</strong> property on <strong class="source-inline">target</strong>, which<a id="_idIndexMarker413"/> matches the field ID:</p>
<pre class="source-code">
const handleChange = ({ target }) =&gt;
  setCustomer(customer =&gt; ({
    ...customer,
<strong class="bold">   [target.name]</strong>: target.value
  }));</pre>
<h2 id="_idParaDest-78"><a id="_idTextAnchor076"/>Testing it out</h2>
<p>At this <a id="_idIndexMarker414"/>stage, your the <strong class="source-inline">AppointmentsDayView</strong> instance is complete. Now is a good time to try it out for real.</p>
<p>Update your entry point in <strong class="source-inline">src/index.js</strong> so that it renders a new <strong class="source-inline">CustomerForm</strong> instance, rather than <strong class="source-inline">AppointmentsDayView</strong>. By doing so, you should be ready to manually test:</p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<img alt="Figure 4.1 – The completed CustomerForm " height="306" src="image/Figure_4.01_B18423.jpg" width="685"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – The completed CustomerForm</p>
<p>With that, you have learned one way to quickly duplicate specifications across multiple form fields: since <strong class="source-inline">describe</strong> and <strong class="source-inline">it</strong> are plain old functions, you can treat them just like you would with any other function and build your own structure around them.</p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor077"/>Summary</h1>
<p>In this chapter, you learned how to create an HTML form with text boxes. You wrote tests for the <strong class="source-inline">form</strong> element, and for <strong class="source-inline">input</strong> elements of types <strong class="source-inline">text</strong> and <strong class="source-inline">submit</strong>.</p>
<p>Although the text box is about the most basic input element there is, we’ve taken this opportunity to dig much deeper into test-driven React. We’ve discovered the intricacies of raising <strong class="source-inline">submit</strong> and <strong class="source-inline">change</strong> events via JSDOM, such as ensuring that <strong class="source-inline">event.preventDefault()</strong> is called on the event to avoid a browser page transition.</p>
<p>We’ve also gone much further<a id="_idIndexMarker415"/> with Jest. We extracted common test logic into modules, used nested <strong class="source-inline">describe</strong> blocks, and built assertions using DOM’s Form API.</p>
<p>In the next chapter, we’ll test-drive a more complicated form example: a form with select boxes and radio buttons.</p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor078"/>Exercises</h1>
<p>The following are some exercises for you to try out:</p>
<ol>
<li value="1">Extract a <strong class="source-inline">labelFor</strong> helper into <strong class="source-inline">test/reactTestExtensions.js</strong>. It should be used like so:<p class="source-code">expect(labelFor(fieldName)).not.toBeNull();</p></li>
<li>Add a <strong class="source-inline">toBeInputFieldOfType</strong> matcher that replaces the three expectations in the <strong class="source-inline">itRendersAsATextBox</strong> function. It should be used like so:<p class="source-code">expect(field(fieldName)).toBeInputFieldOfType("text");</p></li>
</ol>
</div>
</div></body></html>