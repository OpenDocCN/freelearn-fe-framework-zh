- en: Putting Things to the Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing tests is crucial for the maintainability of your code. It's a known
    fact that having a good range of tests, covering most of your functionality, is
    as important as the functionality itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that comes to mind when thinking about tests is probably code
    quality assurance. You test the code that you write, so this is definitely ensuring
    the quality of your code. However, there are many other important aspects of writing
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resistance to unexpected changes**: Your tests define what your code is supposed
    to do. They test whether your code conforms to your specifications. This has several
    benefits, the most obvious of which is probably a resistance to unexpected changes
    in the future. If you modify the code in the future, you''ll be less likely to
    break your existing code, because your tests will validate whether the existing
    functionality still works as specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation**: Your tests define what your code should do. At the same
    time, they display the API calls that are required to use the concerned functionality.
    This is the perfect documentation for any developer. Whenever I want to understand
    how a library really works, the tests are the first thing I look at.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoiding unnecessary code**: The practice of writing tests forces you to
    limit your code to fulfill the requirements of your specification, and nothing
    more. Any code in your application that is not reached in your automated tests
    can be considered dead code. If you stick to a merciless refactoring approach,
    you''ll remove such unused code as soon as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we haven't considered testing in our book at all, and, given its importance,
    you may wonder why I am approaching this now, in the very last chapter of the
    book. In a real project, we'd definitely create tests much earlier, if not at
    first. However, I hope you understand that in this book, we postponed this rather
    important topic until the end for a reason. I really love testing, but, as we're
    mainly focused on the component architecture of Angular, placing this chapter
    at the end seemed more logical.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll look into how to perform proper unit testing on your
    components. We'll focus on unit testing; automated, end-to-end testing is beyond
    the scope of this book. We'll look into how to test user interaction with components,
    but not at the level it would be done in end-to-end testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will delve into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to the Jasmine testing framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing simple tests for components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Jasmine spies and observing component output properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about Angular testing utilities, such as `inject`, `async`, `TestBed`,
    `ComponentFixture`, `DebugElement`, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking existing services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating tests for our `Efforts` UI component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating tests for our `TaskListContainer` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to Jasmine and Karma
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jasmine is a very simple testing framework that comes with an API; it allows
    you to write **Behavior-Driven Development** (**BDD**) style tests. BDD is an
    agile software development process for defining specifications in a written format.
  prefs: []
  type: TYPE_NORMAL
- en: 'In BDD, we define that an agile user story consists of multiple scenarios.
    These scenarios closely relate to, or even replace, the acceptance criteria of
    a story. They define requirements on a higher level, and they are mostly written
    narratives. Each scenario consists of three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Given**: This part is used to describe the initial state of the scenario.
    The test code is where we perform all of the setup that is needed to execute the
    test scenario.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When**: This part reflects the changes that we perform on the system being
    tested. Usually, this part consists of some API calls and actions that reflect
    the behavior of a user of the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Then**: This part specifies what the system should look like after the given
    state and the changes applied in the *when* part. In our code, this is the part
    that is usually at the end of our test function, where we use assertion libraries
    to verify the state of the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Jasmine comes with an API that makes it very easy to write tests that are structured
    according to the BDD style. Let''s look at a very simple example of how we can
    use Jasmine to write a test for a shopping cart system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Jasmine provides us with a `describe` function, which allows us to group certain
    scenarios on the same subject. In this example, we used the `describe` function
    to register a new test suite for tests concerning buying items in a shop.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `it` function, we can register individual scenarios that we'd like
    to get tested. Within the `describe` callback function, we can register as many
    scenarios as we like. It's also possible to nest `describe` calls, in order to
    further group our scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the callback function of the Jasmine `it` function, we can start writing
    our test. We can use BDD style comments to structure the code inside our test.
  prefs: []
  type: TYPE_NORMAL
- en: 'You don''t necessarily need to run Jasmine in the browser, but if you do so,
    you''ll get a nice summary report of all of the tests and their states:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dabfdf5e-c33c-4165-8eb2-4f787146e654.png)'
  prefs: []
  type: TYPE_IMG
- en: Jasmine provides a nice visual report of all of your test specifications, which
    also allows you to rerun individual tests and provides you with more options
  prefs: []
  type: TYPE_NORMAL
- en: 'Jasmine comes with three parts that are relevant to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jasmine core**: This contains the test definition APIs, the assertion library,
    and all of the other core parts of the testing framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jasmine HTML**: This is the HTML reporter, which will write all test results
    to the browser document, and will even provide options to rerun individual tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jasmine boot**: This is the file that bootstraps the Jasmine framework for
    the browser and performs any setup that is needed with the HTML reporter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Karma and integration to Angular CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jasmine is the default test framework that ships with the Angular CLI tool.
    The CLI tool installs Jasmine, along with the popular test runner Karma, which
    allows you to run your tests in the browser of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: By using Karma, we don't need to take care of installing and configuring Jasmine
    within our project. Karma takes care of that, and it also provides a lot of extras.
  prefs: []
  type: TYPE_NORMAL
- en: 'A project generated with the Angular CLI comes with two files relevant for
    running tests with Karma and Jasmine:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/karma.conf.js`: This file contains the configuration for the Karma test runner.
    It''s already created for running Angular tests within the browser. By default,
    it''s configured to run tests within a real Chrome browser. However, you can change
    that to a headless version of Chrome, to a different browser, or even to PhantomJS,
    which is a really fast and lightweight headless browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/src/test.ts`: This file is the main entry file for running your tests. It''s
    automatically generated for you when you create a new project using the CLI. This
    file contains all of the necessary preparations to run Angular tests within your
    browser using Karma. It also uses dynamic imports, in order to discover any test
    files (filenames ending with `.spec.ts`) within your project, and passes them
    to Karma for execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Angular CLI comes with a set of predefined commands, in order to execute
    the tests within your project. It supports running all tests once, in order to
    verify your current state. However, sometimes, it's very useful to keep your tests
    running when working on your application. This supports you in test-driven development
    approaches, where you'll want to have a constant feedback loop from your tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start testing by running two different commands using the Angular CLI
    tool. Make sure that you''re within your project folder, and execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will start a single test run within your project. Since
    we have not added any tests yet, you should see an output similar to this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c84a848-64d0-440e-82f9-4d71f0358a2c.png)'
  prefs: []
  type: TYPE_IMG
- en: A single execution (single run) using the Angular CLI, with no tests present
  prefs: []
  type: TYPE_NORMAL
- en: A single run of your tests is nice when you're about to pull a new release,
    or if you want to verify the quality of a certain state of your code. Within this
    chapter, we're going to add a few tests to our existing components, and it will
    be nice to see our tests evaluated when we're performing our changes. For this
    purpose, we're starting Karma using its file watch functionality. By running the
    following Angular CLI command, you can start Karma in watch mode. This will keep
    your Terminal busy with testing, similar to the `serve` command within the Angular
    CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start the Angular CLI in test watch mode by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we're fully omitting the `watch` command-line parameter this
    time. By default, the Angular CLI will run Karma in watch mode when you execute
    the `test` command.
  prefs: []
  type: TYPE_NORMAL
- en: If you like to benefit from constant feedback when running your tests, you should
    always start two Terminal sessions, one executing the Angular CLI server (`ng
    serve`) and another one running Karma in watch mode (`ng test`).
  prefs: []
  type: TYPE_NORMAL
- en: Writing our first test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are all set with the testing setup, we can start writing our first
    test. In this section, we will create a first test for the efforts component that
    we created in [Chapter 8](43791ecf-9bd7-4439-ba76-8f34098d350a.xhtml), *Time Will
    Tell*.
  prefs: []
  type: TYPE_NORMAL
- en: As Angular components are just classes, we can already test a lot of their functionality
    by instantiating the component class and testing its methods. Tests that can be
    performed like this should always be considered first. Tests that don't involve
    the rendering logic of your components can run without Angular compiling and bootstrap
    the component.
  prefs: []
  type: TYPE_NORMAL
- en: The efforts component uses a method to add a certain amount of hours to the
    effective time worked on a task. Within the template of the efforts component,
    we're providing three buttons, to add some common amounts of hours. Let's create
    our first test for the method, `addEffectiveHours`, in our efforts component.
    For this test, we'd like to start simple and create the component class instance
    manually. This allows us to test its basic functionality without the need to start
    the Angular template compiler, change detection and other
  prefs: []
  type: TYPE_NORMAL
- en: When creating a new component with the Angular CLI, a corresponding `spect.ts`
    file, containing some basic tests, will be created for you. However, we've always
    created new components using the flag `--spec false`, which prevents this step.
    Let's create our first spec file manually, by creating a new file on the path
    `src/app/efforts/efforts/efforts.component.spec.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the created file and add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Karma loads our spec files, and it already loaded Jasmine prior to executing
    our test. We can therefore safely rely on the global `describe`, `it`, and `expect`
    functions that are exposed by Jasmine.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we don't really need to bootstrap Angular in order to test some
    of our components' functionality. Simply by testing the component class instance,
    we can already execute some of our specifications.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate how we structure our test in a BDD way, we've added some comments,
    indicating the "given", "when" and "then" sections.
  prefs: []
  type: TYPE_NORMAL
- en: Within the given section, we create a new efforts component instance. We then
    set the efforts input property of our component to a new efforts object, containing
    an estimated and effective duration of zero. In the when section, we call the
    method `addEffectiveHours`, with a parameter of 8 hours.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'd like to test whether our method call is performing as we expected.
    Our efforts component is a pure UI component that does not store any of its state.
    Instead, it delegates any state changes using output properties. In the context
    of our test, the `outEffortsChange` output is triggered after a call to the method
    `addEffectiveHours`.
  prefs: []
  type: TYPE_NORMAL
- en: Since event emitters present on component output properties are just observables,
    we can simply subscribe to the output in order to validate our test. We use the
    Jasmine helper function, `expect`, in order to assert whether the updated effective
    efforts property is what we expect it to be after our test.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you had the Angular CLI test command still running when writing this first
    test, you should now see a successful test execution on your Terminal output.
    Otherwise, just start the test runner again, using the command `ng test` on your
    Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f418e02a-dcdb-40a2-aa85-b1dd8348f413.png)'
  prefs: []
  type: TYPE_IMG
- en: Terminal and Angular CLI ng test command, showing our first test running successfully
  prefs: []
  type: TYPE_NORMAL
- en: Spying on component output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In testing, a common practice is to spy on function calls during the execution
    of tests, and then evaluate these calls, checking whether all functions were called
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine provides us with some nice helpers, in order to use `spy` function calls.
    We can use the `spyOn` function of Jasmine to replace the original function with
    a `spy` function. The `spy` function will record any calls, and we can evaluate
    how many times they were called, and with what parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a simple example of how to use the `spyOn` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We will test a simple calculator class that has two methods. The `multiply`
    method simply multiplies two numbers and returns the result. The `pythagorean`
    method calculates the hypotenuse of a right-angled triangle with two sides, `a`
    and `b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might remember the formula for the Pythagorean theorem from your early
    school days:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2d7af3c-2cd4-475b-8b49-1f3696cd3402.png)'
  prefs: []
  type: TYPE_IMG
- en: We will use this formula to produce `c` from `a` and `b`, by getting the square
    root of the result of `a*a + b*b`. For the multiplication, we'll use our `multiply`
    method, instead of using arithmetic operators directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we want to test our calculator `pythagorean` method, and, as it uses the
    `multiply` method to multiply `a` and `b`, we can spy on the method to verify
    our test result in depth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `spyOn` function of Jasmine takes an object as the first parameter and the
    function name of the object on which we'd like to spy as a second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: This will effectively replace the original `multiply` function in our class
    instance with a new `spy` function of Jasmine. By default, `spy` functions will
    only record function calls, and they won't delegate the call to the original function.
    We can use the `.and.callThrough()` function to specify that we'd like Jasmine
    to call the original function. This way, our spy function will act as a proxy,
    and will record any calls at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: In the then section of our test, we can inspect the `spy` function. Using the
    `toHaveBeenCalled` matcher, we can check whether the spy function was called after
    all.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `calls` property of the `spy` function, we can inspect in more detail
    and verify the call count, as well as the arguments that individual calls received.
  prefs: []
  type: TYPE_NORMAL
- en: We can apply the knowledge that we gained about Jasmine spies to our component
    tests. As we know that all output properties of components contain an event emitter,
    we can actually spy on them to check whether our component sends output.
  prefs: []
  type: TYPE_NORMAL
- en: Inside components, we call the `emit` method on event emitters, in order to
    send output to parent component bindings. As this is an asynchronous operation,
    and we'd also like to test our components without needing to involve parent components,
    we can simply spy on the `emit` method of our output properties.
  prefs: []
  type: TYPE_NORMAL
- en: It's generally a good practice to avoid asynchronous operations in unit tests,
    if possible. By using Jasmine spies, we can mock certain function calls that would
    result in asynchronous operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change our first test of the efforts component to use Jasmine spies,
    rather than relying on observable subscriptions. Open the file `src/app/efforts/efforts/efforts.component.spec.ts`,
    and perform the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We've created a Jasmine spy that spies on the `outEffortsChange` output property.
    More precisely, we're spying on any calls to the `emit` method of the underlying
    event emitter.
  prefs: []
  type: TYPE_NORMAL
- en: Since we're no longer relying on a callback registered with the `subscribe`
    method on our event emitter output, we now have a much cleaner testing code. The
    testing code is perfectly structured into the given, when, and then sections of
    our BDD style test, and no subscription with a callback function needs to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `toHaveBeenCalledWith` assertion helper in Jasmine allows us to carefully
    evaluate the `spy` function and check whether the recorded calls match what we
    expected them to be.
  prefs: []
  type: TYPE_NORMAL
- en: Utilities to test components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have tested our components with plain vanilla JavaScript. The fact
    that components are in regular classes makes this possible. However, this can
    only be done for very simple use cases. As soon as we want to test components
    for things that involve template compilation, user interaction on components,
    change detection, or dependency injection, we'll need to get a little help from
    Angular to perform our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Angular comes with a whole bunch of testing tools that can help us out here.
    In fact, the platform-agnostic way that Angular is built allows us to exchange
    the regular view adapter with a debug view adapter. This enables us to render
    components in such a way that we can inspect them in greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular CLI has already enabled this for us, and if you check the content
    of the file `src/test.ts`, you can see that there''s a special preparation step
    that enables our testing Angular platform. The following core excerpt shows the
    relevant content of our default test entry point, which was generated by the Angular
    CLI tool when we created our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using the `initTestEnvironment` function of the `@angular/core/testing` module,
    we can actually initialize a test platform injector, which will then be used in
    the context of our Angular testing.
  prefs: []
  type: TYPE_NORMAL
- en: From the `@angular/platform-browser-dynamic/testing` module, we can import a
    special testing platform factory function, as well as the Angular browser testing
    module.
  prefs: []
  type: TYPE_NORMAL
- en: This code helps us to set up a testing environment that relies on a special
    platform for testing within a browser. Additional debug information will be present
    in the runtime when we're using this platform.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting in tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Injecting Angular dependencies in tests is made easy by two helper functions.
    The `inject` and `async` functions are available through the `@angular/core/testing`
    package, and they help us inject dependencies into our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at this simple example, where we inject the `document` element
    using the `inject` wrapper function. This test is irrelevant for our application,
    but it illustrates how we can make use of injection in our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can simply use `inject` to wrap our test function. The `inject` function
    accepts an array as the first parameter, which should include a list of injectable
    types. The second parameter is our actual test function, which will now receive
    the injected document.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `async` function, on the other hand, helps us with a different concern.
    What if our tests actually involve asynchronous operations? Well, a standard asynchronous
    Jasmine test would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Jasmine provides us with a nice way to specify asynchronous tests. We can simply
    use the first parameter of our test functions, which resolves to a callback function
    and is called `done`, by convention. By calling this callback function, we can
    tell Jasmine that our asynchronous operations are done, and we would like to finish
    the test.
  prefs: []
  type: TYPE_NORMAL
- en: Using callbacks to indicate whether our asynchronous test is finished is a valid
    option. However, this can make our test quite complicated, if many asynchronous
    operations are involved. It's sometimes even impossible to monitor all of the
    asynchronous operations that are happening under the hood, which also makes it
    impossible for us to determine the end of our test.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the `async` helper function comes into play. Angular uses a library
    called Zone.js to monitor any asynchronous operations in the browser. Simply put,
    Zone.js hooks into any asynchronous operations and monitors when they are initiated,
    as well as when they are finished. With this information, Angular knows exactly
    how many pending asynchronous operations there are.
  prefs: []
  type: TYPE_NORMAL
- en: If we're using the `async` helper, we can tell Angular to automatically finish
    our test when all of the asynchronous operations in our test are done. The helper
    uses Zone.js to create a new zone, and also to determine whether all microtasks
    executed within this zone are finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we can combine injection with an asynchronous operation
    in our test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: By combining `inject` with `async` (wrapping), we can now test asynchronous
    operations in our test, without any hassle. The `async` helper will make our test
    wait until all asynchronous operations have completed. We don't need to rely on
    a callback, and we have the guarantee that even internal asynchronous operations
    will complete before our test finishes.
  prefs: []
  type: TYPE_NORMAL
- en: Zone.js is designed to work with all asynchronous operations in the browser.
    It patches all core DOM APIs, and makes sure that every operation goes through
    a zone. Angular also relies on Zone.js to initiate change detection. It waits
    for zones (any asynchronous operations within the browser) to terminate, in order
    to execute change detection. This is pretty smart, since the only possible moment
    for your application state to change is right after asynchronous operations are
    terminated.
  prefs: []
  type: TYPE_NORMAL
- en: Using TestBed for running Angular tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular comes with another very important testing utility. So far, we have
    only tested the component class of our components. However, as soon as we need
    to test components and their behaviors in our application, a few more things will
    be involved:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing the view of components**: It''s sometimes required that we test the
    rendered view of components. With all of the bindings in our view, dynamic instantiation
    using template directives and content projection, it can be hard to write deterministic
    tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing change detection**: As soon as we update our model in our component
    class, we will want to test the updates that are performed via change detection.
    This involves the whole change detection behavior of our components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User interaction**: Our component templates probably contain a set of event
    bindings, which trigger some behaviors in user interaction. We''ll need a way
    to test the state after user interactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overriding and mocking**: In a testing scenario, it''s sometimes required
    to mock certain areas in our components, in order to create a proper isolation
    for our test. In unit testing, we should only be concerned with the specific behavior
    that we want to test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TestBed` class, which is available through the `@angular/core/testing`
    package, helps us with the previously listed concerns. It's our main tool for
    testing components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a very simple example of how we can use the `TestBed` class
    to test the view rendering of a simple dummy component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `beforeEach` function is a Jasmine helper that allows us to execute something
    before each and every test within a given test suite. Within the `beforeEach`
    callback, we're using the `TestBed` class imported from `@angular/core/testing`,
    in order to prepare our testing environment.
  prefs: []
  type: TYPE_NORMAL
- en: The `configureTestingModule` method on the `Testbed` class allows us to configure
    a dynamic Angular module that defines the whole context for our test. The configuration
    object that we're passing to the method is exactly the same as the one that we
    pass to the `@NgModule` decorator factory, when defining Angular modules. It supports
    `import`, `providers`, `declarations`, and all other properties of Angular modules.
    This allows us to create a very specific and isolated testing environment, where
    we can test only the things we really need to.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that we're using the Angular `async` helper to wrap our `beforeEach`
    callback function. This is necessary, since the `compileComponents` method call
    is an asynchronous operation that compiles all components present within our dynamic
    testing module. This will ensure that when we enter our test methods, the compilation
    performed within the `beforeEach` callback is finished, and we can start our testing.
  prefs: []
  type: TYPE_NORMAL
- en: When testing components, you need to make sure that you're including all of
    the necessary dependencies within the dynamic module created by the `configureTestingModule`
    call. This includes any sub-components present within the component, under tests,
    pipes, services, and any other dependencies of your component.
  prefs: []
  type: TYPE_NORMAL
- en: Component fixture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our test, we use the `createComponent` method of the `Testbed` class to create
    a new component instance of our dummy component. As a result of that method call,
    we'll receive a component fixture object that will help us to further perform
    testing on our component.
  prefs: []
  type: TYPE_NORMAL
- en: The component fixture is a wrapper around our component being tested, which
    allows us to further inspect and manipulate our test case. We can now use the
    `nativeElement` property of the fixture to access the root DOM element of the
    created component, and to assert on the text content of that element, to verify
    whether the component has rendered correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `ComponentFixture` type, and the available properties and
    methods, in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Member | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `detectChanges()` | This executes change detection on the root component
    that was created in the context of the fixture. The template bindings will not
    automatically be evaluated after creating a component using the `Testbed` class.
    It''s our own responsibility to trigger change detection. Even after we change
    the state of our components, we need to trigger change detection again. This manual
    change detection may sound cumbersome, but it''s important to have full control
    of any operation performed during a test. We always want a test to be fully deterministic.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `destroy()` | This method destroys the underlying component and performs
    any cleanup that is required. This can be used to test the `OnDestroy` component''s
    life cycle. |'
  prefs: []
  type: TYPE_TB
- en: '| `componentInstance` | This property points to the component class instance,
    and it is our main interaction point if we want to interact with the component.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `nativeElement` | This is a reference to the native DOM element at the root
    of the created component. This property can be used to directly inspect the rendered
    DOM of our component. |'
  prefs: []
  type: TYPE_TB
- en: '| `elementRef` | This is the `ElementRef` wrapper around the root element of
    the created component. |'
  prefs: []
  type: TYPE_TB
- en: '| `debugElement` | This property points to an instance of `DebugElement` that
    was created in the component view rendering pipeline when using the testing browser
    platform. The debug element provides us with some nice utilities to inspect the
    rendered element tree and test user interaction. We''ll take a closer look at
    this later, in another section. |'
  prefs: []
  type: TYPE_TB
- en: Mocking child components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've now looked at a very simple dummy component, and how to test it using
    the Angular `TestBed`, in conjunction with the `inject` and `async` helper functions.
  prefs: []
  type: TYPE_NORMAL
- en: This is great, but it doesn't really reflect the complexity that we face when
    we need to test real components. Real components have a lot more dependencies
    than our dummy component. We rely on child directives, and probably injected services,
    to obtain data.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the Angular `TestBed` also provides us with the tools that we need
    to test more complex components, while keeping the necessary isolation in a unit
    test.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at an example, where we''d like to test a parent component
    that uses a child component to render a list of numbers. In this test, we''d only
    like to test the parent component, and we''re not interested in how the child
    component renders the list. We want to remove the behavior of the child component
    from our test by providing a mock component for the child component during the
    test, allowing us to easily verify that the data is received by the child component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is our starting point. We have two components, and we'll only be interested
    in testing the parent component. However, the child component is required by the
    parent component, and it implies a very specific way to render the numbers that
    are passed by the parent. We would only like to test whether our numbers were
    passed successfully to the child component. We don't want to involve the rendering
    logic of the child component in our test. This is very important, because changing
    only the child component could break our parent component test, which is what
    we want to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we want to create a mock of our child component, in the context of our
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In our mock child component, it's important that we use the same selector property
    as the real component. Otherwise, the mocking will not work. In the template,
    we use a very simple output of the numbers input, which enables an easy inspection.
    The `toString` method on an array will just render all elements, separated by
    commas.
  prefs: []
  type: TYPE_NORMAL
- en: It's also important that we provide the same input properties as the original
    component. Otherwise, we won't imitate the real component correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can go ahead and prepare for our test. By simply adding our mock child
    component to the declarations of our dynamic test module, we can make sure that
    our parent component uses our mock component, instead of the real child component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As a result, we decouple the parent component from the child component, in the
    context of our test. We need this level of separation in order to create a proper
    isolation of our unit test. As our mock child component simply renders the string
    representation of the passed array, we can easily test the text content of our
    fixture.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of a unit test is to test a single unit and isolate the unit
    from any dependencies. If we want to stick to this paradigm, we need to create
    a mock for every dependent component. This can easily get us into a situation
    where we need to maintain more complexity, for the sake of our tests. The key
    lies in finding the right balance. You should mock dependencies that have a great
    impact on the subject, and ignore dependencies that have a low impact on the functionality
    that you'd like to test.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at a different use case, where we have a component that injects a
    service in order to obtain data. As we only want to test our component, and not
    the service it relies on, we somehow need to sneak in a mock service instead of
    the real service. Since we can define our dynamic test module for our needs, we
    can simply use the `providers` property on our module definition to introduce
    mock services.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we should declare our base component and a service that it relies on.
    In this example, the numbers component injects a numbers service, where it obtains
    an array with numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to create a mock service that provides the data required in our
    test and isolates our component from the original service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this simplified example, we just provide a different set of numbers. However,
    in a real mocking case, we could exclude a lot of steps that are unnecessary and
    could potentially create side effects. Using a mock service also ensures that
    our test, which is focused on the numbers component, will not break because of
    a change in the real numbers service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the test case and see how we can use `TestBed` to provide
    our mock service, instead of the real one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Using the `providers` property in the dynamic test module definition, we can
    provide dependencies to the component under test. This allows us to substitute
    dependencies that are used in the component. We can simply create a provider that
    provides our substitute mock numbers service when the numbers service is requested
    within the dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we don''t have full control of our dependencies; for example, when
    we''re obtaining a predefined set of providers by an imported module. The `TestBed`
    helps us in such situations by providing additional override methods. Let''s look
    at the preceding example again; this time, we''re using an override mechanism
    to sneak in our mock service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Using the `overrideProvider` method allows us to override the previously specified
    real service with our mock service. This is an important tool when you're testing
    large applications that rely on imported Angular modules, which won't be under
    your full control.
  prefs: []
  type: TYPE_NORMAL
- en: The `Testbed` class of Angular allows us to perform tests in a very simple,
    isolated, and flexible fashion. It plays a major role when writing unit tests
    for components. If you'd like to read more about the available methods in the
    `Testbed` class, you can visit the official documentation website at [https://angular.io/api/core/testing/TestBed](https://angular.io/api/core/testing/TestBed).
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to use our new knowledge about the `Testbed` utility class and
    start to test our application components in action!
  prefs: []
  type: TYPE_NORMAL
- en: Testing components in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous topic, we learned about the `Testbed` utility class, and how
    to use it to test components in an isolated testing environment. We learned about
    the `inject` and `async` helpers, as well as how to mock components and services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s use this knowledge to work on our tests for the efforts component.
    If you take a look at the template of our efforts component, you''ll remember
    that we rely on two child components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Duration**: The two duration components within the template are used to enter
    both the duration values for estimated as well as effective efforts spent on tasks.
    It''s a good idea to mock out that component when you want to perform tests on
    the efforts component. The duration component itself relies on the rather complex
    editor component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efforts Timeline**: As it is a purely graphical component to represent our
    task efforts, we don''t really want it to participate in our test of the efforts
    component. However, since this component does not really interfere with our efforts
    behavior, we don''t necessarily need to mock it. Let''s use the real component
    in this specific instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alright; let's continue writing tests for our efforts component. So far, we've
    only tested the component class methods of our efforts component. We would now
    like to continue by mocking the duration component and using the Angular `TestBed`
    to create a new component instance.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have it running already, it would be a good time to start the test
    framework using the Angular CLI tool. Use the command `ng test` in your command
    line while inside of the project folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the test file, located on the path `src/app/efforts/efforts/efforts.component.spec.ts`,
    and perform the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Our newly introduced mock duration component might look a bit tenuous, but this
    is actually all that we need for our current tests of the efforts component. The
    duration component should just accept a `duration` input and expose an `ourDurationChange`
    output. This is the interface that is expected within the template of our efforts
    component. Since we don't want to rely on any of the duration component internals,
    including the use of the editor component, the template of our mock duration component
    simply renders the duration input. This way, we can easily verify whether the
    correct duration is rendered within our mock component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create our first test, using the component instance and fixture
    created with the `Testbed`. Apply the following changes to the effort test file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In our tests, we'd like to test whether the effort component initializes the
    duration child components (respectively, our mock duration component) with the
    right content.
  prefs: []
  type: TYPE_NORMAL
- en: Using the component fixture that is provided by the `Testbed` utility class,
    we can start to interact with the created component. Using the `componentInstance`
    member of the component fixture, we can set the required input properties of our
    efforts component.
  prefs: []
  type: TYPE_NORMAL
- en: As we're responsible for handling change detection in our tests manually, we
    use the `detectChanges` method on our fixture to update the component view. This
    will initiate the change detection life cycle on our component and perform the
    necessary view updates.
  prefs: []
  type: TYPE_NORMAL
- en: After the view updates of both duration components, we can run our assertions
    to validate the updated DOM by getting the text content of the `nativeElement`
    property on our fixture.
  prefs: []
  type: TYPE_NORMAL
- en: Using the text content property of our whole component fixture might be good,
    in some circumstances. However, sometimes, this does not provide the necessary
    granularity for a good assertion. In some scenarios, when we have more DOM elements
    involved, it won't be sufficient to directly assert on the root component's `textContent`
    property. It would probably include a lot of noise, which we're not interested
    in for our assertion. We should always try to narrow our assertion to the fewest
    details possible.
  prefs: []
  type: TYPE_NORMAL
- en: Within our newly created test, we need to assert with the string `Estimated:1Effective:2+1h+4h+1d`,
    in order to validate the correct rendering of our components. However, this also
    includes the labels of our add buttons, which is not exactly what we want to test
    here. Remember, we always want to narrow our test down to exactly one single unit
    and avoid any dependencies on things outside of our specific test case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to enhance our test and assert on more specific parts of our component
    view. As we have access to the native DOM element on our fixture, we can simply
    use the DOM API to select child elements, in order to narrow our assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This would successfully select the DOM element of our first mock duration component,
    and we can only check the text content inside the duration component.
  prefs: []
  type: TYPE_NORMAL
- en: Although this would be a feasible approach, Angular provides us with a much
    better approach to solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Provided by the component fixture, we have access to the debug element tree
    that is created by the test browser platform, in the context of our test. Debug
    elements allow us to do an advanced inspection of the element tree that was created
    by Angular while rendering our components. It also contains an advanced querying
    API, which allows us to search for certain elements in the component tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite our test to use the advanced capabilities provided by the debug
    element, and assert on both the estimated and effective duration components views
    individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `query` and `queryAll` methods that are available on every debug element
    object allow us to query the Angular view tree like we would query a DOM tree,
    using `querySelector` and `querySelectorAll`. The difference here is that we can
  prefs: []
  type: TYPE_NORMAL
- en: use a predicate helper to query for matching elements. Using the `By` helper
    class, we can create these predicates, which will then be used to query the debug
    element tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are currently three different predicates available, using the `By` helper:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Member | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `By.all()` | This is the predicate that will result in querying for all of
    the child `DebugElement` objects of the current `DebugElement` object. |'
  prefs: []
  type: TYPE_TB
- en: '| `By.css(selector)` | This is the predicate that will result in querying for
    `DebugElement` using the specified CSS selector. |'
  prefs: []
  type: TYPE_TB
- en: '| `By.directive(type)` | This is the predicate that will result in querying
    for the `DebugElement` that contains the specified directive. |'
  prefs: []
  type: TYPE_TB
- en: Going back to our test, we can now use the query method on the fixture debug
    element, in order to query for our duration components. As we've exchanged the
    real duration component with our mock duration component, we need to query for
    the latter. We use a predicate, `By.directive(MockDurationComponent)`, which will
    successfully query for the debug element object that represents the host elements
    of our two mock duration components.
  prefs: []
  type: TYPE_NORMAL
- en: The `query` method of the debug element object will always return a new debug
    element object of the first found element, if there was a match. It will return
    `null` if the queried element was not found.
  prefs: []
  type: TYPE_NORMAL
- en: The `queryAll` method of a debug element will return an array of many debug
    elements, which will contain all elements that match the predicate. If there are
    no matching elements, this method will return an empty array.
  prefs: []
  type: TYPE_NORMAL
- en: Testing component interaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although UI interaction testing is probably part of end-to-end testing, we'll
    look at how to test basic user interaction with your components. In this topic,
    we'll test the efforts component when the user clicks on one of the buttons to
    add effective effort hours.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a new test to our existing efforts component test file, located
    on the path `src/app/efforts/efforts/efforts.component.spec.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We want to set a Jasmine spy up on the `outEffortsChange.emit` function for
    our test. This way, we can later check whether our efforts component successfully
    emits the event when we click on the button to add a day of effective efforts.
  prefs: []
  type: TYPE_NORMAL
- en: In the given section, we're preparing everything for our test. We initialize
    the `efforts` input of our component with a new object. We also query for the
    debug element of the button within the efforts component view that adds one day
    to the effective effort. We use the `queryAll` method to get a list of all three
    buttons, and select the third by accessing the array element with the index `2`.
    The `css` predicate factory allows us to pass a CSS selector to query for debug
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: In the when section of our test, we can simulate a `click` event on the `addDayButton`
    debug element by using the method `tiggerEventHandler`. Using this method, you
    can trigger an event that you'd like to be emitted on the underlying element.
    Angular event listeners that listen for that event will be triggered synchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Within the then section of our BDD style test, we can simply evaluate the Jasmine
    spy that we've created on the `outEffortsChange` output property of our component.
  prefs: []
  type: TYPE_NORMAL
- en: Testing user interaction on components is made very easy by using the debug
    element. We can also decouple our tests from the underlying DOM event architecture
    by using the `triggerEventHandler` helper method.
  prefs: []
  type: TYPE_NORMAL
- en: The `triggerEventHandler` method operates on the virtual element tree of Angular,
    rather than the actual DOM tree. Due to this, we can also use this method to trigger
    event handlers that are attached to component output properties.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this last chapter of the book, we learned how to write concise unit tests
    for our components. We followed a BDD style approach of writing tests, and we
    also covered the basics of the JavaScript testing framework, Jasmine.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about the debugging tools that are available in Angular, and how
    to set up an environment for testing. Using the Angular `Testbed` utility class,
    we were able to perform tests in a very flexible but precise way. We also learned
    about the debug view tree and the component fixture. These allowed us to perform
    clever inspections and apply practical queries to the rendered views, in order
    to assert expected results.
  prefs: []
  type: TYPE_NORMAL
- en: We used the `inject` and `async` helpers to inject dependencies, and to run
    asynchronous tests at the same time. We built mock components, in order to isolate
    our tests from the rest of our application.
  prefs: []
  type: TYPE_NORMAL
