- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Managing Complex Tasks with Services
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务管理复杂任务
- en: We have reached a point in our journey where we can successfully develop more
    complex applications by nesting components within other components in a sort of
    component tree. However, bundling all our business logic into a single component
    is not the way to go. Our application might become unmaintainable very soon as
    it develops.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的旅程中，我们已经达到了一个阶段，可以通过在组件树中嵌套其他组件来成功开发更复杂的应用程序。然而，将所有业务逻辑捆绑到一个组件中并不是一个好的做法。随着应用程序的发展，它可能会很快变得难以维护。
- en: In this chapter, we’ll investigate the advantages that Angular’s dependency
    management mechanism can bring to the table to overcome such problems. We will
    learn how to use the **Angular Dependency Injection** ( **DI** ) mechanism to
    declare and consume our dependencies across the application with minimum effort
    and optimal results. By the end of this chapter, you will be able to create an
    Angular application that is correctly structured to enforce the **Separation of
    Concerns** ( **SoC** ) pattern using services.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 Angular 的依赖管理机制如何带来优势以克服这些问题。我们将学习如何使用 **Angular 依赖注入**（**DI**）机制以最小的努力和最佳结果在应用程序中声明和消费我们的依赖项。到本章结束时，您将能够创建一个正确结构的
    Angular 应用程序，使用服务强制执行 **关注点分离**（**SoC**）模式。
- en: 'We will cover the following concepts relating to Angular services:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍与 Angular 服务相关的以下概念：
- en: Introducing Angular DI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Angular 依赖注入
- en: Creating our first Angular service
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的第一个 Angular 服务
- en: Providing dependencies across the application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序中提供依赖项
- en: Injecting services in the component tree
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件树中注入服务
- en: Overriding providers in the injector hierarchy
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在注入器层次结构中覆盖提供者
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The chapter contains various code samples to walk you through the concept of
    Angular services. You can find the related source code in the `ch05` folder of
    the following GitHub repository:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种代码示例，以向您介绍 Angular 服务的概念。您可以在以下 GitHub 仓库的 `ch05` 文件夹中找到相关的源代码：
- en: '[https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition](https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition
    )'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition](https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition
    )'
- en: Introducing Angular DI
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Angular 依赖注入
- en: DI is an application design pattern we also come across in other languages,
    such as C# and Java. As our applications grow and evolve, each code entity will
    internally require instances of other objects, better known as **dependencies**
    . Passing such dependencies to the consumer code entity is known as an **injection**
    , and it also entails the participation of another code entity called an **injector**
    . An injector is responsible for instantiating and bootstrapping the required
    dependencies to be ready for use when injected into a consumer. The consumer knows
    nothing about how to instantiate its dependencies and is only aware of the interface
    they implement to use them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入（DI）是一种应用设计模式，我们也在其他语言中遇到过，例如 C# 和 Java。随着我们的应用程序增长和演变，每个代码实体将内部需要其他对象的实例，这通常被称为**依赖项**。将这些依赖项传递给消费者代码实体称为**注入**，这也涉及到另一个称为**注入器**的代码实体。注入器负责实例化和启动所需的依赖项，以便在注入到消费者时可以使用。消费者对其依赖项的实例化方式一无所知，只知道它们实现的接口以使用它们。
- en: Angular includes a top-notch DI mechanism to expose required dependencies to
    any Angular artifact of an Angular application. Before delving deeper into this
    subject, let’s look at the problem that DI in Angular is trying to address.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 包含一个顶级的 DI 机制，用于向任何 Angular 应用程序的 Angular 实体公开所需的依赖项。在深入探讨这个主题之前，让我们看看
    Angular 中的 DI 试图解决的问题。
- en: 'In *Chapter 3* , *Structuring User Interfaces with Components* , we learned
    how to display a list of objects using the `@for` block. We used a static list
    of `Product` objects that were declared in the `product-list.component.ts` file,
    as shown here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 3 章* ，*使用组件构建用户界面* 中，我们学习了如何使用 `@for` 块显示对象列表。我们使用了一个静态的 `Product` 对象列表，这些对象在
    `product-list.component.ts` 文件中声明，如下所示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This previous approach has two main drawbacks:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种先前的方法有两个主要缺点：
- en: In real-world applications, we rarely work with static data. It usually comes
    from a backend API or some other external source.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现实世界的应用中，我们很少处理静态数据。它通常来自后端 API 或其他外部来源。
- en: The product list is tightly coupled with the component. Angular components are
    responsible for the presentation logic and should not be concerned with how to
    get data. They only need to display it in the HTML template. Thus, they should
    delegate business logic to services to handle such tasks.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品列表与组件紧密耦合。Angular 组件负责展示逻辑，不应关心如何获取数据。它们只需要在 HTML 模板中显示数据。因此，它们应该将业务逻辑委托给服务来处理此类任务。
- en: In the following section, we’ll learn how to avoid these obstacles using Angular
    services.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习如何使用 Angular 服务避免这些障碍。
- en: You will need the source code of the Angular application we created in *Chapter
    4* , *Enriching Applications Using Pipes and Directives* , to follow along with
    the rest of the chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章的其余部分，您需要我们创建的 Angular 应用程序的源代码，即 *第 4 章* ，*使用管道和指令丰富应用程序* 。
- en: 'We will create an Angular service that will return the product list. Thus,
    we will effectively delegate business logic tasks away from the component. Remember:
    *the component should only be concerned with presentation logic* .'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 Angular 服务，该服务将返回产品列表。因此，我们将有效地将业务逻辑任务从组件中委托出去。记住：*组件只应关注展示逻辑* 。
- en: Creating our first Angular service
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个 Angular 服务
- en: 'To create a new Angular service, we use the `ng generate` command of the Angular
    CLI while passing the name of the service as a parameter:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的 Angular 服务，我们使用 Angular CLI 的 `ng generate` 命令，同时传递服务的名称作为参数：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Running the preceding command will create the `products` service, which consists
    of the `products.service.ts` file and its accompanying unit test file, `products.service.spec.ts`
    .
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的命令将创建 `products` 服务，它包括 `products.service.ts` 文件及其伴随的单元测试文件 `products.service.spec.ts`
    。
- en: We usually name a service after the functionality that it represents. Every
    service has a business context or domain within which it operates. When it starts
    to cross boundaries between different contexts, this is an indication that you
    should break it into different services. A products service should be concerned
    with products. Similarly, orders should be managed by a separate orders service.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常根据服务所表示的功能来命名服务。每个服务都有一个业务上下文或领域，在其中它运行。当它开始跨越不同上下文之间的边界时，这表明你应该将其拆分为不同的服务。产品服务应该关注产品。同样，订单应该由单独的订单服务管理。
- en: An Angular service is a TypeScript class marked with the `@Injectable` decorator.
    The decorator identifies the class as an Angular service that can be injected
    into other Angular artifacts such as components, directives, or even other services.
    It accepts an object as a parameter with a single property named `providedIn`
    , which defines which injector provides the service.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 服务是一个带有 `@Injectable` 装饰器的 TypeScript 类。装饰器将类标识为 Angular 服务，它可以注入到其他
    Angular 实体中，如组件、指令，甚至是其他服务。它接受一个对象作为参数，该对象有一个名为 `providedIn` 的单个属性，它定义了哪个注入器提供该服务。
- en: 'An Angular service, by default, is registered with an injector – the `root`
    injector of the Angular application, as defined in the `products.service.ts` file:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Angular 服务通过注入器注册——即 Angular 应用程序的 `root` 注入器，如 `products.service.ts`
    文件中定义的那样：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our service does not contain any implementation. Let’s add some logic so that
    our component can use it:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务不包含任何实现。让我们添加一些逻辑，以便我们的组件可以使用它：
- en: 'Add the following statement to import the `Product` interface:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下语句以导入 `Product` 接口：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create the following method in the `ProductsService` class:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ProductsService` 类中创建以下方法：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the following sections, we will learn how to use the service in our application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习如何在我们的应用程序中使用该服务。
- en: Injecting services in the constructor
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在构造函数中注入服务
- en: 'The most common way to use a service in an Angular component is through its
    `constructor` :'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '在 Angular 组件中使用服务最常见的方式是通过其 `constructor` :'
- en: 'Open the `product-list.component.ts` file and modify the `products` property
    so that it is initialized to an empty array:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-list.component.ts` 文件，并修改 `products` 属性，使其初始化为空数组：
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the following statement to import the `ProductsService` class:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下语句以导入 `ProductsService` 类：
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a component property called `productService` and give it a type of `ProductsService`
    :'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建一个名为 `productService` 的组件属性，并为其指定类型 `ProductsService` :'
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Instantiate the property using the `new` keyword in the component’s `constructor`
    :'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `new` 关键字在组件的 `constructor` 中实例化属性：
- en: '[PRE8]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Import the `OnInit` interface from the `@angular/core` npm package:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `@angular/core` npm 包中导入 `OnInit` 接口：
- en: '[PRE9]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the `OnInit` interface to the list of implemented interfaces of the `ProductListComponent`
    class:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`OnInit`接口添加到`ProductListComponent`类的实现接口列表中：
- en: '[PRE10]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following `ngOnInit` method that calls the `getProducts` method of
    the `productService` property and assigns the returned value to the `products`
    property:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`ngOnInit`方法，该方法调用`productService`属性的`getProducts`方法，并将返回值赋给`products`属性：
- en: '[PRE11]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run the application using the `ng serve` command to verify that the list of
    products is still shown correctly on the page:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ng serve`命令运行应用程序以验证产品列表是否仍然正确显示在页面上：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, σχεδίαση  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_05_01.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、屏幕截图、字体、设计的图像自动生成的描述](img/B21418_05_01.png)'
- en: 'Figure 5.1: Product list'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：产品列表
- en: Awesome! We have successfully wired up our component with the service, and our
    application looks great. Well, this seems to be the case, but it’s actually not.
    There are some problems with the actual implementation. If the `ProductsService`
    class must change, maybe to accommodate another dependency, `ProductListComponent`
    should also change the implementation of its `constructor` . Thus, it is evident
    that the product list component is tightly coupled to the implementation of `ProductsService`
    . It prevents us from altering, overriding, or neatly testing the service if required.
    It also entails that a new `ProductsService` object is created every time we render
    a product list component, which might not be desired in specific scenarios, such
    as when we expect to use an actual singleton service.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们已经成功地将组件与服务连接起来，应用程序看起来很棒。嗯，这似乎是情况，但实际上并非如此。实际的实现中存在一些问题。如果`ProductsService`类必须更改，比如为了适应另一个依赖项，`ProductListComponent`也应该更改其`constructor`的实现。因此，很明显，产品列表组件与`ProductsService`的实现紧密耦合。它阻止我们在需要时更改、覆盖或整洁地测试服务。它还意味着每次渲染产品列表组件时都会创建一个新的`ProductsService`对象，这在某些场景中可能不是期望的，例如当我们期望使用实际的单例服务时。
- en: 'DI systems try to solve these issues by proposing several patterns, and the
    **constructor injection** pattern is the one enforced by Angular. We could remove
    the `productService` component property and inject the service directly into the
    `constructor` . The resulting `ProductListComponent` class would be the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入系统通过提出几种模式来尝试解决这些问题，其中**构造函数注入**模式是由Angular强制执行的。我们可以移除`productService`组件属性，并将服务直接注入到`constructor`中。生成的`ProductListComponent`类如下：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Consider declaring injected services as `readonly` to provide more stable code
    and prevent re-assignment of the service. In the preceding snippet, the `constructor`
    could be re-written as `constructor(private readonly productService: ProductsService)
    {}` .'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '考虑将注入的服务声明为`readonly`，以提供更稳定的代码并防止服务重新赋值。在前面的代码片段中，`constructor`可以被重写为`constructor(private
    readonly productService: ProductsService) {}`。'
- en: The component does not need to know how to instantiate the service. On the other
    hand, it expects such a dependency to be available before it is instantiated so
    that it can be injected through its `constructor` . This approach is easier to
    test as it allows us to override it or mock it up.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 组件不需要知道如何实例化服务。另一方面，它期望在实例化之前就有一个这样的依赖项可用，以便可以通过其`constructor`注入。这种方法更容易测试，因为它允许我们覆盖它或模拟它。
- en: However, using a `constructor` is not the only way to inject services in an
    Angular application, as we will learn in the following section.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Angular应用程序中注入服务的方式不仅仅是使用`constructor`，正如我们将在下一节中学习的。
- en: The inject keyword
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注入关键字
- en: 'The Angular framework contains a built-in `inject` method that we can use to
    inject services without using the `constructor` . There are some cases where we
    would like to use the `inject` method:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Angular框架包含一个内置的`inject`方法，我们可以使用它来注入服务而不使用`constructor`。有一些情况下我们希望使用`inject`方法：
- en: The `constructor` contains many injected services, making our code unreadable.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constructor`包含许多注入的服务，这使得我们的代码难以阅读。'
- en: Constructors cannot be used when working with pure functions in the Angular
    router or the HTTP client, as we will learn in the following chapters.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在与Angular路由器或HTTP客户端一起使用纯函数时，不能使用`constructor`，正如我们将在下一章中学习的。
- en: 'Let’s see how we could refactor the product list component to use the `inject`
    method:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何重构产品列表组件以使用`inject`方法：
- en: 'Open the `product-list.component.ts` file and import the `inject` method from
    the `@angular/core` npm package:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-list.component.ts`文件，并从`@angular/core`npm包中导入`inject`方法：
- en: '[PRE13]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Declare the following property in the `ProductListComponent` class:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ProductListComponent`类中声明以下属性：
- en: '[PRE14]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Remove the `constructor` from the `ProductListComponent` class.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`ProductListComponent`类中删除`constructor`。
- en: The application should still work as expected if we run the `ng serve` command.
    The product list should be displayed as in the preceding section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`ng serve`命令，应用程序应该仍然按预期工作。产品列表应该像上一节中显示的那样显示。
- en: We will explore additional use cases for the `inject` method in *Chapter 8*
    , *Communicating with Data Services over HTTP* , and *Chapter 9* , *Navigating
    through Applications with Routing* .
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第8章*通过HTTP与数据服务通信*和第9章*使用路由导航应用程序*中探索`inject`方法的更多用例。
- en: Compared to the `constructor` approach, the `inject` method provides more accurate
    types, enforcing strongly typed Angular applications.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与构造函数方法相比，`inject`方法提供了更精确的类型，强制执行强类型Angular应用程序。
- en: The Angular CLI provides a schematic that we can run to migrate to the new `inject`
    method. You can find more detail on how to run the schematic at [https://angular.dev/reference/migrations/inject-function](https://angular.dev/reference/migrations/inject-function)
    .
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI提供了一个可以运行的图表，我们可以用它来迁移到新的`inject`方法。有关如何运行图表的更多详细信息，请参阅[https://angular.dev/reference/migrations/inject-function](https://angular.dev/reference/migrations/inject-function)。
- en: In this book, we use both the inject method and constructor approach, according
    to the execution context of the application code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们根据应用程序代码的执行上下文，同时使用注入方法和构造函数方法。
- en: As we learned, when we create a new Angular service, the Angular CLI registers
    this service with the root injector of the application by default. In the following
    section, we’ll learn about the internals of the DI mechanism and how the root
    injector works.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，当我们创建一个新的Angular服务时，Angular CLI默认将此服务注册到应用程序的根注入器。在下一节中，我们将了解DI机制的内部原理以及根注入器的工作方式。
- en: Providing dependencies across the application
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在应用程序中提供依赖项
- en: The Angular framework offers a DI mechanism to provide dependencies in Angular
    artifacts such as components, directives, pipes, and services. The Angular DI
    is based on an injector hierarchy where at the top there is the root injector
    of an Angular application.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Angular框架提供了一个DI机制，用于在Angular实体（如组件、指令、管道和服务）中提供依赖项。Angular DI基于一个注入器层次结构，其中在顶部是Angular应用程序的根注入器。
- en: Injectors in Angular can examine the dependencies in the `constructor` of an
    Angular artifact and return an instance of the type represented by each dependency,
    so that we can use it straight away in the implementation of our Angular class.
    The injector maintains a list of all dependencies that an Angular application
    needs. When a component or other artifact wants to use a dependency, the injector
    first checks to see if it has already created an instance of this dependency.
    If not, it creates a new one, returns it to the component, and keeps a copy for
    further use. The next time the same dependency is requested, it returns the copy
    previously created. But how does the injector know which dependencies an Angular
    application needs?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Angular中的注入器可以检查Angular实体（如构造函数）中的依赖项，并为每个依赖项返回其类型的实例，这样我们就可以直接在我们的Angular类实现中使用它。注入器维护一个Angular应用程序需要的所有依赖项的列表。当组件或其他实体想要使用依赖项时，注入器首先检查是否已经创建了该依赖项的实例。如果没有，它将创建一个新的实例，将其返回给组件，并保留一个副本以供进一步使用。下次请求相同的依赖项时，它将返回之前创建的副本。但是，注入器如何知道Angular应用程序需要哪些依赖项呢？
- en: When we create an Angular service, we use the `providedIn` property of the `@Injectable`
    decorator to define how it is provided to the application. That is, we create
    a **provider** for this service. A provider is a *recipe* containing guidelines
    on creating a specific service. During application startup, the framework is responsible
    for configuring the injector with providers of services so that it knows how to
    create one upon request. An Angular service is configured with the root injector
    by default when created with the CLI. The root injector creates singleton services
    that are globally available through the application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个 Angular 服务时，我们使用 `@Injectable` 装饰器的 `providedIn` 属性来定义它如何提供给应用程序。也就是说，我们为这个服务创建一个
    **提供者**。提供者是一个包含创建特定服务的指南的 *配方*。在应用程序启动期间，框架负责使用服务提供者的提供者配置注入器，以便它知道如何在请求时创建一个。使用
    CLI 创建的 Angular 服务默认情况下通过根注入器进行配置。根注入器创建单例服务，这些服务通过应用程序全局可用。
- en: 'In *Chapter 1* , *Building Your First Angular Application* , we learned that
    the application configuration object defined in the `app.config.ts` file has a
    `providers` property where we can register application services. We could remove
    the `providedIn` property from the `@Injectable` decorator of the `products.service.ts`
    file and add it in that array directly. Registering a service in this way is the
    same as configuring the service with `providedIn: ''root''` . The main difference
    between them is that the `providedIn` syntax is **tree shakable** .'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '在 *第一章* ，*构建你的第一个 Angular 应用程序* 中，我们了解到在 `app.config.ts` 文件中定义的应用程序配置对象有一个
    `providers` 属性，我们可以在这里注册应用程序服务。我们可以从 `products.service.ts` 文件的 `@Injectable` 装饰器中移除
    `providedIn` 属性，并将其直接添加到该数组中。以这种方式注册服务与使用 `providedIn: ''root''` 配置服务相同。它们之间的主要区别是
    `providedIn` 语法是 **可树摇的**。'
- en: Tree shaking is the process of finding dependencies that are not used in an
    application and removing them from the final bundle. In the context of Angular,
    the Angular compiler can detect and delete Angular services that are not used,
    resulting in a smaller bundle.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 树摇（Tree shaking）是寻找应用中未使用的依赖项并将它们从最终包中移除的过程。在 Angular 的上下文中，Angular 编译器可以检测并删除未使用的
    Angular 服务，从而生成更小的包。
- en: When you provide a service through the application configuration object, the
    Angular compiler cannot say if the service is used somewhere in the application.
    So, it includes the service in the final bundle *a priori* . Thus, using the `@Injectable`
    decorator over the `providers` array of the application configuration is preferable.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过应用程序配置对象提供服务时，Angular 编译器无法确定该服务是否在应用程序的某个地方被使用。因此，它预先将服务包含在最终包中。因此，在应用程序配置的
    `providers` 数组上使用 `@Injectable` 装饰器是首选的。
- en: You should always register singleton services with the root injector.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该始终在根注入器中注册单例服务。
- en: The root injector is not the only injector in an Angular application. Components
    have their injectors, too. Angular injectors are also hierarchical. Whenever an
    Angular component defines a token in its `constructor` , the injector searches
    for a type that matches that token in the pool of registered providers. If no
    match is found, it delegates the search to the parent component’s provider and
    keeps bubbling the component injector tree until it reaches the root injector.
    If no match is found, Angular throws an exception.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 根注入器并不是 Angular 应用程序中唯一的注入器。组件也有它们自己的注入器。Angular 注入器也是分层的。每当 Angular 组件在其 `constructor`
    中定义一个令牌时，注入器会在注册提供者的池中搜索与该令牌匹配的类型。如果没有找到匹配项，它将搜索委托给父组件的提供者，并继续向上冒泡组件注入器树，直到达到根注入器。如果没有找到匹配项，Angular
    将抛出异常。
- en: 'Let’s explore the injector hierarchy of the product list component using Angular
    DevTools:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Angular DevTools 探索产品列表组件的注入器层次结构：
- en: Run the application using the `ng serve` command and preview it at `http://localhost:4200`
    .
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ng serve` 命令运行应用程序，并在 `http://localhost:4200` 预览它。
- en: Start Angular DevTools and select the **Components** tab.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Angular DevTools 并选择 **组件** 选项卡。
- en: 'Select the **app-product-list** component from the component tree:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从组件树中选择 **app-product-list** 组件：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, αριθμός  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_05_02.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、屏幕截图、字体、编号的图像，自动生成的描述](img/B21418_05_02.png)'
- en: 'Figure 5.2: Components tab'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：组件选项卡
- en: In the preceding image, the **Injected Services** section contains the services
    injected in the component.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，**注入的服务**部分包含了注入到组件中的服务。
- en: 'Click on the down arrow next to the **ProductsService** label, and you will
    see the following diagram:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**ProductsService**标签旁边的向下箭头，你会看到以下图表：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμμή, γραμματοσειρά  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_05_03.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本的图片，屏幕截图，线条，字体  自动生成的描述](img/B21418_05_03.png)'
- en: 'Figure 5.3: Product list injector hierarchy'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：产品列表注入器层次结构
- en: The injector hierarchy diagram in Angular DevTools is in horizontal orientation.
    Here, we show it vertically for readability..
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Angular DevTools中的注入器层次结构图是水平方向的。在这里，我们将其垂直显示以提高可读性。
- en: 'The preceding diagram depicts the injector hierarchy of the product list component.
    It contains two main injector hierarchy types common to an Angular application:
    **environment** and **element** injectors.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表描述了产品列表组件的注入器层次结构。它包含两个在Angular应用程序中常见的注入器层次结构类型：**环境**和**元素**注入器。
- en: Environment injectors are configured using the `providedIn` property and the
    `providers` array in the application configuration object. In our case, we see
    the **Root** and **Standalone[_AppComponent]** injectors because the products
    service is provided from the root injector using the `providedIn` property.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 环境注入器是通过应用程序配置对象中的`providedIn`属性和`providers`数组进行配置的。在我们的例子中，我们看到**Root**和**Standalone[_AppComponent]**注入器，因为产品服务是通过`providedIn`属性从根注入器提供的。
- en: Angular creates an element injector for each component which can be configured
    from the `providers` array of the `@Component` decorator, as we will see in the
    following section. In our case, we see the **AppComponent** and **ProductListComponent**
    injectors because these components are related directly to the product list.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Angular为每个组件创建一个元素注入器，该注入器可以从`@Component`装饰器的`providers`数组中进行配置，正如我们将在下一节中看到的。在我们的例子中，我们看到**AppComponent**和**ProductListComponent**注入器，因为这些组件直接与产品列表相关。
- en: You can select the **Injector Tree** tab of Angular DevTools for a more detailed
    analysis of the application injector hierarchy per type. You can also learn more
    about the different kinds of injectors at [https://angular.dev/guide/di/hierarchical-dependency-injection#types-of-injector-hierarchies](https://angular.dev/guide/di/hierarchical-dependency-injection#types-of-injector-hierarchies)
    .
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过选择Angular DevTools的**注入器树**选项卡来对应用程序的每个类型的注入器层次结构进行更详细的分析。您还可以在[https://angular.dev/guide/di/hierarchical-dependency-injection#types-of-injector-hierarchies](https://angular.dev/guide/di/hierarchical-dependency-injection#types-of-injector-hierarchies)了解更多关于不同类型的注入器信息。
- en: Components create injectors, so they are immediately available to their child
    components. We’ll learn about this in detail in the following section.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 组件创建注入器，因此它们立即可用于其子组件。我们将在下一节中详细介绍这一点。
- en: Injecting services in the component tree
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在组件树中注入服务
- en: 'As we learned in the preceding section, Angular uses an element injector to
    provide services in components through the `providers` property of the `@Component`
    decorator. A service that registers with the element injector can serve two purposes:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Angular使用元素注入器通过`@Component`装饰器的`providers`属性在组件中提供服务。注册到元素注入器的服务可以有两个用途：
- en: It can be shared with its child components
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以与其子组件共享
- en: It can create multiple copies of the service every time the component that provides
    the service is rendered
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以在提供服务的组件每次渲染时创建服务的多个副本
- en: In the following sections, we’ll learn how to apply each approach.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习如何应用每种方法。
- en: Sharing dependencies through components
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过组件共享依赖项
- en: 'A service provided through a component can be shared among the child components
    of the parent component, and it is immediately available for injection into their
    constructors. Child components reuse the same instance of the service as the parent
    component. Let’s walk our way through an example to understand this better:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组件提供的服务可以在父组件的子组件之间共享，并且它立即可用于注入到它们的构造函数中。子组件会重用与父组件相同的服务的实例。让我们通过一个例子来更好地理解这一点：
- en: 'Create a new Angular component named `favorites` :'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`favorites`的新Angular组件：
- en: '[PRE15]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Open the `favorites.component.ts` file and modify the `import` statements accordingly:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`favorites.component.ts`文件并相应地修改`import`语句：
- en: '[PRE16]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Modify the `FavoritesComponent` class to use the `ProductsService` class and
    get the product list in a `products` component property:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`FavoritesComponent`类以使用`ProductsService`类并在`products`组件属性中获取产品列表：
- en: '[PRE17]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Open the `favorites.component.html` file and replace its content with the following
    HTML code:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `favorites.component.html` 文件，将其内容替换为以下 HTML 代码：
- en: '[PRE18]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding snippet, we iterate over the `products` array and use the `slice`
    pipe to display only two products.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们遍历 `products` 数组，并使用 `slice` 管道仅显示两个产品。
- en: 'Modify the `favorites.component.ts` file so that it imports the `CommonModule`
    class that is needed for the `slice` pipe:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `favorites.component.ts` 文件，使其导入 `CommonModule` 类，这是 `slice` 管道所必需的：
- en: '[PRE19]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Open the `favorites.component.css` file to add some CSS styles to our favorite
    products:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `favorites.component.css` 文件，为我们的收藏产品添加一些 CSS 样式：
- en: '[PRE20]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Open the `product-list.component.ts` file, import the `FavoritesComponent`
    class, and add the `ProductsService` class to the `providers` array of the `@Component`
    decorator:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-list.component.ts` 文件，导入 `FavoritesComponent` 类，并将 `ProductsService`
    类添加到 `@Component` 装饰器的 `providers` 数组中：
- en: '[PRE21]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Open the `products.service.ts` file and remove the `providedIn` property from
    the `@Injectable` decorator since the element injector of the product list component
    will provide it.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `products.service.ts` 文件，从 `@Injectable` 装饰器中移除 `providedIn` 属性，因为产品列表组件的元素注入器将提供它。
- en: 'Finally, open the `product-list.component.html` file and add the following
    HTML snippet to display the contents of the favorites component:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开 `product-list.component.html` 文件，并添加以下 HTML 片段以显示收藏组件的内容：
- en: '[PRE22]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When running the application using `ng serve` , you should see the following
    output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `ng serve` 运行应用程序时，你应该看到以下输出：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, σχεδίαση  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_05_04.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、屏幕截图、字体、设计的图像 自动生成的描述](img/B21418_05_04.png)'
- en: 'Figure 5.4: Product list with favorites'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：带有收藏夹的产品列表
- en: Let’s explain what we did in the previous example in more detail. We injected
    `ProductsService` in `FavoritesComponent` but we did not provide it through its
    injector. So, how was the component aware of how to create an instance of the
    `ProductsService` class and use it? It wasn’t. When we added the favorites component
    to the `ProductListComponent` template, we made it a direct child of this component,
    thus giving it access to all its provided services. In a nutshell, `FavoritesComponent`
    can use `ProductsService` out of the box because it is already provided through
    the element injector of its parent component, `ProductListComponent` .
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释一下上一个示例中我们做了什么。我们在 `FavoritesComponent` 中注入了 `ProductsService`，但没有通过其注入器提供它。那么组件是如何知道如何创建
    `ProductsService` 类的实例并使用它的呢？它并不知道。当我们将收藏组件添加到 `ProductListComponent` 模板中时，我们使其成为该组件的直接子组件，从而使其能够访问所有提供的服务。简而言之，`FavoritesComponent`
    可以直接使用 `ProductsService`，因为它已经通过其父组件 `ProductListComponent` 的元素注入器提供。
- en: So, even if `ProductsService` was initially registered with the environment
    root injector, we could also register it with the element injector of `ProductListComponent`
    . In the next section, we’ll investigate how it is possible to achieve such behavior.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使 `ProductsService` 最初是在环境根注入器中注册的，我们也可以将其注册到 `ProductListComponent` 的元素注入器中。在下一节中，我们将探讨如何实现这种行为。
- en: Root and component injectors
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根和组件注入器
- en: We have already learned that when we create an Angular service using the Angular
    CLI, the service is provided in the application’s root injector by default. How
    does this differ when providing a service through the element injector of a component?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，当我们使用 Angular CLI 创建 Angular 服务时，服务默认由应用程序的根注入器提供。通过组件的元素注入器提供服务时，这有何不同？
- en: 'Services provided with the application root injector are available throughout
    the whole application. When a component wants to use such a service, it only needs
    to inject it, nothing more. Now, if the component provides the same service through
    its injector, it will get an instance of the service entirely different from the
    one from the root injector. This technique is called **service scope limiting**
    because we limit the scope of the service to a specific part of the component
    tree:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用应用程序根注入器提供的服务在整个应用程序中可用。当组件想要使用此类服务时，它只需要注入它，无需更多操作。现在，如果组件通过其注入器提供相同的服务，它将获得一个与根注入器完全不同的服务实例。这种技术被称为
    **服务作用域限制**，因为我们限制了服务的范围到组件树的一个特定部分：
- en: '![Table  Description automatically generated](img/B21418_05_05.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![描述自动生成的表格](img/B21418_05_05.png)'
- en: 'Figure 5.5: Service scope limiting'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5：服务作用域限制
- en: 'The previous diagram shows that `ProductsService` can be provided through two
    injectors: the application root injector and the element injector of the product
    list component. The `FavoritesComponent` class injects `ProductsService` to use
    it. As we have already seen, `FavoritesComponent` is a child component of `ProductListComponent`
    .'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图显示，`ProductsService`可以通过两个注入器提供：应用程序根注入器和产品列表组件的元素注入器。`FavoritesComponent`类注入`ProductsService`以使用它。正如我们之前看到的，`FavoritesComponent`是`ProductListComponent`的子组件。
- en: According to the injector hierarchy, it will first ask the injector of its parent
    component, `ProductListComponent` , about providing the service. The `ProductListComponent`
    class indeed provides `ProductsService` , so it creates a new instance of the
    service and returns it to `FavoritesComponent` .
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 根据注入器层次结构，它首先会询问其父组件`ProductListComponent`是否提供该服务。`ProductListComponent`类确实提供了`ProductsService`，因此它会创建该服务的新实例并将其返回给`FavoritesComponent`。
- en: Now, consider that another component in our application, `CmpA` , wants to use
    `ProductsService` . Since it is not a child component of `ProductListComponent`
    and does not contain any parent component that provides the required service,
    it will finally reach the application root injector. The root injector that provides
    `ProductsService` checks if it has already created an instance for that service.
    If not, it creates a new one, called `productService` , and returns it to `CmpA`
    . It also keeps `productService` in the local pool of services for later use.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑我们应用程序中的另一个组件`CmpA`，它想使用`ProductsService`。由于它不是`ProductListComponent`的子组件，也不包含任何提供所需服务的父组件，它最终会到达应用程序根注入器。提供`ProductsService`的根注入器会检查是否已经为该服务创建了一个实例。如果没有，它会创建一个新的实例，称为`productService`，并将其返回给`CmpA`。它还会将`productService`保留在本地服务池中，以供以后使用。
- en: Suppose another component, `CmpB` , wants to use `ProductsService` and asks
    the application root injector. The root injector knows it has already created
    the `productService` instance when `CmpA` requested it and returns it immediately
    to the `CmpB` component.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 假设另一个组件`CmpB`想使用`ProductsService`并请求应用程序根注入器。根注入器知道当`CmpA`请求它时已经创建了`productService`实例，并立即将其返回给`CmpB`组件。
- en: Sandboxing components with multiple instances
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将具有多个实例的组件进行沙盒化
- en: 'When we provide a service through the element injector and inject it into the
    component’s `constructor` , a new instance is created every time the component
    is rendered on the page. It can come in handy in cases such as when we want to
    have a local cache service for each component. We will explore this scenario by
    transforming our Angular application so that the product list displays a quick
    view of each product using an Angular service:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过元素注入器提供服务并将其注入到组件的`constructor`中时，每次组件在页面上渲染时都会创建一个新的实例。这在我们需要为每个组件拥有一个本地缓存服务的情况下很有用。我们将通过将我们的Angular应用程序转换为产品列表使用Angular服务显示每个产品的快速预览来探索这个场景：
- en: 'Run the following command to create a new Angular component for the product
    view:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以创建一个新的Angular组件用于产品视图：
- en: '[PRE23]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Open the `product-view.component.ts` file and declare an input property named
    `id` so we can pass a unique identifier of the product we want to display:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-view.component.ts`文件，声明一个名为`id`的输入属性，这样我们就可以传递我们想要显示的产品的一个唯一标识符：
- en: '[PRE24]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the following Angular CLI command inside the `product-view` folder to create
    an Angular service that will be dedicated to the product view component:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`product-view`文件夹内运行以下Angular CLI命令以创建一个将专门用于产品视图组件的Angular服务：
- en: '[PRE25]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Open the `product-view.service.ts` file and remove the `providedIn` property
    from the `@Injectable` decorator because we will provide it later in the product
    view component.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-view.service.ts`文件，从`@Injectable`装饰器中移除`providedIn`属性，因为我们将在产品视图组件中稍后提供它。
- en: 'Inject `ProductsService` into the `constructor` of the `ProductViewService`
    class:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ProductsService`注入到`ProductViewService`类的`constructor`中：
- en: '[PRE26]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding technique is called **service-in-a-service** because we inject
    one Angular service into another.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 上述技术被称为**服务中的服务**，因为我们在一个Angular服务中注入了另一个服务。
- en: 'Create a method named `getProduct` that takes an `id` property as a parameter.
    The method will call the `getProducts` method of the `ProductsService` class and
    search through the product list based on the `id` . If it finds the product, it
    will keep it in a local variable named `product` :'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`getProduct`的方法，该方法接受一个`id`属性作为参数。该方法将调用`ProductsService`类的`getProducts`方法并根据`id`搜索产品列表。如果找到产品，它将将其保存在一个名为`product`的本地变量中：
- en: '[PRE27]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We have already created the essential Angular artifacts for working with the
    product view component. All we need to do now is connect them and wire them up
    to the product list:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为与产品视图组件一起工作创建了必要的 Angular 元素。我们现在需要做的就是将它们连接起来，并将它们连接到产品列表：
- en: 'Inject `ProductViewService` in the `constructor` of the `ProductViewComponent`
    and implement the `ngOnInit` method:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ProductViewComponent` 的 `constructor` 中注入 `ProductViewService` 并实现 `ngOnInit`
    方法：
- en: '[PRE28]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a component property to keep the product that we will fetch from the
    `ProductViewService` class:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个组件属性以保存我们将从 `ProductViewService` 类获取的产品：
- en: '[PRE29]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Modify the `ngOnInit` method so that it calls the `getProduct` method of the
    `ProductViewService` class as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `ngOnInit` 方法，使其调用 `ProductViewService` 类的 `getProduct` 方法，如下所示：
- en: '[PRE30]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding snippet, we pass the `id` component property to the `getProduct`
    method as a parameter and assign the returned value to the `product` property.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将 `id` 组件属性作为参数传递给 `getProduct` 方法，并将返回的值赋给 `product` 属性。
- en: 'Open the `product-view.component.html` file and replace its content with the
    following HTML template:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-view.component.html` 文件，并用以下 HTML 模板替换其内容：
- en: '[PRE31]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Open the `product-list.component.ts` file and import the `ProductViewComponent`
    class:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-list.component.ts` 文件并导入 `ProductViewComponent` 类：
- en: '[PRE32]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, open the `product-list.component.html` file and modify the `@for`
    block to use the product view component:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开 `product-list.component.html` 文件，并修改 `@for` 块以使用产品视图组件：
- en: '[PRE33]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If we run our application with the `ng serve` command, we will see that the
    product list is still displayed correctly.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `ng serve` 命令运行我们的应用程序，我们会看到产品列表仍然正确显示。
- en: Each rendered product view component creates a dedicated sandboxed `ProductViewService`
    instance for its purpose. Any other component cannot share the instance or be
    changed except by the component that provides it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 每个渲染的产品视图组件都会为其目的创建一个专门的沙盒 `ProductViewService` 实例。任何其他组件都不能共享该实例或被提供它的组件更改。
- en: 'Try to provide `ProductViewService` in `ProductListComponent` instead of `ProductViewComponent`
    ; you will see that only one product is rendered multiple times:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在 `ProductListComponent` 中提供 `ProductViewService` 而不是 `ProductViewComponent`；你会看到只有一个产品被渲染多次：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, λογότυπο  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_05_06.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、屏幕截图、字体、标志的图片，自动生成的描述](img/B21418_05_06.png)'
- en: 'Figure 5.6: Product list'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：产品列表
- en: 'In this case, only one service instance is shared among the child components.
    Why is that? Recall the business logic of the `getProduct` method from the `ProductViewService`
    class:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，只有一个服务实例在子组件之间共享。为什么是这样？回想一下 `ProductViewService` 类中 `getProduct` 方法的业务逻辑：
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding method, the `product` property is set initially when we provide
    the service inside `ProductListComponent` . Since we have only one instance of
    the service, the value of the property will remain the same while we render the
    product view component multiple times.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，当我们在 `ProductListComponent` 内部提供服务时，`product` 属性被初始化设置。由于我们只有一个服务实例，该属性的值将在我们多次渲染产品视图组件时保持不变。
- en: We’ve learned how dependencies are injected into the component hierarchy and
    how provider lookup is performed by bubbling the request upward in the component
    tree. However, what if we want to constrain such injection or lookup actions?
    We’ll see how to do so in the next section.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何将依赖项注入到组件层次结构中，以及如何通过在组件树中冒泡请求来执行提供者查找。然而，如果我们想限制这样的注入或查找操作呢？我们将在下一节中看到如何做到这一点。
- en: Restricting provider lookup
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制提供者查找
- en: 'We can only constrain dependency lookup to the next upper level. To do so,
    we need to apply the `@Host` decorator to those dependency parameters whose provider
    lookup we want to restrict:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能将依赖项查找限制在下一级。为此，我们需要将这些依赖项参数应用 `@Host` 装饰器，我们想要限制其提供者查找：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding example, the element injector of `FavoritesComponent` will
    look for the `ProductsService` class in its providers. If it does not provide
    the service, it will not bubble up the injector hierarchy; instead, it will stop
    and throw an exception in the console window of the browser:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`FavoritesComponent` 的元素注入器将在其提供者中查找 `ProductsService` 类。如果它不提供该服务，它将不会冒泡注入器层次结构；相反，它将停止并在浏览器的控制台窗口中抛出异常：
- en: '**Error: NG0201: No provider for _ProductsService found in NodeInjector.**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误：NG0201：在 NodeInjector 中找不到 _ProductsService 提供者**。'
- en: 'We can configure the injector so that it does not throw an error if we decorate
    the service with the `@Optional` decorator:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以配置注入器，使其在用 `@Optional` 装饰器装饰服务时不会抛出错误：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: However, using the `@Optional` decorator does not solve the actual problem.
    The preceding snippet will still throw an error, different than the previous one,
    because we still use the `@Host` decorator that limits searching the `ProductsService`
    class in the injector hierarchy. We need to refactor the `ngOnInit` lifecycle
    hook event so that it takes care of not finding the service instance.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 `@Optional` 装饰器并不能解决实际问题。前面的代码片段仍然会抛出错误，与之前的错误不同，因为我们仍然使用了限制在注入器层次结构中搜索
    `ProductsService` 类的 `@Host` 装饰器。我们需要重构 `ngOnInit` 生命周期钩子事件，以确保它不会找到服务实例。
- en: The `@Host` and `@Optional` decorators define the level at which the injector
    searches for dependencies. There are two other decorators, called `@Self` and
    `@SkipSelf` . When using the `@Self` decorator, the injector looks for dependencies
    in the injector of the current component. On the contrary, the `@SkipSelf` decorator
    instructs the injector to skip the local injector and search further up in the
    injector hierarchy.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Host` 和 `@Optional` 装饰器定义了注入器搜索依赖项的级别。还有另外两个装饰器，称为 `@Self` 和 `@SkipSelf`。当使用
    `@Self` 装饰器时，注入器在当前组件的注入器中查找依赖项。相反，`@SkipSelf` 装饰器指示注入器跳过本地注入器，并在注入器层次结构中进一步搜索。'
- en: The `@Host` and `@Self` decorators work similarly. For more information about
    when to use each, have a look at [https://angular.dev/guide/di/hierarchical-dependency-injection#self](https://angular.dev/guide/di/hierarchical-dependency-injection#self)
    and [https://angular.dev/guide/di/hierarchical-dependency-injection#host](https://angular.dev/guide/di/hierarchical-dependency-injection#host)
    .
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Host` 和 `@Self` 装饰器的工作方式类似。有关何时使用每个装饰器的更多信息，请参阅[https://angular.dev/guide/di/hierarchical-dependency-injection#self](https://angular.dev/guide/di/hierarchical-dependency-injection#self)
    和 [https://angular.dev/guide/di/hierarchical-dependency-injection#host](https://angular.dev/guide/di/hierarchical-dependency-injection#host)
    。'
- en: So far, we have learned how the Angular DI framework uses classes as dependency
    tokens to work out the type required and return it from any providers available
    in the injector hierarchy. However, there are cases where we might need to override
    the instance of a class or provide types that are not actual classes, such as
    primitive types.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了 Angular DI 框架如何使用类作为依赖项令牌来确定所需类型，并从注入器层次结构中的任何提供者返回它。然而，在某些情况下，我们可能需要覆盖类的实例或提供不是实际类的类型，例如原始类型。
- en: Overriding providers in the injector hierarchy
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖注入器层次结构中的提供者
- en: 'We already learned how to use the `providers` array of the `@Component` decorator
    in the *Sharing dependencies through components* section:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 *通过组件共享依赖项* 部分学习了如何使用 `@Component` 装饰器的 `providers` 数组：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The preceding syntax is called **class provider** syntax and is shorthand for
    the **provide object literal** syntax shown below:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语法称为 **类提供者** 语法，是下面显示的 **提供对象字面量** 语法的简写：
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding syntax uses an object with the following properties:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语法使用了一个具有以下属性的对象：
- en: '`provide` : This is the token used to configure the injector. It is the actual
    class that consumers of the dependency inject into their constructors.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`provide`：这是用于配置注入器的令牌。它是消费者将其注入构造函数的实际类。'
- en: '`useClass` : This is the actual implementation the injector will provide to
    the consumers. The property name will differ according to the implementation type
    provided. The type can be a class, a value, or a factory function. In this case,
    we use `useClass` because we are providing a class.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useClass`：这是注入器将提供给消费者的实际实现。属性名将根据提供的实现类型而有所不同。类型可以是类、值或工厂函数。在这种情况下，我们使用 `useClass`，因为我们提供了一个类。'
- en: Let’s look at some examples to get an overview of how to use the provide object
    literal syntax.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些示例，以了解如何使用提供对象字面量语法。
- en: Overriding service implementation
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖服务实现
- en: 'We have already learned that a component could share its dependencies with
    its child components. Consider the `FavoritesComponent` , where we used the `slice`
    pipe to display a list of favorite products in its template. What if it needs
    to get data through a trimmed version of `ProductsService` and not directly from
    the service instance of `ProductListComponent` ? We could create a new service
    extending the `ProductsService` class and filtering out data using the native
    **Array.slice** method. Let’s create the new service and learn how to use it:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，组件可以与其子组件共享其依赖项。考虑`FavoritesComponent`，我们在其模板中使用`slice`管道显示收藏产品的列表。如果它需要通过`ProductsService`的裁剪版本来获取数据，而不是直接从`ProductListComponent`的服务实例中获取数据怎么办？我们可以创建一个新的服务，该服务扩展了`ProductsService`类，并使用原生的**Array.slice**方法过滤数据。让我们创建新的服务并学习如何使用它：
- en: 'Run the following command to generate the service:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以生成服务：
- en: '[PRE39]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Open the `favorites.service.ts` file and add the following `import` statements:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`favorites.service.ts`文件并添加以下`import`语句：
- en: '[PRE40]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Use the `extends` keyword in the class definition to indicate that `ProductsService`
    is the base class of `FavoritesService` :'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类定义中使用`extends`关键字来指示`ProductsService`是`FavoritesService`的基类：
- en: '[PRE41]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Modify the `constructor` to call the `super` method and execute any business
    logic inside the base class `constructor` :'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`constructor`以调用`super`方法并在基类`constructor`中执行任何业务逻辑：
- en: '[PRE42]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create the following service method that uses the `slice` method to return
    only the first two products from the list:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下服务方法，使用`slice`方法从列表中返回前两个产品：
- en: '[PRE43]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The preceding method is marked with the `override` keyword to indicate that
    the implementation of the method replaces the corresponding method of the base
    class.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的方法使用`override`关键字标记，以表明该方法的实现替换了基类中对应的方法。
- en: 'Open the `favorites.component.ts` file and add the following `import` statement:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`favorites.component.ts`文件，并添加以下`import`语句：
- en: '[PRE44]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Add the `FavoritesService` class in the `providers` array of the `@Component`
    decorator as follows:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`FavoritesService`类添加到`@Component`装饰器的`providers`数组中，如下所示：
- en: '[PRE45]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the preceding snippet, we removed `CommonModule` from the `imports` array
    because we no longer need the `slice` pipe.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们从`imports`数组中移除了`CommonModule`，因为我们不再需要`slice`管道。
- en: Finally, open the `favorites.component.html` file and remove the `slice` pipe
    from the `@for` block.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开`favorites.component.html`文件并从`@for`块中删除`slice`管道。
- en: 'If we run the application using the `ng serve` command, we will see that the
    **Favorites** section is still displayed correctly:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`ng serve`命令运行应用程序，我们将看到**收藏**部分仍然正确显示：
- en: '![Εικόνα που περιέχει κείμενο, γραμματοσειρά, λογότυπο, γραφικά  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_05_07.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、字体、标志、图形的图片，自动生成的描述](img/B21418_05_07.png)'
- en: 'Figure 5.7: Favorite products list'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7：收藏产品列表
- en: The preceding output assumes that you have already imported and added the favorites
    component in the product list component.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出假设您已经将收藏组件导入并添加到产品列表组件中。
- en: The `useClass` property essentially overwrote the initial implementation of
    the `ProductsService` class for the favorites component. Alternatively, we can
    go the extra mile and use a function to return a specific object instance that
    we need, as we will learn in the following section.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`useClass`属性本质上覆盖了`ProductsService`类在收藏组件中的初始实现。或者，我们可以更进一步，使用一个函数返回我们需要的特定对象实例，正如我们将在下一节中学习的那样。'
- en: Providing services conditionally
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件提供服务
- en: 'In the example in the previous section, we used the `useClass` syntax to replace
    the implementation of the injected `ProductsService` class. Alternatively, we
    could create a **factory function** that decides whether it will return an instance
    of the `FavoritesService` or `ProductsService` class according to a condition.
    The function would reside in a simple TypeScript file named `favorites.ts` :'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节的示例中，我们使用了`useClass`语法来替换注入的`ProductsService`类的实现。或者，我们可以创建一个**工厂函数**，根据条件决定返回`FavoritesService`类或`ProductsService`类的实例。该函数将位于一个简单的TypeScript文件中，命名为`favorites.ts`：
- en: '[PRE46]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We could then modify the `providers` array in the `favorites.component.ts`
    file as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以修改`favorites.component.ts`文件中的`providers`数组，如下所示：
- en: '[PRE47]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'It is worth noting that if one of the services also injected other dependencies,
    the previous syntax would not suffice. For example, if the `FavoritesService`
    class was dependent on the `ProductViewService` class, we would add it to the
    `deps` property of the provide object literal syntax:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，如果其中一个服务注入了其他依赖项，之前的语法就不够用了。例如，如果`FavoritesService`类依赖于`ProductViewService`类，我们就会将其添加到提供对象字面量语法的`deps`属性中：
- en: '[PRE48]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We could then use it in the factory function of the `favorites.ts` file as
    follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在`favorites.ts`文件的工厂函数中使用它，如下所示：
- en: '[PRE49]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We have already learned how to provide an alternate class implementation for
    an Angular service. What if the dependency we want to provide is not a class but
    a string or an object? We can use the `useValue` syntax to accomplish this task.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何为Angular服务提供一个替代类实现。如果我们想提供的依赖项不是一个类，而是一个字符串或对象怎么办？我们可以使用`useValue`语法来完成这个任务。
- en: Transforming objects in Angular services
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Angular服务中转换对象
- en: 'It is common to keep application settings in a constant object in real-world
    applications. How could we use the `useValue` syntax to provide these settings
    in our components? We will learn more by creating settings for our application,
    such as the version number and the title:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，通常会将应用程序设置保存在一个常量对象中。我们如何使用`useValue`语法在我们的组件中提供这些设置呢？我们将通过为我们的应用程序创建设置，例如版本号和标题，来了解更多：
- en: 'Create an `app.settings.ts` file in the `src\app` folder of the Angular CLI
    workspace and add the following contents:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Angular CLI工作区的`src\app`文件夹中创建一个`app.settings.ts`文件，并添加以下内容：
- en: '[PRE50]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You may think we could provide these settings as `{ provide: AppSettings, useValue:
    appSettings }` , but this would throw an error because `AppSettings` is an interface,
    not a class. Interfaces are syntactic sugar in TypeScript that are thrown away
    during compilation. Instead, we should provide an `InjectionToken` object.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '你可能会认为我们可以将这些设置作为`{ provide: AppSettings, useValue: appSettings }`提供，但这样会抛出一个错误，因为`AppSettings`是一个接口，不是一个类。接口是TypeScript中的语法糖，在编译过程中会被丢弃。相反，我们应该提供一个`InjectionToken`对象。'
- en: 'Add the following statement to import the `InjectionToken` class from the `@angular/core`
    npm package:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`@angular/core` npm 包中导入`InjectionToken`类的以下语句添加到其中：
- en: '[PRE51]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Declare the following constant variable that uses the `InjectionToken` type:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明以下使用`InjectionToken`类型的常量变量：
- en: '[PRE52]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Open the `app.component.ts` file and modify the `import` statements as follows:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.component.ts`文件，并按以下方式修改`import`语句：
- en: '[PRE53]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Add the application settings token in the `providers` array of the `@Component`
    decorator:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`@Component`装饰器的`providers`数组中添加应用程序设置令牌：
- en: '[PRE54]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `useValue` syntax is particularly useful when testing Angular applications.
    We will use it extensively when we learn about unit testing in *Chapter 13* ,
    *Unit Testing Angular Applications* .
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`useValue`语法在测试Angular应用程序时特别有用。当我们学习第13章“单元测试Angular应用程序”时，我们将广泛使用它。'
- en: 'Add the following property in the `AppComponent` class:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppComponent`类中添加以下属性：
- en: '[PRE55]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Open the `app.component.html` file and modify the `<footer>` tag to include
    the application version:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.component.html`文件，并修改`<footer>`标签以包含应用程序版本：
- en: '[PRE56]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Run the application using the `ng serve` command and observe the footer in
    the application output:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ng serve`命令运行应用程序，并观察应用程序输出的页脚：
- en: '**Copyright ©2024 All Rights Reserved - v1.0**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**版权所有©2024保留所有权利 - v1.0**'
- en: Note that although the `AppSettings` interface did not play a significant role
    in the injection process, we need it to provide typing on the configuration object.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管`AppSettings`接口在注入过程中没有发挥重要作用，但我们仍需要它来为配置对象提供类型定义。
- en: Angular DI is a powerful and robust mechanism that allows us to manage the dependencies
    of our applications efficiently. The Angular team has put much effort into making
    it simple to use and removed the burden from the developer’s side. As we have
    seen, the combinations are plentiful, and how we will use them depends on the
    use case.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Angular DI（依赖注入）是一个强大且稳健的机制，它允许我们高效地管理应用程序的依赖项。Angular团队投入了大量精力使其易于使用，并减轻了开发者的负担。正如我们所见，组合方式众多，我们将如何使用它们取决于具体的使用场景。
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The Angular DI implementation is the backbone of the Angular framework. Angular
    components delegate complex tasks to Angular services, based on the Angular DI.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Angular DI实现是Angular框架的骨架。Angular组件基于Angular DI将复杂任务委托给Angular服务。
- en: In this chapter, we learned what Angular DI is and how to leverage it by creating
    Angular services. We explored different ways of injecting Angular services into
    components. We saw how to share services between components, isolate services
    in components, and define dependency access through the component tree.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Angular DI 是什么以及如何通过创建 Angular 服务来利用它。我们探讨了将 Angular 服务注入组件的不同方法。我们看到了如何在组件之间共享服务，在组件中隔离服务，以及如何通过组件树定义依赖访问。
- en: Finally, we investigated how to override Angular services by replacing the service
    implementation or transforming existing objects into services.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了如何通过替换服务实现或将现有对象转换为服务来覆盖 Angular 服务。
- en: In the next chapter, we will learn what reactive programming is and how we can
    use observables in the context of Angular applications.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习响应式编程是什么以及我们如何在 Angular 应用程序上下文中使用可观察对象。
