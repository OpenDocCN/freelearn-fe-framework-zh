- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Managing Data with React Router
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Router管理数据
- en: Learning Objectives
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够做到以下几点：
- en: Use React Router to fetch or send data without using `useEffect()` or `useState()`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React Router获取或发送数据，而不使用 `useEffect()` 或 `useState()`
- en: Share data between different routes without using React’s context feature
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不使用React的context功能的情况下，在不同路由间共享数据
- en: Update the UI based on the current data submission status
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据当前数据提交状态更新UI
- en: Create page and action routes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建页面和动作路由
- en: Improve the user experience by deferring the loading of non-critical data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过延迟加载非关键数据来提高用户体验
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the preceding chapter, you learned how to use React Router to load different
    components for different URL paths. This is an important feature as it allows
    you to build multipage websites while still using React.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何使用React Router为不同的URL路径加载不同的组件。这是一个重要的特性，因为它允许你在使用React的同时构建多页面网站。
- en: Routing is a crucial feature for many web applications, and React Router is
    therefore a very important package. But just as most websites need routing, almost
    all websites need to fetch and manipulate data. For example, HTTP requests in
    most websites are sent to load data (such as a list of products or blog posts)
    or to mutate data (for example, to create a product or a blog post).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 路由对于许多Web应用来说是一个关键特性，因此React Router是一个非常重要的包。但就像大多数网站需要路由一样，几乎所有的网站都需要获取和操作数据。例如，在大多数网站中，HTTP请求是用来加载数据（例如产品列表或博客文章）或修改数据（例如创建产品或博客文章）的。
- en: In *Chapter 8* , *Handling Side Effects* , you learned that you can use the
    `useEffect()` Hook and various other React features to send HTTP requests from
    inside a React application. But if you’re using React Router, you get some new,
    even more powerful tools for working with data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第8章* ，*处理副作用* 中，你学习了可以使用 `useEffect()` Hook 和其他各种React特性在React应用内部发送HTTP请求。但如果你使用React
    Router，你将获得一些新的、甚至更强大的工具来处理数据。
- en: This chapter will explore which new features are made available by React Router
    and how they may be used to simplify the process of fetching or sending data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨React Router提供了哪些新功能，以及如何使用这些功能简化数据获取或发送的过程。
- en: Data Fetching and Routing Are Tightly Coupled
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据获取和路由紧密耦合
- en: As mentioned previously, most websites do need to fetch (or send) data, and
    most websites do need more than one page. But it’s important to realize that these
    two concepts are typically closely related.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，大多数网站确实需要获取（或发送）数据，并且大多数网站确实需要多个页面。但重要的是要认识到这两个概念通常是紧密相关的。
- en: Whenever a user visits a new page (such as `/posts` ), it’s likely that some
    data will need to be fetched. In the case of a `/posts` page, the required data
    is probably a list of blog posts that is retrieved from a backend server. The
    rendered React component (such as `Posts` ) must therefore send an HTTP request
    to the backend server, wait for the response, handle the response (as well as
    potential errors), and, ultimately, display the fetched data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户访问新页面（例如 `/posts` ）时，很可能需要获取一些数据。在 `/posts` 页面的情况下，所需的数据可能是一份从后端服务器检索到的博客文章列表。因此，渲染的React组件（例如
    `Posts` ）必须向后端服务器发送HTTP请求，等待响应，处理响应（以及潜在的错误），并最终显示获取到的数据。
- en: Of course, not all pages need to fetch data. Landing pages, “About Us” pages,
    and “Terms & Use” pages probably don’t need to fetch data when a user visits them.
    Instead, data on those pages is likely to be static. It might even be included
    in the source code as it doesn’t change frequently.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并非所有页面都需要获取数据。着陆页、“关于我们”页面和“条款与使用”页面在用户访问时可能不需要获取数据。相反，这些页面上的数据可能是静态的。甚至可能包含在源代码中，因为它不经常改变。
- en: But many pages do need to get data from a backend every time they’re loaded—for
    instance, “Products,” “News,” “Events,” or other infrequently updated pages like
    the “User Profile.”
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但许多页面确实需要在每次加载时从后端获取数据——例如，“产品”、“新闻”、“活动”或其他不经常更新的页面，如“用户资料”。
- en: And data fetching isn’t everything. Most websites also contain features that
    require data submission—be it a blog post that can be created or updated, product
    data that’s administered, or a user comment that can be added. Hence, sending
    data to a backend is also a very common use case.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 数据获取并非一切。大多数网站还包含需要提交数据的功能——无论是可以创建或更新的博客文章，管理的产品数据，还是可以添加的用户评论。因此，向后端发送数据也是一个非常常见的用例。
- en: And beyond requests, components might also need to interact with other browser
    APIs, such as `localStorage` . For example, user settings might need to be fetched
    from storage as a certain page loads.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了请求之外，组件可能还需要与其他浏览器 API 交互，例如 `localStorage`。例如，用户设置可能需要在页面加载时从存储中检索。
- en: Naturally, all these interactions happen on pages. But it might not be immediately
    obvious how tightly data fetching and submission are coupled to routing.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，所有这些交互都在页面上发生。但可能并不立即明显数据获取和提交与路由是如何紧密相连的。
- en: Most of the time, data is fetched when a route becomes active, i.e., when a
    component (the page component) is rendered for the first time. Sure, users might
    also be able to click a button to refresh the data, but while this is optional,
    data fetching upon initial page load is almost always required.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，数据是在路由变为活动状态时获取的，即当组件（页面组件）首次渲染时。当然，用户也可能能够点击按钮来刷新数据，但尽管这是可选的，在页面初始加载时获取数据几乎是必需的。
- en: And when it comes to sending data, there is also a close connection to routing.
    At first sight, it’s not clear how it’s related because, while it makes sense
    to fetch data upon page load, it’s less likely that you will need to send some
    data immediately (except perhaps tracking or analytics data).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到发送数据时，它与路由也有密切的联系。乍一看，可能不清楚它们是如何相关的，因为虽然页面加载时获取数据是有意义的，但立即发送一些数据的需求可能较少（除非可能是跟踪或分析数据）。
- en: But it’s very likely that *after* sending data, you will want to navigate to
    a different page, meaning that it’s actually the other way around, and instead
    of initiating data fetching as a page loads, you want to load a different page
    after sending some data. For example, after an administrator enters some product
    data and submits the form, they should typically be redirected to a different
    page (for example, from `/products/new` to the `/products` page).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在发送数据后，你很可能想要导航到不同的页面，这意味着实际上情况正好相反，你希望在发送一些数据后加载不同的页面。例如，在管理员输入一些产品数据并提交表单后，他们通常会被重定向到不同的页面（例如，从
    `/products/new` 到 `/products` 页面）。
- en: 'The connection between data fetching, submission, and routing can therefore
    be summarized by the following points:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，数据获取、提交和路由之间的关系可以总结如下：
- en: '**Data fetching** often should be initiated when a route becomes active (if
    that page needs data)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据获取**通常应该在路由变为活动状态时启动（如果该页面需要数据）'
- en: After **submitting data** , the user should often be redirected to another route
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**提交数据**后，用户通常会被重定向到另一个路由
- en: Because these concepts are tightly coupled, React Router provides extra features
    that vastly simplify the process of working with data.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些概念紧密相连，React Router 提供了额外的功能，极大地简化了与数据交互的过程。
- en: Sending HTTP Requests without React Router
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不使用 React Router 发送 HTTP 请求
- en: Working with data is not just about sending HTTP requests. As mentioned in the
    previous section, you may also need to store or retrieve data via `localStorage`
    or perform some other operation as a page gets loaded. But sending HTTP requests
    is an especially common scenario and will therefore be the main use case considered
    for the majority of this chapter. Nonetheless, it’s vital to keep in mind that
    what you learn in this chapter is not limited to sending HTTP requests.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据交互不仅仅是发送 HTTP 请求。如前所述，你可能还需要通过 `localStorage` 或执行其他操作来存储或检索数据，当页面加载时。但是，发送
    HTTP 请求是一个特别常见的场景，因此将是本章主要考虑的使用案例。然而，重要的是要记住，本章所学的内容并不仅限于发送 HTTP 请求。
- en: As you will see, React Router provides various features that help with sending
    HTTP requests (or using other data fetching and manipulation APIs), but you can
    also send HTTP requests (or interact with `localStorage` or other APIs) without
    these features. Indeed, *Chapter 8* , *Handling Side Effects* , already taught
    you how HTTP requests can be sent from inside React components with the help of
    `useEffect()` .
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将看到的，React Router 提供了各种功能来帮助发送 HTTP 请求（或使用其他数据获取和操作 API），但你也可以在没有这些功能的情况下发送
    HTTP 请求（或与 `localStorage` 或其他 API 交互）。实际上，*第 8 章*，*处理副作用*，已经教你如何使用 `useEffect()`
    在 React 组件内部发送 HTTP 请求。
- en: When using React Router’s data fetching capabilities, you can get rid of `useEffect()`
    and manual state management.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 React Router 的数据获取功能时，你可以摆脱 `useEffect()` 和手动状态管理。
- en: '**Note**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'Besides jumping back in this book, you can also revisit how data fetching with
    `useEffect()` works via this code example on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/examples/01-data-fetching-classic](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/examples/01-data-fetching-classic)
    .'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除了回到这本书中，你还可以通过 GitHub 上的这个代码示例回顾使用`useEffect()`进行数据获取的方式：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/examples/01-data-fetching-classic](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/examples/01-data-fetching-classic)。
- en: Loading Data with React Router
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React Router 加载数据
- en: 'With React Router, fetching data can be simplified down to this, shorter, code
    snippet:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 React Router，可以简化数据获取到这个更短、更简洁的代码片段：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Believe it or not, it really *is* that much less code than in the examples shown
    in *Chapter 8* . Back then, when using `useEffect()` , separate state slices had
    to be managed to handle loading and error states as well as the received data.
    Though, to be fair, the content that should be displayed in case of an error is
    missing here. It’s in a separate file (which will be shown later), but it would
    only add three extra lines of code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，这确实比*第8章*中展示的例子少很多代码。当时，当使用`useEffect()`时，必须管理单独的状态片段来处理加载、错误状态以及接收到的数据。不过，公平地说，这里缺少了错误情况下应显示的内容。它在一个单独的文件中（稍后将会展示），但这只会增加三行额外的代码。
- en: In the preceding code snippet, you see a couple of new features that haven’t
    been covered yet in the book. The `loader()` function and the `useLoaderData()`
    Hook are added by React Router. These features, along with many others that will
    be explored throughout this chapter, are made available by the React Router package.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你可以看到一些尚未在书中介绍的新功能。`loader()`函数和`useLoaderData()` Hook是由 React Router
    添加的。这些功能，以及本章中将探讨的许多其他功能，都是由 React Router 包提供的。
- en: 'With that library installed, you can set an extra `loader` prop on your route
    definitions. This prop accepts a function that will be executed by React Router
    whenever this route (or one of its child routes, if defined) is activated:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了这个库后，你可以在路由定义上设置一个额外的`loader`属性。这个属性接受一个函数，该函数将由 React Router 在激活此路由（或其定义的子路由，如果有的话）时执行：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This function can be used to perform any data fetching or other tasks required
    to successfully display the page component. The logic for getting that required
    data can therefore be extracted from the component and moved into a separate function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以用来执行任何数据获取或其他任务，以成功显示页面组件。因此，获取所需数据的逻辑可以从组件中提取出来，并移动到单独的函数中。
- en: Since many websites have dozens or even hundreds of routes, adding these loader
    functions inline in the route definition objects quickly leads to complex and
    confusing route definitions. For this reason, you will typically add (and export)
    the `loader()` function in the same file that contains the component that needs
    the data.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多网站有数十个甚至数百个路由，将加载函数内联添加到路由定义对象中会迅速导致复杂且令人困惑的路由定义。因此，你通常会（并导出）在包含需要数据的组件的同一文件中添加`loader()`函数。
- en: 'When setting up the route definitions, you can then import the component and
    its `loader` function and use it like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置路由定义时，你可以导入组件及其`loader`函数，并像这样使用它：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Assigning an alias ( `postsLoader` , in this example) to the imported `loader`
    function is optional but recommended since you most likely have multiple `loader`
    functions from different components, which would otherwise lead to name clashes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，将导入的`loader`函数分配一个别名（例如`postsLoader`）是可选的，但推荐这样做，因为你很可能有来自不同组件的多个`loader`函数，否则可能会导致名称冲突。
- en: '**Note**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Technically, you don’t need to name your functions `loader` . You could use
    any name and assign them as values for the `loader` property in the route definition.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，你不需要将你的函数命名为`loader`。你可以使用任何名称，并将它们作为路由定义中`loader`属性的值。
- en: But using `loader` as a function name does not just follow the convention; it
    also has the advantage that React Router’s built-in lazy loading support (covered
    in the previous chapter) lazy-loads the `loader` function when needed. It fails
    to do that if you pick any other name.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 但将`loader`用作函数名不仅遵循了惯例，而且还有这样的优势：React Router 的内置懒加载支持（在上一章中介绍）在需要时懒加载`loader`函数。如果你选择任何其他名称，它将无法做到这一点。
- en: With this `loader` defined, React Router will execute the `loader()` function
    whenever a route is activated. To be precise, the `loader()` function is called
    before the component function is executed (that is, before the component is rendered).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了此`loader`之后，React Router将在激活任何路由时执行`loader()`函数。更准确地说，`loader()`函数是在组件函数执行之前被调用的（即，在组件渲染之前）。
- en: '![img](img/B31339_14_01.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_14_01.png)'
- en: 'Figure 14.1: The Posts component is rendered after the loader is executed'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1：在`loader`执行之后渲染`Posts`组件
- en: This also explains why the `Posts` component example at the beginning of this
    section contained no code that handled any loading state. There simply *is* no
    loading state since a component function is only executed after its loader has
    finished (and the data is available). React Router won’t finish the page transition
    until the `loader()` function has finished its job (though, as you will learn
    toward the end of this chapter, there is a way of changing this behavior).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这也解释了为什么本节开头提到的`Posts`组件示例中没有处理任何加载状态的代码。因为实际上*根本就没有加载状态*，因为组件函数只有在它的`loader`完成（并且数据可用）之后才会执行。React
    Router不会完成页面转换，直到`loader()`函数完成其工作（尽管，如你将在本章末尾学到的那样，有一种方法可以改变这种行为）。
- en: The `loader()` function can perform any operation of your choice (such as sending
    an HTTP request, or reaching out to browser storage via the `localStorage` API).
    Inside that function, you should return the data that should be exposed to the
    component function. It’s also worth noting that the `loader()` function can return
    any kind of data. It may also return a `Promise` object that then resolves to
    any kind of data. In that case, React Router will automatically wait for the `Promise`
    to be fulfilled before executing the related route component function. The `loader()`
    function can thus perform both asynchronous and synchronous tasks.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`loader()`函数可以执行任何你选择的操作（例如发送HTTP请求，或通过`localStorage` API访问浏览器存储）。在该函数内部，你应该返回应该暴露给组件函数的数据。还值得注意的是，`loader()`函数可以返回任何类型的数据。它也可能返回一个`Promise`对象，该对象随后解析为任何类型的数据。在这种情况下，React
    Router将自动等待`Promise`得到解决，在`useLoaderData()`被调用时提供解析后的数据。因此，`loader()`函数可以执行异步和同步任务。'
- en: '**Note**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: It’s important to understand that the `loader()` function, like all the other
    code that makes up your React app, executes on the client side (that is, in the
    browser of a website visitor). Therefore, you may perform any action that could
    be performed anywhere else (for example, inside `useEffect()` ) in your React
    app as well.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '重要的是要理解，`loader()`函数，就像构成你的React应用的其它所有代码一样，在客户端执行（即在网站访问者的浏览器中）。因此，你可以在你的React应用中执行任何可以在任何其他地方执行的操作（例如，在`useEffect()`中）。 '
- en: You must not try to run code that belongs to the server side. Directly reaching
    out to a database, writing to the file system, or performing any other server-side
    tasks will fail or introduce security risks, meaning that you might accidentally
    expose database credentials on the client side.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你绝对不应该尝试运行属于服务器端的代码。直接访问数据库、写入文件系统或执行任何其他服务器端任务都会失败或引入安全风险，这意味着你可能会意外地在客户端暴露数据库凭证。
- en: Getting Access to Loaded Data
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取加载的数据
- en: 'Of course, the component that belongs to a `loader` (that is, the component
    that’s part of the same route definition) needs the data returned by the `loader`
    . This is why React Router offers a new Hook for accessing that data: the `useLoaderData()`
    Hook.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，属于`loader`的组件（即属于同一路由定义的组件）需要`loader`返回的数据。这就是为什么React Router提供了一个新的Hook来访问这些数据：`useLoaderData()`
    Hook。
- en: When called inside a component function, this Hook yields the data returned
    by the `loader` that belongs to the active route. If that returned data is a `Promise`
    , React Router (as mentioned earlier) will automatically wait for that `Promise`
    to resolve and provide the resolved data when `useLoaderData()` is called.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当在组件函数内部调用此Hook时，它将返回属于活动路由的`loader`返回的数据。如果返回的数据是一个`Promise`，React Router（如前所述）将自动等待该`Promise`解决，并在`useLoaderData()`被调用时提供解析后的数据。
- en: The `loader()` function may also return an HTTP response object (or a `Promise`
    resolving to a `Response` ) object. This is the case in the preceding example
    because the `fetch()` function yields a `Promise` that resolves to an object of
    type `Response` . In that instance, React Router automatically extracts the response
    body and provides direct access to the data that was attached to the response
    (via `useLoaderData()` ).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`loader()` 函数也可能返回一个 HTTP 响应对象（或一个解析为 `Response` 的 `Promise`）。在先前的例子中就是这样，因为
    `fetch()` 函数产生一个解析为 `Response` 类型的对象的 `Promise`。在这种情况下，React Router 自动提取响应体，并提供直接访问附加到响应中的数据（通过
    `useLoaderData()`）。'
- en: '**Note**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'If a response should be returned, the returned object must adhere to the standard
    `Response` interface, as defined here: [https://developer.mozilla.org/en-US/docs/Web/API/Response](https://developer.mozilla.org/en-US/docs/Web/API/Response)
    .'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应该返回响应，返回的对象必须遵循这里定义的标准 `Response` 接口：[https://developer.mozilla.org/en-US/docs/Web/API/Response](https://developer.mozilla.org/en-US/docs/Web/API/Response)。
- en: Returning responses might be strange at first. After all, the `loader()` code
    is still executed inside the browser (not on a server). Therefore, technically,
    no request was sent, and no response should be required (since the entire code
    is executed in the same environment, that is, the browser).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 返回响应可能一开始会显得有些奇怪。毕竟，`loader()` 代码仍然在浏览器内部执行（而不是在服务器上）。因此，技术上没有发送请求，也不应该需要响应（因为整个代码都在同一个环境中执行，即浏览器）。
- en: For that reason, you can but don’t have to return a response; you may return
    any kind of value. React Router just also supports responses as one possible return
    value type.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以返回响应，但不必这样做；您可以返回任何类型的值。React Router 也支持响应作为可能的返回值类型之一。
- en: '`useLoaderData()` can be called in any component rendered by the currently
    active route component. That may be the route component itself ( `Posts` , in
    the preceding example), but it may also be any nested component.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`useLoaderData()` 可以在任何由当前活动路由组件渲染的组件中调用。这可能就是路由组件本身（在先前的例子中是 `Posts`），也可能是任何嵌套组件。'
- en: 'For example, `useLoaderData()` can also be used in a `PostsList` component
    that’s included in the `Posts` component (which has a `loader` added to its route
    definition):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`useLoaderData()` 也可以在包含在 `Posts` 组件中的 `PostsList` 组件中使用（该组件在其路由定义中添加了 `loader`）：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For this example, the `Posts` component file looks like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，`Posts` 组件文件看起来是这样的：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This means that `useLoaderData()` can be used in exactly the place where you
    need the data. The `loader()` function can also be defined wherever you want but
    it must be added to the route where the data is required.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `useLoaderData()` 可以在您需要数据的确切位置使用。`loader()` 函数也可以定义在任何您想要的地方，但它必须添加到需要数据的路由中。
- en: '**Note**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Depending on the React Router version being used, you might get a warning related
    to “No HydrateFallback” element being provided. You can ignore this warning as
    it only matters when using server-side rendering.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根据使用的 React Router 版本，您可能会收到有关“未提供 'No HydrateFallback' 元素”的警告。您可以忽略这个警告，因为它仅在服务器端渲染时才有意义。
- en: '**Note**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'You can also explore this code example on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/examples/02-data-fetching-react-router](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/examples/02-data-fetching-react-router)
    .'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在 GitHub 上探索这个代码示例：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/examples/02-data-fetching-react-router](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/examples/02-data-fetching-react-router)。
- en: Loading Data for Dynamic Routes
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态路由的数据加载
- en: For most websites, it’s unlikely that static, pre-defined routes alone will
    be sufficient to meet your needs. For instance, if you created a blogging site
    with exclusively static routes, you would be limited to a simple list of blog
    posts on `/posts` . To add more details about a selected blog post on routes such
    as `/posts/1` or `/posts/2` (for posts with different `id` values) you would need
    to include dynamic routes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数网站来说，仅使用静态、预定义的路由很可能不足以满足您的需求。例如，如果您创建了一个仅使用静态路由的博客网站，您将仅限于在 `/posts` 路径上的简单博客文章列表。要添加关于在
    `/posts/1` 或 `/posts/2`（对于具有不同 `id` 值的文章）等路径上所选博客文章的更多详细信息，您需要包含动态路由。
- en: 'Of course, React Router also supports data fetching with the help of the `loader()`
    function for dynamic routes:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，React Router 也支持通过 `loader()` 函数帮助动态路由进行数据获取：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `PostDetails` component and its `loader` function can be implemented like
    this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`PostDetails` 组件及其 `loader` 函数可以像这样实现：'
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If it looks very similar to the `Posts` component in the *Loading Data with
    React Router* section, that’s no coincidence. Because the `loader()` function
    works in exactly the same way, there is just one extra feature being used to get
    hold of the dynamic path segment value: a `params` object that’s made available
    by React Router.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它与 *使用 React Router 加载数据* 部分的 `Posts` 组件看起来非常相似，这并非巧合。因为 `loader()` 函数以完全相同的方式工作，只是使用了一个额外的功能来获取动态路径段值：由
    React Router 提供的 `params` 对象。
- en: '**Note**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'You can also explore this code example on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/examples/03-dynamic-routes](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/examples/03-dynamic-routes)
    .'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在 GitHub 上探索这个代码示例：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/examples/03-dynamic-routes](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/examples/03-dynamic-routes)。
- en: When adding a `loader()` function to a route definition, React Router calls
    that function whenever the route becomes active, right before the component is
    rendered. When executing that function, React Router passes an object that contains
    extra information as an argument to `loader()` .
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当向路由定义添加 `loader()` 函数时，React Router 在组件渲染之前，即路由变为活跃状态时调用该函数。在执行该函数时，React Router
    将包含额外信息的对象作为参数传递给 `loader()`。
- en: 'This object passed to `loader()` includes two main properties:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `loader()` 的对象包括两个主要属性：
- en: A `request` property that contains an object with more details about the request
    that led to the route activation
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含导致路由激活的请求更多详细信息的 `request` 属性
- en: A `params` property that yields an object containing a key-value map of all
    dynamic route parameters for the active route
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个返回包含所有动态路由参数键值映射的对象的 `params` 属性
- en: The `request` object doesn’t matter for this example and will be discussed in
    the next section. But the `params` object contains an `id` property that carries
    the `id` value of the post for which the route is loaded. The property is named
    `id` because, in the route definition, `/posts/:id` was chosen as a path. If a
    different placeholder name had been chosen, a property with that name would have
    been available on `params` (for example, for `/posts/:postId` , this would be
    `params.postId` ). This behavior is similar to the `params` object yielded by
    `useParams()` , as explained in *Chapter 13* , *Multipage Apps with React Router*
    .
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子来说，`request` 对象并不重要，将在下一节中进行讨论。但 `params` 对象包含一个 `id` 属性，它携带了加载该路由的帖子的
    `id` 值。该属性被命名为 `id`，因为在路由定义中，`/posts/:id` 被选为路径。如果选择了不同的占位符名称，那么在 `params` 上将会有一个具有该名称的属性可用（例如，对于
    `/posts/:postId`，这将是一个 `params.postId`）。这种行为与在 *第 13 章*，*使用 React Router 的多页应用*
    中解释的 `useParams()` 返回的 `params` 对象类似。
- en: With the help of the `params` object and the post `id` , the appropriate post
    `id` can be included in the outgoing request URL (for the `fetch()` request),
    and hence the correct post data can be loaded from the backend API. Once the data
    arrives, React Router will render the `PostDetails` component and expose the loaded
    post via the `useLoaderData()` Hook.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `params` 对象和帖子 `id`，可以在出站请求 URL（对于 `fetch()` 请求）中包含适当的帖子 `id`，从而从后端 API 加载正确的帖子数据。一旦数据到达，React
    Router 将渲染 `PostDetails` 组件，并通过 `useLoaderData()` 钩子公开加载的帖子。
- en: Loaders, Requests, and Client-Side Code
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载器、请求和客户端代码
- en: In the preceding section, you learned about a `request` object being provided
    to the `loader()` function. Getting such a `request` object might be confusing
    because React Router is a client-side library—all the code executes in the browser,
    not on a server. Therefore, no request should reach the React app (as HTTP requests
    are sent from the client to the server, not between JavaScript functions on the
    client side).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，你学习了 `loader()` 函数提供的 `request` 对象。获取这样的 `request` 对象可能会令人困惑，因为 React
    Router 是一个客户端库——所有代码都在浏览器中执行，而不是在服务器上。因此，不应该有请求到达 React 应用（因为 HTTP 请求是从客户端发送到服务器的，而不是客户端
    JavaScript 函数之间的请求）。
- en: And, indeed, there is no request being sent via HTTP. Instead, React Router
    creates a request object via the browser’s built-in `Request` interface to use
    it as a “data vehicle.” This request is not sent via HTTP, but it’s used as a
    value for the `request` property on the data object that is passed to your `loader()`
    function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，并没有通过 HTTP 发送任何请求。相反，React Router 通过浏览器内置的 `Request` 接口创建一个请求对象，用作“数据载体”。这个请求不是通过
    HTTP 发送的，但它被用作传递给 `loader()` 函数的数据对象上的 `request` 属性的值。
- en: '**Note**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: For more information on the built-in `Request` interface, visit [https://developer.mozilla.org/en-US/docs/Web/API/Request](https://developer.mozilla.org/en-US/docs/Web/API/Request)
    .
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 关于内置的 `Request` 接口更多信息，请访问 [https://developer.mozilla.org/en-US/docs/Web/API/Request](https://developer.mozilla.org/en-US/docs/Web/API/Request)
    。
- en: This `request` object will be unnecessary in many `loader` functions, but there
    are occasional scenarios in which you can extract useful information from that
    object—information that might be needed in the `loader` to fetch the right data.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `request` 对象在许多 `loader` 函数中将不再需要，但在某些情况下，你可以从该对象中提取有用的信息——这些信息可能在 `loader`
    中用于获取正确数据。
- en: 'For example, you can use the `request` object and its `url` property to get
    access to any search parameters (query parameters) that may be included in the
    currently active page’s URL:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用 `request` 对象及其 `url` 属性来获取访问任何可能包含在当前活动页面 URL 中的搜索参数（查询参数）：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this code snippet, the `request` value is used to get hold of a query parameter
    value that’s used in the React app URL. That value is then used in an outgoing
    request.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，使用 `request` 值获取用于 React 应用程序 URL 中的查询参数值。然后，该值用于出站请求。
- en: However, it is vital that you keep in mind that the code inside your `loader()`
    function, just like all your other React code, always executes on the client side.
    If, instead, you want to execute code on a server (and, for example, fetch data
    on the server side), you need to use **server-side rendering** ( **SSR** ) or
    some React framework that implements SSR, like Next.js. SSR and Next.js will be
    covered in the next chapter, *Chapter 15* , *Server-side Rendering & Building
    Fullstack Apps with Next.js* , and the chapters thereafter.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你必须牢记，你的 `loader()` 函数内部的代码，就像你所有的其他 React 代码一样，总是在客户端执行。如果你想在服务器上执行代码（例如，在服务器端获取数据），你需要使用
    **服务器端渲染**（**SSR**）或实现 SSR 的某些 React 框架，如 Next.js。SSR 和 Next.js 将在下一章，*第 15 章*，*服务器端渲染与使用
    Next.js 构建全栈应用程序*，以及随后的章节中介绍。
- en: Layouts Revisited
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视布局
- en: React Router supports the concept of layout routes. These are routes that contain
    other routes and render those other routes as nested children. As you may recall,
    this concept was introduced in *Chapter 13* , *Multipage Apps with React Router*
    .
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 支持布局路由的概念。这些是包含其他路由并将这些其他路由作为嵌套子路由渲染的路由。如您所回忆的，这个概念在第 13 章，*使用
    React Router 的多页应用程序* 中介绍。
- en: 'Conveniently, layout routes can also be used for sharing data across nested
    routes. Consider this example website:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的是，布局路由也可以用于在嵌套路由之间共享数据。考虑以下示例网站：
- en: '![img](img/B31339_14_02.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_14_02.png)'
- en: 'Figure 14.2: A website with a header, a sidebar, and some main content'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2：一个包含页眉、侧边栏和一些主要内容的网站
- en: This website has a header with a navigation bar, a sidebar showing a list of
    available posts, and a main area that displays the currently selected blog post.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 该网站有一个包含导航栏的页眉，一个显示可用帖子列表的侧边栏，以及一个显示当前所选博客文章的主要区域。
- en: 'This example includes two layout routes that are nested into each other:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例包括两个嵌套的布局路由：
- en: The root layout route, which includes the top navigation bar that is shared
    across all pages
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根布局路由，它包括跨越所有页面的顶部导航栏
- en: A posts layout route, which includes the sidebar and the main content of its
    child routes (for example, the details for a selected post)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含侧边栏及其子路由（例如，所选帖子的详细信息）主要内容的帖子布局路由
- en: 'The route definitions code looks like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 路由定义代码看起来像这样：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With this setup, both the `<Posts />` and the `<PostDetails />` components are
    rendered next to the sidebar (since the sidebar is part of the `<PostsLayout />`
    element).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种设置，`<Posts />` 和 `<PostDetails />` 组件都渲染在侧边栏旁边（因为侧边栏是 `<PostsLayout />`
    元素的一部分）。
- en: 'The interesting part is that the `/posts` route (i.e., the layout route) loads
    the post data, as it has the `postsLoader` assigned to it, and so the `PostsLayout`
    component file looks like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`/posts` 路径（即布局路径）会加载帖子数据，因为它被分配了 `postsLoader`，因此 `PostsLayout` 组件文件看起来像这样：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since layout routes are also regular routes, you can add `loader()` functions
    and use `useLoaderData()` just as you could in any other route. However, because
    layout routes are activated for multiple child routes, their data is also displayed
    for different routes. In the preceding example, the list of blog posts is always
    displayed on the left side of the screen, no matter if a user visits `/posts`
    or `/posts/10` :'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于布局路由也是常规路由，因此您可以添加 `loader()` 函数并使用 `useLoaderData()`，就像在任意其他路由中一样。然而，由于布局路由为多个子路由激活，它们的数据也会显示在不同的路由上。在前面的例子中，无论用户访问
    `/posts` 还是 `/posts/10`，博客帖子列表始终显示在屏幕的左侧：
- en: '![img](img/B31339_14_03.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_14_03.png)'
- en: 'Figure 14.3: The same layout and data are used for different child routes'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3：相同的布局和数据用于不同的子路由
- en: In this screenshot, the layout and data used do not change as different child
    routes are activated. React Router also avoids unnecessary data re-fetching (for
    the blog posts list data) as you switch between child routes. It’s smart enough
    to realize that the surrounding layout hasn’t changed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在此屏幕截图中，随着不同的子路由被激活，所使用的布局和数据不会改变。React Router 还避免了在切换子路由时进行不必要的数据重新获取（对于博客帖子列表数据）。它足够智能，能够意识到周围的布局没有改变。
- en: Reusing Data across Routes
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在不同路由间复用数据
- en: Layout routes do not just help you share components and markup. They also allow
    you to load and share data across a layout route and its child routes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 布局路由不仅可以帮助您共享组件和标记。它们还允许您在布局路由及其子路由之间加载和共享数据。
- en: 'For example, the `PostDetails` component (that is, the component that’s rendered
    for the `/posts/:id` route) needs the data for a single post, and that data can
    be retrieved via a `loader` attached to the `/posts/:id` route:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`PostDetails` 组件（即渲染 `/posts/:id` 路由的组件）需要一个帖子的数据，并且可以通过附加到 `/posts/:id`
    路由的 `loader` 来检索这些数据：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This example was discussed earlier in this chapter in the *Loading Data for
    Dynamic Routes* section. This approach is fine, but in some situations, this extra
    HTTP request can be avoided. For example, the following route configuration can
    be simplified, and the extra `postDetailsLoader` on the child route can be avoided:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子在本书的 *为动态路由加载数据* 部分已经讨论过。这种方法是可行的，但在某些情况下，可以避免额外的 HTTP 请求。例如，以下路由配置可以简化，并且可以避免在子路由上的额外
    `postDetailsLoader`：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, the `PostsLayout` route already fetches a list of all posts.
    That layout component is also active for the `PostDetails` route. In such a scenario,
    fetching a single post is unnecessary, since all the data has already been fetched
    for the list of posts. Of course, a specific `postDetailsLoader` loader for the
    `PostDetails` child route would be required if the request for the list of posts
    (by `postsLoader` on the `PostsLayout` route) didn’t yield all the data required
    by `PostDetails` .
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，`PostsLayout` 路由已经获取了所有帖子的列表。该布局组件也对 `PostDetails` 路由有效。在这种情况下，获取单个帖子是不必要的，因为已经为帖子列表获取了所有数据。当然，如果帖子列表的请求（在
    `PostsLayout` 路由上的 `postsLoader`）没有提供 `PostDetails` 所需的所有数据，则需要为 `PostDetails`
    子路由提供一个特定的 `postDetailsLoader` 加载器。
- en: But if all the data is available, React Router allows you to tap into the loader
    data of a parent route component via the `useRouteLoaderData()` Hook.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果所有数据都已可用，React Router 允许您通过 `useRouteLoaderData()` 钩子访问父路由组件的加载器数据。
- en: 'This Hook can be used like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此钩子可以这样使用：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`useRouteLoaderData()` requires a route identifier as an argument. It requires
    an identifier assigned to the ancestor route that contains the data that should
    be reused. You can assign such an identifier via the `id` property to your routes
    as part of the route definitions code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`useRouteLoaderData()` 需要一个路由标识符作为参数。它需要一个分配给包含应复用数据的祖先路由的标识符。您可以通过将 `id` 属性分配给路由作为路由定义代码的一部分来指定此类标识符：'
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `useRouteLoaderData()` Hook then returns the same data `useLoaderData()`
    yields in that route to which you added the `id` . In this example, it would provide
    a list of blog posts.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 `useRouteLoaderData()` 钩子返回与您添加 `id` 的路由中 `useLoaderData()` 产生的相同数据。在本例中，它将提供一个博客帖子列表。
- en: 'In `PostDetails` , this Hook can therefore be used like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `PostDetails` 中，此钩子可以这样使用：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `useParams()` Hook is used to get access to the dynamic route parameter
    value, and the `find()` method is used on the list of posts to identify a single
    post with a fitting `id` property. In this example, you would thus avoid sending
    an unnecessary HTTP request by reusing data that’s already available.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`useParams()`钩子来获取动态路由参数值，并在帖子列表上使用`find()`方法来识别具有合适`id`属性的单一帖子。在这个例子中，你将避免发送不必要的HTTP请求，通过重用已经可用的数据。
- en: Therefore, the `postDetailsLoader` that was part of the `/posts/:id` route definition
    can be removed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`/posts/:id`路由定义中作为`postDetailsLoader`的一部分可以删除。
- en: Handling Errors
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: In the first example at the very beginning of this chapter (where the HTTP request
    was sent with the help of `useEffect()` ), the code did not just handle the success
    case but also possible errors. In all the React Router-based examples since then,
    error handling has been omitted. Error handling was not discussed up to this point
    because, while React Router plays an important role in error handling, it’s vital
    to first gain a solid understanding of how React Router works in general and how
    it helps with data fetching. But, of course, errors can’t always be avoided and
    definitely should not be ignored.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头非常早期的第一个例子（其中使用`useEffect()`发送了HTTP请求），代码不仅处理了成功情况，还处理了可能的错误。从那时起，所有基于React
    Router的例子中，错误处理都被省略了。错误处理尚未讨论，因为虽然React Router在错误处理中扮演着重要角色，但首先必须牢固地理解React Router的一般工作原理以及它如何帮助数据获取。但是，当然，错误并不总是可以避免的，并且绝对不应该被忽视。
- en: 'Thankfully, handling errors is also very straightforward and easy when using
    React Router’s data capabilities. You can set an `errorElement` property on your
    route definitions and define the element that should be rendered when an error
    occurs:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，当使用React Router的数据功能时，错误处理也非常简单和容易。你可以在你的路由定义上设置一个`errorElement`属性，并定义当发生错误时应渲染的元素：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This `errorElement` property can be set on any route definition of your choice,
    or even multiple route definitions simultaneously. React Router will render the
    `errorElement` of the route closest to the place where the error was thrown.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`errorElement`属性可以设置在任何你选择的路由定义上，甚至可以同时设置多个路由定义。React Router将会渲染最接近错误抛出位置的路由的`errorElement`。
- en: 'In the preceding snippet, no matter which route produced an error, it would
    always be the root route’s `errorElement` that was displayed (since that’s the
    only route definition with an `errorElement` ). But if you also added an `errorElement`
    to the `/posts` route, and the `:id` route produced an error, it would be the
    `errorElement` of the `/posts` route that was shown on the screen, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，无论哪个路由产生了错误，都会显示根路由的`errorElement`（因为这是唯一带有`errorElement`的路由定义）。但是，如果你也向`/posts`路由添加了一个`errorElement`，并且`:id`路由产生了错误，那么屏幕上显示的将是`/posts`路由的`errorElement`，如下所示：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This allows you, the developer, to set up fine-grained error handling.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你，作为开发者，设置精细的错误处理。
- en: 'Inside the component used as a value for the `errorElement` , you can get access
    to the error that was thrown via the `useRouteError()` Hook:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在用作`errorElement`值的组件内部，你可以通过`useRouteError()`钩子访问抛出的错误：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With this simple yet effective error-handling solution, React Router allows
    you to avoid managing error states yourself. Instead, you simply define a standard
    React element (via the `element` prop) that should be displayed when things go
    right and an `errorElement` to be displayed if things go wrong.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简单而有效的错误处理解决方案，React Router允许你避免自己管理错误状态。相反，你只需定义一个标准的React元素（通过`element`属性），当一切顺利时应该显示，以及一个`errorElement`，当事情出错时应该显示。
- en: Onward to Data Submission
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据提交之旅
- en: Thus far, you’ve learned a lot about data fetching. But as mentioned earlier
    in this chapter, React Router also helps with data submission.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学到了很多关于数据获取的知识。但如本章前面所述，React Router也帮助处理数据提交。
- en: 'Consider the following example component:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例组件：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This component renders a `<form>` element that allows users to enter the details
    for a new post. Due to the following route configuration, the component is displayed
    whenever the `/posts/new` route becomes active:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件渲染一个`<form>`元素，允许用户输入新帖子的详细信息。由于以下路由配置，组件在`/posts/new`路由变为活动状态时显示：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Without React Router’s data-related features, you might handle form submission
    like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有React Router的数据相关功能的情况下，你可能这样处理表单提交：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Just as before when fetching data, this requires quite a bit of code and logic
    to be added to the component function. You must manually extract the submitted
    data, send the HTTP request, and navigate to a different page after receiving
    an HTTP response.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前在获取数据时一样，这需要在组件函数中添加相当多的代码和逻辑。你必须手动提取提交的数据，发送 HTTP 请求，并在收到 HTTP 响应后导航到不同的页面。
- en: In addition, you might also need to manage loading state and potential errors
    (excluded in the preceding example).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可能还需要管理加载状态和潜在的错误（在先前的示例中省略）。
- en: Again, React Router offers some help. Where a `loader()` function can be added
    to handle data loading, an `action()` function can be defined to handle data submission.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，React Router 提供了一些帮助。当可以添加 `loader()` 函数来处理数据加载时，可以定义 `action()` 函数来处理数据提交。
- en: 'When using the new `action()` function, the preceding example component looks
    like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用新的 `action()` 函数时，前面的示例组件看起来像这样：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code might be similar in length but it has the advantage of moving all
    the data submission logic out of the component function into a special `action()`
    function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的长度可能相似，但它有一个优点，就是将所有数据提交逻辑从组件函数移动到特殊的 `action()` 函数中。
- en: 'Besides the addition of the `action()` function, the example code snippet includes
    the following important changes and features:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 除了添加 `action()` 函数之外，示例代码片段还包括以下重要更改和功能：
- en: A `<Form>` component that’s used instead of `<form>` .
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `<Form>` 组件代替 `<form>`。
- en: The `method` prop is set on the `<Form>` (to `"post"` ).
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method` 属性被设置在 `<Form>` 元素上（设置为 `"post"`）。'
- en: The submitted data is extracted as `FormData` by calling `request.formData()`
    .
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交的数据通过调用 `request.formData()` 被提取为 `FormData`。
- en: The user is redirected via a newly added `redirect()` function (instead of `useNavigate()`
    and `navigate()` ).
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户通过新添加的 `redirect()` 函数进行重定向（而不是 `useNavigate()` 和 `navigate()`）。
- en: But what are these elements about?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些元素是什么？
- en: Working with action() and Form Data
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 action() 和表单数据一起工作
- en: 'Just like `loader()` , `action()` is a special function that can be added to
    route definitions, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `loader()` 一样，`action()` 是一个可以添加到路由定义中的特殊函数，如下所示：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With the `action` prop set on a route definition, the assigned function is automatically
    called whenever a `<Form>` (not `<form>` !) targeting this route is submitted.
    `Form` is a component provided by React Router that should be used instead of
    the default `<form>` element.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当在路由定义上设置 `action` 属性时，指定的函数会在提交目标此路由的 `<Form>`（不是 `<form>`！）时自动调用。`Form` 是
    React Router 提供的一个组件，应代替默认的 `<form>` 元素使用。
- en: Internally, `Form` uses the default `<form>` element but prevents the browser
    default of creating and sending an HTTP request upon form submission. Instead,
    React Router creates a `FormData` object and calls the `action()` function defined
    for the route that’s targeted by the `<Form>` , passing a request object, based
    on the built-in `Request` interface, to it. The passed request object contains
    the form data generated by React Router. Later in this chapter, in the *Controlling
    Which <Form> Triggers Which Action* section, you’ll learn how to control which
    `action()` function of which route will be executed by React Router.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，`Form` 使用默认的 `<form>` 元素，但阻止浏览器在表单提交时创建和发送 HTTP 请求。相反，React Router 创建一个 `FormData`
    对象，并调用为 `<Form>` 目标路由定义的 `action()` 函数，传递一个基于内置 `Request` 接口的对象，并将其传递给它。传递的对象包含由
    React Router 生成的表单数据。在本章的 *控制哪个 <Form> 触发哪个动作* 部分，你将学习如何控制 React Router 将执行哪个路由的
    `action()` 函数。
- en: '**Note**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Handling form submissions with the help of “actions” might sound familiar— *Chapter
    9* , *Handling User Input & Forms with Form Actions* , discussed a similar concept.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“actions”来处理表单提交可能听起来很熟悉——*第9章*，*使用表单动作处理用户输入和表单*，讨论了类似的概念。
- en: But whereas *Chapter 9* discussed a feature built into React (which was not
    related or dependent on routing), this chapter explores a core concept of React
    Router.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 但 whereas *第9章* 讨论了内置在 React 中的功能（这与路由无关或依赖），本章探讨了 React Router 的核心概念。
- en: Ultimately, you can use either approach for handling form submissions. Or you
    could use none of the two and instead handle the `submit` event manually via `onSubmit`
    .
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你可以使用任何一种处理表单提交的方法。或者你也可以不使用这两种方法，而是通过 `onSubmit` 手动处理 `submit` 事件。
- en: But when using routing with React Router, you’ll often end up with cleaner,
    more concise code that integrates smoothly with other routing features like redirects
    when using React Router’s `<Form>` component and `action()` function.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但当使用 React Router 进行路由时，你通常会得到更干净、更简洁的代码，这些代码可以与其他路由功能（如使用 React Router 的 `<Form>`
    组件和 `action()` 函数时的重定向）无缝集成。
- en: The form data object that is created by calling `request.formData()` includes
    all form input values entered into the submitted form. To be registered, an input
    element such as `<input>` , `<select>` , or `<textarea>` must have the `name`
    attribute assigned to it. The values set for those `name` attributes can later
    be used to extract the entered data.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `request.formData()` 创建的表单数据对象包括提交的表单中输入的所有表单输入值。为了注册，输入元素（如 `<input>`、`<select>`
    或 `<textarea>`）必须分配一个 `name` 属性。为这些 `name` 属性设置的值可以后来用来提取输入的数据。
- en: The `request` object (that contains the form data) received by the `action()`
    function is created by React Router when the form is submitted.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`action()` 函数接收到的 `request` 对象（包含表单数据）是由 React Router 在表单提交时创建的。'
- en: The `Form` component defines the HTTP method of the request object. By setting
    the `Form` 's `method` prop to either `"get"` (the default) or `"post"` , you
    control what happens when the form is submitted. When setting `method="get"` (or
    when not setting `method` at all), a regular URL navigation will occur—just as
    if a link to a certain path were clicked. Any entered form values will be encoded
    as URL search parameters in that case. To trigger an `action()` function, `<Form>`
    's `method` must be set to `"post"` instead.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`Form` 组件定义了请求对象的 HTTP 方法。通过将 `Form` 的 `method` 属性设置为 `"get"`（默认值）或 `"post"`，你可以控制表单提交时会发生什么。当设置
    `method="get"`（或根本不设置 `method`）时，将发生常规的 URL 导航——就像点击了指向某个路径的链接一样。在这种情况下，任何输入的表单值都将作为
    URL 查询参数进行编码。要触发 `action()` 函数，`<Form>` 的 `method` 必须设置为 `"post"`。'
- en: However, it’s important to understand that the request is not sent via HTTP
    since `action()` , just like `loader()` or the component function, still executes
    in the browser rather than on a server.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要理解，请求不是通过 HTTP 发送的，因为 `action()`，就像 `loader()` 或组件函数一样，仍然在浏览器中执行，而不是在服务器上执行。
- en: 'The `action()` function then receives an object with a `request` property that
    contains the created request object with the included form data. This `request`
    object can be used to extract the values entered into the form input fields like
    this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`action()` 函数接收一个包含 `request` 属性的对象，该属性包含包含表单数据的创建请求对象。此 `request` 对象可以用来提取表单输入字段中输入的值，如下所示：
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The built-in `formData()` method yields a `Promise` that resolves to a `FormData`
    object that offers a `get()` method that can be used to get an entered value by
    its identifier (that is, by the `name` attribute value set on the input element).
    For example, the value entered into `<input name="title">` could be retrieved
    via `formData.get('title')` .
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 `formData()` 方法返回一个解析为 `FormData` 对象的 `Promise`，该对象提供了一个 `get()` 方法，可以用来通过其标识符（即，通过在输入元素上设置的
    `name` 属性值）获取输入的值。例如，输入到 `<input name="title">` 中的值可以通过 `formData.get('title')`
    来检索。
- en: Alternatively, you can follow the approach chosen in the preceding code snippet
    and convert the `formData` object to a simple key-value object via `Object.fromEntries(formData)`
    . This object ( `postData` , in the preceding example) contains the names set
    on the form input elements as properties and the entered values as values for
    those properties (meaning that `postData.title` would yield the value entered
    in `<input name="title">` ).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以遵循前面代码片段中选择的方案，通过 `Object.fromEntries(formData)` 将 `formData` 对象转换为简单的键值对象。此对象（在前面的例子中为
    `postData`）包含在表单输入元素上设置的名称作为属性，以及这些属性的值（这意味着 `postData.title` 会返回 `<input name="title">`
    中输入的值）。
- en: '**Note**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: React Router also supports the other main HTTP verbs ( `"patch"` , `"put"` ,
    and `"delete"` ), and setting `method` to one of these verbs will indeed also
    trigger the `action()` function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 也支持其他主要的 HTTP 动词（`"patch"`、`"put"` 和 `"delete"`），将 `method` 设置为这些动词之一确实也会触发
    `action()` 函数。
- en: This can be useful when working with multiple forms that should trigger the
    same `action()` . By using different methods, you can use one single action to
    run different code based on the value extracted from `request.method` inside the
    `action()` function.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理多个应触发相同 `action()` 的表单时，这很有用。通过使用不同的方法，你可以使用单个操作来根据在 `action()` 函数内部从 `request.method`
    提取的值运行不同的代码。
- en: But it’s worth noting that using methods other than `'get'` and `'post'` is
    not in line with the HTML standard. Therefore, React Router could remove support
    for these methods in the future.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 但值得注意的是，使用除 `'get'` 和 `'post'` 之外的方法不符合 HTML 标准。因此，React Router 可能会在未来移除对这些方法的支持。
- en: Hence, when working with multiple forms that trigger the same `action()` , a
    more stable solution can be to include a hidden input field with a unique identifier
    (e.g., `<input type="hidden" name="_method" value="DELETE">` ). This value can
    then be extracted and used (e.g., in an `if` statement) in the `action()` function.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当处理触发相同 `action()` 的多个表单时，一个更稳定的解决方案是包含一个具有唯一标识符的隐藏输入字段（例如，`<input type="hidden"
    name="_method" value="DELETE">`）。然后可以提取并使用这个值（例如，在 `if` 语句中）在 `action()` 函数中。
- en: 'The extracted data can then be used for any operations of your choice. That
    could be an extra validation step or an HTTP request sent to some backend API,
    where the data may get stored in a database or file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 提取的数据可以用于你选择的任何操作。这可能是一个额外的验证步骤，或者发送到某个后端 API 的 HTTP 请求，其中数据可能被存储在数据库或文件中：
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, once all intended steps are performed, the `action()` function must
    return a value—any value of any type, but at least `null` . Not returning anything
    (i.e., omitting the `return` statement) is not allowed. Though, as with the `loader()`
    function, you may also return a response, for example, a redirect response like
    this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦执行了所有预期的步骤，`action()` 函数必须返回一个值——任何类型的任何值，但至少是 `null`。不返回任何内容（即省略 `return`
    语句）是不允许的。尽管如此，与 `loader()` 函数一样，你也可以返回一个响应，例如，像这样的重定向响应：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Indeed, for actions, it’s highly likely that you will want to navigate to a
    different page once the action has been performed (e.g., once an HTTP request
    to an API has been sent). This may be required to navigate the user away from
    the data input page to a page that displays all available data entries (for example,
    from `/posts/new` to `/posts` ).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，对于操作来说，你很可能希望在操作执行后导航到不同的页面（例如，一旦向 API 发送了 HTTP 请求）。这可能需要将用户从数据输入页面导航到显示所有可用数据条目的页面（例如，从
    `/posts/new` 到 `/posts`）。
- en: To simplify this common pattern, React Router provides a `redirect()` function
    that yields a response object that causes React Router to switch to a different
    route. You can therefore return the result of calling `redirect()` in your `action()`
    function to ensure that the user is navigated to a different page. It’s the equivalent
    of calling `navigate()` (via `useNavigate()` ) when manually handling form submissions.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化这个常见的模式，React Router 提供了一个 `redirect()` 函数，它返回一个响应对象，导致 React Router 切换到不同的路由。因此，你可以在
    `action()` 函数中返回调用 `redirect()` 的结果，以确保用户被导航到不同的页面。这相当于在手动处理表单提交时调用 `navigate()`（通过
    `useNavigate()`）。
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this snippet, React Router’s `redirect()` function is used instead of manually
    constructing a `Response` object.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，React Router 的 `redirect()` 函数被用来代替手动构造 `Response` 对象。
- en: Returning Data Instead of Redirecting
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回数据而不是重定向
- en: As mentioned, your `action()` functions may return anything. You don’t have
    to return a response object. While it is quite common to return a redirect response,
    you may occasionally want to return some raw data instead.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你的 `action()` 函数可以返回任何内容。你不必返回响应对象。虽然返回重定向响应相当常见，但你偶尔可能想返回一些原始数据。
- en: One scenario in which you might *not* want to redirect the user is after validating
    the user’s input. Inside the `action()` function, before sending the entered data
    to some API, you may wish to validate the provided values first. If an invalid
    value (such as an empty title) is detected, a great user experience is typically
    achieved by keeping the user on the route with the `<Form>` . The values entered
    by the user shouldn’t be cleared and lost; instead, the form should be updated
    to present useful validation error information to the user. This information can
    be passed from the `action()` to the component function so that it can be displayed
    there (for example, next to the form input fields).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种情况下你可能不希望重定向用户，那就是在验证用户输入之后。在 `action()` 函数中，在将输入的数据发送到某个 API 之前，你可能希望首先验证提供的值。如果检测到无效的值（例如，空标题），通常通过保持用户在
    `<Form>` 路由上以获得良好的用户体验。用户输入的值不应被清除和丢失；相反，表单应更新以向用户提供有用的验证错误信息。这些信息可以从 `action()`
    传递到组件函数，以便在那里显示（例如，在表单输入字段旁边）。
- en: 'In situations like this, you can return a “normal” value (that is, not a redirect
    response) from your `action()` function:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可以从 `action()` 函数返回一个“正常”值（即不是重定向响应）：
- en: '[PRE27]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this example, a `validationErrors` array is returned if the entered `title`
    or `text` values are empty.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，如果输入的 `title` 或 `text` 值为空，则返回 `validationErrors` 数组。
- en: 'Data returned by an `action()` function can be used in the route component
    (or any other nested component) via the `useActionData()` Hook:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`action()` 函数返回的数据可以通过 `useActionData()` 钩子在路由组件（或任何其他嵌套组件）中使用：'
- en: '[PRE28]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`useActionData()` works a lot like `useLoaderData()` , but unlike `useLoaderData()`
    , it’s not guaranteed to yield any data. This is because while `loader()` functions
    always get called before the route component is rendered, the `action()` function
    only gets called once the `<Form>` is submitted.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`useActionData()` 很像 `useLoaderData()`，但与 `useLoaderData()` 不同，它不保证产生任何数据。这是因为虽然
    `loader()` 函数总是在路由组件渲染之前被调用，但 `action()` 函数只有在 `<Form>` 提交后才会被调用。'
- en: 'In this example, `useActionData()` is used to get access to the `validationErrors`
    returned by `action()` . If `validationErrors` is truthy (that is, is not `undefined`
    ), the array will be mapped to a list of error items that are displayed to the
    user:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`useActionData()` 用于获取 `action()` 返回的 `validationErrors` 的访问权限。如果 `validationErrors`
    是真值（即不是 `undefined`），则数组将被映射到显示给用户的错误项列表：
- en: '![img](img/B31339_14_04.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_14_04.png)'
- en: 'Figure 14.4: Validation errors are output below the input fields'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4：验证错误输出在输入字段下方
- en: The `action()` function is therefore quite versatile in that you can use it
    to perform an action and redirect away as well as to conduct more than one operation
    and return different values for different use cases.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`action()` 函数非常灵活，您可以使用它执行操作并重定向，也可以执行多个操作并为不同的用例返回不同的值。
- en: Controlling Which <Form> Triggers Which Action
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制哪个 <Form> 触发哪个操作
- en: Earlier in this chapter, in the section *Working with action() and Form Data*
    , you learned that when `<Form>` is used instead of `<form>` , React Router will
    execute the targeted `action()` function. But which `action()` function is targeted
    by `<Form>` ?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的部分，在 *使用 action() 和表单数据* 的部分，您学习了当使用 `<Form>` 而不是 `<form>` 时，React Router
    将执行目标 `action()` 函数。但 `<Form>` 针对的是哪个 `action()` 函数？
- en: 'By default, it’s the `action()` function assigned to the route that also renders
    the form (either directly or via some descendent component). Consider this route
    definition:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，渲染表单的 `action()` 函数（无论是直接还是通过某些子组件）也是分配给路由的。考虑以下路由定义：
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With this definition, the `newPostAction()` function would be triggered whenever
    any `<Form>` inside of the `NewPost` component (or any nested component) is submitted.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此定义，当 `NewPost` 组件（或任何嵌套组件）中的任何 `<Form>` 被提交时，将触发 `newPostAction()` 函数。
- en: 'In many cases, this default behavior is exactly what you want. But you can
    also target `action()` functions defined on other routes by setting the `action`
    prop on `<Form>` to the path of the route that contains the `action()` that should
    be executed:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，这种默认行为正是您想要的。但您也可以通过在 `<Form>` 上设置 `action` 属性为目标路由的路径来针对其他路由上定义的 `action()`
    函数：
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This form would cause React Router to execute the `action` belonging to the
    `/save-data` route—even though the `<Form>` component may be rendered as part
    of a component that belongs to a different route (e.g., `/posts` ).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此表单将导致 React Router 执行属于 `/save-data` 路由的 `action`，即使 `<Form>` 组件可能是属于不同路由（例如，`/posts`）的组件的一部分。
- en: It is worth noting, though, that targeting a different route will lead to a
    page transition to that route’s path, even if your action does not return a redirect
    response. In a later section of this chapter, entitled *Behind-the-Scenes Data
    Fetching and Submission* , you will learn how that behavior can be avoided.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得注意的是，针对不同的路由会导致页面过渡到该路由的路径，即使您的操作没有返回重定向响应。在本章的后续部分，标题为 *幕后数据获取和提交* 的部分，您将了解如何避免这种行为。
- en: Reflecting the Current Navigation Status
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反映当前导航状态
- en: After submitting a form, the `action()` function that’s triggered may need some
    time to perform all intended operations. Sending HTTP requests to APIs in particular
    can take up to a few seconds.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 提交表单后，触发的 `action()` 函数可能需要一些时间来执行所有预期的操作。特别是向 API 发送 HTTP 请求可能需要几秒钟。
- en: Of course, it’s not a great user experience if the user doesn’t get any feedback
    about the current data submission status. It’s not immediately clear if anything
    happened at all after the submit button was clicked.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果用户得不到关于当前数据提交状态的任何反馈，那么用户体验就不会很好。点击提交按钮后，是否发生了任何操作并不立即明了。
- en: 'For that reason, you might want to show a loading spinner or update the button
    caption while the `action()` function is running. Indeed, one common way of providing
    user feedback is to disable the submit button and change its caption like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可能想在`action()`函数运行期间显示一个加载指示器或更新按钮的标题。确实，提供用户反馈的一种常见方式是禁用提交按钮并更改其标题，如下所示：
- en: '![img](img/B31339_14_05.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_14_05.png)'
- en: 'Figure 14.5: The submit button is grayed out'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5：提交按钮变灰
- en: You can get the current React Router status (that is, whether it’s currently
    transitioning to another route or executing an `action()` function) via the `useNavigation()`
    Hook. This Hook provides a navigation object that contains various pieces of routing-related
    information.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`useNavigation()` Hook 获取当前的 React Router 状态（即它是否正在过渡到另一个路由或执行`action()`函数）。这个
    Hook 提供了一个包含各种与路由相关的信息的导航对象。
- en: 'Most importantly, this object has a `state` property that yields a string describing
    the current navigation status. This property is set to one of the following three
    possible values:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，这个对象有一个`state`属性，它返回一个描述当前导航状态的字符串。此属性被设置为以下三个可能值之一：
- en: '`submitting` : If an `action()` function is currently executing'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`submitting`：如果当前正在执行`action()`函数'
- en: '`loading` : If a `loader()` function is currently executing (for example, because
    of a `redirect()` response)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loading`：如果当前正在执行`loader()`函数（例如，由于`redirect()`响应）'
- en: '`idle` : If no `action()` or `loader()` functions are currently being executed'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`idle`：如果没有`action()`或`loader()`函数正在执行'
- en: 'You can therefore use this `state` property to find out whether React Router
    is currently navigating to a different page or executing an `action()` . Hence,
    the submit button can be updated as shown in the preceding screenshot via this
    code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以使用这个`state`属性来找出 React Router 是否正在导航到不同的页面或执行`action()`。因此，可以通过前面的截图中的代码更新提交按钮：
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this example, the `isSubmitting` constant is `true` if the current navigation
    state is anything but `'idle'` . This constant is then used to disable the submit
    button (via the `disabled` attribute) and adjust the button’s caption.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果当前导航状态不是`'idle'`，则`isSubmitting`常量是`true`。然后使用这个常量通过`disabled`属性禁用提交按钮并调整按钮的标题。
- en: Submitting Forms Programmatically
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以编程方式提交表单
- en: In some cases, you won’t want to instantly trigger an `action()` when a form
    is submitted—for example, if you need to ask the user for confirmation first such
    as when triggering actions that delete or update data.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能不希望在表单提交时立即触发`action()`，例如，当你需要先请求用户确认时，比如触发删除或更新数据的操作。
- en: For such scenarios, React Router allows you to submit a form (and therefore
    trigger an `action()` function) programmatically. Instead of using the `Form`
    component provided by React Router, you handle the form submission manually using
    the default `<form>` element. As part of your code, you can then use a `submit()`
    function provided by React Router’s `useSubmit()` Hook to trigger the `action()`
    manually once you’re ready for it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此类场景，React Router 允许你以编程方式提交表单（因此触发`action()`函数）。你不需要使用 React Router 提供的`Form`组件，而是使用默认的`<form>`元素手动处理表单提交。作为你代码的一部分，你可以使用
    React Router 的`useSubmit()` Hook提供的`submit()`函数手动触发`action()`。
- en: 'Consider this example:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下例子：
- en: '[PRE32]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this example, the `action()` is manually triggered by programmatically submitting
    data via the `submit()` function provided by `useSubmit()` . This approach is
    required as it would otherwise be impossible to ask the user for confirmation
    (via the browser’s `window.confirm()` method).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`action()`是通过`useSubmit()`提供的`submit()`函数以编程方式提交数据手动触发的。这种做法是必需的，否则将无法通过浏览器的`window.confirm()`方法请求用户确认。
- en: Because data is submitted programmatically, the default `<form>` element should
    be used and the `submit` event handled manually. As part of this process, the
    browser’s default behavior of sending an HTTP request must also be prevented manually.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据是以编程方式提交的，应该使用默认的`<form>`元素，并手动处理`submit`事件。作为这个过程的一部分，必须手动阻止浏览器发送HTTP请求的默认行为。
- en: Typically, using `<Form>` instead of programmatic submission is preferable.
    But in certain situations, such as the preceding example, being able to control
    form submission manually can be useful.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，使用 `<Form>` 而不是程序化提交更为可取。但在某些情况下，例如前述示例中，能够手动控制表单提交可能是有用的。
- en: Behind-the-Scenes Data Fetching and Submission
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景数据获取和提交
- en: There are also situations in which you may need to trigger an action or load
    data without causing a page transition.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能需要触发一个操作或加载数据，而不引起页面转换。
- en: 'A Like button would be an example. When it’s clicked, a process should be triggered
    in the background (such as storing information about the user and the liked post),
    but the user should not be directed to a different page:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 点赞按钮就是一个例子。当点击时，应在后台触发一个过程（例如，存储有关用户和点赞帖子的信息），但用户不应被导向到不同的页面：
- en: '![img](img/B31339_14_06.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_14_06.png)'
- en: 'Figure 14.6: A Like button below a post'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.6：帖子下方的点赞按钮
- en: To achieve this behavior, you could wrap the button into a `<Form>` and, at
    the end of the `action()` function, simply redirect back to the page that is already
    active.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这种行为，你可以将按钮包裹在一个 `<Form>` 中，并在 `action()` 函数的末尾简单地重定向回已活跃的页面。
- en: But technically, this would still lead to an extra navigation action. Therefore,
    `loader()` functions would be executed and other possible side-effects might occur
    (the current scroll position could be lost, for example). For that reason, you
    might want to avoid this kind of behavior.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 但从技术上讲，这仍然会导致额外的导航操作。因此，`loader()` 函数将被执行，并可能发生其他可能的副作用（例如，当前的滚动位置可能会丢失）。因此，你可能想要避免这种行为。
- en: 'Thankfully, React Router offers a solution: the `useFetcher()` Hook, which
    yields an object that contains a `submit()` method. Unlike the `submit()` function
    provided by `useSubmit()` , the `submit()` method yielded by `useFetcher()` is
    meant for triggering actions (or `loader()` functions) without starting a page
    transition.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，React Router 提供了一个解决方案：`useFetcher()` 钩子，它产生一个包含 `submit()` 方法的对象。与 `useSubmit()`
    提供的 `submit()` 函数不同，`useFetcher()` 产生的 `submit()` 方法旨在触发操作（或 `loader()` 函数）而不启动页面转换。
- en: 'A Like button, as described previously, can be implemented like this (with
    the help of `useFetcher()` ):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，点赞按钮可以像这样实现（借助 `useFetcher()`）：
- en: '[PRE33]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `fetcher` object returned by `useFetcher()` has various properties. For
    example, it also contains properties that provide information about the current
    status of the triggered action or loader (including any data that may have been
    returned).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`useFetcher()` 返回的 `fetcher` 对象具有各种属性。例如，它还包含提供有关触发操作或加载程序当前状态的属性（包括可能已返回的任何数据）。'
- en: 'But this object also includes two important methods:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 但此对象还包括两个重要的方法：
- en: '`load()` : To trigger the `loader()` function of a route (e.g., `fetcher.load(''/route-path'')`
    )'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load()`：触发路由的 `loader()` 函数（例如，`fetcher.load(''/route-path'')`）'
- en: '`submit()` : To trigger an `action()` function with the provided data and configuration'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`submit()`：使用提供的数据和配置触发一个 `action()` 函数'
- en: In the code snippet above, the `submit()` method is called to trigger the action
    defined on the `/posts/<post-id>/like` route. Without `useFetcher()` (i.e., when
    using `useSubmit()` or `<Form>` ), React Router would switch to the selected route
    path when triggering its action. With `useFetcher()` , this is avoided, and the
    action of that route can be called from inside another route (meaning the action
    defined for `/posts/<post-id>/like` is called while the `/posts/<post-id>` route
    is active).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，通过调用 `submit()` 方法来触发 `/posts/<post-id>/like` 路由上定义的操作。在没有 `useFetcher()`（即使用
    `useSubmit()` 或 `<Form>`）的情况下，React Router 会切换到选定的路由路径以触发其操作。使用 `useFetcher()`
    时，可以避免这种情况，并且可以从另一个路由内部调用该路由的操作（这意味着在 `/posts/<post-id>` 路由活跃时，会调用为 `/posts/<post-id>/like`
    定义的操作）。
- en: 'This also allows you to define routes that don’t render any element (that is,
    in which there is no page component) and, instead, only contain a `loader()` or
    `action()` function. For example, the `/posts/<post-id>/like` route file ( `pages/like.js`
    ) looks like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这还允许你定义不渲染任何元素的路由（即没有页面组件的路由），而是只包含一个 `loader()` 或 `action()` 函数。例如，`/posts/<post-id>/like`
    路由文件（`pages/like.js`）看起来是这样的：
- en: '[PRE34]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As mentioned in the code snippet, any data may be returned in this action. But
    you must at least return `null` —avoiding the `return` statement and not returning
    anything is not allowed and will cause an error.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码片段中所述，任何数据都可以在这个操作中返回。但你至少必须返回 `null` ——避免 `return` 语句并且不返回任何内容是不允许的，并且会导致错误。
- en: 'It’s registered as a route as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 它被注册为以下路由：
- en: '[PRE35]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This works because this `action()` is only triggered via the `submit()` method
    provided by `useFetcher()` . `<Form>` and the `submit()` function yielded by `useSubmit()`
    would instead initiate a route transition to `/posts/<post-id>/like` . Without
    the `element` property being set on the route definition, this transition would
    lead to an empty page, as shown here:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为这个 `action()` 只通过 `useFetcher()` 提供的 `submit()` 方法触发。`<Form>` 和 `useSubmit()`
    产生的 `submit()` 函数将启动一个路由转换到 `/posts/<post-id>/like` 。如果没有在路由定义上设置 `element` 属性，这个转换将导致一个空页面，如下所示：
- en: '![img](img/B31339_14_07.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_14_07.png)'
- en: 'Figure 14.7: An empty (nested) page is displayed, along with a warning message'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.7：显示了一个空（嵌套）页面，以及一条警告信息
- en: Because of the extra flexibility it offers, `useFetcher()` can be very useful
    when building highly interactive user interfaces. It’s not meant as a replacement
    for `useSubmit()` or `<Form>` , but rather, as an additional tool for situations
    where no route transition is required or wanted.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它提供的额外灵活性，`useFetcher()` 在构建高度交互的用户界面时非常有用。它不是作为 `useSubmit()` 或 `<Form>`
    的替代品，而是一个额外的工具，用于不需要或不需要路由转换的情况。
- en: Deferring Data Loading
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟数据加载
- en: Up to this point in the chapter, all data fetching examples have assumed that
    a page should only be displayed once all its data has been fetched. That’s why
    there was never any loading state that would have been managed (and hence no loading
    fallback content that would have been displayed).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章中的所有数据获取示例都假设页面应该只在所有数据都获取到后才显示。这就是为什么从未有任何加载状态需要管理（因此也没有需要显示的加载重试内容）。
- en: In many situations, this is exactly the behavior you want as it does not often
    make sense to show a loading spinner or similar fallback content for a fraction
    of a second just to then replace it with the actual page data.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，这正是你想要的这种行为，因为仅仅为了在几秒钟内显示一个加载指示器或类似的重试内容，然后再用实际页面数据替换它，通常是没有意义的。
- en: But there are also situations in which the opposite behavior might be desirable—for
    example, if you know that a certain page will take quite a while to load its data
    (possibly due to a complex database query that must be executed on the backend)
    or if you have a page that loads different pieces of data and some pieces are
    much slower than others.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 但也有可能需要相反的行为——例如，如果你知道某个页面将需要相当长的时间来加载数据（可能是因为必须在后端执行的一个复杂的数据库查询）或者如果你有一个页面，它加载不同的数据块，其中一些块比其他块慢得多。
- en: In such scenarios, it may make sense to render the page component even though
    some data is still missing. React Router also supports this use case by allowing
    you to defer data loading, which, in turn, enables the page component to be rendered
    before the data is available.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，即使某些数据仍然缺失，渲染页面组件可能也是有意义的。React Router 也支持这种用例，允许你延迟数据加载，这反过来又使得页面组件可以在数据可用之前被渲染。
- en: 'Deferring data loading is as simple as returning a promise from the loader
    (instead of awaiting it there):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟数据加载就像从加载器返回一个承诺（而不是在那里等待它）一样简单：
- en: '[PRE36]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this example, `getPosts()` is a function that returns a (slow) `Promise`
    :'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`getPosts()` 是一个返回（慢速）`Promise` 的函数：
- en: '[PRE37]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: React Router allows you to return raw promises. When doing so, you can wait
    for the actual values yielded by those promises in the client-side code.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 允许你返回原始承诺。这样做时，你可以在客户端代码中等待那些承诺产生的实际值。
- en: 'Inside the component function where `useLoaderData()` is used, you must also
    use a new component provided by React Router: the `Await` component. It’s used
    like this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `useLoaderData()` 的组件函数内部，你还必须使用 React Router 提供的新组件：`Await` 组件。它的使用方式如下：
- en: '[PRE38]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `<Await>` element takes a `resolve` prop that receives a value of type `Promise`
    from the loader data. It’s wrapped by the `<Suspense>` component provided by React.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`<Await>` 元素接受一个 `resolve` 属性，该属性从加载器数据接收类型为 `Promise` 的值。它被 React 提供的 `<Suspense>`
    组件包裹。'
- en: The value passed to resolve is a `Promise` that was stored in the object returned
    by the `loader()` function. There, a key named posts was used to hold that `Promise`
    . The value for that key was the `Promise` returned by `getPosts()` . It’s this
    `Promise` that’s passed as a value to `resolve` via `<Await resolve={data.posts}>`
    . If a different key name were used (e.g., `blogPosts` ), that key name had to
    be referenced when setting `resolve` (e.g., `<Await resolve={data.blogPosts}>`
    ).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给解决的是存储在 `loader()` 函数返回的对象中的 `Promise`。在那里，一个名为 posts 的键被用来保存那个 `Promise`。那个键的值是
    `getPosts()` 返回的 `Promise`。这就是通过 `<Await resolve={data.posts}>` 传递给 `resolve`
    的 `Promise`。如果使用了不同的键名（例如，`blogPosts`），在设置 `resolve` 时必须引用那个键名（例如，`<Await resolve={data.blogPosts}>`）。
- en: '`Await` automatically waits for the `Promise` to resolve before then calling
    the function that’s passed to `<Await>` as a child (that is, the function passed
    between the `<Await>` opening and closing tags). This function is executed by
    React Router once the data of the deferred operation is available. Therefore,
    inside that function, `loadedPosts` is received as a parameter, and the final
    user interface elements can be rendered.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`Await` 在调用作为 `<Await>` 子组件（即在 `<Await>` 开启和关闭标签之间传递的函数）之前，会自动等待 `Promise`
    解决。这个函数由 React Router 在延迟操作的数据可用时执行。因此，在这个函数内部，`loadedPosts` 作为参数接收，最终的用户界面元素可以被渲染。'
- en: The `Suspense` component that’s used as a wrapper around `<Await>` defines some
    fallback content that is rendered as long as the deferred data is not yet available.
    In *Chapter 10* , *Behind the Scenes of React and Optimization Opportunities*
    , the `Suspense` component was used to show some fallback content until the missing
    code was downloaded. Now, it’s used to bridge the time until the required data
    is available.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 用作 `<Await>` 包装器的 `Suspense` 组件定义了一些后备内容，在延迟数据尚未可用时渲染。在*第10章*，*React背后的场景和优化机会*中，`Suspense`
    组件被用来显示一些后备内容，直到缺失的代码下载完成。现在，它被用来填补直到所需数据可用的时间。
- en: As shown in *Figure 14.8* , when returning a `Promise` (and using `<Await>`
    ) like this, other parts of the website, that are not loaded via `<Await>` , are
    already rendered and displayed while waiting for the posts data.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图14.8*所示，当返回一个 `Promise`（并使用 `<Await>`）时，网站的其他部分，那些不是通过 `<Await>` 加载的，在等待帖子数据的同时已经渲染并显示出来。
- en: '![img](img/B31339_14_08.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_14_08.png)'
- en: 'Figure 14.8: Post details are already visible while the list of posts is loading'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8：在帖子列表加载时，帖子详情已经可见
- en: 'Another big advantage of returning a `Promise` and awaiting it in the client-side
    code is that you can easily combine multiple fetching processes and control which
    processes should be deferred and which ones should not. For example, a route might
    be fetching different pieces of data. If only one process tends to be slow, you
    could defer only the slow one like this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `Promise` 并在客户端代码中等待它的另一个大优点是，你可以轻松地组合多个获取过程，并控制哪些过程应该延迟，哪些不应该。例如，一个路由可能正在获取不同的数据片段。如果只有一个过程比较慢，你可以像这样只延迟慢的那个：
- en: '[PRE39]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this example, `getUserData()` is not deferred because the `await` keyword
    is added in front of it. Therefore, JavaScript waits for that `Promise` (the `Promise`
    returned by `getUserData()` ) to resolve before returning from `loader()` . Hence,
    the route component is rendered once `getUserData()` finishes but before `getPosts()`
    is done.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`getUserData()` 没有被延迟，因为在其前面添加了 `await` 关键字。因此，JavaScript会在从 `loader()`
    返回之前等待那个 `Promise`（`getUserData()` 返回的 `Promise`）解决。因此，当 `getUserData()` 完成时，路由组件就会被渲染，但在
    `getPosts()` 完成之前。
- en: Summary and Key Takeaways
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要和关键要点
- en: React Router can help you with data fetching and submission.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Router可以帮助你处理数据获取和提交。
- en: You can register `loader()` functions for your routes, causing data fetching
    to be initialized as a route becomes active.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以为你的路由注册 `loader()` 函数，使得数据获取在路由变得活跃时初始化。
- en: '`loader()` functions return data (or responses, wrapping data) that can be
    accessed via `useLoaderData()` in your component functions.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loader()` 函数返回数据（或包含数据的响应）可以在你的组件函数中使用 `useLoaderData()` 访问。'
- en: '`loader()` data can be used across components via `useRouteLoaderData()` .'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loader()` 数据可以通过 `useRouteLoaderData()` 在组件间共享。'
- en: You can also register `action()` functions on your routes that are triggered
    upon form submissions.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以在你的路由上注册 `action()` 函数，这些函数在表单提交时被触发。
- en: To trigger `action()` functions, you must use React Router’s `<Form>` component
    or submit data programmatically via `useSubmit()` or `useFetcher()` .
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要触发`action()`函数，你必须使用React Router的`<Form>`组件或通过`useSubmit()`或`useFetcher()`程序化地提交数据。
- en: '`useFetcher()` can be used to load or submit data without initiating a route
    transition.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useFetcher()`可用于在不启动路由转换的情况下加载数据或提交数据。'
- en: When fetching slow data, you can return promises without awaiting them in the
    `loader()` to defer loading some or all of a route’s data.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在获取慢速数据时，你可以在`loader()`中返回承诺而不等待，以延迟加载路由的一些或全部数据。
- en: What’s Next?
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: Fetching and submitting data are extremely common tasks, especially when building
    more complex React applications.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 获取和提交数据是极其常见的任务，尤其是在构建更复杂的React应用程序时。
- en: Typically, those tasks are closely connected to route transitions, and React
    Router is the perfect tool for handling this kind of operation. That’s why the
    React Router package offers powerful data management capabilities that vastly
    simplify these processes.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些任务与路由转换紧密相关，React Router是处理此类操作的完美工具。这就是为什么React Router包提供了强大的数据管理功能，极大地简化了这些过程。
- en: In this chapter, you learned how React Router assists you with fetching or submitting
    data and which advanced features help you handle both basic and more complex data
    manipulation scenarios.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了React Router如何帮助你获取或提交数据，以及哪些高级特性有助于你处理基本和更复杂的数据操作场景。
- en: Therefore, this chapter concludes the list of core React Router features you
    need to know.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章总结了你需要了解的核心React Router特性列表。
- en: The next chapters will explore React’s server-side capabilities and how you
    may build fullstack applications with React, load data on a server, and use the
    Next.js framework.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将探讨React的服务器端功能以及如何使用React构建全栈应用程序，在服务器上加载数据，并使用Next.js框架。
- en: Test Your Knowledge!
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试你的知识！
- en: 'Test your knowledge of the concepts covered in this chapter by answering the
    following questions. You can then compare your answers to the examples found at
    [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/exercises/questions-answers.md)
    :'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题来测试你对本章涵盖的概念的了解。然后，你可以将你的答案与在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/exercises/questions-answers.md)中找到的示例进行比较。
- en: How are data fetching and submission related to routing?
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据获取和提交与路由有何关联？
- en: What’s the purpose of `loader()` functions?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`loader()`函数的目的是什么？'
- en: What’s the purpose of `action()` functions?
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`action()`函数的目的是什么？'
- en: What’s the difference between `<Form>` and `<form>` ?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<Form>`和`<form>`之间有什么区别？'
- en: What’s the difference between `useSubmit()` and `useFetcher()` ?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useSubmit()`和`useFetcher()`之间有什么区别？'
- en: What’s the idea behind returning promises instead of awaiting them in a `loader()`
    ?
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回承诺而不是在`loader()`中等待背后的想法是什么？
- en: Apply What You Learned
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用你所学的知识
- en: Apply your knowledge about routing, combined with data manipulation, to the
    following activity.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 将你对路由的知识与数据操作相结合，应用于以下活动。
- en: 'Activity 14.1: A To-Dos App'
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动十四点一：待办事项应用程序
- en: In this activity, your task is to create a basic to-do list web app that allows
    users to manage their daily to-do tasks. The finished page must allow users to
    add to-do items, update to-do items, delete to-do items, and view a list of to-do
    items.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你的任务是创建一个基本的待办事项列表Web应用程序，允许用户管理他们的日常待办任务。完成的页面必须允许用户添加待办事项、更新待办事项、删除待办事项和查看待办事项列表。
- en: 'The following paths must be supported:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 以下路径必须得到支持：
- en: '`/` : The main page, responsible for loading and displaying a list of to-do
    items'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`：主页面，负责加载和显示待办事项列表'
- en: '`/new` : A page, opened as a modal above the main page, allowing users to add
    a new to-do item'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/new`：一个页面，以模态形式在主页面上方打开，允许用户添加新的待办事项'
- en: '`/:id` : A page, also opened as a modal above the main page, allowing users
    to update or delete a selected to-do item'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/:id`：一个页面，也可以在主页面上方以模态形式打开，允许用户更新或删除选定的待办事项'
- en: If no to-do items exist yet, a fitting info message should be shown on the `/`
    page. If users try to visit `/:id` with an invalid to-do ID, an error modal should
    be displayed.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果还没有待办事项，应在`/`页面上显示一条合适的信息。如果用户尝试访问无效的待办事项ID的`/:id`，应显示一个错误模态。
- en: '**Note**'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: For this activity, there is no backend API you could use. Instead, use `localStorage`
    to manage the to-do data. Keep in mind that the `loader()` and `action()` functions
    are executed on the client side and can therefore use any browser APIs, including
    `localStorage` .
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个活动，没有可用的后端 API。相反，使用 `localStorage` 来管理待办事项数据。请注意，`loader()` 和 `action()`
    函数是在客户端执行的，因此可以使用任何浏览器 API，包括 `localStorage`。
- en: You will find example implementations for adding, updating, deleting, and getting
    to-do items from `localStorage` at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/activities/practice-1/src/data/todos.js](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/activities/practice-1/src/data/todos.js)
    .
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/activities/practice-1/src/data/todos.js](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/activities/practice-1/src/data/todos.js)
    找到添加、更新、删除和从 `localStorage` 获取待办事项的示例实现。
- en: Also, don’t be confused by the pages that open as modals above other pages.
    Ultimately, these are simply nested pages, styled as modal overlays. In case you
    get stuck, you can use the example `Modal` wrapper component found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/activities/practice-1/src/components/Modal.jsx](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/activities/practice-1/src/components/Modal.jsx)
    .
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，不要被打开在其他页面之上的模态页面弄混。最终，这些只是嵌套页面，被设计成模态覆盖样式。如果你遇到困难，可以使用在 [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/activities/practice-1/src/components/Modal.jsx](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/activities/practice-1/src/components/Modal.jsx)
    找到的示例 `Modal` 包装组件。
- en: For this activity, you can write all CSS styles on your own if you so choose.
    But if you want to focus on the React and JavaScript logic, you can also use the
    finished CSS file from the solution at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/activities/practice-1/src/index.css](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/activities/practice-1/src/index.css)
    .
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个活动，如果你愿意，可以自己编写所有的 CSS 样式。但如果你想专注于 React 和 JavaScript 逻辑，你也可以使用解决方案中的完成
    CSS 文件，见 [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/activities/practice-1/src/index.css](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/activities/practice-1/src/index.css)
    。
- en: If you use that file, explore it carefully to ensure you understand which IDs
    or CSS classes might need to be added to certain JSX elements of your solution.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用那个文件，请仔细探索它，以确保你理解哪些 ID 或 CSS 类可能需要添加到你的解决方案的某些 JSX 元素中。
- en: 'To complete the activity, perform the following steps:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个活动，请执行以下步骤：
- en: Create a new React project and install the React Router package.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 React 项目并安装 React Router 包。
- en: Create components (with the content shown in the screenshots below) that will
    be loaded for the three required pages. Also, add links (or programmatic navigation)
    between these pages.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建（如以下截图所示）的内容组件，这些组件将被加载到所需的三个页面中。同时，在这些页面之间添加链接（或程序性导航）。
- en: Enable routing and add the route definitions for the three pages.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用路由并添加三个页面的路由定义。
- en: Create `loader()` functions to load (and use) all the data needed by the individual
    pages.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `loader()` 函数来加载（并使用）单个页面所需的所有数据。
- en: Add `action()` functions for adding, updating, and deleting to-dos.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为添加、更新和删除待办事项添加 `action()` 函数。
- en: '*Hint:* If you need to submit multiple forms for different actions from the
    same page, you could include a hidden input field that sets some value you can
    check for in your `action()` function, e.g., `<input type="hidden" name="_method"
    value="DELETE">` . Alternatively, you can also set `<Form method="delete">` (or
    set it to `"patch"` , `"put"` , or other HTTP verbs) and check for `request.method`
    in your `action()` function.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '*提示:* 如果你需要从同一页面提交多个表单以执行不同的操作，你可以在 `action()` 函数中包含一个隐藏的输入字段来设置一些你可以检查的值，例如
    `<input type="hidden" name="_method" value="DELETE">`。或者，你也可以设置 `<Form method="delete">`（或将它设置为
    `"patch"`、`"put"` 或其他 HTTP 动词）并在 `action()` 函数中检查 `request.method`。'
- en: Add error handling in case data loading or saving fails.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据加载或保存失败的情况下添加错误处理。
- en: 'The finished pages should look like this:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的页面应该看起来像这样：
- en: '![img](img/B31339_14_09.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_14_09.png)'
- en: 'Figure 14.9: The main page displaying a list of to-dos'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.9：主页面显示待办事项列表
- en: '![img](img/B31339_14_10.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_14_10.png)'
- en: 'Figure 14.10: The /new page, opened as a modal, allowing users to add a new
    to-do'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.10：/new 页面，以模态形式打开，允许用户添加新的待办事项
- en: '![img](img/B31339_14_11.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_14_11.png)'
- en: 'Figure 14.11: The /:id page, also opened as a modal, allowing users to edit
    or delete a to-do'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.11：/:id页面，也可以作为模态打开，允许用户编辑或删除待办事项
- en: '![img](img/B31339_14_12.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_14_12.png)'
- en: 'Figure 14.12: An info message, displayed if no to-dos were found'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.12：如果没有找到待办事项，将显示一条信息消息
- en: '**Note**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The full code, and solution, to this activity can be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/activities/practice-1)
    .
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的完整代码和解决方案可以在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/activities/practice-1)找到。
