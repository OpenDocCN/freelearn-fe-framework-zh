- en: Building the Multitrack Player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've made it to the keystone of NativeScript development: Direct access to Objective-C/Swift
    APIs on iOS and Java APIs on Android via TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: This is, by far, one of the most unique aspects of NativeScript and opens up
    many opportunities to you as a mobile developer. In particular, our app is going
    to need to take advantage of rich native audio APIs on both iOS and Android to
    achieve its core competency of delivering a compelling multitrack recording/mixing
    experience to our users.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how to code against these APIs will be essential to unlocking
    your mobile app's full potential. Additionally, learning how to integrate existing
    NativeScript plugins, which may already provide consistent APIs on both iOS and
    Android, can help you reach your goals even faster. Leveraging the best performance
    each platform can deliver will be the focus of our journey in Part 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the Nativescript-audio plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a model for our track player for future scalability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with RxJS observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Angular's NgZone with third-party libraries and view bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling audio playback sync with multiple audio sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking advantage of Angular's bindings, as well as NativeScript's native event
    bindings, to achieve the exact usability we're after
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a custom shuttle slider for our player controls using Angular platform-specific
    directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing our multitrack player via the nativescript-audio plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Luckily, the NativeScript community has published a plugin that provides us
    with a consistent API to use across both iOS and Android to get going with an
    audio player. Feel free to browse [http://plugins.nativescript.org](http://plugins.nativescript.org), *the
    official source for NativeScript plugins,* before implementing features, in order to
    determine if an existing plugin may work for your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the **nativescript-audio** plugin found at [http://plugins.nativescript.org/plugin/nativescript-
    audio](http://plugins.nativescript.org/plugin/nativescript-audio) contains what
    we need to start integrating the player portion of our app''s features, and it
    works on both iOS and Android. *It even provides a recorder we may be able to
    use*. Let''s start by installing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The NativeScript framework allows you to integrate with any npm module, opening
    up a dizzying array of integration possibilities, including NativeScript specific
    plugins. In fact, if you ever run into a situation where an npm module is giving
    you trouble (perhaps, because it relies on a node API not compatible in the NativeScript
    environment), there's even a plugin to help you deal with that at [https://www.npmjs.com/package/nativescript-nodeify](https://www.npmjs.com/package/nativescript-nodeify).
    It is described in detail at [https://www.nativescript.org/blog/how-to-use-any-npm-module-with-nativescript](https://www.nativescript.org/blog/how-to-use-any-npm-module-with-nativescript).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever integrating with a NativeScript plugin, create a model or Angular service
    around its integration to provide isolation around that integration point.
  prefs: []
  type: TYPE_NORMAL
- en: '**Try to isolate third-party plugin integration points by creating a reusable
    model or Angular service around that plugin**. This will not only provide your
    app with nice scalability into the future, but will give you more flexibility
    down the road if you need to swap that plugin out with something different and/or
    provide different implementations on iOS or Android.'
  prefs: []
  type: TYPE_NORMAL
- en: Building the TrackPlayerModel for our multitrack player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need each track to have its own instance of an audio player, as well as to
    expose an API to load the track's audio file. This will also provide a good place
    to expose the track's duration once the audio file is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this model will likely be shared across the entire app (foreseeably with
    recording playback in the future as well), we will create this with our other
    models in `app/modules/shared/models/track-player.model.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We start by importing the sweet NativeScript community audio player `TNSPlayer`
    from the `nativescript- audio` plugin. We then define a simple interface to implement
    for our model which, will reference `trackId`, its `duration`, and a `readonly`
    getter for the `player` instance. Then, we include that interface to use with
    our implementation, which constructs an instance of `TNSPlayer` with itself. Since
    we want a flexible model that can load its track file at any time, we provide
    a `load` method taking `ITrack` that utilizes the `initFromFile` method. This,
    in turn, asynchronously fetches the track's total duration (returned as a string,
    so we use `+duration`) to store the number on the model before resolving the track's
    initialization completes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For consistency and standards, just be sure to also export this new model from
    `app/modules/shared/models/index.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we provide a getter for the player instance that `PlayerService` will
    use. This brings us to our next step: open `app/modules/player/services/player.service.ts`.
    We are going to change up our initial implementation a bit with our latest developments;
    have a look at this in totality and we will explain afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The cornerstone of `PlayerService` at this point is to not only manage the
    hard work of playing multiple tracks in the mix, but to provide a state, which
    our views can observe to reflect the composition''s state. Hence, we have the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Our view will need to know the playing state as well as `duration` and `currentTime`.
    Using `Subject` for the `playing$` and `duration$` states will work well, since
    they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: They can emit values directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They don't need to emit an initial value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They don't need any observable composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, `currentTime$` is going to be set up with some composition
    in mind, since its value will be dependent on an intermittent state that may develop
    over time (more on this shortly!). In other words, the `playing$` state is a value
    we control and emit directly via play actions made by the user (or internally
    based on player state) and the `duration$` state is a value we emit directly as
    a result of all our track's players becoming initialized and ready**. **
  prefs: []
  type: TYPE_NORMAL
- en: '`currentTime` is a value that the player does not emit automatically via a
    player event but rather a value we must check for intermittently. Therefore, we
    compose `Observable.interval(1000)` that will auto emit our mapped value representing
    the longest track''s player instance''s actual `currentTime` every 1 second upon
    its subscription.'
  prefs: []
  type: TYPE_NORMAL
- en: The other `private` references help maintain the internal state for the service's
    use. Most interestingly, we will keep a reference to `_longestTrack`, since our
    composition's total duration will always be based on the longest track and, hence,
    will also be used to track `currentTime`.
  prefs: []
  type: TYPE_NORMAL
- en: This set up will provide the essentials of what our view will need to suffice
    proper user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: '*RxJS does not include any operators by default. Therefore, `Observable.interval(1000)`
    and `.map` will crash your app right now if you are to run it!*'
  prefs: []
  type: TYPE_NORMAL
- en: The minute you start working more with RxJS, it's a good idea to create an `operators.ts`
    file to import all your RxJS operators into. Then, import that file in your root
    `AppComponent`, so you don't end up with those operator imports scattered everywhere
    throughout your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `app/operators.ts` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open `app/app.component.ts` and import that file on the very first line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are free to use map, interval, and any other `rxjs` operators we need
    anywhere in our code, provided we import them into that single file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next bit of our service is rather self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `playing` setter ensures that the internal state, `_playing`, is updated,
    as well as our `playing$` subject''s value emitted for any subscribers needing
    to react to this state change. Convenient getters are also added for good measure.
    The next setter for our composition gets rather interesting, as this is where
    we interact with our new `TrackPlayerModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever we set the active composition, we first ensure our service''s internal
    `_trackPlayers` reference is properly cleaned up and cleared with `this._resetTrackPlayers()`.
    We then set up a local method `initTrackPlayer` that can be called iteratively,
    given the async nature of each player''s `load` method to ensure each track''s
    player is properly loaded with the audio file, including its duration. After each
    successful load, we add to our collection of `_trackPlayers`, iterate, and continue
    until all the audio files are loaded. When complete, we call `this._updateTotalDuration()`
    to determine the final duration of our composition of tracks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Since the track with the longest duration should always be used to determine
    the total duration of the entire composition, we use `Math.max` to determine what
    the longest duration is and then store a reference to the track. Because multiple
    tracks could have the same duration, it doesn't really matter which track is used,
    just as long as one matches the longest duration. This `_longestTrack` will be
    our *pace setter* if you will, as it will be used to determine `currentTime` of
    the entire composition. Lastly, we emit the longest duration as `totalDuration`
    via our `duration$` subject for any subscribing observers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next couple of methods provide the basis of our composition''s overall
    playback control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Our primary play button in our UI will use the `togglePlay` method to control
    playback and, hence, is used to toggle the internal state as well as engage all
    the track player's play or pause methods.
  prefs: []
  type: TYPE_NORMAL
- en: Let the music play!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To try all this out, let's add three sample audio files from a jazz track composed
    by the exquisite *Jesper Buhl Trio* called *What Is This Thing Called Love*. The
    tracks are already separated by drums, bass, and piano. We can add these `.mp3`
    files to an `app/audio` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify our demo composition''s tracks in `MixerService` to provide references
    to these new real audio files. Open `app/modules/mixer/services/mixer.service.ts`
    and make the following modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now provide an input to our player controls, which will take our selected
    composition. Open `app/modules/mixer/components/mixer.component.html`, and make
    the following highlighted modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `PlayerControlsComponent` at `app/modules/player/components/player-
    controls/player-controls.component.ts`, we can now observe the state of `PlayerService` via
    its various observables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The cornerstone of `PlayerControlComponent` is now its ability to set the active
    composition via `this.playerService.composition = this.composition` inside `ngOnInit`,
    which is when the composition input is ready, as well as subscribe to the various
    states provided by `PlayerService` to update our UI. Most interesting here is
    the `playing$` subscription that manages the `currentTime$` subscription based
    on whether it''s playing or not. If you recall, our `currentTime$` observable
    started with `Observable.interval(1000)`, meaning every one second, it will emit
    the longest track''s `currentTime`, shown here again for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We only want to update `currentTime` of `Slider` when playback is engaged; hence,
    the subscription when the `playing$` subject emit is `true`, which will allow
    our component to receive the player's `currentTime` every second. When `playing$`
    emit is `false`, we unsubscribe, to no longer receive the `currentTime` updates.
    Excellent.
  prefs: []
  type: TYPE_NORMAL
- en: We also subscribe to our `duration$` subject to update the Slider's maxValue.
    Lastly, we ensure all subscriptions are cleaned up via their `Subscription` references
    inside `ngOnDestroy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at our view bindings now for `PlayerControlsComponent` at
    `app/modules/player/components/player-controls/player-controls.component.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you run the app, you can now select the Demo composition and play music on
    both iOS and Android.
  prefs: []
  type: TYPE_NORMAL
- en: '*MUSIC TO OUR EARS! This is pretty awesome. In fact, it''s friggin'' sweet!!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple things you may notice or desire at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: After choosing the Play button, it properly changes to Stop, but when playback
    reaches the end, it does not return to its original Play text.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Slider` should also return to position 0 to reset playback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The total `duration` and `currentTime` on iOS uses seconds; however, Android
    uses milliseconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On iOS, you may notice a very subtle playback sync issue on all the tracks if
    you choose to play/pause many times during the playback of the composition's demo
    tracks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current time and duration labels are needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Playback seeking** would be nice to be able to shuttle our slider to control
    the position of playback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polishing the implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re missing a few important pieces in our model and service to really polish
    off our implementation. Let''s start with handling completion and error conditions
    with our track player instances. Open `TrackPlayerModel` at `app/modules/shared/models/track-player.model.ts` and
    add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining the shape of each track error with `IPlayerError`. Then,
    we define references to the `_completeHandler` and `_errorHandler` functions captured via
    the `load` arguments, which now require complete and error callbacks. We assign
    those both before assigning the model's internal `this._trackComplete`and `this._trackError`
    (*using the `.bind(this)` syntax to ensure the function scope is locked to itself*)to
    `completeCallback` and `errorCallback` of `TNSPlayer`.
  prefs: []
  type: TYPE_NORMAL
- en: '`completeCallback` and`errorCallback` will fire outside the zone. This is why
    we inject `NgZone` and use `ngZone.run()` later in the chapter. We can avoid that
    by creating a callback with the `zonedCallback` function. It will make sure that
    the callback will be executed in the same zone as the code that creates the callback.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This provides us the ability to internally handle each condition before dispatching
    out those conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'One such internal condition is resetting each audio player back to zero when
    it completes playing, so we simply call the `seekTo` method of `TNSPlayer`to reset
    it. We mark a *TODO,* because although this works well when all the tracks are
    the same length (*as is the case with our Demo tracks*), this will most certainly
    become potentially problematic in the future when we start recording our own varied
    multitracks with different lengths. Imagine we have two tracks in a composition:
    track 1 with a duration of 1 minute and track 2 a duration of 30 seconds. If we
    play the composition to 45 seconds and hit pause, track 2 would have called its
    completion handler already and reset back to 0\. We then hit play to resume. Track
    1 resumes from 45 seconds but track 2 is back at 0\. *We will address that when
    we get there, so don''t fret about it!* At this point, we are polishing our first
    phase implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we call out to the assigned `completeHandler` to let the caller know
    which trackId has completed. For `trackError`, we simply call out passing along
    `trackId` and `error`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s go back to `PlayerService` and wire this in. Open `app/modules/player/services/player.service.ts` and
    make the following modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We've added another subject, `complete$`, to allow view components to subscribe
    to when the track playback completes. Additionally, we have added two callback
    handlers, `_trackComplete` and `_trackError`, which we pass along to our `load`
    method of `TrackPlayerModel`.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we were to try and update view bindings as a result of the `complete$`
    subscriptions firing in any view component, you would notice something puzzling.
    **The view would not update!**
  prefs: []
  type: TYPE_NORMAL
- en: Anytime you integrate with third-party libraries, take note of callback handlers
    coming from the library, which you may intend to update a view binding. Inject
    NgZone and wrap with `this.ngZone.run(() => ...` where needed.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party libraries that provide callbacks may often need to run through Angular's NgZone.
    The great folks at Thoughtram published a great article on Zones if you'd like
    to learn more, at [https://blog.thoughtram.io/angular/2016/02/01/zones-in-angular-2.html](https://blog.thoughtram.io/angular/2016/02/01/zones-in-angular-2.html).
  prefs: []
  type: TYPE_NORMAL
- en: The third-party library **nativescript-audio** integrates with the iOS and Android
    native audio players and provides callbacks you can wire up to handle completion
    and error conditions. These callbacks are executed asynchronously within the context
    of the native audio players and, because they are not handled within the context
    of user events like a tap, or a result of a network request, or a timer like `setTimeout`,
    we need to ensure the result and the subsequent code execution take place within
    Angular's NgZone if we intend them to result in updating view bindings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we intend for the `complete$` subject to result in view binding updates
    (*specifically, resetting our slider*), we will inject NgZone and wrap our callback
    handling. Back in `app/modules/player/services/player.service.ts`, let''s make
    the following adjustment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will be clear when using this new `complete$` subject to react to our
    service''s state in our view components. Let''s adjust `PlayerControlsComponent`
    at `app/modules/player/components/player- controls/player-controls.component.ts` to
    observe the `complete$` subject to reset our `currentTime` binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: iOS Audio Player reports `duration` and `currentTime` in seconds, whereas Android
    reports in milliseconds. We need to standardize that!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a method to `PlayerService` to standardize the time, so we can rely
    on both the platforms providing time in seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We are able to take advantage of the `isIOS` Boolean provided by the `platform`
    module from NativeScript to conditionally adjust our time for Android's milliseconds
    to seconds conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `isIOS` and/or `isAndroid` Boolean from NativeScript's `platform`
    module is a very effective way to make platform adjustments across your codebase
    where needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**So what about that subtle playback sync issue with multiple tracks on iOS
    ?**'
  prefs: []
  type: TYPE_NORMAL
- en: On iOS, you may notice a very subtle playback sync issue on all the tracks if
    you choose play/pause many times during the 14 seconds of playback on the composition's
    demo tracks. We could surmise this could also happen on Android at some point.
  prefs: []
  type: TYPE_NORMAL
- en: Using NativeScript's strengths by tapping directly into the native API of the
    underlying iOS AVAudioPlayer instance from the nativescript-audio plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's insert some safeguards into our play/pause logic to help ensure our tracks
    stay in sync to the best of our programming abilities. The **nativescript-audio**
    plugin offers an iOS-only method called `playAtTime`. It works in tandem with
    the special `deviceCurrentTime` property, as described in Apple's documentation
    for this very purpose at [https://developer.apple.com/reference/avfoundation/avaudioplayer/1387462-devicecurrenttime?
    language=objc](https://developer.apple.com/reference/avfoundation/avaudioplayer/1387462-devicecurrenttime?language=objc).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `deviceCurrentTime` is not exposed by the nativescript-audio plugin,
    we can access the native property directly via the `ios` getter. Let''s adjust
    the `play` method of `PlayerService`to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Since `track.player` is our instance of `TNSPlayer`, we can access the underlying
    native platform player instance (for iOS, it's `AVAudioPlayer`) via its **ios**
    getter to access `deviceCurrentTime` directly. We provide a very short start delay
    for good measure, add that into the first track's `deviceCurrentTime`, and use
    that to start all of our tracks at precisely the same time, which works wonderfully! Because
    `playAtTime` is not published via the TypeScript definitions with the nativescript-audio
    plugin, we simply type-cast the player instance (`<any>track.player`) before calling
    the method to suffice the tsc compiler. Since there is no equivalent on Android,
    we will just use the standard media player's play method, which works well for
    Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now adjust our pause method with a similar safeguard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: By using the first track's `currentTime` as the **pace setter**, we pause each
    track in our mix and ensure they remain at exactly the same time by seeking to
    the same `currentTime` immediately after pausing. This helps ensure that, when
    we resume play, they all start from the same point in time. Let's put all this to
    use in the next section when we build a custom shuttle slider.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom ShuttleSliderComponent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can't have a multitrack studio experience without the ability to shuttle
    back and forth through our mix! Let's double down on `Slider` and enhance its
    capabilities by combining the best of all the options NativeScript and Angular
    provide us. In the process, our player controls will start to become much more
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting at the high level, open `app/modules/player/components/player-controls/player-controls.component.html`
    and replace it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We are replacing `GridLayout` with `StackLayout` to change up our player control''s
    layout a bit. Let''s go with a full-width slider stacked on top of our play/pause
    button. What we''re after is similar to the Apple Music app on an iPhone, where
    the slider is full width with the current time and duration displayed underneath.
    Now, let''s build our custom `shuttle-slider` component and create `app/modules/player/components/player-controls/shuttle-
    slider.component.html` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here's where things are going to get very interesting. We are going to combine
    Angular bindings where useful, like these bindings: `[maxValue]="duration"` and `[text]="durationDisplay"` .
    However for the rest of our usability wiring we will want more fine grained and
    manual control. For instance, our containing `GridLayout` via `#sliderArea` is
    going to be the area the user is going to be able to touch to shuttle back/forth
    instead of the `Slider` component itself, and we are going to completely disable
    user interaction with the Slider itself (hence, the `slim-slider` directive attribute,
    you see). The slider is going to instead be used just for its visual representation
    of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason we will be doing this is because we want this interaction to kick
    off several programmatic actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Pause playback (if playing) while shuttling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the current time display label as we move back/forth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kick off the `seekTo` commands to our track player's instances in a controlled
    manner; hence, reducing extraneous seek commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resume playback when no longer shuttling if it was playing before attempting
    to shuttle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we used `Slider` with an Angular binding to `currentTime` via the `currentTime$`
    observable, which in turn was being controlled by our interaction with it in addition
    to the state of our track's players, things would be coupled too tightly to achieve the
    fine grain control we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'The beauty of what we are about to do here serves as an exemplary testament
    to how flexible the combination of Angular with NativeScript really is. Let''s
    start programming our interactions in `app/modules/player/components/player-controls/shuttle-slider.component.ts`; here''s
    the complete setup for you to view in full, which we will break down in a moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For a rather small component footprint, there's a ton of great stuff going on
    here! Let's break it down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at those property decorators, starting with `@Input`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have our `@ViewChild` references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We can then access those `ElementRef` instances in our component to programmatically
    work with them; however, not right away. Since `ElementRef` is a proxy wrapper
    to the view component, its underlying `nativeElement` (our actual NativeScript
    component) is only accessible once Angular's component lifecycle hook `ngAfterViewInit`
    fires.
  prefs: []
  type: TYPE_NORMAL
- en: 'Learn all about Angular''s component lifecycle hooks here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://angular.io/docs/ts/latest/guide/lifecycle- hooks.html.](https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we assign private references to our actual NativeScript components
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We also take this opportunity to reference the overall screen width using the
    **density-independent pixel** (**dip**) units via the `screen` utility from the
    `platform` module. This will allow us to do some calculations using our user's
    finger position on our `sliderArea` StackLayout to adjust the actual value of
    `Slider`. We then make a call to set up our essential event handlers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using our `_sliderArea` reference to the containing StackLayout, we add a `touch`
    gesture listener to capture any touches the user makes to our slider area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to grab the `X` position of their finger via `args.getX()`. We
    use that to divide into the user's device screen width to determine a percentage
    from the left to the right. Since our calculation is not exactly precise, we make
    a small adjustment when the user passes the 50% mark. This usability works well
    for our use case right now, but we will reserve the option to improve that later;
    however, it's perfectly fine for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then multiply the duration by this percentage to get our `seekTo` mark to
    update our value of  `Slider` in order to get immediate UI updates using manual
    precision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are actually using our NativeScript components directly without Angular's
    bindings or NgZone in the mix. This can be very handy in cases where you need
    fine grained and performance control of your UI. Since we want the `Slider` track
    to move immediately with the user's finger, as well as the time display label
    formatted with standard musical timecode to represent real time as they interact,
    we set their values directly at the appropriate time.
  prefs: []
  type: TYPE_NORMAL
- en: We then use a seek delay timeout to ensure we don't make extraneous seek commands
    to our multitrack player. Each movement by the user will further delay making
    an actual seek command until they rest where they want it. We also use our `isIOS`
    Boolean to convert the time as appropriately needed by each platform audio player
    (seconds for iOS and milliseconds for Android).
  prefs: []
  type: TYPE_NORMAL
- en: 'Most interesting might be our `ngOnChanges` lifecycle hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Angular calls its `ngOnChanges()` method whenever it detects changes to the
    ***input properties*** of the component (or directive).
  prefs: []
  type: TYPE_NORMAL
- en: This is a wonderful way for `ShuttleSliderComponent` to react to its `Input`
    property changes, `currentTime`, and `duration`. Here, we simply update our slider
    and the current time display label manually via `this._updateSlider(this.currentTime)`
    only when it does fire with a valid number. Lastly, we also ensure we update our
    duration display label. This method will fire every second the PlayerService's
    `currentTime$` observable fires while an active subscription exists. **Nice!**
    Oh, and don't forget to add `ShuttleSliderComponent` to the `COMPONENTS` array
    to be included with the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to actually implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to use a couple more nifty observable tricks with our seeking
    state. Let''s open our PlayerService in `app/modules/player/services/player.service.ts`
    and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We are introducing three new observable operators `switchMap`, `never`, and
    `of`, which we need to ensure are also imported in our `app/operators.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`switchMap` allows our observable to switch streams based on several conditions,
    helping us to manage whether `currentTime` needs to emit updates or not. Clearly,
    when seeking, we don''t need to react to the `currentTime` changes. Therefore,
    we switch our Observable stream to `Observable.never()` while `this._seeking`
    is true, ensuring our observer is never called.'
  prefs: []
  type: TYPE_NORMAL
- en: In our `seeking` setter, we adjust the internal state reference (`this._seeking`)
    ,and if it was currently `this._playing` and had not yet been paused due to seeking
    (hence, `!this._seekPaused`), we immediately pause playback (only once). We then
    set up another timeout to delay resuming playback an additional 400 milliseconds
    after `seekTo` has been fired from the component if it was playing when seek started
    (hence, the check on `this._seekPaused`).
  prefs: []
  type: TYPE_NORMAL
- en: This way, the user is free to move their finger across our shuttle slider as
    much as they'd like and as quickly as they'd like. They will see immediate UI
    updates to the `Slider` track as well as the current time display label in real
    time; all the while we are avoiding extraneous `seekTo` commands being sent to
    our multitrack player until they come to rest, providing a really nice user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Creating SlimSliderDirective for iOS and Android native API modifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We still have a directive to create for that `slim-slider` attribute we had
    on `Slider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We are going to create platform-specific directives, since we will tap into
    the slider's actual native API on iOS and Android to disable user interaction
    and hide the thumb for a seamless appearance.
  prefs: []
  type: TYPE_NORMAL
- en: 'For iOS, create `app/modules/player/directives/slider.directive.ios.ts` with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We gain access to the underlying native iOS `UISlider` instance via NativeScript's
    `ios` getter off the `Slider` component itself. We use Apple's API reference documentation
    ([https://developer.apple.com/reference/uikit/uislider](https://developer.apple.com/reference/uikit/uislider))
    to locate an appropriate API to disable interaction via the `userInteractionEnabled`
    flag and hide the thumb by setting a blank as the thumb. Perfect.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Android, create `app/modules/player/directives/slider.directive.android.ts`
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We gain access to the native `android.widget.SeekBar` instance via the `android`
    getter on the `Slider` component. We use Android's API reference documentation
    ([https://developer.android.com/reference/android/ widget/SeekBar.html](https://developer.android.com/reference/android/widget/SeekBar.html))
    to locate the SeekBar's API and disable user interaction by overriding `OnTouchListener`,
    and we hide the thumb by setting its Drawable alpha to 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create `app/modules/player/directives/slider.directive.d.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This will allow us to import and use our `SlimSlider` class as a standard ES6
    module; Create `app/modules/player/directives/index.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: At runtime, NativeScript will only build the appropriate platform-specific files
    into the target platform, completely excluding nonapplicable code. This is a very
    powerful way to create platform-specific functionality in your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish up, let''s just ensure our directives are declared in `PlayerModule`
    at `app/modules/player/player.module.ts` with the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We should now see this on iOS with our playback paused at 6 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'For Android, it will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can now observe the following:'
  prefs: []
  type: TYPE_NORMAL
- en: All the three tracks play together in a perfect mix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playback can be shuttled via the slider whether it's playing or not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The play/pause toggle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When playback reaches the end, our controls properly reset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And it all works on iOS and Android. An amazing feat, without question.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now fully immersed in the rich world of NativeScript, having introduced
    plugin integration as well as direct access to native APIs on iOS and Android.
    To top it off, we have a really neat multitrack player with full playback control,
    including shuttling through the mix!
  prefs: []
  type: TYPE_NORMAL
- en: The exciting combination of Angular, including its RxJS observable underpinnings,
    is really starting to shine through, where we've been able to take advantage of
    view bindings where needed and react to service event streams with powerful observable
    compositions, all while still retaining the ability to manually control our UI
    with fine grain control. Whether our view needs an Angular directive to enrich
    its capabilities or manual touch gesture control via raw NativeScript capabilities,
    we have it all at our fingertips now.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that all along we are building a fully native iOS and Android app is
    truly mind blowing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue to dig further into native APIs and plugins
    as we bring recording into our app's abilities to deliver on the core requirements
    of our multi-track recording studio mobile app.
  prefs: []
  type: TYPE_NORMAL
