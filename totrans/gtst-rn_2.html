<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Understanding React Native Fundamentals"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Understanding React Native Fundamentals</h1></div></div></div><p>You might not be familiar with how React for Web works, so we are going to cover the fundamentals in this chapter. We will also explain the core principles of how React for Web works under the hood. Once you have a solid understanding of the basics, we will dive into how React for Web works and the subtle differences between mobile and web. By the end of this chapter, you will have the necessary skills to start building the example application.</p><p>In this chapter we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Virtual DOM</li><li class="listitem" style="list-style-type: disc">Introducing components and JSX</li><li class="listitem" style="list-style-type: disc">Writing our first component</li><li class="listitem" style="list-style-type: disc">Props and state of components</li></ul></div><div class="section" title="The Virtual DOM"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec12"/>The Virtual DOM</h1></div></div></div><p>Do you <a id="id11" class="indexterm"/>know how to write a JavaScript function? If you do, that's great! You're well on your way to understand how React and React Native work under the hood. What do we mean exactly? Well, when you research how React works, you'll eventually encounter someone explaining it in the following manner:</p><div class="informalexample"><pre class="programlisting">UI = f(data)</pre></div><p>You may say, <span class="emphasis"><em>Nerd alert! How is this helpful?</em></span> Well, it's saying that your UI is a function of your data. To put it in more familiar terms, let's say that:</p><div class="informalexample"><pre class="programlisting">var todos = function(data) { return data.join( " -- " ) }</pre></div><p>You can call the <code class="literal">function</code> with an array of data, such as:</p><div class="informalexample"><pre class="programlisting">var ui = todos( ["wake up", "get out of bed", "drag a comb across my head"] );
console.log(ui);</pre></div><p>This is not a particularly earth-shattering code; however, you're now rendering some content, in this case to the console.</p><p>What if, all <a id="id12" class="indexterm"/>your UI rendering code could be this predictable? It can be! Let's start getting a little more advanced. What if, in addition to our <code class="literal">todos()</code> function, we had a function called <code class="literal">todoItem()</code>, such as:</p><div class="informalexample"><pre class="programlisting">var todoItem = function(data) { return "&lt;strong&gt;" + data + "&lt;/strong&gt;" }</pre></div><p>That looks a lot like our original <code class="literal">UI</code> function, doesn't it?:</p><div class="informalexample"><pre class="programlisting">UI = f(data)</pre></div><p>What if we start composing our <code class="literal">todos()</code> and <code class="literal">todoItems()</code>, such as:</p><div class="informalexample"><pre class="programlisting">var ui = todos( [todoItem("wake up"), todoItem("get out of bed")] );</pre></div><p>You can start to get the picture that we can start to render more and more complex outputs by composing simple functions.</p><p>What if we want to start rendering our content to the browser? I'm sure you can imagine changing our <code class="literal">todoItem()</code> to add elements to the DOM using jQuery; however, in this case we will start repeating ourselves a lot with many instances of <code class="literal">appendChild()</code> calls and jQuery selectors. If we are really smart, we might write a framework to abstract away the DOM manipulations so that we can write the code that matters to our application, not just the code that matters to the browser.</p><p>OK, so now let's say that we've magically got a framework that lets us represent our UI as a <code class="literal">data</code> function and we don't have to think about how our content will get rendered to the DOM. We can start changing our data over and over and watch the DOM update! That sounds great in theory, but when we have dozens of <code class="literal">div</code> elements in a deeply nested hierarchy, the underlying DOM manipulations become complex and inefficient.</p><p>What if our magic framework had an intermediate representation of the DOM? Let's call it Virtual DOM and let's say that instead of making every little change to the DOM, we batch the changes together. We can even compare the before and after states of the Virtual DOM. Figure out the differences and reduce the number of real DOM manipulations that we need to perform. Now we're really on to something!</p><p>So we can now express our UI as a function of our data. We don't have to think about the underlying DOM manipulation code and our UI is nice and snappy because the underlying framework is really smart and reduces the number of DOM manipulations it needs to perform. It will be pretty great to have a framework that could do that for us, but you know what will be really cool? What if the DOM didn't have to be a browser DOM? What if that same abstraction that allows us to write the code that matters to our app could be used to, say, update native mobile components? Enter React Native.</p></div></div>
<div class="section" title="Components"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Components</h1></div></div></div><p>Now here <a id="id13" class="indexterm"/>is an interesting problem; we have come across this great framework for making fast differences between the Virtual DOM and its native components. How do we tell React Native what UI to represent or when to change it? A React Native component is a simple, reusable, function-like object that enables us to describe the native mobile components we want to render. They will always contain properties, state, and a render method. Let's start really simple by creating our own component.</p><div class="section" title="Creating your first component"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec09"/>Creating your first component</h2></div></div></div><p>Creating a <a id="id14" class="indexterm"/>new component in React Native will look similar to the following:</p><div class="informalexample"><pre class="programlisting">import React, {
  Text,
  View
  } from 'react-native';
class HelloComponent extends React.Component {
  render () {
    return (
    &lt;View&gt;
      &lt;Text&gt;Hello React&lt;/Text&gt;
    &lt;View&gt;
  );
  }
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>Remember to import the React Native module. Here, we are using the ES6 import statement; it is similar to how the node require module works.</p></div></div><p>
<span class="emphasis"><em>Wait a second…</em></span> What are these weird XML elements doing in my JavaScript code? Facebook has created its own syntactic extension over JavaScript to describe React components. Here is the exact same code, but written in ordinary JavaScript:</p><div class="informalexample"><pre class="programlisting">var HelloComponent = React.createClass({displayName: "HelloComponent"}, render: function () {
  return (
    React.createElement(View, null,
      React.createElement(Text, null, "Hello React")
  )
));</pre></div><p>While it is possible to write React Native applications only in JavaScript, the previous syntax includes<a id="id15" class="indexterm"/> many added benefits for the developer.</p></div><div class="section" title="JSX"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec10"/>JSX</h2></div></div></div><p>
<span class="strong"><strong>JavaScript XML</strong></span> (<span class="strong"><strong>JSX</strong></span>) is <a id="id16" class="indexterm"/>an XML-like extension to <a id="id17" class="indexterm"/>the ECMAScript specification. It combines the component logic (JavaScript) and markup (DOM or Native UI) into a single file.</p><p>A JSX Element will take the following form:</p><div class="informalexample"><pre class="programlisting">var element = (
  &lt;JSXElement&gt;
    &lt;SubJSXElement /&gt;
    &lt;SubJSXElement /&gt;
    &lt;SubJSXElement /&gt;
  &lt;JSXElement /&gt;
);</pre></div><p>The JSX specification also defines the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The JSX Elements can be either self-opening <code class="literal">&lt;JSXElement&gt;&lt;/JSXElement&gt;</code> or self-closing <code class="literal">&lt;JSXElement /&gt;</code>.</li><li class="listitem" style="list-style-type: disc">Accept attributes as an expression <code class="literal">{}</code> or string <code class="literal">""</code> <code class="literal">&lt;Component attr="attribute"&gt;</code>. Expressions are JavaScript snippets.</li><li class="listitem" style="list-style-type: disc">The children elements can be text, expressions, or elements.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>
<span class="strong"><strong>What if you have more than one component or a list of components?</strong></span>
</p><p>There can only be a single root element; it means that if you have multiple components, you must wrap them in a parent component.</p></div></div><p>This is cool! We have gone from a deeply nested and imperative JavaScript code to a declarative format that describes the exact elements that we want to see in our components. There is no separation of concerns since our logic is coupled with our markup, making the components easier to debug and test. Since you can always include the same component in multiple other components, there is no need to duplicate the code anyway.</p><p>Note that JSX is only meant to be used as a preprocessor and it is not recommended to transpile in your production build. More information on JSX can be found in the official React documentation <a class="ulink" href="https://facebook.github.io/react/docs/jsx-in-depth.html">https://facebook.github.io/react/docs/jsx-in-depth.html</a> or in the official JSX Specification <a class="ulink" href="https://facebook.github.io/jsx/">https://facebook.github.io/jsx/</a>.</p></div><div class="section" title="Back to our first component"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec11"/>Back to our first component</h2></div></div></div><p>There are a few things that we have overlooked in our component. <span class="strong"><strong>View</strong></span> and <span class="strong"><strong>Text</strong></span> are two of the many<a id="id18" class="indexterm"/> components provided by React Native to build a UI. These are not regular components that render in the JavaScript layer, they can map directly to their native container parts! The<a id="id19" class="indexterm"/> View component maps to <code class="literal">UIView</code> in IOS and <code class="literal">android.view</code> in Android, while Text is the generic component to display text on each platform <a id="id20" class="indexterm"/>respectively. <span class="strong"><strong>View</strong></span> <a id="id21" class="indexterm"/>and <span class="strong"><strong>Text</strong></span> support various functions, such as layouts, styling, and touch handling.</p><p>Displaying the same static text over and over is not very exciting. Let's extend this simple component and add some more functionalities.</p></div><div class="section" title="Props and states"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Props and states</h2></div></div></div><p>At this<a id="id22" class="indexterm"/> point, you may be wondering how React Native deals with component manipulation and communication as the number of components grows into a component hierarchy. A component hierarchy, similar to a tree, starts with a root component and can contain many children. React Native provides two methods of data passing; one for data-flow down the component hierarchy and another for maintaining internal state.</p><div class="section" title="Props"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec01"/>Props</h3></div></div></div><p>How do the<a id="id23" class="indexterm"/> components in the same component hierarchy communicate with each other? Data is passed down through properties commonly known as <span class="strong"><strong>props</strong></span>. Props <a id="id24" class="indexterm"/>are considered to be immutable by convention and should never be modified directly. To pass a prop into a component, just add a camel-cased attribute to the component:</p><div class="informalexample"><pre class="programlisting">&lt;HelloComponent text="Hello React" /&gt;</pre></div><p>Props can be accessed internally in the component through <code class="literal">this.props</code>:</p><div class="informalexample"><pre class="programlisting">import React, {
  Text,
  View
} from 'react-native';

class HelloComponent extends React.Component {
  render () {
    return (
      &lt;View&gt;
        &lt;Text&gt;{this.props.text}&lt;/Text&gt;
      View&gt;
    );
  }
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>
<span class="strong"><strong>What if I want to pass down a lot of props?</strong></span>
</p><p>It is possible to pass an array of props to a component using the ES7 spread operator <code class="literal">&lt;HelloComponent {...props} /&gt;</code>.</p></div></div><p>It is not <a id="id25" class="indexterm"/>always necessary to include props with a component, but if you <a id="id26" class="indexterm"/>require a default value for your props, you can assign the <code class="literal">defaultProps</code> object to the component's class constructor.</p><div class="informalexample"><pre class="programlisting">HelloComponent.defaultProps = {text: "Default Text!"};</pre></div><div class="section" title="Validating props"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec01"/>Validating props</h4></div></div></div><p>If you are <a id="id27" class="indexterm"/>planning to expose your component to the public, it makes sense to constrain the ways developers can use it. To enforce that your components are being used correctly, the <a id="id28" class="indexterm"/>
<span class="strong"><strong>PropTypes</strong></span> module can be used to validate any props passed in. In the event that a prop does not pass the <code class="literal">propType</code> validation, a warning is shown to the developer in the console. The <code class="literal">PropTypes</code> cover a wide range of JavaScript types and primitives, including nested objects. You can define <code class="literal">propTypes</code> on a component's class constructor:</p><div class="informalexample"><pre class="programlisting">HelloComponent.propTypes = {text: React.PropTypes.string};</pre></div><p>For more information on <code class="literal">propTypes</code>, visit the Prop Validation section of React Docs <a class="ulink" href="https://facebook.github.io/react/docs/reusable-components.html">https://facebook.github.io/react/docs/reusable-components.html</a>.</p></div></div><div class="section" title="State"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec02"/>State</h3></div></div></div><p>So <a id="id29" class="indexterm"/>now <a id="id30" class="indexterm"/>we can pass in the data, but what if the data changes, then how can we display these changes to the user? Components can optionally contain state, a mutable and private set of data. State is a great way to keep track of user input, asynchronous requests, and events. Let's update our component with additional text when the user interacts with it:</p><div class="informalexample"><pre class="programlisting">import React, {
  Text,
  View,
  Component
  } from 'react-native';
  class HelloComponent extends React.Component{
    constructor (props) {
      super(props);
      this.state = {  // Set Initial State
      appendText: ''
    };
  }
  render () {
    return (
      &lt;View&gt;
        &lt;Text onPress={() =&gt; setState({text: ' Native!'})}&gt;{this.props.text + this.state.appendText}&lt;/Text&gt;
        &lt;View&gt;
    );
  }
}</pre></div><p>Touching the <a id="id31" class="indexterm"/>
<code class="literal">Text</code> component will trigger the function in its <code class="literal">onPress</code> prop. We are taking advantage of the ES6 arrow syntax to include our functionality in line with the text component.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>Using the ES6 arrow syntax will automatically bind this to a function. For any non-arrow function, if you need access to this then you need to bind the value to the function in the props expression <code class="literal">&lt;Text onPress={this.myFunction.bind(this)}&gt;</code>.</p></div></div><p>The <code class="literal">setState</code> function will merge the object you pass into the first argument with the current state of the component. Calling <code class="literal">setState</code> will trigger a new render where, instead of being empty, <code class="literal">this.state.appendText</code> will append <span class="strong"><strong>Native!</strong></span> to the value of text, which we originally passed in from props. The final result is <code class="literal">"Hello React" + " Native!"</code> to produce <code class="literal">"Hello React Native!"</code>.</p><p>Never try and modify the value of this state on your own. Directly changing the state could result in data loss during the next <code class="literal">setState</code> call and it will not trigger another re-render.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Summary</h1></div></div></div><p>Now hopefully, you understand the radical new direction React has taken in achieving performance. The Virtual DOM handles all of the DOM manipulations for us behind the scenes. At the same time, it uses efficient diffing algorithms to minimize the number of calls to the DOM. We have also seen how JSX allows us to express our components declaratively and combine our application logic into a single file. By using props and state, we can pass the data through components and update them dynamically.</p><p>I hope you can now take the information you learned in this chapter and convince your boss to start using React Native right away!</p></div></body></html>