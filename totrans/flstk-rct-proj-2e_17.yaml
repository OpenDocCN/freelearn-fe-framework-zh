- en: Developing a Web-Based VR Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The advent of **virtual reality** (**VR**) and **augmented reality** (**AR**)
    technologies is transforming how users interact with software and, in turn, the
    world around them. The possible applications of VR and AR are innumerable, and
    though the gaming industry has been an early adopter, these rapidly developing
    technologies have the potential to shift paradigms across multiple disciplines
    and industries.
  prefs: []
  type: TYPE_NORMAL
- en: In order to demonstrate how the MERN stack paired with React 360 can easily
    add VR capabilities to any web application, we will discuss and develop a dynamic,
    web-based VR game in this and the next chapter. In this chapter, we will focus
    on defining the features of the VR game. Additionally, we will go over the key
    3D VR concepts that are relevant to implementing this VR game, before developing
    the game view using React 360.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will build the VR game using React 360 by covering the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the MERN VR Game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with React 360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key concepts for developing 3D VR applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining game details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the game view in React 360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bundling the React 360 code to integrate with the MERN skeleton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After going over these topics, you will be able to apply 3D VR concepts and
    use React 360 to start building your own VR-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the MERN VR Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The MERN VR Game web application will be developed by extending the MERN skeleton
    and integrating VR capabilities using React 360\. It will be a dynamic, web-based
    VR game application, in which registered users can make their own games, and any
    visitor to the application can play these games. The home page of this application
    will list the games on the platform, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3d1a186-03b5-4201-82d2-0dccbfa3446f.png)'
  prefs: []
  type: TYPE_IMG
- en: The code to implement features of the VR game using React 360 is available on
    GitHub at [https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter13/MERNVR](https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter13/MERNVR). You
    can clone this code and run the application as you go through the code explanations
    in the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The features of the game will be simple enough to reveal the capabilities of
    introducing VR into a MERN-based application, without delving too deeply into
    the advanced concepts of React 360 that may be used to implement more complex
    VR features. In the next section, we will briefly define the features of a game
    in this application.
  prefs: []
  type: TYPE_NORMAL
- en: Game features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each game in the MERN VR Game application will essentially be a different VR
    world, where users can interact with 3D objects placed at different locations
    in a 360-degree panoramic world.
  prefs: []
  type: TYPE_NORMAL
- en: The gameplay will be similar to that of a scavenger hunt, and to complete each
    game, users will have to find and collect the 3D objects that are relevant to
    the clue or description for each game. This means the game world will contain
    some VR objects that can be collected by the player and some VR objects that cannot
    be collected, but that may be placed by makers of the game as props or hints.
    Finally, the game will be won when all of the relevant 3D objects have been collected
    by the user.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will build these game features using React 360, focusing
    primarily on VR and React 360 concepts that will be relevant to implementing the
    features defined here. Once the game features are ready, we will discuss how the
    React 360 code can be bundled and prepared for integration with the MERN application
    code developed in [Chapter 14](17bbfed7-9867-4c8b-99fd-42581044a906.xhtml), *Making
    the VR Game Dynamic Using MERN*. Before diving into the implementation of the
    game features with React 360, we will first look at setting up and getting started
    with React 360 in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with React 360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React 360 makes it possible to build VR experiences using the same declarative
    and component-based approach as in React. The underlying technology of React 360
    makes use of the Three.js JavaScript 3D engine to render 3D graphics with WebGL
    within any compatible web browser and also provides us with access to VR headsets
    with the Web VR API.
  prefs: []
  type: TYPE_NORMAL
- en: Though React 360 builds on top of React and the apps run in the browser, React
    360 has a lot in common with React Native, thus making React 360 apps cross-platform.
    This also means that some concepts of React Native are also applicable to React
    360\. Covering all of the React 360 concepts is outside the scope of this book;
    therefore, we will focus on the concepts that are required to build the game and
    integrate them with the MERN stack web application. In the following section,
    we will begin by setting up a React 360 project, which will be extended on later
    in the chapter in order to build the game features.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a React 360 project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React 360 provides developer tools that make it easy to start developing a new
    React 360 project. The steps to get started are detailed in the official React
    360 documentation, so we will only summarize the steps here and point out the
    files that are relevant to developing the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we already have Node and Yarn installed for the MERN applications, we
    can start by installing the React 360 CLI tool by running the following command
    in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use this React 360 CLI tool to create a new application, and install
    the required dependencies by running the following command from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will add the new React 360 application with all of the necessary files
    into a folder, named `MERNVR`, in the current directory. Finally, we can go into
    this folder in the command line, and run the application using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This `start` command will initialize the local development server, and the default
    React 360 application can be viewed in the browser at `http://localhost:8081/index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: To update this starter application and implement our game features, we will
    modify code mainly in the `index.js` file with some minor updates in the `client.js`
    file, which can be found in the `MERNVR` project folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default code in `index.js` for the starter application generated by React
    360 should be as follows. Note that it renders a Welcome to React 360 text in
    a 360-degree world in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This `index.js` file contains the application''s content and the main code,
    including the view and style code. The code in `client.js` contains the boilerplate
    that connects the browser to the React application in `index.js`. The default
    `client.js` file in the starter project folder should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code executes the React code defined in `index.js`, essentially creating
    a new instance of React 360 and loading the React code by attaching it to the
    DOM.
  prefs: []
  type: TYPE_NORMAL
- en: With this, the default React 360 starter project is set up and ready for extension.
    Before modifying this code to implement the game, in the next section, we will
    first look at some of the key concepts related to developing 3D VR experiences,
    in the context of how these concepts are applied with React 360.
  prefs: []
  type: TYPE_NORMAL
- en: Key concepts for developing the VR game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before creating VR content and an interactive 360-degree experience for the
    game, we will highlight some of the relevant aspects of the virtual world, and
    how React 360 can be used to work with these VR concepts. Given the wide range
    of possibilities in the VR space and the various options available with React
    360, we need to identify and explore the specific concepts that will enable us
    to implement the interactive VR features we defined for the game. In the following
    sections, we will discuss the images that will make up the 360-degree world of
    the game, the 3D positioning system, along with the React 360 components, APIs,
    and input events that will be utilized to implement the game.
  prefs: []
  type: TYPE_NORMAL
- en: Equirectangular panoramic images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The VR world for the game will be composed of a panoramic image that is added
    to the React 360 environment as a background image.
  prefs: []
  type: TYPE_NORMAL
- en: Panorama images are generally 360-degree images or spherical panoramas projected
    onto a sphere that completely surrounds the viewer. A common and popular format
    for 360-degree panorama images is the equirectangular format. React 360 currently
    supports mono and stereo formats for equirectangular images.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about the 360 images and video support in React 360, refer to
    the React 360 documentation at [facebook.github.io/react-360/docs/setup.html](https://facebook.github.io/react-360/docs/setup.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The photograph shown here is an example of an equirectangular, 360-degree panoramic
    image. To set the world background for a game in MERN VR Game, we will use this
    kind of image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c413a1ae-2ec4-4546-9026-1b8a8dd83eae.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An equirectangular panoramic image consists of a single image with an aspect
    ratio of 2:1, where the width is twice the height. These images are created with
    a special 360-degree camera. An excellent source of equirectangular images is
    Flickr; you just need to search for the `equirectangular` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the game world by setting the background scene using an equirectangular
    image in a React 360 environment will make the VR experience immersive and transport
    the user to a virtual location. To enhance this experience and add 3D objects
    in this VR world effectively, we need to learn more about the layout and coordinate
    system relevant to the 3D space, which is discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: 3D position – coordinates and transforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to understand positioning and orientation in the VR world space, in
    order to place 3D objects at the desired locations and to make the VR experience
    feel more real. In the following sections, we will review the 3D coordinate system
    to help us to determine the location of a virtual object in the 3D space, and
    the transform capabilities in React 360, which will allow us to position, orient,
    and scale objects as required.
  prefs: []
  type: TYPE_NORMAL
- en: 3D coordinate system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For mapping in a 3D space, React 360 uses a three-dimensional meter-based coordinate
    system that is similar to the OpenGL® 3D coordinate system. This allows individual
    components to be transformed, moved, or rotated in 3D in relation to the layout
    in their parent component.
  prefs: []
  type: TYPE_NORMAL
- en: The 3D coordinate system used in React 360 is a right-handed system. This means
    the positive *x* axis is to the right, the positive *y* axis points upward, and
    the positive *z* axis is backward. This provides a better mapping with common
    coordinate systems of the world space in assets and 3D world modeling.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to visualize the 3D space, the user starts out at the center of the
    **x-y-z** axes pictured in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba726573-d550-4e4b-9d27-8df91a3868d6.png)'
  prefs: []
  type: TYPE_IMG
- en: The ***z ***axis points forward toward the user and the user looks out at the **-z **axis
    direction. The **y **axis runs up and down, whereas the **x **axis runs from side
    to side. The curved arrow in the diagram shows the direction of the positive rotation
    values.
  prefs: []
  type: TYPE_NORMAL
- en: While deciding where and how to place 3D objects in the 360-degree world, we
    will have to set values according to this 3D coordinate system. In the next section,
    we will demonstrate how to place 3D objects using React 360 by setting values
    in transform properties.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming 3D objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The position and orientation of a 3D object will be determined by its transform
    properties, which will have values corresponding to the 3D coordinate system.
    In the following screenshot, the same 3D book object is placed in two different
    positions and orientations by changing the `transform` properties in the style
    attribute of a React 360 `Entity` component that is rendering the 3D object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/228b2a5e-9d0e-48c0-a64f-693a2961e5eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This transform feature is based on the transform style used in React, which
    React 360 extends to be fully 3D, considering the **x-y-z** axes. The `transform`
    properties are added to the `Entity` components in the `style` attribute as an
    array of keys and values in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The transform commands and values that are relevant to the 3D objects to be
    placed in our games are `translate [x, y, z]`, with values in meters; `rotate
    [x, y, z]`, with values in degrees; and `scale`, to determine the size of the
    object across all axes. We can also utilize the `matrix` command instead, which
    accepts an array of 16 numbers representing the translation, rotation, and scale
    values.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about the React 360 3D coordinates and transforms, refer to the
    React 360 documentation at [facebook.github.io/react-360/docs/setup.html](https://facebook.github.io/react-360/docs/setup.html).
  prefs: []
  type: TYPE_NORMAL
- en: We will utilize these transform properties to position and orient 3D objects
    according to the 3D coordinate system while placing objects in the game world
    built using React 360\. In the next section, we will go over the React 360 components
    that will allow us to build the game world.
  prefs: []
  type: TYPE_NORMAL
- en: React 360 components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React 360 provides a range of components that can be used out of the box to
    create the VR user interface for the game. This range consists of basic components
    available from React Native and also VR-specific components that will allow you
    to incorporate the interactive 3D objects in the VR game. In the following sections,
    we will summarize the specific components that will be used to build the game
    view and features, including core components, such as `View` and `Text`, and VR-specific
    components, such as `Entity` and `VrButton`.
  prefs: []
  type: TYPE_NORMAL
- en: Core components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core components in React 360 include two of React Native's built-in components
    – the `Text` and `View` components. In the game, we will use these two components to
    add content to the game world. In the following sections, we will discuss these
    two core components.
  prefs: []
  type: TYPE_NORMAL
- en: View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `View` component is the most fundamental component for building a user
    interface in React Native, and it maps directly to the native view equivalent
    on whatever platform React Native is running on. In our case, since the application
    will render in the browser, it will map to a `<div>` element in the browser. The
    `View` component can be added as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `View` component is typically used as a container for other components;
    it can be nested inside other views and can have zero-to-many children of any
    type.
  prefs: []
  type: TYPE_NORMAL
- en: We will use `View` components to hold the game world view and add 3D object
    entities and text to the game. Next, we will look at the `Text` component, which
    will allow us to add text to the view.
  prefs: []
  type: TYPE_NORMAL
- en: Text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Text` component is a React Native component for displaying text, and we
    will use it to render strings in a 3D space by placing `Text` components inside `View`
    components, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will compose the game world using these two React Native components, along
    with other React 360 components to integrate VR features into the game. In the
    next section, we will go over the React 360 components that will let us add interactive
    VR objects in the game world.
  prefs: []
  type: TYPE_NORMAL
- en: Components for the 3D VR experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React 360 provides a set of its own components to create the VR experience.
    Specifically, we will use the `Entity` component to add 3D objects and a `VrButton`
    component to capture clicks from the user. We will discuss the `Entity` and `VrButton`
    components in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Entity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to add 3D objects to the game world, we will use the `Entity` component,
    which allows us to render 3D objects in React 360\. The `Entity` component can
    be added in the view as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Files containing the specific 3D object''s information are added to the `Entity`
    component using a `source` attribute. The `source` attribute takes an object of
    key-value pairs to map resource file types to their locations. React 360 supports
    the Wavefront OBJ file format, which is a common representation for 3D models.
    So, in the `source` attribute, the `Entity` component supports the following keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '`obj`: The location of an OBJ-formatted model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mtl`: The location of an MTL-formatted material (the companion to OBJ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The values for the `obj` and `mtl` properties point to the location of these
    files and can be static strings, `asset()` calls, `require()` statements, or URI
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: OBJ (or .OBJ) is a geometry definition file format that was first developed
    by Wavefront Technologies. It is a simple data format that represents 3D geometry
    as a list of vertices and texture vertices. OBJ coordinates have no units, but
    OBJ files can contain scale information in a human-readable comment line. You
    can learn more about this format at [paulbourke.net/dataformats/obj/](http://paulbourke.net/dataformats/obj/).
  prefs: []
  type: TYPE_NORMAL
- en: MTL (or .MTL) are material library files that contains one or more material
    definitions, each of which includes the color, texture, and reflection map of
    individual materials. These are applied to the surfaces and vertices of objects.
    You can learn more about this format at [paulbourke.net/dataformats/mtl/](http://paulbourke.net/dataformats/mtl/).
  prefs: []
  type: TYPE_NORMAL
- en: The `Entity` component also takes `transform` property values in the `style`
    attribute, so the objects can be placed at the desired positions and orientations
    in the 3D world space.
  prefs: []
  type: TYPE_NORMAL
- en: In our MERN VR Game application, makers will add URLs pointing to the VR object
    files (both `.obj` and `.mtl`) for each of their `Entity` objects in a game, and
    also specify the `transform` property values to indicate where and how the 3D
    objects should be placed in the game world.
  prefs: []
  type: TYPE_NORMAL
- en: A good source of 3D objects is [https://clara.io/](https://clara.io/), with
    multiple file formats available for download and use.
  prefs: []
  type: TYPE_NORMAL
- en: The `Entity` component will render 3D objects in the 3D world space. In order
    to make these objects interactive, we need to use the `VrButton` component, which
    is discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: VrButton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `VrButton` component in React 360 will help us to implement a simple, button-style `onClick`
    behavior for the objects and `Text` buttons that will be added to the game. A
    `VrButton` component is not visible in the view by default and will only act as
    a wrapper to capture events, but it can be styled in the same way as a `View`
    component, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This component is a helper for managing click-type interactions from the user
    across different input devices. Input events that will trigger the click event
    include a spacebar press on the keyboard, a left-click on the mouse, and a touch
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The `Entity` and `VrButton` components from React 360 will allow us to render
    interactive 3D objects in the game world. To integrate other VR functionalities
    such as setting the background scene and playing audio in the game world, we will
    explore relevant options from the React 360 API in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The React 360 API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides the React 360 components discussed in the previous section, we will
    utilize the APIs provided by React 360 to implement functionality such as setting
    the background scene, playing audio, dealing with external links, adding styles,
    capturing the current orientation of the user's view, and using static asset files.
    In the following sections, we will explore the `Environment` API, the `Audio`
    and `Location` native modules, the `StyleSheet` API, the `VrHeadModel` module,
    and the asset specification options.
  prefs: []
  type: TYPE_NORMAL
- en: Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the game, we will set the world or background scene with equirectangular
    panoramic images. We will use the `Environment` API from React 360 to change this
    background scene dynamically from the React code using its `setBackgroundImage`
    method. This method can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This method sets the current background image with the resource at the specified
    URL. When we integrate the React 360 game code with the MERN stack containing
    the game application backend, we can use this to set the game world image dynamically
    using image links provided by the user. In the next section, we will explore native
    modules that will allow us to play audio in this rendered scene in the browser,
    and provide access to the browser location.
  prefs: []
  type: TYPE_NORMAL
- en: Native modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Native modules in React 360 provide us with the ability to access functionality
    that is only available in the main browser environment. In the game, we will use
    `AudioModule` in `NativeModules`, to play sounds in response to user activity,
    and the `Location` module, to give us access to `window.location` in the browser
    to handle external links. These modules can be accessed in `index.js`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can use these imported modules in the code to manipulate the audio and location
    URL in the browser. In the following sections, we will explore how these modules
    can be used to implement the features of the game.
  prefs: []
  type: TYPE_NORMAL
- en: AudioModule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the user interacts with the 3D objects in the game, we will play sounds
    based on whether the object can be collected or not, and also whether the game
    has been completed. The `AudioModule` in `NativeModules` allows us to add sound
    to the VR world as background environmental audio, one-off sound effects, and
    spatial audio. In our game, we will use environmental audio and one-off sound
    effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Environmental audio**: To play audio on loop and set the mood when the game
    is successfully completed, we will use the `playEnvironmental` method, which takes
    an audio file path as the `source` attribute, and the `loop` option as a `playback`
    parameter, as shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**Sound effects**: To play a single sound once when the user clicks on 3D objects,
    we will use the `playOneShot` method that takes an audio file path as the `source` attribute,
    as shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `source` attribute in the options passed to `playEnvironmental` and `playOneShot`
    takes a resource file location to load the audio. It can be an `asset()` statement
    or a resource URL declaration in the form of `{uri: ''PATH''}`.'
  prefs: []
  type: TYPE_NORMAL
- en: We will call these `AudioModule` methods to play specified audio files as needed
    from the game implementation code. In the next section, we will look at how we
    can use the `Location` module, which is another native module in React 360.
  prefs: []
  type: TYPE_NORMAL
- en: Location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we integrate the React 360 code containing the game with the MERN stack
    containing the game application backend, the VR game will be launched from the
    MERN server at a declared route containing the specific game's ID. Then, once
    a user completes a game, they will also have the option to leave the VR space
    and go to a URL containing a list of other games. To handle these incoming and
    outgoing app links in the React 360 code, we will utilize the `Location` module
    in `NativeModules`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Location` module is essentially the `Location` object returned by the
    read-only `window.location` property in the browser. We will use the `replace` method
    and the `search` property in the `Location` object to implement features related
    to external links. We will handle outgoing and incoming links as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Handling outgoing links**: When we want to direct the user out of the VR
    application to another link, we can use the `replace` method in `Location`, as
    shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**Handling incoming links**: When the React 360 app is launched from an external
    URL and after the registered component mounts, we can access the URL and retrieve
    its query string part using the `search` property in `Location`, as shown in the
    following code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For the purpose of integrating this React 360 component with MERN VR Game, and
    dynamically loading game details, we will capture this initial URL to parse the
    game ID from a query parameter and then use it to make a read API call to the
    MERN application server. This implementation is elaborated further in [Chapter
    11](17bbfed7-9867-4c8b-99fd-42581044a906.xhtml), *Making the VR Game Dynamic Using
    MERN*.
  prefs: []
  type: TYPE_NORMAL
- en: Besides using these native modules from the React 360 API, we will also use
    the StyleSheet API to add styling to the components rendered to make the game
    view. We will demonstrate how to use the StyleSheet API in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: StyleSheet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The StyleSheet API from React Native can also be used in React 360 to define
    several styles in one place rather than adding styles to individual components.
    The styles can be defined using StyleSheet, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'These style objects defined using `StyleSheet.create` can be added to components
    as required, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will apply the CSS styles to the `View` and `Text` components accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The default distance units for CSS properties, such as width and height, are
    in meters when mapping to 3D space in React 360, whereas the default distance
    units are in pixels for 2D interfaces in React Native.
  prefs: []
  type: TYPE_NORMAL
- en: We will use StyleSheet in this way to define styles for the components that
    will make up the game view. In the next section, we will discuss the `VrHeadModel`
    module in React 360, which will allow us to figure out where the user is currently
    looking.
  prefs: []
  type: TYPE_NORMAL
- en: VrHeadModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`VrHeadModel` is a utility module in React 360 that simplifies the process
    of obtaining the current orientation of the headset. Since the user is moving
    around in a VR space, when the desired feature requires that an object or piece
    of text should be placed in front of or with respect to the user''s current orientation,
    it becomes necessary to know exactly where the user is currently gazing.'
  prefs: []
  type: TYPE_NORMAL
- en: In MERN VR Game, we will use this to show the game completed message to the
    user in front of their view, no matter where they end up turning to from their
    initial position. For example, the user may be looking up or down when collecting
    the final object, and the completed message should pop up wherever the user is
    gazing.
  prefs: []
  type: TYPE_NORMAL
- en: To implement this, we will retrieve the current head matrix as an array of numbers
    using `getHeadMatrix()` from `VrHeadModel`, and set it as a value for the `transform`
    property in the style attribute of the `View` component containing the game completed
    message.
  prefs: []
  type: TYPE_NORMAL
- en: This will render the message at the location where the user is currently gazing.
    We will see the usage of this `getHeadMatrix()` function later in the chapter, in
    the *Building the game view in React 360 *section. In the next section, we will
    discuss how static assets can be loaded in React 360.
  prefs: []
  type: TYPE_NORMAL
- en: Loading assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to load any static asset files such as image or audio files in the
    code, we can utilize the `asset` method in React 360\. This `asset()` functionality
    in React 360 allows us to retrieve external resource files, including audio and
    image files.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we will place the sound audio files for the game in the `static_assets`
    folder, to be retrieved using `asset()` for each audio added to the game, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This will load the audio file to be played in the call to `playOneShot`.
  prefs: []
  type: TYPE_NORMAL
- en: With these different APIs and modules available in React 360, we will integrate
    different features for the VR game such as setting the background scene, playing
    audio, adding styles, loading static files, and retrieving the user orientation.
    In the next section, we will look at some of the input events available in React
    360 that will allow us to make the game interactive.
  prefs: []
  type: TYPE_NORMAL
- en: React 360 input events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to make the game interface interactive, we will utilize some of the
    input event handlers exposed in React 360\. Input events are collected from mouse,
    keyboard, touch, and gamepad interactions, and also with the `gaze` button click
    on a VR headset.
  prefs: []
  type: TYPE_NORMAL
- en: 'The specific input events we will work with are the `onEnter`, `onExit`, and
    `onClick` events, as discussed in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onEnter`: This event is fired whenever the platform cursor begins intersecting
    with a component. We will capture this event for the VR objects in the game, so
    the objects can start rotating around the *y* axis when the platform cursor enters
    the specific object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onExit`: This event is fired whenever the platform cursor stops intersecting
    with a component. It has the same properties as the `onEnter` event and we will
    use it to stop rotating the VR object just exited.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onClick`: The `onClick` event is used with the `VrButton` component, and is
    fired when there is click interaction with `VrButton`. We will use this to set
    click event handlers on the VR objects, and also on the game complete message
    to redirect the user out of the VR application to a link containing a list of
    games.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These events will allow us to add actions to the game, which happens when the
    user does something.
  prefs: []
  type: TYPE_NORMAL
- en: While implementing the VR game, we will apply 3D world concepts to determine
    how to set the game world with equirectangular panoramic images, and position
    VR objects in this world based on the 3D coordinate system. We will use React
    360 components such as `View`, `Text`, `Entity`, and `VrButton` to render the
    VR game view. We can also use available React 360 APIs to load audio and external
    URLs for the VR game in the browser environment. Finally, we can utilize available
    React 360 events that capture user interactions to make the VR game interactive.
    With the VR-related concepts, React 360 components, APIs, modules, and events
    discussed in this section, we are ready to define the specific game data details
    before we start implementing the complete VR game using these concepts. In the
    next section, we will go over the game data structure and details.
  prefs: []
  type: TYPE_NORMAL
- en: Defining game details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each game in MERN VR Game will be defined in a common data structure that the
    React 360 application will also adhere to when rendering the individual game details.
    In the following sections, we will discuss the data structure for capturing a
    game's details, and then highlight the difference between using static game data
    and dynamically loaded game data.
  prefs: []
  type: TYPE_NORMAL
- en: Game data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The game data will consist of details such as the game''s name, a URL pointing
    to the location of the equirectangular image for the game world, and two arrays
    containing details for each VR object to be added to the game world. The following
    list indicates the fields corresponding to the game data attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: A string representing the name of the game'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`world`: A string with the URL pointing to the equirectangular image either
    hosted on cloud storage, CDNs, or stored on MongoDB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`answerObjects`: An array of JavaScript objects containing details of the VR
    objects that can be collected by the player'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wrongObjects`: An array of JavaScript objects containing details of the other
    VR objects to be placed in the VR world that cannot be collected by the player'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These details will define each game in the MERN VR Game application. The arrays
    containing the VR object details will store properties of each object to be added
    to the 3D world in the game. In the following section, we will go over the details
    representing a VR object in these arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Details of VR objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The two arrays in the game data structure will store details of the VR objects
    to be added in the game world. The `answerObjects` array will contain details
    of the 3D objects that can be collected, and the `wrongObjects` array will contain
    details of 3D objects that cannot be collected. Each object will contain links
    to the 3D data resource files and `transform` style property values. In the following
    list, we will go over these specific details to be stored for each object:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OBJ and MTL links**: The 3D data information resources for the VR objects
    will be added to the `objUrl` and `mtlUrl` attributes. These attributes will contain
    the following values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`objUrl`: The link to the `.obj` file for the 3D object'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mtlUrl`: The link to the accompanying `.mtl` file'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `objUrl` and `mtlUrl` links may point to files either hosted on cloud storage,
    CDNs, or stored on MongoDB. For MERN VR Game, we will assume that makers will
    add URLs to their own hosted OBJ, MTL, and equirectangular image files.
  prefs: []
  type: TYPE_NORMAL
- en: '**Translation values**: The position of the VR object in the 3D space will
    be defined with the `translate` values in the following attributes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`translateX`: The translation value of the object along the *x* axis'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`translateY`: The translation value of the object along the *y* axis'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`translateZ`: The translation value of the object along the *z* axis'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All translation values are numbers in meters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Rotation values**: The orientation of the 3D object will be defined with
    the `rotate` values in the following keys:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotateX`: The rotation value of the object around the *x* axis; in other words,
    turning the object up or down'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotateY`: The rotation value of the object around the *y* axis that would
    turn the object left or right'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotateZ`: The rotation value of the object around the *z* axis, making the
    object tilt forward or backward'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All rotation values are in numbers or string representations of a number in
    degrees.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scale value**: The `scale` value will define the relative size and appearance
    of the 3D object in the 3D environment:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale`: A number value that defines uniform scale across all axes'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Color**: If the 3D object''s material texture is not provided in an MTL file,
    a color value can be defined to set the default color of the object in the `color`
    attribute:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color`: A string value representing color values allowed in CSS'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These attributes will define the details of each VR object to be added to the
    game.
  prefs: []
  type: TYPE_NORMAL
- en: With this game data structure capable of holding the details of the game and
    its VR objects, we can implement the game in React 360 accordingly with sample
    data values. In the next section, we will look at sample game data and distinguish
    between setting game data statically in contrast to loading it dynamically for
    different games.
  prefs: []
  type: TYPE_NORMAL
- en: Static data versus dynamic data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While integrating the game developed using React 360 with the MERN-based application
    in the next chapter, we will update the React 360 code to fetch game data dynamically
    from the backend database. This will render the React 360 game view with different
    games stored in the database. For now, we will start developing the game features
    here with dummy game data that is set in component state. The sample game data
    will be set as follows, using the defined game data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This game object holds the details of a sample game including the name, a link
    to the 360 world image, and two object arrays with one 3D object detailed in each
    array. For initial development purposes, this sample game data can be set in state
    to be rendered in the game view. Using this game structure and data, in the next
    section, we will implement the game features in React 360.
  prefs: []
  type: TYPE_NORMAL
- en: Building the game view in React 360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will apply the React 360 concepts and use the game data structure to implement
    the game features for each game in the MERN VR Game application. For these implementations,
    we will update the default starter code generated in the `index.js` and `client.js` files
    within the initiated React 360 project.
  prefs: []
  type: TYPE_NORMAL
- en: For a working version of the game, we will start with the `MERNVR` component's
    state that was initialized using the sample game data from the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MERNVR` component is defined in `index.js`, and the code will be updated
    with the game data in state, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will make the sample game's details available for building the rest of
    the game features. In the following sections, we will update the code in the `index.js`
    and `client.js` files to first mount the game world, define the CSS styles, and
    load the 360-degree environment for the game. Then, we will add the 3D VR objects
    to the game, make these objects interactive, and implement behavior that indicates
    the game is completed.
  prefs: []
  type: TYPE_NORMAL
- en: Updating client.js and mounting to Location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The default code in `client.js` attaches the mount point declared in `index.js`
    to the default `Surface` in the React 360 app, where `Surface` is a cylindrical
    layer that is used for placing a 2D user interface. In order to use the 3D meter-based
    coordinate system for a layout in 3D space, we need to mount to a `Location` object
    instead of a `Surface`. So, we will update `client.js` to replace the `renderToSurface`
    with a `renderToLocation`, as highlighted in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/client.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will mount our game view to a React 360 `Location`.
  prefs: []
  type: TYPE_NORMAL
- en: You can also customize the initial background scene by updating the `r360.compositor.setBackground(**r360.getAssetURL('360_world.jpg')**)` code
    in `client.js` to use your desired image.
  prefs: []
  type: TYPE_NORMAL
- en: With this update added in `client.js`, we can move on to updating the code in
    `index.js`, which will contain our game functionalities. In the next section,
    we will start by defining CSS styles for the elements to be rendered in the game
    view.
  prefs: []
  type: TYPE_NORMAL
- en: Defining styles with StyleSheet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `index.js`, we will update the default styles generated in the initial React
    360 project to add our own CSS rules. In the `StyleSheet.create` call, we will
    define style objects to be used with the components in the game, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: For the game features implemented in this book, we are keeping the styling simple
    with CSS declared for only the text and button to be displayed when the game is
    completed. In the next section, we will look at how to load the 360 panoramic
    image that will represent the 3D world for each game.
  prefs: []
  type: TYPE_NORMAL
- en: World background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to set the game''s 360-degree world background, we will update the
    current background scene using the `setBackgroundImage` method from the `Environment`
    API. We will call this inside the `componentDidMount` of the `MERNVR` component
    defined in `index.js`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This will replace the default 360-degree background in the starter React 360
    project with our sample game''s world image fetched from cloud storage. If you
    are editing the default React 360 application and have it running, refreshing
    the `http://localhost:8081/index.html` link in the browser should show an outer
    space background, which you can pan across using the mouse:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee255992-346f-4421-97dd-0faf23675ac0.png)'
  prefs: []
  type: TYPE_IMG
- en: To generate the preceding screenshot, the `View` and `Text` components in the
    default code were also updated with custom CSS rules to show this hello text on
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we will have a 360-degree game world that can be explored by the
    user. In the next section, we will explore how to place 3D objects in this world.
  prefs: []
  type: TYPE_NORMAL
- en: Adding 3D VR objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will add 3D objects to the game world using `Entity` components from React
    360, along with the sample object details in the `answerObjects` and `wrongObjects`
    arrays that were defined for the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will concatenate the `answerObjects` and `wrongObjects` arrays in
    `componentDidMount` to form a single array containing all of the VR objects, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us a single array containing all of the VR objects for the game.
    Then, in the main view, we will iterate over this merged `vrObjects` array to
    render the `Entity` components with details of each object. The iteration code
    will be added using `map`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `obj` and `mtl` file links are added to the `source` prop in `Entity`, and
    the `transform` style details are applied in the `Entity` component's styles with
    the call to `setModelStyles`. The `setModelStyles` method constructs the styles
    for the specific VR object to be rendered, using values defined in the VR object's
    details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `setModelStyles` method is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `display` property will allow us to show or hide an object based on whether
    it has already been collected by the player or not. The `translate` and `rotate`
    values will render the 3D objects in the desired positions and orientations across
    the VR world. Next, we will update the `Entity` code further to enable user interactions
    with these 3D objects.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with VR objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to make the VR game objects interactive, we will use the React 360
    event handlers, such as `onEnter` and `onExit` with `Entity`, and `onClick` with
    `VrButton`, to add rotation animation and gameplay behavior. In the following
    sections, we will add the implementations for rotating a VR object when a user
    focuses on it, and for adding click behavior on the objects to allow a user to
    collect the correct objects in the game.
  prefs: []
  type: TYPE_NORMAL
- en: Rotating a VR object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to add a feature that starts rotating a 3D object around its *y* axis
    whenever a player focuses on the 3D object, that is, when the platform cursor
    begins intersecting with the `Entity` component rendering the specific 3D object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will update the `Entity` component from the previous section to add the
    `onEnter` and `onExit` handlers, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The object rendered with this `Entity` component will start rotating on a cursor
    entry or focus on the object, and it will stop when the platform cursor exits
    the object and is no longer in the player's focus. In the following section, we
    will discuss the implementation of this rotation animation.
  prefs: []
  type: TYPE_NORMAL
- en: Animation with requestAnimationFrame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The rotation behavior for each 3D object is implemented in the event handlers
    added to the `Entity` component, which is rendering the 3D object. Specifically,
    in the `rotate(index)` and `stopRotate()` handler methods that are called when
    the `onEnter` and `onExit` events occur, we will implement rotation animation
    behavior using `requestAnimationFrame` for smooth animations in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: The `window.requestAnimationFrame()` method asks the browser to call a specified
    callback function to update an animation before the next repaint. With `requestAnimationFrame`,
    the browser optimizes the animations to make them smoother and more resource-efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `rotate` method, we will update the `rotateY` transform value of
    the given object at a steady rate on a set time interval with `requestionAnimationFrame`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `requestAnimationFrame` method will take the `rotate` method as a recursive
    callback function, then execute it to redraw each frame of the rotation animation
    with the new values, and, in turn, update the animation on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `requestAnimateFrame` method returns a `requestID`, which we will use in
    the call to `stopRotate`, so the animation gets canceled in the `stopRotate` method.
    This `stopRotate` method is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This will implement the functionality of animating the 3D object only when
    it is in the viewer''s focus. As shown in the following screenshot, the 3D Rubik''s
    cube rotates clockwise around its *y* axis while it is in focus:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4e0594f-f0cf-4b75-a370-17cb575b375d.png)'
  prefs: []
  type: TYPE_IMG
- en: Though not covered here, it is also worth exploring the React 360 Animated library,
    which can be used to compose different types of animations. Core components can
    be animated natively with this library, and it is possible to animate other components
    using `createAnimatedComponent()`. This library was originally implemented from
    React Native; to learn more, you can refer to the React Native documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Now the users playing the game will observe motion when they focus on any of
    the VR objects placed in the game world. In the next section, we will add the
    functionality for capturing user clicks on these objects.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on the 3D objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to register the click behavior on each 3D object added to the game,
    we need to wrap the `Entity` component with a `VrButton` component that can call
    the `onClick` handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will update the `Entity` component added inside the `vrObjects` array iteration
    code, to wrap it with the `VrButton` component, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `VrButton` component will call the `collectItem` method when clicked on,
    and pass it the current object's details.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a 3D object is clicked on by a user, we need the `collectItem` method
    to perform the following actions with respect to the game features:'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether the clicked object is an `answerObject` or a `wrongObject`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on the object type, play the associated sound.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the object is an `answerObject`, it should be collected and removed from
    view, then added to a list of collected objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check whether all instances of `answerObject` were successfully collected with
    this click:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If yes, show the game completed message to the player and play the sound for game
    completed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will implement these actions in the `collectItem` method with the following
    structure and steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Any time a VR object is clicked on by the user, in this method, we will first
    check the type of the object before taking the related actions. We will discuss
    the implementation of these steps and actions in detail in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting the correct object on click
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a user clicks on a 3D object, we need to first check whether the clicked
    object is an answer object. If it is, this object will be *collected* and hidden
    from view, and a list of collected objects will be updated along with the total
    number to keep track of the user's progress in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether the clicked VR object is an `answerObject`, we will use the
    `indexOf` method to find a match in the `answerObjects` array, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If the `vrObject` is an `answerObject`, `indexOf` will return the array index
    of the matched object; otherwise, it will return `-1` if no match is found.
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep track of collected objects in the game, we will also maintain an array
    of Boolean values in `collectedList` at corresponding indices, and the total number
    of objects collected so far in `collectedNum`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `collectedList` array, we will also determine which `Entity` component
    should be hidden from the view because the associated object was collected. The
    `display` style property of the relevant `Entity` component will be set based
    on the Boolean value of the corresponding index in the `collectedList` array.
    We set this in the style for the `Entity` component using the `setModelStyles`
    method, as shown earlier in the *Adding 3D VR objects* section. This display style
    value is set conditionally with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Depending on whether the array index of the rendered VR object is set to true
    in the collected list of objects, we hide or show the `Entity` component in the
    view.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following screenshot, the treasure chest can be clicked
    on to be collected as it is an `answerObject`, whereas the flower pot cannot be
    collected because it is a `wrongObject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6f20097-fa73-4e6d-bc13-42e071be5f90.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the treasure chest is clicked on, it disappears from the view as the `collectedList`
    is updated, and we also play the sound effect for collection using `AudioModule.playOneShot` with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'However, when the flower pot is clicked on, and it is identified as a wrong
    object, we play another sound effect indicating it cannot be collected, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As the flower pot was identified to be a wrong object, the `collectedList`
    was not updated and it remains on the screen, whereas the treasure chest is gone, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1a2710e-819b-48d2-84d6-57e71f478797.png)'
  prefs: []
  type: TYPE_IMG
- en: The complete code in the `collectItem` method that executes all of these steps
    when an object is clicked on will be as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: After a clicked object is collected using this method, we will also check whether
    all of the `answerObjects` have been collected and whether the game is complete
    with a call to the `checkGameCompleteStatus` method. We will take a look at the
    implementation of this method and the game completed functionality in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Game completed state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every time an `answerObject` is collected, we will check whether the total
    number of collected items is equal to the total number of objects in the `answerObjects`
    array to determine whether the game is complete. We will achieve this by calling
    the `checkGameCompleteStatus` method, which will perform this check, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In this method, we first confirm that the game is indeed complete, and then
    we perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Play the audio for game completed, using `AudioModule.playEnvironmental`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetch the current `headMatrix` value using `VrHeadModel` so that it can be set
    as the transform matrix value for the `View` component containing the game completion
    message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the `display` style property of the `View` message to `flex`, so the message
    renders to the viewer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `View` component containing the message congratulating the player for completing
    the game will be added to the parent `View` component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to the `setGameCompletedStyle()` method will set the styles for the
    `View` message with the updated `display` value and the `transform` matrix value. The `setGameCompletedStyle` method
    is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'These style values will render the `View` component with the completion message
    at the center of the user''s current view, regardless of whether they are looking
    up, down, behind, or forward in the 360-degree VR world, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c0f6b18-b1d5-42f9-8366-626522807d36.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The final text in the `View` message will act as a button, as we wrapped this
    `View` in a `VrButton` component that calls the `exitGame` method when clicked.
    The `exitGame` method is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/MERNVR/index.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `exitGame` method will use the `Location.replace` method to redirect the
    user to an external URL that may contain a list of games.
  prefs: []
  type: TYPE_NORMAL
- en: The `replace` method can be passed any valid URL, and once this React 360 game
    code is integrated with the MERN VR Game application in [Chapter 14](17bbfed7-9867-4c8b-99fd-42581044a906.xhtml),
    *Making the VR Game Dynamic Using MERN*, `replace('/')` will take the user to
    the home page of the whole application.
  prefs: []
  type: TYPE_NORMAL
- en: The VR game functionalities are complete with these updates to the React 360
    project. It is now possible to set a 360-degree panoramic background as the game
    world and add interactive VR objects to this world. These 3D objects will rotate
    in place and can be collected based on user interaction if the game rules allow
    it. In the next section, we will demonstrate how to bundle this React 360 code
    so that the game can be integrated with a MERN-based web application.
  prefs: []
  type: TYPE_NORMAL
- en: Bundling for production and integration with MERN
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have features of the VR game implemented and are functional with
    the sample game data, we can prepare it for production and add it to our MERN-based
    application to see how VR can be added to an existing web application. In the
    following sections, we will look at how to bundle the React 360 code, integrate
    it with a MERN application, and test the integration by running the game from
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: Bundling React 360 files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React 360 tools provide a script to bundle all of the React 360 application
    code into a few files that we can just place on the MERN web server and serve
    as content at a specified route. To create the bundled files, we can run the following
    command in the React 360 project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates compiled versions of the React 360 application files in a folder
    called `build`. The compiled bundle files are `client.bundle.js` and `index.bundle.js`.
    These two files, in addition to the `index.html` file and the `static-assets/`
    folder, make up the production version of the whole React 360 application that
    was developed. The final production code will be in the following folder and files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We will have to take these folders and files over to a MERN project directory
    to integrate the game with the MERN application, as discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with a MERN application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to integrate the game developed in React 360 with a MERN-based web
    application, we will first bring the React 360 production files discussed in the
    previous section to our MERN application project. Then, we will update the bundle
    file references in the generated `index.html` code to point to the new location
    of the bundle files, before loading the `index.html` code at a specified route
    in the Express app.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the React 360 production files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With consideration to the folder structure in the existing MERN skeleton application,
    we will add the `static_assets` folder and the bundle files from the React 360
    production files to the `dist/` folder. This will keep our MERN code organized
    with all the bundles in the same location. The `index.html` file will be placed
    in a new folder, named `vr` in the `server` folder, as highlighted in the following
    folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This will bring the React 360 code over to the MERN application. However, to
    make it functional, we need to update the file references in the `index.html`
    code, as discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Updating references in index.html
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `index.html` file, which was generated after bundling the React 360 project,
    references the bundle files expecting these files to be in the same folder, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We need to update this `index.html` code to refer to the correct location of
    the `client.bundle.js`, `index.bundle.js`, and `static_assets` folders.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, update the reference to `client.bundle.js` as follows, to point to the
    file we placed in the `dist` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, update the `React360.init` call with the correct reference to `index.bundle.js`,
    and `assetRoot` set to the correct location of the `static_assets` folder, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `assetRoot` specifies where to look for asset files when we use `asset()`
    to set resources in the React 360 components.
  prefs: []
  type: TYPE_NORMAL
- en: The game view implemented with React 360 is now available in the MERN application.
    In the next section, we will try out this integration by setting up a route to
    load the game from the web application.
  prefs: []
  type: TYPE_NORMAL
- en: Trying out the integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we set up an Express route in the MERN application to return the `index.html` file
    in the response, then visiting the route in the browser will render the React
    360 game. To test out this integration, we can set up an example route, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This declares a `GET` route in the `'/game/play'` path, which will simply return
    the `index.html` file that we placed in the `vr` folder with the server code,
    in response to the requesting client.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we can run the MERN server and open this route in the browser at `localhost:3000/game/play`.
    This should render the complete React 360 game implemented in this chapter from
    within the MERN-based web application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we used React 360 to develop a web-based VR game that can be
    easily integrated into MERN applications.
  prefs: []
  type: TYPE_NORMAL
- en: We began by defining simple VR features for the gameplay. Then, we set up React
    360 for development and looked at key VR concepts, such as equirectangular panoramic
    images, 3D positions, and coordinate systems in the 360-degree VR world. We explored
    the React 360 components and APIs required to implement the game features, including
    components such as `View`, `Text`, `Entity`, and `VrButton`, along with the `Environment`, `VrHeadModel`, and
    `NativeModules` APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we updated the code in the starter React 360 project to implement the
    game with sample game data, then we bundled the code files and discussed how to
    add these compiled files to an existing MERN application.
  prefs: []
  type: TYPE_NORMAL
- en: With these steps covered, you will now be able to build your own VR interfaces
    with React 360, which can be easily integrated with any MERN-based web application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will develop the MERN VR Game application, complete
    with a game database and backend APIs. This is so that we can make the game developed
    in this chapter dynamic by fetching data from a game collection stored in MongoDB.
  prefs: []
  type: TYPE_NORMAL
