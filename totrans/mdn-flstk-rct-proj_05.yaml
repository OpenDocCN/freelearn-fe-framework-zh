- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Implementing a Backend Using Express, Mongoose ODM, and Jest
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Express、Mongoose ODM和Jest实现后端
- en: After learning the basics of Node.js and MongoDB, we will now put them into
    practice by building our first backend service using Express to provide a REST
    API, Mongoose **object data modeling** (**ODM**) to interface with MongoDB, and
    Jest to test our code. We will first learn how to structure a backend project
    using an architectural pattern. Then, we will create database schemas using Mongoose.
    Next, we will make service functions to interface with the database schemas and
    write tests for them using Jest. Then, we will learn what REST is and when it
    is useful. Finally, we provide a REST API and serve it using Express. At the end
    of this chapter, we will have a working backend service to be consumed by a frontend
    developed in the next chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了Node.js和MongoDB的基础知识之后，我们将通过使用Express提供REST API、Mongoose **对象数据建模**（**ODM**）与MongoDB接口以及Jest测试我们的代码来将它们付诸实践。我们首先将学习如何使用架构模式来构建后端项目。然后，我们将使用Mongoose创建数据库模式。接下来，我们将创建服务函数以与数据库模式接口，并使用Jest为它们编写测试。然后，我们将学习REST是什么以及何时有用。最后，我们将提供一个REST
    API并使用Express来提供服务。在本章结束时，我们将拥有一个可供下一章开发的前端使用的工作后端服务。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主要内容：
- en: Designing a backend service
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计后端服务
- en: Creating database schemas using Mongoose
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Mongoose创建数据库模式
- en: Developing and testing service functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发和测试服务函数
- en: Providing a REST API using Express
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Express提供REST API
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before we start, please install all requirements from [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016),
    *Preparing for Full-stack Development*, and [*Chapter 2*](B19385_02.xhtml#_idTextAnchor028),
    *Getting to Know Node.js* *and MongoDB*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请从[*第1章*](B19385_01.xhtml#_idTextAnchor016)，*为全栈开发做准备*，以及[*第2章*](B19385_02.xhtml#_idTextAnchor028)，*了解Node.js*和*MongoDB*中安装所有要求。
- en: The versions listed in those chapters are the ones used in the book. While installing
    a newer version should not be an issue, please note that certain steps might work
    differently on a newer version. If you are having an issue with the code and steps
    provided in this book, please try using the versions mentioned in *Chapters 1*
    and *2*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那些章节中列出的版本是本书中使用的版本。虽然安装较新版本可能不会出现问题，但请注意，某些步骤在较新版本上可能有所不同。如果您在使用本书中提供的代码和步骤时遇到问题，请尝试使用*第1章*和*第2章*中提到的版本。
- en: You can find the code for this chapter on GitHub at [https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch3](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch3).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码：[https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch3](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch3)。
- en: If you cloned the full repository for the book, Husky may not find the `.git`
    directory when running `npm install`. In that case, just run `git init` in the
    root of the corresponding chapter folder.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您克隆了本书的完整仓库，当运行`npm install`时，Husky可能找不到`.git`目录。在这种情况下，只需在相应章节文件夹的根目录中运行`git
    init`即可。
- en: 'The CiA video for the chapter can be found at: [https://youtu.be/fFHVVVn03rc](https://youtu.be/fFHVVVn03rc).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可以在以下网址找到：[https://youtu.be/fFHVVVn03rc](https://youtu.be/fFHVVVn03rc)。
- en: Designing a backend service
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计后端服务
- en: 'To design our backend service, we are going to use a variation of an existing
    architectural pattern called **model–view–controller** (**MVC**) pattern. The
    MVC pattern consists of the following parts:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设计我们的后端服务，我们将使用一种名为**模型-视图-控制器**（**MVC**）的现有架构模式的变体。MVC模式包括以下部分：
- en: '**Model**: Handles data and basic data logic'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：处理数据和基本数据逻辑'
- en: '**Controller**: Controls how data is processed and displayed'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：控制数据的处理和显示方式'
- en: '**View**: Displays the current state'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：显示当前状态'
- en: 'In traditional full-stack applications, the backend would render and display
    the frontend completely, and an interaction would usually require a full-page
    refresh. The MVC architecture was designed mainly for such applications. However,
    in modern applications, the frontend is usually interactive and rendered in the
    backend only through server-side rendering. In modern applications, we thus often
    distinguish between the actual backend service(s) and the backend for frontend
    (which handles static site generation and server-side rendering):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的全栈应用中，后端会完全渲染和显示前端，通常一个交互需要整个页面的刷新。MVC 架构主要是为这类应用设计的。然而，在现代应用中，前端通常是交互式的，并且仅通过服务器端渲染在后台进行渲染。因此，在现代应用中，我们通常区分实际的底层服务（服务）和用于前端的后台（处理静态站点生成和服务器端渲染）：
- en: '![Figure 3.1 – A modern full-stack architecture, with a single backend service
    and a frontend with server-side rendering (SSR) and static-site generation (SSG)](img/B19385_03_1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 一个现代全栈架构，包含单个后端服务和具有服务器端渲染（SSR）和静态站点生成（SSG）的前端](img/B19385_03_1.jpg)'
- en: Figure 3.1 – A modern full-stack architecture, with a single backend service
    and a frontend with server-side rendering (SSR) and static-site generation (SSG)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 一个现代全栈架构，包含单个后端服务和具有服务器端渲染（SSR）和静态站点生成（SSG）的前端
- en: 'For modern applications, the idea is that the backend service only deals with
    processing and serving requests and data and does not render the user interface
    anymore. Instead, we have a separate application that handles the frontend and
    server-side rendering of user interfaces specifically. To adapt to this change,
    we adjust the MVC architectural pattern to a data-service-route pattern for the
    backend service as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现代应用，后端服务只处理处理和提供请求及数据，不再渲染用户界面。相反，我们有一个专门处理前端和用户界面服务器端渲染的独立应用。为了适应这种变化，我们将
    MVC 架构模式调整为适用于后端服务的以下数据-服务-路由模式：
- en: '**Route layer**: Defines routes that consumers can access and handles user
    input by processing the request parameters and body and then calling service functions'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由层**：定义消费者可以访问的路由，并通过处理请求参数和主体来处理用户输入，然后调用服务函数'
- en: '**Service layer**: Provides service functions, such as **create–read–update–delete**
    (**CRUD**) functions, which access the database through the data layer'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务层**：提供服务函数，例如 **创建-读取-更新-删除**（**CRUD**）函数，这些函数通过数据层访问数据库'
- en: '**Data layer**: Only deals with accessing the database and does basic validation
    to ensure that the database is consistent'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据层**：仅处理访问数据库和进行基本验证以确保数据库的一致性'
- en: This separation of concerns works best for services that only expose routes
    and do not deal with rendering user interfaces. Each layer in this pattern only
    deals with one step in processing the request.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关注点分离对于只暴露路由而不处理用户界面渲染的服务来说效果最佳。在这个模式中的每一层只处理请求处理中的一个步骤。
- en: After learning about the design of backend services, let’s get started creating
    a folder structure reflecting what we have learned.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了后端服务的设计之后，让我们开始创建一个反映我们所学的文件夹结构。
- en: Creating the folder structure for our backend service
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建后端服务的文件夹结构
- en: 'We are now going to create a folder structure for our backend service based
    on this pattern. Follow these steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将根据这个模式创建后端服务的文件夹结构。按照以下步骤操作：
- en: 'First, copy the **ch2** folder to a new **ch3** folder to create a new folder
    for our backend service, as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将 **ch2** 文件夹复制到新的 **ch3** 文件夹中，以创建一个新的用于后端服务的文件夹，如下所示：
- en: '[PRE0]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Open the new **ch3** folder in VS Code.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开新的 **ch3** 文件夹。
- en: 'Edit the **.eslintrc.json** file and replace the **browser** env with the **node**
    and **es6** env, as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **.eslintrc.json** 文件，将 **browser** 环境替换为 **node** 和 **es6** 环境，如下所示：
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Also, *remove* the **react** and **jsx-a11y** plugins from the **.eslintrc.json**
    file. We can also remove the React-related **settings** and **overrides** now
    by removing the highlighted lines:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，从 **.eslintrc.json** 文件中 *移除* **react** 和 **jsx-a11y** 插件。现在我们也可以通过移除高亮行来移除与
    React 相关的 **设置** 和 **覆盖**：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Delete* the **index.html** and **vite.config.js** files.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*删除* **index.html** 和 **vite.config.js** 文件。'
- en: 'We can now also *remove* the **vite.config.js** file from the **.****eslintignore**
    file:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在也可以从 **.eslintignore** 文件中 *移除* **vite.config.js** 文件：
- en: '[PRE3]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Delete* the **public**, **backend**, and **src** folders.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*删除* **public**、**backend** 和 **src** 文件夹。'
- en: 'Open the **ch3** folder in VS Code, open a Terminal and run the following commands
    to remove **vite** and **react**:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开 **ch3** 文件夹，打开一个终端并运行以下命令以移除 **vite** 和 **react**：
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Edit the **package.json** file and *remove* the **dev**, **build**, and **preview**
    scripts from it:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **package.json** 文件，并从中 *删除* **dev**、**build** 和 **preview** 脚本：
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, create a new **src/** folder, and within it, create **src/db/** (for the
    data layer), **src/services/** (for the services layer), and **src/routes/** (for
    the routes layer) folders.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个新的 **src/** 文件夹，并在其中创建 **src/db/**（用于数据层）、**src/services/**（用于服务层）和 **src/routes/**（用于路由层）文件夹。
- en: 'Our first application is going to be a blog application. For such an application,
    we are going to need the API to be able to do the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个应用程序将是一个博客应用程序。对于这样的应用程序，我们需要 API 能够执行以下操作：
- en: Get a list of posts
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取帖子列表
- en: Get a single post
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取单个帖子
- en: Create a new post
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的帖子
- en: Update an existing post
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新现有的帖子
- en: Delete an existing post
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除现有的帖子
- en: To provide these functions, we first need to create a database schema to define
    what a blog post object should look like in our database. Then, we need service
    functions to handle CRUD functionality for blog posts. Finally, we are going to
    define our REST API to query, create, update, and delete blog posts.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供这些功能，我们首先需要创建一个数据库模式来定义我们的数据库中博客文章对象的外观。然后，我们需要服务函数来处理博客文章的 CRUD 功能。最后，我们将定义我们的
    REST API 以查询、创建、更新和删除博客文章。
- en: Creating database schemas using Mongoose
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Mongoose 创建数据库模式
- en: Before we can get started defining the database schemas, we first need to set
    up Mongoose itself. Mongoose is a library that simplifies MongoDB object modeling
    by reducing the boilerplate code needed to interface with MongoDB. It also includes
    common business logic such as setting `createdAt` and `updatedAt` timestamps automatically
    and validation and type casting to keep the database state consistent.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始定义数据库模式之前，我们首先需要设置 Mongoose 本身。Mongoose 是一个库，通过减少与 MongoDB 交互所需的样板代码来简化
    MongoDB 对象建模。它还包括常见的业务逻辑，例如自动设置 `createdAt` 和 `updatedAt` 时间戳以及验证和类型转换，以保持数据库状态的一致性。
- en: 'Follow these steps to set up the `mongoose` library:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤设置 `mongoose` 库：
- en: 'First, install the **mongoose** library:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，安装 **mongoose** 库：
- en: '[PRE6]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a new **src/db/init.js** file and import **mongoose** there:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **src/db/init.js** 文件中创建一个新的 **src/db/init.js** 文件，并在其中导入 **mongoose**：
- en: '[PRE7]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Define and export a function that will initialize the database connection:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义并导出一个初始化数据库连接的函数：
- en: '[PRE8]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'First, we define **DATABASE_URL** to point to our local MongoDB instance running
    via Docker and specify **blog** as the database name:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义 **DATABASE_URL** 以指向通过 Docker 运行的本地 MongoDB 实例，并指定 **blog** 作为数据库名称：
- en: '[PRE9]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The connection string is similar to what we used in the previous chapter when
    directly accessing the database via Node.js.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 连接字符串与我们之前在通过 Node.js 直接访问数据库时使用的类似。
- en: 'Then, add a listener to the **open** event on the Mongoose connection so that
    we can show a log message once we are connected to the database:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，向 Mongoose 连接的 **open** 事件添加一个监听器，以便我们在连接到数据库后显示一条日志消息：
- en: '[PRE10]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, use the **mongoose.connect()** function to connect to our MongoDB database
    and return the **connection** object:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 **mongoose.connect()** 函数连接到我们的 MongoDB 数据库并返回 **connection** 对象：
- en: '[PRE11]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a new **src/example.js** file and import and run the **initDatabase**
    function there:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **src/example.js** 文件中创建一个新的 **src/example.js** 文件，并在其中导入并运行 **initDatabase**
    函数：
- en: '[PRE12]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the **src/example.js** file using Node.js to see Mongoose successfully
    connecting to our database:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Node.js 运行 **src/example.js** 文件以查看 Mongoose 成功连接到我们的数据库：
- en: '[PRE13]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As always, you can stop the server by pressing *Ctrl* + *C* in the Terminal.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 和往常一样，您可以通过在终端中按 *Ctrl* + *C* 来停止服务器。
- en: We can see our log message being printed to the Terminal, so we know that Mongoose
    was able to successfully connect to our database! If there is an error, for example,
    because Docker (or the container) is not running, it will hang for a while and
    then throw an error about the connection being refused (`ECONNREFUSED`). In that
    case, make sure the Docker MongoDB container is running properly and can be connected
    to.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到日志消息被打印到终端，因此我们知道 Mongoose 成功连接到了我们的数据库！如果有错误，例如，因为 Docker（或容器）没有运行，它将挂起一段时间，然后抛出一个关于连接被拒绝的错误
    (`ECONNREFUSED`)。在这种情况下，请确保 Docker MongoDB 容器正在正常运行并且可以被连接到。
- en: Defining a model for blog posts
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义博客文章的模型
- en: 'After initializing the database, the first thing we should do is define the
    data structure for blog posts. Blog posts in our system should have a title, an
    author, contents, and some tags associated with the post. Follow these steps to
    define the data structure for blog posts:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化数据库后，我们应该做的第一件事是定义博客文章的数据结构。在我们的系统中，博客文章应该有一个标题、一个作者、内容以及与文章关联的一些标签。按照以下步骤定义博客文章的数据结构：
- en: Create a new **src/db/models/** folder.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **src/db/models/** 文件夹。
- en: 'Inside that folder, create a new **src/db/models/post.js** file, import the
    **mongoose** and the **Schema** classes:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那个文件夹内，创建一个新的 **src/db/models/post.js** 文件，导入 **mongoose** 和 **Schema** 类：
- en: '[PRE14]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Define a new schema for posts:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为文章定义一个新的模式：
- en: '[PRE15]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now specify all properties of a blog post and the corresponding types. We have
    a required **title**, an **author**, and **contents**, which are all strings:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在指定博客文章的所有属性及其对应类型。我们有一个必需的 **title**、一个 **author** 和 **contents**，它们都是字符串：
- en: '[PRE16]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Lastly, we have **tags**, which are a string array:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有 **tags**，它是一个字符串数组：
- en: '[PRE17]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now that we have defined the schema, we can create a Mongoose model from it
    by using the **mongoose.model()** function:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了模式，我们可以通过使用 **mongoose.model()** 函数从它创建一个 Mongoose 模型：
- en: '[PRE18]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The first argument to **mongoose.model()** specifies the name of the collection.
    In our case, the collection will be called **posts** because we specified **post**
    as the name. In Mongoose models, we need to specify the name of the document in
    singular form.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**mongoose.model()** 的第一个参数指定了集合的名称。在我们的例子中，集合将被命名为 **posts**，因为我们指定了 **post**
    作为名称。在 Mongoose 模型中，我们需要指定文档的单数形式名称。'
- en: Now that we have defined the data structure and model for blog posts, we can
    start using it to create and query posts.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了博客文章的数据结构和模型，我们可以开始使用它来创建和查询文章。
- en: Using the blog post model
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用博客文章模型
- en: 'After creating our model, let’s try using it! For now, we are simply going
    to access it in the `src/example.js` file because we have not defined any service
    functions or routes yet:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 创建我们的模型后，让我们尝试使用它！目前，我们只是在 `src/example.js` 文件中访问它，因为我们还没有定义任何服务函数或路由：
- en: 'Import the **Post** model in the **src/example.js** file:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **src/example.js** 文件中导入 **Post** 模型：
- en: '[PRE19]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The **initDatabase()** function we defined earlier is an **async** function,
    so we need to **await** it; otherwise, we would be attempting to access the database
    before we are connected to it:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们之前定义的 **initDatabase()** 函数是一个 **async** 函数，所以我们需要 **await** 它；否则，我们将在连接到数据库之前尝试访问数据库：
- en: '[PRE20]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a new blog post by calling **new Post()**, defining some example data:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 **new Post()** 并定义一些示例数据来创建一个新的博客文章：
- en: '[PRE21]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Call **.save()** on the blog post to save it to the database:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在博客文章上调用 **.save()** 以将其保存到数据库：
- en: '[PRE22]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we can use the **.find()** function to list all posts, and log the result:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 **.find()** 函数列出所有文章，并记录结果：
- en: '[PRE23]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run the example script to see our post being inserted and listed:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例脚本以查看我们的文章被插入和列出：
- en: '[PRE24]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You will get the following result after running the preceding script:'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的脚本后，您将得到以下结果：
- en: '![Figure 3.2 – Our first document inserted via Mongoose!](img/B19385_03_2.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 我们通过 Mongoose 插入的第一个文档！](img/B19385_03_2.jpg)'
- en: Figure 3.2 – Our first document inserted via Mongoose!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 我们通过 Mongoose 插入的第一个文档！
- en: As you can see, using Mongoose is very similar to using MongoDB directly. However,
    it offers us some wrappers around models for convenience, making it easier to
    deal with documents.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用 Mongoose 与直接使用 MongoDB 非常相似。然而，它为我们提供了模型的一些包装器，以便于使用，使得处理文档更加容易。
- en: Defining creation and last update dates in the blog post
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在博客文章中定义创建和最后更新日期
- en: 'You may have noticed that we have not added any dates to our blog post. So,
    we do not know when a blog post is created or when it was last updated. Mongoose
    makes implementing such functionality simple, let’s try it out now:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们没有为博客文章添加任何日期。因此，我们不知道博客文章是在何时创建的，或者最后一次更新是在何时。Mongoose 使得实现此类功能变得简单，现在让我们试试看：
- en: 'Edit the **src/db/models/post.js** file and add a second argument to the **new
    Schema()** constructor. The second argument specifies options for the schema.
    Here, we set the **timestamps:** **true** setting:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/db/models/post.js** 文件，并将第二个参数添加到 **new Schema()** 构造函数中。第二个参数指定了模式的选项。在这里，我们设置了
    **timestamps:** **true** 设置：
- en: '[PRE25]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now all we need to do is create a new blog post by running the example script,
    and we will see that the last post inserted now has **createdAt** and **updatedAt**
    timestamps:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要做的就是通过运行示例脚本创建一个新的博客文章，我们会看到最后插入的文章现在有 **createdAt** 和 **updatedAt** 时间戳：
- en: '[PRE26]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To see if the **updatedAt** timestamp works, let’s try updating the created
    blog post by using the **findByIdAndUpdate** method. Save the result of **await
    post.save()** in a **createdPost** constant, then add the following code close
    to the end of the **src/example.js** file, before the **Post.find()** call:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了查看 **updatedAt** 时间戳是否工作，让我们尝试通过使用 **findByIdAndUpdate** 方法更新创建的博客文章。将 **await
    post.save()** 的结果保存在 **createdPost** 常量中，然后在 **src/example.js** 文件的末尾添加以下代码，在
    **Post.find()** 调用之前：
- en: '[PRE27]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run the server again to see the blog posts being updated:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行服务器以查看博客文章的更新：
- en: '[PRE28]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You will get three posts, and the last one of them now looks as follows:'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将得到三篇文章，其中最后一篇现在看起来如下：
- en: '![Figure 3.3 – Our updated document with the automatically updated timestamps](img/B19385_03_3.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 我们自动更新时间戳的更新文档](img/B19385_03_3.jpg)'
- en: Figure 3.3 – Our updated document with the automatically updated timestamps
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 我们自动更新时间戳的更新文档
- en: As we can see, using Mongoose makes dealing with MongoDB documents much more
    convenient! Now that we have defined our database model, let’s start developing
    (and writing tests for) service functions!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，使用 Mongoose 使得处理 MongoDB 文档变得更加方便！现在我们已经定义了数据库模型，让我们开始开发（并为它们编写测试）服务函数！
- en: Developing and testing service functions
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发和测试服务函数
- en: Up until now, we have always been testing code by putting it in the `src/example.js`
    file. Now, we are going to write some service functions and learn how to write
    actual tests for them by using Jest.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直通过将代码放入 `src/example.js` 文件中来测试代码。现在，我们将编写一些服务函数，并通过使用 Jest 学习如何为它们编写实际的测试。
- en: Setting up the test environment
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置测试环境
- en: 'First, we are going to set up our test environment by following these steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将按照以下步骤设置我们的测试环境：
- en: 'Install **jest** and **mongodb-memory-server** as dev dependencies:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **jest** 和 **mongodb-memory-server** 作为开发依赖项安装：
- en: '[PRE29]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Create a **src/test/** folder to put the setup for our tests in.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 **src/test/** 文件夹，用于放置我们的测试设置。
- en: 'In this folder, create a **src/test/globalSetup.js** file, where we will import
    **MongoMemoryServer** from the previously installed library:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件夹中，创建一个 **src/test/globalSetup.js** 文件，其中我们将从之前安装的库中导入 **MongoMemoryServer**：
- en: '[PRE30]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now define a **globalSetup** function, which creates a memory server for MongoDB:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在定义一个 **globalSetup** 函数，为 MongoDB 创建一个内存服务器：
- en: '[PRE31]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When creating the **MongoMemoryServer**, set the binary version to **6.0.4**,
    which is the same version that we installed for our Docker container:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建 **MongoMemoryServer** 时，将二进制版本设置为 **6.0.4**，这是我们为我们的 Docker 容器安装的相同版本：
- en: '[PRE32]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will store the MongoDB instance as a global variable to be able to access
    it later in the **globalTeardown** function:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 MongoDB 实例存储为全局变量，以便在之后的 **globalTeardown** 函数中访问它：
- en: '[PRE33]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We will also store the URL to connect to our test instance in the **DATABASE_URL**
    environment variable:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将把连接到我们的测试实例的 URL 存储在 **DATABASE_URL** 环境变量中：
- en: '[PRE34]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Edit **src/db/init.js** and adjust the **DATABASE_URL** to come from the environment
    variable so that our tests will be using the correct database:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/db/init.js** 并调整 **DATABASE_URL** 以从环境变量中获取，以便我们的测试将使用正确的数据库：
- en: '[PRE35]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Additionally, create a **src/test/globalTeardown.js** file to stop the MongoDB
    instance when our tests are finished and add the following code inside it:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，创建一个 **src/test/globalTeardown.js** 文件，在测试完成后停止 MongoDB 实例，并在其中添加以下代码：
- en: '[PRE36]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, create a **src/test/setupFileAfterEnv.js** file. Here, we will define
    a **beforeAll** function to initialize our database connection in Mongoose before
    all tests run and an **afterAll** function to disconnect from the database after
    all tests finish running:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个 **src/test/setupFileAfterEnv.js** 文件。在这里，我们将定义一个 **beforeAll** 函数，在所有测试运行之前初始化我们的数据库连接，以及一个
    **afterAll** 函数，在所有测试运行完成后从数据库断开连接：
- en: '[PRE37]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, create a new **jest.config.json** file in the root of our project where
    we will define the config for our tests. In the **jest.config.json** file, we
    first set the test environment to **node**:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在项目的根目录中创建一个新的 **jest.config.json** 文件，我们将在这里定义测试的配置。在 **jest.config.json**
    文件中，我们首先将测试环境设置为 **node**：
- en: '[PRE38]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, tell Jest to use the **globalSetup**, **globalTeardown**, and **setupFileAfterEnv**
    files we created earlier:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，告诉 Jest 使用我们之前创建的 **globalSetup**、**globalTeardown** 和 **setupFileAfterEnv**
    文件：
- en: '[PRE39]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this case, **<rootDir>** is a special string that automatically gets resolved
    to the root directory by Jest. You do not need to manually fill in a root directory
    here.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，**<rootDir>** 是一个特殊的字符串，Jest 会自动将其解析为根目录。你在这里不需要手动填写根目录。
- en: 'Finally, edit the **package.json** file and add a **test** script, which will
    run Jest:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，编辑**package.json**文件并添加一个**test**脚本，该脚本将运行Jest：
- en: '[PRE40]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing, the JavaScript ecosystem is still in the process of
    moving to the **ECMAScript module** (**ESM**) standard. In this book, we already
    use this new standard. However, Jest does not support it yet by default, so we
    need to pass the **--experimental-vm-modules** option when running Jest.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本书时，JavaScript生态系统仍在向**ECMAScript模块**（**ESM**）标准过渡。在这本书中，我们已经使用了这个新标准。然而，Jest默认不支持它，因此我们需要在运行Jest时传递**--experimental-vm-modules**选项。
- en: 'If we attempt running this script now, we will see that there are no tests
    found, but we can still see that Jest is set up and working properly:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在尝试运行此脚本，我们会看到没有找到测试，但我们仍然可以看到Jest已设置并正常工作：
- en: '[PRE41]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![Figure 3.4 – Jest is set up successfully, but we have not defined any tests
    yet](img/B19385_03_4.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – Jest已成功设置，但我们还没有定义任何测试](img/B19385_03_4.jpg)'
- en: Figure 3.4 – Jest is set up successfully, but we have not defined any tests
    yet
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – Jest已成功设置，但我们还没有定义任何测试
- en: Now that our test environment is set up, we can start writing our service functions
    and unit tests. It is always a good idea to write unit tests right after writing
    service functions, as it means we will be able to debug them right away while
    still having their intended behavior fresh in our minds.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了测试环境，我们可以开始编写我们的服务函数和单元测试。在编写服务函数后立即编写单元测试总是一个好主意，这意味着我们可以在仍然记得它们预期行为的情况下立即调试它们。
- en: 'Writing our first service function: createPost'
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写我们的第一个服务函数：createPost
- en: 'For our first service function, we are going to make a function to create a
    new post. We can then write tests for it by verifying that the create function
    creates a new post with the specified properties. Follow these steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个服务函数，我们将创建一个用于创建新帖子的函数。然后我们可以通过验证创建函数是否创建了一个具有指定属性的新帖子来编写针对它的测试。按照以下步骤进行：
- en: Create a new **src/services/posts.js** file.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**src/services/posts.js**文件。
- en: 'In the **src/services/posts.js** file, first import the **Post** model:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**src/services/posts.js**文件中，首先导入**Post**模型：
- en: '[PRE42]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Define a new **createPost** function, which takes an object with **title**,
    **author**, **contents**, and **tags** as arguments and creates and returns a
    new post:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的**createPost**函数，它接受一个包含**标题**、**作者**、**内容**和**标签**的对象作为参数，并创建并返回一个新的帖子：
- en: '[PRE43]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We specifically listed all properties that we want the user to be able to provide
    here instead of simply passing the whole object to the `new Post()` constructor.
    While we need to type more code this way, it allows us to have control over which
    properties a user should be able to set. For example, if we later add permissions
    to the database models, we may be accidentally allowing users to set those permissions
    here, if we forget to exclude those properties. For those security reasons, it
    is always good practice to have a list of allowed properties instead of simply
    passing down the whole object.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里特别列出了我们希望用户能够提供的所有属性，而不是简单地传递整个对象给`new Post()`构造函数。虽然这种方式需要我们编写更多的代码，但它允许我们控制用户应该能够设置哪些属性。例如，如果我们后来向数据库模型添加权限，我们可能会不小心允许用户在这里设置那些权限，如果我们忘记排除那些属性。出于这些安全原因，始终有一个允许属性的列表而不是简单地传递整个对象是一个好的做法。
- en: After writing our first service function, let’s continue by writing test cases
    for it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写我们的第一个服务函数之后，让我们继续编写针对它的测试用例。
- en: Defining test cases for the createPost service function
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义createPost服务函数的测试用例
- en: 'To test if the `createPost` function works as expected, we are going to define
    unit test cases for it using Jest:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试`createPost`函数是否按预期工作，我们将使用Jest定义针对它的单元测试用例：
- en: Create a new **src/__tests__/** folder, which will contain all test definitions.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**src/__tests__/**文件夹，它将包含所有测试定义。
- en: Note
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Alternatively, test files can also be co-located with the related files that
    they are testing. However, in this book, we use the **__tests__** directory to
    make it easier to distinguish tests from other files.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，测试文件也可以与它们所测试的相关文件位于同一位置。然而，在这本书中，我们使用**__tests__**目录来更容易地区分测试和其他文件。
- en: 'Create a new **src/__tests__/posts.test.js** file for our tests related to
    posts. In this file, start by importing **mongoose** and the **describe**, **expect**,
    and **test** functions from **@jest/globals**:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为与帖子相关的测试创建一个新的**src/__tests__/posts.test.js**文件。在这个文件中，首先从**@jest/globals**导入**mongoose**和**describe**、**expect**、**test**函数：
- en: '[PRE44]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Also import the **createPost** function from our services and the **Post**
    model:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还从我们的服务中导入**createPost**函数和**Post**模型：
- en: '[PRE45]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, use the **describe()** function to define a new test. This function describes
    a group of tests. We can call our group **creating posts**:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用**describe()**函数定义一个新的测试。这个函数描述了一组测试。我们可以将我们的组命名为**创建帖子**：
- en: '[PRE46]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Inside the group, we will define a test by using the **test()** function. We
    can pass an **async** function here to be able to use async/await syntax. We call
    the first test **creating posts with all parameters** **should succeed**:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个组内，我们将使用**test()**函数定义一个测试。我们可以传递一个**async**函数来使用async/await语法。我们称第一个测试为**创建包含所有参数的帖子****应成功**：
- en: '[PRE47]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Inside this test, we will use the **createPost** function to create a new post
    with some parameters:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个测试中，我们将使用**createPost**函数使用一些参数创建一个新的帖子：
- en: '[PRE48]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, verify that it returns a post with an ID by using the **expect()** function
    from Jest and the **toBeInstanceOf** matcher to verify that it is an **ObjectId**:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用Jest的**expect()**函数和**toBeInstanceOf**匹配器来验证它返回的是一个**ObjectId**，以验证它返回了一个帖子：
- en: '[PRE49]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now use Mongoose directly to find the post with the given ID:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在直接使用Mongoose来查找具有给定ID的帖子：
- en: '[PRE50]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We **expect()** the **foundPost** to equal an object containing at least the
    properties of the original post object we defined. Additionally, we expect the
    created post to have **createdAt** and **updatedAt** timestamps:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们**expect()****foundPost**等于一个包含至少我们定义的原帖子对象的属性的对象。此外，我们期望创建的帖子有**createdAt**和**updatedAt**时间戳：
- en: '[PRE51]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Additionally, define a second test, called **creating posts without title should
    fail**. As we defined the **title** to be required, it should not be possible
    to create a post without one:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，定义第二个测试，称为**创建没有标题的帖子应失败**。因为我们定义了**标题**为必需的，所以不可能创建没有标题的帖子：
- en: '[PRE52]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Use a **try**/**catch** construct to catch the error and **expect()** the error
    to be a Mongoose **ValidationError**, which tells us that the title is required:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**try**/**catch**结构来捕获错误，并**expect()**错误是一个Mongoose **ValidationError**，这告诉我们标题是必需的：
- en: '[PRE53]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, make a test called **creating posts with minimal parameters should
    succeed** and only enter the **title**:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个名为**创建具有最小参数的帖子应成功**的测试，并且只输入**标题**：
- en: '[PRE54]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now that we have defined our tests, run the script we defined earlier:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的测试，运行我们之前定义的脚本：
- en: '[PRE55]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As we can see, using unit tests we can do isolated tests on our service functions
    without having to define and manually access routes or write some manual test
    setups. These tests also have the added advantage that when we change code later,
    we can ensure that the previously defined behavior did not change by re-running
    the tests.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，使用单元测试，我们可以在不定义和手动访问路由或编写一些手动测试设置的情况下对服务函数进行隔离测试。这些测试还有额外的优势，即当我们稍后更改代码时，我们可以通过重新运行测试来确保之前定义的行为没有改变。
- en: Defining a function to list posts
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个函数来列出帖子
- en: 'After defining a function to create posts, we are now going to define an internal
    `listPosts` function, which allows us to query posts and define a sort order.
    Then, we are going to use this function to define `listAllPosts`, `listPostsByAuthor`,
    and `listPostsByTag` functions:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了创建帖子的函数之后，我们现在将定义一个内部的`listPosts`函数，它允许我们查询帖子并定义排序顺序。然后，我们将使用这个函数来定义`listAllPosts`、`listPostsByAuthor`和`listPostsByTag`函数：
- en: 'Edit the `query` and an `options` argument (with `sortBy` and `sortOrder` properties).
    With `sortBy`, we can define which field we want to sort by, and the `sortOrder`
    argument allows us to specify whether posts should be sorted in ascending or descending
    order. By default, we list all posts (empty object as query) and show the newest
    posts first (sorted by `createdAt`, in `descending` order):'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`query`和`options`参数（包含`sortBy`和`sortOrder`属性）。通过`sortBy`，我们可以定义我们想要排序的字段，而`sortOrder`参数允许我们指定帖子应该按升序还是降序排序。默认情况下，我们列出所有帖子（空对象作为查询），并首先显示最新的帖子（按`createdAt`降序排序）：
- en: '[PRE56]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can use the **.find()** method from our Mongoose model to list all posts,
    passing an argument to sort them:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用Mongoose模型的**.find()**方法来列出所有帖子，并通过传递参数来排序：
- en: '[PRE57]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now we can define a function to list all posts, which simply passes an empty
    object as query:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以定义一个函数来列出所有帖子，它只需简单地将一个空对象作为查询传递：
- en: '[PRE58]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Similarly, we can create a function to list all posts by a certain author by
    passing **author** to the query object:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，我们可以创建一个函数来通过将**author**传递到查询对象中来列出特定作者的帖子：
- en: '[PRE59]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Lastly, define a function to list posts by tag:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，定义一个函数来按标签列出帖子：
- en: '[PRE60]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In MongoDB, we can simply match strings in an array by matching the string
    as if it was a single value, so all we need to do is add a query for `tags: ''nodejs''`.
    MongoDB will then return all documents that have a `''nodejs''` string in their
    `tags` array.'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '在 MongoDB 中，我们可以简单地通过将字符串作为单个值匹配来匹配数组中的字符串，所以我们只需要添加一个 `tags: ''nodejs''` 的查询。MongoDB
    将返回所有在 `tags` 数组中包含 `''nodejs''` 字符串的文档。'
- en: Note
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The **{ [variable]: … }** operator resolves the string stored in the **variable**
    to a key name for the created object. So, if our variable contains **''createdAt''**,
    the resulting object will be **{ createdAt: … }**.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**{ [变量]: … }** 操作符将存储在 **变量** 中的字符串解析为创建的对象的关键名称。因此，如果我们的变量包含 **''createdAt''**，则生成的对象将是
    **{ createdAt: … }**。'
- en: After defining the list post function, let’s also write test cases for it.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义列表帖子函数之后，我们也为它编写测试用例。
- en: Defining test cases for list posts
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义列表帖子的测试用例
- en: 'Defining test cases for list posts is similar to create posts. However, we
    now need to create an initial state where we already have some posts in the database
    to be able to test the list functions. We can do this by using the `beforeEach()`
    function, which executes some code before each test case is executed. We can use
    the `beforeEach()` function for a whole test file or only run it for each test
    inside a `describe()` group. In our case, we are going to define it for the whole
    file, as the sample posts will come in handy when we test the delete post function
    later:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 定义列表帖子的测试用例与创建帖子类似。然而，我们现在需要创建一个初始状态，其中数据库中已经有一些帖子，以便能够测试列表函数。我们可以通过使用 `beforeEach()`
    函数来实现，该函数在每个测试用例执行之前执行一些代码。我们可以为整个测试文件使用 `beforeEach()` 函数，或者只为 `describe()` 组内的每个测试运行它。在我们的情况下，我们将为整个文件定义它，因为样本帖子在稍后测试删除帖子函数时将很有用：
- en: 'Edit the **src/__tests__/posts.js** file, adjust the **import** statement to
    import the **beforeEach** function from **@jest/globals** and import the various
    functions to list posts from our services:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/__tests__/posts.js** 文件，调整 **import** 语句以从 **@jest/globals** 导入 **beforeEach**
    函数，并从我们的服务中导入列出帖子的各种函数：
- en: '[PRE61]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'At the end of the file, define an array of sample posts:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件末尾，定义一个样本帖子数组：
- en: '[PRE62]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, define an empty array, which will be populated with the created posts.
    Then, define a **beforeEach** function, which first clears all posts from the
    database and clears the array of created sample posts and then creates the sample
    posts in the database again for each of the posts defined in the array earlier.
    This ensures that we have a consistent state of the database before each test
    case runs and that we have an array to compare against when testing the list post
    functions:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义一个空数组，它将被创建的帖子填充。然后，定义一个 **beforeEach** 函数，它首先从数据库中清除所有帖子，并清除创建的样本帖子数组，然后再次在数据库中创建之前定义在数组中的每个帖子。这确保了在每次测试用例运行之前数据库处于一致状态，并且在测试列表帖子函数时有一个数组进行比较：
- en: '[PRE63]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: To ensure that our unit tests are modular and independent from each other, we
    insert posts into the database directly by using Mongoose functions (instead of
    the `createPost` function).
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了确保我们的单元测试是模块化和相互独立的，我们直接使用 Mongoose 函数将帖子插入数据库（而不是使用 `createPost` 函数）。
- en: 'Now that we have some sample posts ready, let’s write our first test case,
    which should simply list all posts. We will define a new test group for **listing
    posts** and a test to verify that all sample posts are listed by the **listAllPosts()**
    function:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一些样本帖子准备好了，让我们编写我们的第一个测试用例，它应该简单地列出所有帖子。我们将定义一个新的测试组用于 **列出帖子**，并定义一个测试用例来验证所有样本帖子是否通过
    **listAllPosts()** 函数列出：
- en: '[PRE64]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, make a test that verifies that the default sort order shows newest posts
    first. We sort the **createdSamplePosts** array manually by **createdAt** (descending)
    and then compare the sorted dates to those returned from the **listAllPosts()**
    function:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个测试用例来验证默认排序顺序是否显示最新的帖子。我们手动按 **createdAt**（降序）对 **createdSamplePosts**
    数组进行排序，然后比较排序后的日期与 **listAllPosts()** 函数返回的日期：
- en: '[PRE65]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The **.map()** function applies a function to each element of an array and returns
    the result. In our case, we select the **createdAt** property from all elements
    of the array. We cannot directly compare the arrays with each other because Mongoose
    returns documents with a lot of additional information in hidden metadata, which
    Jest will attempt to compare.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**.map()** 函数将一个函数应用于数组的每个元素，并返回结果。在我们的情况下，我们从数组的所有元素中选择 **createdAt** 属性。我们不能直接比较数组，因为
    Mongoose 返回的文档包含大量隐藏的元数据，Jest 将尝试比较这些元数据。'
- en: 'Additionally, define a test case where the **sortBy** value is changed to **updatedAt**,
    and the **sortOrder** value is changed to **ascending** (showing oldest updated
    posts first):'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，定义一个测试用例，其中将 **sortBy** 值更改为 **updatedAt**，并将 **sortOrder** 值更改为 **ascending**（首先显示最早更新的帖子）：
- en: '[PRE66]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then, add a test to ensure that listing posts by author works:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加一个测试用例来确保按作者列出帖子是否正常工作：
- en: '[PRE67]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We are controlling the test environment by creating a specific set of sample
    posts before each test case runs. We can make use of this controlled environment
    to simplify our tests. As we already know that there are only three posts with
    that author, we can simply check if the function returned exactly three posts.
    Doing so keeps our tests simple, and they are still safe because we control the
    environment completely.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在每个测试用例运行之前创建一组特定的样本帖子来控制测试环境。我们可以利用这个受控环境来简化我们的测试。因为我们已经知道只有三位作者的帖子，所以我们可以简单地检查函数是否返回了恰好三个帖子。这样做使我们的测试保持简单，并且由于我们完全控制了环境，它们仍然是安全的。
- en: 'Finally, add a test to verify that listing posts by tag works:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加一个测试用例来验证按标签列出帖子是否正常工作：
- en: '[PRE68]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Run the tests again and watch them all pass:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试，并观察它们全部通过：
- en: '[PRE69]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '![Figure 3.5 – All our tests passing successfully!](img/B19385_03_5.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 所有测试都成功通过！](img/B19385_03_5.jpg)'
- en: Figure 3.5 – All our tests passing successfully!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 所有测试都成功通过！
- en: As we can see, for some tests, we need to prepare an initial state. In our case,
    we only had to create some posts, but this initial state may become more sophisticated.
    For example, on a more advanced blogging platform, it may be necessary to create
    a user account first, then create a blog on the platform, and then create blog
    posts for that blog. In that case, we could create test utility functions, such
    as `createTestUser`, `createTestBlog`, `createTestPost` and import them in our
    tests. We can then use these functions in `beforeEach()` across multiple test
    files instead of manually doing it every single time. Depending on your application
    structure, different test utility functions may be needed, so feel free to define
    them as you see fit.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，对于某些测试，我们需要准备一个初始状态。在我们的例子中，我们只需创建一些帖子，但这个初始状态可能变得更加复杂。例如，在一个更高级的博客平台上，可能首先需要创建一个用户账户，然后在平台上创建一个博客，然后为该博客创建博客帖子。在这种情况下，我们可以创建测试实用函数，如
    `createTestUser`、`createTestBlog`、`createTestPost` 并在测试中导入它们。然后，我们可以在多个测试文件中的
    `beforeEach()` 中使用这些函数，而不是每次都手动执行。根据你的应用程序结构，可能需要不同的测试实用函数，所以请随意定义它们，以适合你的需求。
- en: After defining the test cases for the list posts function, let’s continue by
    defining the get single post, update post, and delete post functions.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了列表帖子功能的测试用例之后，让我们继续定义获取单个帖子、更新帖子以及删除帖子功能。
- en: Defining the get single post, update and delete post functions
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义获取单个帖子、更新和删除帖子功能
- en: 'The get single post, update and delete post functions can be defined very similarly
    to the list posts function. Let’s do that quickly now:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 获取单个帖子、更新和删除帖子功能可以非常类似于列表帖子功能来定义。让我们现在快速完成它：
- en: 'Edit the **src/services/posts.js** file and define a **getPostById** function
    as follows:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/services/posts.js** 文件并定义一个 **getPostById** 函数，如下所示：
- en: '[PRE70]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: It may seem a bit trivial to define a service function that just calls `Post.findById`,
    but it is good practice to define it anyway. Later, we may want to add some additional
    restrictions, such as access control. Having the service function allows us to
    change it only in one place and we do not have to worry about forgetting to add
    it somewhere. Another benefit is that if we, for example, want to change the database
    provider later, the developer only needs to worry about getting the service functions
    working again, and they can be verified with the test cases.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义一个仅调用 `Post.findById` 的服务函数可能看起来有点微不足道，但无论如何定义它都是一种良好的实践。稍后，我们可能想要添加一些额外的限制，例如访问控制。拥有服务函数允许我们只在一个地方更改它，我们不必担心忘记在某处添加它。另一个好处是，如果我们，例如，稍后想要更改数据库提供者，开发者只需担心让服务函数再次工作，并且可以使用测试用例进行验证。
- en: 'In the same file, define the **updatePost** function. It will take an ID of
    an existing post, and an object of parameters to be updated. We are going to use
    the **findOneAndUpdate** function from Mongoose, together with the **$set** operator,
    to change the specified parameters. As a third argument, we provide an options
    object with **new: true** so that the function returns the modified object instead
    of the original:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在同一文件中，定义**updatePost**函数。它将接受现有帖子的ID以及要更新的参数对象。我们将使用Mongoose的**findOneAndUpdate**函数以及**$set**运算符来更改指定的参数。作为第三个参数，我们提供一个包含**new:
    true**的选项对象，以便函数返回修改后的对象而不是原始对象：'
- en: '[PRE71]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In the same file, also define a **deletePost** function, which simply takes
    the ID of an existing post and deletes it from the database:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，还定义一个**deletePost**函数，该函数简单地接受现有帖子的ID并将其从数据库中删除：
- en: '[PRE72]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Tip
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Depending on your application, you may want to set a **deletedOn** timestamp
    instead of deleting it right away. Then, set up a function that gets all documents
    that have been deleted for more than 30 days and delete them. Of course, this
    means that we need to always filter out already deleted posts in the **listPosts**
    function and that we need to write test cases for this behavior!
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的应用程序，您可能希望设置一个**deletedOn**时间戳而不是立即删除。然后，设置一个函数来获取所有已删除超过30天的文档并将它们删除。当然，这意味着我们需要在**listPosts**函数中始终过滤掉已删除的帖子，并且我们需要为此行为编写测试用例！
- en: 'Edit the **src/__tests__/posts.js** file and import the **getPostById** function:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/__tests__/posts.js**文件并导入**getPostById**函数：
- en: '[PRE73]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Add tests for getting a post by ID and failing to get a post because the ID
    did not exist in the database:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加通过ID获取帖子以及因为数据库中不存在该ID而无法获取帖子的测试：
- en: '[PRE74]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In the first test, we use`.toObject()` to convert the Mongoose object with all
    its internal properties and metadata to a **plain old JavaScript object** (**POJO**)
    so that we can compare it to the sample post object by comparing all properties.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第一个测试中，我们使用`.toObject()`将具有所有内部属性和元数据的Mongoose对象转换为**纯旧JavaScript对象**（**POJO**），以便我们可以通过比较所有属性来将其与样本帖子对象进行比较。
- en: 'Next, import the **updatePost** function:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，导入**updatePost**函数：
- en: '[PRE75]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Then, add tests for updating a post successfully. We add one test to verify
    that the specified property was changed and another test to verify that it does
    not interfere with other properties:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加测试以成功更新帖子。我们添加一个测试来验证指定的属性是否已更改，并添加另一个测试来验证它不会干扰其他属性：
- en: '[PRE76]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Additionally, add a test to ensure the **updatedAt** timestamp was updated.
    To do so, first convert the **Date** objects to numbers by using **.getTime()**,
    and then we can compare them by using the **expect(…).toBeGreaterThan(…)** matcher:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，添加一个测试以确保**updatedAt**时间戳已更新。为此，首先使用**.getTime()**将**Date**对象转换为数字，然后我们可以使用**expect(…).toBeGreaterThan(…)**匹配器进行比较：
- en: '[PRE77]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Also add a failing test to see if the **updatePost** function returns **null**
    when no post with a matching ID was found:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还添加一个失败的测试来查看当找不到匹配ID的帖子时，**updatePost**函数是否返回**null**：
- en: '[PRE78]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Lastly, import the **deletePost** function:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，导入**deletePost**函数：
- en: '[PRE79]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Then, add tests for successful and unsuccessful deletes by checking if the
    post was deleted and verifying the returned **deletedCount**:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过检查帖子是否被删除并验证返回的**deletedCount**来添加成功和失败的删除测试：
- en: '[PRE80]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Finally, run all tests again; they should all pass:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，再次运行所有测试；它们都应该通过：
- en: '[PRE81]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Writing tests for service functions may be tedious, but it will save us a lot
    of time in the long run. Adding additional functionality later, such as access
    control, may change the basic behavior of the service functions. By having the
    unit tests, we can ensure that we do not break existing behavior when adding new
    functionality.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为服务函数编写测试可能很繁琐，但长远来看可以节省我们大量时间。添加额外的功能，如访问控制，可能会改变服务函数的基本行为。通过单元测试，我们可以确保在添加新功能时不会破坏现有行为。
- en: Using the Jest VS Code extension
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Jest VS Code扩展
- en: 'Up until now, we have run our tests by using Jest via the Terminal. There is
    also a Jest extension for VS Code, which we can use to make running tests more
    visual. The extension is especially helpful for larger projects where we have
    many tests in multiple files. Additionally, the extension can automatically watch
    and re-run tests if we change the definitions. We can install the extension as
    follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过在终端中使用Jest来运行我们的测试。还有一个VS Code的Jest扩展，我们可以使用它来使运行测试更加直观。该扩展对于具有多个文件中许多测试的大型项目尤其有帮助。此外，扩展可以自动监视并重新运行测试，如果我们更改定义。我们可以按照以下方式安装扩展：
- en: Go to the **Extensions** tab in the VS Code sidebar.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 的侧边栏中转到 **扩展** 选项卡。
- en: Enter **Orta.vscode-jest** in the search box to find the Jest extension.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中输入 **Orta.vscode-jest** 来查找 Jest 扩展。
- en: Install the extension by pressing the **Install** button.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击 **安装** 按钮来安装扩展。
- en: 'Now go to the newly added test icon on the sidebar (it should be a chemistry
    flask icon):'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在转到侧边栏上新添加的测试图标（它应该是一个化学试剂瓶图标）：
- en: '![Figure 3.6 – The Testing tab in VS Code provided by the Jest extension](img/B19385_03_6.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 由 Jest 扩展提供的 VS Code 中的测试选项卡](img/B19385_03_6.jpg)'
- en: Figure 3.6 – The Testing tab in VS Code provided by the Jest extension
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 由 Jest 扩展提供的 VS Code 中的测试选项卡
- en: The Jest extension provides us an overview of all tests that we have defined.
    We can hover over them and press on the **Play** icon to re-run a specific test.
    By default, the Jest extension enables **auto-run-watch** (as can be seen in *Figure
    3**.6*). If **auto-run-watch** is enabled, the extension will re-run tests automatically
    when test definition files are saved. That’s pretty handy!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 扩展为我们提供了所有已定义测试的概览。我们可以悬停在它们上方并点击 **播放** 图标来重新运行特定的测试。默认情况下，Jest 扩展启用了
    **auto-run-watch**（如图 *3.6* 所示）。如果 **auto-run-watch** 被启用，当测试定义文件被保存时，扩展会自动重新运行测试。这非常方便！
- en: Now that we have defined and tested our service functions, we can start using
    them when defining routes, which we are going to do next!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义并测试了我们的服务函数，我们可以在定义路由时开始使用它们，这是我们接下来将要做的！
- en: Providing a REST API using Express
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Express 提供REST API
- en: Having our data and service layers set up, we have a good framework for being
    able to write our backend. However, we still need an interface that lets users
    access our backend. This interface will be a **representational state transfer**
    (**REST**) API. A REST API provides a way to access our server via HTTP requests,
    which we can make use of when we develop our frontend.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好我们的数据和服务层之后，我们就有了一个良好的框架来编写后端代码。然而，我们仍然需要一个让用户访问我们后端的接口。这个接口将是一个 **表征状态转移**
    （**REST**） API。REST API 提供了一种通过 HTTP 请求访问我们服务器的方式，这在我们开发前端时可以加以利用。
- en: '![Figure 3.7 – The interaction between client and server using HTTP requests](img/B19385_03_7.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 使用 HTTP 请求的客户端和服务器之间的交互](img/B19385_03_7.jpg)'
- en: Figure 3.7 – The interaction between client and server using HTTP requests
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 使用 HTTP 请求的客户端和服务器之间的交互
- en: 'As we can see, clients can send requests to our backend server, and the server
    will respond to them. There are five commonly used methods in a REST-based architecture:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，客户端可以向我们的后端服务器发送请求，服务器将对此做出响应。在基于 REST 的架构中，有五种常用的方法：
- en: '**GET**: This is used to read resources. Generally, it should not influence
    the database state and, given the same input, it should return the same output
    (unless the database state was changed through other requests). This behavior
    is called **idempotence**. In response to a successful GET request, a server usually
    returns the resource(s) with a 200 OK status code.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET**：这个方法用于读取资源。通常，它不应该影响数据库状态，并且给定相同的输入，它应该返回相同的输出（除非数据库状态通过其他请求被更改）。这种行为被称为
    **幂等性**。对于成功的 GET 请求，服务器通常会返回资源（资源）并带有 200 OK 状态码。'
- en: '**POST**: This is used to create new resources, from the information provided
    in the request body. In response to a successful POST request, a server usually
    either returns the newly created object with a 201 Created status code or returns
    an empty response (with 201 Created status code) with a URL in the **Location**
    header that points to the newly created resource.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**POST**：这个方法用于根据请求体中提供的信息创建新的资源。对于成功的 POST 请求，服务器通常会返回一个包含 201 Created 状态码的新创建的对象，或者返回一个空的响应（带有
    201 Created 状态码），并在 **Location** 头部包含一个指向新创建资源的 URL。'
- en: '**PUT**: This is used to update an existing resource with a given ID, replacing
    the resource completely with the new data provided in the request body. In some
    cases, it can also be used to create a new resource with a client-specified ID.
    In response to a successful PUT request, a server either returns the updated resource
    with a 200 OK status code, 204 No Content if it does not return the updated resource,
    or 201 Created if it created a new resource.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PUT**：这个方法用于使用请求体中提供的新数据完全替换具有给定 ID 的现有资源。在某些情况下，它也可以用于使用客户端指定的 ID 创建新的资源。对于成功的
    PUT 请求，服务器要么返回带有 200 OK 状态码的更新资源，要么返回 204 No Content（如果没有返回更新资源），或者返回 201 Created（如果创建了新的资源）。'
- en: '**PATCH**: This is used to modify an existing resource with a given ID, only
    updating the fields specified in the request body instead of replacing the whole
    resource. In response to a successful PATCH request, a server either returns the
    updated resource with 200 OK or 204 No Content if it does not return the updated
    resource.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PATCH**: 这用于修改具有给定ID的现有资源，仅更新请求体中指定的字段，而不是替换整个资源。对于成功的PATCH请求，服务器要么返回更新后的资源并返回200
    OK，要么如果未返回更新后的资源，则返回204 No Content。'
- en: '**DELETE**: This is used to delete a resource with a given ID. In response
    to a successful DELETE request, a server either returns the deleted resource with
    200 OK or 204 No Content if it does not return the deleted resource.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DELETE**: 这用于删除具有给定ID的资源。对于成功的DELETE请求，服务器要么返回已删除的资源并返回200 OK，要么如果未返回已删除的资源，则返回204
    No Content。'
- en: HTTP REST API routes are usually defined in a folder-like structure. It is always
    a good idea to prefix all routes with `/api/v1/` (`v1` being the version of the
    API definition, starting with `1`). If we want to change the API definition later,
    we can then easily run `/api/v1/` and `/api/v2/` in parallel for a while until
    everything is migrated.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP REST API路由通常在类似文件夹的结构中定义。始终以`/api/v1/`（`v1`是API定义的版本，从`1`开始）作为所有路由的前缀是一个好主意。如果我们想稍后更改API定义，我们就可以轻松地同时运行`/api/v1/`和`/api/v2/`一段时间，直到一切迁移完成。
- en: Defining our API routes
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义我们的API路由
- en: 'Now that we have learned how HTTP REST APIs work, let’s start by defining routes
    for our backend, covering all functionality we have already implemented in the
    service functions:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了HTTP REST API的工作原理，让我们首先定义后端的路由，涵盖我们在服务函数中已经实现的所有功能：
- en: '**GET /api/v1/posts**: Get a list of all posts'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET /api/v1/posts**: 获取所有帖子的列表'
- en: '**GET /api/v1/posts?sortBy=updatedAt&sortOrder=ascending**: Get a list of all
    posts sorted by **updatedAt** (ascending)'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET /api/v1/posts?sortBy=updatedAt&sortOrder=ascending**: 获取按**updatedAt**（升序）排序的所有帖子列表'
- en: Note
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Everything after the **?** symbol is called a query string and follows the format
    **key1=value1&key2=value2&…**. The query string can be used to provide additional
    optional parameters to a route.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**?**符号之后的内容称为查询字符串，其格式为**key1=value1&key2=value2&…**。查询字符串可以用于向路由提供额外的可选参数。'
- en: '**GET /api/v1/posts?author=daniel**: Get a list of posts by author “daniel”'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET /api/v1/posts?author=daniel**: 获取作者为“daniel”的帖子列表'
- en: '**GET /api/v1/posts?tag=react**: Get a list of posts with the tag **react**'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET /api/v1/posts?tag=react**: 获取带有标签**react**的帖子列表'
- en: '**GET /api/v1/posts/:id**: Get a single post by ID'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET /api/v1/posts/:id**: 通过ID获取单个帖子'
- en: '**POST /api/v1/posts**: Create a new post'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**POST /api/v1/posts**: 创建新的帖子'
- en: '**PATCH /api/v1/posts/:id**: Update an existing post by ID'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PATCH /api/v1/posts/:id**: 通过ID更新现有帖子'
- en: '**DELETE /api/v1/posts/:id**: Delete an existing post by ID'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DELETE /api/v1/posts/:id**: 通过ID删除现有帖子'
- en: As we can see, by putting together our already developed service functions and
    what we have learned about REST APIs, we can easily define routes for our backend.
    Now that we have defined our routes, let’s set up Express and our backend server
    to be able to expose those routes.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，通过将我们已开发的服务函数和我们关于REST API的知识结合起来，我们可以轻松地定义后端的路由。现在我们已经定义了路由，让我们设置Express和我们的后端服务器，以便能够公开这些路由。
- en: Note
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This is just one example of how a REST API can be designed. It is intended as
    an example to get you started with full-stack development. Later, on your own
    time, feel free to check out other resources, such as [https://standards.rest](https://standards.rest),
    to deepen your knowledge of REST API designs.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是REST API设计的一个示例。它旨在作为一个示例，帮助你开始全栈开发。稍后，在您自己的时间里，您可以自由地查看其他资源，例如[https://standards.rest](https://standards.rest)，以加深您对REST
    API设计的了解。
- en: Setting up Express
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Express
- en: Express is a web application framework for Node.js. It provides utility functions
    to easily define routes for REST APIs and serve HTTP servers. Express is also
    very extensible, and there are many plugins for it in the JavaScript ecosystem.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Express是Node.js的Web应用程序框架。它提供了实用函数，可以轻松定义REST API的路由并服务HTTP服务器。Express也非常可扩展，在JavaScript生态系统中有许多针对它的插件。
- en: Note
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While Express is the most well-known framework at the time of writing, there
    are also newer ones, such as Koa ([https://koajs.com](https://koajs.com)) or Fastify
    ([https://fastify.dev](https://fastify.dev)). Koa is designed by the team behind
    Express but aims to be smaller, more expressive, and more robust. Fastify focuses
    on efficiency and low overhead. Feel free to check these out on your own time
    to see if they fit your requirements better.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Express 在写作时是最知名的框架，但也有更新的框架，例如 Koa ([https://koajs.com](https://koajs.com))
    或 Fastify ([https://fastify.dev](https://fastify.dev))。Koa 是由 Express 背后的团队设计的，但旨在更小、更易于表达和更健壮。Fastify
    专注于效率和低开销。请自行检查这些，看看它们是否更适合您的需求。
- en: 'Before we can set up the routes, let’s take some time to set up our Express
    application and backend server by following these steps:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以设置路由之前，让我们花些时间按照以下步骤设置我们的 Express 应用程序和后端服务器：
- en: 'First, install the **express** dependency:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，安装 **express** 依赖项：
- en: '[PRE82]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Create a new **src/app.js** file. This file will contain everything needed
    to set up our Express app. In this file, first import **express**:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **src/app.js** 文件。此文件将包含设置我们的 Express 应用程序所需的所有内容。在此文件中，首先导入 **express**：
- en: '[PRE83]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Then create a new Express app, as follows:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建一个新的 Express 应用程序，如下所示：
- en: '[PRE84]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now we can define routes on the Express app. For example, to define a GET route,
    we can write the following code:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在 Express 应用程序上定义路由。例如，要定义一个 GET 路由，我们可以编写以下代码：
- en: '[PRE85]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We export the app to be able to use it in other files:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导出应用以便在其他文件中使用它：
- en: '[PRE86]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Next, we need to create a server and specify a port, similar to what we did
    before when creating an HTTP server. To do so, we create a new **src/index.js**
    file. In this file, we import the Express app:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个服务器并指定一个端口，这与我们之前创建 HTTP 服务器时所做的类似。为此，我们创建一个新的 **src/index.js**
    文件。在此文件中，我们导入 Express 应用程序：
- en: '[PRE87]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Then, we define a port, make the Express app listen to it, and log a message
    telling us where the server is running:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个端口，让 Express 应用程序监听它，并记录一条消息告诉我们服务器正在哪里运行：
- en: '[PRE88]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Edit **package.json** and add a **start** script to run our server:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **package.json** 并添加一个 **start** 脚本来运行我们的服务器：
- en: '[PRE89]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Run the backend server by executing the following command:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令运行后端服务器：
- en: '[PRE90]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now, navigate to **http://localhost:3000/** in your browser and you will see
    **Hello from Express!** Being printed, just like before with the plain http server:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在您的浏览器中导航到 **http://localhost:3000/**，您将看到 **Hello from Express!** 正在被打印出来，就像之前使用普通的
    http 服务器一样：
- en: '![Figure 3.8 – Accessing our first Express app from the browser!](img/B19385_03_8.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – 从浏览器访问我们的第一个 Express 应用程序！](img/B19385_03_8.jpg)'
- en: Figure 3.8 – Accessing our first Express app from the browser!
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 从浏览器访问我们的第一个 Express 应用程序！
- en: That’s all there is to setting up a simple Express app! We can now keep defining
    routes by using `app.get()` for GET routes, `app.post()` for POST routes, etc.
    However, before we start developing our routes, let’s take some time to improve
    our development environment. First, we should make `PORT` and `DATABASE_URL` configurable
    so that we can change them without having to change the code. To do so, we are
    going to use environment variables.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是设置简单 Express 应用程序的全部内容！我们现在可以通过使用 `app.get()` 为 GET 路由，`app.post()` 为 POST
    路由等来继续定义路由。然而，在我们开始开发路由之前，让我们花些时间来改善我们的开发环境。首先，我们应该使 `PORT` 和 `DATABASE_URL` 可配置，这样我们就可以在不更改代码的情况下更改它们。为此，我们将使用环境变量。
- en: Using dotenv for setting environment variables
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 dotenv 设置环境变量
- en: 'A good way to load environment variables is using `dotenv`, which loads environment
    variables from `.env` files into our `process.env`. This makes it easy to define
    environment variables for local development while keeping it possible to set them
    differently in, for example, a testing environment. Follow these steps to set
    up `dotenv`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dotenv` 是加载环境变量的好方法，它将环境变量从 `.env` 文件加载到我们的 `process.env` 中。这使得定义用于本地开发的环境变量变得容易，同时仍然可以在测试环境等地方设置不同的值。按照以下步骤设置
    `dotenv`：
- en: 'Install the **dotenv** dependency:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 **dotenv** 依赖项：
- en: '[PRE91]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Edit **src/index.js**, import **dotenv** there, and call **dotenv.config()**
    to initialize the environment variables. We should do this before we call any
    other code in our app:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/index.js**，在那里导入 **dotenv** 并调用 **dotenv.config()** 来初始化环境变量。我们应该在我们应用程序中的任何其他代码之前这样做：
- en: '[PRE92]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Now we can start replacing our static variables with environment variables.
    Edit **src/index.js** and replace the static port **3000** with **process.env.PORT**:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以开始用环境变量替换我们的静态变量。编辑 **src/index.js** 并将静态端口 **3000** 替换为 **process.env.PORT**：
- en: '[PRE93]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We have already migrated the **initDatabase** function to use **process.env.DATABASE_URL**
    earlier when we set up Jest. Now, we can edit **src/index.js** and import **initDatabase**
    there:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经在设置Jest时将**initDatabase**函数迁移到使用**process.env.DATABASE_URL**。现在，我们可以编辑**src/index.js**并从中导入**initDatabase**：
- en: '[PRE94]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Adjust the existing code to first call **initDatabase**, and only when the
    database initialized, start the Express app. We can now also handle errors while
    connecting to the database by adding a try/catch block:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整现有代码，首先调用**initDatabase**，只有当数据库初始化后，才开始Express应用。现在我们还可以通过添加try/catch块来处理连接数据库时的错误：
- en: '[PRE95]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Finally, create a **.env** file in the root of the project and define the two
    environment variables there:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在项目的根目录下创建一个**.env**文件，并在其中定义两个环境变量：
- en: '[PRE96]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We should exclude the **.env** file from the Git repository, as it is only
    used for local development. Edit **.gitignore** and add **.env** to it in a new
    line:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该将**.env**文件排除在Git仓库之外，因为它仅用于本地开发。编辑**.gitignore**并在新行中添加**.env**：
- en: '[PRE97]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: At the moment, we have no sensible information in our environment variables,
    but it is still a good practice to do this already now. Later, we may have some
    credentials in the environment variables, which we do not want to accidentally
    push to a Git repository.
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前，我们的环境变量中没有合理的信息，但这样做仍然是一个好习惯。稍后，我们可能有一些凭证存储在环境变量中，我们不希望不小心将其推送到Git仓库。
- en: To make it easier for someone to get started with our project, we can create
    a copy of our **.env** file and duplicate it to **.env.template**, making sure
    that it does not contain any sensitive credentials, of course! Sensitive credentials
    could instead be stored in, for example, a shared password manager.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使某人更容易开始我们的项目，我们可以创建**.env**文件的副本，并将其复制到**.env.template**，确保它不包含任何敏感凭证！敏感凭证可以存储在，例如，一个共享密码管理器中。
- en: 'If it is still running from before, stop the server (by pressing *Ctrl* + *C*
    in the Terminal) and start it again as follows:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它之前仍在运行，请停止服务器（在终端中按*Ctrl* + *C*），然后按照以下步骤重新启动：
- en: '[PRE98]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'You will get the following result:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下结果：
- en: '![Figure 3.9 – Initializing the database connection and the Express server
    with environment variables](img/B19385_03_9.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9 – 使用环境变量初始化数据库连接和Express服务器](img/B19385_03_9.jpg)'
- en: Figure 3.9 – Initializing the database connection and the Express server with
    environment variables
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – 使用环境变量初始化数据库连接和Express服务器
- en: As we can see, `dotenv` makes it easy to maintain environment variables for
    development while still allowing us the possibility to change them in a continuous
    integration, testing, or production environment.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`dotenv`使得在开发过程中维护环境变量变得容易，同时仍然允许我们在持续集成、测试或生产环境中更改它们。
- en: You may have noticed that we need to manually restart the server after making
    some changes. This is a stark contrast to the hot reloading we got out of the
    box from Vite, where any changes we make are applied to the frontend in the browser
    instantly. Let’s now spend some time to improve the development experience by
    making the server auto-restart on changes.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在做出一些更改后，我们需要手动重启服务器。这与我们从Vite中获得的即时热重载形成了鲜明对比，在那里我们做出的任何更改都会立即应用于浏览器中的前端。现在，让我们花些时间通过使服务器在更改时自动重启来改善开发体验。
- en: Using nodemon for easier development
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用nodemon简化开发
- en: To make our server auto-restart on changes, we can use the `nodemon` tool. The
    `nodemon` tool allows us to run our server, similarly to the node CLI command.
    However, it offers the possibility to auto-restart the server on changes to the
    source files.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的服务器在更改时自动重启，我们可以使用`nodemon`工具。`nodemon`工具允许我们运行服务器，类似于node CLI命令。然而，它提供了在源文件更改时自动重启服务器的可能性。
- en: 'Install the **nodemon** tool as a dev dependency:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**nodemon**工具安装为开发依赖项：
- en: '[PRE99]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Create a new **nodemon.json** file in the root of your project and add the
    following contents to it:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录下创建一个新的**nodemon.json**文件，并将以下内容添加到其中：
- en: '[PRE100]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: This makes sure that all code in the `src/` folder is watched for changes, and
    it will refresh if any files inside it are changed. Additionally, we specified
    the `.env` file in case environment variables are changed and the `package-lock.json`
    file in case packages are added or upgraded.
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这确保了`src/`文件夹中的所有代码都会被监视以检测更改，如果其中任何文件被更改，它将刷新。此外，我们还指定了`.env`文件，以防环境变量被更改，以及`package-lock.json`文件，以防添加或升级了包。
- en: 'Now, edit **package.json** and define a new **"dev"** script that runs **nodemon**:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编辑**package.json**，并定义一个新的**"dev"**脚本来运行**nodemon**：
- en: '[PRE101]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Stop the server (if it is currently running) and start it again by running
    the following command:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止服务器（如果它目前正在运行），然后通过运行以下命令重新启动它：
- en: '[PRE102]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'As we can see, our server is now running through **nodemon**! We can try it
    out by changing the port in the **.****env** file:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如我们所见，我们的服务器现在正在通过**nodemon**运行！我们可以通过更改**.env**文件中的端口号来尝试它：
- en: '[PRE103]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Edit **.env.template** as well to change the port to **3001**:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也要编辑**.env.template**，将端口号更改为**3001**：
- en: '[PRE104]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Keep the server running.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持服务器运行。
- en: '![Figure 3.10 – Nodemon automatically restarting the server after we changed
    the port](img/B19385_03_10.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![图3.10 – 在我们更改端口号后，Nodemon自动重新启动服务器](img/B19385_03_10.jpg)'
- en: Figure 3.10 – Nodemon automatically restarting the server after we changed the
    port
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – 在我们更改端口号后，Nodemon自动重新启动服务器
- en: After making the change, `nodemon` automatically restarted the server for us
    with the new port. We now have something like hot reloading, but for backend development—awesome!
    Now that we have improved the developer experience on the backend, let’s start
    writing our API routes with Express. Keep the server running (via `nodemon`) to
    see it restart and update live while coding!
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出更改后，`nodemon`会自动为我们使用新端口号重新启动服务器。现在我们有了类似热重载的功能，但适用于后端开发——太棒了！现在我们已经改善了后端开发者的体验，让我们开始使用Express编写我们的API路由。保持服务器运行（通过`nodemon`），以便在编码时看到它重新启动和更新：
- en: Creating our API routes with Express
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Express创建我们的API路由
- en: 'We can now start creating our previously defined API routes with express. We
    start by defining the GET routes:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始使用Express创建之前定义的API路由。我们首先定义GET路由：
- en: 'Create a new **src/routes/posts.js** file and import the service functions
    there:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**src/routes/posts.js**文件，并在其中导入服务函数：
- en: '[PRE105]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Now create and export a new function called **postsRoutes**, which takes the
    Express app as an argument:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建并导出一个名为**postsRoutes**的新函数，该函数接受Express应用作为参数：
- en: '[PRE106]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'In this function, define the routes. Start with the **GET /****api/v1/posts**
    route:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个函数中，定义路由。从**GET /****api/v1/posts**路由开始：
- en: '[PRE107]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'In this route, we need to make use of query params (**req.query** in Express)
    to map them to the arguments of our functions. We want to be able to add query
    params for **sortBy**, **sortOrder**, **author**, and **tag**:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此路由中，我们需要利用查询参数（Express中的**req.query**）将它们映射到我们函数的参数上。我们希望能够为**sortBy**、**sortOrder**、**author**和**tag**添加查询参数：
- en: '[PRE108]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Before we call our service functions, which might throw an error if we pass
    invalid data to the database functions, we should add a try-catch block to handle
    potential errors properly:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们调用服务函数之前，这些函数可能会在将无效数据传递给数据库函数时抛出错误，我们应该添加一个try-catch块来正确处理潜在的错误：
- en: '[PRE109]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'We now need to check if the **author** or **tag** was provided. If both were
    provided, we return a **400 Bad Request** status code and a JSON object with an
    error message by calling **res.json()**:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要检查是否提供了**author**或**tag**。如果两者都提供了，我们通过调用**res.json()**返回一个**400 Bad Request**状态码和包含错误信息的JSON对象：
- en: '[PRE110]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Otherwise, we call the respective service function and return a JSON response
    in Express by calling **res.json()**. In case an error happened, we catch it,
    log it, and return a 500 status code:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们调用相应的服务函数，并通过调用**res.json()**在Express中返回JSON响应。如果发生错误，我们捕获它，记录它，并返回一个500状态码：
- en: '[PRE111]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Next, we define an API route to get a single post. We use the **:id** param
    placeholder to be able to access it as a dynamic parameter in the function:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个API路由来获取单个帖子。我们使用**:id**参数占位符来能够在函数中将其作为动态参数访问：
- en: '[PRE112]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Now, we can access **req.params.id** to get the **:id** part of our route and
    pass it to our service function:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过访问**req.params.id**来获取路由中的**:id**部分，并将其传递给我们的服务函数：
- en: '[PRE113]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'If the result of the function is **null**, we return a 404 response because
    the post was not found. Otherwise, we return the post as a JSON response:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果函数的结果是**null**，我们返回一个404响应，因为帖子未找到。否则，我们返回作为JSON响应的帖子：
- en: '[PRE114]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: By default, Express will return the JSON response with status 200 OK.
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，Express将返回带有状态200 OK的JSON响应。
- en: 'After defining our GET routes, we still need to mount them in our app. Edit
    **src/app.js** and import the **postsRoutes** function there:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义我们的GET路由之后，我们仍然需要在我们的应用中挂载它们。编辑**src/app.js**，并在其中导入**postsRoutes**函数：
- en: '[PRE115]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Then, call the **postsRoutes(app)** function after initializing our Express
    app:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在初始化我们的Express应用后，调用**postsRoutes(app)**函数：
- en: '[PRE116]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Go to http://localhost:3001/api/v1/posts to see the route in action!
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往http://localhost:3001/api/v1/posts查看该路由的实际效果！
- en: '![Figure 3.11 – Our first real API route in action!](img/B19385_03_11.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.11 – 我们第一个真正的 API 路由正在运行！](img/B19385_03_11.jpg)'
- en: Figure 3.11 – Our first real API route in action!
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – 我们第一个真正的 API 路由正在运行！
- en: Tip
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can install a **JSON Formatter** extension in your browser to format the
    JSON response nicely, like in *Figure 3**.11*.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在浏览器中安装一个 **JSON 格式化器** 扩展来格式化 JSON 响应，就像在 *图 3.11* 中那样。
- en: After defining the GET routes, we need to define the POST routes. However, these
    accept a body, which will be formatted as JSON objects. As such, we need a way
    to parse this JSON body in Express.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了 GET 路由之后，我们需要定义 POST 路由。然而，这些路由接受一个体，其格式为 JSON 对象。因此，我们需要一种方法在 Express
    中解析这个 JSON 体。
- en: Defining routes with a JSON request body
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义带有 JSON 请求体的路由
- en: To define routes with a JSON request body in Express, we need to use the `body-parser`
    module. This module detects if a client sent a JSON request (by looking at the
    `Content-Type` header) and then automatically parses it for us so that we can
    access the object in `req.body`.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Express 中，要定义带有 JSON 请求体的路由，我们需要使用 `body-parser` 模块。此模块会检测客户端是否发送了 JSON 请求（通过查看
    `Content-Type` 头部），然后自动为我们解析它，以便我们可以访问 `req.body` 中的对象。
- en: 'Install the **body-parser** dependency:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 **body-parser** 依赖项：
- en: '[PRE117]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Edit **src/app.js** and import the **body-parser** there:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/app.js** 并在其中的 **body-parser** 模块中导入：
- en: '[PRE118]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Now add the following code after our app is initialized to load the **body-parser**
    plugin as middleware into our Express app:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们的应用初始化后添加以下代码，将 **body-parser** 插件作为中间件加载到我们的 Express 应用中：
- en: '[PRE119]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Note
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Middleware in Express allows us to do something before and after each request.
    In this case, **body-parser** is reading the JSON body for us, parsing it as JSON
    and giving us a JavaScript object that we can easily access from our route definitions.
    It should be noted that only routes defined after the middleware have access to
    it, so the order of defining middleware and routes is important!
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: Express 的中间件允许我们在每个请求之前和之后执行某些操作。在这种情况下，**body-parser** 为我们读取 JSON 体，将其解析为 JSON，并给我们一个
    JavaScript 对象，我们可以轻松地从我们的路由定义中访问它。需要注意的是，只有定义在中间件之后的路由才能访问它，因此定义中间件和路由的顺序很重要！
- en: 'After loading the **body-parser**, we edit **src/routes/posts.js** and import
    the service functions needed to make the rest of our routes:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在加载 **body-parser** 之后，我们编辑 **src/routes/posts.js** 并导入制作其余路由所需的服务函数：
- en: '[PRE120]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Now, we define the **POST /api/v1/posts** route by using **app.post** and **req.body**,
    inside of the **postsRoutes** function:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们通过使用 **app.post** 和 **req.body** 在 **postsRoutes** 函数内部定义 **POST /api/v1/posts**
    路由：
- en: '[PRE121]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Similarly, we can define the update route, where we need to make use of the
    **id** param and the request body:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们可以定义更新路由，其中我们需要使用 **id** 参数和请求体：
- en: '[PRE122]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Finally, we define the delete route, which does not require the **body-parser**;
    we just need to get the **id** param here. We return 404 if the post was not found,
    and 204 No Content if the post was deleted successfully:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义一个删除路由，它不需要 **body-parser**；我们只需要在这里获取 **id** 参数。如果帖子未找到，则返回 404，如果帖子成功删除，则返回
    204 No Content：
- en: '[PRE123]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: As we can see, Express makes defining and handling routes, requests, and responses
    much easier. It already detects and sets headers for us, and thus it can read
    and send JSON responses properly. It also allows us to change the HTTP status
    code easily.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Express 使定义和处理路由、请求和响应变得容易得多。它已经为我们检测并设置了头部，因此可以正确地读取和发送 JSON 响应。它还允许我们轻松地更改
    HTTP 状态码。
- en: Now that we finished defining the routes with a JSON request body, let’s allow
    access to our routes from other URLs using **cross-origin resource** **sharing**
    (**CORS**).
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了带有 JSON 请求体的路由定义，让我们允许从其他 URL 访问我们的路由，使用 **跨源资源共享**（**CORS**）。
- en: Allowing access from other URLs using CORS
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 CORS 允许从其他 URL 访问
- en: 'Browsers have a safety feature to only allow us to access APIs on the same
    URL as the page we are currently on. To allow access to our backend from other
    URLs than the backend URL itself (for example, when we run the frontend on a different
    port in the next chapter), we need to allow CORS requests. Let’s set that up now
    by using the `cors` library with Express:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器有一个安全特性，只允许我们访问与我们当前页面相同的 URL 的 API。为了允许从除后端 URL 本身之外的其他 URL（例如，当我们将在下一章中在另一个端口上运行前端时）访问我们的后端，我们需要允许
    CORS 请求。现在让我们通过使用 Express 的 `cors` 库来设置它：
- en: 'Install the **cors** dependency:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 **cors** 依赖项：
- en: '[PRE124]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Edit **src/app.js** and import **cors** there:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/app.js** 并在其中导入 **cors**：
- en: '[PRE125]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Now add the following code after our app is initialized to load the **cors**
    plugin as middleware into our Express app:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要在应用初始化后添加以下代码，将**cors**插件作为中间件加载到我们的Express应用中：
- en: '[PRE126]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Now that CORS requests are allowed, we can start trying out the routes in a
    browser!
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 现在CORS请求被允许后，我们可以在浏览器中开始尝试这些路由！
- en: Trying out the routes
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尝试路由
- en: 'After defining our routes, we can try them out by using the `fetch()` function
    in the browser:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义我们的路由后，我们可以通过在浏览器中使用`fetch()`函数来尝试它们：
- en: In your browser, go to **http://localhost:3001/**, open the console by right-clicking
    on a page and clicking **Inspect**, then go to the **Console** tab.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中，访问**http://localhost:3001/**，通过右键点击页面并点击**Inspect**来打开控制台，然后转到**Console**标签页。
- en: 'In the console, enter the following code to make a GET request to get all posts:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中输入以下代码来发送一个GET请求以获取所有帖子：
- en: '[PRE127]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Now we can modify this code to make a POST request by specifying the **Content-Type**
    header to tell the server that we will be sending JSON and then sending a body
    with **JSON.stringify** (as the body has to be a string):'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以修改这段代码，通过指定**Content-Type**头来告诉服务器我们将发送JSON，然后使用**JSON.stringify**发送一个体（因为体必须是一个字符串）来发送一个POST请求：
- en: '[PRE128]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Similarly, we can also send a **PATCH** request, as follows:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们也可以发送一个**PATCH**请求，如下所示：
- en: '[PRE129]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Make sure to replace the MongoDB IDs in the URL with the one returned from the
    `POST` request made before!
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保将URL中的MongoDB IDs替换为之前通过`POST`请求返回的一个！
- en: 'Finally, we can send a **DELETE** request:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以发送一个**DELETE**请求：
- en: '[PRE130]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'When doing a GET request, we can see that our post has now been deleted again:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当进行GET请求时，我们可以看到我们的帖子现在已经被再次删除：
- en: '[PRE131]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: This request should now return a `404`.
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个请求现在应该返回一个`404`。
- en: Tip
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Instead of the browser console, you can also use command line tools such as
    **curl** or apps such as Postman to make the requests. Feel free to use different
    tools to try out the requests if you are already familiar with them.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 除了浏览器控制台，您还可以使用**curl**或Postman等应用程序来发送请求。如果您已经熟悉这些工具，请随意使用不同的工具来尝试请求。
- en: We have now successfully defined all routes needed to handle a simple blog post
    API!
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经成功定义了处理简单博客文章API所需的所有路由！
- en: Summary
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The first version of our backend service is now complete, allowing us to create,
    read, update, and delete blog posts via a REST API (using Express), which then
    get stored in a MongoDB database (using Mongoose). Additionally, we have created
    service functions with unit tests, defined using the Jest test suite. All in all,
    we managed to create a solid foundation for our backend in this chapter.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的后端服务的第一版现在已完成，允许我们通过REST API（使用Express）创建、读取、更新和删除博客文章，这些文章随后被存储在MongoDB数据库中（使用Mongoose）。此外，我们还创建了带有单元测试的服务函数，这些测试是用Jest测试套件定义的。总的来说，我们在本章中为我们的后端建立了一个坚实的基础。
- en: In the next chapter, [*Chapter 4*](B19385_04.xhtml#_idTextAnchor076), *Integrating
    a Frontend Using React and TanStack Query*, we are going to integrate our backend
    into a React frontend using TanStack Query, a library to handle asynchronous state
    and thus data fetched from our server. This means that, after the next chapter,
    we will have developed our first full-stack application!
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，[*第4章*](B19385_04.xhtml#_idTextAnchor076)，*使用React和TanStack Query集成前端*，我们将使用TanStack
    Query库（一个处理异步状态和从我们的服务器获取的数据的库）将我们的后端集成到React前端中。这意味着在下一章之后，我们将开发出我们的第一个全栈应用程序！
