<html><head></head><body>
<div id="_idContainer058">
<h1 class="chapter-number" id="_idParaDest-205"><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.1.1">14</span></h1>
<h1 id="_idParaDest-206"><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.2.1">Real Time with Remix</span></h1>
<p><span class="koboSpan" id="kobo.3.1">The web platform offers standards and capabilities to send data in real time. </span><span class="koboSpan" id="kobo.3.2">With real-time technologies, we can implement chat features and multiplayer UIs for real-time collaboration and interactions. </span><span class="koboSpan" id="kobo.3.3">We have seen several apps with real-time features grow in popularity and redefine their product categories, such as Google Docs and Figma. </span><span class="koboSpan" id="kobo.3.4">In this chapter, we will learn about real-time UIs </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">with Remix.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">This chapter is split into </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">two sections:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Working with </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">real-time technologies</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Building real-time UIs </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">with Remix</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.11.1">First, we will compare real-time technologies and discuss the requirements for hosting providers and server environments. </span><span class="koboSpan" id="kobo.11.2">Next, we will outline implementations with Remix. </span><span class="koboSpan" id="kobo.11.3">Finally, we will implement </span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.12.1">a simple real-time UI in BeeRich by utilizing </span><strong class="bold"><span class="koboSpan" id="kobo.13.1">Server-Sent </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.14.1">Events</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.15.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.16.1">SSE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">After reading this chapter, you will understand the requirements for working with real-time technologies in Remix. </span><span class="koboSpan" id="kobo.18.2">You will also be able to name the differences between polling, SSE, and WebSocket. </span><span class="koboSpan" id="kobo.18.3">Finally, you will know how to work with SSE </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">in Remix.</span></span></p>
<h1 id="_idParaDest-207"><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.20.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.21.1">You can find the code for this chapter here: </span><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/14-real-time-with-remix"><span class="koboSpan" id="kobo.22.1">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/14-real-time-with-remix</span></a><span class="koboSpan" id="kobo.23.1">. </span><span class="koboSpan" id="kobo.23.2">No additional setup is required for </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">this chapter.</span></span></p>
<h1 id="_idParaDest-208"><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.25.1">Working with real-time technologies</span></h1>
<p><span class="koboSpan" id="kobo.26.1">The </span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.27.1">web platform offers different protocols and standards for real-time communication. </span><span class="koboSpan" id="kobo.27.2">In this section, we will review different technologies and techniques and discuss the requirements for utilizing them with Remix. </span><span class="koboSpan" id="kobo.27.3">We will discuss polling, learn about SSE, and review the WebSocket API. </span><span class="koboSpan" id="kobo.27.4">First, let’s have a look at </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">polling techniques.</span></span></p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.29.1">Understanding polling</span></h2>
<p><span class="koboSpan" id="kobo.30.1">Polling is a</span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.31.1"> client-pull technique in which the client requests </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.32.1">data from the server. </span><span class="koboSpan" id="kobo.32.2">Instead of relying on a server to push updates, polling utilizes intervals to check for the latest data from </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">the server.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">We can differentiate between short and long polling. </span><span class="koboSpan" id="kobo.34.2">Short polling sends requests in time-based intervals to the server. </span><span class="koboSpan" id="kobo.34.3">The server responds immediately, either with new data or indicating nothing has changed. </span><span class="koboSpan" id="kobo.34.4">With long polling, the server only responds once new data is available, keeping the request unanswered until then. </span><span class="koboSpan" id="kobo.34.5">The client sends a new request once the server responds or the request </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">times out.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">The advantage of polling is that it does not require the server environment and hosting provider to support WebSockets, HTTP/2, or long-running streaming responses. </span><span class="koboSpan" id="kobo.36.2">Polling can be a great compromise when working with server environments and hosting providers that do not support real-time protocols and standards. </span><span class="koboSpan" id="kobo.36.3">It is also simpler to implement and potentially a great tool </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">for prototyping.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">The disadvantage of polling is its wasteful resource consumption and delayed real-time behavior. </span><span class="koboSpan" id="kobo.38.2">Short polling creates many unnecessary requests that yield no new data, while long polling forces the server to handle idle requests until new data is received. </span><span class="koboSpan" id="kobo.38.3">Short polling may also delay real-time updates based on the interval </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">retry time.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">Next, let’s have a look </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">at SSE.</span></span></p>
<h2 id="_idParaDest-210"><a id="_idTextAnchor209"/><span class="koboSpan" id="kobo.42.1">Understanding SSE</span></h2>
<p><span class="koboSpan" id="kobo.43.1">SSE is </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.44.1">an </span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.45.1">HTTP-based server push standard and part of the HTML5 spec. </span><span class="koboSpan" id="kobo.45.2">SSE requires both a client and a server. </span><span class="koboSpan" id="kobo.45.3">The client requests a connection using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">EventSource</span></strong><span class="koboSpan" id="kobo.47.1"> API; the server implements an endpoint that returns a stream response with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">text/event-stream</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.49.1">media type.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">The stream response creates a one-way communication line from the server to the client. </span><span class="koboSpan" id="kobo.50.2">This allows the server to send events to the client without the need for the client to </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">use polling.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">The </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.53.1">advantage of SSE is reduced resource consumption. </span><span class="koboSpan" id="kobo.53.2">The client does not need to send unnecessary requests to the server. </span><span class="koboSpan" id="kobo.53.3">Instead, the server only sends events to the client once an update </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">is available.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">The</span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.56.1"> disadvantage of SSE is the long-running HTTP connection, which needs to be maintained by the server. </span><span class="koboSpan" id="kobo.56.2">Additionally, SSE only provides a one-way communication line. </span><span class="koboSpan" id="kobo.56.3">The client is not able to send messages to the server. </span><span class="koboSpan" id="kobo.56.4">Finally, HTTP/1 only allows servers to maintain six concurrent connections at a time. </span><span class="koboSpan" id="kobo.56.5">Luckily, most server environments support HTTP/2, but the HTTP/1 limitation may still be relevant, depending on your </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">hosting provider.</span></span></p>
<h2 id="_idParaDest-211"><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.58.1">Understanding WebSocket</span></h2>
<p><span class="koboSpan" id="kobo.59.1">WebSocket is </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.60.1">a communication protocol that’s </span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.61.1">implemented through the web’s WebSocket API and creates a persistent two-way communication line. </span><span class="koboSpan" id="kobo.61.2">Unlike SSE and polling solutions, WebSocket operates directly on TCP rather </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">than HTTP.</span></span></p>
<p><span class="koboSpan" id="kobo.63.1">Once a WebSocket connection has been established, both parties (for example, the browser and the server) can send and receive messages simultaneously. </span><span class="koboSpan" id="kobo.63.2">Since the protocol operates on TCP, it can transfer not only UTF-8-encoded data but also binary data, making it a performant </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">lower-level protocol.</span></span></p>
<p><span class="koboSpan" id="kobo.65.1">The advantage of </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.66.1">WebSocket connections is their two-way communication channel and the increased performance from using TCP directly. </span><span class="koboSpan" id="kobo.66.2">However, WebSocket connections are not supported by all hosting providers and JavaScript runtimes as they require long-running servers. </span><span class="koboSpan" id="kobo.66.3">The WebSocket API is also the most complex to implement and utilize, requiring the setup of a </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">WebSocket server.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">All three techniques enable us to implement real-time capabilities. </span><span class="koboSpan" id="kobo.68.2">Polling lets us build multiplayer UIs, even if our server environment does not support streaming responses or setting up WebSocket servers. </span><span class="koboSpan" id="kobo.68.3">SSE provides a simpler way for the server to send events and data to the client. </span><span class="koboSpan" id="kobo.68.4">The WebSocket API is a lower-level protocol that allows us to create bi-directional communication channels capable of creating performant and scalable </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">multiplayer UIs.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">Now that you understand the differences between polling, SSE, and the WebSocket API, we can implement a real-time UI in BeeRich. </span><span class="koboSpan" id="kobo.70.2">In the next section, we will do </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">just that.</span></span></p>
<h1 id="_idParaDest-212"><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.72.1">Building real-time UIs with Remix</span></h1>
<p><span class="koboSpan" id="kobo.73.1">BeeRich</span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.74.1"> uses Remix’s Express.js adapter and runs on a long-running server. </span><span class="koboSpan" id="kobo.74.2">As such, BeeRich can take advantage of polling, SSE, and the WebSocket API to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">real-time features.</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">Short polling is simple to set up. </span><span class="koboSpan" id="kobo.76.2">We can implement short polling in Remix by using Remix’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">useRevalidator</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.78.1"> hook:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.79.1">
import { useEffect } from 'react';</span><strong class="bold"><span class="koboSpan" id="kobo.80.1">import { useRevalidator } from '@remix-run/react';</span></strong><span class="koboSpan" id="kobo.81.1">
function Component() {
  </span><strong class="bold"><span class="koboSpan" id="kobo.82.1">const { revalidate } = useRevalidator();</span></strong><span class="koboSpan" id="kobo.83.1">
  useEffect(() =&gt; {
    const interval = setInterval(</span><strong class="bold"><span class="koboSpan" id="kobo.84.1">revalidate</span></strong><span class="koboSpan" id="kobo.85.1">, 4000);
    return () =&gt; {
      clearInterval(interval);
    };
  }, [revalidate]);
}</span></pre>
<p><span class="koboSpan" id="kobo.86.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">revalidate</span></strong><span class="koboSpan" id="kobo.88.1"> function of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">useRevalidator</span></strong><span class="koboSpan" id="kobo.90.1"> hook triggers a </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">loader</span></strong><span class="koboSpan" id="kobo.92.1"> revalidation. </span><span class="koboSpan" id="kobo.92.2">This allows us to refetch all loader data, similar to how Remix refetches all loader data after executing an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">action</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.94.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">Since the WebSocket protocol is TCP-based, we would need to create the WebSocket server and endpoint outside of our Remix application using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">server.js</span></strong><span class="koboSpan" id="kobo.97.1"> file at the root of our project or using a different server environment altogether. </span><span class="koboSpan" id="kobo.97.2">This is doable but outside the scope of this book. </span><span class="koboSpan" id="kobo.97.3">Instead, we will review how to use SSE </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">with Remix.</span></span></p>
<p><span class="koboSpan" id="kobo.99.1">Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">loader</span></strong><span class="koboSpan" id="kobo.101.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">action</span></strong><span class="koboSpan" id="kobo.103.1"> functions can create HTTP-based resource routes. </span><span class="koboSpan" id="kobo.103.2">We can implement an SSE endpoint on a long-running server environment by using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">loader</span></strong><span class="koboSpan" id="kobo.105.1"> function to return a stream response with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">text/event-stream</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.107.1">media type.</span></span></p>
<p><span class="koboSpan" id="kobo.108.1">We aim to</span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.109.1"> inform all devices and open browser tabs that are logged in with the same user of expense and invoice data changes. </span><span class="koboSpan" id="kobo.109.2">We also want to revalidate the UI whenever such a change is detected. </span><span class="koboSpan" id="kobo.109.3">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">get started:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.111.1">First, create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">server-sent-events</span></strong><span class="koboSpan" id="kobo.113.1"> folder </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">app/modules/</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.117.1">Next, create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">events.server.ts</span></strong><span class="koboSpan" id="kobo.119.1"> file in the new folder and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.121.1">
import { EventEmitter } from 'events';declare global {  // eslint-disable-next-line no-var  var emitter: EventEmitter;}global.emitter = global.emitter || new EventEmitter();export const emitter = global.emitter;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.122.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">EventEmitter</span></strong><span class="koboSpan" id="kobo.124.1"> API from Node.js and declare a globally accessible event emitter for our server environment. </span><span class="koboSpan" id="kobo.124.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">EventEmitter</span></strong><span class="koboSpan" id="kobo.126.1"> object can be used to listen to and emit events. </span><span class="koboSpan" id="kobo.126.2">We will utilize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">emit</span></strong><span class="koboSpan" id="kobo.128.1"> function in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">action</span></strong><span class="koboSpan" id="kobo.130.1"> functions to communicate data changes to the server-sent event connection </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">handler code.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.132.1">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">EventEmitter</span></strong><span class="koboSpan" id="kobo.134.1"> API has nothing to do with SSE but provides a neat way for event-based communication in our Node.js </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">server environment.</span></span></p></li> <li><span class="koboSpan" id="kobo.136.1">Now, implement an </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">eventStream</span></strong><span class="koboSpan" id="kobo.138.1"> helper function </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">events.server.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.142.1">
export type SendEvent = (event: string, data: string) =&gt; void;export type OnSetup = (send: SendEvent) =&gt; OnClose;export type OnClose = () =&gt; void;export function eventStream(request: Request, onSetup: OnSetup) {  </span><strong class="bold"><span class="koboSpan" id="kobo.143.1">const stream = new ReadableStream</span></strong><span class="koboSpan" id="kobo.144.1">({    start(controller) {      const encoder = new TextEncoder();      const send: SendEvent = (event, data) =&gt; {        controller.enqueue(encoder.encode(`event: ${event}\n`));        controller.enqueue(encoder.encode(`data: ${data}\n\n`));      };      const onClose = onSetup(send);      let closed = false;      const close = () =&gt; {        if (closed) return;        closed = true;        onClose();        request.signal.removeEventListener('abort', close);        controller.close();      };      request.signal.addEventListener('abort', close);      if (request.signal.aborted) {        close();        return;      }    },  });  return new Response(</span><strong class="bold"><span class="koboSpan" id="kobo.145.1">stream</span></strong><span class="koboSpan" id="kobo.146.1">, {    headers: {      'Cache-Control': 'no-store, no-transform',      </span><strong class="bold"><span class="koboSpan" id="kobo.147.1">Connection: 'keep-alive'</span></strong><span class="koboSpan" id="kobo.148.1">,      </span><strong class="bold"><span class="koboSpan" id="kobo.149.1">'Content-Type': 'text/event-stream'</span></strong><span class="koboSpan" id="kobo.150.1">,    },  });}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.151.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">eventStream</span></strong><span class="koboSpan" id="kobo.153.1"> function creates a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">ReadableStream</span></strong><span class="koboSpan" id="kobo.155.1"> object. </span><span class="koboSpan" id="kobo.155.2">The stream object contains a </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">start</span></strong><span class="koboSpan" id="kobo.157.1"> function. </span><span class="koboSpan" id="kobo.157.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">start</span></strong><span class="koboSpan" id="kobo.159.1">, we define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">send</span></strong><span class="koboSpan" id="kobo.161.1"> function, which</span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.162.1"> is responsible for adding events to the stream that will be sent to the client. </span><span class="koboSpan" id="kobo.162.2">The code also includes logic to correctly close the stream. </span><span class="koboSpan" id="kobo.162.3">Finally, the function returns an event stream </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">Response</span></strong><span class="koboSpan" id="kobo.164.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">ReadableStream</span></strong><span class="koboSpan" id="kobo.166.1"> object as the </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">response body.</span></span></p></li> <li><span class="koboSpan" id="kobo.168.1">Next, implement the endpoint responsible for delivering the event stream response. </span><span class="koboSpan" id="kobo.168.2">Create </span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.169.1">a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">/sse.tsx</span></strong><span class="koboSpan" id="kobo.171.1"> route in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">routes</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.174.1"> folder:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.175.1">
import type { LoaderFunctionArgs } from '@remix-run/node';import type { OnSetup } from '~/modules/server-sent-events/events.server';import { emitter, eventStream } from '~/modules/server-sent-events/events.server';import { requireUserId } from '~/modules/session/session.server';export async function loader({ request }: LoaderFunctionArgs) {  </span><strong class="bold"><span class="koboSpan" id="kobo.176.1">const userId = await requireUserId(request);</span></strong><span class="koboSpan" id="kobo.177.1">  const onSetup: OnSetup = (send) =&gt; {    function handler() {      send('server-change', `Data change for ${userId}`);    }    </span><strong class="bold"><span class="koboSpan" id="kobo.178.1">emitter.addListener(userId, handler);</span></strong><span class="koboSpan" id="kobo.179.1">    return () =&gt; {      emitter.removeListener(userId, handler);    };  };  </span><strong class="bold"><span class="koboSpan" id="kobo.180.1">return eventStream(request, onSetup);</span></strong><span class="koboSpan" id="kobo.181.1">}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.182.1">This</span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.183.1"> isn’t a lot a lot of code considering that we implement an endpoint capable of sending real-time events. </span><span class="koboSpan" id="kobo.183.2">First, we ensure the request comes from an authenticated user (</span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">requireUserId</span></strong><span class="koboSpan" id="kobo.185.1">). </span><span class="koboSpan" id="kobo.185.2">Next, we implement a helper function that we will pass to </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">eventStream</span></strong><span class="koboSpan" id="kobo.187.1">. </span><span class="koboSpan" id="kobo.187.2">This helper function uses our </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">EventEmitter</span></strong><span class="koboSpan" id="kobo.189.1"> object to listen to events on the server. </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">emitter</span></strong><span class="koboSpan" id="kobo.191.1"> listens for events that match the </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">userId</span></strong><span class="koboSpan" id="kobo.193.1"> property of the authenticated user and triggers a new sever-sent event using the event stream once such event </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">is received.</span></span></p></li> <li><span class="koboSpan" id="kobo.195.1">Next, add the global </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">emitter</span></strong><span class="koboSpan" id="kobo.197.1"> object to all expense and invoice </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">action</span></strong><span class="koboSpan" id="kobo.199.1"> functions. </span><span class="koboSpan" id="kobo.199.2">Whenever an action succeeds, we want to emit the </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">server-change</span></strong><span class="koboSpan" id="kobo.201.1"> event on the server and trigger a new event to all </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">connected clients:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.203.1">
emitter.emit(userId);</span></pre></li> <li><span class="koboSpan" id="kobo.204.1">For instance, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">action</span></strong><span class="koboSpan" id="kobo.206.1"> function of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">dashboard.expenses._index.tsx</span></strong><span class="koboSpan" id="kobo.208.1"> route module, add the event emitter call before returning the redirect. </span><span class="koboSpan" id="kobo.208.2">This ensures the event is only emitted after the action has succeeded and the database has </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">been updated:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.210.1">emitter.emit(userId);</span></strong><span class="koboSpan" id="kobo.211.1">return redirect(`/dashboard/expenses/${expense.id}`);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.212.1">We set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">emitter</span></strong><span class="koboSpan" id="kobo.214.1"> object on the global object and can access it on the server without importing it. </span><span class="koboSpan" id="kobo.214.2">However, you can also import it if </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">you like:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.216.1">import { emitter } from '~/modules/server-sent-events/events.server';</span></pre></li> <li><span class="koboSpan" id="kobo.217.1">After adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">emit</span></strong><span class="koboSpan" id="kobo.219.1"> function call to the expense and invoice creation actions, add </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">emit</span></strong><span class="koboSpan" id="kobo.221.1"> function calls to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">handleDelete</span></strong><span class="koboSpan" id="kobo.223.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">handleUpdate</span></strong><span class="koboSpan" id="kobo.225.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">handleRemoveAttachment</span></strong><span class="koboSpan" id="kobo.227.1"> functions in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">dashboard.expenses.$id._index.tsx</span></strong><span class="koboSpan" id="kobo.229.1"> route module. </span><span class="koboSpan" id="kobo.229.2">Again, call </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">emit</span></strong><span class="koboSpan" id="kobo.231.1"> after the data mutation has succeeded to avoid </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">race conditions.</span></span></li>
<li><span class="koboSpan" id="kobo.233.1">Make sure</span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.234.1"> you also apply the same changes to the invoice </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">action</span></strong><span class="koboSpan" id="kobo.236.1"> functions. </span><span class="koboSpan" id="kobo.236.2">You can always review the final implementation in the solution folder of </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">this chapter.</span></span></li>
<li><span class="koboSpan" id="kobo.238.1">Let’s turn our attention to the client environment. </span><span class="koboSpan" id="kobo.238.2">Add a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">event-source.tsx</span></strong><span class="koboSpan" id="kobo.240.1"> file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">app/modules/server-sent-events</span></strong><span class="koboSpan" id="kobo.242.1"> folder and implement the event stream </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">connection request:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.244.1">
import { </span><strong class="bold"><span class="koboSpan" id="kobo.245.1">useRevalidator</span></strong><span class="koboSpan" id="kobo.246.1"> } from '@remix-run/react';import { useEffect } from 'react';export function useEventSource() {  </span><strong class="bold"><span class="koboSpan" id="kobo.247.1">const { revalidate } = useRevalidator();</span></strong><span class="koboSpan" id="kobo.248.1">  useEffect(() =&gt; {    function handler(event: MessageEvent) {      console.log(`Received server event [${new Date().toLocaleTimeString()}]`, event.data);      </span><strong class="bold"><span class="koboSpan" id="kobo.249.1">revalidate();</span></strong><span class="koboSpan" id="kobo.250.1">    }    const eventSource = new EventSource(</span><strong class="bold"><span class="koboSpan" id="kobo.251.1">'/sse'</span></strong><span class="koboSpan" id="kobo.252.1">);    eventSource.addEventListener(</span><strong class="bold"><span class="koboSpan" id="kobo.253.1">'server-change'</span></strong><span class="koboSpan" id="kobo.254.1">, handler);    return () =&gt; {      eventSource.removeEventListener('server-change', handler);      eventSource.close();    };  }, [revalidate]);}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.255.1">We use </span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.256.1">Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">revalidate</span></strong><span class="koboSpan" id="kobo.258.1"> function to revalidate all loader data once a server-sent event is received. </span><span class="koboSpan" id="kobo.258.2">The hook uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">EventSource</span></strong><span class="koboSpan" id="kobo.260.1"> API to connect to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">/sse</span></strong><span class="koboSpan" id="kobo.262.1"> route, where we implemented our event stream </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">loader</span></strong><span class="koboSpan" id="kobo.264.1"> function. </span><span class="koboSpan" id="kobo.264.2">The hook then adds an event listener to listen for </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">server-change</span></strong><span class="koboSpan" id="kobo.266.1"> events – an arbitrary event name we specified in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">loader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.268.1"> code.</span></span></p></li> <li><span class="koboSpan" id="kobo.269.1">Finally, import the new hook in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">dashboard.tsx</span></strong><span class="koboSpan" id="kobo.271.1"> route module and call the hook in the route </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">module component:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.273.1">
import { </span><strong class="bold"><span class="koboSpan" id="kobo.274.1">useEventSource</span></strong><span class="koboSpan" id="kobo.275.1"> } from '~/modules/server-sent-events/event-source';export default function Component() {  const { firstExpense, firstInvoice } = useLoaderData&lt;typeof loader&gt;();  </span><strong class="bold"><span class="koboSpan" id="kobo.276.1">useEventSource();</span></strong><span class="koboSpan" id="kobo.277.1">  //…}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.278.1">Just like that, we set up a connection using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">EventSource</span></strong><span class="koboSpan" id="kobo.280.1"> API and </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">SSE standard.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.282.1">Whenever the user navigates to a dashboard route, we now initiate a request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">/sse</span></strong><span class="koboSpan" id="kobo.284.1"> endpoint. </span><span class="koboSpan" id="kobo.284.2">The endpoint authenticates the user and returns a streaming response. </span><span class="koboSpan" id="kobo.284.3">The server further listens for events from </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">action</span></strong><span class="koboSpan" id="kobo.286.1"> functions using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">EventEmitter</span></strong><span class="koboSpan" id="kobo.288.1"> API. </span><span class="koboSpan" id="kobo.288.2">Once the same user calls an </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">action</span></strong><span class="koboSpan" id="kobo.290.1"> function (for example, by submitting a form), the </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">action</span></strong><span class="koboSpan" id="kobo.292.1"> function emits an event that is then handled by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">loader</span></strong><span class="koboSpan" id="kobo.294.1"> code of the streaming response. </span><span class="koboSpan" id="kobo.294.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">handler</span></strong><span class="koboSpan" id="kobo.296.1"> function is executed on the server and sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">server-change</span></strong><span class="koboSpan" id="kobo.298.1"> event to all connected clients of the same user. </span><span class="koboSpan" id="kobo.298.2">The clients receive the event and initiate a </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">loader revalidation.</span></span></p></li> <li><span class="koboSpan" id="kobo.300.1">Run the</span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.301.1"> application locally by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">npm run dev</span></strong><span class="koboSpan" id="kobo.303.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">a terminal.</span></span></li>
<li><span class="koboSpan" id="kobo.305.1">Test the implementation by opening BeeRich in two or more tabs. </span><span class="koboSpan" id="kobo.305.2">You can also run BeeRich in several browsers to investigate the real-time behavior. </span><span class="koboSpan" id="kobo.305.3">Log in as the same user and update and delete invoices and expenses. </span><span class="koboSpan" id="kobo.305.4">Do you see how the expense history grows with every change in real time? </span><span class="koboSpan" id="kobo.305.5">Can you see the UI update across the different windows </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">and tabs?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.307.1">Great work! </span><span class="koboSpan" id="kobo.307.2">Just like that, we can implement real-time UIs in Remix. </span><span class="koboSpan" id="kobo.307.3">However, the current implementation has one notable issue: the client that calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">action</span></strong><span class="koboSpan" id="kobo.309.1"> function revalidates its UI twice – one time using Remix’s built-in revalidation step and once after receiving the server-sent event. </span><span class="koboSpan" id="kobo.309.2">This puts an extra burden on the server and the user’s network bandwidth. </span><span class="koboSpan" id="kobo.309.3">Do you have an idea of how we could avoid the </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">double revalidation?</span></span></p>
<p><span class="koboSpan" id="kobo.311.1">Consider implementing this yourself to practice working with SSE in Remix! </span><span class="koboSpan" id="kobo.311.2">Maybe you can use a unique connection identifier to avoid the server-sent event revalidation in the browser tab that mutates the data. </span><span class="koboSpan" id="kobo.311.3">You could add the identifier to the server-sent event payload and compare it with a local version stored on the client. </span><span class="koboSpan" id="kobo.311.4">Alternatively, you could use Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">shouldRevalidate</span></strong><span class="koboSpan" id="kobo.313.1"> route module API to avoid Remix’s built-in revalidation after </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">action</span></strong><span class="koboSpan" id="kobo.315.1"> function calls that trigger the server-sent events. </span><span class="koboSpan" id="kobo.315.2">Refer to the Remix documentation for more information about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">shouldRevalidate</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.317.1">function: </span></span><a href="https://remix.run/docs/en/2/route/should-revalidate#shouldrevalidate"><span class="No-Break"><span class="koboSpan" id="kobo.318.1">https://remix.run/docs/en/2/route/should-revalidate#shouldrevalidate</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.319.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.320.1">In this section, you implemented an SSE endpoint in BeeRich to revalidate loader data whenever the user mutates data in an </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">action</span></strong><span class="koboSpan" id="kobo.322.1"> function across different tabs, browsers, </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">and devices.</span></span></p>
<h1 id="_idParaDest-213"><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.324.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.325.1">In this chapter, you learned about real-time technologies and techniques and how to use them </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">in Remix.</span></span></p>
<p><span class="koboSpan" id="kobo.327.1">First, we discussed polling, SSE, and the WebSocket API and compared their advantages and disadvantages. </span><span class="koboSpan" id="kobo.327.2">Polling is the easiest to set up. </span><span class="koboSpan" id="kobo.327.3">A simple polling implementation does not require changes on the server. </span><span class="koboSpan" id="kobo.327.4">SSE provides a one-way communication line using the HTTP protocol, while WebSocket connections use TCP and </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">are bi-directional.</span></span></p>
<p><span class="koboSpan" id="kobo.329.1">Second, you learned about server requirements for SSE and WebSocket. </span><span class="koboSpan" id="kobo.329.2">You now understand that SSE requires support for streaming responses, while WebSocket servers can only run on </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">long-running servers.</span></span></p>
<p><span class="koboSpan" id="kobo.331.1">Finally, we implemented a real-time UI in BeeRich by utilizing SEE. </span><span class="koboSpan" id="kobo.331.2">We implemented a new endpoint and associated React hook using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">EventSource</span></strong><span class="koboSpan" id="kobo.333.1"> API. </span><span class="koboSpan" id="kobo.333.2">Since Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">loader</span></strong><span class="koboSpan" id="kobo.335.1"> functions return HTTP </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">Response</span></strong><span class="koboSpan" id="kobo.337.1"> objects, we can implement the server-sent event endpoint in Remix using a </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">resource route.</span></span></p>
<p><span class="koboSpan" id="kobo.339.1">In the next chapter, we will learn more about session management and discuss advanced session management patterns </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">with Remix.</span></span></p>
<h1 id="_idParaDest-214"><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.341.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.342.1">You can read more about SSE and WebSocket in the MDN </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">Web Docs:</span></span></p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events"><span class="No-Break"><span class="koboSpan" id="kobo.344.1">https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events</span></span></a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Websockets_API"><span class="No-Break"><span class="koboSpan" id="kobo.345.1">https://developer.mozilla.org/en-US/docs/Web/API/Websockets_API</span></span></a></li>
</ul>
<p><span class="koboSpan" id="kobo.346.1">Here is a great talk from Remix Conf 2023 about SSE by Alex </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">Anderson: </span></span><a href="https://www.youtube.com/watch?v=cAYHw_dP-Lc"><span class="No-Break"><span class="koboSpan" id="kobo.348.1">https://www.youtube.com/watch?v=cAYHw_dP-Lc</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.349.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.350.1">Sergio Xalambrí wrote an article on how to set up Remix with socket.io to create a WebSocket </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">connection: </span></span><a href="https://sergiodxa.com/articles/use-remix-with-socket-io"><span class="No-Break"><span class="koboSpan" id="kobo.352.1">https://sergiodxa.com/articles/use-remix-with-socket-io</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.353.1">.</span></span></p>
</div>
</body></html>