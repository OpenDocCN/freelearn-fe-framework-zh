- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Handling Routing with Vue Router
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Vue Router 处理路由
- en: '**Single-page applications** (**SPAs**), such as the one offered by Vue.js,
    provide an architecture built upon a single page. This methodology prevents the
    page from fully reloading and offers an improved user experience.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**单页应用程序**（**SPAs**），例如 Vue.js 提供的，基于单页面的架构。这种方法防止页面完全重新加载，并提供了改进的用户体验。'
- en: As your application grows, you will find the need to create different views
    in your application. Even if the term *SPA* can lead to the understanding that
    your application will be built on a single page, the truth is far from it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的应用程序增长，您将需要在应用程序中创建不同的视图。即使术语 *SPA* 可能会导致您认为您的应用程序将建立在单个页面上，但事实远非如此。
- en: Most frameworks, including Vue.js, offer packages aimed at recreating the routing
    system available in other frameworks such as PHP, .NET, and more. The routing
    functionality offered by SPA frameworks provides the best of both worlds. It offers
    developers a complete routing toolkit, while still providing the same user experience
    expected by SPA frameworks. The router package used in Vue.js is called vue-router.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数框架，包括 Vue.js，都提供旨在在其他框架（如 PHP、.NET 等）中重现路由系统的包。SPA 框架提供的路由功能提供了两者的最佳结合。它为开发者提供了一个完整的路由工具包，同时仍然提供了
    SPA 框架预期的相同用户体验。Vue.js 中使用的路由包称为 vue-router。
- en: In this chapter, you will learn how to use routing in your Vue.js application.
    At the end of the chapter, you will have a good understanding of vue-router and
    its configuration, and how routes are defined and used. You will be able to create
    basic, dynamic, and nested routes and navigate to them using different methodologies.
    Lastly, you will learn how to improve your user experience with the use of `redirect`
    and aliases.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何在您的 Vue.js 应用程序中使用路由。在本章结束时，您将很好地理解 vue-router 及其配置，以及路由是如何定义和使用的。您将能够创建基本、动态和嵌套路由，并使用不同的方法导航到它们。最后，您将学习如何使用
    `redirect` 和别名来提高用户体验。
- en: We are first going to learn about vue-router by covering its configuration.
    We will then learn how to implement our first route and route navigation by creating
    a couple of static pages. Next, we will introduce dynamic routes by defining a
    user profile page. Then, we will add another level of navigation by splitting
    the user view into a user profile and user posts using nested routes. Finally,
    we will complete the chapter by familiarizing ourselves with `redirect` and `alias`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将通过介绍其配置来了解 vue-router。然后，我们将通过创建几个静态页面来学习如何实现我们的第一个路由和路由导航。接下来，我们将通过定义用户个人资料页面来介绍动态路由。然后，我们将通过使用嵌套路由将用户视图拆分为用户个人资料和用户帖子来添加另一个导航级别。最后，我们将通过熟悉
    `redirect` 和 `alias` 来完成本章。
- en: 'This chapter is going to be broken down into the following sections:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将分为以下部分：
- en: Introducing vue-router
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 vue-router
- en: Navigating between routes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在路由间导航
- en: Dynamic route matching
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态路由匹配
- en: Nested routes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套路由
- en: Reusing routes with `alias` and `redirect`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `alias` 和 `redirect` 重复使用路由
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, the branch is called `CH10`. To pull this branch, run the
    following command or use your GUI of choice to support you in this operation:
    `git``switch CH10`.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，该分支被称为 `CH10`。要拉取此分支，请运行以下命令或使用您选择的 GUI 来支持您进行此操作：`git switch CH10`。
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在 [https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners)
    找到。
- en: Introducing vue-router
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 vue-router
- en: vue-router is the official router package built and maintained by the Vue.js
    core team and community members. Just like other packages that we have introduced
    so far in the Companion App, also vue-router was automatically set up for us when
    we initialized our application using Vite.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: vue-router 是由 Vue.js 核心团队和社区成员构建和维护的官方路由包。就像我们在 Companion App 中介绍的其他包一样，当我们使用
    Vite 初始化应用程序时，vue-router 也自动为我们设置好了。
- en: In this section, we will learn about the file structure and configuration required
    for vue-router and introduce some of the syntax used when working with routes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解 vue-router 所需的文件结构和配置，并介绍在处理路由时使用的部分语法。
- en: vue-router offers a standard set of functionalities that are expected from a
    router. So, if you have previously worked with routers in other languages, most
    of what we will cover will sound familiar, but it is still worth a read as the
    syntax may be different.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: vue-router提供了一组标准的、从路由器期望的功能。所以，如果您在其他语言中以前使用过路由器，我们将涵盖的大部分内容听起来可能很熟悉，但阅读它仍然值得，因为语法可能不同。
- en: Learning about vue-router configuration
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解vue-router配置
- en: Let’s first start by learning how to best configure the router in an application.
    In fact, even if vue-router is usually preset by tools such as **createVue** and
    **Vite**, it is important to understand how it is set behind the scenes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先学习如何最好地配置应用程序中的路由。实际上，即使vue-router通常由**createVue**和**Vite**等工具预设，了解它在幕后是如何设置的仍然很重要。
- en: The configuration required for the plugin to work is stored in a file commonly
    named `router.js`. or an `index.js` file within a folder called `router`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 插件工作所需的配置存储在一个通常命名为`router.js`的文件中，或者存储在名为`router`的文件夹中的`index.js`文件中。
- en: In our case, the file is stored within the `router` folder.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，文件存储在`router`文件夹内。
- en: All plugins need to be registered in main.js
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所有插件都需要在`main.js`中注册
- en: All plugins must be registered in `main.js` before they can work. So, if you
    ever want to find the configuration file or information for a plugin that is currently
    loaded in your application, you can open the `main.js` file and search for the
    `app.use(pluginName)` syntax.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所有插件必须在`main.js`中注册后才能工作。因此，如果您想找到当前在您的应用程序中加载的插件的配置文件或信息，您可以打开`main.js`文件并搜索`app.use(pluginName)`语法。
- en: 'Let’s look at the syntax you might find in this `index.js` file:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看您可能会在`index.js`文件中找到的语法：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s go over the important points of the preceding configuration. First, we
    can talk about the `createRouter` method. This method provided by the vue-router
    package creates an instance of the router that can be attached to a Vue application.
    This method expects an object including the router configuration.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下前面配置的重要点。首先，我们可以谈谈`createRouter`方法。这个由vue-router包提供的方法创建了一个可以附加到Vue应用程序的router实例。此方法期望一个包含router配置的对象。
- en: Next, it is time to look at the first entry of the configuration object, `history`.
    The `history` property defines how your application will navigate between the
    different pages. In standard apps, this is usually achieved by changing the website
    URL to the desired page – for example, by appending `/team` to the URL to visit
    the Team page. Let’s look at a couple of different configurations that can be
    used to set our `history` property.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，是时候看看配置对象中的第一个条目，`history`。`history`属性定义了您的应用程序如何在不同的页面之间导航。在标准应用程序中，这通常是通过将网站URL更改为所需的页面来实现的——例如，通过将`/team`附加到URL来访问团队页面。让我们看看可以用来设置`history`属性的一些不同的配置。
- en: Hash mode
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Hash模式
- en: This method is achieved by using `createWebHashHistory`. This method is provided
    by the vue-router package, and it is the easiest one to implement as it will not
    require any server-side configuration. When using hash mode, an actual hash (`#`)
    is going to be added between the base URL and our routes. With this configuration,
    accessing the Team page can be done by visiting `www.mywebsite.com#team`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是通过使用`createWebHashHistory`实现的。这个方法由vue-router包提供，并且它是实现起来最简单的一个，因为它不需要任何服务器端配置。当使用hash模式时，实际的hash（`#`）将被添加到基础URL和我们的路由之间。使用这种配置，访问团队页面可以通过访问`www.mywebsite.com#team`来完成。
- en: This method can impact your SEO negatively, so if your application is accessed
    publicly, you should invest time and set up the next available method, web history
    mode.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可能会对您的SEO产生负面影响，所以如果您的应用程序是公开访问的，您应该投入时间并设置下一个可用的方法，即web历史模式。
- en: HTML5/web history mode
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTML5/web历史模式
- en: HTML5 mode can be configured by using the `createWebHistory` method. With this
    history mode, our website will act as a standard site with its route being served
    directly after the website URL (e.g., `www.mywebsite.com/team`).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5模式可以通过使用`createWebHistory`方法进行配置。使用这种历史模式，我们的网站将表现得像一个标准网站，其路由将直接在网站URL之后提供（例如，`www.mywebsite.com/team`）。
- en: Because SPA websites are built on a single page (hence the name), they can just
    serve the application from one single endpoint (the website base URL). So, deploying
    our site and trying to access the Team page directly would result in a `404` page
    (not found).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SPA网站是建立在单个页面上的（因此得名），它们可以从一个单一的端点（网站基础URL）提供应用程序。因此，部署我们的网站并直接尝试访问团队页面会导致`404`页面（未找到）。
- en: Solving this issue is a trivial task in today’s hosting site, as all that is
    needed is a catch-all rule that ensures site navigation is funneled to the SPA
    entry point. If you wish to use this method, a little googling will help you find
    the instructions you need to properly set this in your hosting provider.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的托管网站上解决此问题是一个简单任务，因为所需的一切只是一个通配符规则，确保网站导航被引导到SPA入口点。如果您想使用这种方法，稍作搜索就能找到您在托管提供商中正确设置所需的说明。
- en: In our case, we are using web history. This is my default history setting, not
    only because it improves SEO but also because it has been the normal way to navigate
    our sites for years and I like to keep things consistent.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们使用Web历史记录。这是我的默认历史设置，不仅因为它提高了SEO，而且因为它已经是我们网站导航的正常方式多年了，我喜欢保持一致性。
- en: 'Finally, it is time to cover the last entry of our configuration: routes.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是时候介绍我们的配置中的最后一个条目：路由。
- en: Defining routes
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义路由
- en: We have reached the most important part of our router configuration, the actual
    routes. The word *route* defines the ability of our application to direct a user
    to a specific page. So, when declaring routes, we define the pages a user can
    visit on our site.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了我们的路由配置中最重要的一部分，即实际的路由。单词 *route* 定义了我们的应用程序将用户引导到特定页面的能力。因此，当声明路由时，我们定义了用户可以在我们的网站上访问的页面。
- en: To declare a route, we require two pieces of information, `path` and `component`,
    but I usually prefer to always include a third one called `name`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个路由，我们需要两个信息，`path` 和 `component`，但我通常更喜欢总是包括第三个称为 `name` 的信息。
- en: The `path` attribute is used to define the URL that needs to be accessed for
    this route to be loaded. So, a path of `/` will be delivered if the user navigates
    to the base of your site, while a path of `/team` would be accessible on `www.mysite.com/team`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`path` 属性用于定义需要访问此路由才能加载的URL。因此，如果用户导航到您网站的基路径，将传递 `/` 路径，而 `/team` 路径将可在 `www.mysite.com/team`
    上访问。'
- en: The `component` attribute is the Vue component expected to be loaded when this
    route is accessed. Lastly, we have `name`. Adding this parameter to all our routes
    is good practice as `name` is used to navigate a route programmatically. We will
    cover this in more detail later as we will learn how to navigate within our application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`component` 属性是当访问此路由时预期要加载的Vue组件。最后，我们有 `name`。将此参数添加到所有我们的路由中是良好的实践，因为 `name`
    用于程序化导航路由。我们将在稍后更详细地介绍这一点，因为我们将会学习如何在我们的应用程序内导航。'
- en: Now that we know all the different aspects of a route, let’s try to decode what
    route was declared in the previously shared code snippet. The snippets show a
    route directing the user to the base path of our site (`path` is `/`), with the
    `name` value of `home`, which will load a `HomeView.vue` component.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了路由的所有不同方面，让我们尝试解码之前共享的代码片段中声明的路由。这些片段显示了一个路由将用户引导到我们网站的基路径（`path` 是
    `/`），`name` 值为 `home`，这将加载一个 `HomeView.vue` 组件。
- en: 'Until now, we have learned how to configure a Vue instance, but there is one
    more step needed before our routes can function properly: adding `RouterView`
    to our application.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何配置Vue实例，但在我们的路由能够正常工作之前，还需要一个额外的步骤：将 `RouterView` 添加到我们的应用程序中。
- en: We have defined which component to load for a given URL, but we have yet to
    tell our Vue application where to load this component.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了给定URL要加载的组件，但我们还没有告诉我们的Vue应用程序在哪里加载此组件。
- en: The way the router works is by replacing the content of our application every
    time a user navigates to a different page. So, in very simple terms, a router
    can be defined as a huge `if/else` statement that renders the component depending
    on the URL.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器的工作方式是在每次用户导航到不同的页面时替换我们应用程序的内容。所以，用非常简单的话说，路由器可以被定义为一个巨大的 `if/else` 语句，根据URL渲染组件。
- en: 'To allow the router to work correctly, we are going to add a component called
    `<RouterView>` to the main entry point of our application, the `App.vue` file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许路由器正确工作，我们将向我们的应用程序的主要入口点，即 `App.vue` 文件，添加一个名为 `<RouterView>` 的组件：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From this stage onward, vue-router is going to take ownership of what is displayed
    on the screen using the route definition we defined in our configuration.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个阶段开始，vue-router 将接管我们配置中定义的路由定义所显示的屏幕内容。
- en: Creating our first view
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的第一个视图
- en: Let’s try to add a new router navigation for a static page called **Privacy**.
    This is just going to include some dummy text for now.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试添加一个新的路由导航，用于一个名为 **隐私** 的静态页面。现在这仅仅包括一些占位文本。
- en: 'To add a new page, we need two steps: a route defined in our `routes` array
    and a component that will be loaded when that route is accessed.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个新页面，我们需要两个步骤：在我们的`routes`数组中定义一个路由，以及当访问该路由时将被加载的组件。
- en: Components that are used as routes are stored in a folder called `views`. If
    we access this folder, we see that we currently have two views set, `Home` and
    `About`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 用作路由的组件存储在一个名为`views`的文件夹中。如果我们访问这个文件夹，我们会看到我们目前有两个视图设置，`Home`和`About`。
- en: '![Figure 10.1: Folder tree showing the content of the views folder](img/B21130_10_01.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1：显示视图文件夹内容的文件夹树](img/B21130_10_01.jpg)'
- en: 'Figure 10.1: Folder tree showing the content of the views folder'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：显示视图文件夹内容的文件夹树
- en: We are going to add a new file to our folder called `PrivacyView.vue`. It is
    common to match the filename with the route’s name. Because this file will be
    static, we will re-use the layout defined in [*Chapter 9*](B21130_09.xhtml#_idTextAnchor120)
    when we learned about slots.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的文件夹中添加一个名为`PrivacyView.vue`的新文件。将文件名与路由的名称匹配是常见的。因为这个文件将是静态的，所以当我们学习插槽时，我们将重用定义在[*第9章*](B21130_09.xhtml#_idTextAnchor120)中的布局。
- en: 'The layout used for the static page defined as `StaticTemplate.vue` accepts
    three different named slots: a heading, a footer, and a default template used
    for its main content. Our `PrivacyView.Vue` file content should be defined like
    this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 用于定义静态页面的布局`StaticTemplate.vue`接受三个不同的命名插槽：一个标题、一个页脚以及用于其主内容的默认模板。我们的`PrivacyView.Vue`文件内容应该定义如下：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You may have noticed that the file content just defines two slots (`heading`
    and `default`) and is missing the footer. This has been done on purpose as the
    footer has a default value that we want to display.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，文件内容仅定义了两个槽位（`heading` 和 `default`）并且缺少页脚。这是故意为之，因为页脚有一个我们想要显示的默认值。
- en: 'Before our new component can be visited and displayed we need to add it to
    our route. Let’s do this by going back to `index.js` within the `router` folder
    and adding the route for our Privacy page within the `routes` array:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新组件可以被访问和显示之前，我们需要将其添加到我们的路由中。让我们通过回到`router`文件夹内的`index.js`并添加我们的隐私页面路由到`routes`数组中来实现这一点：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our new page views are first imported at the top of the page as a normal Vue
    component and then assigned to the new route. Just as we mentioned before, routes
    require three values. First, we set the `path` value as `/privacy`, then we defined
    a `name` value of `privacy` for future programmatic navigation, and lastly, we
    assigned the imported `PrivacyView` component to it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新页面视图首先作为普通Vue组件导入页面的顶部，然后分配给新的路由。正如我们之前提到的，路由需要三个值。首先，我们将`path`值设置为`/privacy`，然后我们定义了一个名为`privacy`的`name`值，用于未来的程序化导航，最后，我们将导入的`PrivacyView`组件分配给它。
- en: 'After these changes, we should be able to see our page by accessing `http://localhost:5173/privacy`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改之后，我们应该可以通过访问`http://localhost:5173/privacy`来看到我们的页面：
- en: '![Figure 10.2: Screenshot of the Privacy page](img/B21130_10_02.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2：隐私页面的截图](img/B21130_10_02.jpg)'
- en: 'Figure 10.2: Screenshot of the Privacy page'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：隐私页面的截图
- en: In this section, we have learned how to configure vue-router, introduced routes
    and defined how they are used by the application to render pages, and finally,
    talked about `<RouterView>` and how vue-router uses it to display the correct
    page to our visitors.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何配置vue-router，介绍了路由以及它们如何被应用程序用于渲染页面，最后讨论了`<RouterView>`以及vue-router如何使用它来向我们的访客显示正确的页面。
- en: In the next section, we are going to learn how to navigate between different
    routes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何在不同的路由之间进行导航。
- en: Navigating between routes
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在路由之间导航
- en: Until now, we have learned how to create our routes and how to navigate through
    them by loading the URL directly in the browser. In this section, we will learn
    how to navigate between different routes directly in the code base.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何创建我们的路由以及如何通过在浏览器中直接加载URL来导航它们。在本节中，我们将学习如何在代码库中直接导航到不同的路由。
- en: It is true that we could define our navigation using a simple `<a>` tag, but
    that will force the app to fully reload on any navigation and so will go against
    the whole architecture of a SPA, which offers a “reload-free” experience.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，我们可以使用简单的`<a>`标签来定义我们的导航，但这将迫使应用程序在每次导航时完全重新加载，这与SPA的整体架构相违背，SPA提供了一种“无重新加载”的体验。
- en: To solve this issue, vue-router offers components and methods that will handle
    navigations without reloading the page.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，vue-router提供了组件和方法来处理导航而不会重新加载页面。
- en: While using vue-router, navigation can be achieved in two different ways. One
    uses a component called `<router-link>` while the other is triggered programmatically
    using `router.push()`. Let’s see both methods in action and learn when to use
    them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用vue-router时，可以通过两种不同的方式进行导航。一种使用名为`<router-link>`的组件，另一种则是通过`router.push()`程序化触发。让我们看看这两种方法的具体操作，并了解何时使用它们。
- en: Using the <router-link> component
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`<router-link>`组件
- en: Using the `<router-link>` component to navigate within your application is a
    simple task, as it uses the same syntax offered by the native HTML `<a>` element.
    Behind the scenes, `<router-link>` is just an anchor tag with added functionality
    that prevents the app from fully reloading while navigating.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`<router-link>`组件在您的应用内进行导航是一个简单的任务，因为它使用了与原生HTML `<a>`元素相同的语法。在幕后，`<router-link>`只是一个带有附加功能的锚点标签，它阻止应用在导航时完全重新加载。
- en: Our Companion App has three different pages, but there is nowhere to access
    them unless we enter the URL directly. Let’s go and fix this now by adding two
    links in our sidebar, one for each static page we have created so far.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的伴随应用有三个不同的页面，但除非直接输入URL，否则无法访问它们。现在让我们通过在侧边栏中添加两个链接来修复这个问题，每个链接对应我们迄今为止创建的每个静态页面。
- en: As a reminder, the main page is `HomePage.vue`, but the actual sidebar is just
    a child component of this page and can be found in the `organisms` folder under
    the name `SideBar.vue`. Now that we have located the file, it is time to add our
    router links.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，主页是`HomePage.vue`，但实际的侧边栏只是该页面的一个子组件，可以在`organisms`文件夹下以`SideBar.vue`的名称找到。现在我们已经找到了文件，是时候添加我们的路由链接了。
- en: 'First, we import the component from vue-router in the `script` section of the
    component:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在组件的`script`部分导入vue-router组件：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we add the links in our sidebar, directly after the `Update` `Time` button:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在侧边栏中添加链接，直接在`Update Time`按钮之后：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `router-link` component accepts a property called `to`. This property can
    accept the URL that the browser needs to navigate to or a `route` object, which
    we will cover later in the chapter.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`router-link`组件接受一个名为`to`的属性。这个属性可以接受浏览器需要导航到的URL或`route`对象，我们将在本章后面介绍。'
- en: In our example, we have specified the value of the `to` property to be equal
    to `privacy` for the link directing to the `about` for the page navigating to
    the **About** page.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们已将`to`属性的值指定为`privacy`，用于指向`about`页面，以便导航到**关于**页面。
- en: After these two changes, the application will have two new links in the sidebar.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两项更改之后，应用侧边栏将新增两个链接。
- en: '![Figure 10.3: Companion app sidebar with the router links](img/B21130_10_03.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3：带有路由链接的伴随应用侧边栏](img/B21130_10_03.jpg)'
- en: 'Figure 10.3: Companion app sidebar with the router links'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：带有路由链接的伴随应用侧边栏
- en: Because router links are just simple `<a>` elements, they inherit the style
    of the anchor that was defined by the project template.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因为路由链接只是简单的`<a>`元素，它们继承了项目模板中定义的锚点样式。
- en: Programmatic navigation
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序化导航
- en: For most cases, navigating using the router link component is all you need,
    but there are some situations in which you may find it beneficial to navigate
    through the app directly in the code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数情况，使用路由链接组件进行导航就足够了，但在某些情况下，您可能会发现直接在代码中通过应用进行导航更有益。
- en: There is no real difference in navigating using the `router-link` component
    or programmatically, and both methods are offered to ensure that your code can
    be clean and easy to read.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`router-link`组件进行导航或程序化导航之间没有真正的区别，这两种方法都提供以确保代码整洁且易于阅读。
- en: Programmatic navigation is useful when attached to a piece of logic. Being able
    to trigger the navigation manually helps you take control of the flow of the data,
    ensuring that your code is well written and that the user receives the best experience.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 程序化导航在逻辑部分使用时很有用。能够手动触发导航可以帮助您控制数据流，确保代码编写良好，用户获得最佳体验。
- en: To be able to navigate to a different page, we can use a method offered by the
    `router` object called `push`. This method, just like `<router-link>`, can accept
    the URL or a `route` object.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要导航到不同的页面，我们可以使用`router`对象提供的一个名为`push`的方法。这个方法与`<router-link>`一样，可以接受URL或`route`对象。
- en: We are going to add another link, but this time, a simple anchor element, and
    trigger the navigation using the `onclick` event.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加另一个链接，但这次是一个简单的锚点元素，并使用`onclick`事件触发导航。
- en: 'First, we are going to add an import from the vue-router package called `useRouter`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从 vue-router 包中添加一个名为 `useRouter` 的导入：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we use this method to access the `router` instance. This just needs to
    be done once per file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用此方法来访问 `router` 实例。这只需要在每个文件中做一次：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we are going to create a method that will handle the `click` event of
    our anchor:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个方法来处理我们的锚点的 `click` 事件：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Triggering navigation programmatically allows us to trigger side effects that
    would not be possible if using a `<router-link>` component, – for example, conditionally
    navigate a user to different pages depending on a value returned from the server.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编程方式触发导航允许我们触发使用 `<router-link>` 组件时不可能出现的副作用，例如，根据从服务器返回的值有条件地导航用户到不同的页面。
- en: 'Lastly, we are going to create a new anchor in the HTML section of our component.
    This element is going to use the `navigateToPrivacy` method:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在组件的 HTML 部分创建一个新的锚点。这个元素将使用 `navigateToPrivacy` 方法：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have now completed the first part of this chapter. At this stage, you have
    learned the basics of vue-router and gained an understanding of how to define
    routes, how they work, and how to navigate between the different pages.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了本章的第一部分。在这个阶段，你已经学习了vue-router的基础知识，并了解了如何定义路由、它们的工作原理以及如何在不同的页面之间导航。
- en: In the next sections, we will learn about more advanced topics such as nested
    routes and dynamic route matching.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习更高级的主题，例如嵌套路由和动态路由匹配。
- en: Dynamic route matching
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态路由匹配
- en: If you are tasked to build a simple portfolio site, basic routes are going to
    be just fine. However, as you start to work on more complex sites such as blogs,
    you will need more complex routing. In this section, we are going to learn about
    dynamic route matching. Dynamic route matching is used to define routes that require
    one or more parameters to be dynamic.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你被分配去构建一个简单的个人作品集网站，基本的路由就足够了。然而，当你开始处理更复杂的网站，例如博客时，你需要更复杂的路由。在本节中，我们将学习动态路由匹配。动态路由匹配用于定义需要一个或多个参数来动态化的路由。
- en: All the routes that we have defined until now were static and did not change.
    So, we had the `/about` endpoint that would render the `/` path that would welcome
    the home page of our site. What would happen if we wanted to develop a blog post
    with our current knowledge? After our first blog post, we would write a route,
    `/blog/1`, then after the second, we would have to create another route, `/blog/2`,
    and so on.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止定义的所有路由都是静态的，没有变化。因此，我们有一个 `/about` 端点，它会渲染 `/` 路径，欢迎我们的网站主页。如果我们想用当前的知识开发一篇博客文章会发生什么？在我们的第一篇博客文章之后，我们会写一个路由
    `/blog/1`，然后第二篇之后，我们必须创建另一个路由 `/blog/2`，依此类推。
- en: Defining routes statically like this is not an ideal solution, and this is where
    dynamic route matching comes into place. Dynamic route matching allows us to create
    a pattern, for example, `blog/:blogId`, and then let the application render a
    specific page that uses the defined argument to render another specific page.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式静态定义路由不是一个理想的选择，这正是动态路由匹配发挥作用的地方。动态路由匹配允许我们创建一个模式，例如，`blog/:blogId`，然后让应用程序渲染一个特定的页面，该页面使用定义的参数来渲染另一个特定的页面。
- en: To learn about this great feature, we are going to enhance our Companion App
    by adding a new feature that will allow us to open a specific user profile.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这个伟大的功能，我们将通过添加一个新功能来增强我们的伴侣应用程序，该功能将允许我们打开特定的用户个人资料。
- en: 'The requirements for this task are the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务的要求如下：
- en: We are going to add the ability for the user to open a user profile page from
    the main view of the application
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将添加用户从应用程序的主视图打开用户个人资料页面的能力
- en: We are going to create a new route that will display a user
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将创建一个新的路由，用于显示用户信息
- en: We are going to create a new component that will display the user with all its
    information
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将创建一个新的组件，用于显示包含所有信息的用户
- en: We are going to develop this backward, starting by creating the user-specific
    page.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个任务的反向开始开发，首先创建用户特定的页面。
- en: Creating a user profile page
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户个人资料页面
- en: Our first task requires us to create a new page that will later be used by our
    route as the content of our user page. Just like all other pages, this will also
    live in a folder called `views` and will be called `UserView.vue`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一项任务需要我们创建一个新页面，该页面将作为我们路由的用户页面内容。就像所有其他页面一样，它也将位于一个名为 `views` 的文件夹中，并被称为
    `UserView.vue`。
- en: In this component, we are going to first load a specific user profile and then
    display its information on the screen. To ease development, we are going to hardcode
    `userId` so that we can see the correct information on screen for now, and then
    remove this later after our dynamic route is fully set.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个组件中，我们首先将加载一个特定的用户配置文件，然后在屏幕上显示其信息。为了简化开发，我们将硬编码`userId`，这样我们目前可以在屏幕上看到正确的信息，之后在完全设置动态路由后将其移除。
- en: 'Just like a simple component, we will need to define three different parts:
    the HTML, the logic required to fetch the correct information, and the styles.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 就像简单的组件一样，我们需要定义三个不同的部分：HTML、获取正确信息的逻辑以及样式。
- en: To help you prepare for the real world, you could go a step further than this
    book and learn what information we would need from the API to develop the page.
    When developing from an external source, such as an API or a Content Management
    System (`user` object, but what will that include? Would it have a name? Would
    it have a date of birth, and if so, what would the format be?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您为现实世界做好准备，您可以比这本书更进一步，了解我们从API需要哪些信息来开发页面。当从外部来源（如API或内容管理系统）开发时，`user`对象（但那将包括什么？会有名字吗？会有出生日期，如果是的话，格式会是什么？）
- en: 'All these questions are usually answered by the `user` object, which is usually
    available directly from API and CMS documentation. In our case, since we are using
    [dummyapi.com](http://dummyapi.com), the information about the API models can
    be found here: [https://dummyapi.io/docs/models](https://dummyapi.io/docs/models).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题通常都由`user`对象回答，该对象通常可以直接从API和CMS文档中获得。在我们的案例中，由于我们使用[dummyapi.com](http://dummyapi.com)，有关API模型的信息可以在这里找到：[https://dummyapi.io/docs/models](https://dummyapi.io/docs/models)。
- en: 'Within the model, we can find our specific one, called **User Full**:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型中，我们可以找到我们的特定模型，称为**User Full**：
- en: '![Figure 10.4: Model information for User Full](img/B21130_10_04.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4：用户全信息的模式信息](img/B21130_10_04.jpg)'
- en: 'Figure 10.4: Model information for User Full'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：用户全信息的模式信息
- en: Model information such as that shown in *Figure 10**.4* can help us develop
    a well-structured code base and make the correct choices ahead of time.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图10**.4*所示的模式信息可以帮助我们开发一个结构良好的代码库，并提前做出正确的选择。
- en: 'Now that we have a good understanding of the object that the API will return,
    it is time to build our component. Let’s start by defining the HTML section:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经很好地理解了API将返回的对象，是时候构建我们的组件了。让我们从定义HTML部分开始：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The HTML markup makes use of the `v-for` directive to loop through a preselected
    list of properties that we want to display from the user object received from
    the API. We are then using `v-if` to add some further validation to ensure that
    our application will not break in case the API changes its returned object. The
    HTML will generate a simple design that will render a pair of labels/input for
    each property, but further development could be made to improve the UI.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: HTML标记使用了`v-for`指令来遍历从API接收到的用户对象中预选的属性列表，我们随后使用`v-if`添加一些额外的验证，以确保我们的应用程序在API更改其返回对象的情况下不会崩溃。HTML将生成一个简单的布局，为每个属性渲染一对标签/输入，但可以进行进一步的开发以改进UI。
- en: 'Next, we are going to create the logic required to fetch and assign our user
    information. As previously mentioned, we are going to hardcode an ID of `657a3106698992f50c0a5885`,
    which will later be changed to be dynamic:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建获取和分配我们的用户信息的逻辑。如前所述，我们将硬编码一个ID为`657a3106698992f50c0a5885`，这将在以后被改为动态：
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The API logic is very similar to other requests that we have already made in
    this book. The only differences are as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: API逻辑与其他我们已经在这本书中做出的请求非常相似。唯一的区别如下：
- en: The `url` variable is not a static value but dynamic as it makes use of `userId`.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`变量不是一个静态值，而是动态的，因为它使用了`userId`。'
- en: Since we are switching the full value of `user`, we had to use `Object.assign`.
    This is required when changing the entire value of a `reactive` property.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们需要切换`user`的全值，我们必须使用`Object.assign`。在更改`reactive`属性的整个值时，这是必需的。
- en: The value of `valuesToDisplay` has been set to be a simple array and it is not
    using either `ref` or `reactive`. This has been done on purpose as this array
    is not expected to be modified and it is therefore not required to be reactive.
    At the start of your Vue.js development, it is probably best to always define
    a variable as `ref`/`reactive` as something that you expect to be static could
    easily turn into dynamic.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`valuesToDisplay`的值已被设置为简单的数组，并且没有使用`ref`或`reactive`。这是故意为之，因为这个数组预计不会被修改，因此不需要是响应式的。在你开始Vue.js开发时，最好始终将变量定义为`ref`/`reactive`，因为静态的预期可能会很容易变成动态的。'
- en: The user profile component is now complete, but it is still not accessible from
    the UI as there is no component or view that loads it. We can fix this in the
    next section where we will introduce dynamic routes.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 用户资料组件现在已经完成，但它仍然无法从UI中访问，因为没有组件或视图来加载它。我们将在下一节中修复这个问题，我们将介绍动态路由。
- en: Creating a user profile route
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户资料路由
- en: 'The creation of a dynamic route follows the same flow as a normal route. All
    routes are defined by adding an entry into the `route` array within the route
    configuration file in `router/index.js`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 动态路由的创建遵循与正常路由相同的流程。所有路由都是通过在`router/index.js`中的路由配置文件中添加到`route`数组中定义的：
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Just like before, we added three different properties to our `route` object:
    `name` (which will provide us with a friendly name to associate with the route),
    `component` (which will show us which component to load – in our case, our newly
    created `UserView` component), and finally, `path`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们向我们的`route`对象添加了三个不同的属性：`name`（这将为我们提供一个与路由关联的友好名称），`component`（这将显示要加载哪个组件——在我们的例子中，是我们新创建的`UserView`组件），最后是`path`。
- en: You may have noticed that the `path` value has a different syntax compared to
    the previous routes and this is what makes this path a dynamic route. In fact,
    in previous cases, the URL created by the route was unique and static, while in
    this case, we have added a dynamic part to the URL called `:`) preceding the word
    `userId`. So, this path does not translate into `website.com/user/:userId`, but
    it defines a URL that expects a value to replace `:userId`. In our example, the
    path would probably look like `website.com/user/1234` or `website.com/user/my-user-id`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，与之前的路由相比，`path`值有不同的语法，这就是使这条路径成为动态路由的原因。实际上，在之前的例子中，由路由创建的URL是唯一的和静态的，而在这个例子中，我们在URL中添加了一个名为`:`的动态部分，位于`userId`单词之前。因此，这个路径不会翻译成`website.com/user/:userId`，而是定义了一个期望用值替换`:userId`的URL。在我们的例子中，路径可能看起来像`website.com/user/1234`或`website.com/user/my-user-id`。
- en: As we mentioned before, the value that replaced the parameter is then going
    to be available within the Vue component and can be used to render a unique page.
    In our case, the ID provided will be used to load the information of a specific
    user, so accessing URLs with different IDs will render pages with different user
    information.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，替换参数的值将在Vue组件内部可用，并可用于渲染唯一的页面。在我们的例子中，提供的ID将用于加载特定用户的信息，因此访问不同ID的URL将渲染不同的用户信息页面。
- en: You can have multiple parameters in a route
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在一个路由中拥有多个参数
- en: Did you know you can have multiple dynamic parameters in a single route? Each
    is going to be defined using the same syntax. For example, you could have a URL
    defined as `/account/:accountId/user/:userId`. The component that will load this
    route will have access to two dynamic parameters, one containing the account ID
    and the other the user ID.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道你可以在单个路由中拥有多个动态参数吗？每个参数都将使用相同的语法定义。例如，你可以定义一个URL为`/account/:accountId/user/:userId`。将加载此路由的组件将能够访问两个动态参数，一个包含账户ID，另一个包含用户ID。
- en: Adding navigation using the route name
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用路由名称添加导航
- en: Now that the user route is defined, it is time to make some changes to our design
    to ensure that the users can navigate to it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户路由已经定义，是时候对我们的设计做一些更改，以确保用户可以导航到它。
- en: Even if we could easily achieve this task by using the navigation we learned
    in the previous section, we are going to take this opportunity to introduce a
    new syntax that navigates using the route name.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们可以通过使用之前章节中学到的导航轻松完成这个任务，我们还是要抓住这个机会来介绍一种新的语法，即使用路由名称进行导航。
- en: When defining a new route, we provided both a `path` and `name` value for each
    route item. Navigating using a path is simple for a basic URL, but as things get
    complicated, it may be cleaner to use the route name to define the navigation
    code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义新路由时，我们为每个路由项提供了`path`和`name`值。使用路径导航对基本URL来说很简单，但随着事情变得复杂，可能更干净的做法是使用路由名称来定义导航代码。
- en: Providing a name for every route is a best practice highly adopted in routing
    systems, as it allows for more readable and maintainable code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在路由系统中为每个路由提供名称是一种高度采用的最佳实践，因为它允许代码更易于阅读和维护。
- en: 'Let’s open `SocialPost.vue` and add the navigation logic to the user avatar.
    To accomplish this task, we are first going to add a `click` event to the `<``img>`
    element:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`SocialPost.vue`并添加导航逻辑到用户头像。为了完成这个任务，我们首先将向`<img>`元素添加一个`click`事件：
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We attached a method called `navigateToUser` to the `click` event. This method
    does not have any argument as we will be able to access everything we need directly
    from the `component` scope.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将名为`navigateToUser`的方法附加到`click`事件。这个方法没有参数，因为我们能够直接从`component`作用域访问所需的一切。
- en: 'Next, we are going to create the `navigateToUser` method in the `<script>`
    block of our component:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在组件的`<script>`块中创建`navigateToUser`方法：
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To add our programmatic navigation, we first imported the `useRoute` method,
    then we initiated the route with `const router = useRouter();`, and finally, we
    defined our method.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加我们的程序化导航，我们首先导入了`useRoute`方法，然后使用`const router = useRouter();`初始化路由，最后定义了我们的方法。
- en: Navigating using the name utilizes the same method used with the path navigation,
    `router.push`. The difference lies in the value passed to it. While, in previous
    examples, we just passed a single string, we are now passing an object.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名称进行导航使用与路径导航相同的`router.push`方法。区别在于传递给它的值。在之前的例子中，我们只是传递了一个单个字符串，而现在我们传递了一个对象。
- en: 'This object includes the route name and a list of parameters, which, in our
    case, is equivalent to `userId`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象包括路由名称和参数列表，在我们的案例中相当于`userId`：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Both the name and the parameters need to match the information defined in the
    `route` array. This information is case-sensitive, so take extra care when applying
    it to your navigation object.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 名称和参数都需要与`route`数组中定义的信息相匹配。这个信息是区分大小写的，所以在将其应用于导航对象时要格外小心。
- en: Running the application and clicking on the user avatars will redirect to a
    URL such as `http://localhost:5173/user/60d21b4667d0d8992e610c85`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并点击用户头像将重定向到类似`http://localhost:5173/user/60d21b4667d0d8992e610c85`的URL。
- en: Before we can celebrate our work as completed, we need to do one more step,
    which will require us to read the value from the route and use it to load the
    correct user. The ID used to load the user from the API has been hardcoded, and
    clicking on different avatars will result in the same user being displayed.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们庆祝工作完成之前，我们需要做一步，这将需要我们读取路由的值并使用它来加载正确的用户。用于从API加载用户的ID已经硬编码，点击不同的头像将导致显示相同的用户。
- en: Reading route parameters in a route component
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在路由组件中读取路由参数
- en: When a task requires you to create a dynamic route, chances are that you will
    need one or multiple dynamic parameters to render the page correctly.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个任务需要你创建一个动态路由时，很可能会需要一个或多个动态参数来正确渲染页面。
- en: If you are creating a blog page, the dynamic parameters will be the blog ID;
    if you are loading a book library, the parameters could be the category or the
    author to filter by. No matter the reason, using a dynamic URL will require you
    to read and use that value within your component.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在创建一个博客页面，动态参数将是博客ID；如果你正在加载一个图书库，参数可能是用于过滤的分类或作者。无论原因如何，使用动态URL将需要你在组件中读取和使用该值。
- en: 'Reading route parameters can be achieved using the `params` object available
    within the `route` package. Let’s go back to `UserView.vue` and modify the code
    to load `userId` dynamically from the route:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`route`包中可用的`params`对象来实现读取路由参数。让我们回到`UserView.vue`并修改代码以从路由中动态加载`userId`：
- en: '[PRE16]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To load our parameters from the route, we made three changes to our view. First,
    we imported `useRoute` from the vue-router package. Then, we created an instance
    of the route using `const route = useRoute()`, and finally, we removed the hardcoded
    `userId` and replaced it with the route parameters using `route.params.userId`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从路由中加载我们的参数，我们对视图进行了三项更改。首先，我们从vue-router包中导入了`useRoute`。然后，我们使用`const route
    = useRoute()`创建了一个路由实例，最后，我们移除了硬编码的`userId`，并用路由参数替换了它，即使用`route.params.userId`。
- en: UseRouter versus UseRoute
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`UseRouter`与`UseRoute`
- en: You may have noticed that, in previous components, we used `useRouter`, while
    in the current one, we used `useRoute`. These names are very similar, and their
    differences can easily be missed. `useRouter` is used when we need to have access
    to the router object – for example, to add routes, push navigation, and trigger
    before and after route actions – while `useRoute` is used to gain information
    on the current route, such as the parameters, path, or URL query information.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在之前的组件中，我们使用了`useRouter`，而在当前组件中，我们使用了`useRoute`。这两个名字非常相似，它们之间的差异很容易被忽略。`useRouter`用于我们需要访问路由对象时——例如，添加路由、推送导航和触发路由的前后操作——而`useRoute`用于获取当前路由的信息，如参数、路径或URL查询信息。
- en: At this stage, the dynamic route will be fully functional, and clicking a user
    avatar will load information for that specific user.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，动态路由将完全可用，点击用户头像将加载该特定用户的信息。
- en: '![Figure 10.5: User view page displaying user information](img/B21130_10_05.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5：显示用户信息的用户视图页面](img/B21130_10_05.jpg)'
- en: 'Figure 10.5: User view page displaying user information'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：显示用户信息的用户视图页面
- en: In this section, we have learned about all the different aspects of dynamic
    routes. We have learned why they are needed and the problem that they try to solve,
    and we introduced their syntax by adding a dynamic route for the users within
    our `route` array. While doing so, we took the opportunity to learn about programmatic
    navigation using the `name` and `params` values of a route, and finally, we learned
    how to access route information, such as `params`, using the route object offered
    by the vue-router package to make our user view dynamic.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了动态路由的所有不同方面。我们了解了为什么需要它们以及它们试图解决的问题，并且通过在我们的`route`数组中添加一个动态路由来介绍它们的语法。在此过程中，我们利用机会学习了如何使用路由的`name`和`params`值进行程序化导航，并最终学习了如何使用vue-router包提供的路由对象来访问路由信息，如`params`，从而使我们的用户视图动态化。
- en: While completing the section, we have also gone over previously learned topics
    such as components, directives, events, and so much more.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本节的同时，我们还回顾了之前学习过的主题，如组件、指令、事件等等。
- en: In the next section, we will go one step deeper and learn about nested routes.
    This will follow a similar flow to the current section and hopefully feel familiar
    to you.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将进一步学习嵌套路由。这将遵循与本节类似的流程，并希望对你来说感觉熟悉。
- en: Learning about nested routes
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习嵌套路由
- en: SPAs are very powerful but the addition of a well-structured router, such as
    vue-router, can help take SPAs to another level. The strength of a SPA relies
    on its ability to swap components on the fly without the need to refresh the page,
    but what if I told you that vue-router can go even deeper than a page layout?
    This is where nested routes come in handy.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用（SPAs）非常强大，但添加一个结构良好的路由器，如vue-router，可以帮助将SPAs提升到另一个层次。SPA的强大之处在于其能够在不刷新页面的情况下动态交换组件的能力，但如果你告诉我vue-router甚至可以比页面布局更深层次，你会怎么想？这就是嵌套路由发挥作用的地方。
- en: Nested routes provide you with the ability to define routes within routes, multiple
    levels deep, to create a very complex layout. The concept of nested routes may
    sound complicated, but their use makes the application easier to develop and they
    are recommended for most applications.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套路由允许你在路由中定义路由，可以有多层深度，以创建一个非常复杂的布局。嵌套路由的概念可能听起来很复杂，但它们的使用使得应用程序更容易开发，并且对于大多数应用程序来说都是推荐的。
- en: When we created the main routes, we said that the page would be swapped entirely
    when on navigation; with nested routes, the concept is the same, but instead of
    swapping the full page, we just swap an internal part of the page.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建主路由时，我们说当进行导航时页面将完全交换；对于嵌套路由，概念相同，但不是交换整个页面，而是只交换页面的一部分内部内容。
- en: '![Figure 10.6: Example of nested routes](img/B21130_10_06.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6：嵌套路由示例](img/B21130_10_06.jpg)'
- en: 'Figure 10.6: Example of nested routes'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：嵌套路由示例
- en: To better understand how nested routes work, let’s discuss the little example
    shown in *Figure 10**.6*. Imagine you have created a dashboard. While developing
    different parts of the dashboard, such as a `settings` view and an `analytics`
    view, you realize that there is a part of the layout that is shared. This may
    be the navbar, the sidebar, and even some features such as *print screen* or chat.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解嵌套路由的工作原理，让我们来讨论一下*图10**.6*中展示的小例子。想象一下，你已经创建了一个仪表板。在开发仪表板的不同部分，例如`settings`视图和`analytics`视图时，你意识到布局中有一部分是共享的。这可能包括导航栏、侧边栏，甚至一些功能，如*打印屏幕*或聊天。
- en: To avoid duplicating these functionalities, we can use nested routes. In our
    example, we would have a parent route called `dashboard`, which will have a set
    of children – in our example, these will be a `settings` nested route and an `analytics`
    nested route.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免重复这些功能，我们可以使用嵌套路由。在我们的例子中，我们将有一个父路由称为`dashboard`，它将有一组子路由——在我们的例子中，这些将是一个`settings`嵌套路由和一个`analytics`嵌套路由。
- en: The main `dashboard` route is going to include all the reusable components we
    mentioned previously, plus the addition of a `<RouterView>` component. This component,
    just as we did in the `app.vue` file at the start of this chapter, will be used
    by the router to render the appropriate route.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的`dashboard`路由将包括我们之前提到的所有可复用组件，以及新增的`<RouterView>`组件。这个组件，就像我们在本章开头`app.vue`文件中所做的那样，将被路由器用来渲染适当的路由。
- en: After this theoretical introduction of nested routes, it is time to apply this
    knowledge to our Companion App and learn how to use this new feature of vue-router.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在对嵌套路由的理论介绍之后，现在是时候将这个知识应用到我们的Companion App中，并学习如何使用vue-router的这个新特性了。
- en: Applying nested routes to the user
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将嵌套路由应用于用户
- en: In this section, we are going back to the user page to enable nested routes
    by adding the ability to toggle between the user profile and the user posts view.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回到用户页面，通过添加在用户个人资料和用户帖子视图之间切换的能力来启用嵌套路由。
- en: The example we are going to develop is a very good use case and something that
    you may encounter in real-life development.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要开发的例子是一个非常合适的用例，你可能在现实生活中的开发中会遇到。
- en: The idea of nested routes is that the views have something in common. This may
    either be just the layout or some specific route parameters. A very common example
    of nested routes is an application that has tabs or offers a multi-step form.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套路由的想法是视图有共同之处。这可能是仅仅是布局，或者是某些特定的路由参数。一个非常常见的嵌套路由例子是具有标签或提供多步表单的应用程序。
- en: Completing this task takes a couple of steps. First, we will create a file that
    is going to load a list of posts for the user. Next, we will rename the `userView`
    file to align with the new route, and finally, we will modify the `route` array
    to define the new nested view.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个任务需要几个步骤。首先，我们将创建一个文件，用于加载用户的帖子列表。接下来，我们将重命名`userView`文件以符合新的路由，最后，我们将修改`route`数组以定义新的嵌套视图。
- en: For the first step, I am going to provide you with just some guidance on how
    to complete the task, because I want to give you a chance to try and figure it
    out by yourself. If you get stuck, you can check the `CH10-end` branch, which
    includes the completed file.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一步，我将只提供一些完成任务的建议，因为我希望给你一个机会自己尝试并找出答案。如果你卡住了，可以查看`CH10-end`分支，其中包含完成的文件。
- en: The requirements are to create a file that will load the user posts. This file
    is going to be called `userPostsView.vue` and will be located within the `views`
    folder.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 需求是创建一个文件，该文件将加载用户帖子。这个文件将被命名为`userPostsView.vue`，并将位于`views`文件夹中。
- en: The logic of this file is going to be very similar to the `SocialPost.vue` file.
    In fact, the responses returned by both endpoints are the same, so this allows
    us to reuse most of the logic and the UI. For the scope of this book, we can copy
    the content of the `SocialPost.vue` file into our newly created file, but in a
    real example, we would have refactored the component so that we could have reused
    it.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件的逻辑将非常类似于`SocialPost.vue`文件。事实上，两个端点返回的响应是相同的，这使我们能够重用大部分逻辑和UI。对于本书的范围，我们可以将`SocialPost.vue`文件的内容复制到我们新创建的文件中，但在实际例子中，我们会重构组件以便重用。
- en: The only modification the file needs is to load `userId` from the `route` object,
    just like we did in `userView.vue`, and then change the URL used to load the information
    to be `{baseUrl}/user/${userId}/post?limit=10`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 文件需要的唯一修改是从`route`对象中加载`userId`，就像我们在`userView.vue`中所做的那样，然后更改用于加载信息的URL为`{baseUrl}/user/${userId}/post?limit=10`。
- en: Testing and developing a new component
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 测试和开发新组件
- en: You may be wondering, “*How can you develop a component if you are not able
    to test it in the browser?*”. It is common practice when developing new components
    to create dummy routes that can be used to test new components. In this case,
    our route would need to have access to the user ID from the path, so a simple
    way to test it out is to swap it in the `route` array so that the new component
    is returned when accessing the existing `user` endpoint.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，“*如果你无法在浏览器中测试组件，你如何开发组件呢？*”。在开发新组件时，创建用于测试新组件的虚拟路由是一种常见的做法。在这种情况下，我们的路由需要能够从路径中访问用户
    ID，因此一个简单的方法是在 `route` 数组中替换它，以便在访问现有的 `user` 端点时返回新的组件。
- en: Next, we are going to rename the `userView.vue` file to align with the route
    changes that we are going to make. The new name is going to be `userProfileView.vue`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把 `userView.vue` 文件重命名为与我们将要进行的路由更改相匹配。新的名称将是 `userProfileView.vue`。
- en: 'Finally, we are going to learn the syntax required to create a nested route.
    So, let’s open the `index.js` file within the `router` folder and see the changes
    required to split the `user` endpoint:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将学习创建嵌套路由所需的语法。因此，让我们打开 `router` 文件夹内的 `index.js` 文件，看看分割 `user` 端点所需进行的更改：
- en: '[PRE17]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The syntax required for nested routes is quite intuitive and it uses the knowledge
    that we gained in the previous section.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套路由所需的语法非常直观，它使用了我们在上一节中获得的知识。
- en: Nested routes are defined within our existing `user` route and denoted by the
    `children` property. This property accepts an array of routes that is defined
    with the same structure that we used before with `name`, `path`, and `component`.
    The only thing that you need to consider here is that when defining nested routes,
    we are not at the root of the project anymore, so the value assigned to `path`
    is added to the existing one. So, in this case, the full path of the `userProfile`
    route will be `mysite.com/user/:userId/profile`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套路由是在我们现有的 `user` 路由内部定义的，并通过 `children` 属性来标识。这个属性接受一个数组形式的路由，其结构与我们之前使用的
    `name`、`path` 和 `component` 相同。在这里你需要考虑的唯一一点是，当我们定义嵌套路由时，我们不再处于项目的根目录，因此分配给 `path`
    的值会被添加到现有的路径上。所以，在这种情况下，`userProfile` 路由的完整路径将是 `mysite.com/user/:userId/profile`。
- en: The user profile and the user posts views are ready to be visited by navigating
    to `http://localhost:5173/user/:userId/profile` and `http://localhost:5173/user/:userId/posts`,
    respectively (where `userId` is replaced with an actual user ID).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 用户资料和用户帖子视图已经准备好通过导航到 `http://localhost:5173/user/:userId/profile` 和 `http://localhost:5173/user/:userId/posts`（其中
    `userId` 被替换为实际的用户 ID）来访问。
- en: A nested path does not mean a nested layout
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套路由并不意味着嵌套布局
- en: You may have noticed that, with the example in *Figure 10**.6*, we mentioned
    that nested routes can share a layout and be used to update just part of the page
    such as an inner tab, but in our case, this has not been the case as we are using
    our nested routes to update the page fully. What we did is not uncommon. In fact,
    the use of nested routes is not just achieved to share a layout but also to share
    specific data. In our case, the use of nested routes was used to allow both routes
    to share the `path` parameters named `userId`. If you want to practice further,
    you could create a component for the user path and use it as a layout for the
    user profile and posts route. Just remember to add a `<RouterView>` component
    in your HTML to define where vue-router should append the routes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在 *图10.6* 的例子中，我们提到嵌套路由可以共享布局，并用于更新页面的一部分，例如内部标签页，但在这个例子中，情况并非如此，因为我们使用嵌套路由来完全更新页面。我们所做的是不常见的。事实上，嵌套路由的使用不仅仅是为了共享布局，也是为了共享特定的数据。在我们的例子中，嵌套路由的使用是为了允许两个路由共享名为
    `userId` 的 `path` 参数。如果你想进一步练习，你可以创建一个用于用户路径的组件，并将其用作用户资料和帖子路由的布局。只需记住，在你的 HTML
    中添加一个 `<RouterView>` 组件来定义 vue-router 应该附加路由的位置。
- en: In this section, we learned what nested routes are. We then updated our Companion
    app to use a nested route to load two different user views. We also created a
    new view to display user posts. Next, we learned and applied the syntax required
    to implement nested routes. The final product is the ability for us to navigate
    to two different pages, one that displays the user profile information and one
    that displays the user posts.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了嵌套路由的概念。然后，我们将我们的伴侣应用更新，以使用嵌套路由来加载两个不同的用户视图。我们还创建了一个新的视图来显示用户帖子。接下来，我们学习了并应用了实现嵌套路由所需的语法。最终产品是我们能够导航到两个不同的页面，一个显示用户个人资料信息，另一个显示用户帖子。
- en: You may have noticed that we have moved the `user` route to one of its children.
    Because of this, if we access the `user` route (e.g., `http://localhost:5173/user/60d21b4667d0d8992e610c85`),
    we will be greeted with an empty page. This is not a bug but is expected because
    we have not actually declared any route that satisfies that specific endpoint.
    We are going to fix this now by creating an alias.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们已经将`user`路由移动到了其子路由之一。因此，如果我们访问`user`路由（例如，`http://localhost:5173/user/60d21b4667d0d8992e610c85`），我们将看到一个空页面。这不是一个错误，而是预期的，因为我们实际上没有声明任何满足该特定端点的路由。我们现在将通过创建别名来解决这个问题。
- en: Reusing routes with alias and redirect
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用别名和重定向重用路由
- en: 'So far, we have learned how to create new routes, but there is another skill
    required to master vue-router: **alias** and **redirect**.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何创建新路由，但掌握vue-router还需要另一项技能：**别名**和**重定向**。
- en: Both `alias` and `redirect` allow you to reuse existing routes by navigating
    the user from one route to another and are very useful when you want to create
    SEO-friendly URLs. The only distinction between the two features is the result
    that the user sees within the browser.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`alias`和`redirect`都允许您通过将用户从一个路由导航到另一个路由来重用现有路由，这在您想要创建SEO友好的URL时非常有用。这两个功能之间的唯一区别是用户在浏览器中看到的结果。'
- en: Using our previous example, we have found ourselves in a situation in which
    a route is currently unusable because it has no component or view attached to
    it. This is a common scenario when working with `children` routes and can easily
    be solved with an alias or redirect.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前的示例，我们发现自己处于一个路由目前无法使用的情况，因为它没有组件或视图与之关联。这是在处理`children`路由时常见的情况，可以通过别名或重定向轻松解决。
- en: To solve our empty route problem, we are going to use `redirect` to navigate
    all users that land on the `user/:userId` path to its `children` path, `user/:userId/profile.`
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决我们的空路由问题，我们将使用`redirect`将所有到达`user/:userId`路径的用户导航到其子路径`user/:userId/profile`。
- en: Creating an alias or redirect is just the same as a simple route, with the only
    added property of `redirect` or `alias` used to specify what view should be used.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 创建别名或重定向与简单路由相同，只是增加了一个`redirect`或`alias`属性，用于指定应使用哪个视图。
- en: 'Let’s change our user view to include a `redirect` property:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改我们的用户视图以包含`redirect`属性：
- en: '[PRE18]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With the simple addition of the highlighted code, the user is now going to be
    redirected from one path to another. If you try to access the path `http://localhost:5173/user/60d21bf967d0d8992e610e9b`,
    you will see the URL change to `http://localhost:5173/user/60d21bf967d0d8992e610e9b/profile`
    immediately.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地添加高亮代码，用户现在将被重定向到另一个路径。如果您尝试访问路径`http://localhost:5173/user/60d21bf967d0d8992e610e9b`，您将立即看到URL变为`http://localhost:5173/user/60d21bf967d0d8992e610e9b/profile`。
- en: The value of `redirect` could either be an object including a name, as in our
    example, a simple path, or even be a complex object with `name`, `params`, and
    much more.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`redirect`的值可以是包含名称的对象，如我们的示例所示，一个简单的路径，甚至可以是一个包含`name`、`params`等更多内容的复杂对象。'
- en: It is now time to introduce `alias`. Previously, we saw that we can use `redirect`
    to transport the user from one route to another. But what if you just want to
    ensure that the users are able to access a given route using multiple URLs? A
    good example could be the need for us to create a “friendly URL,” which is a URL
    that is simple for a user to type or remember. It is very common for websites,
    such as e-commerce websites, to define a specific URL when you are navigating
    through the website, while also offering a friendly URL that is usually what is
    indexed and used by Google.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候介绍`alias`了。之前，我们看到了我们可以使用`redirect`将用户从一个路由传输到另一个路由。但如果你只想确保用户能够通过多个URL访问给定的路由，那会怎么样？一个很好的例子是我们需要创建一个“友好URL”，这是一个用户容易输入或记住的URL。对于网站来说，如电子商务网站，在用户浏览网站时定义一个特定的URL是很常见的，同时提供一个友好URL，这通常是Google索引和使用的URL。
- en: Just to give an example, you may want to render the same route if the user accesses
    [mywebsite.com/p/123](http://mywebsite.com/p/123) and [mywebsite.com/product/123](http://mywebsite.com/product/123).
    To achieve this, we can use aliases.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 仅举一个例子，如果你希望当用户访问[mywebsite.com/p/123](http://mywebsite.com/p/123)和[mywebsite.com/product/123](http://mywebsite.com/product/123)时渲染相同的路由，我们可以使用别名来实现这一点。为了达到这个目的，我们可以使用别名。
- en: When using aliases, we can define one or more URLs that can be matched with
    the same route. Aliases accept a string or an array of strings that match the
    different URLs for a given route.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用别名时，我们可以定义一个或多个可以与同一路由匹配的URL。别名接受一个字符串或字符串数组，这些字符串匹配给定路由的不同URL。
- en: 'Let’s pretend, for example, that we would like our static `/privacy` page to
    also render if the user accesses `/privacy-policy`. To achieve this, we would
    write the following rule in the route:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设，例如，我们希望我们的静态`/privacy`页面在用户访问`/privacy-policy`时也能渲染。为了实现这一点，我们将在路由中写下以下规则：
- en: '[PRE19]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After adding the alias in our route declaration, our Companion app will render
    the Privacy page for both `localhost:5173/privacy` and `localhost:5173/privacy-policy`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的路由声明中添加别名后，我们的伴侣应用将为`localhost:5173/privacy`和`localhost:5173/privacy-policy`两个地址都渲染隐私页面。
- en: In this small section, we have introduced the methods of `alias` and `redirect`.
    We have defined the use case that these two methods solve and their differences.
    Lastly, we have implemented the method in our own route definition to prevent
    our user from seeing a blank page when accessing the `user` endpoint and provided
    a simple example to showcase aliases by defining two endpoints for one route.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个小节中，我们介绍了`alias`和`redirect`的方法。我们定义了这两个方法解决的问题及其区别。最后，我们在自己的路由定义中实现了这个方法，以防止用户在访问`user`端点时看到空白页面，并提供了两个端点定义一个路由的简单示例来展示别名。
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about vue-router, the first external package
    that is part of the Vue core set of libraries to be covered in the book. The chapter
    introduced us to the package by covering its configuration and settings such as
    history mode. We then learned about the usage of routes, how to define them, and
    how to navigate to them.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了vue-router，这是书中将要介绍的Vue核心库集的第一个外部包。本章通过介绍其配置和设置，如历史模式，向我们介绍了这个包。然后我们学习了路由的使用，如何定义它们，以及如何导航到它们。
- en: After learning the basics of vue-router, we moved on to more advanced topics
    such as dynamic routes and nested routes.,
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习完vue-router的基础知识后，我们继续深入到更高级的主题，例如动态路由和嵌套路由。
- en: Lastly, we learned about `alias` and `redirect` to complete our basic understanding
    of the router and how to use it to build both simple and complex applications.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了`alias`和`redirect`，以完成我们对路由及其如何用于构建简单和复杂应用的基本理解。
- en: 'In the next chapter, we are going to learn about another core package of the
    Vue ecosystem: **Pinia**. This package is used to define and share state across
    our application.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习Vue生态系统中的另一个核心包：**Pinia**。这个包用于在应用中定义和共享状态。
