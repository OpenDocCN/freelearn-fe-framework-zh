- en: Chapter 12. Flux
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。Flux
- en: In the previous chapter, we took a look at the various tools in the React ecosystem
    that are useful in the whole lifetime of an application—development, testing,
    and production. We also saw how React improves the developer experience using
    developer tools. We learned about the various testing tools that can be used with
    React. To summarize it, we saw how to use build tools such as Webpack and Browserify
    and how they can be used with React.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们查看了一系列在应用程序整个生命周期中都有用的React生态系统中的工具——开发、测试和生产。我们还看到了React如何使用开发者工具来提高开发者体验。我们了解到了可以与React一起使用的各种测试工具。为了总结，我们看到了如何使用构建工具，如Webpack和Browserify，以及它们如何与React一起使用。
- en: In this chapter, we are going to dive deep in Flux as an architecture. We have
    seen how problems arise during data sharing across components. We will see how
    we can overcome them by having a single point of data store. Next, we will check
    out how to use React to overcome this.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨Flux作为一种架构。我们已经看到了在组件间数据共享过程中出现的问题。我们将看到如何通过拥有一个单一的数据存储点来克服这些问题。接下来，我们将检查如何使用React来克服这个问题。
- en: Dispatcher acts as a central hub to manage this data flow and communication
    and how Actions invoke them. Finally, we will we take a look at the complete data
    flow that takes place, while building our Social Media Tracker application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 分发器充当一个中央枢纽来管理这种数据流和通信以及动作如何调用它们。最后，我们将查看在构建我们的社交媒体追踪器应用程序时发生的完整数据流。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Flux architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flux架构
- en: Stores
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储库
- en: Actions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作
- en: Dispatcher
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发器
- en: Flux implementations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flux实现
- en: At the end of chapter, we will be able to start replacing parts of our application
    that have tight data coupling, with Flux We will be able to set up the necessary
    groundwork for Flux and easily start using the same in our React views.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将能够开始用Flux替换应用程序中具有紧密数据耦合的部分。我们将能够为Flux搭建必要的基础，并轻松地在我们的React视图中开始使用它。
- en: Flux architecture and unidirectional flow
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flux架构和单向流
- en: '"Hey Mike and Shawn!" entered Carla, on a bright morning.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: “嘿，迈克和肖恩！”卡拉在一个晴朗的早晨说道。
- en: '"Hi Carla, how are you today?"'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: “嗨，卡拉，你今天怎么样？”
- en: '"Wonderful. The previous app that you build was nice, the clients liked it.
    They will soon add more features to it. Meanwhile, we have got another small app
    to build."'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: “太棒了。你之前构建的应用程序很好，客户喜欢它。他们很快会为它添加更多功能。同时，我们还有一个小型应用程序要构建。”
- en: '"Oh, nice. What are we planning to build?" inquired Mike.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: “哦，不错。我们打算构建什么？”迈克问道。
- en: '"We need to build a kind of social tracker. To start with, we show a user''s
    reddits, tweets, and so on. We will later extend it to display other information."'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: “我们需要构建一种社交追踪器。首先，我们展示用户的reddits、tweets等内容。我们稍后会扩展它以显示其他信息。”
- en: '"Got it," iterated Shawn.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: “明白了，”肖恩重复道。
- en: '"Have a good day; I will leave it to you."'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: “祝你有美好的一天；我将把它留给你。”
- en: '"So Shawn, what do you think about the new project?"'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: “肖恩，你对这个新项目有什么看法？”
- en: '"It should be exciting. Umm… can we explore Flux and use it in the app? We
    had discussed it when we were building the last app."'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: “这应该会很有趣。嗯……我们能否探索Flux并在应用程序中使用它？我们在构建上一个应用程序时讨论过它。”
- en: '"Yeah, we can. This will be the perfect opportunity to see how Flux works.
    Before we start using it, let''s go through what Flux actually is."'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: “是的，我们可以。这将是一个了解Flux如何工作的完美机会。在我们开始使用它之前，让我们先了解一下Flux实际上是什么。”
- en: '"Flux is a simple architecture for React to make use of unidirectional flow.
    We have discussed previously how unidirectional flow suits React. React follows
    the render-always model when there are any changes made to data. Data doesn''t
    go other way around, like in the case of two-way bindings."'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: “Flux是React使用单向流的一个简单架构。我们之前讨论过单向流如何适合React。当数据有任何更改时，React遵循始终渲染的模型。数据不会像双向绑定的情况那样有其他方向。”
- en: '"It''s not exactly the **Model-View-Controller** (**MVC**) way of working.
    It consists of Model (Stores), Actions and Dispatchers, and finally Views (React
    Views)."'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: “这并不完全符合**模型-视图-控制器**（**MVC**）的工作方式。它由模型（存储库）、动作和分发器组成，最后是视图（React视图）。”
- en: '"There is no module for complete Flux as a framework as it''s not meant to
    be. Facebook provides the Flux module, which consists of the **Dispatcher**. Other
    parts such as **View** and **Stores** can be done without much support. Let''s
    go over them one by one, shall we?"'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: “目前还没有完整的Flux作为框架的模块，因为它不是为此而设计的。Facebook提供了Flux模块，它由**分发器**组成。其他部分，如**视图**和**存储库**，可以在没有太多支持的情况下完成。让我们一一过一遍，好吗？”
- en: '"Sure. I believe we can go over how they correlate and why exactly are they
    useful when an app starts to grow."'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '"当然。我相信我们可以讨论它们是如何相互关联的，以及为什么当应用开始增长时它们特别有用。"'
- en: '"Yup."'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的。"'
- en: '"As you can see in the following image, the various components are tied together
    and function distinctly. Data flows in a single direction in a cycle."'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '"正如您在下面的图像中可以看到的，各种组件相互连接并独立工作。数据在一个循环中以单一流向流动。"'
- en: '"As I mentioned previously, a **Dispatcher** acts as the central hub. Whenever
    an event takes place from the View, such as a user clicks a button or an Ajax
    call is completed, an action from the Actions is called. The **Action** may also
    get called from the **Dispatcher**."'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '"正如我之前提到的，**分发器**充当中央枢纽。每当视图发生事件时，例如用户点击按钮或Ajax调用完成，就会调用动作。动作也可能由**分发器**调用。"'
- en: '"The Actions are simple constructs that deliver the payload to the **Dispatcher**,
    which identify what the **Action** is and other details from the action and data
    needed to update current state."'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '"动作是简单的结构，将有效载荷传递给**分发器**，**分发器**识别**动作**以及从动作和数据中获取的更新当前状态所需的其他细节。"'
- en: '![Flux architecture and unidirectional flow](img/4730_12_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Flux架构和单向流](img/4730_12_01.jpg)'
- en: '"The **Dispatcher** then propagates it to the stores. **Dispatcher** acts like
    a callback registry, where all stores register themselves. **Dispatcher** notifies
    and callbacks stores whenever some action takes place. Irrespective of the action,
    it is delivered to all the stores."'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '"然后**分发器**将其传播到存储。**分发器**就像一个回调注册表，所有存储都注册自己。每当发生某些动作时，**分发器**都会通知并回调存储。无论动作是什么，它都会被发送到所有存储。"'
- en: '"The **Dispatcher** is not doing any complex activities, it just forwards the
    payload to registered stores, and it doesn''t process any data."'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '"**分发器**不做任何复杂的活动，它只是将有效载荷转发给已注册的存储，并且不处理任何数据。"'
- en: '"The responsibility to perform logical and complex decisions and data changes
    is entrusted with the stores. This helps to make the point of data changes at
    a single place and avoid changes all around the application, which are harder
    to track."'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '"执行逻辑和复杂决策以及数据更改的责任委托给了存储。这有助于将数据更改点集中在单一位置，并避免在应用程序周围进行更改，这些更改更难追踪。"'
- en: '"On receiving a callback from the **Dispatcher**, the **Store** decides whether
    it needs to perform any action or not, based on the **Action** type. Based on
    the callback, it can update the current store. It can also wait for other stores
    to be updated. After it is done with the changes, it goes ahead and notifies the
    view. This can be achieved in our simple Flux version by making use of an `EventEmitter`
    module which is available from the events module."'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '"在接收到**分发器**的回调后，**存储**根据**动作**类型决定是否需要执行任何操作。基于回调，它可以更新当前存储。它也可以等待其他存储更新。在完成更改后，它继续通知视图。在我们的简单Flux版本中，可以通过使用从events模块可用的`EventEmitter`模块来实现这一点。"'
- en: '"Similar to Actions, the Views register themselves to hear changes in stores.
    On some changes, an event is emitted by `EventEmitter`. Based on the event type,
    it will call a `View` method, which has registered to listen to an event."'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '"与动作类似，视图会注册自己以监听存储中的变化。在某些变化发生时，`EventEmitter`会发出一个事件。根据事件类型，它将调用一个已注册监听该事件的`View`方法。"'
- en: '"The **View** receiving the event can then update its own state, based on the
    current state of any stores that are available to it. The state update then triggers
    the **View** update."'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '"接收事件的**视图**可以根据它可用的任何存储的当前状态更新其自身状态。状态更新然后触发**视图**更新。"'
- en: '"This process continues with a **View** event, resulting in calls to the **Actions**
    and **Dispatcher** and so forth."'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '"这个过程通过**视图**事件继续，导致对**动作**和**分发器**等的调用。"'
- en: '"Hope, this is somewhat clear now?" queried Mike.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '"希望，现在这有点清晰了？" 迈克问道。'
- en: '"Umm… yeah, let me wrap my head around it. We have actions to perform an **Action**,
    based on an event. It then notifies the **Dispatcher**, which then notifies any
    store registered to listen for the changes. The Stores then update themselves,
    based on the action type and notify the React Views to update themselves."'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '"嗯...是的，让我理清思路。我们有动作来执行动作，基于一个事件。然后它通知**分发器**，然后通知任何已注册监听更改的存储。存储根据动作类型更新自己，并通知React视图更新自己。"'
- en: '"Correct! Let''s dive in the app right away. We will base our app from the
    official Flux example. It will be structured like this."'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '"正确！让我们立即深入到应用中。我们将基于官方Flux示例构建我们的应用。它将这样结构化。"'
- en: '`js/`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`js/`'
- en: '`├── actions`'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`├── actions`'
- en: '`│ └── SocialActions.js`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`│ └── SocialActions.js`'
- en: '`├── app.js`'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`├── app.js`'
- en: '`├── components`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`├── components`'
- en: '`│ └── SocialTracker.react.js`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`│ └── SocialTracker.react.js`'
- en: '`├── constants`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`├── constants`'
- en: '`│ └── SocialConstants.js`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`│ └── SocialConstants.js`'
- en: '`├── dispatcher`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`├── dispatcher`'
- en: '`│ └── AppDispatcher.js`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`│ └── AppDispatcher.js`'
- en: '`├── stores`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`├── stores`'
- en: '`│ └── SocialStore.js`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`│ └── SocialStore.js`'
- en: '`└── utils`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`└── utils`'
- en: '`└── someutil.js`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`└── someutil.js`'
- en: '"Now, as Carla mentioned, we need to show the user''s data from Twitter and
    Reddit. For Reddit, it''s available openly via API calls, as we will see shortly."'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '"现在，正如卡拉提到的，我们需要显示来自Twitter和Reddit的用户数据。对于Reddit，它可以通过API调用公开获取，正如我们很快将看到的。"'
- en: '"For Twitter, we are going to need to set up some groundwork and create a Twitter
    app. We can create a new one on [https://apps.twitter.com/](https://apps.twitter.com/).
    I have already created one for our app."'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '"对于Twitter，我们需要做一些基础设置并创建一个Twitter应用。我们可以在[https://apps.twitter.com/](https://apps.twitter.com/)上创建一个新的。我已经为我们的应用创建了一个。"'
- en: '![Flux architecture and unidirectional flow](img/4730_12_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Flux架构和单向流](img/4730_12_02.jpg)'
- en: '"We are then going to make use of the `twitter` module to access Twitter and
    fetch tweets from users. Let''s set up a `config.js` file to store the preceding
    access tokens that we have created, as follows:"'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '"然后我们将使用`twitter`模块来访问Twitter并从用户那里获取tweets。让我们设置一个`config.js`文件来存储我们之前创建的访问令牌，如下所示："'
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '"These correspond to the relative keys and secrets that we created in our app.
    Next, we will create a client to access the data using the preceding credentials."'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '"这些对应于我们在我们的应用中创建的相对键和秘密。接下来，我们将创建一个客户端，使用前面的凭证访问数据。"'
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '"We are going to make use of this client in our express server application.
    As I said, for Reddit, we can hit Reddit API directly to access reddits. For Twitter,
    it will first hit our node `App` and return tweets to our React Components."'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们将在我们的express服务器应用程序中使用这个客户端。正如我说的，对于Reddit，我们可以直接调用Reddit API来访问reddits。对于Twitter，它将首先击中我们的node
    `App`并返回tweets到我们的React组件。"'
- en: '"Would you like to define this, Shawn?"'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '"你想定义这个吗，肖恩？"'
- en: '"Sure."'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '"当然。"'
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '"I defined a JSON endpoint here called `tweets.json`. It will call the `client.get()`
    method, which is a REST API wrapper to call Twitter API. We invoke the `statuses/user_timeline`
    API to fetch the user timeline for a user, which is passed to us from the request.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '"我在这里定义了一个名为`tweets.json`的JSON端点。它将调用`client.get()`方法，这是一个REST API包装器，用于调用Twitter
    API。我们调用`statuses/user_timeline` API来获取用户的用户时间线，这是从请求中传递给我们的。"'
- en: On receiving the response, it will send this back to the React component calling
    it."
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在收到响应后，它将把这个信息发送回调用它的React组件。"
- en: '"Looks good. Now, let''s start with the App. We will start by defining the
    Dispatcher."'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '"看起来不错。现在，让我们从App开始。我们将首先定义Dispatcher。"'
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '"We define our dispatcher by requiring it from `flux.Dispatcher`. We will then
    use this at various places."'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们通过从`flux.Dispatcher`中引入它来定义我们的dispatcher。然后我们将在各个地方使用它。"'
- en: Flux actions
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flux actions
- en: '"Now we need to define the actions types that we are going to refer to as constants
    at various places, such as sending the type from Actions to store, and in our
    store, deciding what action type has been passed to store to take appropriate
    actions.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '"现在我们需要定义我们将要作为常量在各种地方引用的动作类型，例如从Actions发送类型到store，并在我们的store中，决定传递给store的动作类型以采取适当的行动。'
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '"Here, we are using the [https://github.com/STRML/keyMirror](https://github.com/STRML/keyMirror)
    package to create keys and values for the object based on the keys. This will
    convert into object similar to below."'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '"在这里，我们使用[https://github.com/STRML/keyMirror](https://github.com/STRML/keyMirror)包根据键创建对象的关键和值。这将转换为类似于以下的对象。"'
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '"This is handy when adding new keys to not repeat the same contents again."'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '"当添加新键时，这很方便，可以避免再次重复相同的内容。"'
- en: '"We can now start using the action constants. They represent four actions that
    we are going to perform, as follows:"'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们现在可以开始使用动作常量了。它们代表我们将要执行的四种动作，如下所示："'
- en: '`SYNC_TWEETS`: This fetches the tweets for a given user'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SYNC_TWEETS`: 这将获取给定用户的tweets'
- en: '`SYNC_REDDITS`: This fetches the reddits for a give topic'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SYNC_REDDITS`: 这将获取给定主题的reddits'
- en: '`FILTER_BY_TWEETS`: This only displays tweets, instead of tweets and reddits'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FILTER_BY_TWEETS`: 这仅显示tweets，而不是tweets和reddits'
- en: '`FILTER_BY_REDDITS`: This only displays reddits, instead of tweets and reddits'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FILTER_BY_REDDITS`: 这仅显示reddits，而不是tweets和reddits'
- en: '"Next, let''s define the actions that will be called from different places
    in our views."'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '"接下来，让我们定义将在我们的视图的不同地方调用的动作。"'
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '"Let''s go through these actions, case-by-case:"'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '"让我们逐个分析这些动作："'
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '"Here, we are using fetch, which is similar to Ajax that we have used before,
    to fetch tweets from our own `tweets.json` API, where we are passing the username
    for which we need to get the tweets. We are making use of JSON utility methods
    here that we have defined as follows:"'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '"在这里，我们使用fetch，这与我们之前使用的Ajax类似，用于从我们的`tweets.json` API获取推文，其中我们传递了需要获取推文的用户名。我们在这里使用我们定义的JSON实用方法。"'
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '"They help us convert responses to JSON, or in case of failures, logs them:"'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '"它们帮助我们将响应转换为JSON，或者在失败的情况下记录它们："'
- en: After we receive a successful response from API, we call `SocialActions.syncTweets(json)`
    method, from the same module.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '"在从API接收到成功响应后，我们从同一模块调用`SocialActions.syncTweets(json)`方法。"'
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '"Next, `syncTweets` accepts the JSON. Then, it wraps the JSON into an object
    payload to be sent to dispatcher. In this object, we are creating a tweets array
    out of the payload. We are also tagging each object to depict its type as tweet
    so that we can mix and match the tweets and reddit in same arrays and identity
    which object it represents: a tweet or reddit."'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '"接下来，`syncTweets`接受JSON。然后，它将JSON包装成一个对象有效载荷，发送给分发器。在这个对象中，我们创建了一个推文数组，从有效载荷中。我们还为每个对象标记了类型，以表示它是推文，这样我们就可以在同一个数组中混合和匹配推文和Reddit，并识别它代表的是推文还是Reddit。"'
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '"We use `Object.assign`, which merges two objects together. We use it from
    the `object-assign` package here."'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们使用`Object.assign`，它将两个对象合并在一起。我们在这里使用`object-assign`包。"'
- en: '"Now, we notify the Dispatcher about the payload to be ultimately delivered
    to the stores follows"'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '"现在，我们通知分发器关于最终要传递给存储器的有效载荷，如下所示："'
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '"Similarly, we have the `syncReddits` method, as follows:"'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '"同样，我们还有一个`syncReddits`方法，如下所示："'
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '"This fetches the reddits from `https://www.reddit.com/r/${topic}.json`, for
    example [https://www.reddit.com/r/twitter.json](https://www.reddit.com/r/twitter.json).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '"这从`https://www.reddit.com/r/${topic}.json`获取Reddit，例如[https://www.reddit.com/r/twitter.json](https://www.reddit.com/r/twitter.json)。"'
- en: '"After fetching, it delivers the data to `SocialActions.syncReddits(json))`,
    which creates the payloads for the dispatcher, as follows:"'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '"在获取数据后，它将数据传递给`SocialActions.syncReddits(json))`，从而为分发器创建有效载荷，如下所示："'
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '"Note, how we are passing the type attribute for the actions here. This is
    to notify the stores what action to take when they receive the payload."'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '"请注意，我们在这里传递了类型属性给动作。这是为了通知存储器在接收到有效载荷时采取什么动作。"'
- en: '"Got it. It would be interesting to see how we proceed on the basis of this
    object."'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '"明白了。看到我们如何基于这个对象进行操作会很有趣。"'
- en: '"Yup. Next, we have two simple methods that relay the events to the stores,
    as follows:"'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的。接下来，我们有两个简单的方法，将事件传递到存储器中，如下所示："'
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '"We are going to use these methods as `onClick` methods. On clicking the checkboxes,
    the value for the checkbox—either reddit or twitter—will be available in `event.target.checked`."'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们将使用这些方法作为`onClick`方法。点击复选框时，复选框的值——无论是Reddit还是Twitter——将在`event.target.checked`中可用。"'
- en: '"We wrap these in a simple object, tag them with the type of action call, and
    send the same to the Dispatcher. This way, we will know if we are going to display
    the tweets, reddit, or none."'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们将这些包裹在一个简单的对象中，用动作调用的类型标记它们，并将相同的对象发送给分发器。这样，我们将知道我们将要显示推文、Reddit还是什么都没有。"'
- en: Flux stores
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flux存储
- en: '"Cool, it looks like now we are all set to create our store."'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '"很好，看起来我们现在都准备好创建我们的存储器了。"'
- en: '"Yup Shawn. We will start by defining the state object that we will keep on
    updating and using as a store."'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的，肖恩。我们将从定义我们将不断更新并用作存储器的状态对象开始。"'
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '"We have also defined a `CHANGE_EVENT` constant that we use as an identifier
    to *listen* to events of the *change* type from the event emitter in our store."'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们还定义了一个`CHANGE_EVENT`常量，我们将其用作标识符来*监听*来自存储器事件发射器的*更改*类型的事件。"'
- en: '"We then define a method to update the states, creating a new one."'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '"然后我们定义一个方法来更新状态，创建一个新的状态。"'
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '"This merges the new properties that need to be updated and merged into the
    existing state and updated the current state."'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '"这合并了需要更新和合并到现有状态中的新属性，并更新了当前状态。"'
- en: '"Cool, this looks somewhat similar to the `setState` React method," said Shawn.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '"很好，这看起来与React的`setState`方法有些相似，”肖恩说。"'
- en: '"Yup. Now we are going to define our store that will update the current state."'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的。现在我们将定义我们的存储器，它将更新当前状态。"'
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '"Here, we are defining our `SocialStore` by inheriting from `EventEmitter`.
    This gives it the capability to be used by the components to register to listen
    on events, `CHANGE_EVENT` in our case. The `addChangeListener` and `removeChangeListener`
    methods take in methods that should be called on events and remove the listener,
    as follows:" `this.on(CHANGE_EVENT, callback);` and `this.removeListener(CHANGE_EVENT,
    callback);`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '"在这里，我们通过继承`EventEmitter`来定义我们的`SocialStore`。这使它能够被组件用来注册监听事件，在我们的例子中是`CHANGE_EVENT`。`addChangeListener`和`removeChangeListener`方法接受应该在事件上调用并移除监听器的方法，如下：`this.on(CHANGE_EVENT,
    callback);`和`this.removeListener(CHANGE_EVENT, callback);`'
- en: '"Whenever we want to notify the listeners, we call."'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '"每当我们要通知监听器时，我们调用。"'
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '"Finally, our views can get the current state from the store using following
    function:"'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '"最后，我们的视图可以使用以下函数从存储中获取当前状态："'
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '"Finally, Shawn, let''s tie this all together with our Single Dispatcher, as
    follows:"'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '"最后，Shawn，让我们用我们的单个分发器将这些全部结合起来，如下："'
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '"Whenever we have `AppDispatcher.dispatch` being called by the payload, the
    preceding method is invoked."'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '"每当`AppDispatcher.dispatch`被有效载荷调用时，前面的方法就会被调用。"'
- en: '"Let''s take a look at one of these actions."'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '"让我们看看这些操作中的一个。"'
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '"What we are doing here is calling `updateState` to update the current state
    by providing it with the updated tweets and update the feed, based on the `mergeFeed`
    method."'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们在这里所做的就是调用`updateState`来通过提供更新的推文和基于`mergeFeed`方法的更新来更新当前状态。"'
- en: '"Let''s take a look at it."'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '"让我们看看它。"'
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '"I have combined various operations here to be handled, based on whether `showTweets`,
    `showReddits` are selected."'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '"我根据是否选择了`showTweets`和`showReddits`来组合了各种要处理的操作。"'
- en: '"So, what this method does is that it accepts the tweets and reddit array data,
    as well as checks whether show reddits or show tweets is checked or not. We build
    the final feed based on these checked/unchecked fields into the `mergedFeed` array."'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '"所以，这个方法所做的就是接受推文和reddit数组数据，以及检查是否选中了显示reddits或显示推文。我们根据这些选中的/未选中的字段将这些字段构建到`mergedFeed`数组中。"'
- en: '"Then, we sort this array of both mixed up tweets and reddits data—`mergedFeed`,
    using `underscorejs` method, `sortBy`, and we sort the array on the basis of time
    fields on the two types of objects. In case of tweets, this field is the `created_at`
    field, and in case of reddit, it''s the `created_utc` field. We normalize the
    time in UTC timestamp for comparison."'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '"然后，我们使用`underscorejs`的`sortBy`方法对这个混合的推文和reddits数据数组`mergedFeed`进行排序，基于两种类型对象的`time`字段。对于推文，这个字段是`created_at`字段，而对于reddit，它是`created_utc`字段。我们使用UTC时间戳来规范化时间以进行比较。"'
- en: '"Coming back to the sync tweets action, after updating the state, we call the
    emitter method on store:"'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '"回到同步推文操作，在更新状态后，我们在存储上调用发射器方法："'
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '"This calls our emitter from the store to eventually deliver updates to the
    components."'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '"这会从存储中调用我们的发射器，最终将更新传递给组件。"'
- en: '"Got it. I believe the next step is creating our Views."'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '"明白了。我认为下一步是创建我们的视图。"'
- en: '"That''s right. We will split our view into three components—`Header`, `MainSection`,
    and `SocialTracker` container component."'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '"没错。我们将视图拆分为三个组件——`Header`、`MainSection`和`SocialTracker`容器组件。"'
- en: '"We start with the `Header`, as follows:"'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们首先从`Header`开始，如下："'
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '"It''s a simple display component, containing the header."'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '"这是一个简单的显示组件，包含标题。"'
- en: '"Ah, Mike. I notice you are using the react-bootstrap module. That looks neat.
    Instead of defining it in plain elements and bootstrap properties, it helps us
    to wrap them in the React Components with properties."'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '"啊，Mike。我注意到你正在使用react-bootstrap模块。这看起来很整洁。它帮助我们用属性将它们包裹在React组件中，而不是在普通元素和bootstrap属性中定义。"'
- en: '"Yup. We are using the `Jumbotron` and `Row` here. This Row will get wrapped
    in a bootstrap Grid component."'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的。我们在这里使用`Jumbotron`和`Row`。这个`Row`将被包裹在一个bootstrap网格组件中。"'
- en: '"Next, we are going to get our `MainSection` component set up, this will show
    the inputs to get the usernames for Twitter and Reddit topic, as well as check
    for them:"'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '"接下来，我们将设置我们的`MainSection`组件，这将显示获取Twitter和Reddit主题用户名的输入，以及检查它们："'
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '"Now the component is doing a couple of things here. First, it''s setting the
    state on the basis of the store."'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '"现在组件在这里做了一些事情。首先，它根据存储设置状态。"'
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '"It is also tracking two different fields—Twitter and Reddit—username information.
    We bind these values based on inputs from the fields, as we have seen before:"'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '"它还在跟踪两个不同的字段——Twitter和Reddit——用户名信息。我们根据之前看到的字段输入绑定这些值："'
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '"And then use this change handler on the input fields, like so."'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '"然后在输入字段上使用这个更改处理程序，就像这样。"'
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '"Next, we have our `componentDidMount` and `componentWillUnmount` functions
    register and de-register them to listen to the events emitted from the `SocialStore`:"'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '"接下来，我们有 `componentDidMount` 和 `componentWillUnmount` 函数来注册和注销，以便监听来自 `SocialStore`
    的事件："'
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '"Here, we register the `_onChange` method to be called whenever the changes
    occur in the `SocialStore`. The `_onChange` method, in turn, updates the current
    state of the component, based on state of the store, as follows:"'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '"在这里，我们将 `_onChange` 方法注册为每当 `SocialStore` 发生变化时被调用。`_onChange` 方法反过来根据存储的状态更新组件的当前状态，如下所示："'
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '"Next, we specify the `SocialAction` methods to be called for events such as
    checking/unchecking Twitter/Reddit display and calling to sync the tweets and
    reddits. On calling out the syncing data, `syncFeed` gets called, which calls
    the related sync methods from `SocialActions`, passing in the current Twitter
    name and Reddit topic."'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '"接下来，我们指定要为检查/取消检查推特/Reddit显示和同步推文和Reddit调用等事件调用的 `SocialAction` 方法。在调用同步数据时，`syncFeed`
    被调用，它从 `SocialActions` 调用相关的同步方法，传入当前的推特名称和Reddit主题。"'
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '"Finally, we are going to wrap everything up with the `SocialTracker` component,
    as follows:"'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '"最后，我们将使用 `SocialTracker` 组件来封装一切，如下所示："'
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '"We have the same set up that we used previously to listen to the store updates
    and update the current state of the component."'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们使用了之前用来监听存储更新并更新组件当前状态的相同设置。"'
- en: '"Nice, I see, all that''s left is looping over the feed and displaying them,"
    continued Shawn.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '"很好，我看到，剩下的只是遍历信息流并将它们显示出来，”肖恩继续说。'
- en: '"I see that we are displaying the feed in groups of three in a row and applying
    individual styles, based on whether its a tweet and so on. To divide them in groups,
    we seem to be using `ArrayUtil`."'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '"我看到我们正在以每行三组的格式显示信息流，并根据是否是推文等应用单独的样式。为了分组，我们似乎使用了 `ArrayUtil`。"'
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '"Yup, that''s right. With this, it looks like we are all set. We will finally
    display the component as usual."'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '"没错。有了这个，看起来我们一切都准备好了。我们最终将按常规显示组件。"'
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '"Let''s take a look at how it looks, shall we?"'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '"让我们看看它看起来怎么样，好吗？"'
- en: '![Flux stores](img/4730_12_03.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![Flux stores](img/4730_12_03.jpg)'
- en: '"Here''s how it looks, without tweets:"'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '"这是它的样子，没有推文："'
- en: '![Flux stores](img/4730_12_04.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![Flux stores](img/4730_12_04.jpg)'
- en: '"Here''s how it looks, when changing the twitter user:"'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '"当更改推特用户时，它看起来是这样的："'
- en: '![Flux stores](img/4730_12_05.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![Flux stores](img/4730_12_05.jpg)'
- en: '"This looks awesome, Mike!"'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '"这看起来很棒，迈克！"'
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We did a deep dive in Flux as an architecture. We saw Dispatcher act as a central
    hub to transmit our data and Actions to process them. We saw how the main responsibility
    to manipulate the state and update itself was delegated to the stores themselves.
    Finally, we saw how they were tied up together and made it easy to be used in
    views and share stores across the components.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们深入研究了Flux作为架构。我们看到Dispatcher充当中央枢纽来传输我们的数据和动作，以及处理它们的动作。我们看到主要责任是操纵状态和更新状态被委托给了存储本身。最后，我们看到它们是如何结合在一起，并使其在视图中使用和跨组件共享存储变得容易。"'
