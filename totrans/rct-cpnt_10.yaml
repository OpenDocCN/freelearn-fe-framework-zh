- en: Chapter 10. Testing Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we looked at ways of making our components friendly for
    plugin developers. We saw a few of the benefits of dependency injection and how
    AdonisJS Fold can help us achieve it with minimal effort.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about testing—automated testing, effective testing,
    before-you-make-a-mess-of-your-code testing. We will learn about the benefits
    of testing and the different kinds of tests.
  prefs: []
  type: TYPE_NORMAL
- en: Eat your vegetables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is there something you really don't like to eat? Perhaps it's a kind of vegetable
    or fruit. When I was a kid, there were many things I didn't like to eat. I couldn't
    even remember what many of them tasted like, and they didn't hurt me. I just made
    up my mind that they were bad, and I didn't like them.
  prefs: []
  type: TYPE_NORMAL
- en: Some developers have similar habits. Are there things you don't like to do as
    a developer? Not because they're difficult or bad, but just because...
  prefs: []
  type: TYPE_NORMAL
- en: For me, testing was one of those things. I learned about testing many years
    after I started programming, and it's still something I need to actively work
    on. I know why it's good, and why the common arguments against testing are bad.
    Still, I need to convince myself to continually test my work well.
  prefs: []
  type: TYPE_NORMAL
- en: I had to learn that it's not enough just to click through an interface, that
    testing isn't really testing unless it can be run automatically, that testing
    isn't really useful unless it happens continuously, and that testing is often
    very useful as part of a design phase before any implementation happens.
  prefs: []
  type: TYPE_NORMAL
- en: Here are some reasons why I believe these things. Perhaps you'll find them useful
    as you learn about testing or even as you try to convince people why they should
    plan and budget for testing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I can't stress enough on the importance of testing. The concepts we look at
    here are just the tip of the iceberg. If you really want to learn about testing
    and writing testable code, I highly recommend that you read *Clean Code* (by Robert
    C. Martin).
  prefs: []
  type: TYPE_NORMAL
- en: Design by testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing can be a powerful design tool for code as much as wireframes can be
    for interactive interfaces. Sometimes, it's good to make a rapid prototype of
    the code you think can work for you. But once you know how you want your code
    to behave, it's useful to write some assertions for this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Put the prototype to one side and start creating a checklist of the behavior
    you now know your code should have. Perhaps this is a good time to involve the
    product owners, as you essentially create a contract of functionality you have
    yet to implement.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of a testing-first approach is often referred to as **test-driven
    development** (**TDD**). Tests are useful whether or not you write them first.
    But if you do write them first, they can help you shape the behavior of your code
    at a critical stage of a project.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation by testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unless you have a folder of examples or extensive documentation, tests may be
    the only way for you to demonstrate what your code is supposed to do and how it
    is supposed to do it.
  prefs: []
  type: TYPE_NORMAL
- en: You (or the developers who work with your code) may know little of what your
    code is supposed to do, but if you write good tests, they can learn interesting
    things about it. Tests can reveal the parameters of functions, the ways in which
    functions break, and even what code is unused.
  prefs: []
  type: TYPE_NORMAL
- en: Sleep by testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Few things set me on edge quite like deploying critical code changes to large
    production systems. Does your team follow the "never deploy on a Friday" rule?
    If you had a good suite of tests, you could deploy fearlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Tests are an excellent way to discover regressions in code. Want to know if
    a change you're making will affect other parts of the application? If the application
    is well tested, you'll know the moment it does.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, a good test suite will help you keep your code doing what it should
    and let you know when you've broken it. Tests are great.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whether you write tests before or after the rest of your application code, having
    any tests is usually better than having no tests. You don't have to follow TDD
    principles, but they have been known to improve the design of code. And grown-ups
    know to try broccoli before dismissing it.
  prefs: []
  type: TYPE_NORMAL
- en: Types of tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many books can (and have been) filled with the intricacies of testing. There's
    a lot of jargon and we could go on for quite some time. Instead, I want to focus
    on a handful of terms, which I think will be most useful to us. There are two
    common kinds of tests we can write.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unit tests are tests that focus on one small, practical unit of work at a time.
    Given a non-trivial class or component, a unit test will focus on just one method
    or even just a single part of that method (if the method does many things).
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, consider the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In previous chapters, we created a workflow for being able to run the ES6 code
    through Node.js. I recommend that you recreate this setup for some of the code
    in this chapter, or use a site such as [http://jsbin.com/](http://jsbin.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'A unit test for the `Page` component could be something like this: given an
    instance of this component, and an object with a title `"Home"` and content `"A
    welcome message"`, when I call something such as `ReactDOMServer.render`, I see
    markup containing an `h1` element with the same title and a few `data-reactid`
    attributes.'
  prefs: []
  type: TYPE_NORMAL
- en: We test a small, practical unit of work. In this case, `Page` has a single method
    with a small focus. We can test the whole component at once, assured that we're
    testing something small and focused.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, a unit test for `Pages` can be something like this: given
    an instance of this component with the `pages` property containing an array of
    well-formed page objects, when I call `getPageComponents`, the `getPageComponent`
    method is called once for each page object with the correct properties each time.'
  prefs: []
  type: TYPE_NORMAL
- en: We would write separate tests for each method since they have different focuses
    and produce different results. We wouldn't test all of the pages together in a
    unit test.
  prefs: []
  type: TYPE_NORMAL
- en: Functional tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As compared to unit tests, functional tests are less concerned with such a
    narrow focus. Functional tests still test more areas, but they don''t require
    as much unit isolation as unit tests. We can test the whole `Pages` component
    in a single functional test, perhaps, as follows: given an instance of this component
    with the `pages` property containing an array of well-formed page objects, when
    I call something such as `ReactDOMServer.render`, I see markup containing all
    pages and their correct properties.'
  prefs: []
  type: TYPE_NORMAL
- en: We can test a lot more in a shorter period of time using functional tests. The
    downside to this is that the causes of errors are harder to pinpoint. Unit tests
    immediately point to the causes of smaller errors, while functional tests often
    only show that the group of functionality isn't working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of this is to say—the more accurately and granularly you test your code,
    the easier it will be to pinpoint the causes of errors. You can write a single
    functional test or 20 unit tests for the same code. So you need to balance the
    available time with the importance of detailed testing.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with assertions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assertions are the spoken/written language constructs made in the code. They
    look and function similar to how I''ve been speaking about them. In fact, most
    tests are structured in the same way we''ve been describing tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Given some pre-conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When something happens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We see some post-conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first two points happen as we create objects and components and call their
    various methods. Assertions happen in the third point. Node.js ships with a few
    basic assertion methods, which we can use to write our first tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There are quite a few assertion methods we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assert(condition), assert.ok(condition)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert.equal(actual, expected)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert.notEqual(actual, expected)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert.strictEqual(actual, expected)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert.notStrictEqual(actual, expected)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert.deepEqual(actual, expected)`…'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert.notDeepStrictEqual(actual, expected)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert.throws(function, type)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can add an optional custom message string to the parameters for any of these
    methods. The custom message will be displayed in place of the default error messages
    for each of these.
  prefs: []
  type: TYPE_NORMAL
- en: We can write these quite simply—creating a `tests.js` file, importing classes
    and components, and making assertions against their methods and markup.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer a more expressive syntax, consider installing the `assertthat`
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then write tests similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The example code for this chapter includes tests that you can inspect and run.
    I''ve also created a BabelJS-powered way to use ES6 and JSX in the tests. You
    can run the tests with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This runs the NPM script defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Don't be alarmed if you see nothing after running that. The tests are set up
    in such a way that you'll only see errors if the tests fail. If you see no errors,
    everything is OK!
  prefs: []
  type: TYPE_NORMAL
- en: Testing for immutability and idempotence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we looked at Flux and Redux, one of the interesting things we saw is that
    they recommend immutable types and idempotent functionality (like in reducers).
    If we were to test for these qualities, we can! Let''s install a helper library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If this is unfamiliar to you, refer back to the chapter on design patterns ([Chapter
    8](ch08.html "Chapter 8. React Design Patterns"), *React Design Patterns*).
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have an example reducer, store, and assertion. The reducer handles
    a single action—adding new pages. When we dispatch an `ADD_PAGE` action to the
    store, the reducer adds a new page to the `pages` state array. This reducer is
    not idempotent—it cannot be run with the same input and always produce the same
    output.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this by freezing the default state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this, we should see an error such as `Can''t add property 0, object
    is not extensible`. Remember that we can fix this problem by returning a new,
    modified state object from our reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can dispatch the same actions and always get the same results. We're
    no longer modifying the state in-place, but rather returning a new, modified state.
    The particulars of idempotence and immutability are better explained elsewhere;
    but the important thing to note is how we test for idempotence.
  prefs: []
  type: TYPE_NORMAL
- en: We can freeze the objects/arrays we want to remain idempotent and be assured
    that we're not modifying the things we don't want to modify.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to Travis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having tests is a great first step toward better code, but it's also important
    to run them often. There are many ways to do this (such as Git hooks or build
    steps), but the way I prefer is to connect my projects to *Travis*.
  prefs: []
  type: TYPE_NORMAL
- en: Travis is a continuous integration service, meaning that Travis watches for
    changes in a GitHub repository ([https://github.com](https://github.com)) and
    triggers tests for those changes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting to Travis](img/5268_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will look at how to connect Travis to a GitHub repository, which means we
    need a GitHub repository already set up. I will not go into detail about how to
    use GitHub, but you can find an excellent tutorial at [https://guides.github.com/activities/hello-world](https://guides.github.com/activities/hello-world).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can sign in to Travis by logging into your GitHub account and clicking
    on one of the **Sign in with GitHub** buttons. Hover over your profile and click
    on **Accounts**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting to Travis](img/5268_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Enable the repositories you would like Travis to check. In addition, you need
    to create a configuration file called `.travis.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells Travis to test this project as a Node.js project and to test it
    against version 5.5\. By default, Travis will run `npm install` before any tests.
    It will also run `npm test` to run the actual tests. We can enable this command
    by adding the following to `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you've put your tests in another file, you'll need to adjust that command
    to reflect what you type to run your tests. It's nothing more than a common alias.
  prefs: []
  type: TYPE_NORMAL
- en: After you commit code to your repository, Travis should test that code for you.
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting to Travis](img/5268_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can learn more about Travis at [https://docs.travis-ci.com/user/for-beginners](https://docs.travis-ci.com/user/for-beginners).
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may also want to try testing your application as a normal user would. You
    already do this as you click through the application you're developing to check
    whether things you just typed work as you expect. Why not automate the process?
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few tools for this. The one I've enjoyed using is called *Protractor*.
    It can be a little tricky to set up, but there's an excellent tutorial on the
    subject at [http://www.joelotter.com/2015/04/18/protractor-reactjs.html](http://www.joelotter.com/2015/04/18/protractor-reactjs.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the benefits of writing tests and running
    them often. We created a few tests for our classes and components and made assertions
    about their behavior.
  prefs: []
  type: TYPE_NORMAL
- en: We've now covered all the topics I want to share with you. Hopefully, they've
    given you all the tools to start creating interfaces with confidence. We've learned
    so much together; covering topics such as single component designs and states,
    how components talk to each other (through things such as context), how to structure
    and decorate the whole system, and even how to test it.
  prefs: []
  type: TYPE_NORMAL
- en: The React community is just beginning, and you can join it and influence it.
    All it will take is for you to spend a bit of time building things with React
    and talking to others about your experiences doing so.
  prefs: []
  type: TYPE_NORMAL
