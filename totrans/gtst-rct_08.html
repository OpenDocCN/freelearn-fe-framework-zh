<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;8.&#xA0;Testing React Components"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08" class="calibre1"/>Chapter 8. Testing React Components</h1></div></div></div><p class="calibre7">Until now, we have explored React's components lifecycle, properties, state, validations, and ECMAScript with respect to React 0.1.13 and future versions. In this chapter, we will explore the testing of JavaScript and ReactJS-related stuffs. First, we will be going through the testing as a whole using different JavaScript test frameworks and how we can run the tests, followed by testing views build with the ReactJS library.</p><p class="calibre7">The following are the things we will be covering in this chapter:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Testing in JavaScript using Chai and Mocha</li><li class="listitem">ReactTestUtils to test React components</li><li class="listitem">Exploring Jest</li><li class="listitem">Testing React-based app using Expect, Mocha, and Shallow rendering</li></ul></div><p class="calibre7">There are various ways that you can mix and match while testing JavaScript. Let's have a brief overview of the various things such as frameworks, assertion libraries, and testing tools. The list given here is not an exhaustive one, and covering all of them in detail is beyond the scope of this book.</p><p class="calibre7"><span class="strong"><strong class="calibre8">Mocha</strong></span> and <span class="strong"><strong class="calibre8">Jasmine</strong></span> are testing frameworks. They can be used with various testing assertion <a id="id248" class="calibre1"/>libraries <a id="id249" class="calibre1"/>as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">should.js</code> which<a id="id250" class="calibre1"/> is an assertion library. It is framework agnostic and works from IE9 and higher. The details of the library <a id="id251" class="calibre1"/>can be found from <a class="calibre1" href="https://www.npmjs.com/package/should">https://www.npmjs.com/package/should</a>.</li><li class="listitem"><code class="literal">chaijs</code> is <a id="id252" class="calibre1"/>also an assertion library, where we add plugins. It also works with the testing framework(s). The details of the library<a id="id253" class="calibre1"/> can be found online from <a class="calibre1" href="http://chaijs.com/karma">http://chaijs.com/karma</a>. It is a JavaScript testing tool, which enables to test JavaScript codes in browsers. It's framework agnostic (can be used to run Mocha, Jasmine, Qunit, and so on). The details can be found at <a class="calibre1" href="https://www.npmjs.com/package/karma">https://www.npmjs.com/package/karma</a>.</li></ul></div><p class="calibre7">It should be remembered that karma is neither a JavaScript framework like Jasmine or Mocha nor an assertion library like <code class="literal">chaijs</code> or <code class="literal">should.js</code>. This, we should use the assertion library and the framework as required along with karma in order to launch the HTTP server so that we can test the JS code in browsers.</p><p class="calibre7"><span class="strong"><strong class="calibre8">Jest</strong></span> is <a id="id254" class="calibre1"/>also a framework on Jasmine framework. The Facebook developer team suggests the use of Jest for testing React-based applications. According to the Jest website (<a class="calibre1" href="https://facebook.github.io/jest/">https://facebook.github.io/jest/</a>), these are some advantages of using <a id="id255" class="calibre1"/>Jest instead of vanilla jasmine for testing purposes:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Jest<a id="id256" class="calibre1"/> provides multiple layers on top of Jasmine</li><li class="listitem">It automatically searches and finds tests for you to execute</li><li class="listitem">It mocks dependencies for you while you run the tests</li><li class="listitem">It runs tests in parallel, hence finishing executing them faster</li><li class="listitem">It allows you to test asynchronous code synchronously</li><li class="listitem">It enables you to run tests on the command line with the fake DOM implementation via jsdom</li></ul></div></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;Testing React Components">
<div class="book" title="Testing in JavaScript using Chai and Mocha"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch08lvl1sec41" class="calibre1"/>Testing in JavaScript using Chai and Mocha</h1></div></div></div><p class="calibre7">As <a id="id257" class="calibre1"/>discussed earlier, in order to write test cases for the React <a id="id258" class="calibre1"/>code, we will be installing some testing libraries to run tests and write assertions. Let's walk through the setup for the Chai assertion library and the Mocha testing framework. We need to install the libraries with the help of <code class="literal">npm</code>.</p><p class="calibre7">In the terminal type:</p><div class="informaltable"><pre class="programlisting">
<span class="strong"><strong class="calibre8">npm i -D mocha chai</strong></span>
</pre></div><div class="informaltable" title="Note"><h3 class="title2"><a id="note33" class="calibre1"/>Note</h3><p class="calibre7"><code class="literal">install</code> shortform: <code class="literal">i</code></p><p class="calibre7"><code class="literal">devDependencies</code> shortform: <code class="literal">D</code> (the package will be installed only in a development environment)</p></div><p class="calibre7">After the Chai and Mocha libraries are installed by the previously mentioned command, they can be found under the <code class="literal">node_modules</code> directory.</p><p class="calibre7">We need to add the Mocha and Chai entries in our <code class="literal">package.json</code> file.</p><p class="calibre7"><span class="strong"><strong class="calibre8">Package.json code</strong></span></p><div class="informaltable"><pre class="programlisting">{
  "name": "JSApp",
  "version": "1.0.0",
  "description": "Get random numbers",
  "main": "index.js",
<span class="strong"><strong class="calibre8">  "scripts": {</strong></span>
<span class="strong"><strong class="calibre8">    "test": "mocha test.js"</strong></span>
<span class="strong"><strong class="calibre8">  },</strong></span>
<span class="strong"><strong class="calibre8">  "devDependencies": {</strong></span>
<span class="strong"><strong class="calibre8">    "chai": "3.2.0",</strong></span>
<span class="strong"><strong class="calibre8">    "mocha": "2.2.5"</strong></span>
<span class="strong"><strong class="calibre8">  }</strong></span>
}</pre></div><p class="calibre7">According <a id="id259" class="calibre1"/>to <a class="calibre1" href="https://docs.nodejitsu.com/articles/getting-started/npm/what-is-the-file-package-json">https://docs.nodejitsu.com/articles/getting-started/npm/what-is-the-file-package-json</a></p><p class="calibre7">All <code class="literal">npm</code> packages <a id="id260" class="calibre1"/>contain a file named <code class="literal">package.json</code>. This file is usually found in the project root. This file holds all metadata relevant to<a id="id261" class="calibre1"/> the project. A <code class="literal">package.json</code> file is used to offer information to <code class="literal">npm</code> thus allowing it to identify the project as well as handle the project's dependencies efficiently.</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">name</code>: This depicts the name of the application.</li><li class="listitem"><code class="literal">version</code>: This is a version of the application.</li><li class="listitem"><code class="literal">description</code>: This is general description of the application.</li><li class="listitem"><code class="literal">main</code>: This is the main JavaScript file, which may internally call other JS files. In this example, it's <code class="literal">index.js</code> file.</li><li class="listitem"><code class="literal">scripts</code>: This is the script to be executed when we call <code class="literal">npm</code> start. It should execute the test (mocha <code class="literal">test.js</code> file).</li><li class="listitem"><code class="literal">devDependencies</code>: These are the packages that are installed in the same directory as in <code class="literal">package.json</code>, unless the <code class="literal">–production</code> flag is passed on it. The packages are not installed on any other directory unless the <code class="literal">–dev</code> option is passed.</li></ul></div><p class="calibre7">Add a <code class="literal">test.js</code> file. In order to check the setup working properly, we are adding a simple single test assertion.</p><div class="informaltable"><pre class="programlisting">
<span class="strong"><strong class="calibre8">Test.js file code</strong></span>
var expect = require('chai').expect
, name = 'my Name';

var random = require('./index');

describe('random', function() {
  it('should work!', function() {
    expect(false).to.be.false;
  });

  it ('return my Name', function() {
        expect(name).to.be.a('string');
        expect(name).to.equal('my Name');
        expect(name).to.have.length(7);
        })
});</pre></div><div class="informaltable" title="Note"><h3 class="title2"><a id="note34" class="calibre1"/>Note</h3><p class="calibre7"><code class="literal">assertions</code> are called from Chai.</p><p class="calibre7"><code class="literal">describe</code> is called from Mocha framework to describe the tests.</p></div><p class="calibre7">Now <a id="id262" class="calibre1"/>we run the test, from <a id="id263" class="calibre1"/>the app's root directory in terminal, as shown here:</p><div class="informaltable"><pre class="programlisting">
<span class="strong"><strong class="calibre8">npm test</strong></span>
</pre></div><div class="mediaobject"><img src="../images/00044.jpeg" alt="Testing in JavaScript using Chai and Mocha" class="calibre9"/><div class="caption"><p class="calibre25">A console screenshot using the Mocha and Chai setup</p></div></div><p class="calibre10"> </p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Testing using ReactTestUtils"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec42" class="calibre1"/>Testing using ReactTestUtils</h1></div></div></div><p class="calibre7">ReactTestUtils is<a id="id264" class="calibre1"/> used to test React-based components. It <a id="id265" class="calibre1"/>can simulate all the JavaScript-based events, which ReactJS supports. The documentation is<a id="id266" class="calibre1"/> cited in the Facebook developer site (<a class="calibre1" href="https://facebook.github.io/react/docs/test-utils.html">https://facebook.github.io/react/docs/test-utils.html</a>).</p><p class="calibre7">The code is as shown for the stimulate function:</p><div class="informaltable"><pre class="programlisting">Simulate.{eventName}(
  DOMElement element,
  [object eventData]
)</pre></div></div>

<div class="book" title="Testing using ReactTestUtils">
<div class="book" title="Installing React and JSX"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec52" class="calibre1"/>Installing React and JSX</h2></div></div></div><p class="calibre7">As mentioned<a id="id267" class="calibre1"/> earlier, while installing the Chai and mocha, we are here <a id="id268" class="calibre1"/>installing React- and JSX-specific test tools (ReactTestUtils) in order to ease our task. Let's explore the ReactTestUtils with help from some React-based components and stimulate them to test the behavior and functionality.</p><p class="calibre7">The following is an example of such a code.</p><p class="calibre7">We need to install the <code class="literal">jest</code> package via <code class="literal">npm</code> with the following code in the terminal:</p><div class="informaltable"><pre class="programlisting">
<span class="strong"><strong class="calibre8">sudo npm install jest-cli –save-dev</strong></span>
</pre></div><p class="calibre7">sudo/root access to the machine/server where the node packages has to be installed is required. This is particularly required as the directory where the node is installed. We can check the installed directory, using the following command:</p><div class="informaltable"><pre class="programlisting">
<span class="strong"><strong class="calibre8">npm config get prefix</strong></span>
</pre></div><p class="calibre7">As per the screenshot here, it's installed in the <code class="literal">/usr</code> directory, which has the permissions set to root. Hence, we need to install the <code class="literal">npm</code> packages using the <code class="literal">sudo</code> option.</p><div class="mediaobject"><img src="../images/00045.jpeg" alt="Installing React and JSX" class="calibre9"/><div class="caption"><p class="calibre25">A console screenshot of the /usr directory file owner/permissions.</p></div></div><p class="calibre10"> </p><p class="calibre7">Another way is to set the permission of the <code class="literal">/usr</code> directory to the user, which can have permissions to own and modify the files in the directory:</p><div class="informaltable"><pre class="programlisting">
<span class="strong"><strong class="calibre8">sudo chown -R $(whoami) $(npm config get prefix)/{lib/node_modules,bin,share}</strong></span>
</pre></div><p class="calibre7">Let's try to have a approach of <span class="strong"><strong class="calibre8">test-driven development</strong></span> (<span class="strong"><strong class="calibre8">TDD</strong></span>) , whereby we will be creating <a id="id269" class="calibre1"/>a failing test case following the actual code to pass.</p><p class="calibre7">Create<a id="id270" class="calibre1"/> a <a id="id271" class="calibre1"/>JS file, which will greet any name with <code class="literal">hi</code>:</p><div class="informaltable"><pre class="programlisting">// greeting.js

module.exports = greetings;</pre></div><p class="calibre7">Now, let's create the <code class="literal">test</code> file within a directory named <code class="literal">__test__</code>:</p><div class="informaltable"><pre class="programlisting">// __tests__/greeting-test.js

<span class="strong"><strong class="calibre8"> jest.dontMock('../greetings');</strong></span>

//executed when the test runs
<span class="strong"><strong class="calibre8"> describe('greetings', function() {</strong></span>
<span class="strong"><strong class="calibre8">  it('greets the name', function() {</strong></span>
 var greet = require('../greetings');
 expect(greet("react")).toBe("hi react");
 });
 });</pre></div><p class="calibre7">Let's recap about some jest properties, from the earlier-mentioned code:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">jest.dontMock</code> is explicitly mentioned here, as jest by default mocks everything. Thus in order to test the actual code without mocking we need to ask jest not to mock the code which has to be tested (<code class="literal">greetings.js</code>)</li><li class="listitem"><code class="literal">describe('greetings', function())</code> each describe block is the test suite which gets executed when the test runs (<code class="literal">npm test</code>/<code class="literal">jest</code>). One describe block can have multiple test cases.</li><li class="listitem"> <code class="literal">it('greets the name', function()</code>, it block the actual test spec/case within the describe block.</li></ul></div><p class="calibre7">In order to execute the tests within the _<code class="literal">_test__/</code> directory, we need to have the <code class="literal">package.json</code> file with the following entries:</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note35" class="calibre1"/>Note</h3><p class="calibre7">We will be covering more about packaging in the next chapter.</p></div><p class="calibre7">Here is the code for <code class="literal">package.json</code> file:</p><div class="informaltable"><pre class="programlisting">{
  "dependencies": {
    "react": "~0.14.0",
    "react-dom": "~0.14.0"
  },
  "devDependencies": {
    "jest-cli": "^0.8.2",
    "react-addons-test-utils": "~0.14.0"
  },
  "scripts": {
    "test": "jest"
  },
  "jest": {
    "unmockedModulePathPatterns": [
      "&lt;rootDir&gt;/node_modules/react",
      "&lt;rootDir&gt;/node_modules/react-dom",
      "&lt;rootDir&gt;/node_modules/react-addons-test-utils",
      "&lt;rootDir&gt;/node_modules/fbjs"
    ]
  }
}</pre></div><p class="calibre7">Let's have<a id="id272" class="calibre1"/> a quick<a id="id273" class="calibre1"/> recap of the this code within <code class="literal">package.json</code>.</p><p class="calibre7">Once all are ready, we can run the test in the terminal, using the following command:</p><div class="informaltable"><pre class="programlisting">
<span class="strong"><strong class="calibre8">npm test</strong></span>
</pre></div><p class="calibre7">The output is shown as here:</p><div class="mediaobject"><img src="../images/00046.jpeg" alt="Installing React and JSX" class="calibre9"/><div class="caption"><p class="calibre25">The TDD console screenshot, showing failing tests.</p></div></div><p class="calibre10"> </p><p class="calibre7">Now, let's add the code so that the name is greeted with the name and the test passes:</p><div class="informaltable"><pre class="programlisting">// greeting.js

function greetings(name) {
  return "hi "+name;
}
module.exports = greetings;</pre></div><p class="calibre7">Now, when we execute the test, we will be seeing a passing test case:</p><div class="mediaobject"><img src="../images/00047.jpeg" alt="Installing React and JSX" class="calibre9"/><div class="caption"><p class="calibre25">The TDD console screenshot, using npm test, showing passing tests.</p></div></div><p class="calibre10"> </p><p class="calibre7">One <a id="id274" class="calibre1"/>of the <a id="id275" class="calibre1"/>other ways to execute the tests is by installing <code class="literal">jest</code> and executing them by calling the jest from the terminal:</p><div class="informaltable"><pre class="programlisting">
<span class="strong"><strong class="calibre8">sudo npm install -g jest-cli</strong></span>
</pre></div><p class="calibre7">The output is as shown here:</p><div class="mediaobject"><img src="../images/00048.jpeg" alt="Installing React and JSX" class="calibre9"/><div class="caption"><p class="calibre25">The TDD console screenshot, using jest, showing passing tests.</p></div></div><p class="calibre10"> </p><p class="calibre7">Thus, we can see with either of the commands <code class="literal">npm test</code>/<code class="literal">jest</code>, we are getting the same output.</p></div></div>
<div class="book" title="The jestTypical example of a Testsuite with Mocha, expect, ReactTestUtils and Babel"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec43" class="calibre1"/>The jestTypical example of a Testsuite with Mocha, expect, ReactTestUtils and Babel</h1></div></div></div><p class="calibre7">Let's see<a id="id276" class="calibre1"/> a typical example of <code class="literal">package.json</code>, which<a id="id277" class="calibre1"/> is<a id="id278" class="calibre1"/> using<a id="id279" class="calibre1"/> the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Mocha as a testing framework</li><li class="listitem">Expect as an assertion library</li><li class="listitem">ReactTestUtils to test react-based JavaScript components</li><li class="listitem">Babel used as a transcompiler, which changes the ES6 codes into currently compatible (ES5) JavaScript code.</li></ul></div><p class="calibre7">The <a id="id280" class="calibre1"/>example <a id="id281" class="calibre1"/>of<a id="id282" class="calibre1"/> <code class="literal">package.json</code> file:</p><div class="informaltable"><pre class="programlisting">"scripts": {
<span class="strong"><strong class="calibre8">    "test": "mocha './src/**/*.test.js' --compilers js:babel-core/register",</strong></span>
  },
  "devDependencies": {
<span class="strong"><strong class="calibre8">    "babel-core": "6.1.4",</strong></span>
<span class="strong"><strong class="calibre8">    "babel-loader": "6.1.0",</strong></span>
<span class="strong"><strong class="calibre8">    "babel-preset-es2015": "6.1.4",</strong></span>
<span class="strong"><strong class="calibre8">    "babel-preset-react": "6.1.4",</strong></span>
<span class="strong"><strong class="calibre8">    "babel-preset-stage-2": "6.1.2",</strong></span>
    "mocha": "2.3.3",
    "react-addons-test-utils": "0.14.3",
  }
}</pre></div><p class="calibre7">As in<a id="id283" class="calibre1"/> the previous examples, within the script object, we keep the the test files and all the test files follow the convention of ending with the <code class="literal">.test.js</code> extension. Any extension for the test files can be used. For compilation from ES6 code to browser compatible JS code, the <code class="literal">–compiler</code> tag is added in the script.</p><p class="calibre7">Install all the following packages, as here, mentioned in <code class="literal">package.json</code>:</p><div class="informaltable"><pre class="programlisting">
<span class="strong"><strong class="calibre8">npm install babel-loader babel-preset-es2015 babel-preset-react babel-preset-stage-2 react-addons-test-utilsBabel being the transpiler, we need to add the following entry to enable the import (reserver keyword) in the following .babelrc file:</strong></span>
</pre></div><div class="informaltable"><pre class="programlisting">{
    "presets": ["es2015"]
}</pre></div><p class="calibre7">Here is <a id="id284" class="calibre1"/>the definition of a transpiler. Source <a class="calibre1" href="https://en.wikipedia.org/wiki/Source-to-source_compiler">https://en.wikipedia.org/wiki/Source-to-source_compiler</a></p><div class="blockquote"><blockquote class="blockquote1"><p class="calibre23"><span class="strong"><em class="calibre12">"A source-to-source compiler, transcompiler, or transpiler is a type of compiler that takes the source code of a program written in one programming language as its input and produces the equivalent source code in another programming language."</em></span></p></blockquote></div><p class="calibre7">The <code class="literal">.babelrc</code> file contains all the Babel API options. The following is the screenshot of the file <a id="id285" class="calibre1"/>structures of the app with test suite setup. The details can be found in the Babel documentation at  <a class="calibre1" href="https://babeljs.io/docs/usage/babelrc/">https://babeljs.io/docs/usage/babelrc/</a>.</p><div class="mediaobject"><img src="../images/00049.jpeg" alt="The jestTypical example of a Testsuite with Mocha, expect, ReactTestUtils and Babel" class="calibre9"/><div class="caption"><p class="calibre25">The screenshot showing the dir structure of a typical JS Application with the __test__ , node_modules, package.json, and .babelrc</p></div></div><p class="calibre10"> </p><p class="calibre7">Using<a id="id286" class="calibre1"/> the same <code class="literal">greetings.js</code> file as before but <a id="id287" class="calibre1"/>testing with the <a id="id288" class="calibre1"/>new<a id="id289" class="calibre1"/> ES6 syntax in the <code class="literal">greetings.test.js</code> and <code class="literal">index.test.js</code> files, let's test the testsuite.</p><p class="calibre7"><span class="strong"><strong class="calibre8">Code __test__/greetings.test.js (using ES6 syntax)</strong></span></p><div class="informaltable"><pre class="programlisting">import expect from 'expect';
describe('greetings', () =&gt; {
   it('greets the name', () =&gt; {
     var greet = require('../greetings');
     expect(greet("react")).toBe("hi react");
   });
});</pre></div><p class="calibre7"><span class="strong"><strong class="calibre8">Code __test__/index.test.js (using ES6 syntax)</strong></span></p><div class="informaltable"><pre class="programlisting">import expect from 'expect';
  describe('setup',() =&gt; {
    it('testing the setup is working', () =&gt; {
      expect(true).toEqual(true);
   });
      });</pre></div><div class="mediaobject"><img src="../images/00050.jpeg" alt="The jestTypical example of a Testsuite with Mocha, expect, ReactTestUtils and Babel" class="calibre9"/><div class="caption"><p class="calibre25">A screenshot showing tests using ES6 syntaxes, mocha, and babel</p></div></div><p class="calibre10"> </p><p class="calibre7">Executing <a id="id290" class="calibre1"/>this test file using ES6 syntaxes with the<a id="id291" class="calibre1"/> mocha testing framework, expect assertion library<a id="id292" class="calibre1"/> and after been transpiled by Babel <a id="id293" class="calibre1"/>yielded the same result as before.</p></div>
<div class="book" title="Testing with shallow rendering"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec44" class="calibre1"/>Testing with shallow rendering</h1></div></div></div><p class="calibre7"><span class="strong"><strong class="calibre8">Shallow rendering</strong></span> is <a id="id294" class="calibre1"/>a method used while testing React <a id="id295" class="calibre1"/>components in which the component is "one level deep". Such a shallow-rendered test component has the facts regarding the returned things with respect to the <code class="literal">render</code> methods. Such components do not have the child components attached to it, and it does not require DOM.</p><p class="calibre7">Thus, while testing with a shallow rendering method, it should be remembered that any changes in the parent component that has the DOM changes and/or any child components been changed may require in rewriting the test.</p><p class="calibre7">Let's explore this with help of some code. In the following example, we will be creating a React component (<code class="literal">GreetingComponent</code>) where the <code class="literal">render</code> method will return a <code class="literal">div</code> with two children (<code class="literal">h2</code> and <code class="literal">span</code> elements).</p><p class="calibre7">The code of <code class="literal">greeting.js</code>:</p><div class="informaltable"><pre class="programlisting">// greeting.js

import React from 'react';

const { div, h2, span} = React.DOM;



export default React.createClass({

  displayName: 'GreetingComponent',

  render(){

    return(

    div({classname: 'Greeting'},

      h2({classname: "heading2"}, "Hi"),

      span({classname: "like"},"ReactJs")

    )

    );

  }

});</pre></div><p class="calibre7">Let's <a id="id296" class="calibre1"/>write the test for this React code using the shallow rendering method.</p><p class="calibre7"><span class="strong"><strong class="calibre8">Code of __test__/greeting.test.js</strong></span></p><div class="informaltable"><pre class="programlisting">// Importing the necessary libraries and JavaScript code to be tested
import expect from 'expect';
import React from 'react';
import TestUtils from 'react-addons-test-utils';
import GreetingComponent from '../greetings.js';
describe('GreetingComponent', () =&gt; {
  it('should greet with the name', () =&gt; {

// Creating a shallow rendered object and stored within  renderer
    const renderer = TestUtils.createRenderer();

/*creating the react element (GreetingComponent, declared in the greeting.js code). This might be comparable to the "place" where the component to be tested is rendered. This component can respond to events and update itself
*/
    renderer.render(React.createElement(GreetingComponent));
/* method is called on the renderer (TestUtils.createRenderer()) and stored within output. We can inspect this output in the console */
    const output = renderer.getRenderOutput();
    console.log(output);
    expect(output.type).toBe('div');</pre></div><p class="calibre7">The output value is printed in the console. Based on that, we can see the different hierarchy and values of the concerned react component. The following is output from <code class="literal">console.log</code> (output)</p><div class="mediaobject"><img src="../images/00051.jpeg" alt="Testing with shallow rendering" class="calibre9"/><div class="caption"><p class="calibre25">The screenshot showing the renderedOutput() method in the console.</p></div></div><p class="calibre10"> </p><p class="calibre7">Let's go <a id="id297" class="calibre1"/>a level deep and check the value of the following: <code class="literal">const output = renderer.getRenderOutput().props.children</code>.</p><p class="calibre7">Thus, we can see the exact two children with their types and values of the <code class="literal">GreetingComponent</code> React <code class="literal">div</code> element:</p><div class="mediaobject"><img src="../images/00052.jpeg" alt="Testing with shallow rendering" class="calibre9"/><div class="caption"><p class="calibre25">The screenshot showing the renderedOutput() method of the children in the console.</p></div></div><p class="calibre10"> </p><p class="calibre7">Based <a id="id298" class="calibre1"/>on the output, we can test both the children (<code class="literal">h2</code> and <code class="literal">span</code>) of the <code class="literal">div</code> element of the React <code class="literal">GreetingComponent</code> as follows:</p><div class="informaltable"><pre class="programlisting">
<span class="strong"><strong class="calibre8">Code of __test__/greeting.test.js</strong></span>
import React from 'react';
import TestUtils from 'react-addons-test-utils';
import GreetingComponent from '../greetings.js';

describe('GreetingComponent', () =&gt; {


  it('should greet with the greeting Hi', () =&gt; {

    const renderer = TestUtils.createRenderer();
    renderer.render(React.createElement(GreetingComponent));
    const output = renderer.getRenderOutput();
    console.log(output);
    expect(output.type).toBe('div');

<span class="strong"><strong class="calibre8">    expect(output.props.children[0].type).toBe('h2');</strong></span>
<span class="strong"><strong class="calibre8">    expect(output.props.children[0].props.classname).toBe('heading2');</strong></span>
<span class="strong"><strong class="calibre8">    expect(output.props.children[0].props.children).toBe('Hi');</strong></span>

  });



  it('should return the like as ReactJs', () =&gt; {

    const renderer = TestUtils.createRenderer();

    renderer.render(React.createElement(GreetingComponent));

    const output = renderer.getRenderOutput();

    console.log(output);

<span class="strong"><strong class="calibre8">    expect(output.type).toBe('div');</strong></span>

<span class="strong"><strong class="calibre8">    expect(output.props.children[1].type).toBe('span');</strong></span>

<span class="strong"><strong class="calibre8">    expect(output.props.children[1].props.classname).toBe('like');</strong></span>

<span class="strong"><strong class="calibre8">    expect(output.props.children[1].props.children).toBe('ReactJs');</strong></span>

  });


});</pre></div><p class="calibre7">We <a id="id299" class="calibre1"/>can see that there are several lines of codes that are common between the two <code class="literal">it</code> blocks. Hence, we can separate these common codes and refactor it as shown here:</p><div class="informaltable"><pre class="programlisting">// __tests__/sum-test.js

//jest.dontMock('../greetings.js');

import expect from 'expect';
import React from 'react';
import TestUtils from 'react-addons-test-utils';
import GreetingComponent from '../greetings.js';

describe('GreetingComponent', () =&gt; {
  describe('Common code', () =&gt; {
    const renderer = TestUtils.createRenderer();
    renderer.render(React.createElement(GreetingComponent));
    const output = renderer.getRenderOutput();
//    console.log(renderer);
    console.log("From Common Code");
    console.log(output);


  it('should greet with the greeting Hi', () =&gt; {
//    console.log(renderer);
    console.log("h2 component");
    console.log(output);
    expect(output.props.children[0].type).toBe('h2');
  expect(output.props.children[0].props.classname).toBe('heading2');
    expect(output.props.children[0].props.children).toBe('Hi');
  });

  it('should return the like as ReactJs', () =&gt; {
//    console.log(renderer);
    console.log("span component");
    console.log(output);

    expect(output.props.children[1].type).toBe('span');

    expect(output.props.children[1].props.classname).toBe('like');

    expect(output.props.children[1].props.children).toBe('ReactJs');

  });



});

});</pre></div><p class="calibre7">While <a id="id300" class="calibre1"/>executing the code, we can get the output in a file, with the following command:</p><div class="informaltable"><pre class="programlisting">
<span class="strong"><strong class="calibre8">npm test &gt; test_output.txt</strong></span>
</pre></div><p class="calibre7">The following is the output in the <code class="literal">test_output.txt</code> file. You can play and check the different properties of the React elements. The explanation of each of them is beyond the scope<a id="id301" class="calibre1"/> of this book. But we can see that all React components are nothing but JavaScript objects.</p><div class="mediaobject"><img src="../images/00053.jpeg" alt="Testing with shallow rendering" class="calibre9"/></div><p class="calibre10"> </p></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec45" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">We saw how we can test the different components in a React-based application and JavaScript as whole. In order to test a JavaScript code, we used chai and expect as assertion libraries, jasmine and jest as testing frameworks. To test a React application, we used ReactTestUtils and shallow rendering. In the following chapter, you will be learning about the deployment process of a React application. We will be exploring more about <code class="literal">package.json</code>, which we touched on in this chapter.</p></div></body></html>