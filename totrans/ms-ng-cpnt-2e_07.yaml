- en: Components for User Experience
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户体验组件
- en: User experience should be a core concern for developers building today's applications.
    We are no longer living in a world where users are content with an application
    that simply works. The expectations are now much higher. An application needs
    to be highly usable, and should provide an efficient workflow; users even expect
    it to bring them pleasure when performing tasks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于今天构建应用程序的开发者来说，用户体验应该是一个核心关注点。我们不再生活在一个用户对仅仅能工作的应用程序就感到满意的世界里。现在的期望要高得多。一个应用程序需要高度可用，并且应该提供高效的流程；用户甚至期望它在执行任务时能给他们带来愉悦。
- en: In this chapter, we're going to look at building some components that will increase
    the overall usability of our task management system. These features will enrich
    the current functionality and provide more efficient workflows.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨构建一些组件，这些组件将提高我们任务管理系统的整体可用性。这些特性将丰富当前的功能并提供更高效的流程。
- en: 'We will develop the following two technical features and embed them into our
    current application, wherever applicable:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发以下两个技术特性，并将它们嵌入到我们当前的应用程序中， wherever applicable：
- en: '**Tag management**: We''ll enable the use of tags within generated content,
    such as comments, activities, and other areas where they can be of use. Tags will
    help users build links between content and navigation shortcuts.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签管理**：我们将启用在生成内容（如评论、活动和其他可能有用的地方）中使用标签的功能。标签将帮助用户在内容和导航快捷方式之间建立链接。'
- en: '**Drag and drop**: We''ll build generic components that will make the using
    drag and drop features a breeze. By enabling drag and drop features, we''ll allow
    users to fulfill certain tasks with much higher efficiency.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拖放**：我们将构建通用的组件，使使用拖放功能变得轻而易举。通过启用拖放功能，我们将允许用户以更高的效率完成某些任务。'
- en: 'We''ll cover the following topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating a tag management system to enter and display tags
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个标签管理系统以输入和显示标签
- en: Creating a stateful pipe to render tags using a service
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务渲染标签创建一个有状态的管道
- en: Creating a component to autocomplete tags during user input
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个组件，在用户输入时自动完成标签
- en: Using the `read` property on a `ViewChild` decorator to query for directive
    instances
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ViewChild`装饰器上的`read`属性来查询指令实例
- en: Going through the basics of the HTML5 drag and drop API
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握HTML5拖放API的基础
- en: Creating directives for draggable elements and drop targets
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为可拖动元素和拖放目标创建指令
- en: Using `dataTransfer` objects and a custom attribute to enable selective drop
    targets
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`dataTransfer`对象和自定义属性来启用选择性拖放目标
- en: Tag management
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签管理
- en: The classic form of tagging enables you to establish a taxonomy within a system.
    It helps you to organize your content. It allows you to have a many-to-many association
    that can be managed quickly, and you can use it later to filter relevant information.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的标签形式允许你在系统中建立分类法。它帮助你组织内容。它允许你有一个可以快速管理的多对多关联，你可以在以后用它来过滤相关信息。
- en: In our task management system, we're going to use a slightly different version
    of tags. Our goal is to provide a way to allow semantic shortcuts within the application.
    With the help of tags, a user should be able to cross-reference information between
    different parts of the data, providing a summary of the referenced entity, as
    well as a navigation shortcut.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的任务管理系统里，我们将使用一个略有不同的标签版本。我们的目标是提供一个在应用程序内允许语义快捷方式的方法。借助标签，用户应该能够在不同部分的数据之间交叉引用信息，提供所引用实体的摘要以及导航快捷方式。
- en: For example, we can include a project tag within a user comment. A user can
    enter the tag by simply typing in the project ID. When a comment is displayed,
    we will see the title of the project, and when we click on the tag, we can directly
    navigate to the project detail page where the task is located.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在用户评论中包含一个项目标签。用户可以通过简单地输入项目ID来输入标签。当评论显示时，我们将看到项目的标题，当我们点击标签时，我们可以直接导航到任务所在的项目详情页面。
- en: In this section, we'll develop the required system of components to provide
    a way to use project tags to cross-reference other projects within comments. We'll
    also use tag management in our activities, which we created in the previous chapter,
    *Keeping up with Activities*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发所需的组件系统，以提供一种使用项目标签在评论中交叉引用其他项目的方法。我们还将使用标签管理，这是我们在上一章“跟上活动”中创建的。
- en: A model for our tags
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们标签的模型
- en: 'Let''s start with a tag model to represent tags within our system. Open up
    our model module file, located in `src/app/model.ts`, and add the following interface:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从表示我们系统中标签的标签模型开始。打开位于`src/app/model.ts`的模型模块文件，并添加以下接口：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This interface represents tags; whenever we store tag information, we''ll use
    this interface. Let''s look at the individual fields and elaborate on their use:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口表示标签；每次我们存储标签信息时，我们都会使用此接口。让我们看看各个字段并详细说明它们的使用：
- en: '`hashTag`: This is the text representation of a tag. All of our tags need to
    be identified uniquely, using this text representation. We can define the text
    representation of tags as follows:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hashTag`：这是标签的文本表示。我们需要使用此文本表示来唯一标识所有标签。我们可以将标签的文本表示定义为如下：'
- en: Hashtags always start with a hash symbol (`#`).
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签符号始终以井号符号（`#`）开头。
- en: Hashtags only contain word characters or the minus symbol (`-`).
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签符号只包含字母字符或减号符号（`-`）。
- en: All other details of a tag, defined by the properties `title`, `link`, and `type`,
    can be somehow derived from the `hashTag` property. The hashtag can, therefore,
    be considered a unique identifier.
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签的所有其他细节，由`title`、`link`和`type`属性定义，都可以从`hashTag`属性中推导出来。因此，标签符号可以被认为是一个唯一的标识符。
- en: '`title`: This is a comparatively longer text representation of a tag. It should
    contain as much detail about the subject as possible. In the case of project tags,
    this could mean the project title, open tags count, assignee, and other important
    information. Since this is the field that will be rendered if a tag is presented
    to the user, it''ll be beneficial if the content stays relatively condensed.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：这是标签的比较长的文本表示。它应该包含尽可能多的关于主题的细节。在项目标签的情况下，这可能意味着项目标题、开放标签计数、分配者和其他重要信息。由于这是如果标签呈现给用户时将被渲染的字段，因此保持内容相对紧凑将是有益的。'
- en: '`link`: A valid URL, which will be used when the tag is rendered. This URL
    will make links clickable and enable shortcut navigation. In the case of the project
    tags we''re going to create, this will be a URL that will link to the given project
    view.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`link`：一个有效的URL，当标签被渲染时将使用它。此URL将使链接可点击并启用快捷导航。在我们将要创建的项目标签的情况下，这将是一个链接到给定项目视图的URL。'
- en: '`type`: This is used to distinguish between different tags and provide us with
    a way to organize tags at a higher granularity level.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：用于区分不同的标签，并为我们提供一种在更高粒度级别组织标签的方法。'
- en: So far, so good. We now have a data model that we can use to transfer information
    about tags.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。我们现在有一个数据模型，我们可以用它来传输关于标签的信息。
- en: Creating a tags service
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建标签服务
- en: 'The next step for implementing our tagging system is to write a tags service.
    The service will be responsible for gathering all possible tags within our application.
    The list of available tags can then be shown to the user within our editor component.
    That way, the user can add tags to comments and other editable fields within our
    application. The tags service should also be used to convert text that contains
    simple hashtags into HTML. That way, tags can be rendered to links, which allow
    us to navigate to detail views within our application. The responsibilities of
    our tags service can be divided into two main areas. Let''s look at these responsibilities
    in detail:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 实现我们的标签系统的下一步是编写标签服务。该服务将负责收集我们应用程序中所有可能存在的标签。然后，可以在我们的编辑器组件中向用户展示可用的标签列表。这样，用户就可以在我们的应用程序中添加标签到评论和其他可编辑字段。标签服务还应用于将包含简单标签符号的文本转换为HTML。这样，标签可以渲染为链接，允许我们在应用程序中导航到详细视图。我们的标签服务的责任可以分为两大主要领域。让我们详细看看这些责任：
- en: '**Providing a list of tags**: For the moment, we only want to enable projects
    within our tagging system. Therefore, our tagging service needs to create one
    project tag for every project within our project service. This system will be
    extensible, and other sources for tags can easily be implemented.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供标签列表**：目前，我们只想在我们的标签系统中启用项目。因此，我们的标签服务需要为我们的项目服务中的每个项目创建一个项目标签。这个系统将是可扩展的，其他标签来源可以轻松实现。'
- en: '**Parsing and rendering tags**: The parsing functionality of the tags service
    is responsible for finding hashtags within an input string. While parsing the
    input string, the service will check for matching tags, and then use the `title`
    and `link` fields of the tag objects to render their HTML representations.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解析和渲染标签**：标签服务的解析功能负责在输入字符串中查找哈希标签。在解析输入字符串时，服务将检查匹配的标签，然后使用标签对象的 `title`
    和 `link` 字段来渲染它们的HTML表示。'
- en: 'Let''s use the Angular CLI tool to create the stubs of our new service:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Angular CLI 工具来创建我们新服务的占位符：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s add the following code as a starting point for our service:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加以下代码作为我们服务的起点：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `tags` member of our tags service class is an observable,with the generic
    type `Tag[]`. This observable will always emit the most recent list of available
    tags within our application. Within our constructor, we're using the project list
    observable from the project service as a base to convert all projects to project
    tags.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们标签服务类的 `tags` 成员是一个可观察对象，具有泛型类型 `Tag[]`。这个可观察对象将始终发出我们应用程序中可用的最新标签列表。在我们的构造函数中，我们使用项目服务中的项目列表可观察对象作为基础，将所有项目转换为项目标签。
- en: In the case of projects, we set the type of our tag object to `'project'`. In
    a later stage of our project, we can also use sources other than projects to generate
    tags, but for the moment, we're only concerned about projects.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的情况下，我们将我们的标签对象的类型设置为 `'project'`。在我们项目的后期阶段，我们也可以使用除项目之外的其他来源来生成标签，但就目前而言，我们只关注项目。
- en: For the `hashTag` property, we're using the prefix `'#project-` and appending
    the ID of the project. That way, our hashtags can be identified as project tags,
    and by using the appended ID, we can also identify exactly which project is referenced.
    For the `title` field, we used a helper function, `limitWithEllipsis`, which truncates
    project titles that are longer than 20 characters. For the `link` field of the
    tag object, we specify the URL that will navigate to the project details view.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `hashTag` 属性，我们使用前缀 `'#project-'` 并附加项目的ID。这样，我们的标签可以被识别为项目标签，并且通过附加的ID，我们还可以确定引用的是哪个具体项目。对于
    `title` 字段，我们使用了一个辅助函数 `limitWithEllipsis`，该函数会截断超过20个字符的项目标题。对于标签对象的 `link` 字段，我们指定了将导航到项目详情视图的URL。
- en: Rendering tags
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染标签
- en: We now have a service that uses a reactive approach to generate tags from the
    available projects. This already addresses the first concern of our service. Let's
    look at its other responsibility, which is parsing text content for tags and rendering
    HTML.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个使用响应式方法从可用项目中生成标签的服务。这已经解决了我们服务的第一个问题。让我们看看它的其他责任，即解析文本内容以查找标签并渲染HTML。
- en: 'Before we start writing our parse method in the tags service, we need to create
    a small utility function for string replacement. Open the file `src/app/utilities/string-utilities.ts`,
    where we have already created our `limitWithEllipsis` function, and add the following
    code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始在标签服务中编写 `parse` 方法之前，我们需要创建一个用于字符串替换的小型实用函数。打开文件 `src/app/utilities/string-utilities.ts`，其中我们已经创建了
    `limitWithEllipsis` 函数，并添加以下代码：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding method uses a small JavaScript trick to replace all occurrences
    of a string with another string. Unfortunately, that's not possible with the default
    `replace` function on strings.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法使用了一个小的JavaScript技巧来替换字符串中所有出现的字符串。不幸的是，这不可能使用字符串的默认 `replace` 函数。
- en: 'Let''s move on with our tags service. Rendering tags is not a big deal, since
    we have already abstracted the data model of tags in a clean way. Since tags have
    URLs that point to a location, we''re going to use anchor HTML elements to represent
    our tags. These elements also have classes that will help us style tags differently
    than regular content. Let''s create another method within the tags service that
    can be used to parse text, recognize tags within the text content, and render
    them into HTML. Open up the tags service file located in `src/app/tags/tags.service.ts`,
    and apply the following changes:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续我们的标签服务。渲染标签并不是什么大问题，因为我们已经以一种干净的方式抽象了标签的数据模型。由于标签有指向位置的URL，我们将使用锚点HTML元素来表示我们的标签。这些元素还具有帮助我们以不同于常规内容的样式来样式化标签的类。让我们在标签服务中创建另一个方法，该方法可以用于解析文本，识别文本内容中的标签，并将它们渲染成HTML。打开位于
    `src/app/tags/tags.service.ts` 的标签服务文件，并应用以下更改：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s quickly recap the preceding changes and look at the `parse` method step
    by step:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾前面的更改，并逐步查看 `parse` 方法：
- en: First, we're searching the text content that was passed into the `parse` method
    for hashtags and storing the list of discovered hashtags into a variable called
    `hashTags`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在传递给 `parse` 方法的文本内容中搜索标签，并将发现的标签列表存储在一个名为 `hashTags` 的变量中。
- en: If no hashtags have been discovered, we immediately return a new observable
    stream with the original text content that was passed into the method. We're using
    the RxJS `of` helper to do so.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有发现任何标签，我们立即返回一个包含传递给方法的原文本内容的新可观察流。我们使用RxJS的 `of` 辅助函数来完成这个操作。
- en: The next step is to render all discovered hashtags with the corresponding tag
    objects within our service. We don't store tags directly within our service, but
    rather, we use an observable stream to convert different sources into tags. We
    use a `map` operator to obtain the list of tags, and then render all discovered
    hashtags into HTML.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在我们的服务中渲染所有发现的标签与相应的标签对象。我们不会直接在我们的服务中存储标签，而是使用一个可观察的流将不同的来源转换为标签。我们使用 `map`
    操作符来获取标签列表，然后将所有发现的标签渲染到HTML中。
- en: We are using `Array.prototype.forEach` to iterate through all discovered hashtags
    within the initial text content. We are then trying to find a matching tag object
    within the list of available project tags. We do that by simply comparing the
    hashtag found within the text to the `hashTag` property on our tag objects.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `Array.prototype.forEach` 来遍历初始文本内容中的所有发现的标签。然后我们尝试在可用项目标签列表中找到一个匹配的标签对象。我们通过简单地比较文本中找到的标签与我们的标签对象上的
    `hashTag` 属性来完成这个操作。
- en: If a matching tag was found, we use our newly created `replaceAll` helper function
    to replace all occurrences of a given hashtag with a rendered HTML version of
    that tag. We're using the tag object's `type`, `link`, and `title` fields to render
    an anchor HTML element.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到了匹配的标签，我们使用我们新创建的 `replaceAll` 辅助函数来替换所有给定标签的所有出现，并用该标签的渲染HTML版本来替换。我们使用标签对象的
    `type`、`link` 和 `title` 字段来渲染一个锚点HTML元素。
- en: After all hashtags have been replaced with the HTML versions of those tags,
    we're returning the rendered HTML content from the observable mapping function.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有标签都被替换为这些标签的HTML版本之后，我们从可观察的映射函数中返回渲染的HTML内容。
- en: That's it for our tags service. As a next step, we will create a pipe that will
    use our service to render tags directly within the view of components.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的标签服务的全部内容。作为下一步，我们将创建一个管道，该管道将使用我们的服务直接在组件视图中渲染标签。
- en: Integrating tags using a pipe
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用管道集成标签
- en: All of the concerns of our task service have now been taken care of, and it
    is already storing tags for available projects. We can now go ahead and integrate
    our service into the application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务服务的所有问题现在都已经得到解决，并且它已经开始为可用的项目存储标签。现在我们可以继续将我们的服务集成到应用程序中。
- en: Since our tags service turns text with simple hashtags into HTML with links,
    a pipe would be a perfect helper to integrate the functionality within our components.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的标签服务将带有简单标签的文本转换为带有链接的HTML，因此管道将是一个完美的辅助工具，用于在组件中集成该功能。
- en: 'Let''s create a new pipe by using the Angular CLI tool:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Angular CLI工具创建一个新的管道：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Open up the generated file, located in `src/app/pipes/tags.pipe.ts`, and add
    the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于 `src/app/pipes/tags.pipe.ts` 的生成文件，并添加以下代码：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have already created a few pipes. However, this pipe is a bit different,
    in that it isn't a pure pipe. Pipes are considered pure if their `transform` function
    always returns the same output for a given input. This implies that the `transform`
    function should not be dependent on any other external source that can influence
    the outcome of the transform, and the only dependencies are the input values.
    This is not true for our tags pipe, though. It depends on the tags service to
    transform the input, and new tags can be stored in the tags service at any time.
    Successive transformations can successfully render tags that were non-existent
    just a moment ago.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一些管道。然而，这个管道有点不同，因为它不是一个纯管道。如果管道的 `transform` 函数总是对给定的输入返回相同的输出，则认为管道是纯的。这意味着
    `transform` 函数不应依赖于任何其他可能影响转换结果的外部来源，唯一的依赖是输入值。但我们的标签管道并不符合这一点。它依赖于标签服务来转换输入，并且可以在任何时间将新标签存储在标签服务中。连续的转换可以成功渲染刚刚还不存在的标签。
- en: By telling Angular that our pipe is not pure, we can disable the optimization
    it performs on pure pipes. This also means that Angular will need to re-validate
    the output of the pipe on every change detection. This can lead to performance
    issues; therefore, the pure flag should be used with caution.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过告诉Angular我们的管道不是纯的，我们可以禁用它在纯管道上执行的性能优化。这也意味着Angular需要在每次变更检测时重新验证管道的输出。这可能导致性能问题；因此，纯标志应该谨慎使用。
- en: Within our pipe, we're injecting the tags service, which helps us to convert
    simple text into rendered HTML. However, Angular has some security mechanisms
    preventing us from using this HTML string directly within our template. To ensure
    Angular that we know what we're doing here, we can use the DOM sanitizer instance
    to create trusted HTML, which we can then render within `innerHTML` bindings.
    By calling `bypassSecurityTrustHtml` on the sanitizer, passing our generated HTML
    string, we can tell Angular to put aside any security concerns for that instance,
    and we can go ahead and render the HTML within our view.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的管道中，我们注入了标签服务，这有助于我们将简单文本转换为渲染的HTML。然而，Angular有一些安全机制阻止我们直接在模板中使用这个HTML字符串。为了确保Angular我们知道我们在做什么，我们可以使用DOM清理器实例来创建可信的HTML，然后我们可以在`innerHTML`绑定中渲染它。通过在清理器上调用`bypassSecurityTrustHtml`，传递我们的生成的HTML字符串，我们可以告诉Angular对这个实例忽略任何安全担忧，然后我们可以在视图中渲染HTML。
- en: Alright; as far as rendering tags is concerned, we are all set. Let's integrate
    our tags functionality into our editor component so we can make use of them within
    the commenting system.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 好的；就标签的渲染而言，我们已经准备好了。让我们将我们的标签功能集成到我们的编辑组件中，这样我们就可以在注释系统中使用它们。
- en: 'All that we really need to do is include the tags pipe within our editor component
    template. Let''s open the editor template located in `src/app/ui/editor/editor.component.html`,
    and apply the following change:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正需要做的只是在我们编辑组件模板中包含标签管道。让我们打开位于 `src/app/ui/editor/editor.component.html`
    的编辑器模板，并应用以下更改：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The only change that we've made in the template is where we display the editor
    content. We are using a property binding to the `innerHTML` property of our editor's
    output HTML element. This allows us to render the HTML content generated by our
    tags service. Since the tags pipe is returning an observable, we need to chain
    in an async pipe, as well.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模板中做的唯一更改是我们显示编辑器内容的地方。我们正在使用属性绑定到我们的编辑器输出HTML元素的`innerHTML`属性。这允许我们渲染由我们的标签服务生成的HTML内容。由于标签管道返回一个可观察对象，我们需要链式连接一个异步管道。
- en: Congratulations! Your tagging system is already halfway done! We've created
    a tags service that collects available tags within the application, and, together
    with our newly created pipe, renders tags within our editor component. Preview
    your changes within the browser, and try to add hashtags to some comments on the
    comments tab of projects. Currently, we only have two projects within our application.
    Try to add the following hashtag to a comment—`#project-2`—and save the changes
    in the editor. You should now be able to see the rendered tag in the comment.
    If you're editing the comment again, you'll see the hashtag text representation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您的标签系统已经完成了一半！我们已经创建了一个标签服务，它收集应用程序中的可用标签，并且与我们的新创建的管道一起，在编辑组件中渲染标签。在浏览器中预览您的更改，并尝试在项目的注释标签页上添加一些注释的标签。目前，在我们的应用程序中只有两个项目。尝试将以下标签添加到注释中——`#project-2`——并在编辑器中保存更改。现在您应该能够在注释中看到渲染的标签。如果您再次编辑注释，您将看到标签的文本表示。
- en: Let's digress for a moment. We've already created a tagging system, and we just
    integrated it into our editor component by using the tags pipe. If a user writes
    project tags in any comment, they will now be rendered by the tags service. This
    is fantastic! Users can now establish cross-links to other projects within comments,
    which will be automatically rendered as links and show a truncated project title.
    All a user needs to do is add the text representation of a project tag to a comment.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时偏离一下主题。我们已经创建了一个标签系统，并且我们刚刚通过使用标签管道将其集成到我们的编辑组件中。如果用户在任何注释中写入项目标签，它们现在将由标签服务渲染。这太棒了！用户现在可以在注释中建立与其他项目的交叉链接，这些链接将自动渲染为链接并显示截断的项目标题。用户需要做的只是将项目标签的文本表示添加到注释中。
- en: 'The following two screenshots illustrate an example of the commenting system.
    The first screenshot is an example of an editor in edit mode, under the commenting
    system, where a text tag is entered:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个截图展示了注释系统的示例。第一个截图是编辑模式下编辑器的示例，在注释系统中输入了一个文本标签：
- en: '![](img/0ec45e75-11b4-4519-b27e-391838c1857a.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ec45e75-11b4-4519-b27e-391838c1857a.png)'
- en: An example of when a text tag is entered
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文本标签的一个示例
- en: 'The second screenshot is an example of a rendered tag enabled in the commenting
    system through our editor integration:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个截图是使用我们的编辑器集成在评论系统中启用渲染标签的一个示例：
- en: '![](img/48ce0d4d-6eb6-4901-b11b-f3a9dc82813e.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48ce0d4d-6eb6-4901-b11b-f3a9dc82813e.png)'
- en: An example of a rendered tag through editor integration
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编辑器集成渲染标签的一个示例
- en: 'In this section, we looked at the following concepts:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了以下概念：
- en: We built a tags service that generates, caches, and renders tags
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们构建了一个标签服务，它可以生成、缓存和渲染标签
- en: We built a stateful pipe using the `pure` flag
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`pure`标志构建了一个有状态的管道
- en: We used the `[innerHTML]` property binding to render HTML content into an element
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了`[innerHTML]`属性绑定来将HTML内容渲染到元素中
- en: We used the DOM sanitizer to bypass security checks when using `innerHTML` bindings
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了DOM清理器来绕过使用`innerHTML`绑定时的安全检查
- en: We're not done yet, when it comes to entering tags. We cannot expect our users
    to know all of the available tags within the system and then enter them manually
    within comments. Let's look at how we can improve this in the next section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成标签输入的工作。我们不能期望我们的用户知道系统中所有可用的标签，然后手动在评论中输入它们。让我们看看在下一节中我们如何改进这一点。
- en: Supporting tag input
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持标签输入
- en: Here, we're going to build a component (and its supporting structures) to make
    the process of entering tags a smooth experience for our users. So far, they can
    write project tags, but it requires them to know the project IDs, which makes
    our tag management quite useless. What we'd like to do is provide the user with
    some choices when they are about to write a tag. Ideally, we will show them the
    available tags as soon as they start writing a tag by typing the hash (`#`) symbol.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将构建一个组件（及其支持结构），以使用户输入标签的过程变得顺畅。到目前为止，他们可以编写项目标签，但这需要他们知道项目ID，这使得我们的标签管理变得毫无用处。我们希望提供一些选择，当用户准备编写标签时。理想情况下，我们将显示可用的标签，一旦他们开始通过输入哈希符号（`#`）编写标签。
- en: 'What sounds simple at first is actually a quite tricky thing to implement.
    Our tag input needs to deal with the following challenges:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 起初听起来很简单的事情实际上是一个相当棘手的问题。我们的标签输入需要处理以下挑战：
- en: Handling input events to monitor tag creation. Somehow, we need to know when
    a user starts writing a tag, and we need to know when the typed tag name is updated
    or cancelled by using an invalid tag character.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理输入事件以监控标签创建。我们需要知道用户何时开始编写标签，以及当使用无效的标签字符时，输入的标签名称何时被更新或取消。
- en: Calculating the position of the input caret of the user. Yeah, I know this sounds
    pretty simple, but it actually isn't. Calculating the viewport offset position
    of a user's input caret requires the use of the browser's Selection API, which
    is quite low-level and needs some abstraction.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算用户输入光标的位置。是的，我知道这听起来很简单，但实际上并不是。计算用户输入光标的视口偏移位置需要使用浏览器的Selection API，这是一个相当底层的API，需要一些抽象。
- en: In order to tackle these challenges, we are going to introduce a utility directive
    that we can use to handle those rather complicated low-level user input events.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这些挑战，我们将引入一个实用指令，我们可以使用它来处理那些相当复杂的底层用户输入事件。
- en: Creating a tag input directive
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个标签输入指令
- en: Since recognizing hashtags within user input is not such a simple task, we're
    going to create a directive that helps us with that. This is actually our first
    directive that we're creating together! If you remember from [Chapter 1](72fc993e-43db-48eb-8797-c65ea9226b87.xhtml),
    *Component-Based User Interfaces*, directives are there to create custom behaviors
    without the need for an own view. Our tags input directive will collect and recognize
    hashtags from user input, but it does not actually render its own view.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在用户输入中识别标签并不是一个简单的任务，我们将创建一个指令来帮助我们完成这个任务。这实际上是我们共同创建的第一个指令！如果你还记得[第1章](72fc993e-43db-48eb-8797-c65ea9226b87.xhtml)中的*组件化用户界面*，指令是用来创建自定义行为而不需要自己视图的。我们的标签输入指令将收集并识别用户输入中的标签，但它实际上并不渲染自己的视图。
- en: 'Let''s add two more interfaces to our model file in `src/app/model.ts`, to
    help us communicate hashtag user input:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`src/app/model.ts`中的模型文件中添加两个更多接口，以帮助我们与标签用户输入进行通信：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For every user input that is recognized as hashtag input by our directive,
    we will communicate using hashtag input objects. Besides the actual text content
    of the hashtag, we''re also sending an input position that consists of the following
    properties:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们指令识别为hashtag输入的每个用户输入，我们将使用hashtag输入对象进行通信。除了hashtag的实际文本内容外，我们还发送一个由以下属性组成的输入位置：
- en: '`top` and `left`: Represent the top and left screen, offset in pixels of the
    caret position where the actual input happened.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`top` 和 `left`: 表示光标位置的实际输入发生的屏幕顶部和左侧，以像素为单位。'
- en: '`caretOffset`: Describes the character offset of the hashtag within the text
    content of the editable element. This will be useful when we want to replace the
    hashtag within the editable element and achieve a feeling of autocomplete.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`caretOffset`: 描述了在可编辑元素的文本内容中，hashtag的字符偏移量。当我们要在可编辑元素中替换hashtag并实现自动完成的感觉时，这将非常有用。'
- en: 'From the `top` and `left` properties of the `InputPosition` interface, you
    can see that we want to compute the coordinates where the actual user input happened.
    This sounds very trivial, but it actually isn''t. To help us with that computation,
    we''re going to introduce a new helper function, which we''re creating within
    a new file, on the path `src/app/utilities/dom-utilities.ts`. Create that new
    file and add the following content:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从`InputPosition`接口的`top`和`left`属性中，你可以看到我们想要计算实际用户输入发生的坐标。这听起来非常简单，但实际上并非如此。为了帮助我们进行这个计算，我们将引入一个新的辅助函数，我们将在一个新文件中创建这个函数，路径为`src/app/utilities/dom-utilities.ts`。创建这个新文件并添加以下内容：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's not get into too much detail here. What this code basically does is try
    to find the bounding box `DOMRect` object, which describes the `top`, `right`,
    `bottom`, and `left` offsets of the caret position, relative to the viewport.
    The problem is that the Selection API does not allow us to get the position of
    the caret directly; it only allows us to get the position of the current selection.
    If the caret is not placed correctly, we will need to insert a dummy element at
    the location of the caret and return the bounding box `DOMRect` object of the
    dummy element. Of course, we'll need to remove the dummy element again, before
    we return the `DOMRect` object.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们就不深入细节了。这段代码基本上是尝试找到描述光标位置相对于视口的`top`、`right`、`bottom`和`left`偏移量的`DOMRect`对象，即边界框。问题是，Selection
    API不允许我们直接获取光标的位置；它只允许我们获取当前选择的位置。如果光标放置不正确，我们需要在光标位置插入一个虚拟元素，并返回虚拟元素的边界框`DOMRect`对象。当然，在返回`DOMRect`对象之前，我们需要再次移除虚拟元素。
- en: 'So, that''s all that we need to write our tags input directive. Let''s use
    the Angular CLI to create our first directive. The command to create directives
    is very similar to that to create components:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是我们需要编写的标签输入指令的所有内容。让我们使用Angular CLI创建我们的第一个指令。创建指令的命令与创建组件的命令非常相似：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'That generated the stub for our new directive. Let''s open the file `src/app/tags/tags-input.directive.ts`,
    and add the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成了我们新指令的存根。让我们打开文件`src/app/tags/tags-input.directive.ts`，并添加以下代码：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The private `hashTagInput` property is an internal state to store the current
    hashtag input information. The `hashTagSubject` member is a behavior subject,
    which we're using internally to publish hashtag input changes. We're using the
    `asObservable` method on the subject to expose an observable stream that emits
    hashtag input objects on every change. We're storing this derived observable stream
    in the member `hashTagChange`, which has public visibility. Other components can
    access this property and subscribe to get notified when there are hashtag input
    events.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 私有`hashTagInput`属性是一个内部状态，用于存储当前的hashtag输入信息。`hashTagSubject`成员是一个行为主题，我们内部使用它来发布hashtag输入更改。我们使用主题上的`asObservable`方法来公开一个可观察的流，该流在每次更改时都会发出hashtag输入对象。我们将这个派生可观察流存储在具有公共可见性的`hashTagChange`成员中。其他组件可以访问这个属性并订阅，以便在hashtag输入事件发生时得到通知。
- en: 'Let''s now add more parts to our directive, piece by piece. Let''s first add
    a reset method, which we can call when the hashtag input should be reset. This
    method will be used internally, when an input is aborted, but can also be called
    from outside, from another component, to abort tag entry:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐步添加更多到我们的指令中。首先，让我们添加一个重置方法，当hashtag输入应该被重置时我们可以调用这个方法。这个方法将在内部使用，当输入被取消时，也可以从外部，从另一个组件中调用，以取消标签输入：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The next method is used to update the internal hashtag input object, based
    on user input:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法用于根据用户输入更新内部hashtag输入对象：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s add the two main methods to our tags input directive, to collect
    user input. We''re using the `HostListener` decorator to create event bindings
    on the host element for `keydown` and `keypress` events:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向我们的标签输入指令添加两个主要方法，以收集用户输入。我们使用 `HostListener` 装饰器在宿主元素上创建 `keydown` 和
    `keypress` 事件的绑定：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `keyDown` method will be called by the host event binding to `keydown`
    events. We are concerned about the backspace, which should also remove the last
    character of the tag that is currently entered. If we can detect a backspace (char
    code `8`), we''re calling our `updateHashTag` method, and updating the current
    hashtag by removing the last character, using the `Array.prototype.slice` function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`keyDown` 方法将由宿主事件绑定调用 `keydown` 事件。我们关注的是退格键，它应该也会移除当前输入的标签的最后字符。如果我们能检测到退格键（字符代码
    `8`），我们将调用我们的 `updateHashTag` 方法，并使用 `Array.prototype.slice` 函数更新当前哈希标签，移除最后一个字符：'
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `keyPress` method is called from the host element event binding on `keypress`
    events. This is where the main logic of this supporting directive lies. Here,
    we handle two different cases:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`keyPress` 方法是在 `keypress` 事件上从宿主元素的事件绑定中调用的。这就是这个支持指令的主要逻辑所在。在这里，我们处理两种不同的情况：'
- en: If the pressed key is a hash symbol, we will start over with a new tag
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果按下的键是哈希符号，我们将从头开始一个新的标签
- en: If the pressed key is not a valid word character or a hash symbol, we will reset
    it to its initial state, which will cancel the tag entry
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果按下的键不是有效的单词字符或哈希符号，我们将将其重置为其初始状态，这将取消标签输入
- en: Any other valid character, we'll add to the current text tag string
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何其他有效字符，我们将添加到当前的文本标签字符串中
- en: 'Add the following code to the tags input directive:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到标签输入指令中：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When a new hashtag is entered (if a user inserts the hash symbol), we will update
    the internal hashtag input object and use our utility function, `getRangeBoundingClientRect`,
    to set the input object's position to the current caret position.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入一个新的哈希标签（如果用户插入哈希符号）时，我们将更新内部哈希标签输入对象，并使用我们的实用函数 `getRangeBoundingClientRect`
    将输入对象的位置设置为当前光标位置。
- en: Okay; now we have all of the support we need to handle tag input. However, we
    still need a way to show the available tags in the tags service to the user. For
    this purpose, we'll create a new tags select component. It will show a list of
    available tags to the user, and will make use of the tag input changes emitted
    by our support directive in order to filter and position the list.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 好的；现在我们有了处理标签输入所需的所有支持。然而，我们仍然需要一个方法来向用户展示标签服务中的可用标签。为此，我们将创建一个新的标签选择组件。它将向用户展示可用标签的列表，并利用我们支持指令发出的标签输入变化来过滤和定位列表。
- en: Creating a tags select component
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个标签选择组件
- en: 'To support the user in finding the right tag, we''ll provide them with a drop-down
    menu with the available tags. To do this, we need to use the hashtag input objects
    emitted by our tags input directive. Let''s briefly look at the requirements of
    this component:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助用户找到正确的标签，我们将提供一个包含可用标签的下拉菜单。为此，我们需要使用我们标签输入指令发出的标签输入对象。让我们简要地看看这个组件的要求：
- en: It should display the available tags gathered from our tags service in a tooltip/callout
    box
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该在工具提示/呼出框中显示从我们的标签服务中收集到的可用标签
- en: It should support a limitation of displayed tags
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该支持显示标签的限制
- en: It should receive a hashtag input object to filter the available tags and to
    position itself using the positional data on the hashtag input object
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该接收一个带标签输入对象，用于过滤可用标签并使用标签输入对象上的位置数据定位自身
- en: It should emit an event once the user clicks on a tag in the listed tags
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该在用户点击列表中的标签时发出一个事件
- en: 'The component should hide if the filter is invalid, or if there are no elements
    matching the filter:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果过滤器无效，或者没有元素匹配过滤器，组件应该隐藏：
- en: '![](img/a8853fa4-31f0-4d42-a5a3-3a51108249f3.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a8853fa4-31f0-4d42-a5a3-3a51108249f3.png)'
- en: Finished tags select component, filtered with user input
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 完成标签选择组件，通过用户输入过滤
- en: 'Let''s start by updating our application model, located in `src/app/model.ts`,
    to include a new interface to be used to communicate tag selection. Add the following
    code to the file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先更新我们的应用程序模型，位于 `src/app/model.ts`，以包括一个用于通信标签选择的新接口。将以下代码添加到文件中：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If a tag gets selected, we want to know which tag object was selected, but also,
    the corresponding hashtag input object should be passed along. This data is required
    so that we can properly react to the selected tag and correctly update the editable
    element.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个标签被选中，我们想知道被选中的是哪个标签对象，同时，相应的标签输入对象也应该传递。这些数据是必要的，以便我们能够正确地响应选中的标签并正确更新可编辑元素。
- en: 'Let''s move on with our component, and create the component class. First, let''s
    scaffold a new component using the Angular CLI:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续我们的组件，并创建组件类。首先，让我们使用Angular CLI构建一个新的组件：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will generate a new component, where we''ll opening the component class
    file, located in `src/app/tags/tags-select/tags-select.component.ts`, and add
    the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个新的组件，我们将打开位于`src/app/tags/tags-select/tags-select.component.ts`的组件类文件，并添加以下代码：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our component has two input elements. The `tags` input is used to pass all available
    tags into the tags select component. This is the list of tags that will be presented
    to the user when selecting available tags. The `hashTagInput` input is the hashtag
    input object that we obtain from the tags input directive we create previously.
    We will extract the current user input from that object in order to filter the
    displayed tags. We will also use the position data from that object to position
    the component onto the screen coordinates of the caret position where the user
    started to write the hashtag input.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件有两个输入元素。`tags`输入用于将所有可用的标签传递到标签选择组件中。这是当用户选择可用标签时将展示给用户的标签列表。`hashTagInput`输入是我们从之前创建的标签输入指令中获取的标签输入对象。我们将从该对象中提取当前用户输入以过滤显示的标签。我们还将使用该对象的位置数据将组件定位到用户开始编写标签输入的插入点屏幕坐标。
- en: The output `outSelectTag` is used to emit an event when a user selects a tag
    from the list of tags. The `filteredTags` property is used for the computed filtered
    list of tags. We're calling the `filterTags` method when there's a change in the
    `hashTagInput` or `tags` input objects. Here, we're filtering the list of all
    tags with the current hashtag input data that we have. Since this is only a computed
    state, our component is still a pure component, and we can still use the `OnPush`
    change detection strategy.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 输出`outSelectTag`用于在用户从标签列表中选择标签时发出事件。`filteredTags`属性用于计算过滤后的标签列表。当`hashTagInput`或`tags`输入对象发生变化时，我们调用`filterTags`方法。在这里，我们使用当前标签输入数据过滤所有标签列表。由于这只是一个计算状态，我们的组件仍然是一个纯组件，我们仍然可以使用`OnPush`变更检测策略。
- en: The `selectTag` method is called from the view when the user selects a tag from
    the list of filtered tags. There, we're emitting a new tag selection object that
    consists of the selected tag, as well as the hashtag input object.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户从过滤后的标签列表中选择标签时，会从视图中调用`selectTag`方法。在那里，我们发出一个新的标签选择对象，该对象包含选中的标签以及标签输入对象。
- en: 'Let''s move on and add a few accessor properties to our component, which we''re
    using to create host element style bindings. The following accessor property—`hasFilteredTags`—is
    bound to the host element''s display style property. It will control whether the
    component is displayed or hidden. We will only display the component if the filter
    is valid and the filtered tags contain at least one tag:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续并添加一些访问器属性到我们的组件中，我们使用这些属性来创建宿主元素样式绑定。以下访问器属性`hasFilteredTags`绑定到宿主元素的显示样式属性。它将控制组件是显示还是隐藏。只有当过滤器有效且过滤后的标签至少包含一个标签时，我们才会显示组件：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following two accessor properties use host bindings to set the `top` and
    `left` styles of our host element, based on the `hashTagInput` input of the component:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个访问器属性使用宿主绑定来设置宿主元素的`top`和`left`样式，基于组件的`hashTagInput`输入：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The template for our component is rather simple. Let''s open the view template
    that is stored in `src/app/tags/tags-select/tags-select.component.html`, and apply
    the following changes:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件模板相当简单。让我们打开存储在`src/app/tags/tags-select/tags-select.component.html`中的视图模板，并应用以下更改：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We used the `NgFor` directive to iterate over all of the tags within the `filteredTags`
    member. If a tag is clicked, we will need to execute the `selectTag` method and
    pass the tag of the current iteration. In the listing, we'll only display the
    tag title that should help the user identify the tag that they would like to use.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`NgFor`指令来遍历`filteredTags`成员中的所有标签。如果点击了一个标签，我们需要执行`selectTag`方法并传递当前迭代的标签。在列表中，我们只显示标签标题，这有助于用户识别他们想要使用的标签。
- en: Now, we have built all of the pieces that we need to enable smooth tag entering
    for our users. However, we still need to wire everything together. The next step
    is to enable tag selection within our project comments.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经构建了我们需要的所有组件，以实现用户平滑地输入标签。然而，我们仍然需要将所有这些组件连接起来。下一步是在我们的项目评论中启用标签选择。
- en: Integrating tag selection within the editor component
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在编辑器组件中集成标签选择
- en: As the first step, we should amend our editor component to utilize the tags
    input directive in conjunction with the tags select component that we just created.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们应该修改我们的编辑器组件，以便利用我们刚刚创建的标签选择组件与标签输入指令一起使用。
- en: Before we start changing our editor, let's look at a new string helper function,
    `splice`, which allows us to pass a specific location within the text, where we
    want to replace the partial hashtag entered by the user with the final hashtag
    from the selected tag object.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始更改编辑器之前，让我们看看一个新的字符串辅助函数`splice`，它允许我们传递文本中的特定位置，在那里我们想要用从所选标签对象中获取的最终标签替换用户输入的部分标签。
- en: 'The `splice` method works similar to the `Array.prototype.splice` function,
    and allows us to remove a certain part within a string and add a new part to that
    string, at the same location. This allows us to replace certain areas in strings
    very specifically, which is exactly what we need in this situation. Let''s implement
    this little helper function within our string utility module, located in `src/app/utilities/string-utilities.ts`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`splice`方法与`Array.prototype.splice`函数类似，允许我们在字符串中删除一定部分并添加新部分到该字符串的同一位置。这允许我们非常具体地替换字符串中的某些区域，这正是我们在这个情况下所需要的。让我们在我们的字符串实用模块`src/app/utilities/string-utilities.ts`中实现这个小小的辅助函数：'
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s go back to our editor component and look at the changes to be made inside
    of the component template, located in `src/app/ui/editor/editor.component.html`.
    Effective changes in the template are marked in bold:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的编辑器组件，看看在`src/app/ui/editor/editor.component.html`中组件模板内的更改。模板中的有效更改以粗体标注：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first thing that we need to add is our tags input directive, which will
    help us to collect input data when a user enters a hashtag within our editable
    content field.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加的第一件事是我们的标签输入指令，它将帮助我们收集用户在可编辑内容字段中输入的标签数据。
- en: Just below the editable content element, we're adding our new tags select component.
    We're only rendering the tags select component if a list of tags was provided
    to the editor component as input. We're using the extracted hashtag input object
    from our tags input directive and passing it into the tags select `hashTagInput`
    input. If the tags select component emits a `outSelectTag` event, we're calling
    a new `selectTag` method, which we're going to implement on our editor component.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在可编辑内容元素下方，我们添加了新的标签选择组件。只有当将标签列表作为输入提供给编辑器组件时，我们才会渲染标签选择组件。我们使用从标签输入指令中提取的标签输入对象，并将其传递到标签选择的`hashTagInput`输入。如果标签选择组件发出`outSelectTag`事件，我们将调用一个新的`selectTag`方法，我们将在我们的编辑器组件中实现它。
- en: 'Now, let''s apply the necessary changes to our component class, located in
    `src/app/ui/editor/editor.component.html`. The ellipsis character (`…`) indicates
    code parts that have not changed. Effective changes are marked in bold:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将必要的更改应用到我们的组件类中，位于`src/app/ui/editor/editor.component.html`。省略号字符（`…`）表示未更改的代码部分。有效更改以粗体标注：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: First, we're adding another view query for our editable content element, using
    the view reference `editableContentElement`. However, this time, we're using an
    additional configuration object within the view query decorator. The `read` property
    in the view query option allows us to specify that we don't want to select the
    default `ElementRef` object, but a reference to a component instance or a directive
    instance that is present on the element. In our case, we want to get a handle
    on the tags input directive, which we've placed onto the editable content element.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为我们的可编辑内容元素添加了另一个视图查询，使用视图引用`editableContentElement`。然而，这次我们在视图查询装饰器中使用了额外的配置对象。视图查询选项中的`read`属性允许我们指定我们不想选择默认的`ElementRef`对象，而是选择一个在元素上存在的组件实例或指令实例的引用。在我们的例子中，我们想要获取到放置在可编辑内容元素上的标签输入指令的引用。
- en: Within the `saveEdit` and the `cancelEdit` methods of our editor, we can now
    additionally call the reset method on our tags input directive. This will ensure
    that we're not persisting any previous tag entry when a user saves or cancels
    an edit.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的编辑器的`saveEdit`和`cancelEdit`方法中，我们现在可以额外调用我们的标签输入指令的reset方法。这将确保当用户保存或取消编辑时，我们不会持久化任何之前的标签条目。
- en: 'Finally, we''re adding a new method: `selectTag`. This method is called from
    the editor view, as a reaction to the `outSelectTag` event from the tags select
    component. All we''re doing here is replacing the part of the hashtag in our editable
    content element that was entered by the user with the hashtag that is emitted
    in the tag selection object.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了一个新的方法：`selectTag`。这个方法是从编辑视图调用的，作为对来自标签选择组件的`outSelectTag`事件的响应。我们在这里所做的一切就是用标签选择对象中发出的标签替换掉用户输入的可编辑内容元素中的哈希标签部分。
- en: Great stuff! We have completed our work on the tags select component and integrated
    it, with our tags input directive, into the editor component.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们已经完成了对标签选择组件的工作，并将其与我们的标签输入指令集成到编辑组件中。
- en: Integrating tag selection in project comments
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在项目评论中集成标签选择
- en: Since the editor component now relies on a list of available tags to be passed
    as input, we need to apply some changes to our project comment components.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编辑组件现在依赖于一个要作为输入传递的可用标签列表，我们需要对我们的项目评论组件应用一些更改。
- en: 'Let''s start with the project comments container component, located in `src/app/container/project-comments-container/project-comments-container.component.ts`.
    The ellipsis character is hiding irrelevant code parts, while effective changes
    are in bold:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从项目评论容器组件开始，该组件位于`src/app/container/project-comments-container/project-comments-container.component.ts`。省略号字符隐藏了无关的代码部分，而有效的更改以粗体显示：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s look at the view template changes within the container component
    located in `src/app/container/project-comments-container/project-comments-container.component.ts`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看容器组件中的视图模板更改，该组件位于`src/app/container/project-comments-container/project-comments-container.component.ts`：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: That was easy! All we did was get the tags observable from our tags service,
    subscribe in the view, and pass the resulting tags list down into our comments
    component.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 真的很简单！我们只是从我们的标签服务中获取了标签可观察对象，在视图中订阅，并将生成的标签列表传递到我们的评论组件中。
- en: 'Let''s change our comments component to accept that list of tags as input.
    Open the file `src/app/comments/comments/comments.component.ts`, and add the following
    changes:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的评论组件更改为接受该标签列表作为输入。打开文件`src/app/comments/comments/comments.component.ts`，并添加以下更改：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Using the same mechanism that we use within our editor, we''re also enabling
    tag selection within the comment editable element. Let''s look at the changes
    within the view template of our comments component, located in `src/app/comments/comments/comments.component.html`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们在编辑器中使用的相同机制，我们也在评论可编辑元素中启用了标签选择。让我们看看评论组件视图模板中的更改，该模板位于`src/app/comments/comments/comments.component.html`：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Besides implementing our own tag selection for the comments editable content
    element, we're also passing the tags, which we've received from our parent container
    component, down into each comment component as input.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为评论可编辑内容元素实现我们自己的标签选择外，我们还向下传递了从我们的父容器组件接收到的标签，作为每个评论组件的输入。
- en: 'Let''s continue and complete the integration of our tagging system. Open up
    the comment component class, located in `src/app/comments/comment/comment.component.ts`,
    and apply the following changes:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续并完成标签系统的集成。打开位于`src/app/comments/comment/comment.component.ts`的评论组件类，并应用以下更改：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'All we needed to add was an additional input, to receive our tag list. Let''s
    also reflect the necessary changes to our comment component view template, located
    in `src/app/comments/comment/comment.component.html`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一个额外的输入来接收我们的标签列表。让我们也将必要的更改反映到我们的评论组件视图模板中，该模板位于`src/app/comments/comment/comment.component.html`：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Alright! There were quite a few changes for integration. However, they were
    pretty simple changes, and now we're ready to use our tagging system!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！为了集成，确实有很多更改，但它们都很简单，现在我们可以使用我们的标签系统了！
- en: Finishing up our tagging system
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成我们的标签系统
- en: Congratulations! You've now successfully implemented the first of the three
    usability components.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在已经成功实现了三个可用性组件中的第一个。
- en: With the help of a tag input directive, we have hidden the low-level programming
    of user input and the processing of the user caret position. Then, we created
    a component to display the available tags to the user, and provided a way for
    them to select a tag by clicking on it. In our editor component, we used the tags
    input directive, together with the tags select component, to enable the smooth
    entering of tags when editing comments.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在标签输入指令的帮助下，我们隐藏了用户输入的低级编程和用户光标位置的处理。然后，我们创建了一个组件来向用户显示可用的标签，并提供了他们可以通过点击来选择标签的方式。在我们的编辑器组件中，我们使用了标签输入指令以及标签选择组件，以在编辑注释时平滑地输入标签。
- en: 'We''ve covered the following concepts in this section:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们涵盖了以下概念：
- en: We processed complex user input within a designated directive, to offload logic
    from our components
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在指定的指令中处理了复杂的用户输入，以将逻辑从我们的组件中卸载
- en: We used host bindings to set positional style attributes
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用宿主绑定来设置位置样式属性
- en: We used the `read` property on a `ViewChild` decorator, to query for directive
    instances
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`ViewChild`装饰器上的`read`属性来查询指令实例
- en: We implemented fully reactive components that rely on observables and don't
    create side effects during change detection
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们实现了完全响应式组件，这些组件依赖于可观察对象，并在变更检测期间不产生副作用
- en: In the next section, we're going to look at how we can integrate drag and drop
    functionality within our application. We will build Angular directives, which
    will help us to easily integrate drag and drop capabilities into any area of our
    task management application.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何将拖放功能集成到我们的应用程序中。我们将构建Angular指令，这将帮助我们轻松地将拖放功能集成到任务管理应用程序的任何区域。
- en: Drag and drop
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拖放
- en: 'We have learned to use our computer mouse and keyboard with great efficiency.
    Using keyboard shortcuts, different click actions, and contextual mouse menus,
    can provide us with support for performing tasks. However, there is one pattern
    that has gained more attention in applications lately, given the current mobile
    and touch device hype. Drag and drop actions are a very intuitive and logical
    way to express actions, such as moving or copying items. One particular task,
    performed on user interfaces, benefits from drag and drop: ordering items within
    a list. If we need to order items via action menus, it gets very confusing. Moving
    items step-by-step, using the up and down buttons, works great, but it takes a
    lot of time. If you can drag items around and drop them in a place where you''d
    like them to be reordered, you can sort a list of items extremely quickly.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了高效地使用我们的计算机鼠标和键盘。使用键盘快捷键、不同的点击动作和上下文鼠标菜单，可以为我们执行任务提供支持。然而，在当前的移动和触摸设备热潮中，有一个模式最近受到了更多的关注。拖放动作是一种非常直观和逻辑的表达动作的方式，例如移动或复制项目。在用户界面执行的一个特定任务受益于拖放：在列表中对项目进行排序。如果我们需要通过动作菜单对项目进行排序，会变得非常混乱。逐步移动项目，使用上下按钮，效果很好，但需要花费很多时间。如果你可以拖动项目并将它们拖放到你希望它们重新排序的位置，你可以非常快速地对项目列表进行排序。
- en: In this topic, we will build the required elements to enable drag and drop within
    our application. We will use the drag and drop feature to enable users to reorder
    their task lists. By developing reusable directives to provide this functionality,
    we can later enable the feature at any spot within our application.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本主题中，我们将构建启用应用程序内拖放所需的基本元素。我们将使用拖放功能来启用用户重新排序他们的任务列表。通过开发可重用的指令来提供此功能，我们可以在应用程序的任何位置启用该功能。
- en: To implement our directives, we will make use of the HTML5 drag and drop API,
    which is supported in all of the major browsers at the time of writing this book.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的指令，我们将利用HTML5拖放API，该API在撰写本书时得到了所有主要浏览器的支持。
- en: 'Since we would like to reuse our drag and drop behavior on multiple components,
    we will use directives for the implementation. We are going to create two directives
    in this section:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望在多个组件上重用我们的拖放行为，我们将使用指令来实现。在本节中，我们将创建两个指令：
- en: '**Draggable directive**: This directive should be attached to components, which
    should be enabled for dragging'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可拖动指令**：此指令应附加到可以启用拖动的组件'
- en: '**Draggable drop zone directive**: This directive should be attached to components
    that will act as drop targets'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可拖动放置区域指令**：此指令应附加到将作为放置目标的组件'
- en: We'll also implement a feature wherein we can be selective about what can be
    dragged where. For this, we will use a type attribute on our draggable directives,
    as well as an accepted type attribute on our drop zones.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将实现一个功能，可以让我们选择性地决定哪些内容可以被拖放到哪些位置。为此，我们将在我们的可拖动指令中使用类型属性，以及在目标区域中使用接受类型属性。
- en: Updating our model for ordering tasks
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新我们的任务排序模型
- en: 'As a first step, we should enable our task model for ordering. By introducing
    an `order` field on our task object, we can then use that field to sort tasks
    accordingly. Let''s make the following changes to our model file, located in `src/app/model.ts`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们应该使我们的任务模型支持排序。通过在我们的任务对象中引入一个 `order` 字段，然后我们可以使用该字段相应地排序任务。让我们对我们的模型文件进行以下更改，该文件位于
    `src/app/model.ts`：
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We have also added a new type alias, `DraggableType`, which we're using to identify
    things that can be dragged within our application. We will use this type to make
    sure that we can only drag and drop to locations that support the given type.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个新的类型别名，`DraggableType`，我们使用它来识别我们应用程序内可以拖动的对象。我们将使用此类型来确保我们只能将拖放操作到支持给定类型的区域。
- en: Since we have changed the model for our tasks to include an `order` property,
    we will need to make some changes to our existing application state management,
    in order to work with the `order` property.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经更改了任务模型以包含 `order` 属性，我们需要对我们的现有应用程序状态管理进行一些更改，以便与 `order` 属性一起工作。
- en: 'Let''s first change our in-memory database, and open the file `src/app/database.ts`
    to apply the following changes:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们更改我们的内存数据库，并打开文件 `src/app/database.ts` 以应用以下更改：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, all of our initial tasks contain an `order` property. Now, we need to
    take care of two additional things:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们所有的初始任务都包含了一个 `order` 属性。现在，我们需要处理两件额外的事情：
- en: When new tasks get created, we need to compute the next available order value
    and use it to create a new task
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当创建新任务时，我们需要计算下一个可用的顺序值并使用它来创建新任务
- en: We need to change our task list to use the `order` property for sorting
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要将任务列表更改为使用 `order` 属性进行排序
- en: 'We can implement both of these changes within our task list container component.
    Let''s open the file `src/app/container/task-list-container/task-list-container.component.ts`,
    and apply some changes. Irrelevant code parts are hidden using the ellipsis character,
    while the effective changes are marked in bold:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任务列表容器组件中实现这两个更改。让我们打开文件 `src/app/container/task-list-container/task-list-container.component.ts`，并应用一些更改。不相关的代码部分使用省略号字符隐藏，而有效的更改以粗体显示：
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Alright; that's it, for now. We've successfully introduced a new `order` property,
    which is now used to sort our task list. This order becomes very important when
    we want to use our drag and drop feature to sort the task list.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 好了；目前就是这样。我们已经成功引入了一个新的 `order` 属性，现在它被用来排序我们的任务列表。当我们想要使用拖放功能来排序任务列表时，这个顺序变得非常重要。
- en: Implementing the draggable directive
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现可拖动指令
- en: 'The `draggable` directive will be attached to the elements that we want to
    enable for drag and drop. Let''s get started by creating a new directive using
    the Angular CLI tool:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`draggable` 指令将被附加到我们希望启用拖放功能的元素上。让我们使用 Angular CLI 工具创建一个新的指令开始：'
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s open the directive class file, located in `src/app/draggable/draggable.directive.ts`,
    and add the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开位于 `src/app/draggable/draggable.directive.ts` 的指令类文件，并添加以下代码：
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: By setting the HTML attribute `draggable` to `true`, using a host binding, we
    tell the browser that we're considering this element a draggable element. This
    HTML attribute is already part of the drag and drop API of the browser.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 HTML 属性 `draggable` 设置为 `true`，使用宿主绑定，我们告诉浏览器我们正在考虑这个元素为可拖动元素。这个 HTML 属性已经是浏览器拖放
    API 的一部分。
- en: The `draggableData` input is used to specify the data that represents the element
    that can be dragged. This data will be serialized to JSON and transferred to our
    drop zones once a drag action is completed.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`draggableData` 输入用于指定表示可拖动元素的的数据。一旦拖动操作完成，这些数据将被序列化为 JSON 并传输到我们的目标区域。'
- en: By specifying a draggable type using the `draggableType` input, which we have
    introduced to our model, we can be more selective when the element is dragged
    over a drop zone. Within the drop zone, we can include a counterpart that controls
    what types are acceptable to be dropped.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用我们引入到模型中的 `draggableType` 输入指定可拖动类型，当元素拖动到目标区域时，我们可以更加选择性地进行。在目标区域内，我们可以包括一个控制可接受的拖放类型的对应元素。
- en: Additionally, we can use a host binding to set a class, called `dragging`, which
    will apply some special styles that will make it easy to recognize that an element
    is dragged.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用主机绑定来设置一个名为`dragging`的类，这将应用一些特殊样式，使得识别出被拖动的元素变得容易。
- en: 'Now, we need to handle two events within our directive, to implement the behavior
    of a draggable element. The following DOM events are triggered by the drag and
    drop DOM API:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在我们的指令中处理两个事件，以实现可拖动元素的行为。以下DOM事件由拖放DOM API触发：
- en: '`dragstart`: This event is emitted on elements that are grabbed and moved across
    the screen'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dragstart`：这个事件在元素被抓住并在屏幕上移动时发出'
- en: '`dragend`: If the previously initiated dragging of the element is ended, because
    of a successful drop or a release outside of a valid drop target, this DOM event
    will be triggered'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dragend`：如果之前启动的元素拖动因为成功的放置或释放到有效的放置目标之外而结束，这个DOM事件将被触发'
- en: 'Let''s use the `HostListener` decorator to implement the logic for the `dragstart`
    event:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`HostListener`装饰器来实现`dragstart`事件的逻辑：
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, let's discuss the different actions that we can perform in the implementation
    of our host listener.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论在实现我们的主机监听器时可以执行的不同操作。
- en: 'We will need to access the DOM event object in our host listener. If we were
    to create this binding within the template, we would probably need to write something
    similar to this: `(dragstart)="dragStart($event)"`. Within event bindings, we
    can make use of the synthetic variable `$event`, which is a reference to the event
    that would have triggered the event binding. If we are creating an event binding
    on our host element using the `HostListener` decorator, we need to construct the
    parameter list for the binding by using the second argument of the decorator.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在我们的主机监听器中访问DOM事件对象。如果我们要在模板中创建这个绑定，我们可能需要写一些类似这样的代码：`(dragstart)="dragStart($event)"`。在事件绑定中，我们可以利用合成变量`$event`，它是触发事件绑定的事件的引用。如果我们使用`HostListener`装饰器在我们的主机元素上创建事件绑定，我们需要通过装饰器的第二个参数来构造绑定的参数列表。
- en: The first action in our event listener is to set the desired `effectAllowed`
    property on the data transfer object. Currently, we only support the `move` effect,
    as our main concern is to reorder tasks within the task list using drag and drop.
    The drag and drop API is very system-specific, but usually, there are different
    drag effects if a user holds a modifier key (such as *Ctrl* or *Shift*) while
    initiating the dragging. Within our `draggable` directive, we can force the `move`
    effect for all drag actions.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们事件监听器的第一个操作是在数据传输对象上设置所需的`effectAllowed`属性。目前，我们只支持`move`效果，因为我们的主要关注点是使用拖放重新排序任务列表。拖放API非常特定于系统，但通常，如果用户在启动拖动时按住修饰键（如*Ctrl*或*Shift*），会有不同的拖放效果。在我们的`draggable`指令中，我们可以强制所有拖动操作都使用`move`效果。
- en: In the next code snippet, we set the data that should be transferred by dragging.
    It's important to understand the core purpose of the drag and drop API. It not
    only provides a way to implement drag and drop for elements in your DOM, but it
    also supports the dragging of files and other objects into your browser. Because
    of this, the API undergoes some constraints, one of which is making it impossible
    to transfer data, other than simple string values. In order for us to transfer
    complex objects, we will serialize the data from the `draggableData` input, using
    `JSON.stringify`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码片段中，我们设置了通过拖动应该传输的数据。理解拖放API的核心目的是非常重要的。它不仅提供了一种在DOM元素中实现拖放的方法，而且还支持将文件和其他对象拖入浏览器。正因为如此，API存在一些限制，其中之一是使得除了简单的字符串值之外的数据传输变得不可能。为了使我们能够传输复杂对象，我们将使用`JSON.stringify`将`draggableData`输入的数据序列化。
- en: Another limitation caused by some security constraints within the API is that
    data can only be read after a successful drop. This means that we cannot inspect
    the data if the user is just hovering over an element. However, we need to know
    some facts about the data when hovering over drop zones. We need to know the type
    of draggable element when entering a drop zone. This way we can control that certain
    draggable elements can only be dropped in specific drop zones. We're using a small
    workaround for this issue. The drag and drop API hides the data when we drag data
    over a drop target. However, it tells us what type of data it is. Knowing this
    fact, we can use the `setData` function to encode our draggable type. Accessing
    the data keys only is considered secure, and can therefore be done in all drop
    zone events.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于API中的一些安全约束导致的另一个限制是，数据只能在成功释放后读取。这意味着如果用户只是悬停在元素上，我们无法检查数据。然而，当悬停在释放区域上时，我们需要了解一些关于数据的事实。我们需要知道当进入释放区域时，可拖动元素的类型。这样我们就可以控制某些可拖动元素只能被放置在特定的释放区域中。我们为此问题使用了一个小的解决方案。拖放API在拖动数据到释放目标上时隐藏数据。然而，它告诉我们数据的类型。了解这一事实后，我们可以使用`setData`函数来编码我们的可拖动类型。仅访问数据键被认为是安全的，因此可以在所有释放区域事件中执行。
- en: Finally, we'll set the dragging flag to `true`, which will cause the class binding
    to re-validate and add the `dragging` class to the element.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将拖动标志设置为`true`，这将导致类绑定重新验证并添加`dragging`类到元素上。
- en: 'After dealing with the `dragstart` event, we now need to handle the `dragend`
    event, to complete our draggable directive. The only thing we do within the `dragEnd`
    method that is bound to the `dragend` event is set the dragging member to false.
    This will cause the `dragging` class to be removed from the host element:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完`dragstart`事件后，我们现在需要处理`dragend`事件，以完成我们的可拖动指令。在绑定到`dragend`事件的`dragEnd`方法中，我们唯一做的事情是将拖动成员设置为`false`。这将导致`dragging`类从宿主元素中移除：
- en: '[PRE38]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: That's it for the behavior of our draggable directive. Now, we need to create
    its counterpart directive, to provide the behavior of a drop zone.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的可拖动指令的行为。现在，我们需要创建其对应指令，以提供释放区域的行为。
- en: Implementing a drop target directive
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现释放目标指令
- en: 'Drop zones will act as containers where draggable elements can be dropped.
    For this, we''ll create a new draggable drop zone directive. Let''s use the Angular
    CLI to create the directive:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 释放区域将作为容器，其中可拖动元素可以被放置。为此，我们将创建一个新的可拖动释放区域指令。让我们使用Angular CLI来创建指令：
- en: '[PRE39]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s open the directive file, located in `src/app/draggable/draggable-drop-zone.directive.ts`,
    and add the following code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开位于`src/app/draggable/draggable-drop-zone.directive.ts`的指令文件，并添加以下代码：
- en: '[PRE40]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Using the `dropAcceptType` input, we can specify what types of draggable elements
    we accept in this drop zone. This will help the users identify whether they are
    able to drop off the draggable elements, when approaching the drop zone.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dropAcceptType`输入，我们可以指定在这个释放区域中我们接受哪些类型的可拖动元素。这将帮助用户识别他们是否能够将可拖动元素放置在释放区域上。
- en: Upon successful drops into the drop zone, we will need to emit an event, so
    that the components using our drag and drop functionality can react accordingly.
    For that purpose, we will use the `dropDraggable` output property.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功将项目拖放到释放区域后，我们需要发出一个事件，以便使用我们的拖放功能的组件可以相应地做出反应。为此，我们将使用`dropDraggable`输出属性。
- en: The `over` member field will store the state if an accepted element is in the
    process of being dragged over the drop zone. We are using a host binding to set
    the class `over` on our host element. That way, a drop zone element can be styled
    differently when we are about to drop an item onto it.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`over`成员字段将存储如果被接受元素正在拖动到释放区域上时所处的状态。我们使用宿主绑定在宿主元素上设置类`over`。这样，当我们将项目拖放到释放区域上时，释放区域元素可以有不同的样式。'
- en: 'Now, let''s add a method to check whether our drop zone should accept any given
    drag and drop event by checking against our `dropAcceptType` member. Remember
    the security problems that we needed to work around when creating the draggable
    directive? Now, we''re implementing the counterpart, to extract the draggable
    type from the drag event and check whether the dragged item is supported by this
    drop zone:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个方法来检查我们的释放区域是否应该接受任何给定的拖放事件，通过检查我们的`dropAcceptType`成员。记得我们在创建可拖动指令时需要解决的那些安全问题吗？现在，我们正在实现其对应部分，从拖动事件中提取可拖动类型并检查拖动的项目是否被这个释放区域支持：
- en: '[PRE41]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We can only read the keys of the data within data transfer objects for drag
    events, where the data itself is hidden until a successful `drop` event has occurred.
    To bypass this security limitation, we've encoded the draggable type information
    into a data key itself. Since we can list all of the data keys safely by using
    the `types` field on data transfer objects, it's not too hard to extract the encoded
    draggable type information. We search for a data type key that starts with `'draggable-type'`,
    and then split it by the column character. The value after the column character
    is our type information, which we can then compare against the `dropAcceptType`
    directive input property.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能读取拖动事件中数据传输对象内的键，其中数据本身在成功的`drop`事件发生之前是隐藏的。为了绕过这个安全限制，我们将可拖动类型信息编码到数据键本身中。由于我们可以通过使用数据传输对象的`types`字段安全地列出所有数据键，因此提取编码的可拖动类型信息并不太难。我们寻找一个以`'draggable-type'`开头的数据类型键，然后通过列字符进行分割。列字符后面的值是我们的类型信息，然后我们可以将其与`dropAcceptType`指令输入属性进行比较。
- en: 'We will use two events to determine whether a draggable element is moved to
    our drop zone:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个事件来确定可拖动元素是否被移动到我们的拖放区域：
- en: '`dragenter`: This event is fired by an element if another element is dragged
    over it'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dragenter`：当另一个元素被拖动到它上面时，该事件由一个元素触发'
- en: '`dragleave`: This event is fired by an element if the previously entered element
    has left again'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dragleave`：当之前进入的元素再次离开时，该事件由一个元素触发'
- en: 'There''s one problem with the preceding events, which is that they actually
    bubble, and we will receive a `dragleave` event if the dragged element is moved
    to a child element within our drop zone. Because of the bubbling, we will then
    also receive `dragenter` and `dragleave` events from the child elements. This
    is not desired, in our case, and we need to build some functionality to improve
    this behavior. We make use of a counter member field, `dragEnterCount`, which
    counts up on all `dragenter` events and counts down on `dragleave` events. This
    way, we can now say that only on `dragleave` events, where the counter becomes
    zero, the users'' mouse cursor will leave the drop zone. Let''s look at the following
    diagram, which illustrates the problem:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的事件有一个问题，就是它们实际上会冒泡，如果拖动的元素被移动到我们的拖放区域内的子元素中，我们将会收到一个`dragleave`事件。由于冒泡，我们还会从子元素那里收到`dragenter`和`dragleave`事件。在我们的情况下，这并不是我们想要的，我们需要构建一些功能来改善这种行为。我们使用一个计数成员字段`dragEnterCount`，它在所有`dragenter`事件上增加计数，在`dragleave`事件上减少计数。这样，我们现在可以说，只有在`dragleave`事件中，当计数器变为零时，用户的鼠标光标才会离开拖放区域。让我们看看以下图表，它说明了这个问题：
- en: '![](img/f85d34b2-94fa-40ac-adc4-ad749352a14e.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f85d34b2-94fa-40ac-adc4-ad749352a14e.png)'
- en: Visualization of important variables and functions for our calculations
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算的重要变量和函数的可视化
- en: 'Let''s implement this logic to build a proper behavior for `dragenter` and
    `dragleave` events within our drop zone:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现这个逻辑，以在我们的拖放区域内为`dragenter`和`dragleave`事件构建适当的行为：
- en: '[PRE42]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Within both of the events, we first check whether the event is carrying a data
    transfer object, of which we accept the type. After validating the type using
    our `typeIsAccepted` method, we deal with the counter, and set the `over` member
    field, if required.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个事件中，我们首先检查事件是否携带数据传输对象，我们接受其类型。在通过我们的`typeIsAccepted`方法验证类型后，我们处理计数器，并在需要时设置`over`成员字段。
- en: 'We need to handle another event, which is important for drag and drop functionality.
    The `dragover` event helps us to set the accepted `dropEffect` of the current
    dragging action. This will tell our browser that the initiated dragging action
    from our draggable is suitable for this drop zone. It''s also important that we
    prevent the default browser behavior, so that there''s no default browser behavior
    in the way of our custom drag and drop implementation. Let''s add another host
    listener to cover those concerns:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要处理另一个事件，这对于拖放功能非常重要。`dragover`事件帮助我们设置当前拖动操作的接受`dropEffect`。这将告诉我们的浏览器，从我们的可拖动元素发起的拖动操作适合这个拖放区域。同样重要的是，我们需要防止默认的浏览器行为，这样就不会干扰我们自定义的拖放实现。让我们添加另一个主机监听器来覆盖这些关注点：
- en: '[PRE43]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, we need to handle the most important event in the drop zone, which
    is the `drop` event that is triggered if a user drops a draggable item into our
    drop zone:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要处理拖放区域中最重要的事件，即当用户将可拖动项拖入我们的拖放区域时触发的`drop`事件：
- en: '[PRE44]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: After checking whether the dropped element is of an accepted type, we can go
    ahead and read the data transfer object data from the event. This data was previously
    set by the draggable directive, and needs to be deserialized, using `JSON.parse`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查放下元素是否为接受类型之后，我们可以继续从事件中读取数据传输对象数据。这些数据之前由可拖动指令设置，需要使用 `JSON.parse` 进行反序列化。
- en: Since the drop was successful, we can reset our `dragEnterCount` member and
    set the `over` flag to `false`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 由于放置成功，我们可以重置我们的 `dragEnterCount` 成员并将 `over` 标志设置为 `false`。
- en: Finally, we will emit the deserialized data from the draggable element using
    our `outDropDraggable` output property.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用我们的 `outDropDraggable` 输出属性发出来自可拖动元素的已反序列化数据。
- en: That's all we need to build a highly reusable drag and drop behavior. We can
    now attach the draggable and the draggable drop zone to any components within
    our application where we feel the need to enable drag and drop.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们构建高度可重用拖放行为所需的所有内容。现在，我们可以将可拖动和可拖动放置区域附加到我们应用程序中任何需要启用拖放的组件上。
- en: In the next section, we're going to integrate the drag and drop functionality
    within our application.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将集成应用程序中的拖放功能。
- en: Integrating drag and drop
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成拖放
- en: We can now use the draggable and draggable drop zone directives in our task
    list component, so that we can enable the reordering of tasks using drag and drop.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在任务列表组件中使用可拖动和可拖动放置区域指令，这样我们就可以通过拖放来启用任务的重新排序。
- en: We can do this by attaching both of the directives to the task elements within
    the task list component template. Yeah, that's right! We want to make our task
    components draggable, but also a drop zone at the same time. That way, we can
    drop tasks onto other tasks, and that gives us the foundation for reordering.
    What we will do is reorder the list on a drop, so that the dropped task will be
    squeezed into the position right before the task where it was dropped.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将这两个指令都附加到任务列表组件模板中的任务元素上来做到这一点。没错！我们希望使我们的任务组件可拖动，同时也是一个放置区域。这样，我们就可以将任务拖放到其他任务上，这为我们提供了重新排序的基础。我们将执行的操作是在放置时重新排序列表，以便放置的任务将挤入它被放置的任务之前的位置。
- en: 'First, let''s apply the drag and drop directives to the task host elements
    in the task list component template. Open the file `src/app/tasks/task-list/task-list.component.html`,
    and apply the following changes:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将拖放指令应用到任务列表组件模板中的任务宿主元素上。打开文件 `src/app/tasks/task-list/task-list.component.html`，并应用以下更改：
- en: '[PRE45]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Alright; using the preceding attributes, we made our tasks not only draggable,
    but also drop zones at the same time. By specifying both `draggableType` and `dropAcceptType`
    to the `'task'` string, we are telling our drag and drop behavior that these task
    elements can be dropped into other task elements. Our draggable drop zone directive
    is set to emit an `outDropDraggable` event whenever a valid draggable is dropped
    off. On a successful drop, we will call a new method within our task list component
    `dropTask`, to which we will pass the current task and the drop zone event object.
    The draggable drop zone directive will emit the data that was previously set using
    the `draggableData` input of the draggable directive. In other words, the `dropTask`
    method is called with the target task as the first parameter and the source task
    as the second parameter.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 好的；使用前面的属性，我们使我们的任务不仅可拖动，同时也可以作为放置区域。通过将 `draggableType` 和 `dropAcceptType`
    都指定为 `'task'` 字符串，我们告诉我们的拖放行为这些任务元素可以被拖放到其他任务元素中。我们的可拖动放置区域指令被设置为在有效可拖动元素被放下时发出一个
    `outDropDraggable` 事件。在成功放置后，我们将在任务列表组件中调用一个新的方法 `dropTask`，我们将传递当前任务和放置区域事件对象。可拖动放置区域指令将发出之前使用可拖动指令的
    `draggableData` 输入设置的任何数据。换句话说，`dropTask` 方法以目标任务作为第一个参数，源任务作为第二个参数被调用。
- en: 'Let''s implement the `dropTask` method within our component class, located
    in `src/app/tasks/task-list/task-list.component.ts`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在组件类中实现 `dropTask` 方法，该类位于 `src/app/tasks/task-list/task-list.component.ts`：
- en: '[PRE46]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s elaborate on the implementation within our task list component:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细说明任务列表组件中的实现：
- en: 'If you check the template again, you will see that we bound to the `dropTask`
    method with the following expression: `(outDropDraggable)="dropTask(task, $event)"`.
    Since the drop zone emitted an event with deserialized data that was bound using
    the draggable input property `draggableData`, we can safely assume that we will
    receive a copy of the task that was dropped into the drop zone. As the first parameter
    to our binding, we added the local view variable `task`, which is actually the
    task that acts as the drop zone. Therefore, we can say that the first parameter
    of our `dropTask` method represents the target, while the second represents the
    source task.'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你再次检查模板，你会看到我们使用以下表达式绑定到`dropTask`方法：`(outDropDraggable)="dropTask(task, $event)"`。由于拖放区域发出的事件包含使用可拖动输入属性`draggableData`绑定的反序列化数据，我们可以安全地假设我们将收到一个被拖放到拖放区域的任务的副本。作为我们绑定的第一个参数，我们添加了本地视图变量`task`，它实际上是作为拖放区域起作用的任务。因此，我们可以说我们的`dropTask`方法的第一个参数代表目标，而第二个参数代表源任务。
- en: As a first check in our method, we compare the source ID with the target ID,
    and if they match, we can assume that the task was dropped to itself, and we don't
    need to perform any further actions.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的方法中，我们首先比较源ID和目标ID，如果它们匹配，我们可以假设任务被拖放到自身，我们不需要执行任何进一步的操作。
- en: Now, all we do is emit two update task events from our task list component,
    to reorder both the source and target task. We do that by switching the order
    property between the source and target. This is just one way to reorder, and we
    can also implement this differently.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需从我们的任务列表组件中发出两个更新任务事件，以重新排列源任务和目标任务。我们通过在源任务和目标任务之间切换顺序属性来实现这一点。这只是重新排列的一种方式，我们也可以以不同的方式实现。
- en: How great is that? We have successfully implemented drag and drop on our task
    list, to provide a very useful feature to reorder tasks.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这有多棒？我们已经成功地在任务列表中实现了拖放，为用户提供了一个非常有用的功能来重新排列任务。
- en: Recapitulate on drag and drop
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拖放回顾
- en: With the use of the low-level drag and drop API, using events and data transfer
    objects, we have implemented two directives that can now be used to execute smooth
    drag and drop functionality within our application, wherever we desire.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用低级拖放API，使用事件和数据传输对象，我们已经实现了两个指令，现在可以在我们的应用程序中执行平滑的拖放功能，无论我们希望在何处。
- en: With almost no effort, we have implemented our drag and drop behavior on the
    task list, to provide a nice feature to reorder the tasks within the list. The
    only thing that we needed to do, besides hooking up the directives, was implement
    a method where we could reorder the tasks based on the information from the draggable
    drop zone directive output.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎没有花费任何力气，我们就已经在任务列表上实现了拖放行为，为用户提供了一个很好的功能来重新排列列表中的任务。除了连接指令之外，我们唯一需要做的事情是实现一个方法，我们可以根据可拖动拖放区域指令的输出信息重新排列任务。
- en: 'We worked with the following concepts in this section:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用了以下概念：
- en: We learned the basics of the HTML5 drag and drop API
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了HTML5拖放API的基础知识
- en: We used the data transfer object to securely transfer data within drag and drop
    events
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用数据传输对象在拖放事件中安全地传输数据
- en: We built reusable behavior patterns, using directives
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用指令构建了可重用的行为模式
- en: We enriched the standard drag and drop API by providing our own custom selection
    mechanisms, using a custom data type that encodes draggable type information
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过提供我们自己的自定义选择机制，使用自定义数据类型来编码可拖动类型信息，丰富了标准的拖放API
- en: Summary
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built two features to enhance the usability of our application.
    Users can now make use of tags, to easily annotate comments with navigable items
    that provide summaries to the subject. They can also use drag and drop, to reorder
    tasks within the task list component.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了两个功能来增强我们应用程序的可用性。用户现在可以使用标签，轻松地使用可导航的项目注释注释，这些项目提供了主题的摘要。他们还可以使用拖放，在任务列表组件中重新排列任务。
- en: Usability is a key asset in today's applications, and, by providing highly encapsulated
    and reusable components to address usability concerns, we can make our lives a
    lot easier when building those applications. When dealing with usability, thinking
    in terms of components is a very good thing, not only for easing development,
    but for establishing consistency. Consistency itself plays a major role in making
    an application usable.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 用户体验是当今应用的关键资产，通过提供高度封装和可重用的组件来解决用户体验问题，我们可以在构建这些应用时使生活变得更加轻松。在处理用户体验时，从组件的角度思考是非常好的，这不仅有助于简化开发，还有助于建立一致性。一致性本身在使应用易于使用方面发挥着重要作用。
- en: In the next chapter, we're going to create some nifty components to manage time
    within our task management system. This will also include some new user input
    components, to enable simple work time-entry fields.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建一些巧妙的组件来管理任务管理系统中的时间。这还将包括一些新的用户输入组件，以实现简单的工时输入字段。
