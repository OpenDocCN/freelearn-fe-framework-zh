- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing Microfrontends in Production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to develop and test web applications on your local computer is great;
    however, deploying them them to production, maintaining them, and releasing new
    features while your applications are being visited by hundreds and thousands of
    visitors takes your software development skills to the next level. This chapter
    will cover some of the key concepts around deploying and maintaining your microfrontends
    in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Branching strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Versioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rollback strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature toggles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have taken the first steps toward reliably
    maintaining your microfrontend applications in production.
  prefs: []
  type: TYPE_NORMAL
- en: Foundational components for a strong software delivery model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to deploying and maintaining applications in production, I recommend
    using **DevOps Research and Assessment’s** (**DORA’s**) software delivery maturity
    model to help prioritize areas to focus on and aspects of your production deployment
    processes you should optimize.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'The software delivery maturity model talks about four key areas—namely, *Deployment
    frequency*, *Lead time for changes*, *Time to restore service*, and *Change failure
    rate*, and these are categorized as *Elite*, *High*, *Medium*, and *Low*. You
    can read more about this in detail here in the *State of DevOps 2021* report:
    [https://dora.dev/publications/pdf/state-of-devops-2021.pdf](https://dora.dev/publications/pdf/state-of-devops-2021.pdf).
    You can also register and view the rest of the reports at [https://dora.dev/publications/](https://dora.dev/publications/)
    and [https://cloud.google.com/devops/state-of-devops](https://cloud.google.com/devops/state-of-devops).'
  prefs: []
  type: TYPE_NORMAL
- en: We will look at a couple of key components that help you create the right foundation
    to ensure you are able to move up the maturity model as your team gains more confidence
    in deploying and managing microfrontends in production.
  prefs: []
  type: TYPE_NORMAL
- en: Branching strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In my opinion, the branching strategy is the most critical component that helps
    you improve the *Deployment frequency* and *Lead time for* *changes* metrics.
  prefs: []
  type: TYPE_NORMAL
- en: GitFlow and GitHub Flow are two popular branching strategies for Git-based version
    control systems, each with its strengths and weaknesses.
  prefs: []
  type: TYPE_NORMAL
- en: GitFlow is a branching model that uses two long-lived branches, `main` and `develop`,
    as well as feature, release, and hotfix branches.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Flow, on the other hand, is a simpler and more flexible branching strategy
    that is suitable for smaller teams and projects. It revolves around a single main
    branch, typically `master` or `main`, and encourages developers to make changes
    in feature branches that are then merged into the `main` branch through pull requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our opinion, when working with microfrontends and monorepos, GitHub Flow
    is the only viable branching strategy. This is primarily because of the following
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplicity**: GitHub Flow simplifies the development process by enforcing
    a single, linear history on the **main** branch. Every feature, bug fix, or improvement
    is developed on a separate branch created from **main**, and once ready, it’s
    merged back into **main**. There are no long-lived branches apart from **main**,
    avoiding the complications of managing, syncing, and maintaining multiple long-term
    branches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolation of changes**: In a monorepo, it’s crucial to ensure changes to
    one project don’t unintentionally impact another. GitHub Flow’s practice of isolated
    branches for each new feature or bug fix aids in containing the scope of changes,
    reducing the risk of cross-project interference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous Integration/Continuous Deployment** (**CI/CD**): GitHub Flow is
    designed with CD in mind. In monorepos, this can be even more beneficial. Since
    all projects live within the same repository, it’s easier to ensure that all changes
    are tested and deployed consistently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced merge conflicts**: With a strategy such as Git Flow, where changes
    are often merged into **develop** or **release** branches before **main**, there
    can be significant delays between when code is written and when it’s deployed.
    In a fast-paced monorepo, this can lead to complex merge conflicts. GitHub Flow
    mitigates this by encouraging frequent merges directly into **main**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While working with GitFlow we’ve also seen that it is beneficial to slightly
    switch how code is merged to `main` based on whether you are in active development
    or post your first production deployment.
  prefs: []
  type: TYPE_NORMAL
- en: During active development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: During the active development phase of a project, team members diligently generate
    feature branches, merging them back into the `main` branch only after the pull
    requests have received the necessary approvals. It’s common practice, and possibly
    part of your CI builds, to initiate an array of automated unit tests on each pull
    request prior to merging into the `main` branch. Additionally, a suite of integration
    and end-to-end tests are preferably executed on the `main` branch each night.
    This routine helps ensure that any disruptions in the `main` branch are identified
    and rectified promptly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at the branching and merging workflow with GitHub Flow during active
    development:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Branching and merging strategy during active development](img/Figure_9.01_B18987.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Branching and merging strategy during active development
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, with GitHub Flow, branching and merging is quite straightforward.
    Developers branch off the `main` branch and merge back into `main`.
  prefs: []
  type: TYPE_NORMAL
- en: After the first release to production
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Subsequent to your inaugural production release, the merging strategy undergoes
    a subtle evolution. The teams continue to create feature branches off the `main`
    branch as before; however, the process diverges post-feature testing and approval.
    The tested feature release is rebased with `main`, tagged and deployed directly
    from the feature branch into production. It is only once stability in production
    is confirmed that the feature branch is merged into the `main` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following workflow will help illustrate the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Branching and releasing after the first release](img/Figure_9.02_B18987.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Branching and releasing after the first release
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 9**.2*, the process to deploy a feature, bug, or hotfix
    is the same, keeping things simple. A key step here is to rebase the `main` branch
    before you deploy your feature or bug.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this may sound unconventional, adhering to this approach has several
    benefits, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The **main** branch perpetually mirrors the stable, current version in production.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The team is given the opportunity to swiftly address and resolve any minor issues
    encountered during feature deployment, stabilizing the release prior to its merge
    into the **main** branch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It eliminates the necessity of prohibiting commits to the **main** branch until
    the release stabilizes, an impractical strategy when executing multiple daily
    deployments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the **main** branch is always in alignment with the current production version,
    the process of deploying a feature or hotfix remains consistent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since all merges into the **main** branch are post-release, the likelihood of
    a disrupted **main** branch is significantly reduced. Such disruptions can impede
    a large development team and halt further production deployments until the issue
    is resolved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the context of GitHub Flow, it is vital to note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Prior to deploying your feature branch, ensure a final rebase from the **main**
    branch. This ensures that your feature branch encompasses all previous deployments
    executed while your feature was in development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contrary to popular belief, GitHub Flow development is not exclusive to small
    2-3-member teams. It is, in fact, notably advantageous for large teams operating
    in small, focused squads or pods.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning micro apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The versioning of applications being deployed to production is standard practice,
    and there are different ways of defining versioning strategies. Versioning is
    important from many aspects; it helps in managing changelogs and mapping the different
    features and bugs to a build. It also helps with rollback strategies.
  prefs: []
  type: TYPE_NORMAL
- en: '`MAJOR.MINOR.PATCH`.'
  prefs: []
  type: TYPE_NORMAL
- en: This structure not only helps users to understand the nature of changes in the
    new release but also helps with dependency management in software systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our recommended strategy is to use SemVer as a guide. Each micro app should
    adhere to its own versioning rules, ensuring that any changes to the application’s
    public features are reflected in its version number. A micro app can increment
    its version number following the `MAJOR.MINOR.PATCH` pattern each time there’s
    a major feature release, minor feature release, or a bug fix change. We recommend
    prefixing the app name to the semantic version—for example, `catalog-2.8.3` would
    mean the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Micro app** **name**: **catalog**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Major** **version**: 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minor** **version**: 8'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path/bug fix** **version**: 3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a simple way to manage tagging, whenever you are working on a release, we
    recommend creating a release branch such as `releases/catalog-2.0.1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the release is tested and ready to deploy, we tag it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '**git** **tag catalog-2.0.0**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**git push** **origin catalog-2****.0.0**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a CI/CD pipeline, we can set it to automatically trigger a deployment to
    the test environments whenever a new tag is detected.
  prefs: []
  type: TYPE_NORMAL
- en: Note that while SemVer’s official definition uses the term *breaking changes*
    to define a major version, with microfrontends and module federation we can’t
    really have a breaking change. Hence for us, a micro app containing a major feature
    release would warrant a major version number increment.
  prefs: []
  type: TYPE_NORMAL
- en: A common scenario with multiple micro apps and multiple frequent releases is
    that it becomes challenging for everybody in the team to know which version of
    which micro app is currently in production. A simple way to solve this is to have
    a `/versions` route in every micro app that will display information such as the
    current version number, the date of release, the branch it was released from,
    and so on. This can be super helpful for developers trying to debug issues in
    production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of information we had on a `/``versions` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For a large number of micro apps or frequent releases, manually tagging every
    version might become tedious. You might want to consider automating this using
    a script. Here is an example of a `bash` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you will notice that the script loops through each micro
    app in the `apps` folder, fetches the latest tags from `git` using the `git describe`
    and `git rev-list` commands, runs the `npm version` command to update the version
    numbers, and then commits and pushes the updated tags back to `git`.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use tools such as `semantic-release` or `standard-version`. These
    tools automate version management and changelog generation based on commit messages.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning and tagging micro apps is critical to ensure that there is clarity
    with all stakeholders on the current status of which version of each micro app
    is currently in production. As we will see in the next section, it also plays
    a critical role in rollback strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Rolling back a micro app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A rollback strategy is a key component to managing any production software.
    This impacts the *Time to restore* *service* metric.
  prefs: []
  type: TYPE_NORMAL
- en: Rollback strategies for microfrontends center on the ability to revert a specific
    micro app or the entire system to a previous stable state when issues arise during
    or post-deployment. *Thanks to the independence of microfrontends, a rollback
    doesn’t necessarily affect the entire application but can be targeted to the problematic
    component, reducing overall* *system disruption*.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest rollback strategy involves utilizing version control systems such
    as Git along with CI/CD pipelines. In this setup, each microfrontend has specific
    tagged releases, which are stored and can be redeployed if required. For instance,
    if the current version of a microfrontend is `catalog-1.2.3` and an issue is detected,
    you can quickly revert to the previous stable version, `catalog-1.2.2`, by triggering
    the corresponding deployment in your CI/CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, leveraging a blue-green deployment strategy can be effective.
    In this approach, two environments—blue and green—are maintained. While one serves
    live traffic (blue), the other (green) is idle or being prepared for the next
    release. If something goes wrong with the green environment post-deployment, you
    can quickly switch back to the blue environment, effectively rolling back the
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: Rollbacks in Kubernetes are straightforward thanks to its declarative nature
    and built-in versioning mechanism. When a new deployment is created, Kubernetes
    automatically versions it and stores its details. If an issue arises with a new
    release, you can quickly roll back to a previous version using the `kubectl rollout
    undo` command. For instance, if you find a problem with a deployment named `deployment/catalog`,
    you can roll back using the `kubectl rollout undo deployment/catalog` command.
    Kubernetes will revert the deployment to the previous stable version gracefully
    without any downtime, making it a powerful tool for managing rollbacks in microfrontend
    architectures.
  prefs: []
  type: TYPE_NORMAL
- en: When rolling back a micro app, it is important to be aware of any incompatibilities
    with backend APIs and whether the corresponding backend API also needs to be rolled
    back.
  prefs: []
  type: TYPE_NORMAL
- en: Rollbacks at times can be painful, and the need for rollbacks can be mitigated
    by releasing new features or versions of micro apps using feature toggles, which
    we will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying micro apps with feature toggles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Feature toggling, also known as feature flagging, is a powerful technique that
    allows individual features to be turned on or off at runtime without requiring
    a redeployment. This is particularly useful in a microfrontend architecture, as
    it enables the independent release and control of micro apps across multiple micro
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: With feature toggling, teams can deploy new features to production but have
    them “hidden” behind a toggle until they’re ready to be released. This allows
    for extensive testing in the live environment and enables progressive delivery
    techniques such as canary releases or A/B testing. If any issues arise with the
    new feature, it can be quickly “switched off” via the feature toggle, effectively
    mitigating the impact without requiring a full rollback or redeployment.
  prefs: []
  type: TYPE_NORMAL
- en: Unleash ([https://www.getunleash.io/](https://www.getunleash.io/)) is a popular
    open source tool for feature toggles.
  prefs: []
  type: TYPE_NORMAL
- en: Feature toggles can be used to provide different experiences for different users.
    For instance, you can use them to selectively enable features for specific user
    groups, such as beta testers or premium users.
  prefs: []
  type: TYPE_NORMAL
- en: However, feature toggling needs to be managed carefully to avoid an accumulation
    of outdated toggles, which can lead to code complexity and technical debt. Regular
    audits and cleanup of feature toggles should be part of the development process.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we come to the end of this section, which covered some of the foundational
    elements of managing your microfrontends in production. This goes in conjunction
    with everything we saw in the previous chapters about deploying microfrontends
    to the cloud and eventually helping reduce the overall stress involved with deploying
    and maintaining applications in production.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude this chapter, let us quickly summarize what we’ve learned so
    far. We learned about DORA’s software delivery performance metrics: *Deployment
    frequency*, *Lead time for changes*, *Time to restore service*, and *Change failure
    rate*. We then had a look at some of the foundational elements that teams need
    to focus on to ensure they are set up for success.'
  prefs: []
  type: TYPE_NORMAL
- en: We learned about branching strategies and that GitHub Flow is the preferred
    branching strategy. We also learned about the nuances of workflows when software
    is being built versus when it’s deployed.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about the right way to version our micro apps. We also learned about
    the importance of rollback strategies and how microfrontends help minimize the
    blast radius. And finally, we learned about feature toggles and how we can gradually
    release new micro apps into production via feature toggles and, more importantly,
    if there are any problems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at some common pitfalls to avoid when building
    microfrontends.
  prefs: []
  type: TYPE_NORMAL
