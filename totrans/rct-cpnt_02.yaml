- en: Chapter 2. Working with Properties and State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we set up our workflow. We worked out how to compile
    ReactJS and ES6 code through a build step, interpret it directly in our browser,
    and even run it using services such as JSBin. Now, we can begin creating components
    for our content management system.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to start building our interface. We'll see interesting
    and effective ways to connect components. The important thing in this chapter
    is learning how to arrange components in complex hierarchies. We're going to nest
    several components and communicate between them and our data source, using a custom
    data backend.
  prefs: []
  type: TYPE_NORMAL
- en: Nesting components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's think about how we want to structure the components of our interface.
    Many content management systems feature lists of items—items that we store in
    and retrieve from a database. For example, let's imagine a system through which
    we can manage the pages of a website.
  prefs: []
  type: TYPE_NORMAL
- en: 'For such a system, we need an entry-point—something like `PageAdmin`, which
    connects our persistence layer to our interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also represent the persistence layer in the form of a backend class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Later, we'll look at ways of persisting this data. For now, it's OK to just
    use static data in this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could connect `PageAdmin` to this class by proving an instance of `Backend`
    as a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can start using the `Backend` data in our `PageAdmin` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The truth is that we don't really need to define a default state, or store the
    page objects to the state. I've done so to demonstrate the idiomatic way of defining
    initial component state and overriding state when working with ES6-style components.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a lot going on here, so let''s break it down bit-by-bit:'
  prefs: []
  type: TYPE_NORMAL
- en: We made a constructor. In the constructor, we defined the initial state of a
    component. We defined the state as an object with an empty `pages` array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React will call a few *magic* methods in the life cycle of a component. We used
    `componentWillMount` to get an array of pages, so we have something to render.
    We also passed this array of pages to the `setState` method. This exists to store
    state data and update the markup of a component at the same time. The `this.state.pages`
    method will now contain the array of pages from the backend.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we use curly braces inside markup, it acts like a dynamic value (just like
    with properties). We can use the `Array.prototype.map` method to return a new
    element for each page in the array of pages. This will return a new list of `li`
    components. React also expects components in a list to have a special `key` property,
    which it uses to identify them. React uses this to track which components it can
    remove, add, or change efficiently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The code references `page.id`. The pages returned by the backend should have
    the `id`, `title`, and `body` properties for these examples to work.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s concentrate on how to show each page through the content management
    system. The `PageAdmin` renders each page as a list item, so let''s think about
    what we want to do inside each list item. I think it makes sense to have a non-interactive
    summary of each page. Think of a tabular view of all pages in a website:'
  prefs: []
  type: TYPE_NORMAL
- en: Home
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terms of service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contact us
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So there''s one aspect to pages that is static: the view of the page title.
    Perhaps we can also include links to edit or delete each page.'
  prefs: []
  type: TYPE_NORMAL
- en: We also want to be able to update each page. We're probably going to need some
    sort of form, with text inputs for each field we might want to update.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can represent these two scenarios in a single component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can switch between the different components, based on whether we''re
    editing or not. Of course, we also need to define these new components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that we can define input elements in a way you might expect, if you've
    worked with HTML markup before. We'll revisit this component later, so don't worry
    about the details just yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preview mode, for this component, is a little similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This raises an interesting question. How can we efficiently transfer properties
    from one component to another? ES6 provides a great tool for this in the form
    of a language feature called the *spread* operator. First, we need to provide
    pages to page components in `PageAdmin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re replacing `a new page` with the `Page` component we created earlier.
    We use the spread operator to assign each object key as a component property.
    We can repeat this concept in `Page`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `{...this.props}` expands the page object keys. The `page.id` becomes `this.props.id`
    inside the `PageEditor` and `PageView` components. This method is great for transferring
    many properties; we don't need to write out each one.
  prefs: []
  type: TYPE_NORMAL
- en: Shared component actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, how do we change from a `PageView` class to a `PageEditor` class? For that,
    we need to hook into browser events and fiddle with the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We're providing a way for *child* components to call methods in *parent* components
    by passing down methods child components can use. When a `PageView` class wants
    to put the `Page` into edit mode, it can call `this.props.onEdit`. The `Page`
    will know how to handle that. We'll see this pattern often, so it's good to understand
    what it's doing here before moving on!
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, we provide a way for a `PageEditor` class to cancel edit mode.
    In both these cases, we use `setState` to switch between editing and viewing states.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We bind the handle methods, because otherwise `this` will mean something different
    when the methods are called. Binding like this is not efficient, so we'll revisit
    this later with an alternative!
  prefs: []
  type: TYPE_NORMAL
- en: 'We can connect these handlers to click events in each component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to prevent default form submission before calling the `onCancel` passed
    down through props. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now be able to run this in a browser and toggle between the edit
    and view aspects of each page. This is a good time to stop and take stock of what
    we''ve achieved:'
  prefs: []
  type: TYPE_NORMAL
- en: We created an entry-point component to page management called `PageAdmin`. This
    component handles fetching and persisting page data. It uses a `Backend` class
    to do these. It also renders `Page` components for each page that `Backend` returns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We created a `Page` component to encapsulate page data as well as edit and view
    aspects of each page. The `Page` component handles switching between these two
    child components, via callbacks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We created `PageEditor` as an interface for editing page data. It contains a
    couple of fields, which we'll shortly discuss.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we created `PageView` as an interface for viewing page data and getting
    to the edit mode. We're about to make the **Delete** button work too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you''ve been following along, your interface may look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shared component actions](img/5268_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have created new function references throughout this chapter. Every time
    we use `fn.bind(this)`, we create a new function. This is inefficient if we''re
    doing it inside render methods. We can get around this by creating a base component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If we extend this base component (instead of the usual `React.Component`), then
    we will have access to the `bind` method. It takes one or more function names,
    and replaces them with bound versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to add event handlers for updating and deleting pages. Let''s
    start with `PageView` and `PageEditor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We added an `onClick` handler to the Delete button. This will trigger a bound
    version of `onDelete` in which we pass the correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we added `onUpdate` so that we can determine which input changed. It calls
    the props `onUpdate` method with the correct property name and value.
  prefs: []
  type: TYPE_NORMAL
- en: We also add the `name` and `value` attributes for the inputs, setting the values
    to the corresponding properties. These updates are triggered when the inputs change,
    calling the `onUpdate` method. This means property updates will reflect in the
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Where do these new handler properties come from? We need to add them to `PageAdmin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we create a couple of methods to handle updates and deletes. These
    are bound, as we've been doing to methods in the other classes. They also use
    the rest/spread operators as a bit of a shortcut!
  prefs: []
  type: TYPE_NORMAL
- en: 'We can fake the backend data and operations with an array of pages and a few
    array modifier methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is by no means an efficient implementation. Please do not use this code
    in production. It's just an example interface against which we can test our code!
  prefs: []
  type: TYPE_NORMAL
- en: The `all` method returns a filtered and mapped array of initial pages. The `()
    => {}` syntax is a shortcut for `(function(){}).bind(this)`. The brackets are
    even optional, if there is exactly one property for the function. The filter checks
    that each page `id` is not in the `deleted` array. We're not actually deleting
    pages in this pretend backend. We're simply excluding ones we know we don't want
    to see.
  prefs: []
  type: TYPE_NORMAL
- en: We don't update the pages directly, but we apply updates to the array before
    `all` returns it. This isn't efficient, but it does allow us to see out interface
    in action.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can learn more about these array tricks at [https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array).
    It's a great place to learn about JavaScript language features.
  prefs: []
  type: TYPE_NORMAL
- en: Component life cycle methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a couple of tricks I want to show you before we wrap up. The first
    is a *life cycle method* we can use to tell when a component's properties will
    change. We can use this to change the appearance of a component, or refresh the
    internal state.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add this method to `PageEditor`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can now tell when the page changes, even though the changes are immediately
    propagated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another magic method we can use will help cut down on the comparisons React
    needs to perform. It''s called `shouldComponentUpdate` and we can add it to `PageView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `shouldComponentUpdate` method gives us a way to tell React not to look
    for changes in this component. At this scale, we're not likely to see huge performance
    improvements. But when we add this method to more complex layouts, it will drastically
    reduce the amount of work required to work out how the document should change.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be using these tricks later, as we build more complex content management
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned even more about ES6 classes and how they complement
    React components in structure and functionality. We also looked at some interesting
    uses of state and properties.
  prefs: []
  type: TYPE_NORMAL
- en: Above all, we saw how it's both possible and beneficial to avoid the internal
    component state. Properties are a powerful tool for component design. We know
    how to react to changing properties and how to reduce the work React needs to
    do to render our interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to discuss how to persist this data (to different
    kinds of local storage). We will see how to connect to these data stores through
    events.
  prefs: []
  type: TYPE_NORMAL
