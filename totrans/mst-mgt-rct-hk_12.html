<html><head></head><body>
		<div id="_idContainer034">
			<h1 id="_idParaDest-116"><em class="italic"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.1.1">Chapter 9</span></em><span class="koboSpan" id="kobo.2.1">: Use Case Scenario 3 – Valtio</span></h1>
			<p><span class="koboSpan" id="kobo.3.1">Valtio (</span><a href="https://github.com/pmndrs/valtio"><span class="koboSpan" id="kobo.4.1">https://github.com/pmndrs/valtio</span></a><span class="koboSpan" id="kobo.5.1">) is yet another library for global state. </span><span class="koboSpan" id="kobo.5.2">Unlike Zustand and Jotai, it's based on the mutating update model. </span><span class="koboSpan" id="kobo.5.3">It's primarily for module states like Zustand. </span><span class="koboSpan" id="kobo.5.4">It utilizes proxies to get an immutable snapshot, which is required to integrate with React.</span></p>
			<p><span class="koboSpan" id="kobo.6.1">The API is just JavaScript and everything works behind the scenes. </span><span class="koboSpan" id="kobo.6.2">It also leverages proxies to automatically optimize re-renders. </span><span class="koboSpan" id="kobo.6.3">It doesn't require a selector to control re-renders. </span><span class="koboSpan" id="kobo.6.4">The automatic render optimization is based on a technique called </span><strong class="bold"><span class="koboSpan" id="kobo.7.1">state usage tracking</span></strong><span class="koboSpan" id="kobo.8.1">. </span><span class="koboSpan" id="kobo.8.2">Using state usage tracking, it can detect which part</span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.9.1"> of the state is used, and it can let a component re-render only if the used part of the state is changed. </span><span class="koboSpan" id="kobo.9.2">In the end, developers need to write less code.</span></p>
			<p><span class="koboSpan" id="kobo.10.1">In this chapter, we will learn about the basic usage of the Valtio library and how it deals with mutating updates. </span><span class="koboSpan" id="kobo.10.2">Snapshots are a key feature to create an immutable state. </span><span class="koboSpan" id="kobo.10.3">We will also discuss how snapshots and proxies allow us to optimize re-renders.</span></p>
			<p><span class="koboSpan" id="kobo.11.1">In this chapter, we will cover the following topics:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.12.1">Exploring Valtio, another module state library</span></li>
				<li><span class="koboSpan" id="kobo.13.1">Utilizing proxies to detect mutations and create an immutable state</span></li>
				<li><span class="koboSpan" id="kobo.14.1">Using proxies to optimize re-renders</span></li>
				<li><span class="koboSpan" id="kobo.15.1">Creating small application code</span></li>
				<li><span class="koboSpan" id="kobo.16.1">The pros and cons of this approach</span></li>
			</ul>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.17.1">Technical requirements</span></h1>
			<p><span class="koboSpan" id="kobo.18.1">You are expected to have moderate knowledge of React, including React Hooks. </span><span class="koboSpan" id="kobo.18.2">Refer to the official site, </span><a href="https://reactjs.org"><span class="koboSpan" id="kobo.19.1">https://reactjs.org</span></a><span class="koboSpan" id="kobo.20.1">, to learn more.</span></p>
			<p><span class="koboSpan" id="kobo.21.1">In some code, we use TypeScript (</span><a href="https://www.typescriptlang.org"><span class="koboSpan" id="kobo.22.1">https://www.typescriptlang.org</span></a><span class="koboSpan" id="kobo.23.1">), and you should have basic knowledge of it.</span></p>
			<p><span class="koboSpan" id="kobo.24.1">The code in this chapter is available on GitHub: </span><a href="https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_09"><span class="koboSpan" id="kobo.25.1">https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_09</span></a><span class="koboSpan" id="kobo.26.1">.</span></p>
			<p><span class="koboSpan" id="kobo.27.1">To run the code snippets, you need a React environment, for example, Create React App (</span><a href="https://create-react-app.dev"><span class="koboSpan" id="kobo.28.1">https://create-react-app.dev</span></a><span class="koboSpan" id="kobo.29.1">) or CodeSandbox (</span><a href="https://codesandbox.io"><span class="koboSpan" id="kobo.30.1">https://codesandbox.io</span></a><span class="koboSpan" id="kobo.31.1">).</span></p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.32.1">Exploring Valtio, another module state library</span></h1>
			<p><span class="koboSpan" id="kobo.33.1">Valtio is a library primarily used</span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.34.1"> for module state, which is the same as Zustand.</span></p>
			<p><span class="koboSpan" id="kobo.35.1">As we learned in </span><a href="B17780_07_Final_VK_ePub.xhtml#_idTextAnchor092"><em class="italic"><span class="koboSpan" id="kobo.36.1">Chapter 7</span></em></a><span class="koboSpan" id="kobo.37.1">, </span><em class="italic"><span class="koboSpan" id="kobo.38.1">Use Case Scenario 1 – Zustand</span></em><span class="koboSpan" id="kobo.39.1">, we create a store in Zustand as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.40.1">const store = create(() =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.41.1">  count: 0,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.42.1">  text: "hello",</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.43.1">}));</span></p>
			<p><span class="koboSpan" id="kobo.44.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">store</span></strong><span class="koboSpan" id="kobo.46.1"> variable</span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.47.1"> has some properties, one of which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">setState</span></strong><span class="koboSpan" id="kobo.49.1">. </span><span class="koboSpan" id="kobo.49.2">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">setState</span></strong><span class="koboSpan" id="kobo.51.1">, we can update the state. </span><span class="koboSpan" id="kobo.51.2">For example, the following is incrementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">count</span></strong><span class="koboSpan" id="kobo.53.1"> value:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.54.1">store.setState((prev) =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.55.1">  count: prev.count + 1,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.56.1">}))</span></p>
			<p><span class="koboSpan" id="kobo.57.1">Why do we need to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">setState</span></strong><span class="koboSpan" id="kobo.59.1"> to update a state value? </span><span class="koboSpan" id="kobo.59.2">Because we want to update the state immutably. </span><span class="koboSpan" id="kobo.59.3">Internally, the previous </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">setState</span></strong><span class="koboSpan" id="kobo.61.1"> works like the following:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.62.1">moduleState = Object.assign({}, moduleState, {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.63.1">  count: moduleState.count + 1</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.64.1">});</span></p>
			<p><span class="koboSpan" id="kobo.65.1">This is the way to update an object immutably.</span></p>
			<p><span class="koboSpan" id="kobo.66.1">Let's imagine a case where we don't need to follow the immutable update rule. </span><span class="koboSpan" id="kobo.66.2">In this case, the code to increment the </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">count</span></strong><span class="koboSpan" id="kobo.68.1"> value in </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">moduleState</span></strong><span class="koboSpan" id="kobo.70.1"> would be the following:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.71.1">++moduleState.count;</span></p>
			<p><span class="koboSpan" id="kobo.72.1">Wouldn't it be nice if we could write code like that and make it work with React? </span><span class="koboSpan" id="kobo.72.2">Actually, we can implement this with proxies.</span></p>
			<p><span class="koboSpan" id="kobo.73.1">A proxy is a special object in JavaScript (</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"><span class="koboSpan" id="kobo.74.1">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy</span></a><span class="koboSpan" id="kobo.75.1">). </span><span class="koboSpan" id="kobo.75.2">We can define some handlers to trap object</span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.76.1"> operations. </span><span class="koboSpan" id="kobo.76.2">For example, you can add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">set</span></strong><span class="koboSpan" id="kobo.78.1"> handler to trap object mutations:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.79.1">const proxyObject = new Proxy({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.80.1">  count: 0,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.81.1">  text: "hello",</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.82.1">}, {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.83.1">  set: (target, prop, value) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.84.1">    console.log("start setting", prop);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.85.1">    target[prop] = value;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.86.1">    console.log("end setting", prop);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.87.1">  },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.88.1">});</span></p>
			<p><span class="koboSpan" id="kobo.89.1">We create </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">proxyObject</span></strong><span class="koboSpan" id="kobo.91.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">new Proxy</span></strong><span class="koboSpan" id="kobo.93.1"> with two arguments. </span><span class="koboSpan" id="kobo.93.2">The first argument is an object itself. </span><span class="koboSpan" id="kobo.93.3">The second argument is a collection object of handlers. </span><span class="koboSpan" id="kobo.93.4">In this case, we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">set</span></strong><span class="koboSpan" id="kobo.95.1"> handler, which</span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.96.1"> traps the </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">set</span></strong><span class="koboSpan" id="kobo.98.1"> operation and adds </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">console.log</span></strong><span class="koboSpan" id="kobo.100.1"> statements.</span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">proxyObject</span></strong><span class="koboSpan" id="kobo.102.1"> is a special object and when you set a value, it will log to the console before and after setting the value. </span><span class="koboSpan" id="kobo.102.2">The following is the screen</span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.103.1"> output if you run the code in the Node.js REPL (</span><a href="https://nodejs.dev/learn/how-to-use-the-nodejs-repl"><span class="koboSpan" id="kobo.104.1">https://nodejs.dev/learn/how-to-use-the-nodejs-repl</span></a><span class="koboSpan" id="kobo.105.1">):</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.106.1">&gt; ++proxyObject.count</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.107.1">start setting count</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.108.1">end setting count</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.109.1">1</span></p>
			<p><span class="koboSpan" id="kobo.110.1">Conceptually, as a proxy</span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.111.1"> can detect any mutations, we could technically use similar behavior to </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">setState</span></strong><span class="koboSpan" id="kobo.113.1"> in Zustand. </span><span class="koboSpan" id="kobo.113.2">Valtio is a library that utilizes proxies to detect state mutations.</span></p>
			<p><span class="koboSpan" id="kobo.114.1">In this section, we learned that Valtio is a library that uses the mutating update model. </span><span class="koboSpan" id="kobo.114.2">Next up, we will learn how Valtio creates immutable states with mutations.</span></p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.115.1">Utilizing proxies to detect mutations and create an immutable state</span></h1>
			<p><span class="koboSpan" id="kobo.116.1">Valtio creates immutable</span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.117.1"> objects from mutable objects with proxies. </span><span class="koboSpan" id="kobo.117.2">We call the immutable</span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.118.1"> object a </span><strong class="bold"><span class="koboSpan" id="kobo.119.1">snapshot</span></strong><span class="koboSpan" id="kobo.120.1">.</span></p>
			<p><span class="koboSpan" id="kobo.121.1">To create a mutable object</span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.122.1"> wrapped in a proxy object, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">proxy</span></strong><span class="koboSpan" id="kobo.124.1"> function exported by Valtio.</span></p>
			<p><span class="koboSpan" id="kobo.125.1">The following example is to create an object with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">count</span></strong><span class="koboSpan" id="kobo.127.1"> property:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.128.1">import { proxy } from "valtio";</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.129.1">const state = proxy({ count: 0 });</span></p>
			<p><span class="koboSpan" id="kobo.130.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">state</span></strong><span class="koboSpan" id="kobo.132.1"> object returned by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">proxy</span></strong><span class="koboSpan" id="kobo.134.1"> function is a proxy object that detects mutations. </span><span class="koboSpan" id="kobo.134.2">This allows you to create an immutable object.</span></p>
			<p><span class="koboSpan" id="kobo.135.1">To create</span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.136.1"> an immutable object, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">snapshot</span></strong><span class="koboSpan" id="kobo.138.1"> function exported by Valtio, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.139.1">import { snapshot } from "valtio";</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.140.1">const snap1 = snapshot(state);</span></p>
			<p><span class="koboSpan" id="kobo.141.1">Though the </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">state</span></strong><span class="koboSpan" id="kobo.143.1"> variable is </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">{ count: 0 }</span></strong><span class="koboSpan" id="kobo.145.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">snap1</span></strong><span class="koboSpan" id="kobo.147.1"> variable is </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">{ count: 0 }</span></strong><span class="koboSpan" id="kobo.149.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">state</span></strong><span class="koboSpan" id="kobo.151.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">snap1</span></strong><span class="koboSpan" id="kobo.153.1"> have different references. </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">state</span></strong><span class="koboSpan" id="kobo.155.1"> is a mutable object wrapped in a proxy, whereas </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">snap1</span></strong><span class="koboSpan" id="kobo.157.1"> is an immutable</span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.158.1"> object frozen with </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">Object.freeze</span></strong><span class="koboSpan" id="kobo.160.1"> (</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze"><span class="koboSpan" id="kobo.161.1">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze</span></a><span class="koboSpan" id="kobo.162.1">).</span></p>
			<p><span class="koboSpan" id="kobo.163.1">Let's see how snapshots work. </span><span class="koboSpan" id="kobo.163.2">We mutate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">state</span></strong><span class="koboSpan" id="kobo.165.1"> object and create another snapshot, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.166.1">++state.count;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.167.1">const snap2 = snapshot(state);</span></p>
			<p><span class="koboSpan" id="kobo.168.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">state</span></strong><span class="koboSpan" id="kobo.170.1"> variable is </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">{ count: 1 }</span></strong><span class="koboSpan" id="kobo.172.1"> and has the same reference as before. </span><span class="koboSpan" id="kobo.172.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">snap2</span></strong><span class="koboSpan" id="kobo.174.1"> variable is </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">{ count: 1 }</span></strong><span class="koboSpan" id="kobo.176.1"> and has a new reference. </span><span class="koboSpan" id="kobo.176.2">Because </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">snap1</span></strong><span class="koboSpan" id="kobo.178.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">snap2</span></strong><span class="koboSpan" id="kobo.180.1"> are immutable, we can check the equality with </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">snap1 === snap2</span></strong><span class="koboSpan" id="kobo.182.1">, and know whether anything in the objects differs.</span></p>
			<p><span class="koboSpan" id="kobo.183.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">proxy</span></strong><span class="koboSpan" id="kobo.185.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">snapshot</span></strong><span class="koboSpan" id="kobo.187.1"> functions</span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.188.1"> work for nested objects and optimize snapshot creation. </span><span class="koboSpan" id="kobo.188.2">That means</span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.189.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">snapshot</span></strong><span class="koboSpan" id="kobo.191.1"> function will create a new snapshot only if necessary, that is, when any of its properties are changed. </span><span class="koboSpan" id="kobo.191.2">Let's look at another example. </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">state2</span></strong><span class="koboSpan" id="kobo.193.1"> has two nested </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">c</span></strong><span class="koboSpan" id="kobo.195.1"> properties:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.196.1">const state2 = proxy({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.197.1">  obj1: { c: 0 },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.198.1">  obj2: { c: 0 },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.199.1">});</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.200.1">const snap21 = snapshot(state2)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.201.1">++state2.obj.c;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.202.1">const snap22 = snapshot(state2)</span></p>
			<p><span class="koboSpan" id="kobo.203.1">In this case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">snap21</span></strong><span class="koboSpan" id="kobo.205.1"> variable is </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">{ obj1: { c: 0 }, obj2: { c: 0 } }</span></strong><span class="koboSpan" id="kobo.207.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">snap22</span></strong><span class="koboSpan" id="kobo.209.1"> variable is </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">{ obj1: { c: 1 }, obj2: { c: 0 } }</span></strong><span class="koboSpan" id="kobo.211.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">snap21</span></strong><span class="koboSpan" id="kobo.213.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">snap22</span></strong><span class="koboSpan" id="kobo.215.1"> have difference references, hence </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">snap21 !== snap22</span></strong><span class="koboSpan" id="kobo.217.1"> holds. </span></p>
			<p><span class="koboSpan" id="kobo.218.1">How about nested objects? </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">snap21.obj1</span></strong><span class="koboSpan" id="kobo.220.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">snap22.obj1</span></strong><span class="koboSpan" id="kobo.222.1"> are different, but </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">snap21.obj2</span></strong><span class="koboSpan" id="kobo.224.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">snap22.obj2</span></strong><span class="koboSpan" id="kobo.226.1"> are the same. </span><span class="koboSpan" id="kobo.226.2">This is because the value of the internal </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">c</span></strong><span class="koboSpan" id="kobo.228.1"> property of </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">obj2</span></strong><span class="koboSpan" id="kobo.230.1"> isn't changed. </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">obj2</span></strong><span class="koboSpan" id="kobo.232.1"> doesn't need to be changed, hence </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">snap21.obj2 === snap22.obj2</span></strong><span class="koboSpan" id="kobo.234.1"> holds.</span></p>
			<p><span class="koboSpan" id="kobo.235.1">This snapshot optimization is an important feature. </span><span class="koboSpan" id="kobo.235.2">The fact that </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">snap21.obj2</span></strong><span class="koboSpan" id="kobo.237.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">snap22.obj2</span></strong><span class="koboSpan" id="kobo.239.1"> have the same reference means they share memory. </span><span class="koboSpan" id="kobo.239.2">Valtio creates snapshots only if necessary, optimizing memory usage. </span><span class="koboSpan" id="kobo.239.3">This optimization can be done in Zustand, but it's the developer's responsibility to properly create new immutable states. </span><span class="koboSpan" id="kobo.239.4">In contrast, Valtio does the optimization behind the scenes. </span><span class="koboSpan" id="kobo.239.5">In Valtio, developers are free from the responsibility of creating new immutable states.</span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.240.1">Important Note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.241.1">Valtio's optimization</span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.242.1"> is based on caching with a previous snapshot. </span><span class="koboSpan" id="kobo.242.2">In other words, the cache size is 1. </span><span class="koboSpan" id="kobo.242.3">If we increment the count with </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">++state.count</span></strong><span class="koboSpan" id="kobo.244.1"> and then decrement it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">--state.count</span></strong><span class="koboSpan" id="kobo.246.1">, a new snapshot will be created.</span></p>
			<p><span class="koboSpan" id="kobo.247.1">In this section, we learned</span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.248.1"> how Valtio creates immutable</span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.249.1"> state "snapshots" automatically. </span><span class="koboSpan" id="kobo.249.2">Next up, we will learn about Valtio's hooks for React.</span></p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.250.1">Using proxies to optimize re-renders</span></h1>
			<p><span class="koboSpan" id="kobo.251.1">Valtio uses proxies to optimize</span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.252.1"> re-renders, as well as detecting</span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.253.1"> mutations. </span><span class="koboSpan" id="kobo.253.2">This is the pattern of optimizing re-renders we learned about in the </span><em class="italic"><span class="koboSpan" id="kobo.254.1">Detecting property access</span></em><span class="koboSpan" id="kobo.255.1"> section of </span><a href="B17780_06_Final_VK_ePub.xhtml#_idTextAnchor080"><em class="italic"><span class="koboSpan" id="kobo.256.1">Chapter 6</span></em></a><span class="koboSpan" id="kobo.257.1">, </span><em class="italic"><span class="koboSpan" id="kobo.258.1">Introducing Global State Libraries</span></em><span class="koboSpan" id="kobo.259.1">.</span></p>
			<p><span class="koboSpan" id="kobo.260.1">Let's learn about the usage and behavior of Valtio hooks with a counter app. </span><span class="koboSpan" id="kobo.260.2">The hook is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">useSnapshot</span></strong><span class="koboSpan" id="kobo.262.1">. </span><span class="koboSpan" id="kobo.262.2">The implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">useSnapshot</span></strong><span class="koboSpan" id="kobo.264.1"> is based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">snapshot</span></strong><span class="koboSpan" id="kobo.266.1"> function and another proxy to wrap it. </span><span class="koboSpan" id="kobo.266.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">snapshot</span></strong><span class="koboSpan" id="kobo.268.1"> proxy has a different purpose from the proxy used in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">proxy</span></strong><span class="koboSpan" id="kobo.270.1"> function. </span><span class="koboSpan" id="kobo.270.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">snapshot</span></strong><span class="koboSpan" id="kobo.272.1"> proxy is used to detect the property access of a snapshot object. </span><span class="koboSpan" id="kobo.272.2">We will see how render optimization works, thanks to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">snapshot</span></strong><span class="koboSpan" id="kobo.274.1"> proxy.</span></p>
			<p><span class="koboSpan" id="kobo.275.1">We start with importing functions from Valtio to create a counter app:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.276.1">import { proxy, useSnapshot } from "valtio";</span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">proxy</span></strong><span class="koboSpan" id="kobo.278.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">useSnapshot</span></strong><span class="koboSpan" id="kobo.280.1"> are two main functions provided by Valtio and they cover most use cases.</span></p>
			<p><span class="koboSpan" id="kobo.281.1">We then create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">state</span></strong><span class="koboSpan" id="kobo.283.1"> object with </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">proxy</span></strong><span class="koboSpan" id="kobo.285.1">. </span><span class="koboSpan" id="kobo.285.2">In our counter app, there are two counts – </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">count1</span></strong><span class="koboSpan" id="kobo.287.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">count2</span></strong><span class="koboSpan" id="kobo.289.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.290.1">const state = proxy({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.291.1">  count1: 0,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.292.1">  count2: 0,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.293.1">});</span></p>
			<p><span class="koboSpan" id="kobo.294.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">proxy</span></strong><span class="koboSpan" id="kobo.296.1"> function takes an initial</span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.297.1"> object and returns a new proxy</span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.298.1"> object. </span><span class="koboSpan" id="kobo.298.2">We can mutate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">state</span></strong><span class="koboSpan" id="kobo.300.1"> object as we like.</span></p>
			<p><span class="koboSpan" id="kobo.301.1">Next, we define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">Counter1</span></strong><span class="koboSpan" id="kobo.303.1"> component, which uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">state</span></strong><span class="koboSpan" id="kobo.305.1"> object and shows the </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">count1</span></strong><span class="koboSpan" id="kobo.307.1"> property:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.308.1">const Counter1 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.309.1">  const snap = useSnapshot(state);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.310.1">  const inc = () =&gt; ++state.count1;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.311.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.312.1">    &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.313.1">      {snap.count1} &lt;button onClick={inc}&gt;+1&lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.314.1">    &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.315.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.316.1">};</span></p>
			<p><span class="koboSpan" id="kobo.317.1">It's our convention to set the name of the return value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">useSnapshot</span></strong><span class="koboSpan" id="kobo.319.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">name</span></strong><span class="koboSpan" id="kobo.321.1">. </span><span class="koboSpan" id="kobo.321.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">inc</span></strong><span class="koboSpan" id="kobo.323.1"> action is a function to mutate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">state</span></strong><span class="koboSpan" id="kobo.325.1"> object. </span><span class="koboSpan" id="kobo.325.2">We mutate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">state</span></strong><span class="koboSpan" id="kobo.327.1"> proxy object; </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">snap</span></strong><span class="koboSpan" id="kobo.329.1"> is only to read. </span><span class="koboSpan" id="kobo.329.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">snap</span></strong><span class="koboSpan" id="kobo.331.1"> object</span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.332.1"> is frozen with </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">Object.freeze</span></strong><span class="koboSpan" id="kobo.334.1"> (</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze"><span class="koboSpan" id="kobo.335.1">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze</span></a><span class="koboSpan" id="kobo.336.1">) and it can't be mutated technically. </span><span class="koboSpan" id="kobo.336.2">Without </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">Object.freeze</span></strong><span class="koboSpan" id="kobo.338.1">, JavaScript objects are always mutable and we can only treat it as immutable by convention. </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">snap.count1</span></strong><span class="koboSpan" id="kobo.340.1"> is accessing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">count1</span></strong><span class="koboSpan" id="kobo.342.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">state</span></strong><span class="koboSpan" id="kobo.344.1"> object. </span><span class="koboSpan" id="kobo.344.2">The access is detected by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">useSnapshot</span></strong><span class="koboSpan" id="kobo.346.1"> hook as tracking information, and based</span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.347.1"> on the tracking</span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.348.1"> information, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">useSnapshot</span></strong><span class="koboSpan" id="kobo.350.1"> hook triggers re-renders only when necessary.</span></p>
			<p><span class="koboSpan" id="kobo.351.1">We define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">Counter2</span></strong><span class="koboSpan" id="kobo.353.1"> component likewise:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.354.1">const Counter2 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.355.1">  const snap = useSnapshot(state);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.356.1">  const inc = () =&gt; ++state.count2;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.357.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.358.1">    &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.359.1">      {snap.count2} &lt;button onClick={inc}&gt;+1&lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.360.1">    &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.361.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.362.1">};</span></p>
			<p><span class="koboSpan" id="kobo.363.1">The difference from </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">Counter1</span></strong><span class="koboSpan" id="kobo.365.1"> is it uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">count2</span></strong><span class="koboSpan" id="kobo.367.1"> property instead of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">count1</span></strong><span class="koboSpan" id="kobo.369.1"> property. </span><span class="koboSpan" id="kobo.369.2">If we want to define a shared component, we can define a single component and take the property name in </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">props</span></strong><span class="koboSpan" id="kobo.371.1">.</span></p>
			<p><span class="koboSpan" id="kobo.372.1">Finally, we define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">App</span></strong><span class="koboSpan" id="kobo.374.1"> component. </span><span class="koboSpan" id="kobo.374.2">As we don't use Context, there are no providers:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.375.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.376.1">  &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.377.1">    &lt;div&gt;&lt;Counter1 /&gt;&lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.378.1">    &lt;div&gt;&lt;Counter2 /&gt;&lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.379.1">  &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.380.1">);</span></p>
			<p><span class="koboSpan" id="kobo.381.1">How does this app work? </span><span class="koboSpan" id="kobo.381.2">On the initial render, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">state</span></strong><span class="koboSpan" id="kobo.383.1"> object is </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">{ count1: 0, count2: 0 }</span></strong><span class="koboSpan" id="kobo.385.1"> and so is its snapshot object. </span><span class="koboSpan" id="kobo.385.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">Counter1</span></strong><span class="koboSpan" id="kobo.387.1"> component accesses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">count1</span></strong><span class="koboSpan" id="kobo.389.1"> property of the snapshot object and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">Counter2</span></strong><span class="koboSpan" id="kobo.391.1"> component accesses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">count2</span></strong><span class="koboSpan" id="kobo.393.1"> property of the snapshot object. </span><span class="koboSpan" id="kobo.393.2">Each </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">useSnapshot</span></strong><span class="koboSpan" id="kobo.395.1"> hook knows and remembers tracking</span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.396.1"> information. </span><span class="koboSpan" id="kobo.396.2">The tracking information represents</span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.397.1"> which property is accessed.</span></p>
			<p><span class="koboSpan" id="kobo.398.1">When we click the button in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">Counter1</span></strong><span class="koboSpan" id="kobo.400.1"> component (the first button in </span><em class="italic"><span class="koboSpan" id="kobo.401.1">Figure 9.1</span></em><span class="koboSpan" id="kobo.402.1">), it increments the </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">count1</span></strong><span class="koboSpan" id="kobo.404.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">state</span></strong><span class="koboSpan" id="kobo.406.1"> object:</span></p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<span class="koboSpan" id="kobo.407.1"><img src="image/Figure_9.01_B17780.jpg" alt="Figure 9.1 – First screenshot of the counter app "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.408.1">Figure 9.1 – First screenshot of the counter app</span></p>
			<p><span class="koboSpan" id="kobo.409.1">Thus, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">state</span></strong><span class="koboSpan" id="kobo.411.1"> object becomes </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">{ count1: 1, count2: 0 }</span></strong><span class="koboSpan" id="kobo.413.1">. </span><span class="koboSpan" id="kobo.413.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">Counter1</span></strong><span class="koboSpan" id="kobo.415.1"> component re-renders with the new number </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">1</span></strong><span class="koboSpan" id="kobo.417.1">. </span><span class="koboSpan" id="kobo.417.2">However, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">Counter2</span></strong><span class="koboSpan" id="kobo.419.1"> component doesn't re-render, because </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">count2</span></strong><span class="koboSpan" id="kobo.421.1"> is still </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">0</span></strong><span class="koboSpan" id="kobo.423.1"> and not changed (</span><em class="italic"><span class="koboSpan" id="kobo.424.1">Figure 9.2</span></em><span class="koboSpan" id="kobo.425.1">):</span></p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<span class="koboSpan" id="kobo.426.1"><img src="image/Figure_9.02_B17780.jpg" alt="Figure 9.2 – Second screenshot of the counter app "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.427.1">Figure 9.2 – Second screenshot of the counter app</span></p>
			<p><span class="koboSpan" id="kobo.428.1">Re-renders are optimized with tracking information.</span></p>
			<p><span class="koboSpan" id="kobo.429.1">In our counter app, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">state</span></strong><span class="koboSpan" id="kobo.431.1"> object</span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.432.1"> is simple</span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.433.1"> with two properties with number values. </span><span class="koboSpan" id="kobo.433.2">Valtio supports</span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.434.1"> nested objects and arrays. </span><span class="koboSpan" id="kobo.434.2">A contrived example is the following:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.435.1">const contrivedState = proxy({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.436.1">  num: 123,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.437.1">  str: "hello",</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.438.1">  arr: [1, 2, 3],</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.439.1">  nestedObject: { foo: "bar" },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.440.1">  objectArray: [{ a: 1 }, { b: 2 }],</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.441.1">});</span></p>
			<p><span class="koboSpan" id="kobo.442.1">Basically, any objects containing plain objects and arrays are fully supported even though they are nested deeply. </span><span class="koboSpan" id="kobo.442.2">For more information, please refer to the project site: </span><a href="https://github.com/pmndrs/valtio"><span class="koboSpan" id="kobo.443.1">https://github.com/pmndrs/valtio</span></a><span class="koboSpan" id="kobo.444.1">.</span></p>
			<p><span class="koboSpan" id="kobo.445.1">In this section, we learned how Valtio optimizes re-renders with snapshots and proxies. </span><span class="koboSpan" id="kobo.445.2">In the next section, we will learn how to structure an app with an example.</span></p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.446.1">Creating small application code</span></h1>
			<p><span class="koboSpan" id="kobo.447.1">We will learn how</span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.448.1"> to create a small app. </span><span class="koboSpan" id="kobo.448.2">Our example app is a to-do app. </span><span class="koboSpan" id="kobo.448.3">Valtio is unopinionated about how to structure apps. </span><span class="koboSpan" id="kobo.448.4">This is one of the typical patterns.</span></p>
			<p><span class="koboSpan" id="kobo.449.1">Let's look at how a to-do app can be structured. </span><span class="koboSpan" id="kobo.449.2">First, we define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">Todo</span></strong><span class="koboSpan" id="kobo.451.1"> type:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.452.1">type Todo = {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.453.1">  id: string;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.454.1">  title: string;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.455.1">  done: boolean;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.456.1">};</span></p>
			<p><span class="koboSpan" id="kobo.457.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">Todo</span></strong><span class="koboSpan" id="kobo.459.1"> item has an </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">id</span></strong><span class="koboSpan" id="kobo.461.1"> string value, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">title</span></strong><span class="koboSpan" id="kobo.463.1"> string value, and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">done</span></strong><span class="koboSpan" id="kobo.465.1"> Boolean value.</span></p>
			<p><span class="koboSpan" id="kobo.466.1">We then define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">state</span></strong><span class="koboSpan" id="kobo.468.1"> object using the defined </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">Todo</span></strong><span class="koboSpan" id="kobo.470.1"> type:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.471.1">const state = proxy&lt;{ todos: Todo[] }&gt;({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.472.1">  todos: [],</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.473.1">});</span></p>
			<p><span class="koboSpan" id="kobo.474.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">state</span></strong><span class="koboSpan" id="kobo.476.1"> object is created by wrapping an initial object with </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">proxy</span></strong><span class="koboSpan" id="kobo.478.1">.</span></p>
			<p><span class="koboSpan" id="kobo.479.1">To manipulate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">state</span></strong><span class="koboSpan" id="kobo.481.1"> object, we define some helper functions – </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">addTodo</span></strong><span class="koboSpan" id="kobo.483.1"> to add a new to-do item, </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">removeTodo</span></strong><span class="koboSpan" id="kobo.485.1"> to remove it, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">toggleTodo</span></strong><span class="koboSpan" id="kobo.487.1"> to toggle the </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">done</span></strong><span class="koboSpan" id="kobo.489.1"> status:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.490.1">const createTodo = (title: string) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.491.1">  state.todos.push({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.492.1">    id: nanoid(),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.493.1">    title,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.494.1">    done: false,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.495.1">  });</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.496.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.497.1">const removeTodo = (id: string) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.498.1">  const index = state.todos.findIndex(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.499.1">    (item) =&gt; item.id === id</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.500.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.501.1">  state.todos.splice(index, 1);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.502.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.503.1">const toggleTodo = (id: string) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.504.1">  const index = state.todos.findIndex(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.505.1">    (item) =&gt; item.id === id</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.506.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.507.1">  state.todos[index].done = !state.todos[index].done;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.508.1">};</span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">nanoid</span></strong><span class="koboSpan" id="kobo.510.1"> is a small function to generate a unique ID (</span><a href="https://www.npmjs.com/package/nanoid"><span class="koboSpan" id="kobo.511.1">https://www.npmjs.com/package/nanoid</span></a><span class="koboSpan" id="kobo.512.1">). </span><span class="koboSpan" id="kobo.512.2">Notice these three</span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.513.1"> functions are based on normal JavaScript syntax. </span><span class="koboSpan" id="kobo.513.2">They treat </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">state</span></strong><span class="koboSpan" id="kobo.515.1"> just like a normal JavaScript object. </span><span class="koboSpan" id="kobo.515.2">This is accomplished with proxies.</span></p>
			<p><span class="koboSpan" id="kobo.516.1">The following is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">TodoItem</span></strong><span class="koboSpan" id="kobo.518.1"> component, which has a checkbox toggle with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">done</span></strong><span class="koboSpan" id="kobo.520.1"> status, text</span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.521.1"> with a different style with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">done</span></strong><span class="koboSpan" id="kobo.523.1"> status, and a button to remove the item:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.524.1">const TodoItem = ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.525.1">  id,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.526.1">  title,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.527.1">  done,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.528.1">}: {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.529.1">  id: string;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.530.1">  title: string;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.531.1">  done: boolean;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.532.1">}) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.533.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.534.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.535.1">      &lt;input</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.536.1">        type="checkbox"</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.537.1">        checked={done}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.538.1">        onChange={() =&gt; toggleTodo(id)}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.539.1">      /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.540.1">      &lt;span</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.541.1">        style={{</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.542.1">          textDecoration: done ? </span><span class="koboSpan" id="kobo.542.2">"line-through" : "none",</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.543.1">        }}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.544.1">      &gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.545.1">        {title}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.546.1">      &lt;/span&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.547.1">      &lt;button onClick={() =&gt; removeTodo(id)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.548.1">        Delete</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.549.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.550.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.551.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.552.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.553.1">const MemoedTodoItem = memo(TodoItem);</span></p>
			<p><span class="koboSpan" id="kobo.554.1">Notice this component receives the </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">id</span></strong><span class="koboSpan" id="kobo.556.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">title</span></strong><span class="koboSpan" id="kobo.558.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">done</span></strong><span class="koboSpan" id="kobo.560.1"> properties separately, instead of receiving the </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">todo</span></strong><span class="koboSpan" id="kobo.562.1"> object. </span><span class="koboSpan" id="kobo.562.2">This is because we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">memo</span></strong><span class="koboSpan" id="kobo.564.1"> function and create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">MemoedTodoItem</span></strong><span class="koboSpan" id="kobo.566.1"> component. </span><span class="koboSpan" id="kobo.566.2">Our state usage tracking detects property access, and if we pass an object to a memoed</span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.567.1"> component, the property access is omitted.</span></p>
			<p><span class="koboSpan" id="kobo.568.1">To use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">MemoedTodoItem</span></strong><span class="koboSpan" id="kobo.570.1"> component, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">TodoList</span></strong><span class="koboSpan" id="kobo.572.1"> component is defined with </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">useSnapshot</span></strong><span class="koboSpan" id="kobo.574.1">, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.575.1">const TodoList = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.576.1">  const { todos } = useSnapshot(state);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.577.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.578.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.579.1">      {todos.map((todo) =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.580.1">        &lt;MemoedTodoItem</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.581.1">          key={todo.id}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.582.1">          id={todo.id}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.583.1">          title={todo.title}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.584.1">          done={todo.done}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.585.1">        /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.586.1">      ))}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.587.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.588.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.589.1">};</span></p>
			<p><span class="koboSpan" id="kobo.590.1">This component takes </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">todos</span></strong><span class="koboSpan" id="kobo.592.1"> from the result of </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">useSnapshot</span></strong><span class="koboSpan" id="kobo.594.1"> and accesses all properties in objects in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">todos</span></strong><span class="koboSpan" id="kobo.596.1"> array. </span><span class="koboSpan" id="kobo.596.2">Hence, </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">useSnapshot</span></strong><span class="koboSpan" id="kobo.598.1"> triggers a re-render if any part of </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">todos</span></strong><span class="koboSpan" id="kobo.600.1"> is changed. </span><span class="koboSpan" id="kobo.600.2">It's not a big issue and this is a valid pattern because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">MemoedTodoItem</span></strong><span class="koboSpan" id="kobo.602.1"> component won't re-render unless </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">id</span></strong><span class="koboSpan" id="kobo.604.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">title</span></strong><span class="koboSpan" id="kobo.606.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">done</span></strong><span class="koboSpan" id="kobo.608.1"> is changed. </span><span class="koboSpan" id="kobo.608.2">We will learn about another pattern later in this section.</span></p>
			<p><span class="koboSpan" id="kobo.609.1">To create</span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.610.1"> a new to-do item, the following is a small component that has a local state for the input field and invokes </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">createTodo</span></strong><span class="koboSpan" id="kobo.612.1"> when the </span><strong class="bold"><span class="koboSpan" id="kobo.613.1">Add</span></strong><span class="koboSpan" id="kobo.614.1"> button is clicked:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.615.1">const NewTodo = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.616.1">  const [text, setText] = useState("");</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.617.1">  const onClick = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.618.1">    createTodo(text);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.619.1">    setText("");</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.620.1">  };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.621.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.622.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.623.1">      &lt;input</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.624.1">        value={text}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.625.1">        onChange={(e) =&gt; setText(e.target.value)}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.626.1">      /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.627.1">      &lt;button onClick={onClick} disabled={!text}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.628.1">        Add</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.629.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.630.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.631.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.632.1">};</span></p>
			<p><span class="koboSpan" id="kobo.633.1">Finally, we combine the defined components in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">App</span></strong><span class="koboSpan" id="kobo.635.1"> component:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.636.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.637.1">  &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.638.1">    &lt;TodoList /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.639.1">    &lt;NewTodo /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.640.1">  &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.641.1">);</span></p>
			<p><span class="koboSpan" id="kobo.642.1">Let's look</span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.643.1"> at how this app works:</span></p>
			<ol>
				<li><span class="koboSpan" id="kobo.644.1">At first, it has only a text field and an </span><strong class="bold"><span class="koboSpan" id="kobo.645.1">Add</span></strong><span class="koboSpan" id="kobo.646.1"> button (</span><em class="italic"><span class="koboSpan" id="kobo.647.1">Figure 9.3</span></em><span class="koboSpan" id="kobo.648.1">):</span><div id="_idContainer029" class="IMG---Figure"><span class="koboSpan" id="kobo.649.1"><img src="image/Figure_9.03_B17780.jpg" alt="Figure 9.3 – First screenshot of the todos app "/></span></div><p class="figure-caption"><span class="koboSpan" id="kobo.650.1">Figure 9.3 – First screenshot of the todos app</span></p></li>
				<li><span class="koboSpan" id="kobo.651.1">If we click the </span><strong class="bold"><span class="koboSpan" id="kobo.652.1">Add</span></strong><span class="koboSpan" id="kobo.653.1"> button, a new item is added (</span><em class="italic"><span class="koboSpan" id="kobo.654.1">Figure 9.4</span></em><span class="koboSpan" id="kobo.655.1">):</span><div id="_idContainer030" class="IMG---Figure"><span class="koboSpan" id="kobo.656.1"><img src="image/Figure_9.04_B17780.jpg" alt="Figure 9.4 – Second screenshot of the todos app "/></span></div><p class="figure-caption"><span class="koboSpan" id="kobo.657.1">Figure 9.4 – Second screenshot of the todos app</span></p></li>
				<li><span class="koboSpan" id="kobo.658.1">We can add as many items as we want (</span><em class="italic"><span class="koboSpan" id="kobo.659.1">Figure 9.5</span></em><span class="koboSpan" id="kobo.660.1">):</span><div id="_idContainer031" class="IMG---Figure"><span class="koboSpan" id="kobo.661.1"><img src="image/Figure_9.05_B17780.jpg" alt="Figure 9.5 – Third screenshot of the todos app "/></span></div><p class="figure-caption"><span class="koboSpan" id="kobo.662.1">Figure 9.5 – Third screenshot of the todos app</span></p></li>
				<li><span class="koboSpan" id="kobo.663.1">Clicking a checkbox</span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.664.1"> will toggle the </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">done</span></strong><span class="koboSpan" id="kobo.666.1"> status (</span><em class="italic"><span class="koboSpan" id="kobo.667.1">Figure 9.6</span></em><span class="koboSpan" id="kobo.668.1">):</span><div id="_idContainer032" class="IMG---Figure"><span class="koboSpan" id="kobo.669.1"><img src="image/Figure_9.06_B17780.jpg" alt="Figure 9.6 – Fourth screenshot of the todos app "/></span></div><p class="figure-caption"><span class="koboSpan" id="kobo.670.1">Figure 9.6 – Fourth screenshot of the todos app</span></p></li>
				<li><span class="koboSpan" id="kobo.671.1">Clicking the </span><strong class="bold"><span class="koboSpan" id="kobo.672.1">Delete</span></strong><span class="koboSpan" id="kobo.673.1"> button will delete the item (</span><em class="italic"><span class="koboSpan" id="kobo.674.1">Figure 9.7</span></em><span class="koboSpan" id="kobo.675.1">):</span></li>
			</ol>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<span class="koboSpan" id="kobo.676.1"><img src="image/Figure_9.07_B17780.jpg" alt="Figure 9.7 – Fifth screenshot of the todos app "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.677.1">Figure 9.7 – Fifth screenshot of the todos app</span></p>
			<p><span class="koboSpan" id="kobo.678.1">The app we created</span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.679.1"> so far works pretty well. </span><span class="koboSpan" id="kobo.679.2">But there is room for improvement in terms of extra re-renders. </span><span class="koboSpan" id="kobo.679.3">When we toggle the </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">done</span></strong><span class="koboSpan" id="kobo.681.1"> state of an existing item, not only the corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">TodoItem</span></strong><span class="koboSpan" id="kobo.683.1"> component but also the </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">TodoList</span></strong><span class="koboSpan" id="kobo.685.1"> component will re-render. </span><span class="koboSpan" id="kobo.685.2">As noted, this is not a big issue as long as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">TodoList</span></strong><span class="koboSpan" id="kobo.687.1"> component itself is fairly lightweight.</span></p>
			<p><span class="koboSpan" id="kobo.688.1">We have another pattern to eliminate the extra re-render in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">TodoList</span></strong><span class="koboSpan" id="kobo.690.1"> component. </span><span class="koboSpan" id="kobo.690.2">This doesn't mean the overall performance can always be improved. </span><span class="koboSpan" id="kobo.690.3">Which approach we should take depends on the app in question.</span></p>
			<p><span class="koboSpan" id="kobo.691.1">In the new approach, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">useSnapshot</span></strong><span class="koboSpan" id="kobo.693.1"> in each </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">TodoItem</span></strong><span class="koboSpan" id="kobo.695.1"> component. </span><span class="koboSpan" id="kobo.695.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">TodoItem</span></strong><span class="koboSpan" id="kobo.697.1"> component only receives the </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">id</span></strong><span class="koboSpan" id="kobo.699.1"> property. </span><span class="koboSpan" id="kobo.699.2">The following is the modified </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">TodoItem</span></strong><span class="koboSpan" id="kobo.701.1"> component:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.702.1">const TodoItem = ({ id }: { id: string }) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.703.1">  const todoState = state.todos.find(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.704.1">    (todo) =&gt; todo.id === id</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.705.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.706.1">  if (!todoState) {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.707.1">    throw new Error("invalid todo id");</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.708.1">  }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.709.1">  const { title, done } = useSnapshot(todoState);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.710.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.711.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.712.1">      &lt;input</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.713.1">        type="checkbox"</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.714.1">        checked={done}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.715.1">        onChange={() =&gt; toggleTodo(id)}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.716.1">      /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.717.1">      &lt;span</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.718.1">        style={{</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.719.1">          textDecoration: done ? </span><span class="koboSpan" id="kobo.719.2">"line-through" : "none",</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.720.1">        }}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.721.1">      &gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.722.1">        {title}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.723.1">      &lt;/span&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.724.1">      &lt;button onClick={() =&gt; removeTodo(id)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.725.1">        Delete</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.726.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.727.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.728.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.729.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.730.1">const MemoedTodoItem = memo(TodoItem);</span></p>
			<p><span class="koboSpan" id="kobo.731.1">Based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">id</span></strong><span class="koboSpan" id="kobo.733.1"> property, it finds </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">todoState</span></strong><span class="koboSpan" id="kobo.735.1">, uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">useSnapshot</span></strong><span class="koboSpan" id="kobo.737.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">todoState</span></strong><span class="koboSpan" id="kobo.739.1">, and gets</span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.740.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">title</span></strong><span class="koboSpan" id="kobo.742.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">done</span></strong><span class="koboSpan" id="kobo.744.1"> properties. </span><span class="koboSpan" id="kobo.744.2">This component will re-render only if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">id</span></strong><span class="koboSpan" id="kobo.746.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">title</span></strong><span class="koboSpan" id="kobo.748.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">done</span></strong><span class="koboSpan" id="kobo.750.1"> properties are changed.</span></p>
			<p><span class="koboSpan" id="kobo.751.1">Now, let's look at the modified </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">TodoList</span></strong><span class="koboSpan" id="kobo.753.1"> component. </span><span class="koboSpan" id="kobo.753.2">Unlike the previous one, it only needs to pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">id</span></strong><span class="koboSpan" id="kobo.755.1"> properties:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.756.1">const TodoList = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.757.1">  const { todos } = useSnapshot(state);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.758.1">  const todoIds = todos.map((todo) =&gt; todo.id);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.759.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.760.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.761.1">      {todoIds.map((todoId) =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.762.1">        &lt;MemoedTodoItem key={todoId} id={todoId} /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.763.1">      ))}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.764.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.765.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.766.1">};</span></p>
			<p><span class="koboSpan" id="kobo.767.1">So, </span><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">todoIds</span></strong><span class="koboSpan" id="kobo.769.1"> is created from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">id</span></strong><span class="koboSpan" id="kobo.771.1"> property of each </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">todo</span></strong><span class="koboSpan" id="kobo.773.1"> object. </span><span class="koboSpan" id="kobo.773.2">This component will only re-render if the order of </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">id</span></strong><span class="koboSpan" id="kobo.775.1"> is changed, or if some </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">id</span></strong><span class="koboSpan" id="kobo.777.1"> is added or removed. </span><span class="koboSpan" id="kobo.777.2">If only the </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">done</span></strong><span class="koboSpan" id="kobo.779.1"> status</span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.780.1"> of an existing item is changed, this component won't re-render. </span><span class="koboSpan" id="kobo.780.2">Hence, the extra re-render is eliminated.</span></p>
			<p><span class="koboSpan" id="kobo.781.1">In medium-sized apps, the change in the two approaches is subtle in terms of performance. </span><span class="koboSpan" id="kobo.781.2">The two approaches are more meaningful for different coding patterns. </span><span class="koboSpan" id="kobo.781.3">Developers can choose the one that is more comfortable with their mental model.</span></p>
			<p><span class="koboSpan" id="kobo.782.1">In this section, we learned about </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">useSnapshot</span></strong><span class="koboSpan" id="kobo.784.1"> use cases with a small app. </span><span class="koboSpan" id="kobo.784.2">Next up, we will discuss some pros and cons of this library and the approach in general.</span></p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.785.1">The pros and cons of this approach</span></h1>
			<p><span class="koboSpan" id="kobo.786.1">We have seen how Valtio</span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.787.1"> works and one question is when we should use it</span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.788.1"> and when we should not.</span></p>
			<p><span class="koboSpan" id="kobo.789.1">One big aspect</span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.790.1"> is the mental model. </span><span class="koboSpan" id="kobo.790.2">We</span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.791.1"> have two state-updating models. </span><span class="koboSpan" id="kobo.791.2">One is for immutable updates and the other for mutable updates. </span><span class="koboSpan" id="kobo.791.3">While JavaScript itself allows mutable updates, React is built around immutable states. </span><span class="koboSpan" id="kobo.791.4">Hence, if we mix the two models, we should be careful not to confuse ourselves. </span><span class="koboSpan" id="kobo.791.5">One possible solution would be to clearly separate the Valtio state and React state so that the mental model switch is reasonable. </span><span class="koboSpan" id="kobo.791.6">If it works, Valtio can fit in. </span><span class="koboSpan" id="kobo.791.7">Otherwise, maybe stick with immutable updates.</span></p>
			<p><span class="koboSpan" id="kobo.792.1">The major benefit of mutable updates</span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.793.1"> is we can use native JavaScript functions.</span></p>
			<p><span class="koboSpan" id="kobo.794.1">For example, removing</span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.795.1"> an item from an array with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">index</span></strong><span class="koboSpan" id="kobo.797.1"> value can be written as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.798.1">array.splice(index, 1)</span></p>
			<p><span class="koboSpan" id="kobo.799.1">In immutable updates, this is not so easy. </span><span class="koboSpan" id="kobo.799.2">For example, it can be written with </span><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">slice</span></strong><span class="koboSpan" id="kobo.801.1">, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.802.1">[...array.slice(0, index), ...array.slice(index + 1)]</span></p>
			<p><span class="koboSpan" id="kobo.803.1">Another example is to change the value in a deeply nested object. </span><span class="koboSpan" id="kobo.803.2">It can be done in mutable updates as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.804.1">state.a.b.c.text = "hello";</span></p>
			<p><span class="koboSpan" id="kobo.805.1">In immutable </span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.806.1">updates, it has to be something</span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.807.1"> like the following:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.808.1">{</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.809.1">  ...state,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.810.1">  a: {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.811.1">    ...state.a,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.812.1">    b: {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.813.1">      ...state.a.b,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.814.1">      c: {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.815.1">        ...state.a.b.c,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.816.1">        text: "hello",</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.817.1">      },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.818.1">    },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.819.1">  },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.820.1">}</span></p>
			<p><span class="koboSpan" id="kobo.821.1">This is not very pleasant to write. </span><span class="koboSpan" id="kobo.821.2">Valtio helps to reduce application code with mutable updates.</span></p>
			<p><span class="koboSpan" id="kobo.822.1">Valtio also helps to reduce application</span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.823.1"> code with proxy-based render optimization.</span></p>
			<p><span class="koboSpan" id="kobo.824.1">Suppose we have a state with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">count</span></strong><span class="koboSpan" id="kobo.826.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">text</span></strong><span class="koboSpan" id="kobo.828.1"> properties, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.829.1">const state = proxy({ count: 0, text: "hello" });</span></p>
			<p><span class="koboSpan" id="kobo.830.1">If we use only </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">count</span></strong><span class="koboSpan" id="kobo.832.1"> in a component, we can write the following in Valtio:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.833.1">const Component = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.834.1">  const { count } = useSnapshot(state);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.835.1">  return &lt;&gt;{count}&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.836.1">};</span></p>
			<p><span class="koboSpan" id="kobo.837.1">In comparison, with Zustand, this will be something like the following:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.838.1">const Component = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.839.1">  const count = useStore((state) =&gt; state.count);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.840.1">  return &lt;&gt;{count}&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.841.1">};</span></p>
			<p><span class="koboSpan" id="kobo.842.1">The difference is trivial, but we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">count</span></strong><span class="koboSpan" id="kobo.844.1"> in two places.</span></p>
			<p><span class="koboSpan" id="kobo.845.1">Let's look at a contrived scenario. </span><span class="koboSpan" id="kobo.845.2">Suppose we want to show the </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">text</span></strong><span class="koboSpan" id="kobo.847.1"> value if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">showText</span></strong><span class="koboSpan" id="kobo.849.1"> property is truthy. </span><span class="koboSpan" id="kobo.849.2">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">useSnapshot</span></strong><span class="koboSpan" id="kobo.851.1">, it can be done as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.852.1">const Component = ({ showText }) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.853.1">  const snap = useSnapshot(state);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.854.1">  return &lt;&gt;{snap.count} {showText ? </span><span class="koboSpan" id="kobo.854.2">snap.text : ""}&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.855.1">};</span></p>
			<p><span class="koboSpan" id="kobo.856.1">Implementing the same behavior with selector-based hooks is tough. </span><span class="koboSpan" id="kobo.856.2">One solution is to use a hook twice. </span><span class="koboSpan" id="kobo.856.3">With Zustand, it will be like the following:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.857.1">const Component = ({ showText }) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.858.1">  const count = useStore((state) =&gt; state.count);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.859.1">  const text = useStore(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.860.1">    (state) =&gt; showText ? </span><span class="koboSpan" id="kobo.860.2">state.text : ""</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.861.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.862.1">  return &lt;&gt;{count} {text}&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.863.1">};</span></p>
			<p><span class="koboSpan" id="kobo.864.1">This means if we have more conditions, we need more hooks.</span></p>
			<p><span class="koboSpan" id="kobo.865.1">On the other hand, a disadvantage</span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.866.1"> of proxy-based render optimization can be less predictability. </span><span class="koboSpan" id="kobo.866.2">Proxies take care of render optimization behind the scenes and sometimes it's hard to debug the behavior. </span><span class="koboSpan" id="kobo.866.3">Some may prefer explicit selector-based hooks.</span></p>
			<p><span class="koboSpan" id="kobo.867.1">In summary, there's no one-size-fits-all solution. </span><span class="koboSpan" id="kobo.867.2">It's up to developers to choose the solution that fits their needs.</span></p>
			<p><span class="koboSpan" id="kobo.868.1">In this section, we discussed the approach taken in the Valtio library.</span></p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.869.1">Summary</span></h1>
			<p><span class="koboSpan" id="kobo.870.1">In this chapter, we learned about a library called Valtio. </span><span class="koboSpan" id="kobo.870.2">It utilizes proxies extensively. </span><span class="koboSpan" id="kobo.870.3">We've seen examples and learned how it can be used. </span><span class="koboSpan" id="kobo.870.4">It allows mutating state, which feels like using normal JavaScript objects, and the proxy-based render optimization helps reduce application code. </span><span class="koboSpan" id="kobo.870.5">It depends on developers' requirements whether this approach is a good choice.</span></p>
			<p><span class="koboSpan" id="kobo.871.1">In the next chapter, we will learn about another library, called React Tracked, which is a library that is based on Context and has proxy-based render optimization like Valtio.</span></p>
		</div>
	</body></html>